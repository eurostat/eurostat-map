(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["eurostatmap"] = factory();
	else
		root["eurostatmap"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* STYLING OF NUTS REGIONS AND BOUNDARIES */
/* Default region fill */
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    fill: #e1e1e1;
}

.em-nutsrg,
.em-cntrg,
.em-grid-cell,
#em-user-regions {
    cursor: pointer;
}

/*  boundaries stroke-width */
.em-bn-0 {
    stroke: none;
}
.em-bn-1,
.em-bn-2,
.em-bn-3,
/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-bn-co {
    stroke-width: 0.2;
}

/* all boudnaries and regions linecap/linejoin */
#em-nutsbn,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-d,
.em-bn-co,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* national boundaries */
.em-cntbn {
    stroke: #000;
    stroke-width: 0.6px;
}

/* NUTS boundaries stroke color */
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'] {
    stroke: #696969;
}

/* coastal boundaries */
.em-bn-co {
    stroke: white;
}

/* kosovo */
.em-kosovo-bn {
    stroke: #000;
    stroke-width: 0.15;
}

/* disputed */
.em-bn-d {
    stroke: #000;
    stroke-width: 0.2;
}

/* dont fill certain elements */
.em-frame,
.em-graticule,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-d,
.em-bn-co {
    fill: none;
}

/* target non cc/eu/efta borders */
/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {
    stroke-width: 0;
} */
`, "",{"version":3,"sources":["webpack://./src/css/NUTS.css"],"names":[],"mappings":"AAAA,2CAA2C;AAC3C,wBAAwB;AACxB;;;IAGI,aAAa;AACjB;;AAEA;;;;IAII,eAAe;AACnB;;AAEA,6BAA6B;AAC7B;IACI,YAAY;AAChB;AACA;;;;;;;;IAQI,iBAAiB;AACrB;;AAEA,gDAAgD;AAChD;;;;;;;;;;;;;;;IAeI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA,wBAAwB;AACxB;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA,iCAAiC;AACjC;;;;;;IAMI,eAAe;AACnB;;AAEA,uBAAuB;AACvB;IACI,aAAa;AACjB;;AAEA,WAAW;AACX;IACI,YAAY;IACZ,kBAAkB;AACtB;;AAEA,aAAa;AACb;IACI,YAAY;IACZ,iBAAiB;AACrB;;AAEA,+BAA+B;AAC/B;;;;;;;;;;IAUI,UAAU;AACd;;AAEA,kCAAkC;AAClC;;GAEG","sourcesContent":["/* STYLING OF NUTS REGIONS AND BOUNDARIES */\r\n/* Default region fill */\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    fill: #e1e1e1;\r\n}\r\n\r\n.em-nutsrg,\r\n.em-cntrg,\r\n.em-grid-cell,\r\n#em-user-regions {\r\n    cursor: pointer;\r\n}\r\n\r\n/*  boundaries stroke-width */\r\n.em-bn-0 {\r\n    stroke: none;\r\n}\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-bn-co {\r\n    stroke-width: 0.2;\r\n}\r\n\r\n/* all boudnaries and regions linecap/linejoin */\r\n#em-nutsbn,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-d,\r\n.em-bn-co,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n/* national boundaries */\r\n.em-cntbn {\r\n    stroke: #000;\r\n    stroke-width: 0.6px;\r\n}\r\n\r\n/* NUTS boundaries stroke color */\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'] {\r\n    stroke: #696969;\r\n}\r\n\r\n/* coastal boundaries */\r\n.em-bn-co {\r\n    stroke: white;\r\n}\r\n\r\n/* kosovo */\r\n.em-kosovo-bn {\r\n    stroke: #000;\r\n    stroke-width: 0.15;\r\n}\r\n\r\n/* disputed */\r\n.em-bn-d {\r\n    stroke: #000;\r\n    stroke-width: 0.2;\r\n}\r\n\r\n/* dont fill certain elements */\r\n.em-frame,\r\n.em-graticule,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-d,\r\n.em-bn-co {\r\n    fill: none;\r\n}\r\n\r\n/* target non cc/eu/efta borders */\r\n/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {\r\n    stroke-width: 0;\r\n} */\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-annotation-group {
    /* pointer-events: none; */
}
`, "",{"version":3,"sources":["webpack://./src/css/annotations.css"],"names":[],"mappings":"AAAA;IACI,0BAA0B;AAC9B","sourcesContent":[".em-annotation-group {\r\n    /* pointer-events: none; */\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/index.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./map.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./tooltip.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./legend.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./labels.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./annotations.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./NUTS.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./world.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css");
// Imports









var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `
`, "",{"version":3,"sources":[],"names":[],"mappings":"","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/labels.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#em-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}

.em-label {
    font-size: 12px;
}
.em-label-background {
    fill: #ffffff;
    pointer-events: none;
}
.em-label-shadow {
    font-size: 12px;
    stroke-width: 2px;
    stroke: white;
}
.em-stat-label {
    opacity: 0.9;
    font-size: 13px;
    fill: #313131;
    stroke: #313131;
    stroke-width: 0.2px;
    font-weight: bold;
}
.em-stat-label-shadow {
    opacity: 0.9;
    font-size: 13px;
    stroke-width: 3.3px;
    stroke: white;
}
.em-label-cc {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-cc {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-countries {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-countries {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-seas {
    font-size: 9px;
    fill: #003399;
    stroke: #003399;
    stroke-width: 0.2px;
    letter-spacing: 3px;
}
.em-label-shadow-seas {
    font-size: 9px;
    letter-spacing: 3px;
    stroke: white;
    stroke-width: 3px;
}

.em-flow-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}
.em-flow-label {
    font-size: 13px;
    fill: black;
    font-weight: bold;
}
.em-flow-label-shadow {
    font-size: 13px;
    stroke-width: 4px;
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/labels.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;;AAEA;IACI,eAAe;AACnB;AACA;IACI,aAAa;IACb,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB;AACA;IACI,YAAY;IACZ,eAAe;IACf,aAAa;IACb,eAAe;IACf,mBAAmB;IACnB,iBAAiB;AACrB;AACA;IACI,YAAY;IACZ,eAAe;IACf,mBAAmB;IACnB,aAAa;AACjB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,cAAc;IACd,aAAa;IACb,eAAe;IACf,mBAAmB;IACnB,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;IACnB,aAAa;IACb,iBAAiB;AACrB;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;AACA;IACI,eAAe;IACf,WAAW;IACX,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB","sourcesContent":["#em-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n\r\n.em-label {\r\n    font-size: 12px;\r\n}\r\n.em-label-background {\r\n    fill: #ffffff;\r\n    pointer-events: none;\r\n}\r\n.em-label-shadow {\r\n    font-size: 12px;\r\n    stroke-width: 2px;\r\n    stroke: white;\r\n}\r\n.em-stat-label {\r\n    opacity: 0.9;\r\n    font-size: 13px;\r\n    fill: #313131;\r\n    stroke: #313131;\r\n    stroke-width: 0.2px;\r\n    font-weight: bold;\r\n}\r\n.em-stat-label-shadow {\r\n    opacity: 0.9;\r\n    font-size: 13px;\r\n    stroke-width: 3.3px;\r\n    stroke: white;\r\n}\r\n.em-label-cc {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-cc {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-countries {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-countries {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-seas {\r\n    font-size: 9px;\r\n    fill: #003399;\r\n    stroke: #003399;\r\n    stroke-width: 0.2px;\r\n    letter-spacing: 3px;\r\n}\r\n.em-label-shadow-seas {\r\n    font-size: 9px;\r\n    letter-spacing: 3px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n\r\n.em-flow-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n.em-flow-label {\r\n    font-size: 13px;\r\n    fill: black;\r\n    font-weight: bold;\r\n}\r\n.em-flow-label-shadow {\r\n    font-size: 13px;\r\n    stroke-width: 4px;\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/legend.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-legend-background {
    fill: white;
    opacity: 0.7;
    rx: 0;
    ry: 0;
    pointer-events: none;
}
.em-legend-label {
    font-size: 15px;
    stroke: none;
    fill: black;
    dominant-baseline: central;
}
.em-legend-title {
    font-size: 16px;
    fill: black;
}
.em-legend-separator {
    stroke: white;
    stroke-width: 1;
}
.em-legend-tick {
    stroke: grey;
    stroke-width: 1;
}
.em-bivariate-frame {
    fill: none;
    stroke: black;
}
.em-bivariate-nodata {
    stroke: black;
    stroke-width: 0.5;
    cursor: pointer;
}
.em-bivariate-axis-title {
    font-size: 15px;
}
.em-bivariate-nodata-label {
    font-size: 14px;
    dominant-baseline: middle;
}
.em-bivariate-tick {
    stroke: black;
    stroke-width: 1;
}
.em-bivariate-tick-label {
    text-anchor: middle;
    font-size: 12px;
}
.em-bivariate-square,
.em-legend-rect {
    cursor: pointer;
    stroke: white;
}

.em-bivariate-square:hover,
.em-legend-rect:hover {
    stroke-width: 2;
    stroke: red;
}

.em-pie-size-legend-line {
    stroke-dasharray: 2;
    stroke: grey;
}

.em-legend-diverging-line {
    stroke: black;
}
`, "",{"version":3,"sources":["webpack://./src/css/legend.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,YAAY;IACZ,KAAK;IACL,KAAK;IACL,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,YAAY;IACZ,WAAW;IACX,0BAA0B;AAC9B;AACA;IACI,eAAe;IACf,WAAW;AACf;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,YAAY;IACZ,eAAe;AACnB;AACA;IACI,UAAU;IACV,aAAa;AACjB;AACA;IACI,aAAa;IACb,iBAAiB;IACjB,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,yBAAyB;AAC7B;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,eAAe;AACnB;AACA;;IAEI,eAAe;IACf,aAAa;AACjB;;AAEA;;IAEI,eAAe;IACf,WAAW;AACf;;AAEA;IACI,mBAAmB;IACnB,YAAY;AAChB;;AAEA;IACI,aAAa;AACjB","sourcesContent":[".em-legend-background {\r\n    fill: white;\r\n    opacity: 0.7;\r\n    rx: 0;\r\n    ry: 0;\r\n    pointer-events: none;\r\n}\r\n.em-legend-label {\r\n    font-size: 15px;\r\n    stroke: none;\r\n    fill: black;\r\n    dominant-baseline: central;\r\n}\r\n.em-legend-title {\r\n    font-size: 16px;\r\n    fill: black;\r\n}\r\n.em-legend-separator {\r\n    stroke: white;\r\n    stroke-width: 1;\r\n}\r\n.em-legend-tick {\r\n    stroke: grey;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-frame {\r\n    fill: none;\r\n    stroke: black;\r\n}\r\n.em-bivariate-nodata {\r\n    stroke: black;\r\n    stroke-width: 0.5;\r\n    cursor: pointer;\r\n}\r\n.em-bivariate-axis-title {\r\n    font-size: 15px;\r\n}\r\n.em-bivariate-nodata-label {\r\n    font-size: 14px;\r\n    dominant-baseline: middle;\r\n}\r\n.em-bivariate-tick {\r\n    stroke: black;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-tick-label {\r\n    text-anchor: middle;\r\n    font-size: 12px;\r\n}\r\n.em-bivariate-square,\r\n.em-legend-rect {\r\n    cursor: pointer;\r\n    stroke: white;\r\n}\r\n\r\n.em-bivariate-square:hover,\r\n.em-legend-rect:hover {\r\n    stroke-width: 2;\r\n    stroke: red;\r\n}\r\n\r\n.em-pie-size-legend-line {\r\n    stroke-dasharray: 2;\r\n    stroke: grey;\r\n}\r\n\r\n.em-legend-diverging-line {\r\n    stroke: black;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/map.css ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* General text settings */
text {
    pointer-events: none;
}

a text {
    pointer-events: all;
}

/* Main map */
.em-map,
.em-legend {
    font-family: Arial, Helvetica, sans-serif;
}

/* Coastal margin */
#em-coast-margin {
    filter: url(#em-coastal-blur);
    stroke-linejoin: round;
    stroke-linecap: round;
    fill: none;
    stroke-width: 5;
    stroke: rgb(161, 198, 237);
}

/* Title and subtitle styling */
.em-title,
.em-inset-title {
    fill: black;
    stroke: none;
}

.em-title {
    font-size: 21px;
    font-weight: bold;
}

.em-inset-title {
    font-size: 12px;
}

.em-subtitle,
.em-inset-subtitle {
    fill: #848280;
    stroke: none;
    stroke-linejoin: round;
    paint-order: stroke;
}

.em-subtitle {
    font-size: 18px;
    font-weight: 100;
}

.em-inset-subtitle {
    font-size: 12px;
}

.em-source-pretext {
    font-size: 11px;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link {
    font-size: 11px;
    fill: #0e47cb;
    cursor: pointer;
    text-decoration: underline;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link:hover {
    fill: #082b7a;
    cursor: pointer;
    text-decoration: underline;
}

.em-frame {
    stroke-width: 0;
    stroke: grey;
}

.em-insets .em-frame {
    /* this will give a frame to inset maps */
    stroke: grey;
    stroke-width: 0.3px !important;
}

.em-sea {
    fill: white;
    /* pointer-events: none; */
}
.em-scalebar-line {
    stroke: black;
    stroke-width: 0.8px;
}
.em-scalebar-label {
    font-size: 9px;
    text-anchor: middle;
}

/* Bottom text and symbol styling */
.em-footnote {
    pointer-events: all;
    cursor: default;
    font-size: 11px;
    transform: translate(5px, -5px);
}
.em-footnote a {
    fill: #0e47cb;
    text-decoration: underline;
}
.em-footnote a:hover {
    fill: #0a328e;
}

.em-centroid {
    cursor: pointer;
}

/* Graticule styling */
.em-graticule {
    stroke: lightgray;
    stroke-width: 1;
}

.em-flow-link {
    cursor: pointer;
}
.em-flow-link-outline {
    cursor: pointer;
}
.em-flow-labels {
    font-size: 15px;
    stroke-width: 1px;
    fill: black;
    pointer-events: none;
}
.em-flow-labels-halo {
    font-size: 15px;
    stroke-width: 2px;
    fill: white;
    pointer-events: none;
}

.em-grid-rect,
.em-grid-hexagon {
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/map.css"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B;IACI,oBAAoB;AACxB;;AAEA;IACI,mBAAmB;AACvB;;AAEA,aAAa;AACb;;IAEI,yCAAyC;AAC7C;;AAEA,mBAAmB;AACnB;IACI,6BAA6B;IAC7B,sBAAsB;IACtB,qBAAqB;IACrB,UAAU;IACV,eAAe;IACf,0BAA0B;AAC9B;;AAEA,+BAA+B;AAC/B;;IAEI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,iBAAiB;AACrB;;AAEA;IACI,eAAe;AACnB;;AAEA;;IAEI,aAAa;IACb,YAAY;IACZ,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,eAAe;IACf,gBAAgB;AACpB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,gCAAgC;AACpC;AACA;IACI,eAAe;IACf,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,gCAAgC;AACpC;AACA;IACI,aAAa;IACb,eAAe;IACf,0BAA0B;AAC9B;;AAEA;IACI,eAAe;IACf,YAAY;AAChB;;AAEA;IACI,yCAAyC;IACzC,YAAY;IACZ,8BAA8B;AAClC;;AAEA;IACI,WAAW;IACX,0BAA0B;AAC9B;AACA;IACI,aAAa;IACb,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;AACvB;;AAEA,mCAAmC;AACnC;IACI,mBAAmB;IACnB,eAAe;IACf,eAAe;IACf,+BAA+B;AACnC;AACA;IACI,aAAa;IACb,0BAA0B;AAC9B;AACA;IACI,aAAa;AACjB;;AAEA;IACI,eAAe;AACnB;;AAEA,sBAAsB;AACtB;IACI,iBAAiB;IACjB,eAAe;AACnB;;AAEA;IACI,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;;AAEA;;IAEI,aAAa;AACjB","sourcesContent":["/* General text settings */\r\ntext {\r\n    pointer-events: none;\r\n}\r\n\r\na text {\r\n    pointer-events: all;\r\n}\r\n\r\n/* Main map */\r\n.em-map,\r\n.em-legend {\r\n    font-family: Arial, Helvetica, sans-serif;\r\n}\r\n\r\n/* Coastal margin */\r\n#em-coast-margin {\r\n    filter: url(#em-coastal-blur);\r\n    stroke-linejoin: round;\r\n    stroke-linecap: round;\r\n    fill: none;\r\n    stroke-width: 5;\r\n    stroke: rgb(161, 198, 237);\r\n}\r\n\r\n/* Title and subtitle styling */\r\n.em-title,\r\n.em-inset-title {\r\n    fill: black;\r\n    stroke: none;\r\n}\r\n\r\n.em-title {\r\n    font-size: 21px;\r\n    font-weight: bold;\r\n}\r\n\r\n.em-inset-title {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-subtitle,\r\n.em-inset-subtitle {\r\n    fill: #848280;\r\n    stroke: none;\r\n    stroke-linejoin: round;\r\n    paint-order: stroke;\r\n}\r\n\r\n.em-subtitle {\r\n    font-size: 18px;\r\n    font-weight: 100;\r\n}\r\n\r\n.em-inset-subtitle {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-source-pretext {\r\n    font-size: 11px;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link {\r\n    font-size: 11px;\r\n    fill: #0e47cb;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link:hover {\r\n    fill: #082b7a;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n}\r\n\r\n.em-frame {\r\n    stroke-width: 0;\r\n    stroke: grey;\r\n}\r\n\r\n.em-insets .em-frame {\r\n    /* this will give a frame to inset maps */\r\n    stroke: grey;\r\n    stroke-width: 0.3px !important;\r\n}\r\n\r\n.em-sea {\r\n    fill: white;\r\n    /* pointer-events: none; */\r\n}\r\n.em-scalebar-line {\r\n    stroke: black;\r\n    stroke-width: 0.8px;\r\n}\r\n.em-scalebar-label {\r\n    font-size: 9px;\r\n    text-anchor: middle;\r\n}\r\n\r\n/* Bottom text and symbol styling */\r\n.em-footnote {\r\n    pointer-events: all;\r\n    cursor: default;\r\n    font-size: 11px;\r\n    transform: translate(5px, -5px);\r\n}\r\n.em-footnote a {\r\n    fill: #0e47cb;\r\n    text-decoration: underline;\r\n}\r\n.em-footnote a:hover {\r\n    fill: #0a328e;\r\n}\r\n\r\n.em-centroid {\r\n    cursor: pointer;\r\n}\r\n\r\n/* Graticule styling */\r\n.em-graticule {\r\n    stroke: lightgray;\r\n    stroke-width: 1;\r\n}\r\n\r\n.em-flow-link {\r\n    cursor: pointer;\r\n}\r\n.em-flow-link-outline {\r\n    cursor: pointer;\r\n}\r\n.em-flow-labels {\r\n    font-size: 15px;\r\n    stroke-width: 1px;\r\n    fill: black;\r\n    pointer-events: none;\r\n}\r\n.em-flow-labels-halo {\r\n    font-size: 15px;\r\n    stroke-width: 2px;\r\n    fill: white;\r\n    pointer-events: none;\r\n}\r\n\r\n.em-grid-rect,\r\n.em-grid-hexagon {\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.estat-vis-tooltip-text {
    background: #ffffff;
    color: #171a22;
    padding: 4px;
    font-size: 16px;
}
.estat-vis-tooltip-bar {
    background: #515560;
    color: #ffffff;
    padding: 6px;
    font-size: 16px;
}
.tooltip-eurostat {
    font-family: Arial;
    max-width: 250px;
    overflow: hidden;
    background: white;
    padding: 0px;
    border: 0px;
    border-radius: 0px;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);
    position: absolute;
    font-family: Helvetica, Arial, sans-serif;
    pointer-events: none;
    opacity: 0;
    z-index: 99999999;
}
.em-tooltip-piechart-breakdown {
    padding: 10px;
    font-size: 14px;
}
.em-tooltip-piechart-container {
    text-align: center;
}
`, "",{"version":3,"sources":["webpack://./src/css/tooltip.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,gBAAgB;IAChB,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,kBAAkB;IAClB,2EAA2E;IAC3E,kBAAkB;IAClB,yCAAyC;IACzC,oBAAoB;IACpB,UAAU;IACV,iBAAiB;AACrB;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,kBAAkB;AACtB","sourcesContent":[".estat-vis-tooltip-text {\r\n    background: #ffffff;\r\n    color: #171a22;\r\n    padding: 4px;\r\n    font-size: 16px;\r\n}\r\n.estat-vis-tooltip-bar {\r\n    background: #515560;\r\n    color: #ffffff;\r\n    padding: 6px;\r\n    font-size: 16px;\r\n}\r\n.tooltip-eurostat {\r\n    font-family: Arial;\r\n    max-width: 250px;\r\n    overflow: hidden;\r\n    background: white;\r\n    padding: 0px;\r\n    border: 0px;\r\n    border-radius: 0px;\r\n    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);\r\n    position: absolute;\r\n    font-family: Helvetica, Arial, sans-serif;\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    z-index: 99999999;\r\n}\r\n.em-tooltip-piechart-breakdown {\r\n    padding: 10px;\r\n    font-size: 14px;\r\n}\r\n.em-tooltip-piechart-container {\r\n    text-align: center;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/world.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#g_worldbn,.em-worldrg,.em-worldbn {
    stroke-linecap: round;
    stroke-linejoin: round;
}

.em-worldbn {
    stroke: #000;
    stroke-width: 0.3px;
}

.em-worldbn {
    fill: none;
}

.em-worldrg {
    fill: #efefef;
    cursor: pointer;
}`, "",{"version":3,"sources":["webpack://./src/css/world.css"],"names":[],"mappings":"AAAA;IACI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA;IACI,UAAU;AACd;;AAEA;IACI,aAAa;IACb,eAAe;AACnB","sourcesContent":["#g_worldbn,.em-worldrg,.em-worldbn {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n.em-worldbn {\r\n    stroke: #000;\r\n    stroke-width: 0.3px;\r\n}\r\n\r\n.em-worldbn {\r\n    fill: none;\r\n}\r\n\r\n.em-worldrg {\r\n    fill: #efefef;\r\n    cursor: pointer;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bisectCenter: () => (/* binding */ bisectCenter),
/* harmony export */   bisectLeft: () => (/* binding */ bisectLeft),
/* harmony export */   bisectRight: () => (/* binding */ bisectRight),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_number_js__WEBPACK_IMPORTED_MODULE_2__["default"]).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-array/src/descending.js");



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"] || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extent)
/* harmony export */ });
function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}


/***/ }),

/***/ "./node_modules/d3-array/src/fsum.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/fsum.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adder: () => (/* binding */ Adder),
/* harmony export */   fcumsum: () => (/* binding */ fcumsum),
/* harmony export */   fsum: () => (/* binding */ fsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "./node_modules/d3-array/src/greatest.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/greatest.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ greatest)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");


function greatest(values, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, maxValue) > 0
          : (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/maxIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/maxIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxIndex)
/* harmony export */ });
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/minIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/minIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minIndex)
/* harmony export */ });
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number),
/* harmony export */   numbers: () => (/* binding */ numbers)
/* harmony export */ });
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ permute)
/* harmony export */ });
function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   quantileIndex: () => (/* binding */ quantileIndex),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maxIndex.js */ "./node_modules/d3-array/src/maxIndex.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./minIndex.js */ "./node_modules/d3-array/src/minIndex.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "./node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");
/* harmony import */ var _greatest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./greatest.js */ "./node_modules/d3-array/src/greatest.js");









function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantileIndex(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)));
  if (p <= 0) return (0,_minIndex_js__WEBPACK_IMPORTED_MODULE_4__["default"])(numbers);
  if (p >= 1) return (0,_maxIndex_js__WEBPACK_IMPORTED_MODULE_5__["default"])(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  (0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(index, i, 0, j, (i, j) => (0,_sort_js__WEBPACK_IMPORTED_MODULE_6__.ascendingDefined)(numbers[i], numbers[j]));
  i = (0,_greatest_js__WEBPACK_IMPORTED_MODULE_7__["default"])(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/quickselect.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-array/src/quickselect.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? _sort_js__WEBPACK_IMPORTED_MODULE_0__.ascendingDefined : (0,_sort_js__WEBPACK_IMPORTED_MODULE_0__.compareDefined)(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ range)
/* harmony export */ });
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sort.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/sort.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascendingDefined: () => (/* binding */ ascendingDefined),
/* harmony export */   compareDefined: () => (/* binding */ compareDefined),
/* harmony export */   "default": () => (/* binding */ sort)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _permute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./permute.js */ "./node_modules/d3-array/src/permute.js");



function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return (0,_permute_js__WEBPACK_IMPORTED_MODULE_0__["default"])(values, index);
  }
  return values.sort(compareDefined(f));
}

function compareDefined(compare = _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
  if (compare === _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}


/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sum)
/* harmony export */ });
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ticks),
/* harmony export */   tickIncrement: () => (/* binding */ tickIncrement),
/* harmony export */   tickStep: () => (/* binding */ tickStep)
/* harmony export */ });
const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log10(step)),
      error = step / Math.pow(10, power),
      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}

function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
  }
  return ticks;
}

function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}

function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/axis.js":
/*!******************************************!*\
  !*** ./node_modules/d3-axis/src/axis.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   axisBottom: () => (/* binding */ axisBottom),
/* harmony export */   axisLeft: () => (/* binding */ axisLeft),
/* harmony export */   axisRight: () => (/* binding */ axisRight),
/* harmony export */   axisTop: () => (/* binding */ axisTop)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-axis/src/identity.js");


var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + x + ",0)";
}

function translateY(y) {
  return "translate(0," + y + ")";
}

function number(scale) {
  return d => +scale(d);
}

function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return d => +scale(d) + offset;
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + offset,
        range1 = +range[range.length - 1] + offset,
        position = (scale.bandwidth ? center : number)(scale.copy(), offset),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient === right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d) + offset); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = Array.from(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  axis.offset = function(_) {
    return arguments.length ? (offset = +_, axis) : offset;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/identity.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-axis/src/identity.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ brighter),
/* harmony export */   darker: () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hcl: () => (/* binding */ Hcl),
/* harmony export */   Lab: () => (/* binding */ Lab),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   gray: () => (/* binding */ gray),
/* harmony export */   hcl: () => (/* binding */ hcl),
/* harmony export */   lch: () => (/* binding */ lch)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   radians: () => (/* binding */ radians)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csvFormat: () => (/* binding */ csvFormat),
/* harmony export */   csvFormatBody: () => (/* binding */ csvFormatBody),
/* harmony export */   csvFormatRow: () => (/* binding */ csvFormatRow),
/* harmony export */   csvFormatRows: () => (/* binding */ csvFormatRows),
/* harmony export */   csvFormatValue: () => (/* binding */ csvFormatValue),
/* harmony export */   csvParse: () => (/* binding */ csvParse),
/* harmony export */   csvParseRows: () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tsvFormat: () => (/* binding */ tsvFormat),
/* harmony export */   tsvFormatBody: () => (/* binding */ tsvFormatBody),
/* harmony export */   tsvFormatRow: () => (/* binding */ tsvFormatRow),
/* harmony export */   tsvFormatRows: () => (/* binding */ tsvFormatRows),
/* harmony export */   tsvFormatValue: () => (/* binding */ tsvFormatValue),
/* harmony export */   tsvParse: () => (/* binding */ tsvParse),
/* harmony export */   tsvParseRows: () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csv: () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   tsv: () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_3__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-force/src/collide.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/jiggle.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force/src/lcg.js":
/*!******************************************!*\
  !*** ./node_modules/d3-force/src/lcg.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force/src/simulation.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["default"])("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/x.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/y.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatPrefix: () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatDecimalParts: () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   prefixExponent: () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatSpecifier: () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionFixed.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionFixed.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionPrefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionPrefix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionRound.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionRound.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(step)) + 1;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adder: () => (/* binding */ Adder),
/* harmony export */   fcumsum: () => (/* binding */ fcumsum),
/* harmony export */   fsum: () => (/* binding */ fsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cartesian: () => (/* binding */ cartesian),
/* harmony export */   cartesianAddInPlace: () => (/* binding */ cartesianAddInPlace),
/* harmony export */   cartesianCross: () => (/* binding */ cartesianCross),
/* harmony export */   cartesianDot: () => (/* binding */ cartesianDot),
/* harmony export */   cartesianNormalizeInPlace: () => (/* binding */ cartesianNormalizeInPlace),
/* harmony export */   cartesianScale: () => (/* binding */ cartesianScale),
/* harmony export */   spherical: () => (/* binding */ spherical)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circleStream: () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   haversin: () => (/* binding */ haversin),
/* harmony export */   hypot: () => (/* binding */ hypot),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-geo-projection/node_modules/d3-array/src/fsum.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");




function longitude(point) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi)
    return point[0];
  else
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  var sum = new d3_array__WEBPACK_IMPORTED_MODULE_1__.Adder();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) ^ (winding & 1);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fitExtent: () => (/* binding */ fitExtent),
/* harmony export */   fitHeight: () => (/* binding */ fitHeight),
/* harmony export */   fitSize: () => (/* binding */ fitSize),
/* harmony export */   fitWidth: () => (/* binding */ fitWidth)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   projectionMutator: () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"], // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"], // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"]), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rotateRadians: () => (/* binding */ rotateRadians)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   arcosh: () => (/* binding */ arcosh),
/* harmony export */   arsinh: () => (/* binding */ arsinh),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   cosh: () => (/* binding */ cosh),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sinci: () => (/* binding */ sinci),
/* harmony export */   sinh: () => (/* binding */ sinh),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   sqrt1_2: () => (/* binding */ sqrt1_2),
/* harmony export */   sqrt2: () => (/* binding */ sqrt2),
/* harmony export */   sqrtPi: () => (/* binding */ sqrtPi),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tanh: () => (/* binding */ tanh),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/robinson.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/robinson.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   robinsonRaw: () => (/* binding */ robinsonRaw)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/src/math.js");



var K = [
  [0.9986, -0.062],
  [1.0000, 0.0000],
  [0.9986, 0.0620],
  [0.9954, 0.1240],
  [0.9900, 0.1860],
  [0.9822, 0.2480],
  [0.9730, 0.3100],
  [0.9600, 0.3720],
  [0.9427, 0.4340],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.8350, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1.0000]
];

K.forEach(function(d) {
  d[1] *= 1.0144;
});

function robinsonRaw(lambda, phi) {
  var i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) * 36 / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i),
      di = i - i0,
      ax = (k = K[i0])[0],
      ay = k[1],
      bx = (k = K[++i0])[0],
      by = k[1],
      cx = (k = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, ++i0)])[0],
      cy = k[1],
      k;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    (phi > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}

robinsonRaw.invert = function(x, y) {
  var yy = y / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
      phi = yy * 90,
      i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi / 5)),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i));
  do {
    var ay = K[i0][1],
        by = K[i0 + 1][1],
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1],
        u = cy - ay,
        v = cy - 2 * by + ay,
        t = 2 * ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(yy) - by) / u,
        c = v / u,
        di = t * (1 - c * t * (1 - 2 * c * t));
    if (di >= 0 || i0 === 1) {
      phi = (y >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) / 5);
        i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i);
        di = i - i0;
        ay = K[i0][1];
        by = K[i0 + 1][1];
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1];
        phi -= (delta = (y >= 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
      } while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K[i0][0],
      bx = K[i0 + 1][0],
      cx = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][0];
  return [
    x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])(robinsonRaw)
      .scale(152.63);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "./node_modules/d3-geo/src/stream.js");





var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(cx, cy, cz),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 = 0;
  X2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Y2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Z2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, centroidStream);

  var x = +X2,
      y = +Y2,
      z = +Z2,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) x = X0, y = Y0, z = Z0;
    m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / m) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rectangle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rectangle.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rejoin.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rejoin.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graticule),
/* harmony export */   graticule10: () => (/* binding */ graticule10)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X)
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function(x) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(x))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function(y) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   haversin: () => (/* binding */ haversin),
/* harmony export */   hypot: () => (/* binding */ hypot),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
    areaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(areaRingSum));
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (areaStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (centroidStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathContext)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};


/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure.js */ "./node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-geo/src/path/string.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  let digits = 3,
      pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
    return _area_js__WEBPACK_IMPORTED_MODULE_1__["default"].result();
  };

  path.measure = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _measure_js__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.bounds = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function(_) {
    if (!arguments.length) return projection;
    projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_5__["default"]) : (projection = _).stream;
    return path;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_6__["default"](digits)) : new _context_js__WEBPACK_IMPORTED_MODULE_7__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  path.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) digits = null;
    else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    if (context === null) contextStream = new _string_js__WEBPACK_IMPORTED_MODULE_6__["default"](digits);
    return path;
  };

  return path.projection(projection).digits(digits).context(context);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/measure.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lengthStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathString)
/* harmony export */ });
// Simple caching for constant-radius points.
let cacheDigits, cacheAppend, cacheRadius, cacheCircle;

class PathString {
  constructor(digits) {
    this._append = digits == null ? append : appendRound(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x, y) {
    switch (this._point) {
      case 0: {
        this._append`M${x},${y}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x},${y}`;
        break;
      }
      default: {
        this._append`M${x},${y}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s = this._;
          this._ = ""; // stash the old string so we can cache the circle path fragment
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
}

function append(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15) return append;
  if (d !== cacheDigits) {
    const k = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k) / k + strings[i];
      }
    };
  }
  return cacheAppend;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fitExtent: () => (/* binding */ fitExtent),
/* harmony export */   fitHeight: () => (/* binding */ fitHeight),
/* harmony export */   fitSize: () => (/* binding */ fitSize),
/* harmony export */   fitWidth: () => (/* binding */ fitWidth)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians, sa = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.sin)(alpha), ca = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.cos)(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_3__.degrees;
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitExtent)(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitSize)(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitWidth)(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitHeight)(projection, height, object);
  };

  return projection;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   genericArray: () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return ((0,_numberArray_js__WEBPACK_IMPORTED_MODULE_0__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ piecewise)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_2__["default"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_4__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_2__["default"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_6__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_6__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_7__.genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathRound: () => (/* binding */ pathRound)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}

class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x, y) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y) {
    this._append`L${this._x1 = +x},${this._y1 = +y}`;
  }
  quadraticCurveTo(x1, y1, x, y) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    }

    // Otherwise, draw an arc!
    else {
      let x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }

      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
    }
  }
  rect(x, y, w, h) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}

function path() {
  return new Path;
}

// Allow instanceof d3.path
path.prototype = Path.prototype;

function pathRound(digits = 3) {
  return new Path(+digits);
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set3.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/category10.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/category10.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/colors.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/colors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/ramp.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/ramp.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scheme => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.rgbBasis)(scheme[scheme.length - 1]));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale/src/band.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/band.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ band),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _ordinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ordinal.js */ "./node_modules/d3-scale/src/ordinal.js");




function band() {
  var scale = (0,_ordinal_js__WEBPACK_IMPORTED_MODULE_0__["default"])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}


/***/ }),

/***/ "./node_modules/d3-scale/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constants)
/* harmony export */ });
function constants(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-scale/src/continuous.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/continuous.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (/* binding */ continuous),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/src/number.js");





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"],
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initInterpolator: () => (/* binding */ initInterpolator),
/* harmony export */   initRange: () => (/* binding */ initRange)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/linear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/linear.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ linear),
/* harmony export */   linearish: () => (/* binding */ linearish)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickFormat.js */ "./node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat_js__WEBPACK_IMPORTED_MODULE_1__["default"])(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, linear());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/log.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/log.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ log),
/* harmony export */   loggish: () => (/* binding */ loggish)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _nice_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nice.js */ "./node_modules/d3-scale/src/nice.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : x => Math.pow(base, x);
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), x => Math.log(x) / base);
}

function reflect(f) {
  return (x, k) => -f(-x, k);
}

function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = count => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;

    if (r) ([u, v] = [v, u]);

    let i = logs(u);
    let j = logs(v);
    let k;
    let t;
    const n = count == null ? 10 : +count;
    let z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1; k < base; ++k) {
          t = i < 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1; k >= 1; --k) {
          t = i > 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(u, v, n);
    } else {
      z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };

  scale.tickFormat = (count, specifier) => {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])(specifier)).precision == null) specifier.trim = true;
      specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.format)(specifier);
    }
    if (count === Infinity) return specifier;
    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return d => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = () => {
    return domain((0,_nice_js__WEBPACK_IMPORTED_MODULE_3__["default"])(domain(), {
      floor: x => pows(Math.floor(logs(x))),
      ceil: x => pows(Math.ceil(logs(x)))
    }));
  };

  return scale;
}

function log() {
  const scale = loggish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_4__.transformer)()).domain([1, 10]);
  scale.copy = () => (0,_continuous_js__WEBPACK_IMPORTED_MODULE_4__.copy)(scale, log()).base(scale.base());
  _init_js__WEBPACK_IMPORTED_MODULE_5__.initRange.apply(scale, arguments);
  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/nice.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/nice.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nice)
/* harmony export */ });
function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number)
/* harmony export */ });
function number(x) {
  return +x;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/ordinal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/ordinal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ordinal),
/* harmony export */   implicit: () => (/* binding */ implicit)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/internmap/src/index.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



const implicit = Symbol("implicit");

function ordinal() {
  var index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    let i = index.get(d);
    if (i === undefined) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap();
    for (const value of _) {
      if (index.has(value)) continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/pow.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/pow.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pow),
/* harmony export */   powish: () => (/* binding */ powish),
/* harmony export */   sqrt: () => (/* binding */ sqrt)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantize.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantize.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantize)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_linear_js__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/threshold.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/threshold.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ threshold)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/tickFormat.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/tickFormat.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tickFormat)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");



function tickFormat(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__["default"])(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__["default"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__["default"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_creator_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([(0,_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(arc);

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle. If this
        // intersection fails, it’s probably because the arc is too small, so
        // disable the corner radius entirely.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
                lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
            rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(area);

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bump.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bump.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpRadial: () => (/* binding */ bumpRadial),
/* harmony export */   bumpX: () => (/* binding */ bumpX),
/* harmony export */   bumpY: () => (/* binding */ bumpY)
/* harmony export */ });
/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");


class Bump {
  constructor(context, x) {
    this._context = context;
    this._x = x;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x, y);
        else this._context.moveTo(x, y);
        break;
      }
      case 1: this._point = 2; // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
        break;
      }
    }
    this._x0 = x, this._y0 = y;
  }
}

class BumpRadial {
  constructor(context) {
    this._context = context;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {}
  point(x, y) {
    x = +x, y = +y;
    if (this._point === 0) {
      this._point = 1;
    } else {
      const p0 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0);
      const p1 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0 = (this._y0 + y) / 2);
      const p2 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, this._y0);
      const p3 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, y);
      this._context.moveTo(...p0);
      this._context.bezierCurveTo(...p1, ...p2, ...p3);
    }
    this._x0 = x, this._y0 = y;
  }
}

function bumpX(context) {
  return new Bump(context, true);
}

function bumpY(context) {
  return new Bump(context, false);
}

function bumpRadial(context) {
  return new BumpRadial(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/identity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(line);

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/link.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   link: () => (/* binding */ link),
/* harmony export */   linkHorizontal: () => (/* binding */ linkHorizontal),
/* harmony export */   linkRadial: () => (/* binding */ linkRadial),
/* harmony export */   linkVertical: () => (/* binding */ linkVertical)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_bump_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curve/bump.js */ "./node_modules/d3-shape/src/curve/bump.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  let source = linkSource,
      target = linkTarget,
      x = _point_js__WEBPACK_IMPORTED_MODULE_0__.x,
      y = _point_js__WEBPACK_IMPORTED_MODULE_0__.y,
      context = null,
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.withPath)(link);

  function link() {
    let buffer;
    const argv = _array_js__WEBPACK_IMPORTED_MODULE_2__.slice.call(arguments);
    const s = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null) output = curve(buffer = path());
    output.lineStart();
    argv[0] = s, output.point(+x.apply(this, argv), +y.apply(this, argv));
    argv[0] = t, output.point(+x.apply(this, argv), +y.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
  };

  return link;
}

function linkHorizontal() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpX);
}

function linkVertical() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpY);
}

function linkRadial() {
  const l = link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/path.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   withPath: () => (/* binding */ withPath)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");


function withPath(shape) {
  let digits = 3;

  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };

  return () => new d3_path__WEBPACK_IMPORTED_MODULE_0__.Path(digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pie.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/pie.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      sortValues = _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0),
      endAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0);

  function pie(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pointRadial.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/pointRadial.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-shape/src/symbol.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Symbol),
/* harmony export */   symbolsFill: () => (/* binding */ symbolsFill),
/* harmony export */   symbolsStroke: () => (/* binding */ symbolsStroke)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/asterisk.js */ "./node_modules/d3-shape/src/symbol/asterisk.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/diamond2.js */ "./node_modules/d3-shape/src/symbol/diamond2.js");
/* harmony import */ var _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbol/plus.js */ "./node_modules/d3-shape/src/symbol/plus.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/square2.js */ "./node_modules/d3-shape/src/symbol/square2.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/triangle2.js */ "./node_modules/d3-shape/src/symbol/triangle2.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol/times.js */ "./node_modules/d3-shape/src/symbol/times.js");
















// These symbols are designed to be filled.
const symbolsFill = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__["default"]
];

// These symbols are designed to be stroked (with a width of 1.5px and round caps).
const symbolsStroke = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__["default"]
];

function Symbol(type, size) {
  let context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_13__.withPath)(symbol);

  type = typeof type === "function" ? type : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  size = typeof size === "function" ? size : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(size === undefined ? 64 : +size);

  function symbol() {
    let buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/asterisk.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/asterisk.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u = t * sqrt3;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u, -t);
    context.lineTo(u, t);
    context.moveTo(-u, t);
    context.lineTo(u, -t);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/circle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/cross.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/cross.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const tan30 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(1 / 3);
const tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / tan30_2);
    const x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond2.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond2.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/plus.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/plus.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const w = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size);
    const x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square2.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square2.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/star.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/star.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const ka = 0.89081309152928522810;
const kr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10);
const kx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;
const ky = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size * ka);
    const x = kx * r;
    const y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (let i = 1; i < 5; ++i) {
      const a = _math_js__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5;
      const c = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a);
      const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/times.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/times.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle2.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle2.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.6824;
    const t = s  / 2;
    const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
    context.moveTo(0, -s);
    context.lineTo(u, t);
    context.lineTo(-u, t);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/wye.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/wye.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const c = -0.5;
const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3) / 2;
const k = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(12);
const a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / a);
    const x0 = r / 2, y0 = r * k;
    const x1 = x0, y1 = r * k + r;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/indexRollupNext.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-svg-annotation/indexRollupNext.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotation: () => (/* binding */ annotation),
/* harmony export */   annotationBadge: () => (/* binding */ d3Badge),
/* harmony export */   annotationCallout: () => (/* binding */ d3Callout),
/* harmony export */   annotationCalloutCircle: () => (/* binding */ d3CalloutCircle),
/* harmony export */   annotationCalloutCurve: () => (/* binding */ d3CalloutCurve),
/* harmony export */   annotationCalloutElbow: () => (/* binding */ d3CalloutElbow),
/* harmony export */   annotationCalloutRect: () => (/* binding */ d3CalloutRect),
/* harmony export */   annotationCustomType: () => (/* binding */ customType),
/* harmony export */   annotationLabel: () => (/* binding */ d3Label),
/* harmony export */   annotationTypeBase: () => (/* binding */ Type),
/* harmony export */   annotationXYThreshold: () => (/* binding */ d3XYThreshold),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js");
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");





var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Annotation = function () {
  function Annotation(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === undefined ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === undefined ? 0 : _ref$y,
        nx = _ref.nx,
        ny = _ref.ny,
        _ref$dy = _ref.dy,
        dy = _ref$dy === undefined ? 0 : _ref$dy,
        _ref$dx = _ref.dx,
        dx = _ref$dx === undefined ? 0 : _ref$dx,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? "grey" : _ref$color,
        data = _ref.data,
        type = _ref.type,
        subject = _ref.subject,
        connector = _ref.connector,
        note = _ref.note,
        disable = _ref.disable,
        id = _ref.id,
        className = _ref.className;
    classCallCheck(this, Annotation);

    this._dx = nx !== undefined ? nx - x : dx;
    this._dy = ny !== undefined ? ny - y : dy;
    this._x = x;
    this._y = y;
    this._color = color;
    this.id = id;
    this._className = className || "";

    this._type = type || "";
    this.data = data;

    this.note = note || {};
    this.connector = connector || {};
    this.subject = subject || {};

    this.disable = disable || [];
  }

  createClass(Annotation, [{
    key: "updatePosition",
    value: function updatePosition() {
      if (this.type.setPosition) {
        this.type.setPosition();
        if (this.type.subject && this.type.subject.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawSubject();
        }
      }
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.type.clearComponents && this.type.clearComponents();
    }
  }, {
    key: "updateOffset",
    value: function updateOffset() {
      if (this.type.setOffset) {
        this.type.setOffset();

        if (this.type.connector.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawConnector();
        }

        this.type.redrawNote();
      }
    }
  }, {
    key: "className",
    get: function get$$1() {
      return this._className;
    },
    set: function set$$1(className) {
      this._className = className;
      if (this.type.setClassName) this.type.setClassName();
    }
  }, {
    key: "type",
    get: function get$$1() {
      return this._type;
    },
    set: function set$$1(type) {
      this._type = type;
      this.clearComponents();
    }
  }, {
    key: "x",
    get: function get$$1() {
      return this._x;
    },
    set: function set$$1(x) {
      this._x = x;
      this.updatePosition();
    }
  }, {
    key: "y",
    get: function get$$1() {
      return this._y;
    },
    set: function set$$1(y) {
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "color",
    get: function get$$1() {
      return this._color;
    },
    set: function set$$1(color) {
      this._color = color;
      this.updatePosition();
    }
  }, {
    key: "dx",
    get: function get$$1() {
      return this._dx;
    },
    set: function set$$1(dx) {
      this._dx = dx;
      this.updateOffset();
    }
  }, {
    key: "dy",
    get: function get$$1() {
      return this._dy;
    },
    set: function set$$1(dy) {
      this._dy = dy;
      this.updateOffset();
    }
  }, {
    key: "nx",
    set: function set$$1(nx) {
      this._dx = nx - this._x;
      this.updateOffset();
    }
  }, {
    key: "ny",
    set: function set$$1(ny) {
      this._dy = ny - this._y;
      this.updateOffset();
    }
  }, {
    key: "offset",
    get: function get$$1() {
      return { x: this._dx, y: this._dy };
    },
    set: function set$$1(_ref2) {
      var x = _ref2.x,
          y = _ref2.y;

      this._dx = x;
      this._dy = y;
      this.updateOffset();
    }
  }, {
    key: "position",
    get: function get$$1() {
      return { x: this._x, y: this._y };
    },
    set: function set$$1(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      this._x = x;
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "translation",
    get: function get$$1() {
      return {
        x: this._x + this._dx,
        y: this._y + this._dy
      };
    }
  }, {
    key: "json",
    get: function get$$1() {
      var json = {
        x: this._x,
        y: this._y,
        dx: this._dx,
        dy: this._dy
      };

      if (this.data && Object.keys(this.data).length > 0) json.data = this.data;
      if (this.type) json.type = this.type;
      if (this._className) json.className = this._className;

      if (Object.keys(this.connector).length > 0) json.connector = this.connector;
      if (Object.keys(this.subject).length > 0) json.subject = this.subject;
      if (Object.keys(this.note).length > 0) json.note = this.note;

      return json;
    }
  }]);
  return Annotation;
}();

var AnnotationCollection = function () {
  function AnnotationCollection(_ref) {
    var annotations = _ref.annotations,
        accessors = _ref.accessors,
        accessorsInverse = _ref.accessorsInverse;
    classCallCheck(this, AnnotationCollection);

    this.accessors = accessors;
    this.accessorsInverse = accessorsInverse;
    this.annotations = annotations;
  }

  createClass(AnnotationCollection, [{
    key: "clearTypes",
    value: function clearTypes(newSettings) {
      this.annotations.forEach(function (d) {
        d.type = undefined;
        d.subject = newSettings && newSettings.subject || d.subject;
        d.connector = newSettings && newSettings.connector || d.connector;
        d.note = newSettings && newSettings.note || d.note;
      });
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors() {
      var _this = this;

      this.annotations.forEach(function (d) {
        d.type.setPositionWithAccessors(_this.accessors);
      });
    }
  }, {
    key: "editMode",
    value: function editMode(_editMode) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.editMode = _editMode;
          a.type.updateEditMode();
        }
      });
    }
  }, {
    key: "updateDisable",
    value: function updateDisable(disable) {
      this.annotations.forEach(function (a) {
        a.disable = disable;
        if (a.type) {
          disable.forEach(function (d) {
            if (a.type[d]) {
              a.type[d].remove && a.type[d].remove();
              a.type[d] = undefined;
            }
          });
        }
      });
    }
  }, {
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.updateTextWrap) {
          a.type.updateTextWrap(textWrap);
        }
      });
    }
  }, {
    key: "updateText",
    value: function updateText() {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.drawText) {
          a.type.drawText();
        }
      });
    }
  }, {
    key: "updateNotePadding",
    value: function updateNotePadding(notePadding) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.notePadding = notePadding;
        }
      });
    }
  }, {
    key: "json",
    get: function get$$1() {
      var _this2 = this;

      return this.annotations.map(function (a) {
        var json = a.json;
        if (_this2.accessorsInverse && a.data) {
          json.data = {};
          Object.keys(_this2.accessorsInverse).forEach(function (k) {
            json.data[k] = _this2.accessorsInverse[k]({ x: a.x, y: a.y });

            //TODO make this feasible to map back to data for other types of subjects
          });
        }
        return json;
      });
    }
  }, {
    key: "noteNodes",
    get: function get$$1() {
      return this.annotations.map(function (a) {
        return _extends({}, a.type.getNoteBBoxOffset(), { positionX: a.x, positionY: a.y });
      });
    }

    //TODO: come back and rethink if a.x and a.y are applicable in all situations
    // get connectorNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))
    // }

    // get subjectNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))
    // }

    // get annotationNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))
    // }

  }]);
  return AnnotationCollection;
}();

var pointHandle = function pointHandle(_ref) {
  var _ref$cx = _ref.cx,
      cx = _ref$cx === undefined ? 0 : _ref$cx,
      _ref$cy = _ref.cy,
      cy = _ref$cy === undefined ? 0 : _ref$cy;

  return { move: { x: cx, y: cy } };
};

var circleHandles = function circleHandles(_ref2) {
  var _ref2$cx = _ref2.cx,
      cx = _ref2$cx === undefined ? 0 : _ref2$cx,
      _ref2$cy = _ref2.cy,
      cy = _ref2$cy === undefined ? 0 : _ref2$cy,
      r1 = _ref2.r1,
      r2 = _ref2.r2,
      padding = _ref2.padding;

  var h = { move: { x: cx, y: cy } };

  if (r1 !== undefined) {
    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
  }

  if (r2 !== undefined) {
    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
  }

  if (padding !== undefined) {
    h.padding = { x: cx + r1 + padding, y: cy };
  }

  return h;
};





//arc handles
var addHandles = function addHandles(_ref5) {
  var group = _ref5.group,
      handles = _ref5.handles,
      _ref5$r = _ref5.r,
      r = _ref5$r === undefined ? 10 : _ref5$r;

  //give it a group and x,y to draw handles
  //then give it instructions on what the handles change
  var h = group.selectAll("circle.handle").data(handles);

  h.enter().append("circle").attr("class", "handle").attr("fill", "grey").attr("fill-opacity", 0.1).attr("cursor", "move").attr("stroke-dasharray", 5).attr("stroke", "grey").call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
    return d.start && d.start(d);
  }).on("drag", function (d) {
    return d.drag && d.drag(d);
  }).on("end", function (d) {
    return d.end && d.end(d);
  }));

  group.selectAll("circle.handle").attr("cx", function (d) {
    return d.x;
  }).attr("cy", function (d) {
    return d.y;
  }).attr("r", function (d) {
    return d.r || r;
  }).attr("class", function (d) {
    return "handle " + (d.className || "");
  });

  h.exit().remove();
};

var leftRightDynamic = function leftRightDynamic(align, y) {
  if (align === "dynamic" || align === "left" || align === "right") {
    if (y < 0) {
      align = "top";
    } else {
      align = "bottom";
    }
  }
  return align;
};

var topBottomDynamic = function topBottomDynamic(align, x) {
  if (align === "dynamic" || align === "top" || align === "bottom") {
    if (x < 0) {
      align = "right";
    } else {
      align = "left";
    }
  }
  return align;
};

var orientationTopBottom = ["topBottom", "top", "bottom"];
var orientationLeftRight = ["leftRight", "left", "right"];

var noteAlignment = (function (_ref) {
  var _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$bbox = _ref.bbox,
      bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
      align = _ref.align,
      orientation = _ref.orientation,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

  var x = -bbox.x;
  var y = 0; //-bbox.y
  if (orientationTopBottom.indexOf(orientation) !== -1) {
    align = topBottomDynamic(align, offset.x);
    if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
      y -= bbox.height + padding;
    } else {
      y += padding;
    }

    if (align === "middle") {
      x -= bbox.width / 2;
    } else if (align === "right") {
      x -= bbox.width;
    }
  } else if (orientationLeftRight.indexOf(orientation) !== -1) {
    align = leftRightDynamic(align, offset.y);
    if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
      x -= bbox.width + padding;
    } else {
      x += padding;
    }

    if (align === "middle") {
      y -= bbox.height / 2;
    } else if (align === "top") {
      y -= bbox.height;
    }
  }

  return { x: x, y: y };
});

var lineBuilder = function lineBuilder(_ref) {
  var data = _ref.data,
      _ref$curve = _ref.curve,
      curve = _ref$curve === undefined ? d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveLinear : _ref$curve,
      canvasContext = _ref.canvasContext,
      className = _ref.className,
      classID = _ref.classID;

  var lineGen = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.line)().curve(curve);

  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {
    builder.attrs = {
      d: lineGen(data)
    };
  }

  return builder;
};

var arcBuilder = function arcBuilder(_ref2) {
  var data = _ref2.data,
      canvasContext = _ref2.canvasContext,
      className = _ref2.className,
      classID = _ref2.classID;


  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  var arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.arc)().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

  if (canvasContext) {
    arcShape.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {

    builder.attrs = {
      d: arcShape()
    };
  }

  return builder;
};

var noteVertical = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      bbox = _ref.bbox,
      offset = _ref.offset;

  align = leftRightDynamic(align, offset.y);

  if (align === "top") {
    y -= bbox.height;
  } else if (align === "middle") {
    y -= bbox.height / 2;
  }

  var data = [[x, y], [x, y + bbox.height]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var noteHorizontal = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      offset = _ref.offset,
      bbox = _ref.bbox;

  align = topBottomDynamic(align, offset.x);

  if (align === "right") {
    x -= bbox.width;
  } else if (align === "middle") {
    x -= bbox.width / 2;
  }

  var data = [[x, y], [x + bbox.width, y]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var lineSetup = function lineSetup(_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;

  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    var angle = Math.asin(-y2 / h);
    var r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0);

    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
  }

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  return [[x1, y1], [x2, y2]];
};

var connectorLine = (function (connectorData) {
  var data = lineSetup(connectorData);
  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorElbow = (function (_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;


  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  var data = [[x1, y1], [x2, y2]];

  var diffY = y2 - y1;
  var diffX = x2 - x1;
  var xe = x2;
  var ye = y2;
  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

  if (Math.abs(diffX) < Math.abs(diffY)) {
    xe = x2;
    ye = y1 + diffX * opposite;
  } else {
    ye = y2;
    xe = x1 + diffY * opposite;
  }

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0);
    var length = r / Math.sqrt(2);

    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
      x1 = length * (x2 < 0 ? -1 : 1);
      y1 = length * (y2 < 0 ? -1 : 1);
      data = [[x1, y1], [xe, ye], [x2, y2]];
    } else if (Math.abs(diffX) > Math.abs(diffY)) {
      var angle = Math.asin(-y2 / r);
      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      data = [[x1, y2], [x2, y2]];
    } else {
      var _angle = Math.acos(x2 / r);
      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
      data = [[x2, y1], [x2, y2]];
    }
  } else {
    data = [[x1, y1], [xe, ye], [x2, y2]];
  }

  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorCurve = (function (_ref) {
  var type = _ref.type,
      connectorData = _ref.connectorData,
      subjectType = _ref.subjectType;


  if (!connectorData) {
    connectorData = {};
  }
  if (!connectorData.points || typeof connectorData.points === "number") {
    connectorData.points = createPoints(type.annotation.offset, connectorData.points);
  }
  if (!connectorData.curve) {
    connectorData.curve = d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveCatmullRom;
  }

  var handles = [];

  if (type.editMode) {
    var cHandles = connectorData.points.map(function (c, i) {
      return _extends({}, pointHandle({ cx: c[0], cy: c[1] }), { index: i });
    });

    var updatePoint = function updatePoint(index) {
      connectorData.points[index][0] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      connectorData.points[index][1] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      type.redrawConnector();
    };

    handles = type.mapHandles(cHandles.map(function (h) {
      return _extends({}, h.move, { drag: updatePoint.bind(type, h.index) });
    }));
  }

  var data = lineSetup({ type: type, subjectType: subjectType });
  data = [data[0]].concat(toConsumableArray(connectorData.points), [data[1]]);
  var components = [lineBuilder({ data: data, curve: connectorData.curve, className: "connector" })];

  return { components: components, handles: handles };
});

var createPoints = function createPoints(offset) {
  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
  var p = [];

  var i = 1;
  for (; i <= anchors; i++) {
    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
  }
  return p;
};

var connectorArrow = (function (_ref) {
  var annotation = _ref.annotation,
      start = _ref.start,
      end = _ref.end,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var offset = annotation.position;
  if (!start) {
    start = [annotation.dx, annotation.dy];
  } else {
    start = [-end[0] + start[0], -end[1] + start[1]];
  }
  if (!end) {
    end = [annotation.x - offset.x, annotation.y - offset.y];
  }

  var x1 = end[0],
      y1 = end[1];

  var dx = start[0];
  var dy = start[1];

  var size = 10 * scale;
  var angleOffset = 16 / 180 * Math.PI;
  var angle = Math.atan(dy / dx);

  if (dx < 0) {
    angle += Math.PI;
  }

  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

  //TODO add in reverse
  // if (canvasContext.arrowReverse){
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // } else {
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // }

  return {
    components: [lineBuilder({
      data: data,
      className: "connector-end connector-arrow",
      classID: "connector-end"
    })]
  };
});

var connectorDot = (function (_ref) {
  var line$$1 = _ref.line,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var dot = arcBuilder({
    className: "connector-end connector-dot",
    classID: "connector-end",
    data: { radius: 3 * Math.sqrt(scale) }
  });
  dot.attrs.transform = "translate(" + line$$1.data[0][0] + ", " + line$$1.data[0][1] + ")";

  return { components: [dot] };
});

var subjectCircle = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.radius && !subjectData.outerRadius) {
    subjectData.radius = 20;
  }

  var handles = [];
  var c = arcBuilder({ data: subjectData, className: "subject" });
  if (type.editMode) {
    var h = circleHandles({
      r1: c.data.outerRadius || c.data.radius,
      r2: c.data.innerRadius,
      padding: subjectData.radiusPadding
    });

    var updateRadius = function updateRadius(attr) {
      var r = subjectData[attr] + d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx * Math.sqrt(2);
      subjectData[attr] = r;
      type.redrawSubject();
      type.redrawConnector();
    };

    var cHandles = [_extends({}, h.r1, {
      drag: updateRadius.bind(type, subjectData.outerRadius !== undefined ? "outerRadius" : "radius")
    })];

    if (subjectData.innerRadius) {
      cHandles.push(_extends({}, h.r2, { drag: updateRadius.bind(type, "innerRadius") }));
    }
    handles = type.mapHandles(cHandles);
  }

  c.attrs["fill-opacity"] = 0;

  return { components: [c], handles: handles };
});

var subjectRect = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.width) {
    subjectData.width = 100;
  }
  if (!subjectData.height) {
    subjectData.height = 100;
  }

  var handles = [];
  var width = subjectData.width,
      height = subjectData.height;


  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
  var rect = lineBuilder({ data: data, className: "subject" });

  if (type.editMode) {
    var updateWidth = function updateWidth() {
      subjectData.width = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x;
      type.redrawSubject();
      type.redrawConnector();
    };

    var updateHeight = function updateHeight() {
      subjectData.height = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y;
      type.redrawSubject();
      type.redrawConnector();
    };

    var rHandles = [{ x: width, y: height / 2, drag: updateWidth.bind(type) }, { x: width / 2, y: height, drag: updateHeight.bind(type) }];

    handles = type.mapHandles(rHandles);
  }
  rect.attrs["fill-opacity"] = 0.1;
  return { components: [rect], handles: handles };
});

var subjectThreshold = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  var offset = type.annotation.position;

  var x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x,
      x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x,
      y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y,
      y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y;

  var data = [[x1, y1], [x2, y2]];
  return { components: [lineBuilder({ data: data, className: 'subject' })] };
});

var subjectBadge = (function (_ref) {
  var _ref$subjectData = _ref.subjectData,
      subjectData = _ref$subjectData === undefined ? {} : _ref$subjectData,
      _ref$type = _ref.type,
      type = _ref$type === undefined ? {} : _ref$type;
  var annotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var typeSettings = type.typeSettings && type.typeSettings.subject;

  if (!subjectData.radius) {
    if (typeSettings && typeSettings.radius) {
      subjectData.radius = typeSettings.radius;
    } else {
      subjectData.radius = 14;
    }
  }
  if (!subjectData.x) {
    if (typeSettings && typeSettings.x) {
      subjectData.x = typeSettings.x;
    }
  }
  if (!subjectData.y) {
    if (typeSettings && typeSettings.y) {
      subjectData.y = typeSettings.y;
    }
  }

  var handles = [];
  var components = [];
  var radius = subjectData.radius;
  var innerRadius = radius * 0.7;
  var x = 0;
  var y = 0;

  var notCornerOffset = Math.sqrt(2) * radius;
  var placement = {
    xleftcorner: -radius,
    xrightcorner: radius,
    ytopcorner: -radius,
    ybottomcorner: radius,
    xleft: -notCornerOffset,
    xright: notCornerOffset,
    ytop: -notCornerOffset,
    ybottom: notCornerOffset
  };

  if (subjectData.x && !subjectData.y) {
    x = placement["x" + subjectData.x];
  } else if (subjectData.y && !subjectData.x) {
    y = placement["y" + subjectData.y];
  } else if (subjectData.x && subjectData.y) {
    x = placement["x" + subjectData.x + "corner"];
    y = placement["y" + subjectData.y + "corner"];
  }

  var transform = "translate(" + x + ", " + y + ")";
  var circlebg = arcBuilder({ className: "subject", data: { radius: radius } });
  circlebg.attrs.transform = transform;
  circlebg.attrs.fill = annotation.color;
  circlebg.attrs["stroke-linecap"] = "round";
  circlebg.attrs["stroke-width"] = "3px";

  var circle = arcBuilder({
    className: "subject-ring",
    data: { outerRadius: radius, innerRadius: innerRadius }
  });

  circle.attrs.transform = transform;
  // circle.attrs.fill = annotation.color
  circle.attrs["stroke-width"] = "3px";
  circle.attrs.fill = "white";

  var pointer = void 0;
  if (x && y || !x && !y) {
    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
    });
  } else if (x || y) {
    var notCornerPointerXY = function notCornerPointerXY(v) {
      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
    };

    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
    });
  }

  if (pointer) {
    pointer.attrs.fill = annotation.color;
    pointer.attrs["stroke-linecap"] = "round";
    pointer.attrs["stroke-width"] = "3px";
    components.push(pointer);
  }

  if (type.editMode) {
    var dragBadge = function dragBadge() {
      subjectData.x = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x < -radius * 2 ? "left" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x > radius * 2 ? "right" : undefined;
      subjectData.y = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y < -radius * 2 ? "top" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y > radius * 2 ? "bottom" : undefined;

      type.redrawSubject();
    };

    var bHandles = { x: x * 2, y: y * 2, drag: dragBadge.bind(type) };
    if (!bHandles.x && !bHandles.y) {
      bHandles.y = -radius;
    }

    handles = type.mapHandles([bHandles]);
  }

  var text = void 0;
  if (subjectData.text) {
    text = {
      type: "text",
      className: "badge-text",
      attrs: {
        fill: "white",
        stroke: "none",
        "font-size": ".7em",
        text: subjectData.text,
        "text-anchor": "middle",
        dy: ".25em",
        x: x,
        y: y
      }
    };
  }

  components.push(circlebg);
  components.push(circle);
  components.push(text);

  return { components: components, handles: handles };
});

//Note options
//Connector options
//Subject options
var Type = function () {
  function Type(_ref) {
    var a = _ref.a,
        annotation = _ref.annotation,
        editMode = _ref.editMode,
        dispatcher = _ref.dispatcher,
        notePadding = _ref.notePadding,
        accessors = _ref.accessors;
    classCallCheck(this, Type);

    this.a = a;

    this.note = annotation.disable.indexOf("note") === -1 && a.select("g.annotation-note");
    this.noteContent = this.note && a.select("g.annotation-note-content");
    this.connector = annotation.disable.indexOf("connector") === -1 && a.select("g.annotation-connector");
    this.subject = annotation.disable.indexOf("subject") === -1 && a.select("g.annotation-subject");
    this.dispatcher = dispatcher;

    if (dispatcher) {
      var handler = addHandlers.bind(null, dispatcher, annotation);
      handler({ component: this.note, name: "note" });
      handler({ component: this.connector, name: "connector" });
      handler({ component: this.subject, name: "subject" });
    }

    this.annotation = annotation;
    this.editMode = annotation.editMode || editMode;
    this.notePadding = notePadding !== undefined ? notePadding : 3;
    this.offsetCornerX = 0;
    this.offsetCornerY = 0;

    if (accessors && annotation.data) {
      this.init(accessors);
    }
  }

  createClass(Type, [{
    key: "init",
    value: function init(accessors) {
      if (!this.annotation.x) {
        this.mapX(accessors);
      }
      if (!this.annotation.y) {
        this.mapY(accessors);
      }
    }
  }, {
    key: "mapY",
    value: function mapY(accessors) {
      if (accessors.y) {
        this.annotation.y = accessors.y(this.annotation.data);
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      if (accessors.x) {
        this.annotation.x = accessors.x(this.annotation.data);
      }
    }
  }, {
    key: "updateEditMode",
    value: function updateEditMode() {
      this.a.selectAll("circle.handle").remove();
    }
  }, {
    key: "drawOnSVG",
    value: function drawOnSVG(component, builders) {
      var _this = this;

      if (!Array.isArray(builders)) {
        builders = [builders];
      }

      builders.filter(function (b) {
        return b;
      }).forEach(function (_ref2) {
        var type = _ref2.type,
            className = _ref2.className,
            attrs = _ref2.attrs,
            handles = _ref2.handles,
            classID = _ref2.classID;

        if (type === "handle") {
          addHandles({ group: component, r: attrs && attrs.r, handles: handles });
        } else {
          newWithClass(component, [_this.annotation], type, className, classID);
          var el = component.select(type + "." + (classID || className));
          var addAttrs = Object.keys(attrs);
          var removeAttrs = [];

          var currentAttrs = el.node().attributes;
          for (var i = currentAttrs.length - 1; i >= 0; i--) {
            var name = currentAttrs[i].name;
            if (addAttrs.indexOf(name) === -1 && name !== "class") removeAttrs.push(name);
          }

          addAttrs.forEach(function (attr) {
            if (attr === "text") {
              el.text(attrs[attr]);
            } else {
              el.attr(attr, attrs[attr]);
            }
          });

          removeAttrs.forEach(function (attr) {
            return el.attr(attr, null);
          });
        }
      });
    }

    //TODO: how to extend this to a drawOnCanvas mode?

  }, {
    key: "getNoteBBox",
    value: function getNoteBBox() {
      return bboxWithoutHandles(this.note, ".annotation-note-content text");
    }
  }, {
    key: "getNoteBBoxOffset",
    value: function getNoteBBoxOffset() {
      var bbox = bboxWithoutHandles(this.note, ".annotation-note-content");
      var transform = this.noteContent.attr("transform").split(/\(|\,|\)/g);
      bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx;
      bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy;
      bbox.offsetX = this.annotation.dx;
      bbox.offsetY = this.annotation.dy;
      return bbox;
    }
  }, {
    key: "drawSubject",
    value: function drawSubject() {
      var _this2 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var subjectData = this.annotation.subject;
      var type = context.type;
      var subjectParams = { type: this, subjectData: subjectData };

      var subject = {};
      if (type === "circle") subject = subjectCircle(subjectParams);else if (type === "rect") subject = subjectRect(subjectParams);else if (type === "threshold") subject = subjectThreshold(subjectParams);else if (type === "badge") subject = subjectBadge(subjectParams, this.annotation);

      var _subject = subject,
          _subject$components = _subject.components,
          components = _subject$components === undefined ? [] : _subject$components,
          _subject$handles = _subject.handles,
          handles = _subject$handles === undefined ? [] : _subject$handles;

      components.forEach(function (c) {
        if (c && c.attrs && !c.attrs.stroke) {
          c.attrs.stroke = _this2.annotation.color;
        }
      });

      if (this.editMode) {
        handles = handles.concat(this.mapHandles([{ drag: this.dragSubject.bind(this) }]));
        components.push({ type: "handle", handles: handles });
      }

      return components;
    }
  }, {
    key: "drawConnector",
    value: function drawConnector() {
      var _this3 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var connectorData = this.annotation.connector;
      var type = connectorData.type || context.type;
      var connectorParams = { type: this, connectorData: connectorData };
      connectorParams.subjectType = this.typeSettings && this.typeSettings.subject && this.typeSettings.subject.type;

      var connector = {};
      if (type === "curve") connector = connectorCurve(connectorParams);else if (type === "elbow") connector = connectorElbow(connectorParams);else connector = connectorLine(connectorParams);
      var _connector = connector,
          _connector$components = _connector.components,
          components = _connector$components === undefined ? [] : _connector$components,
          _connector$handles = _connector.handles,
          handles = _connector$handles === undefined ? [] : _connector$handles;

      var line$$1 = components[0];
      //TODO: genericize this into fill t/f stroke t/f
      if (line$$1) {
        line$$1.attrs.stroke = this.annotation.color;
        line$$1.attrs.fill = "none";
      }
      var endType = connectorData.end || context.end;
      var end = {};
      if (endType === "arrow") {
        var s = line$$1.data[1];
        var e = line$$1.data[0];
        var distance = Math.sqrt(Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2));
        if (distance < 5 && line$$1.data[2]) {
          s = line$$1.data[2];
        }
        end = connectorArrow({
          annotation: this.annotation,
          start: s,
          end: e,
          scale: connectorData.endScale
        });
      } else if (endType === "dot") {
        end = connectorDot({ line: line$$1, scale: connectorData.endScale });
      } else if (!endType || endType === "none") {
        this.connector && this.connector.select(".connector-end").remove();
      }

      if (end.components) {
        end.components.forEach(function (c) {
          c.attrs.fill = _this3.annotation.color;
          c.attrs.stroke = _this3.annotation.color;
        });
        components = components.concat(end.components);
      }

      if (this.editMode) {
        if (handles.length !== 0) components.push({ type: "handle", handles: handles });
      }
      return components;
    }
  }, {
    key: "drawNote",
    value: function drawNote() {
      var _this4 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var noteData = this.annotation.note;
      var align = noteData.align || context.align || "dynamic";
      var noteParams = {
        bbox: context.bbox,
        align: align,
        offset: this.annotation.offset
      };
      var lineType = noteData.lineType || context.lineType;
      var note = {};
      if (lineType === "vertical") note = noteVertical(noteParams);else if (lineType === "horizontal") note = noteHorizontal(noteParams);

      var _note = note,
          _note$components = _note.components,
          components = _note$components === undefined ? [] : _note$components,
          _note$handles = _note.handles,
          handles = _note$handles === undefined ? [] : _note$handles;

      components.forEach(function (c) {
        c.attrs.stroke = _this4.annotation.color;
      });

      if (this.editMode) {
        handles = this.mapHandles([{ x: 0, y: 0, drag: this.dragNote.bind(this) }]);
        components.push({ type: "handle", handles: handles });

        var dragging = this.dragNote.bind(this),
            start = this.dragstarted.bind(this),
            end = this.dragended.bind(this);
        this.note.call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
          return start(d);
        }).on("drag", function (d) {
          return dragging(d);
        }).on("end", function (d) {
          return end(d);
        }));
      } else {
        this.note.on("mousedown.drag", null);
      }
      return components;
    }
  }, {
    key: "drawNoteContent",
    value: function drawNoteContent(context) {
      var noteData = this.annotation.note;
      var padding = noteData.padding !== undefined ? noteData.padding : this.notePadding;
      var orientation = noteData.orientation || context.orientation || "topBottom";
      var lineType = noteData.lineType || context.lineType;
      var align = noteData.align || context.align || "dynamic";

      if (lineType === "vertical") orientation = "leftRight";else if (lineType === "horizontal") orientation = "topBottom";

      var noteParams = {
        padding: padding,
        bbox: context.bbox,
        offset: this.annotation.offset,
        orientation: orientation,
        align: align
      };

      var _noteAlignment = noteAlignment(noteParams),
          x = _noteAlignment.x,
          y = _noteAlignment.y;

      this.offsetCornerX = x + this.annotation.dx;
      this.offsetCornerY = y + this.annotation.dy;
      this.note && this.noteContent.attr("transform", "translate(" + x + ", " + y + ")");

      return [];
    }
  }, {
    key: "drawOnScreen",
    value: function drawOnScreen(component, drawFunction) {
      return this.drawOnSVG(component, drawFunction);
    }
  }, {
    key: "redrawSubject",
    value: function redrawSubject() {
      this.subject && this.drawOnScreen(this.subject, this.drawSubject());
    }
  }, {
    key: "redrawConnector",
    value: function redrawConnector() {
      this.connector && this.drawOnScreen(this.connector, this.drawConnector());
    }
  }, {
    key: "redrawNote",
    value: function redrawNote() {
      var bbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNoteBBox();

      this.noteContent && this.drawOnScreen(this.noteContent, this.drawNoteContent({ bbox: bbox }));
      this.note && this.drawOnScreen(this.note, this.drawNote({ bbox: bbox }));
    }
  }, {
    key: "setPosition",
    value: function setPosition() {
      var position = this.annotation.position;
      this.a.attr("transform", "translate(" + position.x + ", " + position.y + ")");
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.subject && this.subject.select("*").remove();
      this.connector && this.connector.select("*").remove();
      // this.note && this.note.select("*").remove()
    }
  }, {
    key: "setOffset",
    value: function setOffset() {
      if (this.note) {
        var offset = this.annotation.offset;
        this.note.attr("transform", "translate(" + offset.x + ", " + offset.y + ")");
      }
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors(accessors) {
      if (accessors && this.annotation.data) {
        this.mapX(accessors);
        this.mapY(accessors);
      }
      this.setPosition();
    }
  }, {
    key: "setClassName",
    value: function setClassName() {
      this.a.attr("class", "annotation " + (this.className && this.className()) + " " + (this.editMode ? "editable" : "") + " " + (this.annotation.className || ""));
    }
  }, {
    key: "draw",
    value: function draw() {
      this.setClassName();
      this.setPosition();
      this.setOffset();
      this.redrawSubject();
      this.redrawConnector();
      this.redrawNote();
    }
  }, {
    key: "dragstarted",
    value: function dragstarted() {
      d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.sourceEvent.stopPropagation();
      this.dispatcher && this.dispatcher.call("dragstart", this.a, this.annotation);
      this.a.classed("dragging", true);
      this.a.selectAll("circle.handle").style("pointer-events", "none");
    }
  }, {
    key: "dragended",
    value: function dragended() {
      this.dispatcher && this.dispatcher.call("dragend", this.a, this.annotation);
      this.a.classed("dragging", false);
      this.a.selectAll("circle.handle").style("pointer-events", "all");
    }
  }, {
    key: "dragSubject",
    value: function dragSubject() {
      var position = this.annotation.position;
      position.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      position.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.position = position;
    }
  }, {
    key: "dragNote",
    value: function dragNote() {
      var offset = this.annotation.offset;
      offset.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      offset.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.offset = offset;
    }
  }, {
    key: "mapHandles",
    value: function mapHandles(handles) {
      var _this5 = this;

      return handles.map(function (h) {
        return _extends({}, h, {
          start: _this5.dragstarted.bind(_this5),
          end: _this5.dragended.bind(_this5)
        });
      });
    }
  }]);
  return Type;
}();

var customType = function customType(initialType, typeSettings, _init) {
  return function (_initialType) {
    inherits(customType, _initialType);

    function customType(settings) {
      classCallCheck(this, customType);

      var _this6 = possibleConstructorReturn(this, (customType.__proto__ || Object.getPrototypeOf(customType)).call(this, settings));

      _this6.typeSettings = typeSettings;

      if (typeSettings.disable) {
        typeSettings.disable.forEach(function (d) {
          _this6[d] && _this6[d].remove();

          _this6[d] = undefined;
          if (d === "note") {
            _this6.noteContent = undefined;
          }
        });
      }
      return _this6;
    }

    createClass(customType, [{
      key: "className",
      value: function className() {
        return "" + (typeSettings.className || get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this) && get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this).call(this) || "");
      }
    }, {
      key: "drawSubject",
      value: function drawSubject(context) {
        this.typeSettings.subject = _extends({}, typeSettings.subject, this.typeSettings.subject);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawSubject", this).call(this, _extends({}, context, this.typeSettings.subject));
      }
    }, {
      key: "drawConnector",
      value: function drawConnector(context) {
        this.typeSettings.connector = _extends({}, typeSettings.connector, this.typeSettings.connector);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawConnector", this).call(this, _extends({}, context, typeSettings.connector, this.typeSettings.connector));
      }
    }, {
      key: "drawNote",
      value: function drawNote(context) {
        this.typeSettings.note = _extends({}, typeSettings.note, this.typeSettings.note);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNote", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }, {
      key: "drawNoteContent",
      value: function drawNoteContent(context) {
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNoteContent", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }], [{
      key: "init",
      value: function init(annotation, accessors) {
        get(customType.__proto__ || Object.getPrototypeOf(customType), "init", this).call(this, annotation, accessors);
        if (_init) {
          annotation = _init(annotation, accessors);
        }
        return annotation;
      }
    }]);
    return customType;
  }(initialType);
};

var d3NoteText = function (_Type) {
  inherits(d3NoteText, _Type);

  function d3NoteText(params) {
    classCallCheck(this, d3NoteText);

    var _this7 = possibleConstructorReturn(this, (d3NoteText.__proto__ || Object.getPrototypeOf(d3NoteText)).call(this, params));

    _this7.textWrap = params.textWrap || 120;
    _this7.drawText();
    return _this7;
  }

  createClass(d3NoteText, [{
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.textWrap = textWrap;
      this.drawText();
    }

    //TODO: add update text functionality

  }, {
    key: "drawText",
    value: function drawText() {
      if (this.note) {
        newWithClass(this.note, [this.annotation], "g", "annotation-note-content");

        var noteContent = this.note.select("g.annotation-note-content");
        newWithClass(noteContent, [this.annotation], "rect", "annotation-note-bg");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-label");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-title");

        var titleBBox = { height: 0 };
        var label = this.a.select("text.annotation-note-label");
        var wrapLength = this.annotation.note && this.annotation.note.wrap || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrap || this.textWrap;

        var wrapSplitter = this.annotation.note && this.annotation.note.wrapSplitter || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrapSplitter;

        var bgPadding = this.annotation.note && this.annotation.note.bgPadding || this.typeSettings && this.typeSettings.note && this.typeSettings.note.bgPadding;

        var bgPaddingFinal = { top: 0, bottom: 0, left: 0, right: 0 };
        if (typeof bgPadding === "number") {
          bgPaddingFinal = {
            top: bgPadding,
            bottom: bgPadding,
            left: bgPadding,
            right: bgPadding
          };
        } else if (bgPadding && (typeof bgPadding === "undefined" ? "undefined" : _typeof(bgPadding)) === "object") {
          bgPaddingFinal = _extends(bgPaddingFinal, bgPadding);
        }

        if (this.annotation.note.title) {
          var title = this.a.select("text.annotation-note-title");
          title.text(this.annotation.note.title);
          title.attr("fill", this.annotation.color);
          title.attr("font-weight", "bold");
          title.call(wrap, wrapLength, wrapSplitter);
          titleBBox = title.node().getBBox();
        }

        label.text(this.annotation.note.label).attr("dx", "0");
        label.call(wrap, wrapLength, wrapSplitter);

        label.attr("y", titleBBox.height * 1.1 || 0);
        label.attr("fill", this.annotation.color);

        var bbox = this.getNoteBBox();

        this.a.select("rect.annotation-note-bg").attr("width", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right).attr("height", bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom).attr("x", bbox.x - bgPaddingFinal.left).attr("y", -bgPaddingFinal.top).attr("fill", "white").attr("fill-opacity", 0);
      }
    }
  }]);
  return d3NoteText;
}(Type);

var d3Label = customType(d3NoteText, {
  className: "label",
  note: { align: "middle" }
});

var d3Callout = customType(d3NoteText, {
  className: "callout",
  note: { lineType: "horizontal" }
});

var d3CalloutElbow = customType(d3Callout, {
  className: "callout elbow",
  connector: { type: "elbow" }
});

var d3CalloutCurve = customType(d3Callout, {
  className: "callout curve",
  connector: { type: "curve" }
});

var d3Badge = customType(Type, {
  className: "badge",
  subject: { type: "badge" },
  disable: ["connector", "note"]
});

var d3CalloutCircle = customType(d3NoteText, {
  className: "callout circle",
  subject: { type: "circle" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var d3CalloutRect = customType(d3NoteText, {
  className: "callout rect",
  subject: { type: "rect" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var ThresholdMap = function (_d3Callout) {
  inherits(ThresholdMap, _d3Callout);

  function ThresholdMap() {
    classCallCheck(this, ThresholdMap);
    return possibleConstructorReturn(this, (ThresholdMap.__proto__ || Object.getPrototypeOf(ThresholdMap)).apply(this, arguments));
  }

  createClass(ThresholdMap, [{
    key: "mapY",
    value: function mapY(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapY", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {
        a.y = accessors.y(a.data);
      }
      if ((a.subject.x1 || a.subject.x2) && !a.x) {
        a.x = a.subject.x1 || a.subject.x2;
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapX", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {
        a.x = accessors.x(a.data);
      }
      if ((a.subject.y1 || a.subject.y2) && !a.y) {
        a.y = a.subject.y1 || a.subject.y2;
      }
    }
  }]);
  return ThresholdMap;
}(d3Callout);

var d3XYThreshold = customType(ThresholdMap, {
  className: "callout xythreshold",
  subject: { type: "threshold" }
});

var newWithClass = function newWithClass(a, d, type, className, classID) {
  var group = a.selectAll(type + "." + (classID || className)).data(d);
  group.enter().append(type).merge(group).attr("class", className);

  group.exit().remove();
  return a;
};

var addHandlers = function addHandlers(dispatcher, annotation, _ref3) {
  var component = _ref3.component,
      name = _ref3.name;

  if (component) {
    component.on("mouseover.annotations", function () {
      dispatcher.call(name + "over", component, annotation);
    }).on("mouseout.annotations", function () {
      return dispatcher.call(name + "out", component, annotation);
    }).on("click.annotations", function () {
      return dispatcher.call(name + "click", component, annotation);
    });
  }
};

//Text wrapping code adapted from Mike Bostock
var wrap = function wrap(text, width, wrapSplitter) {
  var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.2;

  text.each(function () {
    var text = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this),
        words = text.text().split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
      return w !== "";
    });
    var word = void 0,
        line$$1 = [],
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", 0.8 + "em");

    while (word = words.pop()) {
      line$$1.push(word);
      tspan.text(line$$1.join(" "));
      if (tspan.node().getComputedTextLength() > width && line$$1.length > 1) {
        line$$1.pop();
        tspan.text(line$$1.join(" "));
        line$$1 = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + "em").text(word);
      }
    }
  });
};

var bboxWithoutHandles = function bboxWithoutHandles(selection) {
  var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ":not(.handle)";

  if (!selection) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }

  return selection.selectAll(selector).nodes().reduce(function (p, c) {
    var bbox = c.getBBox();
    p.x = Math.min(p.x, bbox.x);
    p.y = Math.min(p.y, bbox.y);
    p.width = Math.max(p.width, bbox.width);

    var yOffset = c && c.attributes && c.attributes.y;
    p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
    return p;
  }, { x: 0, y: 0, width: 0, height: 0 });
};

function annotation() {
  var annotations = [],
      collection = void 0,
      context = void 0,
      //TODO: add canvas functionality
  disable = [],
      accessors = {},
      accessorsInverse = {},
      editMode = false,
      ids = void 0,
      type = d3Callout,
      textWrap = void 0,
      notePadding = void 0,
      annotationDispatcher = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_3__.dispatch)("subjectover", "subjectout", "subjectclick", "connectorover", "connectorout", "connectorclick", "noteover", "noteout", "noteclick", "dragend", "dragstart"),
      sel = void 0;

  var annotation = function annotation(selection) {
    sel = selection;
    //TODO: check to see if this is still needed
    if (!editMode) {
      selection.selectAll("circle.handle").remove();
    }

    var translatedAnnotations = annotations.map(function (a) {
      if (!a.type) {
        a.type = type;
      }
      if (!a.disable) {
        a.disable = disable;
      }
      return new Annotation(a);
    });

    collection = collection || new AnnotationCollection({
      annotations: translatedAnnotations,
      accessors: accessors,
      accessorsInverse: accessorsInverse,
      ids: ids
    });

    var annotationG = selection.selectAll("g").data([collection]);
    annotationG.enter().append("g").attr("class", "annotations");

    var group = selection.select("g.annotations");
    newWithClass(group, collection.annotations, "g", "annotation");

    var annotation = group.selectAll("g.annotation");

    annotation.each(function (d) {
      var a = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this);

      a.attr("class", "annotation");

      newWithClass(a, [d], "g", "annotation-connector");
      newWithClass(a, [d], "g", "annotation-subject");
      newWithClass(a, [d], "g", "annotation-note");
      newWithClass(a.select("g.annotation-note"), [d], "g", "annotation-note-content");
      d.type = d.type.toString() === "[object Object]" ? d.type : new d.type({
        a: a,
        annotation: d,
        textWrap: textWrap,
        notePadding: notePadding,
        editMode: editMode,
        dispatcher: annotationDispatcher,
        accessors: accessors
      });
      d.type.draw();
      d.type.drawText && d.type.drawText();
    });
  };

  annotation.json = function () {
    /* eslint-disable no-console */
    console.log("Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.", collection.json);
    /* eslint-enable no-console */
    window.copy(JSON.stringify(collection.json.map(function (a) {
      delete a.type;
      return a;
    })));
    return annotation;
  };

  annotation.update = function () {
    if (annotations && collection) {
      annotations = collection.annotations.map(function (a) {
        a.type.draw();
        return a;
      });
    }
    return annotation;
  };

  annotation.updateText = function () {
    if (collection) {
      collection.updateText(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.updatedAccessors = function () {
    collection.setPositionWithAccessors();
    annotations = collection.annotations;
    return annotation;
  };

  annotation.disable = function (_) {
    if (!arguments.length) return disable;
    disable = _;
    if (collection) {
      collection.updateDisable(disable);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    if (collection) {
      collection.updateTextWrap(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.notePadding = function (_) {
    if (!arguments.length) return notePadding;
    notePadding = _;
    if (collection) {
      collection.updateNotePadding(notePadding);
      annotations = collection.annotations;
    }
    return annotation;
  };
  //todo think of how to handle when undefined is sent
  annotation.type = function (_, settings) {
    if (!arguments.length) return type;
    type = _;
    if (collection) {
      collection.annotations.map(function (a) {
        a.type.note && a.type.note.selectAll("*:not(.annotation-note-content)").remove();
        a.type.noteContent && a.type.noteContent.selectAll("*").remove();
        a.type.subject && a.type.subject.selectAll("*").remove();
        a.type.connector && a.type.connector.selectAll("*").remove();
        a.type.typeSettings = {};
        a.type = type;

        a.subject = settings && settings.subject || a.subject;
        a.connector = settings && settings.connector || a.connector;
        a.note = settings && settings.note || a.note;
      });

      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.annotations = function (_) {
    if (!arguments.length) return collection && collection.annotations || annotations;
    annotations = _;

    if (collection && collection.annotations) {
      var rerun = annotations.some(function (d) {
        return !d.type || d.type.toString() !== "[object Object]";
      });

      if (rerun) {
        collection = null;
        annotation(sel);
      } else {
        collection.annotations = annotations;
      }
    }
    return annotation;
  };

  annotation.context = function (_) {
    if (!arguments.length) return context;
    context = _;
    return annotation;
  };

  annotation.accessors = function (_) {
    if (!arguments.length) return accessors;
    accessors = _;
    return annotation;
  };

  annotation.accessorsInverse = function (_) {
    if (!arguments.length) return accessorsInverse;
    accessorsInverse = _;
    return annotation;
  };

  annotation.ids = function (_) {
    if (!arguments.length) return ids;
    ids = _;
    return annotation;
  };

  annotation.editMode = function (_) {
    if (!arguments.length) return editMode;
    editMode = _;

    if (sel) {
      sel.selectAll("g.annotation").classed("editable", editMode);
    }

    if (collection) {
      collection.editMode(editMode);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.collection = function (_) {
    if (!arguments.length) return collection;
    collection = _;
    return annotation;
  };

  annotation.on = function () {
    var value = annotationDispatcher.on.apply(annotationDispatcher, arguments);
    return value === annotationDispatcher ? annotation : value;
  };

  return annotation;
}

var index = {
  annotation: annotation,
  annotationTypeBase: Type,
  annotationLabel: d3Label,
  annotationCallout: d3Callout,
  annotationCalloutCurve: d3CalloutCurve,
  annotationCalloutElbow: d3CalloutElbow,
  annotationCalloutCircle: d3CalloutCircle,
  annotationCalloutRect: d3CalloutRect,
  annotationXYThreshold: d3XYThreshold,
  annotationBadge: d3Badge,
  annotationCustomType: customType
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);
//# sourceMappingURL=indexRollupNext.js.map


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dispatch: () => (/* reexport safe */ _src_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js");



/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.x, y: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__.dispatch)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__.mouse, this, arguments);
    if (!gesture) return;
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
    mousemoving = false;
    mousedownx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX;
    mousedowny = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    if (!mousemoving) {
      var dx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX - mousedownx, dy = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag mouseup.drag", null);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__.yesdrag)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view, mousemoving);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__.touch, this, arguments)) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragEvent)
/* harmony export */ });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drag: () => (/* reexport safe */ _drag__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   dragDisable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   dragEnable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__.yesdrag)
/* harmony export */ });
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");




/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (path);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clientPoint: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   create: () => (/* reexport safe */ _create__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   creator: () => (/* reexport safe */ _creator__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   customEvent: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.customEvent),
/* harmony export */   event: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.event),
/* harmony export */   local: () => (/* reexport safe */ _local__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   matcher: () => (/* reexport safe */ _matcher__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mouse: () => (/* reexport safe */ _mouse__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   namespace: () => (/* reexport safe */ _namespace__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   namespaces: () => (/* reexport safe */ _namespaces__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   select: () => (/* reexport safe */ _select__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   selectAll: () => (/* reexport safe */ _selectAll__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   selection: () => (/* reexport safe */ _selection_index__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   selector: () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   selectorAll: () => (/* reexport safe */ _selectorAll__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   style: () => (/* reexport safe */ _selection_style__WEBPACK_IMPORTED_MODULE_13__.styleValue),
/* harmony export */   touch: () => (/* reexport safe */ _touch__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   touches: () => (/* reexport safe */ _touches__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   window: () => (/* reexport safe */ _window__WEBPACK_IMPORTED_MODULE_16__["default"])
/* harmony export */ });
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js");
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mouse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js");
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _selection_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./touch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js");
/* harmony import */ var _touches__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./touches */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js");
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");




















/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ local)
/* harmony export */ });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  var event = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js");




var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./join */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sort */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./call */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodes */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./node */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./size */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./empty */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./each */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./property */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classed */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./text */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./html */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./raise */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lower */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./append */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./insert */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./datum */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js");
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  join: _join__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_8__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_9__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_10__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_11__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_12__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_13__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_14__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_15__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_16__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_17__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_18__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_19__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_20__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_21__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_22__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_23__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_24__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_25__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_26__["default"],
  clone: _clone__WEBPACK_IMPORTED_MODULE_27__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_28__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_29__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_30__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customEvent: () => (/* binding */ customEvent),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   event: () => (/* binding */ event)
/* harmony export */ });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches) {
  if (touches == null) touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arc: () => (/* reexport safe */ _src_arc__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   area: () => (/* reexport safe */ _src_area__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   curveBasis: () => (/* reexport safe */ _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   curveBasisClosed: () => (/* reexport safe */ _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   curveBasisOpen: () => (/* reexport safe */ _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   curveBundle: () => (/* reexport safe */ _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   curveCardinal: () => (/* reexport safe */ _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   curveCardinalClosed: () => (/* reexport safe */ _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   curveCardinalOpen: () => (/* reexport safe */ _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   curveCatmullRom: () => (/* reexport safe */ _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   curveCatmullRomClosed: () => (/* reexport safe */ _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   curveCatmullRomOpen: () => (/* reexport safe */ _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   curveLinear: () => (/* reexport safe */ _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   curveLinearClosed: () => (/* reexport safe */ _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   curveMonotoneX: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneX),
/* harmony export */   curveMonotoneY: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneY),
/* harmony export */   curveNatural: () => (/* reexport safe */ _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   curveStep: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   curveStepAfter: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepAfter),
/* harmony export */   curveStepBefore: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepBefore),
/* harmony export */   line: () => (/* reexport safe */ _src_line__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   pie: () => (/* reexport safe */ _src_pie__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   radialArea: () => (/* reexport safe */ _src_radialArea__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   radialLine: () => (/* reexport safe */ _src_radialLine__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   stack: () => (/* reexport safe */ _src_stack__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   stackOffsetExpand: () => (/* reexport safe */ _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   stackOffsetNone: () => (/* reexport safe */ _src_offset_none__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   stackOffsetSilhouette: () => (/* reexport safe */ _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   stackOffsetWiggle: () => (/* reexport safe */ _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   stackOrderAscending: () => (/* reexport safe */ _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   stackOrderDescending: () => (/* reexport safe */ _src_order_descending__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   stackOrderInsideOut: () => (/* reexport safe */ _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   stackOrderNone: () => (/* reexport safe */ _src_order_none__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   stackOrderReverse: () => (/* reexport safe */ _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   symbol: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   symbolCircle: () => (/* reexport safe */ _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   symbolCross: () => (/* reexport safe */ _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   symbolDiamond: () => (/* reexport safe */ _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   symbolSquare: () => (/* reexport safe */ _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   symbolStar: () => (/* reexport safe */ _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   symbolTriangle: () => (/* reexport safe */ _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   symbolWye: () => (/* reexport safe */ _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   symbols: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__.symbols)
/* harmony export */ });
/* harmony import */ var _src_arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/arc */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js");
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _src_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _src_pie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pie */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js");
/* harmony import */ var _src_radialArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/radialArea */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js");
/* harmony import */ var _src_radialLine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");
/* harmony import */ var _src_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/symbol */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/curve/basisClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/curve/basisOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/curve/basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/curve/bundle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/curve/cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/curve/cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/curve/cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/curve/catmullRomClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/curve/catmullRomOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/curve/catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/curve/linearClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/curve/monotone */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/curve/natural */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var _src_curve_step__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/curve/step */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var _src_stack__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/stack */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js");
/* harmony import */ var _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/offset/expand */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js");
/* harmony import */ var _src_offset_none__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/offset/silhouette */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js");
/* harmony import */ var _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/offset/wiggle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js");
/* harmony import */ var _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/order/ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");
/* harmony import */ var _src_order_descending__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/order/descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js");
/* harmony import */ var _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/order/insideOut */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js");
/* harmony import */ var _src_order_none__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/order/reverse */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js");












































/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function asin(x) {
  return x >= 1 ? _math__WEBPACK_IMPORTED_MODULE_1__.halfPi : x <= -1 ? -_math__WEBPACK_IMPORTED_MODULE_1__.halfPi : Math.asin(x);
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        da = Math.abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_2__["default"])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math__WEBPACK_IMPORTED_MODULE_1__.tau - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
      context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
          rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var p0 = asin(rp / r0 * Math.sin(ap)),
            p1 = asin(rp / r1 * Math.sin(ap));
        if ((da0 -= p0 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Math.cos(a01),
          y01 = r1 * Math.sin(a01),
          x10 = r0 * Math.cos(a10),
          y10 = r0 * Math.sin(a10);

      // Apply rounded corners?
      if (rc > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var x11 = r1 * Math.cos(a11),
            y11 = r1 * Math.sin(a11),
            x00 = r0 * Math.cos(a00),
            y00 = r0 * Math.sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < _math__WEBPACK_IMPORTED_MODULE_1__.pi) {
          var oc = da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
              lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) || !(da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math__WEBPACK_IMPORTED_MODULE_1__.pi / 2;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x0 = _point__WEBPACK_IMPORTED_MODULE_3__.x,
      x1 = null,
      y0 = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      y1 = _point__WEBPACK_IMPORTED_MODULE_3__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line__WEBPACK_IMPORTED_MODULE_2__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Basis: () => (/* binding */ Basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Basis(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisOpen(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cardinal: () => (/* binding */ Cardinal),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalClosed: () => (/* binding */ CardinalClosed),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalOpen: () => (/* binding */ CardinalOpen),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal__WEBPACK_IMPORTED_MODULE_1__.Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_2__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new LinearClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   monotoneX: () => (/* binding */ monotoneX),
/* harmony export */   monotoneY: () => (/* binding */ monotoneY)
/* harmony export */ });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Natural(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   curveRadialLinear: () => (/* binding */ curveRadialLinear),
/* harmony export */   "default": () => (/* binding */ curveRadial)
/* harmony export */ });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");


var curveRadialLinear = curveRadial(_linear__WEBPACK_IMPORTED_MODULE_0__["default"]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   stepAfter: () => (/* binding */ stepAfter),
/* harmony export */   stepBefore: () => (/* binding */ stepBefore)
/* harmony export */ });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x = _point__WEBPACK_IMPORTED_MODULE_2__.x,
      y = _point__WEBPACK_IMPORTED_MODULE_2__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_3__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sum: () => (/* binding */ sum)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var sums = series.map(sum);
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending__WEBPACK_IMPORTED_MODULE_1__.sum),
      order = (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_2__["default"],
      sortValues = _descending__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      endAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(_math__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _radialLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var a = (0,_area__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return a;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   radialLine: () => (/* binding */ radialLine)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");



function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return radialLine((0,_line__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _offset_none__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _order_none__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var keys = (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([]),
      order = _order_none__WEBPACK_IMPORTED_MODULE_3__["default"],
      offset = _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"],
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? _order_none__WEBPACK_IMPORTED_MODULE_3__["default"] : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"] : _, stack) : offset;
  };

  return stack;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   symbols: () => (/* binding */ symbols)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _symbol_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_star__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye__WEBPACK_IMPORTED_MODULE_6__["default"]
];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var type = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"]),
      size = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_8__["default"])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / Math.sin(7 * _math__WEBPACK_IMPORTED_MODULE_0__.pi / 10),
    kx = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr,
    ky = -Math.cos(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var sqrt3 = Math.sqrt(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./node_modules/internmap/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/internmap/src/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternMap: () => (/* binding */ InternMap),
/* harmony export */   InternSet: () => (/* binding */ InternSet)
/* harmony export */ });
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (entries != null) for (const [key, value] of entries) this.set(key, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}

class InternSet extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (values != null) for (const value of values) this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
}

function intern_get({_intern, _key}, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}

function intern_delete({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}

function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}


/***/ }),

/***/ "./node_modules/jsonstat-toolkit/import.mjs":
/*!**************************************************!*\
  !*** ./node_modules/jsonstat-toolkit/import.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ r)
/* harmony export */ });
// jsonstat-toolkit v1.5.3 Copyright 2024 Xavier Badosa https://jsonstat.com
function t(i,r){var l,s,a,o,u=function(t,i,r){if(0===Object.entries(t).length)return null;var l,s=[];if(r&&!n(r.name)&&(r=null),"string"==typeof t&&(t=[t]),Array.isArray(t)||e(t)){if(t.length===i)return r&&-1===t.findIndex((function(t){return null==t}))?r.from(t):t;if(1===t.length){for(l=0;l<i;l++)s.push(t[0]);return s}}for(l=0;l<i;l++){var a=void 0===t[l]?null:t[l];s.push(a)}return s};if(this.length=0,this.id=[],null!=i)switch(this.class=i.class||"bundle",this.class){case"bundle":var h=[],f=0;if(this.error=null,this.length=0,null===i||"object"!=typeof i)return void(this.class=null);if(i.hasOwnProperty("error"))return void(this.error=i.error);if("dataset"===i.class||"collection"===i.class||"dimension"===i.class)return new t(i);for(s in i)f++,h.push(s);this.__tree__=i,this.length=f,this.id=h;break;case"dataset":i.hasOwnProperty("__tree__")?this.__tree__=l=i.__tree__:this.__tree__=l=i,this.label=l.label||null,this.note=l.note||null,this.link=l.link||null,this.href=l.href||null,this.updated=l.updated||null,this.source=l.source||null,this.extension=l.extension||null;var c,d=0,v=l.size||l.dimension&&l.dimension.size;if(this.size=v,this.value=l.hasOwnProperty("value")&&null!==l.value&&0!==l.value.length?l.value:{},Array.isArray(this.value)||e(this.value))d=this.value.length;else{var y=1;for(c=v.length;c--;)y*=v[c];d=y}if(this.value=u(this.value,d,r),this.status=l.hasOwnProperty("status")&&null!==l.status?u(l.status,d):null,l.hasOwnProperty("dimension")){var p=l.dimension,g=l.role||!l.version&&p.role||null,b=l.id||p.id,m=v.length,_=function(t){g.hasOwnProperty(t)||(g[t]=null)};if(!Array.isArray(b)||!Array.isArray(v)||b.length!=m)return;if(this.length=m,this.id=b,g&&(_("time"),_("geo"),_("metric"),_("classification")),g&&null===g.classification){var x=[],O=["time","geo","metric"],A=function(t,e){for(var n=e.length;n--;)if(t===e[n])return!0;return!1};for(c=0;c<3;c++){var w=g[O[c]];null!==w&&(x=x.concat(w))}for(g.classification=[],c=0;c<m;c++)A(b[c],x)||g.classification.push(b[c]);0===g.classification.length&&(g.classification=null)}this.role=g,this.n=d;for(var j=0,k=this.length;j<k;j++)if(p[b[j]].category.hasOwnProperty("index")){if(Array.isArray(p[b[j]].category.index)){var D={},P=p[b[j]].category.index;for(a=P.length,o=0;o<a;o++)D[P[o]]=o;p[b[j]].category.index=D}}else{var E=0;for(s in p[b[j]].category.index={},p[b[j]].category.label)p[b[j]].category.index[s]=E++}}else this.length=0;break;case"dimension":if(!i.hasOwnProperty("__tree__"))return new t({version:"2.0",class:"dataset",dimension:{d:i},id:["d"],size:[function(t){var e=void 0===t.index?t.label:t.index;return Array.isArray(e)?e.length:Object.keys(e).length}(i.category)],value:[null]}).Dimension(0);var z=[],S=(l=i.__tree__).category;if(!l.hasOwnProperty("category"))return;if(!S.hasOwnProperty("label"))for(s in S.label={},S.index)S.label[s]=s;for(s in S.index)z[S.index[s]]=s;this.__tree__=l,this.label=l.label||null,this.note=l.note||null,this.link=l.link||null,this.href=l.href||null,this.id=z,this.length=z.length,this.role=i.role,this.hierarchy=S.hasOwnProperty("child"),this.extension=l.extension||null;break;case"category":var I=i.child;this.id=I,this.length=null===I?0:I.length,this.index=i.index,this.label=i.label,this.note=i.note||null,this.unit=i.unit,this.coordinates=i.coord;break;case"collection":if(this.length=0,this.label=i.label||null,this.note=i.note||null,this.link=i.link||null,this.href=i.href||null,this.updated=i.updated||null,this.source=i.source||null,this.extension=i.extension||null,null!==this.link&&i.link.item){var C=i.link.item;if(this.length=Array.isArray(C)?C.length:0,this.length)for(o=0;o<this.length;o++)this.id[o]=C[o].href}}}function e(t){return"[object ArrayBuffer]"===Object.prototype.toString.call(t.buffer)}function n(t){return-1!==["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"].indexOf(t)}function i(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.json()}function r(e,n,r){var l="object"==typeof n?n:null;return"function"!=typeof r&&(r=null),r||"function"!=typeof n||(r=n),"object"==typeof e?new t(e,r):"version"===e?"1.5.3":fetch?fetch(e,l).then(i).then((function(e){return new t(e,r)})):void 0}t.prototype.Item=function(t){if(null===this||"collection"!==this.class||!this.length)return null;if("number"==typeof t)return t>this.length||t<0?null:this.link.item[t];var e,n=[];if("object"==typeof t){if(!t.class&&!t.follow)return null;t.class&&(e="dataset"===t.class&&"boolean"==typeof t.embedded?!0===t.embedded?function(t,e,i){var r=t.link.item[e];i.class===r.class&&r.id&&r.size&&r.dimension&&n.push(r)}:function(t,e,i){var r=t.link.item[e];i.class!==r.class||r.id&&r.size&&r.dimension||n.push(r)}:function(t,e,i){i.class===t.link.item[e].class&&n.push(t.link.item[e])})}else e=function(t,e){n.push(t.link.item[e])};for(var i=0;i<this.length;i++)e(this,i,t);return n},t.prototype.Dataset=function(e){if(null===this)return null;if("dataset"===this.class)return void 0!==e?this:[this];var n,i=[],r=0;if("collection"===this.class){var l=this.Item({class:"dataset",embedded:!0});if(void 0===e){for(n=l.length;r<n;r++)i.push(new t(l[r]));return i}if("number"==typeof e&&e>=0&&e<l.length)return new t(l[e]);if("string"==typeof e)for(n=l.length;r<n;r++)if(l[r].href===e)return new t(l[r]);return null}if("bundle"!==this.class)return null;if(void 0===e){for(n=this.id.length;r<n;r++)i.push(this.Dataset(this.id[r]));return i}if("number"==typeof e){var s=this.id[e];return void 0!==s?this.Dataset(s):null}var a=this.__tree__[e];return void 0===a?null:new t({class:"dataset",__tree__:a})},t.prototype.Dimension=function(e,n){n="boolean"!=typeof n||n;var i,r=[],l=this.id.length,s=function(t,e){if(null!==t)for(var n in t)for(var i=null!==t[n]?t[n].length:0;i--;)if(t[n][i]===e)return n;return null};if(null===this||"dataset"!==this.class)return null;if(void 0===e){for(i=0;i<l;i++)r.push(this.Dimension(this.id[i]));return r}if("number"==typeof e){var a=this.id[e];return void 0!==a?this.Dimension(a,n):null}var o=this.role;if("object"==typeof e){if(e.hasOwnProperty("role")){for(i=0;i<l;i++){var u=this.id[i];s(o,u)===e.role&&r.push(this.Dimension(u,n))}return void 0===r[0]?null:r}return null}var h=this.__tree__.dimension;if(void 0===h)return null;var f=h[e];return void 0===f?null:n?new t({class:"dimension",__tree__:f,role:s(o,e)}):function(t,e){var n=[];for(var i in t)n[t[i]]=e[i];return n}(f.category.index,f.category.label)},t.prototype.Category=function(e){if(null===this||"dimension"!==this.class)return null;if(void 0===e){for(var n=[],i=0,r=this.id.length;i<r;i++)n.push(this.Category(this.id[i]));return n}if("number"==typeof e){var l=this.id[e];return void 0!==l?this.Category(l):null}var s=this.__tree__.category;if(void 0===s)return null;var a=s.index[e];if(void 0===a)return null;var o=s.unit&&s.unit[e]||null,u=s.coordinates&&s.coordinates[e]||null,h=s.child&&s.child[e]||null,f=s.note&&s.note[e]||null;return new t({class:"category",index:a,label:s.label[e],note:f,child:h,unit:o,coord:u})},t.prototype.Dice=function(n,i,r){var l,s,a,o,u=function(t,e){return t.hasOwnProperty(e)&&!!t[e]};if(null===this||"dataset"!==this.class||null===this.value)return null;if("object"!=typeof n)return this;"object"!=typeof i?("boolean"==typeof i&&!0===i&&(l=!0),"boolean"==typeof r&&!0===r||(r=!1)):(l=u(i,"clone"),r=u(i,"drop"),s=u(i,"stringify"),a=u(i,"ovalue"),o=u(i,"ostatus"));var h,f=this.value,c=l?new t(JSON.parse(JSON.stringify(this))):this,d=c.status,v=[],y=[],p=function(t,e){var n,i,r,l=(n=t,i=e,r={},Array.isArray(n[i])?(n[i].forEach((function(t,e){null!==t&&(r[String(e)]=t)})),r):n[i]);delete t[e],t[e]=l};Array.isArray(n)&&(n=function(t){var e={};return t.forEach((function(t){e[t[0]]=t[1]})),e}(n)),null===n&&(n={});var g=Object.keys(n);return g.length>0&&(g.forEach((function(t){var e=n[t];Array.isArray(e)||(n[t]=[e]),0===n[t].length&&delete n[t]})),r&&(n=function(t){var e={};return Object.keys(t).forEach((function(n){e[n]=c.Dimension(n).id.filter((function(e){return-1===t[n].indexOf(e)}))})),e}(n)),c.toTable({type:"arrobj",content:"id",status:!0}).forEach((function(t,e){var i=[];g.forEach((function(e){var r=n[e],l=[];r.forEach((function(n){l.push(t[e]===n)})),i.push(-1!==l.indexOf(!0))})),-1===i.indexOf(!1)&&(v.push(t.value),y.push(t.status))})),g.forEach((function(t){var e=c.Dimension(t).id,i=0,r={};c.size[c.id.indexOf(t)]=n[t].length,e.forEach((function(e){-1!==n[t].indexOf(e)&&(r[e]=i,i++)})),c.__tree__.dimension[t].category.index=r})),c.n=v.length,c.value=c.__tree__.value=e(f)?function(t,e){return e.from(t)}(v,f.constructor):v,c.status=c.__tree__.status=null!==d?y:null),s?((h=c.__tree__).hasOwnProperty("id")||(h.version="2.0",h.hasOwnProperty("class")||(h.class="dataset"),h.id=h.dimension.id,h.size=h.dimension.size,delete h.dimension.id,delete h.dimension.size,h.dimension.hasOwnProperty("role")&&(h.role=h.dimension.role,delete h.dimension.role)),h.hasOwnProperty("status")&&-1!==["null","{}","[]"].indexOf(JSON.stringify(h.status))&&delete h.status,h.hasOwnProperty("role")&&(delete h.role.classification,["geo","time","metric"].forEach((function(t){null===h.role[t]&&delete h.role[t]}))),a&&p(h,"value"),o&&h.hasOwnProperty("status")&&p(h,"status"),JSON.stringify(h)):c},t.prototype.Slice=function(t){if(null===this||"dataset"!==this.class||0===Object.entries(this.value).length)return null;if(void 0===t)return this;if(!Array.isArray(t)){var e,n=[];for(e in t)n.push([e,t[e]]);t=n}return this.Dice(t.map((function(t){return[t[0],[t[1]]]})))},t.prototype.Data=function(t,e){var n,i,r=[],l=function(t){for(var e in t)if(t.hasOwnProperty(e))return e};if(null===this||"dataset"!==this.class||null===this.value)return null;if(void 0===t){for(i=this.value.length,n=0;n<i;n++)r.push(this.Data(n));return r}if("boolean"!=typeof e&&(e=!0),"number"==typeof t){var s=this.value[t];return void 0===s?null:e?{value:s,status:this.status?this.status[t]:null}:s}var a="object",o=this.__tree__,u=o.size||o.dimension&&o.dimension.size,h=u.length;if(Array.isArray(t)){if(!Array.isArray(t[0])){if(this.length!==t.length)return null;var f=1,c=0,d=[],v=[];for(n=0;n<h;n++)if(void 0!==t[n]){if("number"!=typeof t[n]||t[n]>=u[n])return null;c+=(f*=n>0?u[h-n]:1)*t[h-n-1]}else d.push(n),v.push(u[n]);if(d.length>1)return null;if(1===d.length){for(var y=0,p=v[0];y<p;y++){var g=[];for(n=0;n<h;n++)n!==d[0]?g.push(t[n]):g.push(y);r.push(this.Data(g,e))}return r}return e?{value:this.value[c],status:this.status?this.status[c]:null}:this.value[c]}a="array"}var b=function(t,e,n){var i,r=[],s={},a=t.dimension,o=t.id||a.id,u=t.size||a&&a.size;if("array"===n){for(i=e.length;i--;)s[e[i][0]]=e[i][1];e=s}for(var h=0,f=o.length;h<f;h++){var c=o[h],d=e[c];r.push("string"==typeof d?d:1===u[h]?l(a[c].category.index):null)}return r}(o,t,a),m=[],_=o.dimension,x=o.id||_.id;for(n=0,i=b.length;n<i;n++)m.push(_[x[n]].category.index[b[n]]);return this.Data(m,e)},t.prototype.toTable=function(t,e){if(null===this||"dataset"!==this.class||null===this.value)return null;1==arguments.length&&"function"==typeof t&&(e=t,t=null),"arrobj"!==(t=t||{field:"label",content:"label",vlabel:"Value",slabel:"Status",type:"array",status:!1,unit:!1,by:null,prefix:"",drop:[],meta:!1,comma:!1,bylabel:!1}).type&&"objarr"!==t.type||void 0!==t.field||(t.field="id");var i,r,l,s,a,o,u,h,f,c="id"===t.field,d=function(t){return(c?"value":t)||"Value"},v=function(t){return(c?"status":t)||"Status"},y=this.__tree__,p=!0===t.status;if("function"==typeof e){i=this.toTable(t);var g=[],b="array"!==t.type?0:1;for(a=(V="object"!==t.type?i.slice(b):i.rows.slice(0)).length,r=0;r<a;r++){var m=e.call(this,V[r],r);void 0!==m&&g.push(m)}return"object"===t.type?{cols:i.cols,rows:g}:("array"===t.type&&g.unshift(i[0]),g)}if("arrobj"===t.type||"objarr"===t.type){var _=[],x=y.role&&y.role.metric,O=function(){},A={},w=this,j=w.id,k=t.by&&-1!==j.indexOf(t.by)?t.by:null,D=!0===t.meta,P=void 0!==t.drop&&Array.isArray(t.drop)?t.drop:[],E=!0===t.comma,z=!0===t.bylabel,S=w.value.constructor,I=function(e){var i,r={},l=d(t.vlabel);if("objarr"===t.type&&(i=null===k&&n(S.name)?function(t){r[t]=t===l?S.from(e,(function(e){return e[t]})):e.map((function(e){return e[t]}))}:function(t){r[t]=e.map((function(e){return e[t]}))},Object.keys(e[0]).forEach(i),e=r),D){r={};return j.forEach((function(t){var e=w.Dimension(t);r[t]={label:e.label,role:e.role,categories:{id:e.id,label:w.Dimension(t,!1)}}})),{meta:{label:w.label,source:w.source,updated:w.updated,id:j,status:p,unit:t.unit,by:k,bylabel:z,drop:null!==k&&P.length>0?P:null,prefix:null!==k?G||"":null,comma:E,dimensions:r},data:e}}return e};k&&(t.field="id");var C=(i=this.toTable({field:t.field,vlabel:t.vlabel,slabel:t.slabel,content:t.content,status:p})).shift();if(null===k&&t.unit&&x){if("id"!==t.content)for(var T=x.length;T--;){var U=this.Dimension(x[T]);A[x[T]]={};for(var J=U.length;J--;)A[x[T]][U.Category(J).label]=U.id[J]}O=function(e,n){if(-1!==x.indexOf(e)){var i=y.dimension[e].category;i.unit?N.unit=i.unit["id"!==t.content?A[e][n]:n]:N.unit=null}},t.unit=!0}else t.unit=!1;for(a=i.length,r=0;r<a;r++){var N={};for(l=i[r].length;l--;)N[C[l]]=i[r][l],O(C[l],i[r][l]);_.push(N)}if(E&&_.forEach((function(t){null!==t.value&&(t.value=(""+t.value).replace(".",","))})),null!==k){var B,F={},V=[],q={},G=void 0!==t.prefix?t.prefix:"";P.forEach((function(t,e){(!w.Dimension(t)||w.Dimension(t).length>1)&&(P[e]="")}));var H=j.filter((function(t){return t!==k&&-1===P.indexOf(t)})),K=w.Dimension(k);for(var L in"id"!==t.content?z?B=function(t,e,n){t[e][G+n[k]]=n.value}:(K.Category().forEach((function(t,e){q[t.label]=K.id[e]})),B=function(t,e,n){t[e][G+q[n[k]]]=n.value}):B=function(t,e,n){t[e][G+n[k]]=n.value},_.forEach((function(t){var e=function(t,e){var n=[];return e.forEach((function(e){n.push(t[e])})),n.join("\t")}(t,H);void 0===F[e]&&(F[e]=function(t,e){var n={};return e.forEach((function(e){n[e]=t[e]})),n}(t,H)),B(F,e,t,k)})),F)V.push(F[L]);return p=!1,I(V)}return I(_)}if("object"===t.type){var M="number"==typeof this.value[0]||null===this.value[0]?"number":"string";o=function(t,e){var n=c&&t||e||t;it.push({id:t,label:n,type:"string"})},u=function(t,e,n){var i=d(t),r=v(e);n&&it.push({id:"status",label:r,type:"string"}),it.push({id:"value",label:i,type:M})},h=function(t){yt.push({v:t})},f=function(t){yt.push({v:t}),rt.push({c:yt})}}else o=function(t,e){var n=c&&t||e||t;it.push(n)},u=function(t,e,n){var i=d(t),r=v(e);n&&it.push(r),it.push(i),nt.push(it)},h=function(t){yt.push(t)},f=function(t){yt.push(t),nt.push(yt)};var Q=y.dimension,R=y.id||Q.id,W=y.size||Q.size,X=R.length;if(X!=W.length)return!1;var Y=[],Z=1,$=(T=1,[]),tt=[],et=[],nt=[],it=[],rt=[];for(r=0;r<X;r++){var lt=R[r];o(lt,Q[lt].label),Z*=W[r],T*=W[r];var st=[];for(l=0;l<W[r];l++)for(var at in Q[R[r]].category.index)if(Q[R[r]].category.index[at]===l){var ot="id"!==t.content&&Q[R[r]].category.label?Q[R[r]].category.label[at]:at;st.push(ot)}Y.push(st),$.push(T)}for(u(t.vlabel,t.slabel,p),a=Y.length,r=0;r<a;r++){for(var ut=[],ht=0,ft=Y[r].length;ht<ft;ht++)for(var ct=0;ct<Z/$[r];ct++)ut.push(Y[r][ht]);tt.push(ut)}for(a=tt.length,r=0;r<a;r++){var dt=[],vt=0;for(s=0;s<Z;s++)dt.push(tt[r][vt]),++vt===tt[r].length&&(vt=0);et.push(dt)}for(s=0;s<Z;s++){var yt=[];a=tt.length;for(var pt=0;pt<a;pt++)h(et[pt][s]);p&&h(this.status?this.status[s]:null),f(this.value[s])}return"object"===t.type?{cols:it,rows:rt}:nt},t.prototype.node=function(){return this.__tree__},t.prototype.toString=function(){return this.class};


/***/ }),

/***/ "./node_modules/simple-statistics/dist/simple-statistics.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/simple-statistics/dist/simple-statistics.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BayesianClassifier: () => (/* binding */ BayesianClassifier),
/* harmony export */   PerceptronModel: () => (/* binding */ PerceptronModel),
/* harmony export */   addToMean: () => (/* binding */ addToMean),
/* harmony export */   approxEqual: () => (/* binding */ approxEqual),
/* harmony export */   average: () => (/* binding */ mean),
/* harmony export */   averageSimple: () => (/* binding */ meanSimple),
/* harmony export */   bayesian: () => (/* binding */ BayesianClassifier),
/* harmony export */   bernoulliDistribution: () => (/* binding */ bernoulliDistribution),
/* harmony export */   binomialDistribution: () => (/* binding */ binomialDistribution),
/* harmony export */   bisect: () => (/* binding */ bisect),
/* harmony export */   chiSquaredDistributionTable: () => (/* binding */ chiSquaredDistributionTable),
/* harmony export */   chiSquaredGoodnessOfFit: () => (/* binding */ chiSquaredGoodnessOfFit),
/* harmony export */   chunk: () => (/* binding */ chunk),
/* harmony export */   ckmeans: () => (/* binding */ ckmeans),
/* harmony export */   coefficientOfVariation: () => (/* binding */ coefficientOfVariation),
/* harmony export */   combinations: () => (/* binding */ combinations),
/* harmony export */   combinationsReplacement: () => (/* binding */ combinationsReplacement),
/* harmony export */   combineMeans: () => (/* binding */ combineMeans),
/* harmony export */   combineVariances: () => (/* binding */ combineVariances),
/* harmony export */   cumulativeStdLogisticProbability: () => (/* binding */ cumulativeStdLogisticProbability),
/* harmony export */   cumulativeStdNormalProbability: () => (/* binding */ cumulativeStdNormalProbability),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   equalIntervalBreaks: () => (/* binding */ equalIntervalBreaks),
/* harmony export */   erf: () => (/* binding */ errorFunction),
/* harmony export */   errorFunction: () => (/* binding */ errorFunction),
/* harmony export */   extent: () => (/* binding */ extent),
/* harmony export */   extentSorted: () => (/* binding */ extentSorted),
/* harmony export */   factorial: () => (/* binding */ factorial),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   gammaln: () => (/* binding */ gammaln),
/* harmony export */   geometricMean: () => (/* binding */ geometricMean),
/* harmony export */   harmonicMean: () => (/* binding */ harmonicMean),
/* harmony export */   interquartileRange: () => (/* binding */ interquartileRange),
/* harmony export */   inverseErrorFunction: () => (/* binding */ inverseErrorFunction),
/* harmony export */   iqr: () => (/* binding */ interquartileRange),
/* harmony export */   jenks: () => (/* binding */ jenks),
/* harmony export */   kMeansCluster: () => (/* binding */ kMeansCluster),
/* harmony export */   kde: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   kernelDensityEstimation: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   linearRegression: () => (/* binding */ linearRegression),
/* harmony export */   linearRegressionLine: () => (/* binding */ linearRegressionLine),
/* harmony export */   logAverage: () => (/* binding */ logAverage),
/* harmony export */   logit: () => (/* binding */ logit),
/* harmony export */   mad: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   maxSorted: () => (/* binding */ maxSorted),
/* harmony export */   mean: () => (/* binding */ mean),
/* harmony export */   meanSimple: () => (/* binding */ meanSimple),
/* harmony export */   median: () => (/* binding */ median),
/* harmony export */   medianAbsoluteDeviation: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   medianSorted: () => (/* binding */ medianSorted),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   minSorted: () => (/* binding */ minSorted),
/* harmony export */   mode: () => (/* binding */ mode),
/* harmony export */   modeFast: () => (/* binding */ modeFast),
/* harmony export */   modeSorted: () => (/* binding */ modeSorted),
/* harmony export */   numericSort: () => (/* binding */ numericSort),
/* harmony export */   perceptron: () => (/* binding */ PerceptronModel),
/* harmony export */   permutationTest: () => (/* binding */ permutationTest),
/* harmony export */   permutationsHeap: () => (/* binding */ permutationsHeap),
/* harmony export */   poissonDistribution: () => (/* binding */ poissonDistribution),
/* harmony export */   probit: () => (/* binding */ probit),
/* harmony export */   product: () => (/* binding */ product),
/* harmony export */   quantile: () => (/* binding */ quantile),
/* harmony export */   quantileRank: () => (/* binding */ quantileRank),
/* harmony export */   quantileRankSorted: () => (/* binding */ quantileRankSorted),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted),
/* harmony export */   quickselect: () => (/* binding */ quickselect),
/* harmony export */   rSquared: () => (/* binding */ rSquared),
/* harmony export */   relativeError: () => (/* binding */ relativeError),
/* harmony export */   rms: () => (/* binding */ rootMeanSquare),
/* harmony export */   rootMeanSquare: () => (/* binding */ rootMeanSquare),
/* harmony export */   sample: () => (/* binding */ sample),
/* harmony export */   sampleCorrelation: () => (/* binding */ sampleCorrelation),
/* harmony export */   sampleCovariance: () => (/* binding */ sampleCovariance),
/* harmony export */   sampleKurtosis: () => (/* binding */ sampleKurtosis),
/* harmony export */   sampleRankCorrelation: () => (/* binding */ sampleRankCorrelation),
/* harmony export */   sampleSkewness: () => (/* binding */ sampleSkewness),
/* harmony export */   sampleStandardDeviation: () => (/* binding */ sampleStandardDeviation),
/* harmony export */   sampleVariance: () => (/* binding */ sampleVariance),
/* harmony export */   sampleWithReplacement: () => (/* binding */ sampleWithReplacement),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   shuffleInPlace: () => (/* binding */ shuffleInPlace),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   silhouette: () => (/* binding */ silhouette),
/* harmony export */   silhouetteMetric: () => (/* binding */ silhouetteMetric),
/* harmony export */   standardDeviation: () => (/* binding */ standardDeviation),
/* harmony export */   standardNormalTable: () => (/* binding */ standardNormalTable),
/* harmony export */   subtractFromMean: () => (/* binding */ subtractFromMean),
/* harmony export */   sum: () => (/* binding */ sum),
/* harmony export */   sumNthPowerDeviations: () => (/* binding */ sumNthPowerDeviations),
/* harmony export */   sumSimple: () => (/* binding */ sumSimple),
/* harmony export */   tTest: () => (/* binding */ tTest),
/* harmony export */   tTestTwoSample: () => (/* binding */ tTestTwoSample),
/* harmony export */   uniqueCountSorted: () => (/* binding */ uniqueCountSorted),
/* harmony export */   variance: () => (/* binding */ variance),
/* harmony export */   wilcoxonRankSum: () => (/* binding */ wilcoxonRankSum),
/* harmony export */   zScore: () => (/* binding */ zScore)
/* harmony export */ });
/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m;
    var b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0;
        var sumY = 0;
        var sumXX = 0;
        var sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point;
        var x;
        var y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    if (typeof sum !== "number") {
        return Number.NaN;
    }

    for (var i = 1; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    }
    if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0];
    // store the mode as we find new modes
    var value = Number.NaN;
    // store how many times we've seen the mode
    var maxSeen = 0;
    // how many times the current candidate for the mode
    // has been seen
    var seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n log(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // choose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample, randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0;
    var lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix[0].length - 1) {
        /* c8 ignore start */
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
        /* c8 ignore end */
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/*
 * Pull Breaks Values for Jenks
 *
 * the second part of the jenks recipe: take the calculated matrices
 * and derive an array of n breaks.
 *
 * @private
 */
function jenksBreaks(data, lowerClassLimits, nClasses) {
    var k = data.length;
    var kclass = [];
    var countNum = nClasses;

    // the calculation of classes will never include the upper
    // bound, so we need to explicitly set it
    kclass[nClasses] = data[data.length - 1];

    // the lowerClassLimits matrix is used as indices into itself
    // here: the `k` variable is reused in each iteration.
    while (countNum > 0) {
        kclass[countNum - 1] = data[lowerClassLimits[k][countNum] - 1];
        k = lowerClassLimits[k][countNum] - 1;
        countNum--;
    }

    return kclass;
}

/*
 * Compute Matrices for Jenks
 *
 * Compute the matrices required for Jenks breaks. These matrices
 * can be used for any classing of data with `classes <= nClasses`
 *
 * @private
 */
function jenksMatrices(data, nClasses) {
    // in the original implementation, these matrices are referred to
    // as `LC` and `OP`
    //
    // * lowerClassLimits (LC): optimal lower class limits
    // * varianceCombinations (OP): optimal variance combinations for all classes
    var lowerClassLimits = [];
    var varianceCombinations = [];
    // loop counters
    var i;
    var j;
    // the variance, as computed at each step in the calculation
    var variance = 0;

    // Initialize and fill each matrix with zeroes
    for (i = 0; i < data.length + 1; i++) {
        var tmp1 = [];
        var tmp2 = [];
        // despite these arrays having the same values, we need
        // to keep them separate so that changing one does not change
        // the other
        for (j = 0; j < nClasses + 1; j++) {
            tmp1.push(0);
            tmp2.push(0);
        }
        lowerClassLimits.push(tmp1);
        varianceCombinations.push(tmp2);
    }

    for (i = 1; i < nClasses + 1; i++) {
        lowerClassLimits[1][i] = 1;
        varianceCombinations[1][i] = 0;
        // in the original implementation, 9999999 is used but
        // since Javascript has `Infinity`, we use that.
        for (j = 2; j < data.length + 1; j++) {
            varianceCombinations[j][i] = Number.POSITIVE_INFINITY;
        }
    }

    for (var l = 2; l < data.length + 1; l++) {
        // `SZ` originally. this is the sum of the values seen thus
        // far when calculating variance.
        var sum = 0;
        // `ZSQ` originally. the sum of squares of values seen
        // thus far
        var sumSquares = 0;
        // `WT` originally. This is the number of
        var w = 0;
        // `IV` originally
        var i4 = 0;

        // in several instances, you could say `Math.pow(x, 2)`
        // instead of `x * x`, but this is slower in some browsers
        // introduces an unnecessary concept.
        for (var m = 1; m < l + 1; m++) {
            // `III` originally
            var lowerClassLimit = l - m + 1;
            var val = data[lowerClassLimit - 1];

            // here we're estimating variance for each potential classing
            // of the data, for each potential number of classes. `w`
            // is the number of data points considered so far.
            w++;

            // increase the current sum and sum-of-squares
            sum += val;
            sumSquares += val * val;

            // the variance at this point in the sequence is the difference
            // between the sum of squares and the total x 2, over the number
            // of samples.
            variance = sumSquares - (sum * sum) / w;

            i4 = lowerClassLimit - 1;

            if (i4 !== 0) {
                for (j = 2; j < nClasses + 1; j++) {
                    // if adding this element to an existing class
                    // will increase its variance beyond the limit, break
                    // the class at this point, setting the `lowerClassLimit`
                    // at this point.
                    if (
                        varianceCombinations[l][j] >=
                        variance + varianceCombinations[i4][j - 1]
                    ) {
                        lowerClassLimits[l][j] = lowerClassLimit;
                        varianceCombinations[l][j] =
                            variance + varianceCombinations[i4][j - 1];
                    }
                }
            }
        }

        lowerClassLimits[l][1] = 1;
        varianceCombinations[l][1] = variance;
    }

    // return the two matrices. for just providing breaks, only
    // `lowerClassLimits` is needed, but variances can be useful to
    // evaluate goodness of fit.
    return {
        lowerClassLimits: lowerClassLimits,
        varianceCombinations: varianceCombinations
    };
}

/**
 * The **[jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)**
 * is an algorithm commonly used in cartography and visualization to decide
 * upon groupings of data values that minimize variance within themselves
 * and maximize variation between themselves.
 *
 * For instance, cartographers often use jenks in order to choose which
 * values are assigned to which colors in a [choropleth](https://en.wikipedia.org/wiki/Choropleth_map)
 * map.
 *
 * @param {Array<number>} data input data, as an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * // split data into 3 break points
 * jenks([1, 2, 4, 5, 7, 9, 10, 20], 3) // = [1, 7, 20, 20]
 */
function jenks(data, nClasses) {
    if (nClasses > data.length) {
        return null;
    }

    // sort data in numerical order, since this is expected
    // by the matrices function
    data = data.slice().sort(function (a, b) {
        return a - b;
    });

    // get our basic matrices
    var matrices = jenksMatrices(data, nClasses);
    // we only need lower class limits here
    var lowerClassLimits = matrices.lowerClassLimits;

    // extract nClasses out of the computed matrices
    return jenksBreaks(data, lowerClassLimits, nClasses);
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_covariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * The [rank correlation](https://en.wikipedia.org/wiki/Rank_correlation) is
 * a measure of the strength of monotonic relationship between two arrays
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample rank correlation
 */
function sampleRankCorrelation(x, y) {
    var xIndexes = x
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });
    var yIndexes = y
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });

    // At this step, we have an array of indexes
    // that map from sorted numbers to their original indexes. We reverse
    // that so that it is an array of the sorted destination index.
    var xRanks = Array(xIndexes.length);
    var yRanks = Array(xIndexes.length);
    for (var i = 0; i < xIndexes.length; i++) {
        xRanks[xIndexes[i]] = i;
        yRanks[yIndexes[i]] = i;
    }

    return sampleCorrelation(xRanks, yRanks);
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] < 0) {
            throw new Error(
                "geometricMean requires only non-negative numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [log average](https://en.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Geometric_mean#Relationship_with_logarithms)
 * is an equivalent way of computing the geometric mean of an array suitable for large or small products.
 *
 * It's found by calculating the average logarithm of the elements and exponentiating.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 */
function logAverage(x) {
    if (x.length === 0) {
        throw new Error("logAverage requires at least one data point");
    }

    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (x[i] < 0) {
            throw new Error(
                "logAverage requires only non-negative numbers as input"
            );
        }
        value += Math.log(x[i]);
    }

    return Math.exp(value / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * The`coefficient of variation`_ is the ratio of the standard deviation to the mean.
 * .._`coefficient of variation`: https://en.wikipedia.org/wiki/Coefficient_of_variation
 *
 *
 * @param {Array} x input
 * @returns {number} coefficient of variation
 * @example
 * coefficientOfVariation([1, 2, 3, 4]).toFixed(3); // => 0.516
 * coefficientOfVariation([1, 2, 3, 4, 5]).toFixed(3); // => 0.527
 * coefficientOfVariation([-1, 0, 1, 2, 3, 4]).toFixed(3); // => 1.247
 */
function coefficientOfVariation(x) {
    return sampleStandardDeviation(x) / mean(x);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to reject](https://en.wikipedia.org/wiki/Exclusion_of_the_null_hypothesis)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * This function calculates the Wilcoxon rank sum statistic for the first sample
 * with respect to the second. The Wilcoxon rank sum test is a non-parametric
 * alternative to the t-test which is equivalent to the
 * [Mann-Whitney U test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).
 * The statistic is calculated by pooling all the observations together, ranking them,
 * and then summing the ranks associated with one of the samples. If this rank sum is
 * sufficiently large or small we reject the hypothesis that the two samples come
 * from the same distribution in favor of the alternative that one is shifted with
 * respect to the other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @returns {number} rank sum for sampleX
 *
 * @example
 * wilcoxonRankSum([1, 4, 8], [9, 12, 15]); // => 6
 */
function wilcoxonRankSum(sampleX, sampleY) {
    if (!sampleX.length || !sampleY.length) {
        throw new Error("Neither sample can be empty");
    }

    var pooledSamples = sampleX
        .map(function (x) { return ({ label: "x", value: x }); })
        .concat(sampleY.map(function (y) { return ({ label: "y", value: y }); }))
        .sort(function (a, b) { return a.value - b.value; });

    for (var rank = 0; rank < pooledSamples.length; rank++) {
        pooledSamples[rank].rank = rank;
    }

    var tiedRanks = [pooledSamples[0].rank];
    for (var i = 1; i < pooledSamples.length; i++) {
        if (pooledSamples[i].value === pooledSamples[i - 1].value) {
            tiedRanks.push(pooledSamples[i].rank);
            if (i === pooledSamples.length - 1) {
                replaceRanksInPlace(pooledSamples, tiedRanks);
            }
        } else if (tiedRanks.length > 1) {
            replaceRanksInPlace(pooledSamples, tiedRanks);
        } else {
            tiedRanks = [pooledSamples[i].rank];
        }
    }

    function replaceRanksInPlace(pooledSamples, tiedRanks) {
        var average = (tiedRanks[0] + tiedRanks[tiedRanks.length - 1]) / 2;
        for (var i = 0; i < tiedRanks.length; i++) {
            pooledSamples[tiedRanks[i]].rank = average;
        }
    }

    var rankSum = 0;

    for (var i$1 = 0; i$1 < pooledSamples.length; i$1++) {
        var sample = pooledSamples[i$1];
        if (sample.label === "x") {
            rankSum += sample.rank + 1;
        }
    }

    return rankSum;
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a naïve bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use `ε`, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return Number.NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
    14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
    0.46523628927048575665e-4, -0.98374475304879564677e-4,
    0.15808870322491248884e-3, -0.21026444172410488319e-3,
    0.2174396181152126432e-3, -0.16431810653676389022e-3,
    0.84418223983852743293e-4, -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Number.POSITIVE_INFINITY;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0 ≤ p ≤ 1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, `λ`.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the χ2 (Chi-Squared) Distribution**
 *
 * The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    1: {
        0.995: 0,
        0.99: 0,
        0.975: 0,
        0.95: 0,
        0.9: 0.02,
        0.5: 0.45,
        0.1: 2.71,
        0.05: 3.84,
        0.025: 5.02,
        0.01: 6.63,
        0.005: 7.88
    },
    2: {
        0.995: 0.01,
        0.99: 0.02,
        0.975: 0.05,
        0.95: 0.1,
        0.9: 0.21,
        0.5: 1.39,
        0.1: 4.61,
        0.05: 5.99,
        0.025: 7.38,
        0.01: 9.21,
        0.005: 10.6
    },
    3: {
        0.995: 0.07,
        0.99: 0.11,
        0.975: 0.22,
        0.95: 0.35,
        0.9: 0.58,
        0.5: 2.37,
        0.1: 6.25,
        0.05: 7.81,
        0.025: 9.35,
        0.01: 11.34,
        0.005: 12.84
    },
    4: {
        0.995: 0.21,
        0.99: 0.3,
        0.975: 0.48,
        0.95: 0.71,
        0.9: 1.06,
        0.5: 3.36,
        0.1: 7.78,
        0.05: 9.49,
        0.025: 11.14,
        0.01: 13.28,
        0.005: 14.86
    },
    5: {
        0.995: 0.41,
        0.99: 0.55,
        0.975: 0.83,
        0.95: 1.15,
        0.9: 1.61,
        0.5: 4.35,
        0.1: 9.24,
        0.05: 11.07,
        0.025: 12.83,
        0.01: 15.09,
        0.005: 16.75
    },
    6: {
        0.995: 0.68,
        0.99: 0.87,
        0.975: 1.24,
        0.95: 1.64,
        0.9: 2.2,
        0.5: 5.35,
        0.1: 10.65,
        0.05: 12.59,
        0.025: 14.45,
        0.01: 16.81,
        0.005: 18.55
    },
    7: {
        0.995: 0.99,
        0.99: 1.25,
        0.975: 1.69,
        0.95: 2.17,
        0.9: 2.83,
        0.5: 6.35,
        0.1: 12.02,
        0.05: 14.07,
        0.025: 16.01,
        0.01: 18.48,
        0.005: 20.28
    },
    8: {
        0.995: 1.34,
        0.99: 1.65,
        0.975: 2.18,
        0.95: 2.73,
        0.9: 3.49,
        0.5: 7.34,
        0.1: 13.36,
        0.05: 15.51,
        0.025: 17.53,
        0.01: 20.09,
        0.005: 21.96
    },
    9: {
        0.995: 1.73,
        0.99: 2.09,
        0.975: 2.7,
        0.95: 3.33,
        0.9: 4.17,
        0.5: 8.34,
        0.1: 14.68,
        0.05: 16.92,
        0.025: 19.02,
        0.01: 21.67,
        0.005: 23.59
    },
    10: {
        0.995: 2.16,
        0.99: 2.56,
        0.975: 3.25,
        0.95: 3.94,
        0.9: 4.87,
        0.5: 9.34,
        0.1: 15.99,
        0.05: 18.31,
        0.025: 20.48,
        0.01: 23.21,
        0.005: 25.19
    },
    11: {
        0.995: 2.6,
        0.99: 3.05,
        0.975: 3.82,
        0.95: 4.57,
        0.9: 5.58,
        0.5: 10.34,
        0.1: 17.28,
        0.05: 19.68,
        0.025: 21.92,
        0.01: 24.72,
        0.005: 26.76
    },
    12: {
        0.995: 3.07,
        0.99: 3.57,
        0.975: 4.4,
        0.95: 5.23,
        0.9: 6.3,
        0.5: 11.34,
        0.1: 18.55,
        0.05: 21.03,
        0.025: 23.34,
        0.01: 26.22,
        0.005: 28.3
    },
    13: {
        0.995: 3.57,
        0.99: 4.11,
        0.975: 5.01,
        0.95: 5.89,
        0.9: 7.04,
        0.5: 12.34,
        0.1: 19.81,
        0.05: 22.36,
        0.025: 24.74,
        0.01: 27.69,
        0.005: 29.82
    },
    14: {
        0.995: 4.07,
        0.99: 4.66,
        0.975: 5.63,
        0.95: 6.57,
        0.9: 7.79,
        0.5: 13.34,
        0.1: 21.06,
        0.05: 23.68,
        0.025: 26.12,
        0.01: 29.14,
        0.005: 31.32
    },
    15: {
        0.995: 4.6,
        0.99: 5.23,
        0.975: 6.27,
        0.95: 7.26,
        0.9: 8.55,
        0.5: 14.34,
        0.1: 22.31,
        0.05: 25,
        0.025: 27.49,
        0.01: 30.58,
        0.005: 32.8
    },
    16: {
        0.995: 5.14,
        0.99: 5.81,
        0.975: 6.91,
        0.95: 7.96,
        0.9: 9.31,
        0.5: 15.34,
        0.1: 23.54,
        0.05: 26.3,
        0.025: 28.85,
        0.01: 32,
        0.005: 34.27
    },
    17: {
        0.995: 5.7,
        0.99: 6.41,
        0.975: 7.56,
        0.95: 8.67,
        0.9: 10.09,
        0.5: 16.34,
        0.1: 24.77,
        0.05: 27.59,
        0.025: 30.19,
        0.01: 33.41,
        0.005: 35.72
    },
    18: {
        0.995: 6.26,
        0.99: 7.01,
        0.975: 8.23,
        0.95: 9.39,
        0.9: 10.87,
        0.5: 17.34,
        0.1: 25.99,
        0.05: 28.87,
        0.025: 31.53,
        0.01: 34.81,
        0.005: 37.16
    },
    19: {
        0.995: 6.84,
        0.99: 7.63,
        0.975: 8.91,
        0.95: 10.12,
        0.9: 11.65,
        0.5: 18.34,
        0.1: 27.2,
        0.05: 30.14,
        0.025: 32.85,
        0.01: 36.19,
        0.005: 38.58
    },
    20: {
        0.995: 7.43,
        0.99: 8.26,
        0.975: 9.59,
        0.95: 10.85,
        0.9: 12.44,
        0.5: 19.34,
        0.1: 28.41,
        0.05: 31.41,
        0.025: 34.17,
        0.01: 37.57,
        0.005: 40
    },
    21: {
        0.995: 8.03,
        0.99: 8.9,
        0.975: 10.28,
        0.95: 11.59,
        0.9: 13.24,
        0.5: 20.34,
        0.1: 29.62,
        0.05: 32.67,
        0.025: 35.48,
        0.01: 38.93,
        0.005: 41.4
    },
    22: {
        0.995: 8.64,
        0.99: 9.54,
        0.975: 10.98,
        0.95: 12.34,
        0.9: 14.04,
        0.5: 21.34,
        0.1: 30.81,
        0.05: 33.92,
        0.025: 36.78,
        0.01: 40.29,
        0.005: 42.8
    },
    23: {
        0.995: 9.26,
        0.99: 10.2,
        0.975: 11.69,
        0.95: 13.09,
        0.9: 14.85,
        0.5: 22.34,
        0.1: 32.01,
        0.05: 35.17,
        0.025: 38.08,
        0.01: 41.64,
        0.005: 44.18
    },
    24: {
        0.995: 9.89,
        0.99: 10.86,
        0.975: 12.4,
        0.95: 13.85,
        0.9: 15.66,
        0.5: 23.34,
        0.1: 33.2,
        0.05: 36.42,
        0.025: 39.36,
        0.01: 42.98,
        0.005: 45.56
    },
    25: {
        0.995: 10.52,
        0.99: 11.52,
        0.975: 13.12,
        0.95: 14.61,
        0.9: 16.47,
        0.5: 24.34,
        0.1: 34.28,
        0.05: 37.65,
        0.025: 40.65,
        0.01: 44.31,
        0.005: 46.93
    },
    26: {
        0.995: 11.16,
        0.99: 12.2,
        0.975: 13.84,
        0.95: 15.38,
        0.9: 17.29,
        0.5: 25.34,
        0.1: 35.56,
        0.05: 38.89,
        0.025: 41.92,
        0.01: 45.64,
        0.005: 48.29
    },
    27: {
        0.995: 11.81,
        0.99: 12.88,
        0.975: 14.57,
        0.95: 16.15,
        0.9: 18.11,
        0.5: 26.34,
        0.1: 36.74,
        0.05: 40.11,
        0.025: 43.19,
        0.01: 46.96,
        0.005: 49.65
    },
    28: {
        0.995: 12.46,
        0.99: 13.57,
        0.975: 15.31,
        0.95: 16.93,
        0.9: 18.94,
        0.5: 27.34,
        0.1: 37.92,
        0.05: 41.34,
        0.025: 44.46,
        0.01: 48.28,
        0.005: 50.99
    },
    29: {
        0.995: 13.12,
        0.99: 14.26,
        0.975: 16.05,
        0.95: 17.71,
        0.9: 19.77,
        0.5: 28.34,
        0.1: 39.09,
        0.05: 42.56,
        0.025: 45.72,
        0.01: 49.59,
        0.005: 52.34
    },
    30: {
        0.995: 13.79,
        0.99: 14.95,
        0.975: 16.79,
        0.95: 18.49,
        0.9: 20.6,
        0.5: 29.34,
        0.1: 40.26,
        0.05: 43.77,
        0.025: 46.98,
        0.01: 50.89,
        0.005: 53.67
    },
    40: {
        0.995: 20.71,
        0.99: 22.16,
        0.975: 24.43,
        0.95: 26.51,
        0.9: 29.05,
        0.5: 39.34,
        0.1: 51.81,
        0.05: 55.76,
        0.025: 59.34,
        0.01: 63.69,
        0.005: 66.77
    },
    50: {
        0.995: 27.99,
        0.99: 29.71,
        0.975: 32.36,
        0.95: 34.76,
        0.9: 37.69,
        0.5: 49.33,
        0.1: 63.17,
        0.05: 67.5,
        0.025: 71.42,
        0.01: 76.15,
        0.005: 79.49
    },
    60: {
        0.995: 35.53,
        0.99: 37.48,
        0.975: 40.48,
        0.95: 43.19,
        0.9: 46.46,
        0.5: 59.33,
        0.1: 74.4,
        0.05: 79.08,
        0.025: 83.3,
        0.01: 88.38,
        0.005: 91.95
    },
    70: {
        0.995: 43.28,
        0.99: 45.44,
        0.975: 48.76,
        0.95: 51.74,
        0.9: 55.33,
        0.5: 69.33,
        0.1: 85.53,
        0.05: 90.53,
        0.025: 95.02,
        0.01: 100.42,
        0.005: 104.22
    },
    80: {
        0.995: 51.17,
        0.99: 53.54,
        0.975: 57.15,
        0.95: 60.39,
        0.9: 64.28,
        0.5: 79.33,
        0.1: 96.58,
        0.05: 101.88,
        0.025: 106.63,
        0.01: 112.33,
        0.005: 116.32
    },
    90: {
        0.995: 59.2,
        0.99: 61.75,
        0.975: 65.65,
        0.95: 69.13,
        0.9: 73.29,
        0.5: 89.33,
        0.1: 107.57,
        0.05: 113.14,
        0.025: 118.14,
        0.01: 124.12,
        0.005: 128.3
    },
    100: {
        0.995: 67.33,
        0.99: 70.06,
        0.975: 74.22,
        0.95: 77.93,
        0.9: 82.36,
        0.5: 99.33,
        0.1: 118.5,
        0.05: 124.34,
        0.025: 129.56,
        0.01: 135.81,
        0.005: 140.17
    }
};

/**
 * The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting χ2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the χ2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI$1;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z;
    var tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of Φ (phi), which are the values of
 * the [cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function)
 * of the normal distribution. It is used to find the probability that a
 * statistic is observed below, above, or between values on the standard
 * normal distribution, and by extension, any normal distribution.
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return Math.round((1 - standardNormalTable[index]) * 1e4) / 1e4;
    }
}

/**
 * **[Logistic Cumulative Distribution Function](https://en.wikipedia.org/wiki/Logistic_distribution)**
 *
 * @param {number} x
 * @returns {number} cumulative standard logistic probability
 */
function cumulativeStdLogisticProbability(x) {
    return 1 / (Math.exp(-x) + 1);
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of τ (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2) ≈ 1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * The [Logit](https://en.wikipedia.org/wiki/Logit)
 * is the inverse of cumulativeStdLogisticProbability,
 * and is also known as the logistic quantile function.
 *
 * @param {number} p
 * @returns {number} logit
 */
function logit(p) {
    if (p <= 0 || p >= 1) {
        throw new Error("p must be strictly between zero and one");
    }
    return Math.log(p / (1 - p));
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @param {Function} [randomSource=Math.random] an optional entropy source
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k, randomSource) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'."
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData, randomSource);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            /* c8 ignore start */
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
            /* c8 ignore end */
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}

/**
 * Calculate Euclidean distance between two points.
 * @param {Array<number>} left First N-dimensional point.
 * @param {Array<number>} right Second N-dimensional point.
 * @returns {number} Distance.
 */
function euclideanDistance(left, right) {
    var sum = 0;
    for (var i = 0; i < left.length; i++) {
        var diff = left[i] - right[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

/**
 * @typedef {Object} kMeansReturn
 * @property {Array<number>} labels The labels.
 * @property {Array<Array<number>>} centroids The cluster centroids.
 */

/**
 * Perform k-means clustering.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points to be clustered.
 * @param {number} numCluster How many clusters to create.
 * @param {Function} randomSource An optional entropy source that generates uniform values in [0, 1).
 * @return {kMeansReturn} Labels (same length as data) and centroids (same length as numCluster).
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 *
 * @example
 * kMeansCluster([[0.0, 0.5], [1.0, 0.5]], 2); // => {labels: [0, 1], centroids: [[0.0, 0.5], [1.0 0.5]]}
 */
function kMeansCluster(points, numCluster, randomSource) {
    if ( randomSource === void 0 ) randomSource = Math.random;

    var oldCentroids = null;
    var newCentroids = sample(points, numCluster, randomSource);
    var labels = null;
    var change = Number.MAX_VALUE;
    while (change !== 0) {
        labels = labelPoints(points, newCentroids);
        oldCentroids = newCentroids;
        newCentroids = calculateCentroids(points, labels, numCluster);
        change = calculateChange(newCentroids, oldCentroids);
    }
    return {
        labels: labels,
        centroids: newCentroids
    };
}

/**
 * Label each point according to which centroid it is closest to.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<Array<number>>} centroids Current centroids.
 * @return {Array<number>} Group labels.
 */
function labelPoints(points, centroids) {
    return points.map(function (p) {
        var minDist = Number.MAX_VALUE;
        var label = -1;
        for (var i = 0; i < centroids.length; i++) {
            var dist = euclideanDistance(p, centroids[i]);
            if (dist < minDist) {
                minDist = dist;
                label = i;
            }
        }
        return label;
    });
}

/**
 * Calculate centroids for points given labels.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<number>} labels Which groups points belong to.
 * @param {number} numCluster Number of clusters being created.
 * @return {Array<Array<number>>} Centroid for each group.
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 */
function calculateCentroids(points, labels, numCluster) {
    // Initialize accumulators.
    var dimension = points[0].length;
    var centroids = makeMatrix(numCluster, dimension);
    var counts = Array(numCluster).fill(0);

    // Add points to centroids' accumulators and count points per centroid.
    var numPoints = points.length;
    for (var i = 0; i < numPoints; i++) {
        var point = points[i];
        var label = labels[i];
        var current = centroids[label];
        for (var j = 0; j < dimension; j++) {
            current[j] += point[j];
        }
        counts[label] += 1;
    }

    // Rescale centroids, checking for any that have no points.
    for (var i$1 = 0; i$1 < numCluster; i$1++) {
        if (counts[i$1] === 0) {
            throw new Error(("Centroid " + i$1 + " has no friends"));
        }
        var centroid = centroids[i$1];
        for (var j$1 = 0; j$1 < dimension; j$1++) {
            centroid[j$1] /= counts[i$1];
        }
    }

    return centroids;
}

/**
 * Calculate the difference between old centroids and new centroids.
 *
 * @private
 * @param {Array<Array<number>>} left One list of centroids.
 * @param {Array<Array<number>>} right Another list of centroids.
 * @return {number} Distance between centroids.
 */
function calculateChange(left, right) {
    var total = 0;
    for (var i = 0; i < left.length; i++) {
        total += euclideanDistance(left[i], right[i]);
    }
    return total;
}

/**
 * Calculate the [silhouette values](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for clustered data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<number>} The silhouette value for each point.
 *
 * @example
 * silhouette([[0.25], [0.75]], [0, 0]); // => [1.0, 1.0]
 */
function silhouette(points, labels) {
    if (points.length !== labels.length) {
        throw new Error("must have exactly as many labels as points");
    }
    var groupings = createGroups(labels);
    var distances = calculateAllDistances(points);
    var result = [];
    for (var i = 0; i < points.length; i++) {
        var s = 0;
        if (groupings[labels[i]].length > 1) {
            var a = meanDistanceFromPointToGroup(
                i,
                groupings[labels[i]],
                distances
            );
            var b = meanDistanceToNearestGroup(
                i,
                labels,
                groupings,
                distances
            );
            s = (b - a) / Math.max(a, b);
        }
        result.push(s);
    }
    return result;
}

/**
 * Create a lookup table mapping group IDs to point IDs.
 *
 * @private
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<Array<number>>} An array of length G, each of whose entries is an array
 * containing the indices of the points in that group.
 */
function createGroups(labels) {
    var numGroups = 1 + max(labels);
    var result = Array(numGroups);
    for (var i = 0; i < labels.length; i++) {
        var label = labels[i];
        if (result[label] === undefined) {
            result[label] = [];
        }
        result[label].push(i);
    }
    return result;
}

/**
 * Create a lookup table of all inter-point distances.
 *
 * @private
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @return {Array<Array<number>>} A symmetric square array of inter-point distances
 * (zero on the diagonal).
 */
function calculateAllDistances(points) {
    var numPoints = points.length;
    var result = makeMatrix(numPoints, numPoints);
    for (var i = 0; i < numPoints; i++) {
        for (var j = 0; j < i; j++) {
            result[i][j] = euclideanDistance(points[i], points[j]);
            result[j][i] = result[i][j];
        }
    }
    return result;
}

/**
 * Calculate the mean distance between this point and all the points in the
 * nearest group (as determined by which point in another group is closest).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} labels Labels of points.
 * @param {Array<Array<number>>} groupings An array whose entries are arrays
 * containing the indices of the points in that group.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the nearest
 * group.
 */
function meanDistanceToNearestGroup(which, labels, groupings, distances) {
    var label = labels[which];
    var result = Number.MAX_VALUE;
    for (var i = 0; i < groupings.length; i++) {
        if (i !== label) {
            var d = meanDistanceFromPointToGroup(
                which,
                groupings[i],
                distances
            );
            if (d < result) {
                result = d;
            }
        }
    }
    return result;
}

/**
 * Calculate the mean distance between a point and all the points in a group
 * (possibly its own).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} group The indices of all the points in the group in
 * question.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the
 * specified group.
 */
function meanDistanceFromPointToGroup(which, group, distances) {
    var total = 0;
    for (var i = 0; i < group.length; i++) {
        total += distances[which][group[i]];
    }
    return total / group.length;
}

/**
 * Calculate the [silhouette metric](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for a set of N-dimensional points arranged in groups. The metric is the largest
 * individual silhouette value for the data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {number} The silhouette metric for the groupings.
 *
 * @example
 * silhouetteMetric([[0.25], [0.75]], [0, 0]); // => 1.0
 */
function silhouetteMetric(points, labels) {
    var values = silhouette(points, labels);
    return max(values);
}

/**
 * Relative error.
 *
 * This is more difficult to calculate than it first appears [1,2].  The usual
 * formula for the relative error between an actual value A and an expected
 * value E is `|(A-E)/E|`, but:
 *
 * 1. If the expected value is 0, any other value has infinite relative error,
 *    which is counter-intuitive: if the expected voltage is 0, getting 1/10th
 *    of a volt doesn't feel like an infinitely large error.
 *
 * 2. This formula does not satisfy the mathematical definition of a metric [3].
 *    [4] solved this problem by defining the relative error as `|ln(|A/E|)|`,
 *    but that formula only works if all values are positive: for example, it
 *    reports the relative error of -10 and 10 as 0.
 *
 * Our implementation sticks with convention and returns:
 *
 * - 0 if the actual and expected values are both zero
 * - Infinity if the actual value is non-zero and the expected value is zero
 * - `|(A-E)/E|` in all other cases
 *
 * [1] https://math.stackexchange.com/questions/677852/how-to-calculate-relative-error-when-true-value-is-zero
 * [2] https://en.wikipedia.org/wiki/Relative_change_and_difference
 * [3] https://en.wikipedia.org/wiki/Metric_(mathematics)#Definition
 * [4] F.W.J. Olver: "A New Approach to Error Arithmetic." SIAM Journal on
 *     Numerical Analysis, 15(2), 1978, 10.1137/0715024.
 *
 * @param {number} actual The actual value.
 * @param {number} expected The expected value.
 * @return {number} The relative error.
 */
function relativeError(actual, expected) {
    // These lines are actually covered by tests, but it seems
    // like c8 has a bug that marks them as not covered.
    /* c8 ignore start */
    if (actual === 0 && expected === 0) {
        return 0;
    }
    /* c8 ignore end */
    return Math.abs((actual - expected) / expected);
}

/**
 * Approximate equality.
 *
 * @param {number} actual The value to be tested.
 * @param {number} expected The reference value.
 * @param {number} tolerance The acceptable relative difference.
 * @return {boolean} Whether numbers are within tolerance.
 */
function approxEqual(actual, expected, tolerance) {
    if ( tolerance === void 0 ) tolerance = epsilon;

    return relativeError(actual, expected) <= tolerance;
}


//# sourceMappingURL=simple-statistics.mjs.map


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   object: () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bbox: () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   feature: () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   merge: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mergeArcs: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   mesh: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   meshArcs: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   neighbors: () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   quantize: () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   transform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   untransform: () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "./node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "./node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mergeArcs: () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   meshArcs: () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "./node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./src/core/annotations.js":
/*!*********************************!*\
  !*** ./src/core/annotations.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendAnnotations: () => (/* binding */ appendAnnotations)
/* harmony export */ });
/* harmony import */ var d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-svg-annotation */ "./node_modules/d3-svg-annotation/indexRollupNext.js");


function appendAnnotations(map) {
    if (map.svg_) {
        const zoomGroup = map.svg_.select('#em-zoom-group-' + map.svgId_)
        //clear previous
        zoomGroup.selectAll('.em-annotation-group').remove()

        const annotationsConfig = map.annotations_

        if (annotationsConfig) {
            // Define a map that maps the type string to the corresponding annotation function
            const annotationTypeMap = {
                annotationLabel: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel,
                annotationCallout: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCallout,
                annotationCalloutRect: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutRect,
                annotationCalloutCircle: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutCircle,
                annotationXYThreshold: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationXYThreshold, // Add any other types you need
            }

            // Map annotations data to ensure each annotation has the proper function
            const annotationsWithTypes = annotationsConfig.annotations.map((d) => {
                // Replace the 'type' string with the corresponding annotation function
                const annotationType = annotationTypeMap[d.type] || d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel // Default to annotationLabel
                return { ...d, type: annotationType } // Update 'type' with the function reference
            })
            const makeAnnotations = (0,d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotation)().type(d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel).annotations(annotationsWithTypes).editMode(annotationsConfig.editMode)

            // append new
            zoomGroup.append('g').attr('class', 'em-annotation-group').call(makeAnnotations)
        }
    }
}


/***/ }),

/***/ "./src/core/cartograms.js":
/*!********************************!*\
  !*** ./src/core/cartograms.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildGridCartogramBase: () => (/* binding */ buildGridCartogramBase)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");



// draw grid cartogram geometries
const buildGridCartogramBase = function (out) {
    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(`#em-zoom-group-${out.svgId_}`)
    const gridGroup = zoomGroup.append('g').attr('id', 'em-grid-container')

    // Ensure margins exist with default values
    out.gridCartogramMargins_ = out.gridCartogramMargins_ || { top: 80, right: 80, bottom: 80, left: 80 }

    // Get grid layout
    const gridLayout = getGridLayout(out)
    const position = parseGridLayout(gridLayout)
    const gridData = getGridData(position, out)

    // Draw the appropriate grid
    if (out.gridCartogramShape_ === 'hexagon') {
        drawHexagonGrid(gridGroup, gridData, out)
    } else {
        drawSquareGrid(gridGroup, gridData, out)
    }

    // Center the grid
    centerGrid(gridGroup, out.width_, out.height_, out.gridCartogramMargins_)
}

/** Determines the grid layout based on settings */
const getGridLayout = (out) => {
    const squareGrid = `
        ,IS,  ,  ,NO,SE,FI,  ,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    const hexagonGrid = `
        ,IS,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,
        ,  ,  ,  ,NO,SE,FI,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    return out.gridCartogramPositions_ || (out.gridCartogramShape_ === 'hexagon' ? hexagonGrid : squareGrid)
}

/** Parses the grid layout and maps each ID to its position */
const parseGridLayout = (gridLayout) => {
    const positionById = new Map()
    ;(0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__.csvParseRows)(gridLayout.trim(), (row, j) => {
        row.forEach((id, i) => {
            if ((id = id.trim())) {
                positionById.set(id, [i, j])
            }
        })
    })
    return positionById
}

/** Converts parsed positions into structured grid data */
const getGridData = (position, out) => {
    return Array.from(position, ([id, [col, row]]) => {
        const feature = out.Geometries.geoJSONs.nutsrg.find((rg) => rg.properties.id == id)
        return {
            id,
            col,
            row,
            properties: {
                id: id,
                name: feature ? feature.properties.na : '',
            },
        }
    })
}

/** Draws a square grid */
const drawSquareGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const cellWidth = (out.width_ - margins.left - margins.right) / numCols - cellPadding
    const cellHeight = (out.height_ - margins.top - margins.bottom) / numRows - cellPadding
    const cellSize = Math.min(cellWidth, cellHeight)

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => `translate(${d.col * (cellSize + cellPadding) + margins.left}, ${d.row * (cellSize + cellPadding) + margins.top})`)
        .each(function (d) {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('rect').attr('width', cellSize).attr('height', cellSize).attr('class', 'em-grid-rect')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('x', cellSize / 2)
                .attr('y', cellSize / 2 + 5)
        })
}

/** Draws a hexagon grid */
const drawHexagonGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const baseHexRadius = Math.min(
        (out.width_ - margins.left - margins.right) / (numCols * 1.5),
        (out.height_ - margins.top - margins.bottom) / (numRows * Math.sqrt(3))
    )

    const hexRadius = baseHexRadius
    const hexHeight = Math.sqrt(3) * hexRadius

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => {
            const x = d.col * (1.5 * hexRadius + cellPadding) + margins.left
            const y = d.row * (hexHeight + cellPadding) + (d.col % 2 === 1 ? (hexHeight + cellPadding) / 2 : 0) + margins.top
            return `translate(${x}, ${y})`
        })
        .each(function (d) {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('path').attr('d', drawHexagon(hexRadius)).attr('class', 'em-grid-hexagon')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('y', 5)
        })
}

/** Generates the hexagon path */
const drawHexagon = (r) => {
    const angle = Math.PI / 3
    return (
        Array.from({ length: 6 }, (_, i) => {
            const x = r * Math.cos(angle * i)
            const y = r * Math.sin(angle * i)
            return `${i === 0 ? 'M' : 'L'}${x},${y}`
        }).join(' ') + ' Z'
    )
}

/** Centers the grid within the SVG */
const centerGrid = (gridGroup, svgWidth, svgHeight, margins) => {
    gridGroup.each(function () {
        const bbox = this.getBBox()
        const dx = (svgWidth - margins.left - margins.right - bbox.width) / 2 - bbox.x + margins.left
        const dy = (svgHeight - margins.top - margins.bottom - bbox.height) / 2 - bbox.y + margins.top
        gridGroup.attr('transform', `translate(${dx}, ${dy})`)
    })
}


/***/ }),

/***/ "./src/core/deprecated.js":
/*!********************************!*\
  !*** ./src/core/deprecated.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defineDeprecatedFunctions: () => (/* binding */ defineDeprecatedFunctions)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/core/utils.js");


/* prettier-ignore */
// to keep track of deprecated functions whilst keeping the current version clean.
// also passes any important parameters to the new functions (if they exist) and overwrites any CSS style rules.
// To be removed when completely phased out.

const defineDeprecatedFunctions = (out) => {
    // styles
    out.seaFillStyle = (v) => (console.warn('seaFillStyle() is now DEPRECATED, please use the .em-sea CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-sea','fill',v), out);
    out.cntrgFillStyle = (v) => (console.warn('cntrgFillStyle() is now DEPRECATED, please use the .em-cntrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-cntrg','fill',v), out);
    out.nutsrgFillStyle = (v) => (console.warn('nutsrgFillStyle() is now DEPRECATED, please use the .em-nutsrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-nutsrg','fill',v), out);
    out.nutsbnStroke = (v) => {
        console.warn('nutsbnStroke() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke',v['3'])
        }
        return out
    };
    out.nutsbnStrokeWidth = (v) => {
        console.warn('nutsbnStrokeWidth() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke-width',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke-width',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke-width',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke-width',v['3'])
        }
        return out
    };
    out.graticuleStroke = (v) => (console.warn('graticuleStroke() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke',v), out);
    out.graticuleStrokeWidth = (v) => (console.warn('graticuleStrokeWidth() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke-width',v), out);
    out.nutsrgSelFillSty = (v) => (console.warn('nutsrgSelFillSty() is now DEPRECATED, please use hoverColor() instead'), out.hoverColor_ = v, out);
    out.titleFontSize = (v) => (console.warn('map.titleFontSize() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','font-size',v), out);
    out.subtitleFontSize = (v) => (console.warn('map.subtitleFontSize() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-size',v), out);
    out.subtitleFontWeight = (v) => (console.warn('map.subtitleFontWeight() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-weight',v), out);
    out.titleFill = (v) => (console.warn('map.titleFill() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','fill',v), out);
    out.subtitleFill = (v) => (console.warn('map.subtitleFill() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','fill',v), out);
    out.cntbnStroke = (v) => {
        console.warn('cntbnStroke() is now DEPRECATED, please use the .em-cntbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v['co'])
        }
        return out
    };
    out.cntbnStrokeWidth = (v) => {
        console.warn('cntbnStrokeWidth() is now DEPRECATED, please use the .em-cntbn .em-worldbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke-width',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke-width',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke-width',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke-width',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v['co'])
        }
        return out
    };
    out.worldStroke = (v) => (console.warn('map.worldStroke() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke',v), out);
    out.worldStrokeWidth = (v) => (console.warn('map.worldStrokeWidth() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke-width',v), out);
    out.worldCoastStroke = (v) => (console.warn('map.worldCoastStroke() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v), out);
    out.worldCoastStrokeWidth = (v) => (console.warn('map.worldCoastStrokeWidth() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v), out);
    out.worldFillStyle = (v) => (console.warn('map.worldFillStyle() is now DEPRECATED. please use the .em-worldrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldrg','fill',v), out); 
    out.coastalMarginWidth = (v) => (console.warn('map.coastalMarginWidth() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke-width',v), out);  
    out.coastalMarginColor = (v) => (console.warn('map.coastalMarginColor() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke',v), out);
    out.fontFamily = (v) => (console.warn('map.fontFamily() is now DEPRECATED. please use the .em-map CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-map','font-family',v), out);
    out.botTxtFontSize = (v) => (console.warn('map.botTxtFontSize() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','font-size',v), out);
    out.botTxtFill = (v) => (console.warn('map.botTxtFill() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','fill',v), out);
    out.scalebarFontSize = (v) => (console.warn('map.scalebarFontSize() is now DEPRECATED. please use the .em-scalebar-label CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-scalebar-label','font-size',v), out);
    out.frameStroke = (v)=> (console.warn('map.frameStroke() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke',v), out);
    out.frameStrokeWidth = (v)=> (console.warn('map.frameStrokeWidth() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke-width',v), out);

   //other
    out.psClassifMethod = (v) => (console.warn('psClassifMethod() is now DEPRECATED. please use psClassificationMethod instead'),out.psClassificationMethod_ = v, out);
    out.geoCenter = (v) => (console.warn('map.geoCenter() is now deprecated. Please use map.position({x,y,z}) instead.'), out.position_.x = v[0], out.position_.y = v[1], out);
    out.pixelSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.pixSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.tooltipText = (v) => (console.warn('map.tooltipText() is now deprecated. Please use map.tooltip(config.textFunction) instead. See API reference for details.'), out.tooltip_.textFunction = v, out);
    out.classifMethod = (v) => (console.warn('map.classifMethod() is now DEPRECATED. please use map.classificationMethod() instead.'), out.classificationMethod_ = v,out);
    out.threshold = (v) => (console.warn('map.threshold() is now DEPRECATED. please use map.thresholds() instead.'), out.thresholds_ = v,out);
    out.clnb = (v) => (console.warn('map.clnb() is now DEPRECATED. please use map.numberOfClasses() instead.'), out.numberOfClasses_ = v,out);
    out.nutsLvl = (v) => (console.warn('map.nutsLvl() is now DEPRECATED. please use map.nutsLevel() instead.'), out.nutsLevel_ = v,out);
    out.lg = (v) => (console.warn('map.lg() is now DEPRECATED. please use map.language() instead.'), out.language_ = v,out);
    out.bottomText = (v) => (console.warn('bottomText is now DEPRECATED. Please use the footnote() method and em-footnote CSS class instead.'),out.footnote_ = v,out);
    out.botTxtFontSize = (v) => (console.warn('botTxtFontSize is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtFill = (v) => (console.warn('botTxtFill is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtPadding = (v) => (console.warn('botTxtPadding is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtTooltipTxt = (v) => (console.warn('botTxtTooltipTxt is now DEPRECATED. Please use footnoteTooltipText() instead.'),out);
    out.tooltipShowFlags = (v) =>(console.warn('tooltipShowFlags is now DEPRECATED. Please use out.tooltip({showFlags}) instead.'),out.tooltip_.showFlags = v,out);
    out.colorFun = (v) =>(console.warn('colorFun is now DEPRECATED. Please use out.colorFunction() instead.'),out.colorFunction_ = v,out);
    out.filtersDefinitionFun = (v)=>(console.warn('filtersDefinitionFun is now DEPRECATED. Please use out.filtersDefinitionFunction() instead.'),out.filtersDefinitionFunction_ = v,out);
    
    //labelling
    out.labelling = (v) =>(console.warn('labelling is now DEPRECATED. Please use out.labels({}) configuration object instead. See documentation for details.'),out);
    out.labelsConfig = (v) =>(console.warn('labelsConfig is now DEPRECATED. Please use out.labels({config:yourConfig}) configuration object instead. See documentation for details.'),out.labels_ =Object.assign(out.labels_ || {}, { config: v }),out);
    out.statLabelsPositions = (v) =>(console.warn('statLabelsPositions is now DEPRECATED. Please use out.labels({statLabelsPositions:yourPositions}) instead. See documentation for details.'),out.labels_ = Object.assign(out.labels_ || {}, { statLabelsPositions: v }),out);
    out.labelsToShow = (v) =>(console.warn('labelsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadowsToShow = (v) =>(console.warn('labelShadowsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadow = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelShadowWidth = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelFilterFunction =(v) =>(console.warn('labelFilterFunction is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) instead. See documentation for details.'),out);
    out.labelFill = (v) => (console.warn('map.labelFill() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStroke = (v) => (console.warn('map.labelStroke() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStrokeWidth = (v) => (console.warn('map.labelStrokeWidth() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelOpacity = (v) => (console.warn('map.labelOpacity() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelValuesFontSize = (v) => (console.warn('map.labelValuesFontSize() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelShadowWidth = (v) => (console.warn('map.labelShadowWidth() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);
    out.labelShadowColor = (v) => (console.warn('map.labelShadowColor() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);

    out.countriesToShow = (v) => (console.warn('map.countriesToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
    out.bordersToShow = (v) => (console.warn('map.bordersToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
}


/***/ }),

/***/ "./src/core/geometries.js":
/*!********************************!*\
  !*** ./src/core/geometries.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Geometries: () => (/* binding */ Geometries)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _kosovo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kosovo */ "./src/core/kosovo.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/graticule.js");
// takes care of the map's geometries






// Geometries class wrapped as a function
const Geometries = function (map, withCenterPoints) {
    let out = {}

    // defaults
    out.defaultGeoData = undefined
    out.allNUTSGeoData = undefined
    out.geoJSONs = {
        mixed: { rg0: undefined, rg1: undefined, rg2: undefined, rg3: undefined },
        cntbn: undefined,
        cntrg: undefined,
        nutsbn: undefined,
        nutsrg: undefined,
        gra: undefined,
        worldrg: undefined,
        worldbn: undefined,
        kosovo: undefined,
    }

    // user defined geometries (layers)
    out.userGeometries = undefined

    // user defined statistical regions
    out.statisticalRegions = undefined

    //centroids for prop symbols etc
    out.centroidsData = undefined //raw
    out.centroidsFeatures = undefined //geojson features

    // get geojson features of all statistical regions
    out.getRegionFeatures = function () {
        if (map.geo_ == 'WORLD') {
            return out.geoJSONs.worldrg
        } else {
            if (map.nutsLevel_ === 'mixed') {
                return [out.geoJSONs.mixed.rg0, out.geoJSONs.mixed.rg1, out.geoJSONs.mixed.rg2, out.geoJSONs.mixed.rg3]
            } else {
                return out.geoJSONs.nutsrg.concat(out.geoJSONs.cntrg)
            }
        }
    }

    /**
     * Retrieves and parses 'default' geo data (for NUTS or World maps)
     */
    out.getDefaultGeoData = function (geo, filterGeometriesFunction, nutsLevel) {
        const promises = out.getDefaultGeoDataPromise()
        return Promise.all(promises)
            .then((results) => {
                if (filterGeometriesFunction) {
                    results = filterGeometriesFunction(results)
                }
                out.allNUTSGeoData = results
                out.defaultGeoData = results[0]

                if (withCenterPoints) {
                    out.centroidsData = nutsLevel === 'mixed' ? [results[4], results[5], results[6], results[7]] : results[1]
                }

                const isWorld = geo === 'WORLD'
                // Decode TopoJSON to GeoJSON
                if (isWorld) {
                    out.geoJSONs.worldrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_RG_20M_2020_4326).features
                    out.geoJSONs.worldbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_BN_20M_2020_4326).features
                    out.geoJSONs.kosovo = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.NUTS_BN_20M_2021_RS_XK_border).features
                    out.geoJSONs.graticule = [(0,d3_geo__WEBPACK_IMPORTED_MODULE_3__["default"])().step([30, 30])()]
                } else {
                    out.geoJSONs.graticule = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.gra).features
                    out.geoJSONs.nutsrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsrg).features
                    out.geoJSONs.nutsbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsbn).features
                    out.geoJSONs.cntrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntrg).features
                    out.geoJSONs.cntbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntbn).features
                }

                return results
            })
            .catch((err) => {
                return Promise.reject(err)
            })
    }

    /**
     * Returns an array of promises for Nuts2JSON topojson data.
     */
    out.getDefaultGeoDataPromise = function () {
        const nutsLevels = [0, 1, 2, 3]
        const promises = []

        const buildUrl = (base, year, geo, proj, scale, level, withCenter = false) => {
            let path = `${base}/${year}`

            // Include geo part if it's specified and not 'EUR' or 'WORLD'
            if (geo && geo !== 'EUR' && geo !== 'WORLD') path += `/${geo}`

            // Add projection
            path += `/${geo == 'WORLD' ? '4326' : proj}` // world geodata is always 4326, then reprojected

            // Add scale only if not using center points
            if (!withCenter && scale) path += `/${scale}`

            // Append the appropriate file name
            path += `/${withCenter ? 'nutspt_' : ''}${level}.json`

            return path
        }

        if (map.nutsLevel_ === 'mixed' && map.geo_ !== 'WORLD') {
            nutsLevels.forEach((lvl) => promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl))))
            if (withCenterPoints) {
                nutsLevels.forEach((lvl) =>
                    promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl, true)))
                )
            }
        } else if (map.geo_ === 'WORLD') {
            const worldMapTopojsonURL = window.location.hostname.includes('ec.europa.eu')
                ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/IMAGE/WORLD_4326.json'
                : 'https://raw.githubusercontent.com/eurostat/eurostat-map/master/src/assets/topojson/WORLD_4326.json'
            promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(worldMapTopojsonURL))
        } else {
            promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_)))
            if (withCenterPoints) {
                promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_, true)))
            }
        }

        return promises
    }
    /** Checks if all geo data is ready */
    out.isGeoReady = function () {
        if (!out.defaultGeoData && !out.userGeometries) return false

        let allReady = true

        ;(0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, null, (inset) => {
            if (!inset.Geometries.isGeoReady()) {
                allReady = false
            }
        })

        return allReady
    }

    out.setUserGeometries = function (geometries) {
        this.userGeometries = geometries

        // get regions that are linked to the statistics
        geometries.forEach((geometry) => {
            if (geometry.statisticalRegions) {
                this.statisticalRegions = geometry
            }
        })
    }

    out.addDefaultGeometriesToMap = function (container, drawGraticule, pathFunction, nutsLevel, nutsYear, geo, proj, scale) {
        if (this.geoJSONs.graticule && drawGraticule) {
            //draw graticule
            container
                .append('g')
                .attr('id', 'em-graticule')
                .attr('class', 'em-graticule')
                .selectAll('path')
                .data(this.geoJSONs.graticule)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw country regions
        if (this.geoJSONs.cntrg) {
            container
                .append('g')
                .attr('id', 'em-cntrg')
                .attr('class', 'em-cntrg')
                .selectAll('path')
                .data(this.geoJSONs.cntrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw world map
        if (this.geoJSONs.worldrg) {
            container
                .append('g')
                .attr('id', 'em-worldrg')
                .attr('class', 'em-worldrg')
                .selectAll('path')
                .data(this.geoJSONs.worldrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw NUTS regions
        if (this.geoJSONs.nutsrg) {
            if (nutsLevel == 'mixed') {
                this.geoJSONs.mixed.rg0 = this.geoJSONs.nutsrg
                this.geoJSONs.mixed.rg1 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[1], out.allNUTSGeoData[1].objects.nutsrg).features
                this.geoJSONs.mixed.rg2 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[2], out.allNUTSGeoData[2].objects.nutsrg).features
                this.geoJSONs.mixed.rg3 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[3], out.allNUTSGeoData[3].objects.nutsrg).features

                //for mixed NUTS, we add every NUTS region across all levels and hide level 1,2,3 by default, only showing them when they have stat data
                // see updateClassification and updateStyle in map-choropleth.js for hiding/showing
                ;[this.geoJSONs.mixed.rg0, this.geoJSONs.mixed.rg1, this.geoJSONs.mixed.rg2, this.geoJSONs.mixed.rg3].forEach((r, i) => {
                    //append each nuts level to map
                    container
                        .append('g')
                        .attr('id', 'em-nutsrg')
                        .attr('class', `em-nutsrg em-nutsrg-${i}`)
                        .selectAll('path')
                        .data(r)
                        .enter()
                        .append('path')
                        .attr('d', pathFunction)
                        .attr('lvl', i) //to be able to distinguish nuts levels
                })

                //add kosovo
                if (geo == 'EUR' && (proj == '3035' || proj == '4326')) {
                    // add kosovo manually
                    addKosovoBorder(container, pathFunction, proj, scale, nutsYear)
                }
            } else {
                // when nutsLevel is not 'mixed'
                container
                    .append('g')
                    .attr('id', 'em-nutsrg')
                    .attr('class', 'em-nutsrg')
                    .selectAll('path')
                    .data(this.geoJSONs.nutsrg)
                    .enter()
                    .append('path')
                    .attr('d', pathFunction)
            }
        }

        //draw country boundaries
        if (this.geoJSONs.cntbn) {
            container
                .append('g')
                .attr('id', 'em-cntbn')
                .attr('class', 'em-cntbn')
                .selectAll('path')
                .data(this.geoJSONs.cntbn)
                .enter()
                .append('path')
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .attr('d', pathFunction)
                .attr('id', (bn) => 'em-bn-' + bn.properties.id)
                .attr('class', function (bn) {
                    let classList = []

                    if (bn.properties.eu === 'T') classList.push('em-bn-eu')
                    if (bn.properties.efta === 'T') classList.push('em-bn-efta')
                    if (bn.properties.cc === 'T') classList.push('em-bn-cc')
                    if (bn.properties.oth === 'T') classList.push('em-bn-oth')
                    if (bn.properties.co === 'T') classList.push('em-bn-co')

                    return classList.join(' ') // Use join with a space to create a valid class string
                })
        }

        //draw NUTS boundaries
        if (this.geoJSONs.nutsbn && nutsLevel !== 'mixed') {
            this.geoJSONs.nutsbn.sort(function (bn1, bn2) {
                return bn2.properties.lvl - bn1.properties.lvl
            })
            container
                .append('g')
                .attr('id', 'em-nutsbn')
                .attr('class', 'em-nutsbn')
                .selectAll('path')
                .data(this.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    let props = bn.properties
                    //KOSOVO
                    if (props.id > 100000) {
                        return 'em-kosovo-bn'
                    }
                    if (props.co === 'T') return 'em-bn-co'
                    const cl = ['em-bn-' + props.lvl]
                    //if (bn.oth === "T") cl.push("bn-oth");
                    return cl.join(' ')
                })
        }

        //draw world boundaries
        if (this.geoJSONs.worldbn) {
            container
                .append('g')
                .attr('id', 'em-worldbn')
                .attr('class', 'em-worldbn')
                .selectAll('path')
                .data(this.geoJSONs.worldbn)
                .enter()
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    if (bn.properties.POL_STAT > 0) {
                        //disputed
                        return 'em-bn-d'
                    }
                    return bn.properties.COAS_FLAG === 'T' ? 'em-bn-co' : 'em-worldbn'
                })
            //.attr("id", (bn) => bn.properties.CNTR_BN_ID)
        }

        if (this.geoJSONs.kosovo) {
            //add kosovo to world maps
            container
                .append('g')
                .attr('id', 'em-kosovo-bn')
                .attr('class', 'em-kosovo-bn')
                .selectAll('path')
                .data(this.geoJSONs.kosovo)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }
    }

    function addKosovoBorder(container, pathFunction, proj, scale, nutsYear) {
        let kosovoFeature = _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear] ? _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear][proj][scale] : _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[2024][proj][scale]
        let kosovoBn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(kosovoFeature, 'nutsbn_1').features
        container
            .append('g')
            .attr('id', 'em-kosovo-bn')
            .attr('class', 'em-kosovo-bn em-bn-cc')
            .selectAll('path')
            .data(kosovoBn)
            .enter()
            .append('path')
            .attr('d', pathFunction)
    }

    /**
     * @description Adds user-defined geometries to the map
     * E.g.
     * map.geometries([
     *  { id: 'regions', features: geoJSON.features, class: (feature) => 'region' },
     *  { id: 'borders', features: bordersData, class: (feature) => 'border' }
     * ])
     * @param geometries array of objects, each containing an array of geoJSON features
     * @param container d3 selection of the parent that we append the geometries to
     * @param pathFunction d3 path function
     */
    out.addUserGeometriesToMap = function (geometries, container, pathFunction) {
        geometries.forEach((geometry) => {
            let group = container
                .append('g')
                .attr('id', geometry.statisticalRegions ? 'em-user-regions' : '')
                .attr('class', geometry.class ? geometry.class : '')

            let elements = group.selectAll('path').data(geometry.features).enter().append('path').attr('d', pathFunction)

            // Allow custom call chain modifications through onEach
            if (typeof geometry.onEach === 'function') {
                geometry.onEach(elements)
            }
        })
    }

    return out
}


/***/ }),

/***/ "./src/core/insets.js":
/*!****************************!*\
  !*** ./src/core/insets.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildInsets: () => (/* binding */ buildInsets),
/* harmony export */   removeInsets: () => (/* binding */ removeInsets)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");



/**
 * Build inset maps for a map template
 */
const buildInsets = function (out, withCenterPoints) {
    if (!out.insetBoxPosition_) {
        out.insetBoxPosition_ = [out.width_ - out.insetBoxWidth_ - 2 * out.insetBoxPadding_, 2 * out.insetBoxPadding_]
    }

    // add container to drawing group
    // Cannot read properties of undefined (reading 'svgId')
    let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId_)
    let drawingGroup = svg.select('#em-drawing-' + out.svgId_)
    const ing = drawingGroup
        .append('g')
        .attr('id', 'em-insets-group')
        .attr('class', 'em-insets')
        .attr('transform', 'translate(' + out.insetBoxPosition_[0] + ',' + out.insetBoxPosition_[1] + ')')

    if (out.insets_ === 'default') {
        //if needed, use default inset config
        out.insets_ = defaultInsetConfig(out.insetBoxWidth_, out.insetBoxPadding_)
    }

    // append each inset to map
    for (let i = 0; i < out.insets_.length; i++) {
        const config = out.insets_[i]
        config.svgId = config.svgId || 'inset' + config.geo + Math.random().toString(36).substring(7)

        //get svg element.
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + config.svgId)
        if (svg.size() == 0) {
            // Create it as an embeded SVG if it does not exist
            const x = config.x == undefined ? out.insetBoxPadding_ : config.x
            const y = config.y == undefined ? out.insetBoxPadding_ + i * (out.insetBoxPadding_ + out.insetBoxWidth_) : config.y
            const ggeo = ing
                .append('g')
                .attr('id', 'em-inset-' + config.svgId)
                .attr('class', 'em-inset')
                .attr('transform', 'translate(' + x + ',' + y + ')')
            ggeo.append('svg').attr('id', config.svgId)
        }

        // build inset
        // GISCO-2676 - PT azores inset has 2 insets with the same Geo, so second was overriding first:
        if (out.insetTemplates_[config.geo]) {
            //if inset already exists in map with same geo, then push both to an array
            let inset = buildInset(config, out, withCenterPoints)
            inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = [out.insetTemplates_[config.geo], inset]
        } else {
            let inset = buildInset(config, out, withCenterPoints)
            let drawnInset = inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = drawnInset
        }
    }

    return out
}

/** Build template for inset, based on main one */
const buildInset = function (config, out, withCenterPoints) {
    //TODO find a better way to do that

    //copy map
    //for(let key__ in map) {
    //mt[key__] = map[key__];
    //}

    const mt = (0,_map_template__WEBPACK_IMPORTED_MODULE_0__.mapTemplate)(config, withCenterPoints)

    //define default values for inset configs
    config = config || {}
    config.proj = config.proj || _defaultCRS[config.geo]
    config.scale = config.scale || out.insetScale_
    config.footnote = config.footnote || ''
    config.showSourceLink = config.showSourceLink || false
    config.zoomExtent = config.zoomExtent || out.insetZoomExtent_
    config.width = config.width || out.insetBoxWidth_
    config.height = config.height || out.insetBoxWidth_
    config.insets = config.insets || []
    config.insetTemplates = config.insetTemplates || {}
    config.callback = config.callback || undefined

    //copy template attributes
    ;[
        'nutsLevel_',
        'nutsYear_',
        'hoverColor_',
        //'nutsbnStroke_', // DEPRECATED
        // 'nutsbnStrokeWidth_', // DEPRECATED
        'cntrgFillStyle_', // DEPRECATED
        'cntbnStroke_', // DEPRECATED
        'cntbnStrokeWidth_', // DEPRECATED
        'seaFillStyle_', // DEPRECATED
        'drawCoastalMargin_',
        'coastalMarginColor_', // DEPRECATED
        'coastalMarginWidth_', // DEPRECATED
        'coastalMarginStdDev_',
        'graticuleStroke_', // DEPRECATED
        'graticuleStrokeWidth_', // DEPRECATED
        'labelling_', // DEPRECATED
        'labelFill_', // DEPRECATED
        'labelValuesFontSize_', // DEPRECATED
        'labelOpacity_', // DEPRECATED
        'labelStroke_', // DEPRECATED
        'labelStrokeWidth_', // DEPRECATED
        'labelShadowWidth_', // DEPRECATED
        'labelShadow_', // DEPRECATED
        'labelShadowColor_', // DEPRECATED
        'labelShadowsToShow_',
        'labelsToShow_', // DEPRECATED
        'fontFamily_', // DEPRECATED
        'lg_',
        'projectionFunction_',
        'filterGeometriesFunction_',
    ].forEach(function (att) {
        mt[att] = out[att]
    })

    //copy stat map attributes/methods
    ;['stat', 'statData', 'legend', 'legendObj', 'noDataText', 'language', 'transitionDuration', 'tooltip_', 'classToText_'].forEach(function (att) {
        mt[att] = out[att]
    })

    //apply config values for inset
    for (let key in config) mt[key + '_'] = config[key]

    mt.isInset = true // flag for inset-specific settings e.g. CSS class for titles
    return mt
}

/**
 * Remove insets maps from the DOM
 */
const removeInsets = function (out) {
    if (out.insetTemplates_) {
        for (let template in out.insetTemplates_) {
            let id = out.insetTemplates_[template].svgId_
            let existing = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + id)
            // if (existing) existing.remove()
            if (existing) existing.html('') // empty them, but dont remove them.
        }
        out.insetTemplates_ = {} //  GISCO-2676
    }
}

/**
 * Default inset setting.
 * @param {*} s The width of the inset box
 * @param {*} p The padding
 */
const defaultInsetConfig = function (s, p) {
    const out = [
        { geo: 'IC', x: 0, y: 0, width: s, height: 0.3 * s },
        { geo: 'CARIB', x: 0, y: 0.3 * s + p, width: 0.5 * s, height: s },
        { geo: 'GF', x: 0.5 * s, y: 0.3 * s + p, width: 0.5 * s, height: 0.75 * s },
        {
            geo: 'YT',
            x: 0.5 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'RE',
            x: 0.75 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT20',
            x: 0,
            y: 1.3 * s + 2 * p,
            width: 0.75 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT30',
            x: 0.75 * s,
            y: 1.3 * s + 2 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        { geo: 'MT', x: 0, y: 1.55 * s + 3 * p, width: 0.25 * s, height: 0.25 * s },
        {
            geo: 'LI',
            x: 0.25 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_SV',
            x: 0.5 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_JM',
            x: 0.75 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        /*{geo:"IC", x:0, y:0}, {geo:"RE", x:dd, y:0}, {geo:"YT", x:2*dd, y:0},
		{geo:"GP", x:0, y:dd}, {geo:"MQ", x:dd, y:dd}, {geo:"GF",scale:"10M", x:2*dd, y:dd},
		{geo:"PT20", x:0, y:2*dd}, {geo:"PT30", x:dd, y:2*dd}, {geo:"MT", x:2*dd, y:2*dd},
		{geo:"LI",scale:"01M", x:0, y:3*dd}, {geo:"SJ_SV", x:dd, y:3*dd}, {geo:"SJ_JM",scale:"01M", x:2*dd, y:3*dd},*/
        //{geo:"CARIB", x:0, y:330}, {geo:"IS", x:dd, y:330}
    ]
    //hide graticule for insets
    for (let i = 0; i < out.length; i++) out[i].drawGraticule = false
    return out
}

/** Default CRS for each geo area */
const _defaultCRS = {
    EUR: '3035',
    IC: '32628',
    GP: '32620',
    MQ: '32620',
    GF: '32622',
    RE: '32740',
    YT: '32738',
    MT: '3035',
    PT20: '32626',
    PT30: '32628',
    LI: '3035',
    IS: '3035',
    SJ_SV: '3035',
    SJ_JM: '3035',
    CARIB: '32620',
    WORLD: '54030',
}


/***/ }),

/***/ "./src/core/kosovo.js":
/*!****************************!*\
  !*** ./src/core/kosovo.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   kosovoBnFeatures: () => (/* binding */ kosovoBnFeatures)
/* harmony export */ });
// mixed nuts dont draw nutsbn so we add them manually
const kosovoBnFeatures = {
  2021:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[3061,1303],[-152,-59],[-32,-66],[-65,72],[-96,7],[-16,59],[-64,19],[-56,-39],[-120,39],[-184,-19],[-16,26],[32,52],[-16,72],[24,40],[8,183]],[[2885,0],[-8,46],[-65,85],[-40,-7],[-40,40],[0,111],[80,13],[25,46],[72,13],[40,98],[-56,118],[144,196],[-24,79],[88,59],[-24,98],[-8,20],[24,39],[8,52],[48,72],[-88,125]],[[825,2638],[-112,-98],[-72,-7],[-88,-118],[-176,-39],[56,-91],[88,-33],[24,-53],[56,-39],[24,-91],[-56,-46],[24,-105],[-56,-92],[-104,0],[-48,-104],[-16,-40],[-57,7],[-40,-53],[-16,-78],[113,-118],[-97,-65],[-88,-99],[-80,20],[-80,-39],[-24,-13]],[[1098,2304],[-193,66],[24,39],[-16,39],[65,13],[0,33],[-65,79],[-88,65]],[[2308,1689],[-153,-20],[-64,59],[-40,7],[-96,-27],[-104,138],[-8,92],[-32,78],[-64,26],[-32,-59],[-24,0],[-56,86],[-40,137],[-25,65],[-56,0],[-56,46],[-64,-72],[-120,53],[-88,-40],[-88,46]]],"transform":{"scale":[37.761044752777565,38.54734205626113],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[962,0],[-29,75],[48,131],[21,35],[11,38],[32,117],[-24,44]],[[1021,440],[-64,-29],[-70,36],[-120,2],[3,121]],[[770,570],[-126,16],[-40,91],[-45,4],[-51,93],[-142,4]],[[275,891],[-131,-99],[30,-36],[24,-31],[-6,-86],[-98,-86],[13,-64],[-27,-38],[-80,-31]],[[366,778],[-37,22],[-54,91]]],"transform":{"scale":[113.2099448513097,114.12782081303801],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[536,0],[-24,45],[15,30],[45,92],[-1,44],[-2,37]],[[569,248],[-130,9],[-10,64]],[[429,321],[-64,10],[-78,94],[-83,13]],[[153,502],[-73,-51],[26,-84],[-48,-53],[-3,-52],[-55,-25]],[[204,438],[-51,64]]],"transform":{"scale":[203.12309601494124,202.56551463031246],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[310,138],[-36,-2],[-40,42]],[[234,178],[-123,65]],[[84,278],[-84,-147]],[[111,243],[-27,35]],[[292,0],[18,138]]],"transform":{"scale":[372.84281730215633,364.87611898580536],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1900,1275],[-30,27],[-27,-13],[-34,23],[-87,6],[25,59],[1,70],[20,34],[24,167]],[[1792,1648],[-116,1],[-62,77],[-89,-8],[-60,148],[7,86],[-4,15],[-13,60],[-45,28],[-33,-48],[-26,4],[-31,142],[-11,53],[5,43],[-19,44],[-39,8],[-40,49],[-52,-59],[-93,71],[-38,-6],[-16,-26]],[[945,2388],[-54,27],[-20,28],[-22,-3],[-17,22],[-25,1],[-10,10],[4,17],[27,14],[-15,29],[1,16],[68,1],[-8,16],[-5,30],[-14,29],[-27,42],[-25,22],[-30,41]],[[773,2730],[-89,-69],[-64,-4],[-82,-92],[-133,-15],[27,-93],[64,-43],[16,-50],[38,-44],[9,-75],[-48,-51],[5,-41],[6,-50],[-52,-84],[-78,14],[-35,-66],[-33,-61],[-45,11],[-35,-42],[-18,-72],[33,-71],[48,-55]],[[1017,2330],[-72,58]],[[307,1677],[-36,-12],[-25,-21],[-26,-10],[-76,-90],[-17,4],[-30,31],[-52,-14],[-26,-23],[-19,1]],[[2319,1185],[-116,-32],[-39,-52],[-42,70],[-68,23],[-12,58],[-43,23],[-42,-23],[-57,23]],[[2044,0],[-4,43],[-38,82],[-34,9],[-24,43],[13,97],[61,4],[32,41],[49,0],[37,82],[-26,118],[130,167],[-8,73],[74,46],[-2,18],[-9,92],[24,35],[7,49],[48,52],[-55,134]]],"transform":{"scale":[0.0006038339283908974,0.00036983475567765975],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '10M':{"type":"Topology","arcs":[[[659,439],[-54,17],[17,111]],[[622,567],[-93,31],[-25,92],[-36,11],[-29,97],[-23,1],[-63,3]],[[328,822],[-33,74],[-27,44]],[[268,940],[-72,-44],[-38,-31],[27,-86],[-14,-65],[-81,-78],[16,-58]],[[353,802],[-25,20]],[[106,578],[-41,-19],[-65,-28]],[[805,408],[-54,-21],[-92,52]],[[709,0],[-22,72],[0,17],[40,36],[18,67],[53,101],[16,64],[-9,51]]],"transform":{"scale":[0.001740521547911524,0.0010740945563829907],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '20M':{"type":"Topology","arcs":[[[380,252],[-21,26],[0,48]],[[359,326],[-49,17],[-56,107],[-51,11]],[[189,472],[-34,68]],[[155,540],[-66,-39],[18,-66],[-54,-68],[8,-35]],[[61,332],[-21,-13],[-10,-12],[-13,5],[-17,-7]],[[464,234],[-84,18]],[[409,0],[-14,46],[61,110],[8,78]]],"transform":{"scale":[0.003018276831896498,0.0018697201537037245],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '60M':{"type":"Topology","arcs":[[[235,156],[-13,46]],[[222,202],[-96,84]],[[117,293],[-21,42]],[[96,335],[-58,-129]],[[126,286],[-9,7]],[[38,206],[-38,-17]],[[287,145],[-52,11]],[[253,0],[34,145]]],"transform":{"scale":[0.004879722822299564,0.0030138772626866006],"translate":[20.352928393000074,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}}
    }
  },
  2024:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[3061,1303],[-152,-59],[-32,-66],[-65,72],[-96,7],[-16,59],[-64,19],[-56,-39],[-120,39],[-184,-19],[-16,26],[32,52],[-16,72],[24,40],[8,183]],[[2885,0],[-8,46],[-65,85],[-40,-7],[-40,40],[0,111],[80,13],[25,46],[72,13],[40,98],[-56,118],[144,196],[-24,79],[88,59],[-24,98],[-8,20],[24,39],[8,52],[48,72],[-88,125]],[[825,2638],[-112,-98],[-72,-7],[-88,-118],[-176,-39],[56,-91],[88,-33],[24,-53],[56,-39],[24,-91],[-56,-46],[24,-105],[-56,-92],[-104,0],[-48,-104],[-16,-40],[-57,7],[-40,-53],[-16,-78],[113,-118],[-97,-65],[-88,-99],[-80,20],[-80,-39],[-24,-13]],[[1098,2304],[-193,66],[24,39],[-16,39],[65,13],[0,33],[-65,79],[-88,65]],[[2308,1689],[-153,-20],[-64,59],[-40,7],[-96,-27],[-104,138],[-8,92],[-32,78],[-64,26],[-32,-59],[-24,0],[-56,86],[-40,137],[-25,65],[-56,0],[-56,46],[-64,-72],[-120,53],[-88,-40],[-88,46]]],"transform":{"scale":[37.761044752777565,38.54734205626113],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[962,0],[-29,75],[48,131],[21,35],[11,38],[32,117],[-24,44]],[[1021,440],[-64,-29],[-70,36],[-120,2],[3,121]],[[770,570],[-126,16],[-40,91],[-45,4],[-51,93],[-142,4]],[[275,891],[-131,-99],[30,-36],[24,-31],[-6,-86],[-98,-86],[13,-64],[-27,-38],[-80,-31]],[[366,778],[-37,22],[-54,91]]],"transform":{"scale":[113.2099448513097,114.12782081303801],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[536,0],[-24,45],[15,30],[45,92],[-1,44],[-2,37]],[[569,248],[-130,9],[-10,64]],[[429,321],[-64,10],[-78,94],[-83,13]],[[153,502],[-73,-51],[26,-84],[-48,-53],[-3,-52],[-55,-25]],[[204,438],[-51,64]]],"transform":{"scale":[203.12309601494124,202.56551463031246],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[310,138],[-36,-2],[-40,42]],[[234,178],[-123,65]],[[84,278],[-84,-147]],[[111,243],[-27,35]],[[292,0],[18,138]]],"transform":{"scale":[372.84281730215633,364.87611898580536],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1900,1275],[-30,27],[-27,-13],[-34,23],[-87,6],[25,59],[1,70],[20,34],[24,167]],[[1792,1648],[-116,1],[-62,77],[-89,-8],[-60,148],[7,86],[-4,15],[-13,60],[-45,28],[-33,-48],[-26,4],[-31,142],[-11,53],[5,43],[-19,44],[-39,8],[-40,49],[-52,-59],[-93,71],[-38,-6],[-16,-26]],[[945,2388],[-54,27],[-20,28],[-22,-3],[-17,22],[-25,1],[-10,10],[4,17],[27,14],[-15,29],[1,16],[68,1],[-8,16],[-5,30],[-14,29],[-27,42],[-25,22],[-30,41]],[[773,2730],[-89,-69],[-64,-4],[-82,-92],[-133,-15],[27,-93],[64,-43],[16,-50],[38,-44],[9,-75],[-48,-51],[5,-41],[6,-50],[-52,-84],[-78,14],[-35,-66],[-33,-61],[-45,11],[-35,-42],[-18,-72],[33,-71],[48,-55]],[[1017,2330],[-72,58]],[[307,1677],[-36,-12],[-25,-21],[-26,-10],[-76,-90],[-17,4],[-30,31],[-52,-14],[-26,-23],[-19,1]],[[2319,1185],[-116,-32],[-39,-52],[-42,70],[-68,23],[-12,58],[-43,23],[-42,-23],[-57,23]],[[2044,0],[-4,43],[-38,82],[-34,9],[-24,43],[13,97],[61,4],[32,41],[49,0],[37,82],[-26,118],[130,167],[-8,73],[74,46],[-2,18],[-9,92],[24,35],[7,49],[48,52],[-55,134]]],"transform":{"scale":[0.0006038339283908974,0.00036983475567765975],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '10M':{"type":"Topology","arcs":[[[659,439],[-54,17],[17,111]],[[622,567],[-93,31],[-25,92],[-36,11],[-29,97],[-23,1],[-63,3]],[[328,822],[-33,74],[-27,44]],[[268,940],[-72,-44],[-38,-31],[27,-86],[-14,-65],[-81,-78],[16,-58]],[[353,802],[-25,20]],[[106,578],[-41,-19],[-65,-28]],[[805,408],[-54,-21],[-92,52]],[[709,0],[-22,72],[0,17],[40,36],[18,67],[53,101],[16,64],[-9,51]]],"transform":{"scale":[0.001740521547911524,0.0010740945563829907],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '20M':{"type":"Topology","arcs":[[[380,252],[-21,26],[0,48]],[[359,326],[-49,17],[-56,107],[-51,11]],[[189,472],[-34,68]],[[155,540],[-66,-39],[18,-66],[-54,-68],[8,-35]],[[61,332],[-21,-13],[-10,-12],[-13,5],[-17,-7]],[[464,234],[-84,18]],[[409,0],[-14,46],[61,110],[8,78]]],"transform":{"scale":[0.003018276831896498,0.0018697201537037245],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '60M':{"type":"Topology","arcs":[[[235,156],[-13,46]],[[222,202],[-96,84]],[[117,293],[-21,42]],[[96,335],[-58,-129]],[[126,286],[-9,7]],[[38,206],[-38,-17]],[[287,145],[-52,11]],[[253,0],[34,145]]],"transform":{"scale":[0.004879722822299564,0.0030138772626866006],"translate":[20.352928393000074,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}}
    }
  }
}

/***/ }),

/***/ "./src/core/labels.js":
/*!****************************!*\
  !*** ./src/core/labels.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULTLABELS: () => (/* binding */ DEFAULTLABELS),
/* harmony export */   addLabelsToMap: () => (/* binding */ addLabelsToMap),
/* harmony export */   statLabelsTextFunction: () => (/* binding */ statLabelsTextFunction),
/* harmony export */   updateLabels: () => (/* binding */ updateLabels),
/* harmony export */   updateValuesLabels: () => (/* binding */ updateValuesLabels)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");



// handles all map labels e.g. stat values, or labels specified in map.labels({labels:[text:'myLabel', x:123, y: 123]})

/**
 * @function addLabelsToMap
 * @param map eurostatmap map instance
 * @param zg zoomgroup (d3 selection of zoomable elements)
 * @description appends text labels to the map. Labels can be countries, country codes, ocean names or statistical values
 */
const addLabelsToMap = function (map, zg) {
    // set defaults
    if (!map.labels_.config) map.labels_.config = DEFAULTLABELS
    if (!map.labels_.statLabelsPositions) map.labels_.statLabelsPositions = DEFAULTSTATLABELPOSITIONS

    // clear existing or append new container
    let existing = zg.select('#em-labels')
    let labelsContainer = existing.empty() ? zg.append('g').attr('id', 'em-labels') : existing

    //for statistical values on maps without centroids, we need to add centroids initially, then add text to them later once the stat data is loaded
    if (map.labels_?.values && map._mapType !== 'ps') appendStatLabelCentroidsToMap(map, labelsContainer)

    // get labels array
    let labelsArray = map.labels_?.labels || DEFAULTLABELS[`${map.geo}_${map.proj_}.cc`]

    // append other labels to map
    if (labelsArray) {
        //common styles between all label shadows
        const shadowg = labelsContainer.append('g').attr('class', 'em-label-shadows').attr('text-anchor', 'middle')

        //common styles between all labels
        const labelg = labelsContainer.append('g').attr('class', 'em-labels').attr('text-anchor', 'middle')

        //SHADOWS
        if (map.labels_?.shadows) {
            let shadows = shadowg
                .selectAll('text')
                .data(labelsArray)
                .enter()
                .append('text')
                .attr('id', (d) => 'em-label-shadow-' + d.text.replace(/\s+/g, '-'))
                .attr('class', (d) => 'em-label-shadow em-label-shadow-' + d.class)
                .attr('x', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[0]
                })
                .attr('y', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[1]
                })
                .attr('dy', -7) // set y position of bottom of text
                .attr('transform', (d) => {
                    if (d.rotate) {
                        let pos = map._projection([d.x, d.y])
                        let x = pos[0]
                        let y = pos[1]
                        return `translate(${x},${y}) rotate(${d.rotate})`
                    } else {
                        return 'rotate(0)'
                    }
                })
                .text(function (d) {
                    return d.text
                }) // define the text to display
        }

        //LABEL texts
        labelg
            .selectAll('text')
            .data(labelsArray)
            .enter()
            .append('text')
            .attr('id', (d) => 'em-label-' + d.text.replace(/\s+/g, '-'))
            .attr('class', (d) => 'em-label em-label-' + d.class)
            //position label
            .attr('x', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[0]
            })
            .attr('y', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[1]
            })
            .attr('dy', -7) // set y position of bottom of text
            //transform labels which have a "rotate" property in the labels config. For rotated labels, their X,Y must also be set in the transform.
            // note: dont apply to country code labels
            .attr('transform', (d) => {
                if (d.rotate) {
                    let pos = map._projection([d.x, d.y])
                    let x = pos[0]
                    let y = pos[1]
                    return `translate(${x},${y}) rotate(${d.rotate})`
                } else {
                    return 'rotate(0)'
                }
            })
            .text(function (d) {
                return d.text
            }) // define the text to display
    }
}

/**
 * @function updateLabels
 * @description update existing map labels
 */
const updateLabels = function (map) {
    if (map.svg_) {
        // Clear previous labels
        let prevLabels = map.svg_.selectAll('#em-labels > *')
        if (prevLabels) prevLabels.remove()

        // Main map
        if (map.labels_) {
            const masterConfig = map.labels_
            let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
            addLabelsToMap(map, zg)
            if (masterConfig.values && map.updateValuesLabels) {
                map.updateValuesLabels(map)
            }

            // Define the callback to apply to each inset
            const applyLabelsCallback = (map) => {
                if (masterConfig) {
                    let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
                    if (map.labels_) addLabelsToMap(map, zg)
                    if (masterConfig.values && map.updateValuesLabels) {
                        map.updateValuesLabels(map)
                    }
                }
            }

            // Apply labels to all insets using the executeForAllInsets function
            if (map.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_0__.executeForAllInsets)(map.insetTemplates_, map.svgId_, applyLabelsCallback)
            }
        }
    }
}

/**
 * @description update the statistical values labels on the map
 * @param {Object} map eurostat-map map instance
 * @return {map} out
 * NOTE: THIS FUNCTION IS NOT CALLED FOR PROPORTIONAL SYMBOL MAPS
 */
const updateValuesLabels = function (map) {
    if (!map) {
        console.warn('No map specified')
        return
    }

    //clear previous labels
    let prevLabels = map.svg_.selectAll('g.em-stat-label > *')
    prevLabels.remove()
    let prevShadows = map.svg_.selectAll('g.em-stat-label-shadow > *')
    prevShadows.remove()
    let statLabels = map.svg_.selectAll('g.em-stat-label')

    // filter stat-label elements to only show those with data
    const filterFunction = map.labels_?.statLabelsFilterFunction ? map.labels_?.statLabelsFilterFunction : defaultStatLabelFilter
    const statData = map.statData()
    statLabels
        .filter((rg) => filterFunction(rg, map))
        // .append('text')
        .each(function (d) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this)
            const labelText = statLabelsTextFunction(d, statData) // Use 'd' directly for the label text

            // Append rectangle behind label
            if (map.labels_.backgrounds) appendRect(labelText, sel)

            // Append text after the rectangle
            sel.append('text').text(labelText).attr('class', 'em-stat-label-text')
        })

    // Function to append a rectangle behind the label
    function appendRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    //add shadows to labels
    if (map.labels_?.shadows) {
        map.svg_
            .selectAll('g.em-stat-label-shadow')
            .filter((rg) => filterFunction(rg, map))
            .append('text')
            .text((d) => statLabelsTextFunction(d, statData)) // Use 'd' directly for the label text)
    }
    return map
}

/**
 * @description text function for statistical labelling
 * @param {Object} d d3 selection json data element
 * @return {string}
 */
const statLabelsTextFunction = (d, statData) => {
    if (statData && statData?.get) {
        const sv = statData.get(d.properties.id)
        if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
            return ''
        } else {
            if (sv.value !== ':') {
                return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.spaceAsThousandSeparator)(sv.value)
            }
        }
    }
}

/**
 * @description function for filtering statistical labels
 * @param {Object} d d3 selection json data element
 * @return {boolean}
 */
const defaultStatLabelFilter = (region, map) => {
    const s = map.statData()
    const sv = s.get(region.properties.id)
    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
        return false
    } else {
        return true
    }
}

const appendStatLabelCentroidsToMap = function (map, labelsContainer) {
    //values label shadows parent <g>
    const gsls = labelsContainer.append('g').attr('class', 'em-stat-labels-shadows').attr('text-anchor', 'middle')

    // values labels parent <g>
    const statLabelsGroup = labelsContainer.append('g').attr('class', 'em-stat-labels').attr('text-anchor', 'middle')

    // our features array
    let statLabelRegions = []

    // deafult geometries
    if (map.Geometries.geoJSONs.nutsrg) {
        //allow for stat label positioning by adding a g element here, then adding the values in the mapType updateValuesLabels function
        if (map.nutsLevel_ == 'mixed') {
            statLabelRegions = map.Geometries.geoJSONs.mixed.rg0.concat(
                map.Geometries.geoJSONs.mixed.rg1,
                map.Geometries.geoJSONs.mixed.rg2,
                map.Geometries.geoJSONs.mixed.rg3
            )
        } else {
            statLabelRegions = map.Geometries.geoJSONs.nutsrg
        }
    } else if (map.Geometries.userGeometries) {
        // user defined geometries
        statLabelRegions = map.Geometries.statisticalRegions.features
    }

    // preprocess centroids
    if (map.processCentroids_) centroidFeatures = map.processCentroids_(centroidFeatures)

    //TODO: dont add labels for regions that are not visible? what about panning and zooming though. Only really an issue for mixed NUTS.

    // stats labels
    statLabelsGroup
        .selectAll('g')
        .data(statLabelRegions)
        .enter()
        .append('g')
        .attr('transform', function (d) {
            // use predefined label positioning
            if (map.labels_.statLabelsPositions[d.properties.id]) {
                const position = map.labels_.statLabelsPositions[d.properties.id]
                let pos = map._projection([position.x, position.y])
                let x = pos[0].toFixed(3)
                let y = pos[1].toFixed(3)
                return `translate(${x},${y})`
            } else {
                let centroid = map._pathFunction.centroid(d)

                if (map.labels_.processValueLabelCentroids) {
                    centroid = map.labels_.processValueLabelCentroids(d, centroid)
                }
                // otherwise we calculate centroids
                return 'translate(' + centroid + ')'
            }
        })
        .attr('class', 'em-stat-label')

    // stat labels shadows
    if (map.labels_?.shadows) {
        gsls.selectAll('g')
            .data(statLabelRegions)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                // use predefined label positioning
                if (map.labels_.statLabelsPositions[d.properties.id]) {
                    let pos = map._projection([
                        map.labels_.statLabelsPositions[d.properties.id].x,
                        map.labels_.statLabelsPositions[d.properties.id].y,
                    ])
                    let x = pos[0].toFixed(3)
                    let y = pos[1].toFixed(3)
                    return `translate(${x},${y})`
                } else {
                    let centroid = map._pathFunction.centroid(d)

                    if (map.labels_.processValueLabelCentroids) {
                        centroid = map.labels_.processValueLabelCentroids(d, centroid)
                    }
                    // otherwise we calculate centroids
                    return 'translate(' + centroid + ')'
                }
            })

            .attr('class', 'em-stat-label-shadow')
    }
}

/**
 * Default labels for country / geographical names.
 * Using centroids would clash with proportional symbols, and are generally not ideal placements, so labels are positioned independently
 * Labels are provided for all supported languages: "en","fr" and "de" (defined using map.language())
 */
const DEFAULTLABELS = {
    EUR_3035: {
        cc: [
            { text: 'AL', x: 5100000, y: 2060000, class: 'cc', size: 7 },
            { text: 'AT', x: 4670000, y: 2629000, class: 'cc', size: 18 },
            { text: 'BE', x: 3930000, y: 3010000, class: 'cc', size: 17 },
            { text: 'BG', x: 5567000, y: 2200000, class: 'cc', size: 22 },
            { text: 'HR', x: 4876000, y: 2455000, class: 'cc', size: 10 },
            { text: 'CY', x: 6426000, y: 1480000, class: 'cc', size: 10 },
            { text: 'CZ', x: 4707000, y: 2885000, class: 'cc', size: 18 },
            { text: 'DK', x: 4316000, y: 3621000, class: 'cc', size: 20 },
            { text: 'EE', x: 5220000, y: 3990000, class: 'cc', size: 12 },
            { text: 'FI', x: 5150000, y: 4424000, class: 'cc', size: 20 },
            { text: 'FR', x: 3767740, y: 2662817, class: 'cc', size: 22 },
            { text: 'DE', x: 4347284, y: 3093276, class: 'cc', size: 22 },
            { text: 'EL', x: 5370000, y: 1750000, class: 'cc', size: 22 },
            { text: 'HU', x: 5020000, y: 2630000, class: 'cc', size: 17 },
            { text: 'IS', x: 3040000, y: 4833000, class: 'cc', size: 10 },
            { text: 'IE', x: 3136000, y: 3394000, class: 'cc', size: 17 },
            { text: 'IT', x: 4469967, y: 2181963, class: 'cc', size: 22 },
            { text: 'LV', x: 5290000, y: 3800000, class: 'cc', size: 12 },
            { text: 'LT', x: 5190000, y: 3630000, class: 'cc', size: 12 },
            { text: 'LU', x: 4120000, y: 2940000, class: 'cc', size: 12 },
            { text: 'MT', x: 4731000, y: 1300000, class: 'cc', size: 10 },
            { text: 'ME', x: 5073000, y: 2185000, class: 'cc', size: 7 },
            { text: 'MK', x: 5300000, y: 2080000, class: 'cc', size: 10 },
            { text: 'NL', x: 4020000, y: 3208000, class: 'cc', size: 17 },
            { text: 'NO', x: 4300000, y: 4147000, class: 'cc', size: 20 },
            { text: 'PL', x: 4964000, y: 3200000, class: 'cc', size: 22 },
            { text: 'PT', x: 2800000, y: 1990000, class: 'cc', size: 18 },
            { text: 'RO', x: 5451000, y: 2600000, class: 'cc', size: 22 },
            { text: 'RS', x: 5200000, y: 2300000, class: 'cc', size: 10 },
            { text: 'SK', x: 5040000, y: 2835000, class: 'cc', size: 12 },
            { text: 'SI', x: 4655000, y: 2480000, class: 'cc', size: 10 },
            { text: 'ES', x: 3160096, y: 1900000, class: 'cc', size: 22 },
            { text: 'SE', x: 4630000, y: 4000000, class: 'cc', size: 20 },
            { text: 'CH', x: 4200000, y: 2564000, class: 'cc', size: 16 },
            { text: 'TR', x: 6510000, y: 2100000, class: 'cc', size: 22 },
            { text: 'UK', x: 3558000, y: 3250000, class: 'cc', size: 17 },
        ],
        en: [
            { text: 'MEDITERRANEAN SEA', x: 3980000, y: 1600000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTIC OCEAN', x: 2820000, y: 2540000, class: 'seas', size: 12, letterSpacing: 2 },
            { text: 'NORTH SEA', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'BALTIC SEA', x: 4900000, y: 3730000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGIAN SEA', x: 3850000, y: 4800000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'BLACK SEA', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 4 },
            { text: 'ALBANIA', cc: 'AL', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUSTRIA', cc: 'AT', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIUM', cc: 'BE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIA', cc: 'BG', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIA', cc: 'HR', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CYPRUS', cc: 'CY', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'CZECHIA', cc: 'CZ', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DENMARK', cc: 'DK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIA', cc: 'EE', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINLAND', cc: 'FI', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', cc: 'FR', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'GERMANY', cc: 'DE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GREECE', cc: 'EL', x: 5470000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HUNGARY', cc: 'HU', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ICELAND', cc: 'IS', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRELAND', cc: 'IE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALY', cc: 'IT', x: 4469967, y: 2181963, class: 'countries', size: 12 },
            { text: 'LATVIA', cc: 'LV', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITHUANIA', cc: 'LT', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', cc: 'LU', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', cc: 'MT', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', cc: 'ME', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'N. MACEDONIA', cc: 'MK', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NETHERLANDS', cc: 'NL', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWAY', cc: 'NO', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLAND', cc: 'PL', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', cc: 'PT', x: 2830000, y: 1990000, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROMANIA', cc: 'RO', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIA', cc: 'RS', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAKIA', cc: 'SK', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVENIA', cc: 'SI', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPAIN', cc: 'ES', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SWEDEN', cc: 'SE', x: 4630000, y: 4100000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SWITZERLAND', cc: 'CH', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURKEY', cc: 'TR', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'U.K.', cc: 'UK', x: 3558000, y: 3250000, class: 'countries', size: 12 },
        ],
        fr: [
            { text: 'MER MÉDITERRANÉE', x: 5472000, y: 1242000, class: 'seas', size: 12 },
            { text: 'OCÈAN ATLANTIQUE', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'MER DU NORD', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'MER BALTIQUE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'MER DE NORVÈGE', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'MER NOIRE', x: 6265000, y: 2472000, class: 'seas', size: 12 },
            { text: 'ALBANIE', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUTRICHE', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIQUE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIE', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIE', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CHYPRE', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TCHÉQUIE', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DANEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIE', x: 5220000, y: 3990000, class: 'countries', size: 10 },
            { text: 'FINLANDE', x: 5125000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'ALLEMAGNE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GRÈCE', x: 5420000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HONGRIE', x: 5020000, y: 2654000, class: 'countries', size: 10 },
            { text: 'ISLANDE', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLANDE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIE', x: 4500000, y: 2181963, class: 'countries', size: 12 },
            { text: 'LETTONIE', x: 5290000, y: 3776000, class: 'countries', size: 10 },
            { text: 'LITUANIE', x: 5190000, y: 3630000, class: 'countries', size: 10 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTE', x: 4731000, y: 1335000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'MAC. DU NORD', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'PAYS-BAS', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORVEGE', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLOGNE', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROUMANIE', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIE', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAQUIE', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVÉNIE', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -35 },
            { text: 'ESPAGNE', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SUÈDE', x: 4700000, y: 4401000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SUISSE', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURQUIE', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'ROYAUME-UNI', x: 3558000, y: 3250000, class: 'countries', size: 10 },
        ],
        de: [
            { text: 'MITTELMEER', x: 5472000, y: 1200000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTISCHER OZEAN', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'NORDSEE', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'OSTSEE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGISCHE MEER', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'SCHWARZE MEER', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'ALBANIEN', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'ÖSTERREICH', x: 4650000, y: 2629000, class: 'countries', size: 7 },
            { text: 'BELGIEN', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIEN', x: 5567000, y: 2256000, class: 'countries', size: 10 },
            { text: 'KROATIEN', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'ZYPERN', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TSCHECHIEN', x: 4707000, y: 2885000, class: 'countries', size: 7 },
            { text: 'DÄNEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTLAND', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINNLAND', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANKREICH', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'DEUTSCHLAND', x: 4347284, y: 3093276, class: 'countries', size: 10 },
            { text: 'GRIECHENLAND', x: 5550000, y: 1500000, class: 'countries', size: 10 },
            { text: 'UNGARN', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ISLAND', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLAND', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIEN', x: 4469967, y: 2181963, class: 'countries', size: 12, rotate: 35 },
            { text: 'LETTLAND', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITAUEN', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'NORDMAZEDONIEN', x: 5350000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NIEDERLANDE', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWEGEN', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLEN', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'RUMÄNIEN', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIEN', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOWAKEI', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOWENIEN', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPANIEN', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SCHWEDEN', x: 4670000, y: 4180000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SCHWEIZ', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TRUTHAHN', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'VEREINIGTES', x: 3550000, y: 3520000, class: 'countries', size: 10 },
            { text: 'KÖNIGREICH', x: 3550000, y: 3420000, class: 'countries', size: 10 },
        ],
    },
    IC_32628: {
        cc: [{ text: 'ES', x: 420468, y: 3180647, class: 'cc', size: 12 }],
        en: [{ text: 'Canary Islands', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        fr: [{ text: 'Les îles Canaries', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        de: [{ text: 'Kanarische Inseln', x: 410000, y: 3180647, class: 'countries', size: 12 }],
    },
    GP_32620: {
        cc: [{ text: 'FR', x: 667000, y: 1740000, class: 'cc', size: 12 }],
        en: [{ text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 12 }],
    },
    MQ_32620: {
        cc: [{ text: 'FR', x: 716521, y: 1621322, class: 'cc', size: 12 }],
        en: [{ text: 'Martinique', x: 716521, y: 1621322, class: 'countries', size: 12 }],
    },
    GF_32622: {
        cc: [{ text: 'FR', x: 266852, y: 444074, class: 'cc', size: 12 }],
        en: [{ text: 'Guyane', x: 266852, y: 444074, class: 'countries', size: 12 }],
        de: [{ text: 'Guayana', x: 266852, y: 444074, class: 'countries', size: 12 }],
    },
    RE_32740: {
        cc: [{ text: 'FR', x: 348011, y: 7680000, class: 'cc', size: 10 }],
        en: [{ text: 'Réunion', x: 348011, y: 7680000, class: 'countries', size: 10 }],
    },
    YT_32738: {
        cc: [{ text: 'FR', x: 516549, y: 8593920, class: 'cc', size: 10 }],
        en: [{ text: 'Mayotte', x: 516549, y: 8593920, class: 'countries', size: 10 }],
    },
    MT_3035: {
        cc: [{ text: 'MT', x: 4719755, y: 1410701, class: 'cc', size: 10 }],
        en: [{ text: 'Malta', x: 4719755, y: 1410701, class: 'countries', size: 10 }],
    },
    PT20_32626: {
        cc: [{ text: 'PT', x: 397418, y: 4320000, class: 'cc', size: 10 }],
        en: [{ text: 'Azores', x: 397418, y: 4320000, class: 'countries', size: 10 }],
        fr: [{ text: 'Açores', x: 397418, y: 4271471, class: 'countries', size: 10 }],
        de: [{ text: 'Azoren', x: 397418, y: 4271471, class: 'countries', size: 10 }],
    },
    PT30_32628: {
        cc: [{ text: 'PT', x: 333586, y: 3624000, class: 'cc', size: 10, rotate: 30 }],
        en: [{ text: 'Madeira', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
        fr: [{ text: 'Madère', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
    },
    LI_3035: {
        cc: [{ text: 'LI', x: 4287060, y: 2660000, class: 'cc', size: 12 }],
        en: [{ text: 'Liechtenstein', x: 4287060, y: 2679000, class: 'countries', size: 7 }],
    },
    IS_3035: {
        cc: [{ text: 'IS', x: 3011804, y: 4960000, class: 'cc', size: 12 }],
        en: [{ text: 'Iceland', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        fr: [{ text: 'Islande', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        de: [{ text: 'Island', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
    },
    SJ_SV_3035: {
        cc: [{ text: 'NO', x: 4570000, y: 6260000, class: 'cc', size: 10 }],
        en: [{ text: 'Svalbard', x: 4570000, y: 6260000, class: 'countries', size: 10 }],
        de: [{ text: 'Spitzbergen', x: 4570000, y: 6260000, class: 'countries', size: 7 }],
    },
    SJ_JM_3035: {
        cc: [{ text: 'NO', x: 3647762, y: 5420300, class: 'cc', size: 10 }],
        en: [{ text: 'Jan Mayen', x: 3647762, y: 5420300, class: 'countries', size: 7 }],
    },
    CARIB_32620: {
        cc: [
            { text: 'FR', x: 700000, y: 1810000, class: 'cc', size: 10 },
            { text: 'FR', x: 640000, y: 1590000, class: 'cc', size: 10 },
            { text: 'FR', x: 540000, y: 1962000, class: 'cc', size: 7 },
        ],
        en: [
            { text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 10 },
            { text: 'Martinique', x: 570000, y: 1590000, class: 'countries', size: 10 },
            { text: 'Saint Martin', x: 597000, y: 1962000, class: 'countries', size: 7 },
        ],
    },
    // note: WORLD x/y are in EPSG:4326 then reprojected by d3 to EPSG:54030
    WORLD_54030: {
        en: [
            { text: 'NORTH ATLANTIC', x: -45, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH ATLANTIC', x: -15, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH PACIFIC', x: -126, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'NORTH', x: -136, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'PACIFIC', x: -134, y: 20, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'INDIAN OCEAN', x: 80, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTHERN OCEAN', x: -5, y: -67, class: 'seas', size: 10, letterSpacing: 6 },
        ],
    },
}

const DEFAULTSTATLABELPOSITIONS = {
    AL: { x: 5150000, y: 2000000 },
    AT: { x: 4670000, y: 2700000 },
    BE: { x: 3930000, y: 3060000 },
    BG: { x: 5567000, y: 2300000 },
    HR: { x: 4657718, y: 2400243 },
    CY: { x: 6426000, y: 1570000 },
    CH: { x: 4170000, y: 2600000 },
    CZ: { x: 4707000, y: 2950000 },
    DK: { x: 4316000, y: 3621000 },
    EE: { x: 5220000, y: 4050000 },
    FI: { x: 5150000, y: 4424000 },
    FR: { x: 3767740, y: 2662817 },
    DE: { x: 4347284, y: 3093276 },
    EL: { x: 5370000, y: 1750000 },
    HU: { x: 5020000, y: 2670000 },
    IS: { x: 3040000, y: 4833000 },
    IE: { x: 3136000, y: 3394000 },
    IT: { x: 4500000, y: 2181963 },
    LV: { x: 5290000, y: 3840000 },
    LT: { x: 5190000, y: 3630000 },
    LU: { x: 4120000, y: 2940000 },
    MT: { x: 4880000, y: 1480000 },
    ME: { x: 5073000, y: 2230000 },
    MK: { x: 5300000, y: 2130000 },
    NL: { x: 4020000, y: 3208000 },
    NO: { x: 4300000, y: 4147000 },
    PL: { x: 4964000, y: 3200000 },
    PT: { x: 2800000, y: 1990000 },
    RO: { x: 5451000, y: 2600000 },
    RS: { x: 5200000, y: 2370000 },
    SK: { x: 5040000, y: 2860000 },
    SI: { x: 4660000, y: 2550000 },
    ES: { x: 3160096, y: 1900000 },
    SE: { x: 4630000, y: 4000000 },
    TR: { x: 6510000, y: 2100000 },
    UK: { x: 3558000, y: 3250000 },
    RU: { x: 6842086, y: 3230517 },
}


/***/ }),

/***/ "./src/core/map-template.js":
/*!**********************************!*\
  !*** ./src/core/map-template.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapTemplate: () => (/* binding */ mapTemplate)
/* harmony export */ });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/src/robinson.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _annotations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotations */ "./src/core/annotations.js");
/* harmony import */ var _labels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels */ "./src/core/labels.js");
/* harmony import */ var _deprecated__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deprecated */ "./src/core/deprecated.js");
/* harmony import */ var _geometries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geometries */ "./src/core/geometries.js");
/* harmony import */ var _insets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./insets */ "./src/core/insets.js");
/* harmony import */ var _stamps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stamps */ "./src/core/stamps.js");
/* harmony import */ var _cartograms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cartograms */ "./src/core/cartograms.js");














// set default d3 locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_9__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * The map template: only the geometrical part.
 * To be used as a base map for a statistical map.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const mapTemplate = function (config, withCenterPoints, mapType) {
    //build map template object
    const out = {}
    out._mapType = mapType

    // expose imported function to other modules
    out.updateValuesLabels = _labels__WEBPACK_IMPORTED_MODULE_3__.updateValuesLabels

    //map
    out.svgId_ = 'map'
    out.svg_ = undefined
    out.width_ = Math.min(795, window.innerWidth)
    out.height_ = 0
    out.containerId_ = undefined

    //geographical focus
    out.gridCartogram_ = false // draw geometries as grid cells
    out.gridCartogramShape_ = 'square' // square or hexagon
    out.gridCartogramMargins_ = { top: 80, right: 50, bottom: 80, left: 150 }
    out.gridCartogramCellPadding_ = 4
    out.gridCartogramPositions_ = undefined //user defined cartograms
    out.nutsLevel_ = 3 // 0,1,2,3, or 'mixed'
    out.nutsYear_ = 2024
    out.geo_ = 'EUR'
    out.proj_ = '3035'
    out.projectionFunction_ = undefined // e.g. d3.geoRobinson()
    out.filterGeometriesFunction_ = undefined // user defined filter function
    out.scale_ = '20M' //TODO choose automatically, depending on pixelSize ?
    out.zoomExtent_ = undefined
    out.maxBounds_ = { xMin: -Infinity, yMin: -Infinity, xMax: Infinity, yMax: Infinity }
    out.geometries_ = undefined // [{id:String, data:geojson, class:function}] user-defined geometries
    out.processCentroids_ = undefined // runs over symbol centroids
    out.position_ = { x: undefined, y: undefined, z: undefined } // map view

    //map title
    out.title_ = ''
    out.titlePosition_ = undefined

    //map subtitle
    out.subtitle_ = ''
    out.subtitlePosition_ = undefined

    //scalebar
    out.showScalebar_ = false
    out.scalebarPosition_ = []
    out.scalebarUnits_ = ' km' //label
    out.scalebarTextOffset_ = [0, 12]
    out.scalebarMaxWidth_ = 150 //px
    out.scalebarHeight_ = 90 //px
    out.scalebarStrokeWidth_ = 1 //px
    out.scalebarSegmentHeight_ = 6
    out.scalebarTickHeight_ = 8

    // stamp annotation
    out.stamp_ = undefined //e.g {x,y,text,size}

    //tooltip
    out.tooltip_ = {
        fontSize: '14px',
        transitionDuration: 200,
        xOffset: 0,
        yOffset: 0,
        textFunction: null,
        showFlags: false,
    } //  See tooltip.js for more details

    // region mouseover color
    out.hoverColor_ = 'red'

    //coastal margin
    out.drawCoastalMargin_ = false
    out.coastalMarginStdDev_ = 3

    //graticule
    out.drawGraticule_ = false

    //background map toggle (e.g. for dorling)
    out.backgroundMap_ = true

    //labelling
    // see docs\reference.md#labelling
    out.labels_ = undefined

    //annotations
    out.annotations_ = undefined
    out.annotationsAdded = false //simple flag to know when annotations have already been added

    //dataset source link
    out.showSourceLink_ = true

    //default copyright and disclaimer text
    out.footnote_ = 'Administrative boundaries: \u00A9EuroGeographics \u00A9UN-FAO \u00A9INSTAT \u00A9Turkstat' //"(C)EuroGeographics (C)UN-FAO (C)Turkstat";
    out.footnoteTooltipText_ =
        'The designations employed and the presentation of material on this map do not imply the expression of any opinion whatsoever on the part of the European Union concerning the legal status of any country, territory, city or area or of its authorities, or concerning the delimitation of its frontiers or boundaries. Kosovo*: This designation is without prejudice to positions on status, and is in line with UNSCR 1244/1999 and the ICJ Opinion on the Kosovo declaration of independence.'

    out.nuts2jsonBaseURL_ = window.location.hostname.includes('ec.europa.eu')
        ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/pub/nuts2json/v2'
        : 'https://raw.githubusercontent.com/eurostat/Nuts2json/master/pub/v2'

    //style for no data regions
    out.noDataFillStyle_ = '#bcbcbc'

    /**
     * Insets.
     * The map template has a recursive structure.
     */

    //insets to show, as a list of map template configs. Ex.: [{geo:"MT"},{geo:"LI"},{geo:"PT20"}]
    out.insets_ = []
    //inset templates - each inset is a map-template instance.
    out.insetTemplates_ = {}

    out.insetBoxPosition_ = undefined
    out.insetBoxPadding_ = 5
    out.insetBoxWidth_ = 210
    //out.insetZoomExtent_ = [1, 3];
    out.insetZoomExtent_ = null //zoom disabled as default
    out.insetScale_ = '03M'

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    for (const att in out) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    }

    // warn existing users of functions that have been banished to the shadow realm.
    (0,_deprecated__WEBPACK_IMPORTED_MODULE_4__.defineDeprecatedFunctions)(out)

    // convert geo to uppercase
    out.geo = function (v) {
        if (!arguments.length) return out.geo_
        out.geo_ = v.toUpperCase()
        return out
    }

    //special ones which affect also the insets
    ;['tooltip_', 'nuts2jsonBaseURL_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]

            if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
                //override default properties
                for (const p in v) {
                    out[att][p] = v[p]
                }
            } else {
                out[att] = v
            }

            //recursive call to inset components
            if (out.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(
                    out.insetTemplates_,
                    out.svgId_,
                    (inset, value) => {
                        const fnName = att.substring(0, att.length - 1)
                        inset[fnName](value)
                    },
                    v
                )
            }
            return out
        }
    })

    //title getter and setter
    out.title = function (v) {
        if (!arguments.length) return out.title_
        out.title_ = v
        if (out.svg())
            out.svg()
                .select('#title' + out.geo())
                .text(v)
        return out
    }

    //subtitle getter and setter
    out.subtitle = function (v) {
        if (!arguments.length) return out.subtitle_
        out.subtitle_ = v
        if (out.svg())
            out.svg()
                .select('#subtitle' + out.geo())
                .text(v)
        return out
    }

    //insets getter/setter
    out.insets = function () {
        if (!arguments.length) return out.insets_
        if (arguments.length == 1 && arguments[0] === 'default') out.insets_ = 'default'
        else if (arguments.length == 1 && arguments[0] === false) out.insets_ = false
        else if (arguments.length == 1 && Array.isArray(arguments[0])) out.insets_ = arguments[0]
        else out.insets_ = arguments
        return out
    }

    // dynamic draw graticule
    out.drawGraticule = function (v) {
        if (!arguments.length) return out.drawGraticule_
        out.drawGraticule_ = v

        //update graticule
        let graticule = out.svg_ ? out.svg().select('#em-graticule') : null
        let zg = out.svg_ ? out.svg_.select('#em-zoom-group-' + out.svgId_) : null

        // if existing and argument is false
        if (graticule) {
            if (graticule._groups[0][0] && v == false) {
                //remove graticule
                graticule.remove()

                // if map already created and argument is true
            } else if (out.Geometries.geoJSONs.graticule && out._pathFunction && zg && v == true) {
                //remove existing graticule
                graticule.remove()
                // add new graticule
                zg.append('g')
                    .attr('id', 'em-graticule')
                    .selectAll('path')
                    .data(out.Geometries.geoJSONs.graticule)
                    .enter()
                    .append('path')
                    .attr('d', out._pathFunction)
                    .attr('class', 'em-graticule')

                out.svg()
                    .select('#em-graticule')
                    .each(function () {
                        // move graticule behind land mass
                        out.geo_ == 'WORLD'
                            ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                            : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                    })
            }
        }
        return out
    }

    //coastal margin override
    out.drawCoastalMargin = function (v) {
        if (!arguments.length) return out.drawCoastalMargin_
        out.drawCoastalMargin_ = v

        //update existing
        if (out.svg_) {
            let margin = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#em-coast-margin')
            let filter = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-coastal-blur')
            let zg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-zoom-group-' + out.svgId_) || null
            if (margin._groups[0][0] && v == false) {
                // remove existing
                margin.remove()
            } else if (v == true && out._pathFunction && zg) {
                //remove existing graticule
                margin.remove()
                filter.remove()
                //add filter
                out.svg_
                    .append('filter')
                    .attr('id', 'em-coastal-blur')
                    .attr('x', '-200%')
                    .attr('y', '-200%')
                    .attr('width', '400%')
                    .attr('height', '400%')
                    .append('feGaussianBlur')
                    .attr('in', 'SourceGraphic')
                    .attr('stdDeviation', out.coastalMarginStdDev_)

                //draw for main map - geometries are still in memory so no rebuild needed
                const drawNewCoastalMargin = (map) => {
                    // zoom group might not be inside main map (out.svg_)
                    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-zoom-group-' + map.svgId_)
                    //draw new coastal margin
                    const cg = zoomGroup.append('g').attr('id', 'em-coast-margin')

                    //countries bn
                    if (map._geom.cntbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-cnt')
                            .selectAll('path')
                            .data(map._geom.cntbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //nuts bn
                    if (map._geom.nutsbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.nutsbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //world bn
                    if (map._geom.worldbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.worldbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.COAS_FLAG === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                }

                //draw for insets - requires geometries so we have to rebuild base template
                if (out.insetTemplates_ && out.drawCoastalMargin_) {
                    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, drawNewCoastalMargin)
                    drawNewCoastalMargin(out)
                }

                // move margin to back (in front of sea)
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#em-coast-margin').each(function () {
                    out.geo_ == 'WORLD'
                        ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                        : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                })
            }
        }
        return out
    }

    //annotations override (update after first call)
    out.annotations = function (v) {
        //get
        if (!arguments.length) return out.annotations_
        //set
        out.annotations_ = v
        //update
        ;(0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
        return out
    }

    //stamps override (update after first call)
    out.stamp = function (v) {
        //get
        if (!arguments.length) return out.stamp_
        //set
        out.stamp_ = v
        //update
        ;(0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        return out
    }

    //labels override (update after first call)
    out.labels = function (v) {
        //get
        if (!arguments.length) return out.labels_
        //set
        out.labels_ = v
        //update
        ;(0,_labels__WEBPACK_IMPORTED_MODULE_3__.updateLabels)(out)
        return out
    }

    // initiate Geometries class
    out.Geometries = (0,_geometries__WEBPACK_IMPORTED_MODULE_5__.Geometries)(out, withCenterPoints)

    /**
     * Requests geographic data and then builds the map template
     */
    out.updateGeoMapTemplate = function (callback) {
        // Erase previous data
        out.Geometries.defaultGeoData = null
        out.Geometries.allNUTSGeoData = null
        out.Geometries.centroidsData = null

        if (out.geometries_) {
            out.Geometries.setUserGeometries(out.geometries_)
            // use custom user-defined geometries
            out.buildMapTemplate()

            // Execute callback if defined
            if (callback) callback()
        } else {
            // use default
            out.Geometries.getDefaultGeoData(out.geo_, out.filterGeometriesFunction_, out.nutsLevel_).then(() => {
                out.buildMapTemplate()

                // Execute callback if defined
                if (callback) callback()
            })
        }

        // Use executeForAllInsets for recursive inset updates
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, (inset) => {
            inset.updateGeoMapTemplate(callback)
        })

        return out
    }

    /**
     * Build a map object, including container, frame, map svg, insets and d3 zoom
     */
    out.buildMapTemplateBase = function () {
        //get svg element. Create it if it does not exists
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#' + out.svgId())
        if (svg.size() == 0) {
            svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('body').append('svg').attr('id', out.svgId())
        }
        svg.attr('class', 'em-map')
        out.svg_ = svg

        //set container for cases where container contains various maps
        if (!out.containerId_) out.containerId_ = out.svgId_
        //tooltip needs to know container to prevent overflow
        if (!out.tooltip_.containerId) {
            out.tooltip_.containerId = out.containerId_
        }

        //clear SVG (to avoid building multiple svgs on top of each other during multiple build() calls)
        (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#' + out.svgId() + ' > *').remove()

        //set SVG dimensions
        if (out.geo_.toUpperCase() == 'WORLD') {
            //if no height was specified, use 45% of the width.
            if (!out.height()) out.height(0.55 * out.width())
            svg.attr('width', out.width()).attr('height', out.height())

            //WORLD geo only accepts proj 54030 (robinson) at the moment
            out.proj_ = 54030
        }
        //if no height was specified, use 85% of the width.
        if (!out.height()) out.height(0.85 * out.width())
        svg.attr('width', out.width()).attr('height', out.height())

        // each map template needs a clipPath to avoid overflow. See GISCO-2707
        svg.append('defs')
            .attr('class', 'em-defs')
            .append('clipPath')
            .attr('id', out.svgId_ + '-clip-path')
            .append('path')
            .attr('d', (0,_utils__WEBPACK_IMPORTED_MODULE_1__.convertRectanglesToPaths)(0, 0, out.width_, out.height_))

        if (out.drawCoastalMargin_) {
            //define filter for coastal margin
            svg.append('filter')
                .attr('id', 'em-coastal-blur')
                .attr('x', '-200%')
                .attr('y', '-200%')
                .attr('width', '400%')
                .attr('height', '400%')
                .append('feGaussianBlur')
                .attr('in', 'SourceGraphic')
                .attr('stdDeviation', out.coastalMarginStdDev_)
        }

        //create drawing group, as first child
        const dg = svg
            .insert('g', ':first-child')
            .attr('id', 'em-drawing-' + out.svgId_)
            .attr('class', 'em-drawing-group')
            .attr('clip-path', 'url(#' + out.svgId_ + '-clip-path' + ')')

        //create main zoom group
        const zg = dg
            .append('g')
            .attr('id', 'em-zoom-group-' + out.svgId_)
            .attr('class', 'em-zoom-group') //out.geo changed to out.svgId in order to be unique

        // build insets
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.removeInsets)(out) //remove existing
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.buildInsets)(out, withCenterPoints) //build new

        //draw frame
        dg.append('rect')
            .attr('id', 'em-frame-' + out.geo_)
            .attr('class', 'em-frame')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', out.width_)
            .attr('height', out.height_)

        if (out.stamp_) {
            (0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        }

        return out
    }

    /**
     * Buid an empty map template, based on the geometries only.
     */
    out.buildMapTemplate = function () {
        //prepare drawing group
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //remove all children
        zoomGroup.selectAll('*').remove()

        // separate logic for cartograms
        if (out.gridCartogram_ == true) {
            (0,_cartograms__WEBPACK_IMPORTED_MODULE_8__.buildGridCartogramBase)(out)
            out.footnote_ = false //dont need copyright
        } else {
            // default geographic logic

            // position
            if (!out.position_.x || !out.position_.y) {
                defineDefaultPosition()
            }
            out.position_.z = out.position_.z || getDefaultZ()

            // d3 projection/path functions
            defineProjection()
            definePathFunction()

            // d3 zoom
            if (out.zoomExtent()) {
                defineMapZoom()
            }

            if (out.backgroundMap_) {
                drawBackgroundMap(out)
            }
        }

        //prepare group for proportional symbols, with centroids
        if (withCenterPoints) {
            addCentroidsToMap(out)
        }

        // add geographical labels to map
        if (out.labels_) {
            (0,_labels__WEBPACK_IMPORTED_MODULE_3__.addLabelsToMap)(out, zoomGroup)
        }

        //annotations
        if (out.annotations_) {
            (0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
            out.annotationsAdded = true
        }

        //title
        if (out.title()) {
            //define default position
            let cssClass = out.isInset ? 'em-inset-title' : 'em-title'
            if (!out.titlePosition()) out.titlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssClass) + (out.isInset ? 0 : 10)])
            //draw title
            out.svg()
                .append('text')
                .attr('id', 'title' + out.geo_)
                .attr('class', cssClass)
                .attr('x', out.titlePosition()[0])
                .attr('y', out.titlePosition()[1])
                .html(out.title())
        }

        //subtitle
        if (out.subtitle()) {
            let cssSubtitleClass = out.isInset ? 'em-inset-subtitle' : 'em-subtitle'
            let cssTitleClass = out.isInset ? 'em-inset-title' : 'em-title'
            //define default position
            if (!out.subtitlePosition()) out.subtitlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssTitleClass) + (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssSubtitleClass) + 15])
            //draw subtitle
            out.svg()
                .append('text')
                .attr('id', 'subtitle' + out.geo_)
                .attr('class', cssSubtitleClass)
                .attr('x', out.subtitlePosition()[0])
                .attr('y', out.subtitlePosition()[1])
                .html(out.subtitle())
        }

        //bottom text
        if (out.footnote_) {
            addFootnote()
        }

        //source dataset URL
        if (out.showSourceLink_) {
            let stat
            if (withCenterPoints) {
                stat = out.stat('size')
            } else {
                stat = out.stat()
            }
            if (stat) {
                if (stat.eurostatDatasetCode) {
                    //dataset link
                    let code = stat.eurostatDatasetCode
                    let url = `https://ec.europa.eu/eurostat/databrowser/view/${code}/default/table?lang=en`
                    let link = out
                        .svg()
                        .append('a')
                        .attr('class', 'em-source-dataset-link')
                        .attr('href', url)
                        .attr('target', '_blank')
                        .append('text')
                        .attr('class', 'em-source-dataset-link-text')
                        .attr('x', out.width_)
                        .attr('y', out.height_)
                        .text('EUROSTAT')
                        .attr('text-anchor', 'end')

                    //pretext "Source:"
                    let linkW = link.node().getComputedTextLength()
                    out.svg()
                        .append('text')
                        .attr('class', 'em-source-pretext')
                        .attr('x', out.width_ - linkW - 2)
                        .attr('y', out.height_)
                        .text('Source:')
                        .attr('text-anchor', 'end')
                }
            }
        }

        // scalebar
        if (out.showScalebar_) {
            if (out.scalebarPosition_.length !== 2) {
                out.scalebarPosition_[0] = 15
                out.scalebarPosition_[1] = out.height_ - 50
            }
            addScalebarToMap()
        }

        return out
    }

    const drawBackgroundMap = function (out) {
        //draw background map
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw sea
        zoomGroup
            .append('rect')
            .attr('id', 'sea')
            .attr('class', 'em-sea')
            .attr('x', -5 * out.width_)
            .attr('y', -5 * out.height_)
            .attr('width', 11 * out.width_)
            .attr('height', 11 * out.height_)

        //sphere for world map
        if (out.geo_ == 'WORLD') {
            zoomGroup.append('path').datum({ type: 'Sphere' }).attr('id', 'sphere').attr('d', out._pathFunction).attr('class', 'em-graticule')
        }

        // coastal margin
        if (out.drawCoastalMargin_) {
            addCoastalMarginToMap()
        }

        // draw polygons and borders
        if (out.geometries_) {
            out.Geometries.addUserGeometriesToMap(out.geometries_, zoomGroup, out._pathFunction)
        } else {
            out.Geometries.addDefaultGeometriesToMap(
                zoomGroup,
                out.drawGraticule_,
                out._pathFunction,
                out.nutsLevel_,
                out.nutsYear_,
                out.geo_,
                out.proj_,
                out.scale_
            )
        }
    }

    const defineDefaultPosition = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            out.position_.x = out.position_.x || defaultPosition.geoCenter[0]
            out.position_.y = out.position_.y || defaultPosition.geoCenter[1]
        } else if (out.Geometries.defaultGeoData?.bbox) {
            // default to center of geoData bbox
            out.position_.x = out.position_.x || 0.5 * (out.Geometries.defaultGeoData.bbox[0] + out.Geometries.defaultGeoData.bbox[2])
            out.position_.y = out.position_.y || 0.5 * (out.Geometries.defaultGeoData.bbox[1] + out.Geometries.defaultGeoData.bbox[3])
        } else {
            //TODO: auto-define user=defined geometries geoCenter
            // out.position_.x = Geometries.userGeometries
            // out.position_.y = Geometries.userGeometries
        }

        // optional: set from URL
        setViewFromURL()
    }

    const getDefaultZ = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            return (defaultPosition.pixelSize * 800) / out.width_
        } else if (out.Geometries.defaultGeoData?.bbox) {
            return Math.min(
                (out.Geometries.defaultGeoData.bbox[2] - out.Geometries.defaultGeoData.bbox[0]) / out.width_,
                (out.Geometries.defaultGeoData.bbox[3] - out.Geometries.defaultGeoData.bbox[1]) / out.height_
            )
        } else {
            return 100
        }
    }

    const defineProjection = function () {
        // Define projection based on the geographical context

        if (out.geo_ === 'WORLD') {
            // Use Robinson projection for the world with optional custom projection function
            out._projection =
                out.projectionFunction_ ||
                (0,d3_geo_projection__WEBPACK_IMPORTED_MODULE_12__["default"])()
                    .translate([out.width_ / 2, out.height_ / 2])
                    .scale((out.width_ - 20) / (2 * Math.PI))
        } else {
            // For non-WORLD geo, use custom or default identity projection with calculated bounding box
            out._projection =
                out.projectionFunction_ || (0,d3_geo__WEBPACK_IMPORTED_MODULE_13__["default"])().reflectY(true).fitSize([out.width_, out.height_], (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getBBOXAsGeoJSON)(getCurrentBbox()))
        }
    }

    // Helper function to calculate current view as bbox
    const getCurrentBbox = function () {
        const halfWidth = 0.5 * out.position_.z * out.width_
        const halfHeight = 0.5 * out.position_.z * out.height_
        const bbox = [out.position_.x - halfWidth, out.position_.y - halfHeight, out.position_.x + halfWidth, out.position_.y + halfHeight]
        return bbox
    }

    const definePathFunction = function () {
        out._pathFunction = (0,d3_geo__WEBPACK_IMPORTED_MODULE_14__["default"])().projection(out._projection)
    }

    const defineMapZoom = function () {
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#' + out.svgId())
        let previousT = d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity
        const xoo = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()
            .scaleExtent(out.zoomExtent())
            .on('zoom', function (e) {
                const t = e.transform
                if (t.k !== previousT.k) {
                    zoomHandler(e, previousT)
                } else {
                    panHandler(e)
                }

                // apply default transform to map
                const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
                zoomGroup.attr('transform', t)
                previousT = t
            })

        svg.call(xoo)
    }

    // Zoom handler function
    const zoomHandler = function (event, previousT) {
        const transform = event.transform
        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k

        // Use the projection to get the projected center in EPSG:3035
        const [projectedX, projectedY] = out._projection.invert([centerX, centerY])

        // set new position
        out.position_.x = projectedX
        out.position_.y = projectedY
        out.position_.z = getMetresPerPixel(transform.k / previousT.k)

        // adjust stroke dynamically according to zoom
        scaleStrokeWidths(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.values) scaleLabelTexts(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.backgrounds) scaleLabelBackgrounds(transform)
    }

    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelBackgrounds = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('.em-label-background')
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            // Get the original width, height, x, and y from data attributes or current attributes
            const originalWidth = parseFloat(element.attr('data-width')) || parseFloat(element.attr('width'))
            const originalHeight = parseFloat(element.attr('data-height')) || parseFloat(element.attr('height'))
            const originalX = parseFloat(element.attr('data-x')) || parseFloat(element.attr('x'))
            const originalY = parseFloat(element.attr('data-y')) || parseFloat(element.attr('y'))

            // Only process elements that have valid width, height, x, and y
            if (originalWidth > 0 && originalHeight > 0 && !isNaN(originalX) && !isNaN(originalY)) {
                // Store the original width, height, x, and y for the first time if not already stored
                if (!element.attr('data-width')) {
                    element.attr('data-width', originalWidth)
                    element.attr('data-height', originalHeight)
                    element.attr('data-x', originalX)
                    element.attr('data-y', originalY)
                }

                // Calculate the target width, height, x, and y based on zoom factor (inverse scaling)
                const targetWidth = originalWidth * (1 / zoomFactor) // Inverse scaling
                const targetHeight = originalHeight * (1 / zoomFactor) // Inverse scaling
                const targetX = originalX * (1 / zoomFactor) // Adjust x position
                const targetY = originalY * (1 / zoomFactor) // Adjust y position

                // Add the style change to a batch array
                updates.push({ element, targetWidth, targetHeight, targetX, targetY })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetWidth, targetHeight, targetX, targetY }) => {
            element.attr('width', targetWidth).attr('height', targetHeight).attr('x', targetX).attr('y', targetY)
        })
    }
    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelTexts = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const labels = zoomGroup.select('#em-labels')
        const elements = labels.selectAll('*') // Select all labels
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get font-size from inline or computed style
            const inlineFontSize = element.attr('font-size')
            const cssFontSize = computedStyle.fontSize
            const fontSize = inlineFontSize || cssFontSize

            // Only process elements that have a font size defined
            if (fontSize && parseFloat(fontSize) > 0) {
                const originalFontSize = parseFloat(element.attr('data-fs')) || parseFloat(inlineFontSize) || parseFloat(cssFontSize)

                // Store the original font size for the first time
                if (!element.attr('data-fs')) {
                    element.attr('data-fs', originalFontSize)
                }

                // Calculate the target font size based on zoom factor
                const targetFontSize = originalFontSize / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetFontSize })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetFontSize }) => {
            element.style.setProperty('font-size', `${targetFontSize}px`, 'important')
        })
    }

    /**
     * @description adjusts all stroke-widths dynamically according to zoom
     * @param {*} transform
     */
    const scaleStrokeWidths = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('*') // Select all elements in the zoom group
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get stroke-width from inline or computed style
            const inlineStrokeWidth = element.attr('stroke-width')
            const cssStrokeWidth = computedStyle.strokeWidth
            const strokeWidth = inlineStrokeWidth || cssStrokeWidth

            // Only process elements that have a stroke width defined
            if (strokeWidth && parseFloat(strokeWidth) > 0) {
                const originalStrokeWidth = parseFloat(element.attr('data-sw')) || parseFloat(inlineStrokeWidth) || parseFloat(cssStrokeWidth)

                // Store the original stroke width for the first time
                if (!element.attr('data-sw')) {
                    element.attr('data-sw', originalStrokeWidth)
                }

                // Calculate the target stroke width
                const targetStrokeWidth = originalStrokeWidth / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetStrokeWidth })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetStrokeWidth }) => {
            element.style.setProperty('stroke-width', `${targetStrokeWidth}px`, 'important')
        })
    }

    /**
     * @description get the current view's metres per pixel, based on a zoomFactor
     * @param {number} zoomFactor this zoom / previous zoom
     * @return {number}
     */
    const getMetresPerPixel = function (zoomFactor) {
        // Get current bounding box width in meters
        const bbox = getCurrentBbox()
        const bboxWidth = bbox[2] - bbox[0] // BBOX width in meters

        // Calculate meters per pixel
        const metersPerPixel = bboxWidth / (out.width_ * zoomFactor)

        return metersPerPixel
    }

    // Pan handler function
    const panHandler = function (event, previousT) {
        const transform = event.transform

        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k
        let [geoX, geoY] = out._projection.invert([centerX, centerY])

        // Clamp geoX and geoY to max bounds and adjust the event transform
        if (out.maxBounds_.xMin !== undefined && geoX < out.maxBounds_.xMin) {
            geoX = out.maxBounds_.xMin
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMin !== undefined && geoY < out.maxBounds_.yMin) {
            geoY = out.maxBounds_.yMin
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }
        if (out.maxBounds_.xMax !== undefined && geoX > out.maxBounds_.xMax) {
            geoX = out.maxBounds_.xMax
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMax !== undefined && geoY > out.maxBounds_.yMax) {
            geoY = out.maxBounds_.yMax
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }

        // set new position
        out.position_.x = geoX
        out.position_.y = geoY
    }

    /** Get x,y,z elements from URL and assign them to the view. */
    const setViewFromURL = function () {
        const x = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('x'),
            y = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('y'),
            z = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('z')
        if (x != null && x != undefined && !isNaN(+x)) out.position_.x = +x
        if (y != null && y != undefined && !isNaN(+y)) out.position_.y = +y
        if (z != null && z != undefined && !isNaN(+z)) out.position_.z = +z
    }

    const addFootnote = function () {
        out.svg()
            .append('text')
            .attr('id', 'em-footnote')
            .attr('class', 'em-footnote')
            .attr('x', 0)
            .attr('y', out.height_)
            .html(out.footnote_)
            .on('mouseover', function () {
                out._tooltip.mw___ = out._tooltip.style('max-width')
                out._tooltip.style('max-width', '400px')
                if (out.footnoteTooltipText_) out._tooltip.mouseover(out.footnoteTooltipText_)
            })
            .on('mousemove', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mouseout(e)
                out._tooltip.style('max-width', out._tooltip.mw___)
            })
    }

    const addCoastalMarginToMap = function () {
        const zg = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw coastal margin
        const cg = zg.append('g').attr('id', 'em-coast-margin').attr('class', 'em-coast-margin')

        //countries bn
        if (out.Geometries.geoJSONs.cntbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-cnt')
                .attr('class', 'em-coast-margin-cnt')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.cntbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //nuts bn
        if (out.Geometries.geoJSONs.nutsbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-nuts')
                .attr('class', 'em-coast-margin-nuts')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //world bn
        if (out.Geometries.geoJSONs.worldbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-world')
                .attr('class', 'em-coast-margin-world')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.worldbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.COAS_FLAG === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }
    }

    const addCentroidsToMap = function (map) {
        let centroidFeatures

        if (!map.Geometries.centroidsData) {
            // if centroids data is absent (e.g. for world maps) then calculate manually
            if (map.geo_ == 'WORLD') {
                centroidFeatures = []
                map.Geometries.geoJSONs.worldrg.forEach((feature) => {
                    let newFeature = { ...feature }
                    // exception for France (because guyane)
                    if (feature.properties.id == 'FR') {
                        newFeature.geometry = {
                            coordinates: [2.2, 46.2],
                            type: 'Point',
                        }
                    } else {
                        newFeature.geometry = {
                            coordinates: (0,d3_geo__WEBPACK_IMPORTED_MODULE_15__["default"])(feature),
                            type: 'Point',
                        }
                    }
                    centroidFeatures.push(newFeature)
                })
            }
        } else {
            if (map.nutsLevel_ == 'mixed') {
                centroidFeatures = [
                    ...map.Geometries.centroidsData[0].features,
                    ...map.Geometries.centroidsData[1].features,
                    ...map.Geometries.centroidsData[2].features,
                    ...map.Geometries.centroidsData[3].features,
                ]
            } else {
                centroidFeatures = map.Geometries.centroidsData.features
            }
        }

        if (map.processCentroids_) centroidFeatures = map.processCentroids_(centroidFeatures)

        // calculate screen coordinates and save centroids to map
        map.Geometries.centroidFeatures = centroidFeatures.map((d) => {
            let coords = map._projection(d.geometry.coordinates)
            d.properties.centroid = coords
            return d
        })

        // em-prop-symbols is the g element containing all proportional symbols for the map
        const zg = map.svg().select('#em-zoom-group-' + map.svgId_)
        const gcp = zg.append('g').attr('id', 'em-prop-symbols')

        // add centroid em-centroid elements
        // then symbols are drawn/appended to these containers in the map-type js file
        const symbolContainers = gcp
            .selectAll('g')
            .data(map.Geometries.centroidFeatures)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                return 'translate(' + d.properties.centroid[0].toFixed(3) + ',' + d.properties.centroid[1].toFixed(3) + ')'
            })
            .attr('class', 'em-centroid') // OUR SYMBOL CONTAINER
            .attr('id', (d) => 'ps' + d.properties.id)
    }

    /**
     * @function addScalebarToMap
     * @description appends an SVG scalebar to the map. Uses pixelSize to calculate units in km
     */
    const addScalebarToMap = function () {
        // Julien's nice scalebars
        const marginLeft = 5
        const maxLengthPix = out.scalebarMaxWidth_
        const textOffsetX = out.scalebarTextOffset_[0]
        const textOffsetY = out.scalebarTextOffset_[1]
        const pixelSizeM = out.position_.z
        const maxLengthM = maxLengthPix * pixelSizeM
        const niceLengthM = niceScaleBarLength(maxLengthM)
        const niceLengthPixel = niceLengthM[0] / pixelSizeM
        const scaleBarStartDigit = niceLengthM[1]
        const subdivisionNbs = {
            1: 4,
            2: 2,
            5: 5,
        }

        const scalebarGroup = out
            .svg()
            .append('g')
            .attr('class', 'em-scalebar')
            .attr('transform', `translate(${out.scalebarPosition_[0]},${out.scalebarPosition_[1]})`)
            .attr('width', maxLengthPix + 20)
            .attr('height', out.scalebarHeight_)

        // top line full width
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', marginLeft)
            .attr('y1', 1)
            .attr('x2', niceLengthPixel + marginLeft)
            .attr('y2', 1)

        //bottom line full width
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', marginLeft)
            .attr('y1', out.scalebarSegmentHeight_)
            .attr('x2', niceLengthPixel + marginLeft)
            .attr('y2', out.scalebarSegmentHeight_)

        //first tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', marginLeft)
            .attr('y1', 1)
            .attr('x2', marginLeft)
            .attr('y2', out.scalebarTickHeight_)

        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text('0')

        //middle ticks
        const subdivisionNb = subdivisionNbs[scaleBarStartDigit]
        const divisionWidth = niceLengthPixel / subdivisionNb
        const divisionMinWidth = 15
        if (divisionWidth >= divisionMinWidth) {
            for (let i = 1; i < subdivisionNb; i++) {
                scalebarGroup
                    .append('line')
                    .attr('class', 'em-scalebar-line')
                    .attr('x1', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y1', 1)
                    .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y2', out.scalebarTickHeight_)
                scalebarGroup
                    .append('text')
                    .attr('class', 'em-scalebar-label')
                    .attr('x', marginLeft + textOffsetX + i * divisionWidth)
                    .attr('y', out.scalebarTickHeight_ + textOffsetY)
                    .text(getScalebarLabel((niceLengthM[0] / subdivisionNb) * i))
            }

            //every other segment mid-line
            for (let i = -1; i < subdivisionNb; i += 2) {
                if (i == 1) {
                    scalebarGroup
                        .append('line')
                        .attr('class', 'em-scalebar-line')
                        .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                        .attr('y1', out.scalebarSegmentHeight_ / 2)
                        .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                        .attr('y2', out.scalebarSegmentHeight_ / 2)
                } else {
                    let x1 = marginLeft + out.scalebarStrokeWidth_ / 2 + (i - 1) * divisionWidth
                    if (x1 > 0) {
                        scalebarGroup
                            .append('line')
                            .attr('class', 'em-scalebar-line')
                            .attr('x1', x1)
                            .attr('y1', out.scalebarSegmentHeight_ / 2)
                            .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                            .attr('y2', out.scalebarSegmentHeight_ / 2)
                    }
                }
            }
        } else {
            // single full-length horizontal mid-line
            scalebarGroup
                .append('line')
                .attr('class', 'em-scalebar-line')
                .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                .attr('y1', out.scalebarSegmentHeight_ / 2)
                .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + divisionWidth * subdivisionNb)
                .attr('y2', out.scalebarSegmentHeight_ / 2)
        }

        //last tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', niceLengthPixel + marginLeft)
            .attr('y1', 1)
            .attr('x2', niceLengthPixel + marginLeft)
            .attr('y2', out.scalebarTickHeight_)
        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', niceLengthPixel + marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text(getScalebarLabel(niceLengthM[0]) + out.scalebarUnits_)
    }

    const niceScaleBarLength = function (scaleBarLength) {
        //compute the 'nice' power of ten
        const pow10 = Math.pow(10, Math.floor(Math.log(scaleBarLength) / Math.log(10)))

        //check if 5 times this value fits
        if (5 * pow10 <= scaleBarLength) return [5 * pow10, 5]

        //check if 2 times this value fits
        if (2 * pow10 <= scaleBarLength) return [2 * pow10, 2]

        //returns the power of ten
        return [pow10, 1]
    }

    const getScalebarLabel = function (valueM) {
        if (valueM < 0.01) return valueM * 1000 + 'mm'
        if (valueM < 1) return valueM * 100 + 'cm'
        if (valueM < 1000) return valueM * 1 + 'm'
        return valueM / 1000
    }

    return out
}

/** Default geocenter positions and pixelSize (for default width = 800px) for territories and projections. */
const _defaultPosition = {
    EUR_3035: { geoCenter: [4970000, 3350000], pixelSize: 6800 },
    IC_32628: { geoCenter: [443468, 3145647], pixelSize: 1000 },
    GP_32620: { geoCenter: [669498, 1784552], pixelSize: 130 },
    MQ_32620: { geoCenter: [716521, 1621322], pixelSize: 130 },
    GF_32622: { geoCenter: [266852, 444074], pixelSize: 500 },
    RE_32740: { geoCenter: [348011, 7661627], pixelSize: 130 },
    YT_32738: { geoCenter: [516549, 8583920], pixelSize: 70 },
    MT_3035: { geoCenter: [4719755, 1441701], pixelSize: 70 },
    PT20_32626: { geoCenter: [397418, 4271471], pixelSize: 1500 },
    PT30_32628: { geoCenter: [333586, 3622706], pixelSize: 150 },
    LI_3035: { geoCenter: [4287060, 2672000], pixelSize: 40 },
    IS_3035: { geoCenter: [3011804, 4960000], pixelSize: 700 },
    SJ_SV_3035: { geoCenter: [4570000, 6160156], pixelSize: 800 },
    SJ_JM_3035: { geoCenter: [3647762, 5408300], pixelSize: 100 },
    CARIB_32620: { geoCenter: [636345, 1669439], pixelSize: 500 },
    WORLD_54030: { geoCenter: [14, 17], pixelSize: 9000 },
}


/***/ }),

/***/ "./src/core/stamps.js":
/*!****************************!*\
  !*** ./src/core/stamps.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendStamp: () => (/* binding */ appendStamp)
/* harmony export */ });
const appendStamp = (stampConfig, map) => {
    if (map.svg_) {
        const existing = map.svg_.select('#em-stamp')
        existing.remove()

        if (stampConfig) {
            const container = map.svg_.append('g').attr('id', 'em-stamp')

            // Set defaults
            if (!stampConfig.size) stampConfig.size = 60
            if (!stampConfig.x) stampConfig.x = 230
            if (!stampConfig.y) stampConfig.y = 100
            if (!stampConfig.textColor) stampConfig.textColor = '#000'
            if (!stampConfig.stampColor) stampConfig.stampColor = '#000'
            if (!stampConfig.strokeWidth) stampConfig.strokeWidth = 1
            if (!stampConfig.lineHeight) stampConfig.lineHeight = 15

            // Draw the circle
            container
                .append('circle')
                .attr('r', stampConfig.size)
                .attr('cx', stampConfig.x)
                .attr('cy', stampConfig.y)
                .attr('id', 'em-stamp-circle')
                .attr('fill', 'none')
                .attr('stroke', stampConfig.stampColor)
                .attr('stroke-width', stampConfig.strokeWidth)

            // Handle text
            const text = stampConfig.text
            const targetWidth = Math.sqrt(measureWidth(text.trim()) * stampConfig.lineHeight)
            const lines = getLines(getWords(text.trim()), targetWidth)
            const textRadius = getTextRadius(lines, stampConfig.lineHeight)

            // Append inside circle
            container
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('fill', stampConfig.textColor)
                .attr('id', 'em-stamp-text')
                .attr('transform', `translate(${stampConfig.x},${stampConfig.y}) scale(${stampConfig.size / textRadius})`)
                .selectAll('tspan')
                .data(lines)
                .enter()
                .append('tspan')
                .attr('x', 0)
                .attr('y', (d, i) => (i - lines.length / 2 + 0.8) * stampConfig.lineHeight)
                .text((d) => d.text.replaceAll('~', ' ').replaceAll('¶', '')) // Removes ¶ (line breaker) and ~ (non breaking space)
        }
    }
}

// Splitting by both spaces and pilcrows
const getWords = (text) => {
    return text
        .split(/(?<=¶)|\s+/g)
        .map((word) => word.trim())
        .filter((word) => word.length > 0)
}

// Computes text width
const measureWidth = (text) => {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text')

    textElement.textContent = text
    svg.appendChild(textElement)
    document.body.appendChild(svg)

    const width = textElement.getComputedTextLength()
    document.body.removeChild(svg)

    return width + 10
}

// Compute text radius
const getTextRadius = (lines, lineHeight) => {
    let radius = 0
    for (let i = 0, n = lines.length; i < n; ++i) {
        const dy = (Math.abs(i - n / 2 + 0.5) + 0.5) * lineHeight
        const dx = lines[i].width / 2
        radius = Math.max(radius, Math.sqrt(dx ** 2 + dy ** 2))
    }
    return radius
}

// Handles forced line breaks
const getLines = (words, targetWidth) => {
    let lines = []
    let line = { width: 0, text: '' }

    for (let i = 0, n = words.length; i < n; ++i) {
        if (words[i] === '¶') {
            // Push current line (if it has text)
            if (line.text) lines.push(line)
            // Start a new empty line
            line = { width: 0, text: '' }
            continue
        }

        let lineText1 = (line.text ? line.text + ' ' : '') + words[i]
        let lineWidth1 = measureWidth(lineText1)

        if ((line.width + lineWidth1) / 2 < targetWidth) {
            line.width = lineWidth1
            line.text = lineText1
        } else {
            lines.push(line)
            line = { width: measureWidth(words[i]), text: words[i] }
        }
    }

    if (line.text) lines.push(line) // Push last line if it exists

    return lines
}


/***/ }),

/***/ "./src/core/stat-data.js":
/*!*******************************!*\
  !*** ./src/core/stat-data.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   statData: () => (/* binding */ statData)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonstat-toolkit */ "./node_modules/jsonstat-toolkit/import.mjs");





/**
 * A statistical dataset, to be used for a statistical map.
 *
 * @param {*} config
 */
const statData = function (config) {
    //build stat data object
    const out = {}

    out.__data = undefined //for debugging

    //out.maxNumberOfDecimalsInDataset = undefined

    /**
     * The statistical values, indexed by NUTS id.
     * Each stat value is an object {value,status}.
     */
    out._data_ = undefined

    /**
     * Return the stat value {value,status} from a nuts id.
     * If no argument is specified, returns the entire index.
     * @param {*} nutsId
     */
    out.get = (nutsId) => {
        if (!nutsId) {
            return out._data_
        } else {
            if (out._data_) {
                return out._data_[nutsId]
            } else {
                return undefined
            }
        }
    }

    /**
     * Return the stat value from a nuts id.
     * @param {*} nutsId
     */
    out.getValue = (nutsId) => {
        const s = out.get(nutsId)
        return s ? s.value : undefined
    }

    /**
     * Set a stat value from a nuts id.
     *
     * @param {String} nutsId
     * @param {Object || String || Number} stat The new statistical data. The format can be either {value:34.324,status:"e"} or a the value only.
     */
    out.set = (nutsId, stat) => {
        out._data_ = out._data_ || {}
        const s = out._data_[nutsId]

        if (s) {
            if (stat.value) {
                s.value = stat.value
                s.status = stat.status
            } else {
                // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
                s.value = stat
                //s.value = isNaN(+stat) ? stat : +stat
            }
        } else {
            // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
            out._data_[nutsId] = stat.value ? stat : { value: stat }
            //out._data_[nutsId] = stat.value ? stat : { value: isNaN(+stat) ? stat : +stat}
        }
        return out
    }

    /**
     * Set statistical data, already indexed by nutsId.
     *
     * @param {Object} data Something like: { "PT":0.2, "LU":0.6, ...}, or with status: { "PT": {value:0.2, status:"e"}, "LU":0.6, ...}
     */
    out.setData = (data) => {
        out.__data = data // for debugging
        out._data_ = {} // overwrite existing data
        Object.keys(data).forEach((nutsId) => out.set(nutsId, data[nutsId]))
        return out
    }

    /** Return all stat values as an array. This can be used to classify the values. */
    out.getArray = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || s)
        }
    }

    /** Return stat unique values. This can be used for categorical maps. */
    out.getUniqueValues = function () {
        return Object.values(out._data_)
            .map((s) => s.value)
            .filter((item, i, ar) => ar.indexOf(item) === i)
    }

    /** Get min value. */
    out.getMin = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.min(acc, v))
        }
    }
    /** Get max value. */
    out.getMax = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.max(acc, v))
        }
    }

    /** Check if the stat data is ready. */
    out.isReady = function () {
        return out._data_ != undefined
    }

    /** Some metadata */
    out.metadata = undefined

    //a text for the statitics unit of measure, to be shown in the tooltip
    out.unitText_ = undefined

    /**
     * Retrieve stat data from remote data sources.
     *
     * @param {*} nutsLevel
     * @param {*} callback
     */
    out.retrieveFromRemote = function (nutsLevel, lang, callback) {
        if (out.eurostatDatasetCode_) updateEurobase(nutsLevel, lang, callback)
        else if (out.csvURL_) updateCSV(callback)
        return out
    }

    //TODO decompose into Eurobase/jsonstat and CSV types ?

    /**
     * Eurobase/jsonstat data source
     * See https://ec.europa.eu/eurostat/web/json-and-unicode-web-services/getting-started/rest-request
     */

    /** The Eurobase dataset code */
    out.eurostatDatasetCode_ = undefined
    /** The Eurobase code */
    out.filters_ = { lastTimePeriod: 1 }
    /** The precision (number of decimal places) */
    out.precision_ = 2

    /**
     * Return promise for Eurobase/jsonstat data.
     */
    const getEurobasePromise = function (nutsLevel, lang) {
        //set precision //DEPRECATED 16/11/2021 https://ec.europa.eu/eurostat/online-help/public/en/NAVIGATION_WDDSTranslator_migration_en/#DECOMMISSION
        //out.filters_["precision"] = out.precision_;
        //select only required geo groups, depending on the specified nuts level
        if (!out.filters_.geo) {
            out.filters_['geoLevel'] = nutsLevel + '' === '0' ? 'country' : 'nuts' + nutsLevel
        }

        //force filtering of euro-geo-aggregates
        //out.filters_["filterNonGeo"] = 1; //DEPRECATED 16/11/2021

        //retrieve stat data from Eurostat API
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getEstatDataURL)(out.eurostatDatasetCode_, out.filters_, lang))
    }

    //for eurobase statistical data to retrieve from Eurostat API
    const updateEurobase = function (nutsLevel, lang, callback) {
        //erase previous data
        out._data_ = null

        getEurobasePromise(nutsLevel, lang).then(function (data___) {
            //decode stat data
            const jsd = (0,jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__["default"])(data___)

            //store jsonstat metadata
            out.metadata = {
                label: jsd.label,
                href: jsd.href,
                source: jsd.source,
                updated: jsd.updated,
                extension: jsd.extension,
            }
            out.metadata.time = jsd.Dimension('time').id[0]

            //index
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.jsonstatToIndex)(jsd)
            //TODO: use maybe https://github.com/badosa/JSON-stat/blob/master/utils/fromtable.md to build directly an index ?

            if (callback) callback()
        })
    }

    /**
     * Return the time stamp of the jsonstat dataset.
     */
    out.getTime = function () {
        const t = out.filters_.time
        if (t) return t
        if (!out._data_) return
        return out.metadata.time
    }

    /**
     * CSV data source
     */

    /** The CSV file URL */
    out.csvURL_ = undefined
    /** The CSV column with the NUTS ids */
    out.geoCol_ = 'geo'
    /** The CSV column with the statistical values */
    out.valueCol_ = 'value'

    /**
     * Return promise for CSV data.
     */
    const getCSVPromise = function (nutsLevel) {
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_3__.csv)(out.csvURL_)
    }

    //for statistical data to retrieve from CSV file
    const updateCSV = function (callback) {
        //erase previous data
        out._data_ = null

        //retrieve csv data
        getCSVPromise().then(function (data___) {
            //decode stat data
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.csvToIndex)(data___, out.geoCol_, out.valueCol_)

            //store some metadata
            out.metadata = { href: out.csvURL_ }

            if (callback) callback()
        })
    }

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['unitText_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config) for (let key in config) out[key + '_'] = config[key]

    return out
}


/***/ }),

/***/ "./src/core/stat-map.js":
/*!******************************!*\
  !*** ./src/core/stat-map.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getURLParameters: () => (/* binding */ getURLParameters),
/* harmony export */   statMap: () => (/* binding */ statMap)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");
/* harmony import */ var _stat_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat-data */ "./src/core/stat-data.js");
/* harmony import */ var _legend_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../legend/legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tooltip/tooltip */ "./src/tooltip/tooltip.js");







/**
 * An abstract statistical map: A map template with statistical data, without any particular styling rule.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const statMap = function (config, withCenterPoints, mapType) {
    //build stat map from map template
    const out = _map_template__WEBPACK_IMPORTED_MODULE_1__.mapTemplate(config, withCenterPoints, mapType)

    //statistical data

    //the statistical data configuration.
    //A map can have several stat datasets. This is a dictionary of all stat configuration
    out.stat_ = { default: undefined }
    out.stat = function (k, v) {
        //no argument: getter - return the default stat
        if (!arguments.length) return out.stat_['default']
        //two arguments: setter - set the config k with value v
        if (arguments.length == 2) {
            out.stat_[k] = v
            return out
        }
        //one string argument: getter - return the config k
        if (typeof k === 'string' || k instanceof String) return out.stat_[k]
        //one non-string argument: setter - set the entire dictionnary
        out.stat_ = k.default ? k : { default: k }
        return out
    }

    //the statistical data, retrieved from the config information. As a dictionary.
    out.statData_ = {
        default: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        color: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        size: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v1: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v2: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //bivariate
        v3: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //trivariate
    }
    out.statData = function (k, v) {
        //no argument: getter - return the default statData
        if (!arguments.length) return out.statData_['default']
        //one argument: getter
        if (arguments.length == 1) return out.statData_[k]
        //setter
        out.statData_[k] = v
        return out
    }

    //test for no data case
    out.noDataText_ = 'No data available'
    //langage (currently used only for eurostat data API)
    out.language_ = 'en'
    //transition time for rendering
    out.transitionDuration_ = 500
    //specific tooltip text function
    out.tooltip_.textFunction = undefined
    //for maps using special fill patterns, this is the function to define them in the SVG image - See functions: getFillPatternLegend and getFillPatternDefinitionFun
    out.filtersDefinitionFunction_ = undefined
    //a callback function to execute after the map build is complete.
    out.callback_ = undefined

    //legend configuration
    out.legend_ = undefined
    //legend object
    out.legendObj_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['legend_', 'legendObj_', 'noDataText_', 'language_', 'transitionDuration_', 'tooltipText_', 'filtersDefinitionFunction_', 'callback_'].forEach(
        function (att) {
            out[att.substring(0, att.length - 1)] = function (v) {
                if (!arguments.length) return out[att]
                out[att] = v
                return out
            }
        }
    )

    //override attribute values with config values
    if (config) for (let key in config) if (out[key] && config[key] != undefined) out[key](config[key])

    // override legend for updating after build
    out.legend = function (v) {
        if (!arguments.length) return out.legend_
        out.legend_ = v
        //update if existing legend
        if (out.legendObj_) out.updateLegend()
        return out
    }

    out.updateLegend = function (v) {
        if (out.legendObj_) out.legendObj().update()
        return out
    }

    /**
     * Build the map.
     * This method should be called once, preferably after the map attributes have been set to some initial values.
     */
    out.build = function () {
        if (out.projectionFunction_) out.proj('4326') //when using custom d3 projection function always request NUTS2JSON in WGS84

        //build map template base
        out.buildMapTemplateBase()

        //add additional filters for fill patterns for example
        if (out.filtersDefinitionFunction_) {
            out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        }

        //legend element
        if (out.legend()) {
            out.buildLegend()
        }

        //define tooltip
        //prepare map tooltip
        if (out.tooltip_) {
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip(out.tooltip_)
        } else {
            //no config specified, use default
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip()
        }

        //launch geo data retrieval
        out.updateGeoData()

        //launch stat data retrieval
        out.updateStatData()

        return out
    }

    out.buildLegend = function () {
        //create legend object
        out.legendObj(out.getLegendConstructor()(out, out.legend()))
        const legend = out.legendObj()

        //get legend svg. If it does not exist, create it embeded within the map
        let legendSvg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#' + legend.svgId)
        if (legendSvg.size() == 0) {
            //get legend position
            const x = legend.x == undefined ? out.width() - 100 - legend.boxPadding : legend.x
            const y = legend.y == undefined ? legend.boxPadding : legend.y

            //build legend SVG in a new group
            out.svg()
                .append('g')
                .attr('id', legend.svgId)
                .attr('class', 'em-legend')
                .attr('transform', 'translate(' + x + ',' + y + ')')
        }

        legend.build()
    }

    /** Check if all stat datasets have been loaded. */
    const isStatDataReady = function () {
        for (let statKey in out.stat_) {
            if (!out.statData_[statKey].isReady()) {
                // BUG HERE. E.G. for chbi maps the user callback is never executed for all inset maps because isReady() returns false, because v1 and v2 are specified but not 'default'.
                return false
            }
        }
        return true
    }

    /**
     * Launch map geo data retrieval, and make/update the map once received.
     * This method should be called after attributes related to the map geometries have changed, to retrieve this new data and refresh the map.
     */
    out.updateGeoData = function () {
        out.updateGeoMapTemplate(() => {
            //if stat datasets have not been loaded, wait again
            if (!isStatDataReady()) return

            //proceed with map construction
            out.updateStatValues()
            //execute callback function
            if (out.callback()) out.callback()(out)
        })

        return out
    }

    /**
     * Launch map geo stat datasets retrieval, and make/update the map once received.
     * This method should be called after specifications on the stat data sources attached to the map have changed, to retrieve this new data and refresh the map.
     */
    out.updateStatData = function () {
        for (let statKey in out.stat_) {
            //case when no stat data source is specified and stat data where specified programmatically
            //bug - map.statData('size').setData({ ES: 10000, DE: 10000, FR: 5000 }) results in out.statData(statKey).get() = undefined
            if (!out.stat(statKey) && out.statData(statKey).get()) return

            //if no config is specified, use default data source: population density - why?
            //TODO move that out of loop ?
            if (statKey == 'default' && !out.stat(statKey)) {
                out.stat(statKey, { eurostatDatasetCode: 'demo_r_d3dens', unitText: 'inhab./km²' })
            }

            //build stat data object from stat configuration and store it
            const statData = _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(out.stat(statKey))
            out.statData(statKey, statData)

            //launch query
            let nl = out.nutsLevel_
            if (out.nutsLevel_ == 'mixed') {
                nl = 0
            }
            statData.retrieveFromRemote(nl, out.language(), () => {
                //if geodata has not been loaded, wait again
                if (!out.Geometries.isGeoReady()) return
                //if stat datasets have not all been loaded, wait again
                if (!isStatDataReady()) return

                //proceed with map construction
                out.updateStatValues()

                //execute callback function
                if (out.callback()) out.callback()()
            })
        }

        return out
    }

    /**
     * Make/update the map with new stat data.
     * This method should be called after stat data attached to the map have changed, to refresh the map.
     * If the stat data sources have changed, call *updateStatData* instead.
     */
    out.updateStatValues = function () {
        //update classification and styles
        out.updateClassification()
        out.updateStyle()

        //update legend, if any
        if (out.legendObj()) out.legendObj().update()

        return out
    }

    /**
     * Abstract method.
     * Make/update the map after classification attributes have been changed.
     * For example, if the number of classes, or the classification method has changed, call this method to update the map.
     */
    out.updateClassification = function () {
        console.log('Map updateClassification function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Make/update the map after styling attributes have been changed.
     * For example, if the style (color?) for one legend element has changed, call this method to update the map.
     */
    out.updateStyle = function () {
        console.log('Map updateStyle function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Function which return the legend constructor function for the map.
     */
    out.getLegendConstructor = function () {
        console.log('Map getLegendConstructor function not implemented')
        return _legend_legend__WEBPACK_IMPORTED_MODULE_3__.legend
    }

    /**
     * Retrieve the time stamp of the map, even if not specified in the dimension initially.
     * This applies only for stat data retrieved from Eurostat API.
     * This method is useful for example when the data retrieved is the freshest, and one wants to know what this date is, for example to display it in the map title.
     */
    out.getTime = function () {
        return out.statData('default').getTime()
    }

    /**
     * Set some map attributes based on the following URL parameters:
     * "w":width, "h":height, "x":xGeoCenter, "y":yGeoCenter, "z":pixGeoSize, "s":scale, "lvl":nuts level, "time":time,
     * "proj":CRS, "geo":geo territory, "ny":nuts version, "language":langage, "numberOfClasses":class number
     */
    out.setFromURL = function () {
        const opts = getURLParameters()
        if (opts.w) out.width(opts.w)
        if (opts.h) out.height(opts.h)
        if (opts.x && opts.y) out.geoCenter([opts.x, opts.y])
        if (opts.z) out.pixelSize(opts.z)
        if (opts.s) out.scale(opts.s)
        if (opts.lvl) out.nutsLevel(opts.lvl)
        if (opts.time) {
            out.filters_.time = opts.time
            delete out.filters_.lastTimePeriod
        }
        if (opts.proj) out.proj(opts.proj)
        if (opts.geo) out.geo(opts.geo)
        if (opts.ny) out.nutsYear(opts.ny)
        if (opts.language) out.language(opts.language)
        if (opts.numberOfClasses) out.numberOfClasses(+opts.numberOfClasses)
        return out
    }

    /**
     * @function exportMapToSVG
     * @description Exports the current map with styling to SVG and downloads it
     *
     */
    out.exportMapToSVG = function () {
        // Clone the original SVG node to avoid modifying the DOM
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Add XML namespaces if not already present
        if (!svgNodeClone.hasAttribute('xmlns')) {
            svgNodeClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
        }
        if (!svgNodeClone.hasAttribute('xmlns:xlink')) {
            svgNodeClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
        }

        // Temporarily append the clone to the document to compute styles
        document.body.appendChild(svgNodeClone)

        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Remove the cloned SVG from the document after applying styles
        document.body.removeChild(svgNodeClone)

        const svgUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getDownloadURL)(svgNodeClone)

        // Create a download link and trigger download
        const downloadLink = document.createElement('a')
        downloadLink.href = svgUrl
        downloadLink.download = 'eurostatmap.svg'
        document.body.appendChild(downloadLink)
        downloadLink.click()
        document.body.removeChild(downloadLink)

        return out
    }

    /**
     * @function exportMapToPNG
     * @description Exports the current map with styling to PNG and downloads it
     *
     */
    out.exportMapToPNG = function (width, height) {
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Step 1: Serialize the SVG node to a string
        const serializer = new XMLSerializer()
        const svgString = serializer.serializeToString(svgNodeClone)

        // Step 2: Create a Blob from the serialized SVG
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' })

        // Step 3: Create a URL for the Blob
        const url = URL.createObjectURL(svgBlob)

        // Get the width and height attributes from the SVG
        width = width || svgNodeClone.getAttribute('width')
        height = height || svgNodeClone.getAttribute('height')

        if (!width || !height) {
            throw new Error('SVG width or height attributes are missing or invalid.')
        }

        // Step 4: Create an Image element and load the Blob URL
        const img = new Image()
        img.onload = function () {
            // Step 5: Draw the image on a canvas
            const canvas = document.createElement('canvas')
            canvas.width = parseFloat(width) // Set canvas width from SVG's width attribute
            canvas.height = parseFloat(height) // Set canvas height from SVG's height attribute

            const context = canvas.getContext('2d')
            context.drawImage(img, 0, 0, canvas.width, canvas.height)

            // Step 6: Convert the canvas to a PNG blob
            canvas.toBlob(function (pngBlob) {
                // Step 7: Download the PNG file
                const pngUrl = URL.createObjectURL(pngBlob)
                const downloadLink = document.createElement('a')
                downloadLink.href = pngUrl
                downloadLink.download = 'eurostat-map.png'
                document.body.appendChild(downloadLink)
                downloadLink.click()
                document.body.removeChild(downloadLink)

                // Clean up URLs
                URL.revokeObjectURL(url)
                URL.revokeObjectURL(pngUrl)
            }, 'image/png')
        }

        // Set the image source to the Blob URL
        img.src = url
        return out
    }

    return out
}

/**
 * Retrieve some URL parameters, which could be then reused as map definition parameters.
 * This allow a quick map customisation by simply adding and changing some URL parameters.
 * See map method: setFromURL(...)
 */
const getURLParameters = function () {
    const ps = {}
    const p = ['w', 'h', 'x', 'y', 'z', 's', 'lvl', 'time', 'proj', 'geo', 'ny', 'language', 'sl', 'numberOfClasses']
    for (let i = 0; i < p.length; i++) ps[p[i]] = getURLParameterByName(p[i])
    return ps
}


/***/ }),

/***/ "./src/core/utils.js":
/*!***************************!*\
  !*** ./src/core/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyInlineStylesFromCSS: () => (/* binding */ applyInlineStylesFromCSS),
/* harmony export */   convertRectanglesToPaths: () => (/* binding */ convertRectanglesToPaths),
/* harmony export */   csvToIndex: () => (/* binding */ csvToIndex),
/* harmony export */   executeForAllInsets: () => (/* binding */ executeForAllInsets),
/* harmony export */   flags: () => (/* binding */ flags),
/* harmony export */   getBBOXAsGeoJSON: () => (/* binding */ getBBOXAsGeoJSON),
/* harmony export */   getCSSPropertyFromClass: () => (/* binding */ getCSSPropertyFromClass),
/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),
/* harmony export */   getEstatDataURL: () => (/* binding */ getEstatDataURL),
/* harmony export */   getEstatRestDataURLBase: () => (/* binding */ getEstatRestDataURLBase),
/* harmony export */   getFontSizeFromClass: () => (/* binding */ getFontSizeFromClass),
/* harmony export */   getLegendRegionsSelector: () => (/* binding */ getLegendRegionsSelector),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   getRegionsSelector: () => (/* binding */ getRegionsSelector),
/* harmony export */   getTextColorForBackground: () => (/* binding */ getTextColorForBackground),
/* harmony export */   getURLParameterByName: () => (/* binding */ getURLParameterByName),
/* harmony export */   hexToRgb: () => (/* binding */ hexToRgb),
/* harmony export */   jsonstatToIndex: () => (/* binding */ jsonstatToIndex),
/* harmony export */   lowerCaseAllWordsExceptFirstLetters: () => (/* binding */ lowerCaseAllWordsExceptFirstLetters),
/* harmony export */   multiplyBlendMultipleHex: () => (/* binding */ multiplyBlendMultipleHex),
/* harmony export */   rasterize: () => (/* binding */ rasterize),
/* harmony export */   serialize: () => (/* binding */ serialize),
/* harmony export */   spaceAsThousandSeparator: () => (/* binding */ spaceAsThousandSeparator),
/* harmony export */   updateCSSRule: () => (/* binding */ updateCSSRule),
/* harmony export */   upperCaseFirstLetter: () => (/* binding */ upperCaseFirstLetter)
/* harmony export */ });
// e.g. to be used with deprecated .style() functions. They will now update CSS classes.
function updateCSSRule(selector, property, value) {
    // Validate the selector
    if (!selector.startsWith('.') && !selector.startsWith('#')) {
        throw new Error('Invalid selector: Must start with "." for classes or "#" for IDs.')
    }

    // Check if the rule already exists in any stylesheet
    const styleSheets = Array.from(document.styleSheets)
    for (const styleSheet of styleSheets) {
        try {
            const rules = styleSheet.cssRules || styleSheet.rules
            for (const rule of rules) {
                if (rule.selectorText === selector) {
                    // Update the property if the rule exists
                    rule.style[property] = value
                    return
                }
            }
        } catch (e) {
            // Some stylesheets (e.g., cross-origin) may not be accessible
            console.warn(`Could not access rules in stylesheet:`, e)
        }
    }

    // If the rule doesn't exist, create a new stylesheet and add it
    let customSheet = document.getElementById('custom-styles')
    if (!customSheet) {
        customSheet = document.createElement('style')
        customSheet.id = 'custom-styles'
        document.head.appendChild(customSheet)
    }

    // Add the new rule to the custom stylesheet
    try {
        customSheet.sheet.insertRule(`${selector} { ${property}: ${value}; }`, customSheet.sheet.cssRules.length)
    } catch (e) {
        console.error(`Failed to insert rule: ${selector} { ${property}: ${value}; }`, e)
    }
}

const getFontSizeFromClass = function (className) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'
    tempElement.style.fontSize = 'initial'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed font-size property and parse it to a number
    const fontSize = parseFloat(window.getComputedStyle(tempElement).fontSize)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return fontSize || 0
}

const getCSSPropertyFromClass = function (className, propertyName) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed value of the specified property
    const propertyValue = window.getComputedStyle(tempElement).getPropertyValue(propertyName)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return propertyValue || null
}

// Helper function to get all CSS rules defined in the document
function getAllCSSRules() {
    let cssRules = []
    for (let sheet of document.styleSheets) {
        try {
            // Some stylesheets may not be accessible due to CORS, so we catch any errors
            for (let rule of sheet.cssRules) {
                cssRules.push(rule)
            }
        } catch (e) {
            console.warn('Unable to access stylesheet:', sheet.href, e)
        }
    }
    return cssRules
}

// Helper function to get explicitly defined styles from CSS for an element
function getStylesFromCSS(element) {
    let matchedRules = []
    const cssRules = getAllCSSRules()

    cssRules.forEach((rule) => {
        if (element.matches(rule.selectorText)) {
            matchedRules.push(rule.style)
        }
    })

    // Create an object of the explicitly set styles
    let explicitStyles = {}
    matchedRules.forEach((style) => {
        for (let i = 0; i < style.length; i++) {
            const property = style[i]
            explicitStyles[property] = style.getPropertyValue(property)
        }
    })

    return explicitStyles
}

// Helper function to apply inline styles explicitly set in CSS. Useful for exporting SVGs with CSS styles.
const applyInlineStylesFromCSS = (svgElement) => {
    const allElements = svgElement.querySelectorAll('*')

    allElements.forEach((element) => {
        const cssStyles = getStylesFromCSS(element)

        // Apply each explicitly defined CSS style as an inline style
        Object.keys(cssStyles).forEach((property) => {
            const value = cssStyles[property]

            // Check if the property already has an inline style
            const existingInlineStyle = element.style.getPropertyValue(property)

            if (!existingInlineStyle && value) {
                // If no existing inline style, set the new style
                element.style.setProperty(property, value)
            }
        })
    })
}

/**
 * Return a GeoJSON feature representing a bounding box, with multipoint geometry.
 * This bounding box is an array like the one in topojson bbox element.
 * [xmin,ymin,xmax,ymax]
 * This is useful for to call d3.fitSize([w, h], getTopoJSONExtentAsGeoJSON(topo.bbox)))
 *
 * @param {*} bb The bounding box [xmin,ymin,xmax,ymax]. For topojson data, just give the topojson.bbox element.
 */
const getBBOXAsGeoJSON = function (bb) {
    return {
        type: 'Feature',
        geometry: {
            type: 'MultiPoint',
            coordinates: [
                [bb[0], bb[1]],
                [bb[2], bb[3]],
            ],
        },
    }
}

// indexing

/**
 * Index JSONStat stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} jsData The JSONStat data to index
 */
const jsonstatToIndex = function (jsData) {
    const ind = {}
    const geos = jsData.Dimension('geo').id
    for (let i = 0; i < geos.length; i++) ind[geos[i]] = jsData.Data(i)
    return ind
}

/**
 * Index CSV stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} csvData The CSV data to index
 * @param {*} geoCol The name of the geo column in the CSV data
 * @param {*} valueCol The name of the statistical value column in the CSV file.
 */
const csvToIndex = function (csvData, geoCol, valueCol) {
    const ind = {}
    for (let i = 0; i < csvData.length; i++) {
        const d = csvData[i]
        const v = d[valueCol]
        if (!v) {
            ind[d[geoCol]] = { value: ':', status: '' }
        } else {
            ind[d[geoCol]] = { value: isNaN(+v) ? v : +v, status: '' }
        }
    }
    return ind
}

/**
 * @description returns string with space as thousand separator
 * @function spaceAsThousandSeparator
 * @param {number} number
 */
const spaceAsThousandSeparator = function (number) {
    return number.toLocaleString('en').replace(/,/gi, ' ')
}

//REST API
const getEstatRestDataURLBase = 'https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/'

/**
 * Build URL to fetch data from eurobase REST API.
 * @param {string} datasetCode The Eurobase dataset code
 * @param {object=} filters The filter parameters as for example: {key:value,key:[value1,value2,value3]}
 * @param {number=} lang
 * @param {number=} format
 * @param {number=} version
 */
const getEstatDataURL = function (datasetCode, filters, lang, format) {
    lang = lang || 'en'
    format = format || 'json'
    var url = []
    url.push(getEstatRestDataURLBase, datasetCode, '?', 'format=', format, '&lang=', lang)
    if (filters)
        for (var param in filters) {
            var o = filters[param]
            if (Array.isArray(o)) for (var i = 0; i < o.length; i++) url.push('&', param, '=', o[i])
            else url.push('&', param, '=', o)
        }
    return url.join('')
}

/**
 * @param {string} name
 * @returns {string}
 */
const getURLParameterByName = function (name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

//flags
const flags = {
    b: 'break in time series',
    c: 'confidential',
    d: 'definition differs, see metadata',
    e: 'estimated',
    f: 'forecast',
    n: 'not significant',
    p: 'provisional',
    r: 'revised',
    s: 'Eurostat estimate',
    u: 'low reliability',
    z: 'not applicable',
}

/**
 * @description Executes a function for all inset maps. Some insets might be external SVGs which is why this function was created.
 * @param {*} insets map.insets
 * @param {*} mainSvgId the ID of the map's svg
 * @param {*} callback the function to execute for each inset
 * @param {*} [parameter=null] the parameter to pass to the callback
 * @param {*} [parameter2=null] the parameter to pass to the callback
 */
const executeForAllInsets = function (insets, mainSvgId, callback, parameter = null, parameter2 = null) {
    for (const geo in insets) {
        const insetGroup = insets[geo]

        if (Array.isArray(insetGroup)) {
            insetGroup.forEach((inset) => {
                // Handle nested arrays for multiple insets with the same geo
                if (Array.isArray(inset)) {
                    inset.forEach((nestedInset) => {
                        if (nestedInset.svgId_ !== mainSvgId) {
                            callback(nestedInset, parameter, parameter2)
                        }
                    })
                } else {
                    if (inset.svgId_ !== mainSvgId) {
                        callback(inset, parameter, parameter2)
                    }
                }
            })
        } else {
            // Apply callback to unique inset
            if (insetGroup.svgId_ !== mainSvgId) {
                callback(insetGroup, parameter, parameter2)
            }
        }
    }
}

const upperCaseFirstLetter = (string) => `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`

const lowerCaseAllWordsExceptFirstLetters = (string) =>
    string.replaceAll(/\S*/g, (word) => `${word.slice(0, 1)}${word.slice(1).toLowerCase()}`)

function getDownloadURL(svgNode) {
    // Create XML header to ensure the SVG is recognized properly
    const xmlHeader = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'

    // create blob
    const svgContent = xmlHeader + svgNode.outerHTML
    const svgBlob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' })
    const svgUrl = URL.createObjectURL(svgBlob)
    return svgUrl
}

// Rasterize function with additional error handling
function serialize(svg) {
    const xmlns = 'http://www.w3.org/2000/xmlns/'
    const xlinkns = 'http://www.w3.org/1999/xlink'
    const svgns = 'http://www.w3.org/2000/svg'
    const fragment = window.location.href + '#'
    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false)
    while (walker.nextNode()) {
        for (const attr of walker.currentNode.attributes) {
            if (attr.value.includes(fragment)) {
                attr.value = attr.value.replace(fragment, '#')
            }
        }
    }
    svg.setAttributeNS(xmlns, 'xmlns', svgns)
    svg.setAttributeNS(xmlns, 'xmlns:xlink', xlinkns)
    const serializer = new window.XMLSerializer()
    const string = serializer.serializeToString(svg)
    return new Blob([string], { type: 'image/svg+xml' })
}

// adapted from https://observablehq.com/@mbostock/saving-sv
//svg to canvas blob promise
function rasterize(svg) {
    let resolve, reject
    const promise = new Promise((y, n) => ((resolve = y), (reject = n)))
    const image = new Image()
    image.onerror = reject
    image.onload = () => {
        const rect = svg.getBoundingClientRect()
        const canvas = document.createElement('canvas')
        canvas.width = rect.width
        canvas.height = rect.height
        const context = canvas.getContext('2d')
        context.drawImage(image, 0, 0, rect.width, rect.height)
        context.canvas.toBlob(resolve)
    }
    image.src = URL.createObjectURL(serialize(svg))
    return promise
}

/**
 * Get a URL parameter by name.
 *
 * @param {string} name
 * @returns {string | null}
 */
function getParameterByName(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    let regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

const hexToRgb = (hex) => {
    hex = hex.replace('#', '')
    if (hex.length === 3) {
        hex = hex
            .split('')
            .map((h) => h + h)
            .join('')
    }
    const int = parseInt(hex, 16)
    return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
}

//blends two colors using 'multiply' blending mode. Returns the blended color as an RGB string
const multiplyBlendMultipleHex = (colors) => {
    // Convert hex color to RGB
    const hexToRgb = (hex) => {
        hex = hex.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((h) => h + h)
                .join('')
        }
        const int = parseInt(hex, 16)
        return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
    }

    // Convert RGB to hex
    const rgbToHex = ([r, g, b]) => `#${[r, g, b].map((c) => c.toString(16).padStart(2, '0')).join('')}`

    // Convert all hex colors to RGB arrays
    const rgbColors = colors.map(hexToRgb)

    // Initialize the result with the first color
    let blended = [...rgbColors[0]]

    // Sequentially multiply each color with the result
    for (let i = 1; i < rgbColors.length; i++) {
        blended = blended.map((v, idx) => Math.round((v / 255) * (rgbColors[i][idx] / 255) * 255))
    }

    // Return the blended color as a hex code
    return rgbToHex(blended)
}

// convert rect attributes into an SVG path string
// used for workaround whereby clipPaths which use rect elements do not work in adobe illustrator
const convertRectanglesToPaths = function (x, y, width, height) {
    var x = parseFloat(x, 10)
    var y = parseFloat(y, 10)
    var width = parseFloat(width, 10)
    var height = parseFloat(height, 10)

    if (x < 0 || y < 0 || width < 0 || height < 0) {
        return ''
    }

    return 'M' + x + ',' + y + 'L' + (x + width) + ',' + y + ' ' + (x + width) + ',' + (y + height) + ' ' + x + ',' + (y + height) + 'z'
}

const getTextColorForBackground = function (backgroundColor) {
    let r, g, b

    // Create a temporary element to handle named colors
    if (!backgroundColor.startsWith('rgb') && !backgroundColor.startsWith('#')) {
        const tempDiv = document.createElement('div')
        tempDiv.style.color = backgroundColor
        document.body.appendChild(tempDiv)
        const computedColor = window.getComputedStyle(tempDiv).color
        document.body.removeChild(tempDiv)
        backgroundColor = computedColor // Convert named color to RGB
    }

    // Handle hex colors like '#FFFFFF' or '#FFF'
    if (backgroundColor.startsWith('#')) {
        let hex = backgroundColor.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((c) => c + c)
                .join('')
        }
        r = parseInt(hex.substring(0, 2), 16)
        g = parseInt(hex.substring(2, 4), 16)
        b = parseInt(hex.substring(4, 6), 16)
    }
    // Handle RGB colors like 'rgb(255,255,255)'
    else {
        const rgb = backgroundColor.match(/\d+/g)
        r = parseInt(rgb[0])
        g = parseInt(rgb[1])
        b = parseInt(rgb[2])
    }

    // Calculate luminance
    const luminance = 0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255)

    // Return black for light backgrounds, white for dark backgrounds
    return luminance > 0.5 ? 'black' : 'white'
}

// get css selector. Different maps have different selectors for their regions
const getRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions path'
    if (map.gridCartogram_) return '#em-grid-container .em-grid-cell'
    if (map.geo_ === 'WORLD') return '#em-worldrg path'
    return '#em-nutsrg path, #em-cntrg path'
}

// get css selector for legend mouse hover. Different maps have different selectors for their regions
const getLegendRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions'
    if (map.gridCartogram_) return '#em-grid-container'
    if (map.geo_ === 'WORLD') return '#em-worldrg'
    return '#em-nutsrg, #em-cntrg'
}


/***/ }),

/***/ "./src/css/index.css":
/*!***************************!*\
  !*** ./src/css/index.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./index.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/eurostat-map.js":
/*!*****************************!*\
  !*** ./src/eurostat-map.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* binding */ getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFun: () => (/* binding */ getFillPatternDefinitionFun),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* binding */ getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maptypes/map-choropleth */ "./src/maptypes/map-choropleth.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maptypes/map-categorical */ "./src/maptypes/map-categorical.js");
/* harmony import */ var _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./maptypes/map-choropleth-bivariate */ "./src/maptypes/map-choropleth-bivariate.js");
/* harmony import */ var _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./maptypes/map-choropleth-trivariate */ "./src/maptypes/map-choropleth-trivariate.js");
/* harmony import */ var _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maptypes/map-stripe-composition */ "./src/maptypes/map-stripe-composition.js");
/* harmony import */ var _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./maptypes/map-piecharts */ "./src/maptypes/map-piecharts.js");
/* harmony import */ var _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./maptypes/map-sparklines */ "./src/maptypes/map-sparklines.js");
/* harmony import */ var _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./maptypes/map-flow */ "./src/maptypes/map-flow.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _core_labels__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/labels */ "./src/core/labels.js");












/**
 * Function returning a eurostat-map object.
 *
 * @param {*} type The type of map ('ch' for choropleth, etc.)
 * @param {*} config The configuration object. Ex.: { title: "Map title", geoCenter: [233,654], ...}
 */
const map = function (type, config) {
    //choropleth map
    if (type == 'choropleth' || type == 'ch') return _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__.map(config)
    //categorical map
    if (type == 'categorical' || type == 'ct') return _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__.map(config)
    //proportionnal symbols map
    if (type == 'proportionalSymbol' || type == 'ps') return _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.map(config)
    //bivariate choropleth
    if (type == 'bivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__.map(config)
    //trivariate choropleth
    if (type == 'trivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__.map(config)
    //stripes composition
    if (type == 'stripeComposition' || type == 'scomp') return _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__.map(config)
    //proportional pie charts
    if (type == 'pieChart' || type == 'pie') return _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__.map(config)
    //sparkline maps
    if (type == 'sparkline' || type == 'spark' || type == 'sparklines') return _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__.map(config)
    //flow maps
    if (type == 'flow' || type == 'flowmap') return _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__.map(config)

    //add new map types here
    //if(type == "XX") return mapXX.map(config);

    console.log('Unexpected map type: ' + type)
    return _core_stat_map__WEBPACK_IMPORTED_MODULE_9__.statMap(config, true, type)
}

/**
 * Return a function which builds fill patterns style.
 * The returned function has for arguments the SVG element where to use the fill pattern, and the number of classes.
 *
 * @param {*} opts Various parameters on the fill pattern.
 * @returns {function}
 */
const getFillPatternDefinitionFunction = function (opts) {
    opts = opts || {}
    opts.shape = opts.shape || 'circle'
    const ps = opts.patternSize || 5
    const smin = opts.minSize || 1
    const smax = opts.maxSize || 5.5
    opts.bckColor = opts.bckColor || 'white'
    opts.symbColor = opts.symbColor || 'black'
    return function (svg, numberOfClasses) {
        //clear previous
        svg.selectAll('.em-fill-pattern').remove()
        for (let i = 0; i < numberOfClasses; i++) {
            const si = smin + ((smax - smin) * i) / (numberOfClasses - 1)
            const patt = svg
                .append('pattern')
                .attr('class', 'em-fill-pattern')
                .attr('id', 'pattern_' + i)
                .attr('x', '0')
                .attr('y', '0')
                .attr('width', ps)
                .attr('height', ps)
                .attr('patternUnits', 'userSpaceOnUse')
            patt.append('rect').attr('x', 0).attr('y', 0).attr('width', ps).attr('height', ps).style('stroke', 'none').style('fill', opts.bckColor)
            if (opts.shape == 'square')
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', si)
                    .attr('height', si)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
            else
                patt.append('circle')
                    .attr('cx', ps * 0.5)
                    .attr('cy', ps * 0.5)
                    .attr('r', si * 0.5)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
        }
    }
}

const getFillPatternDefinitionFun = function (opts) {
    console.warn('getFillPatternDefinitionFun is now DEPRECATED. Please use getFillPatternDefinitionFunction() instead.')
    return getFillPatternDefinitionFunction(opts)
}

const getDefaultLabels = function () {
    return _core_labels__WEBPACK_IMPORTED_MODULE_10__.DEFAULTLABELS
}


/***/ }),

/***/ "./src/legend/legend-categorical.js":
/*!******************************************!*\
  !*** ./src/legend/legend-categorical.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");




/**
 * A legend for categorical maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 13
    //the height of the legend box elements
    out.shapeHeight = 15
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'
    // allow the user to define the order of the legend elements manually as an array
    out.order = undefined

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node() && out.map.classifier_) {
            const map = out.map
            const container = out.lgg

            //draw legend background box
            out.makeBackgroundBox()

            //draw title
            if (out.title) {
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + out.titleFontSize)
                    .text(out.title)
            }

            //get category codes
            const domain = map.classToFillStyle() ? Object.keys(map.classToFillStyle()) : map.classifier_.domain()
            const ecls = out.order ? out.order : domain

            //draw legend elements for classes: rectangle + label
            for (let i = 0; i < ecls.length; i++) {
                //the class
                const ecl_ = ecls[i]
                const ecl = map.classifier_(ecl_)
                const fillColor = map.classToFillStyle_[ecl_]

                //the vertical position of the legend element
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', fillColor)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, ecl)
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, ecl)
                        }
                    })

                //label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dominant-baseline', 'middle')
                    .text(map.classToText() ? map.classToText()[ecl_] : ecl_)
            }

            //'no data' legend box
            if (out.noData) {
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + ecls.length * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', map.noDataFillStyle_)
                    .on('mouseover', function () {
                        highlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, 'nd')
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, 'nd')
                        }
                    })

                //'no data' label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dominant-baseline', 'middle')
                    .text(out.noDataText)
            }

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-bivariate.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-choropleth-bivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth-bivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //size
    out.squareSize = 100

    //orientation
    out.rotation = 0

    //labels
    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'

    //get the font size of the texts
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')

    //breaks
    out.breaks1 = undefined
    out.breaks2 = undefined
    out.showBreaks = false // if set to true and breaks1 and breaks2 are undefined then breaks are automatically defined

    //axis
    out.yAxisLabelsOffset = { x: 7, y: 0 }
    out.xAxisLabelsOffset = { x: 0, y: 0 }

    //show no data
    out.noData = true
    //show no data
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25

    //no data text label
    out.noDataText = 'No data'

    //override padding
    out.boxPadding = out.labelFontSize

    //add extra distance between legend and no data item
    out.noDataYOffset = 20

    //arrows
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10 // padding between arrow and axis label

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()
        const sz = out.squareSize / numberOfClasses
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding

        // Horizontal shift to move everything right (adjust this value as needed)
        const horizontalOffset = out.axisTitleFontSize + out.arrowPadding // Adjust this value to move the whole legend to the right

        // Remove previous content
        lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Draw title
        if (out.title) {
            lgg.append('text')
                .attr('class', 'em-legend-title')
                .attr('x', xc + horizontalOffset)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        // The vertical position of the legend element
        let y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0)

        // Square group with horizontal offset
        const square = lgg
            .append('g')
            .attr('class', 'bivariate-squares-chart')
            .attr('transform', `translate(${out.boxPadding + horizontalOffset},${xc + y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`)

        const initialX = out.yAxisLabelsOffset.x

        // Draw rectangles
        for (let i = 0; i < numberOfClasses; i++) {
            for (let j = 0; j < numberOfClasses; j++) {
                const ecl1 = numberOfClasses - i - 1
                const ecl2 = numberOfClasses - j - 1
                const fill = out.map.classToFillStyle()(ecl1, ecl2)

                square
                    .append('rect')
                    .attr('class', 'em-bivariate-square')
                    .attr('x', initialX + (numberOfClasses - 1 - i) * sz)
                    .attr('y', j * sz)
                    .attr('width', sz)
                    .attr('height', sz)
                    .style('fill', fill)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl1, ecl2)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl1, ecl2)
                        }
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).raise() // raise legend square to avoid stroke issue
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl1, ecl2)
                        }
                    })
            }
        }

        // set breaks if user hasnt defined them but has enabled them
        if (!out.breaks1 && !out.breaks2 && out.showBreaks) {
            // Get quantiles for the first variable (X axis) and truncate to one decimal place
            out.breaks1 = map.classifier1_.quantiles().map((value) => parseFloat(value.toFixed(0)))

            // Get quantiles for the second variable (Y axis) and truncate to one decimal place
            out.breaks2 = map.classifier2_.quantiles().map((value) => parseFloat(value.toFixed(0)))
        }

        // Draw breaks labels 1 (X axis)
        if (out.breaks1) {
            for (let i = 0; i < out.breaks1.length; i++) {
                const x = initialX + sz * (i + 1)
                const y = out.squareSize + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label')

                square
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.xAxisLabelsOffset.x)
                    .attr('y', y + out.xAxisLabelsOffset.y)
                    .text(out.breaks1[i])

                square
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x + out.xAxisLabelsOffset.x)
                    .attr('x2', x + out.xAxisLabelsOffset.x)
                    .attr('y1', out.squareSize)
                    .attr('y2', out.squareSize + 5)
            }
        }

        // Draw breaks labels 2 (Y axis)
        if (out.breaks2) {
            for (let i = 0; i < out.breaks2.length; i++) {
                const x = initialX
                const y = sz * (i + 2) - sz

                square
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.yAxisLabelsOffset.y)
                    .attr('y', y - out.yAxisLabelsOffset.x)
                    .text([...out.breaks2].reverse()[i])
                    .attr('text-anchor', 'middle')
                    .attr('transform', `rotate(-90, ${x}, ${y})`)

                square
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x)
                    .attr('x2', x - 5)
                    .attr('y1', y)
                    .attr('y2', y)
            }
        }

        // Append X axis arrow
        let xAxisArrowY = out.squareSize + out.arrowHeight + out.xAxisLabelsOffset.y
        if (out.showBreaks || (out.breaks1 && out.breaks2)) xAxisArrowY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') / 1.5 // move over for tick labels

        square
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_3__["default"])()([
                    [initialX, xAxisArrowY],
                    [initialX + out.squareSize, xAxisArrowY],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')

        // Append Y axis arrow
        let yAxisArrowX = -out.arrowHeight + out.yAxisLabelsOffset.x
        if (out.showBreaks || (out.breaks1 && out.breaks2)) yAxisArrowX -= out.labelFontSize / 2 // move over for tick labels

        square
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_3__["default"])()([
                    [yAxisArrowX, out.squareSize],
                    [yAxisArrowX, 0],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')

        // X axis title
        square
            .append('text')
            .attr('class', 'em-bivariate-axis-title')
            .attr('x', initialX + out.xAxisLabelsOffset.x)
            .attr('y', xAxisArrowY + out.arrowPadding)
            .text(out.label1)
            .attr('dominant-baseline', 'hanging')
            .attr('alignment-baseline', 'hanging')

        // Y axis title
        square
            .append('text')
            .attr('class', 'em-bivariate-axis-title')
            .attr('x', -out.squareSize)
            .attr('y', yAxisArrowX - out.arrowPadding + (out.rotation == -45 ? -4 : -1))
            .text(out.label2)
            .style('transform', out.rotation < 0 ? 'translate(-51px, 95px) rotate(90deg)' : 'rotate(-90deg)')

        // Frame
        square
            .append('rect')
            .attr('class', 'em-bivariate-frame')
            .attr('x', initialX)
            .attr('y', 0)
            .attr('width', out.squareSize)
            .attr('height', out.squareSize)
            .attr('stroke-width', 0.7)

        // Arrow defs
        square
            .append('defs')
            .append('marker')
            .attr('viewBox', `0 0 ${out.arrowWidth} ${out.arrowHeight}`)
            .attr('id', 'arrowhead')
            .attr('refX', 0)
            .attr('refY', 5)
            .attr('markerWidth', out.arrowWidth)
            .attr('markerHeight', out.arrowHeight)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 5 5 L 0 10')
            .attr('marker-units', 'strokeWidth')

        // 'No data' legend box
        if (out.noData) {
            const noDataYOffset =
                out.rotation === 0 ? out.noDataYOffset + out.squareSize / out.map.numberOfClasses_ + out.arrowHeight / 2 : out.noDataYOffset

            y = out.rotation === 0 ? y + out.squareSize + noDataYOffset : y + 1.4142 * out.squareSize + out.boxPadding * 2 + noDataYOffset

            lgg.append('rect')
                .attr('class', 'em-bivariate-nodata')
                .attr('x', out.boxPadding + out.noDataShapeWidth / 2)
                .attr('y', y + (out.rotation == 0 ? 0 : -10))
                .attr('width', out.noDataShapeWidth)
                .attr('height', out.noDataShapeHeight)
                .style('fill', out.map.noDataFillStyle())
                .on('mouseover', function () {
                    const regions = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg')
                    const sel = regions.selectAll("[nd='nd']")
                    sel.style('fill', 'red')
                })
                .on('mouseout', function () {
                    const nRg = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg')
                    const sel = nRg.selectAll("[nd='nd']")
                    sel.style('fill', function () {
                        return (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___')
                    })
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', out.map.noDataFillStyle())
                })
            lgg.append('text')
                .attr('class', 'em-bivariate-nodata-label')
                .attr('x', out.boxPadding + out.noDataShapeWidth + (out.noDataShapeWidth / 2 + 5))
                .attr('y', y + out.noDataShapeHeight * 0.5 + 1 + (out.rotation == 0 ? 0 : -10))
                .text(out.noDataText)
        }

        // Set legend box dimensions
        out.setBoxDimension()
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-trivariate.js":
/*!****************************************************!*\
  !*** ./src/legend/legend-choropleth-trivariate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");




/**
 * A legend for choropleth-trivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    // Default settings
    out.width = 230
    out.height = 230

    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'
    out.label3 = 'Variable 3' // Add a label for the third variable
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')
    out.showBreaks = false
    out.noData = true
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25
    out.noDataText = 'No data'
    out.boxPadding = 60 // depends on variable 1 label length really
    out.noDataYOffset = 20
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10

    if (config) for (let key in config) out[key] = config[key]

    /**
     * Override the update method to handle trivariate legends
     */
    out.update = function () {
        out.updateConfig()
        out.updateContainer()
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()

        // Remove previous content
        lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Apply padding to the main <g> group
        const paddedGroup = lgg.append('g').attr('transform', `translate(${out.boxPadding}, ${out.boxPadding})`)

        // Draw title
        if (out.title) {
            paddedGroup
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Start at 0 within the padded group
                .attr('y', out.titleFontSize) // Vertical positioning
                .text(out.title)
        }

        // Draw the trivariate Venn diagram
        const labels = [out.label1, out.label2, out.label3]
        const colors = [out.map.color1_, out.map.color2_, out.map.color3_]

        drawTrivariateVennDiagram(paddedGroup, colors, labels)

        // Handle trivariate (Venn Diagram) or bivariate (grid) legend
        // if (numberOfClasses === 7) {
        //     drawTrivariateVennDiagram(lgg, out)
        // } else {
        //     drawTrivariateTernaryPlot(lgg, out, numberOfClasses)
        // }
    }

    return out
}

function drawTrivariateVennDiagram(container, colors, labels) {
    //specs for Circle 1
    const xCenter1 = 50
    const yCenter1 = 50
    const circleRad = 30

    //draw Circle 1
    // const circle1 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter1 + ',' + yCenter1 + ')')

    //add'l specs for Circle 2
    const offsetFactor = 1.2
    const offset = offsetFactor * circleRad
    const xCenter2 = xCenter1 + offset
    const yCenter2 = yCenter1 //creating new var for clarity

    //draw Circle 2
    // const circle2 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter2 + ',' + yCenter2 + ')')

    //add'l specs for Circle 3
    const xCenter3 = xCenter1 + offset / 2
    const yCenter3 = yCenter1 + (Math.sqrt(3) * offset) / 2

    //draw Circle 3
    // const circle3 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter3 + ',' + yCenter3 + ')')

    //compute first points of intersection
    const triHeight = Math.sqrt(circleRad ** 2 - (offset / 2) ** 2)
    //outer intersection of Circles 1 and 2
    const xIsect1 = xCenter3
    const yIsect1 = yCenter1 - triHeight
    //inner intersection of Circles 1 and 2
    const xIsect4 = xCenter3
    const yIsect4 = yCenter1 + triHeight

    //treat "triHeight" as the hypoteneuse of a 30.60.90 triangle.
    //this tells us the shift from the midpoint of a leg of the triangle
    //to the point of intersection
    const xDelta = (triHeight * Math.sqrt(3)) / 2
    const yDelta = triHeight / 2

    const xMidpointC1C3 = (xCenter1 + xCenter3) / 2
    const xMidpointC2C3 = (xCenter2 + xCenter3) / 2
    const yMidpointBoth = (yCenter1 + yCenter3) / 2

    //find the rest of the points of intersection
    const xIsect2 = xMidpointC1C3 - xDelta
    const yIsect2 = yMidpointBoth + yDelta
    const xIsect3 = xMidpointC2C3 + xDelta
    const yIsect3 = yMidpointBoth + yDelta

    const xIsect5 = xMidpointC1C3 + xDelta
    const yIsect5 = yMidpointBoth - yDelta
    const xIsect6 = xMidpointC2C3 - xDelta
    const yIsect6 = yMidpointBoth - yDelta

    const xPoints = [xIsect1, xIsect2, xIsect3, xIsect4, xIsect5, xIsect6]
    const yPoints = [yIsect1, yIsect2, yIsect3, yIsect4, yIsect5, yIsect6]

    const makeIronShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const makeSunShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 0 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 1 1 ${x1} ${y1}`
        return path
    }

    const makeRoundedTri = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 1 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const ironPoints = [
        [1, 5, 6],
        [3, 4, 5],
        [2, 6, 4],
    ]
    const sunPoints = [
        [3, 5, 1],
        [2, 4, 3],
        [1, 6, 2],
    ]
    const roundedTriPoints = [[5, 4, 6]]

    // main circles (raw colors)
    sunPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeSunShapes(ptCycle)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', colors[index]).attr('opacity', 1)
    })

    // first intersects (combination of 2 colors)
    ironPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeIronShapes(ptCycle)

        let color
        if (index == 0) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[2], colors[0]]) // pink + cyan
        } else if (index == 1) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[0]]) // cyan + yellow
        } else if (index == 2) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[2]]) // pink + yellow
        }

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    // nucleus (combination of all 3 colors)
    roundedTriPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeRoundedTri(ptCycle)
        const color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)(colors)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    container
        .selectAll('path.segment')
        .on('mouseover', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 0.8).duration(500)
        })
        .on('mouseout', function () {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 1).duration(500)
        })

    // label intersects
    const yOffset = container
        .append('text')
        .text(labels[0])
        .attr('x', xCenter1 - circleRad - 3)
        .attr('y', xCenter1)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'end')
    container
        .append('text')
        .text(labels[1])
        .attr('x', xCenter2 + circleRad + 3)
        .attr('y', yCenter2)
        .attr('class', 'venn-label')
    container
        .append('text')
        .text(labels[2])
        .attr('x', xCenter3)
        .attr('y', yCenter3 + circleRad + 15)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'middle')
}

/**
 * Draws a trivariate legend as a Venn Diagram
 */
function drawTrivariateVennDiagram2(svg, containerWidth, containerHeight, labels, colors) {
    const radius = containerWidth / 5 // Radius of each circle
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    const offset = radius / 1.5

    // Define circle positions
    const circles = [
        { id: 'circle1', cx: centerX - offset, cy: centerY, label: labels[0], color: colors[0] },
        { id: 'circle2', cx: centerX + offset, cy: centerY, label: labels[1], color: colors[1] },
        { id: 'circle3', cx: centerX, cy: centerY + offset * 1.5, label: labels[2], color: colors[2] },
    ]

    // Draw circles
    circles.forEach(({ id, cx, cy, label, color }, index) => {
        svg.append('circle').attr('id', id).attr('cx', cx).attr('cy', cy).attr('r', radius).style('fill', color).style('opacity', 1)

        // Add labels with specific positioning
        const labelX =
            index === 0
                ? cx - radius - 10 // Left of the first circle
                : index === 1
                  ? cx + radius + 10 // Right of the second circle
                  : cx // Below the third circle

        const labelY = index < 2 ? cy : cy + radius + 20 // Same y for first two circles, below for the third

        svg.append('text')
            .attr('x', labelX)
            .attr('y', labelY)
            .attr('text-anchor', index < 2 ? (index === 0 ? 'end' : 'start') : 'middle') // Adjust alignment
            .attr('class', 'venn-label')
            .text(label)
            .style('font-size', '12px')
    })
}

/**
 * Draws a trivariate legend as a ternary plot
 */
function drawTrivariateTernaryPlot(lgg, out, numberOfClasses) {
    const size = out.squareSize // Size of the legend area
    const padding = 20 // Padding around the plot
    const radius = 5 // Radius of each class point
    const triangleHeight = (Math.sqrt(3) / 2) * size

    const ternaryGroup = lgg
        .append('g')
        .attr('class', 'trivariate-ternary-plot')
        .attr('transform', `translate(${out.boxPadding + size / 2}, ${out.boxPadding + triangleHeight / 2})`)

    // Draw the triangle
    const vertices = [
        { x: 0, y: -triangleHeight / 2 }, // Top vertex (Variable 1)
        { x: -size / 2, y: triangleHeight / 2 }, // Bottom-left vertex (Variable 2)
        { x: size / 2, y: triangleHeight / 2 }, // Bottom-right vertex (Variable 3)
    ]

    ternaryGroup
        .append('polygon')
        .attr('points', vertices.map((d) => `${d.x},${d.y}`).join(' '))
        .attr('fill', 'none')
        .attr('stroke', 'black')

    // Label the vertices
    const labels = [out.label1, out.label2, out.label3]
    vertices.forEach((vertex, i) => {
        ternaryGroup
            .append('text')
            .attr('x', vertex.x)
            .attr('y', vertex.y - (i === 0 ? 10 : -20)) // Offset labels
            .attr('class', 'ternary-label')
            .attr('text-anchor', 'middle')
            .text(labels[i])
    })

    // Plot the points inside the ternary plot
    for (let i = 0; i < numberOfClasses; i++) {
        for (let j = 0; j < numberOfClasses - i; j++) {
            const k = numberOfClasses - i - j - 1 // Ensure sum of i + j + k = numberOfClasses - 1
            const x = ((j - k) * size) / (2 * (numberOfClasses - 1)) // Horizontal position
            const y = (i * -triangleHeight) / (numberOfClasses - 1) // Vertical position

            const fill = out.map.classToFillStyle()(i, j, k)

            ternaryGroup
                .append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', radius)
                .attr('fill', fill)
                .on('mouseover', function () {
                    highlightRegions(out.map, i, j, k)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, i, j, k)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, i, j, k)
                    }
                })
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___'))
        })
    }
}


/***/ }),

/***/ "./src/legend/legend-choropleth.js":
/*!*****************************************!*\
  !*** ./src/legend/legend-choropleth.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/band.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");








/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object (inherit)
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    out.labelType = 'thresholds' // thresholds || ranges
    //the order of the legend elements. Set to false to invert.
    out.ascending = true
    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the separation line length
    out.sepLineLength = out.shapeWidth
    //tick line length in pixels
    out.tickLength = 4
    //the number of decimal for the legend labels
    out.decimals = 0
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 3
    //labelFormatter function
    out.labelFormatter = null
    // manually define labels
    out.labels = null

    //bar charts
    out.barChart = undefined
    out.barChartCounts = undefined //show class count labels
    out.barChartLabelFormat = undefined // allow users to format the bar chart bin labels

    //diverging line
    out.pointOfDivergenceLabel = undefined
    out.pointOfDivergence = undefined
    out.pointOfDivergencePadding = 7
    out.divergingLineLength = undefined
    out.divergingArrowLength = undefined

    //show no data
    out.noData = true
    //no data text label
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const map = out.map
            const container = out.lgg

            // Draw legend background box and title if provided
            out.makeBackgroundBox()
            if (out.title) {
                let cssFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title')
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + cssFontSize)
                    .text(out.title)
            }

            //exit early if no classifier
            if (!map.classToFillStyle()) return

            //set default point of divergence if applicable
            if (out.pointOfDivergenceLabel && !out.pointOfDivergence) out.pointOfDivergence = map.numberOfClasses_ / 2

            if (out.barChart) {
                createBarChartLegend()
            } else {
                if (out.labelType == 'ranges') {
                    createRangesLegend()
                } else {
                    createThresholdsLegend()
                }
            }

            // Set legend box dimensions
            out.setBoxDimension()
        }
    }

    function getThresholds() {
        const map = out.map
        const thresholds =
            map.thresholds_.length > 1
                ? map.thresholds_
                : Array.from({ length: map.numberOfClasses_ })
                      .map((_, index) => {
                          return map.classifier().invertExtent(index)[out.ascending ? 0 : 1]
                      })
                      .slice(1) // Remove the first entry and return the rest as an array
        return thresholds
    }

    function getColors() {
        const map = out.map
        return map.colors_
            ? map.colors_
            : Array.from({ length: map.numberOfClasses_ }).map((_, index) => {
                  return map.classToFillStyle()(index, map.numberOfClasses_)
              })
    }

    function getData() {
        const map = out.map
        return Object.values(map.statData()._data_).map((item) => item.value)
    }

    function createThresholdsLegend() {
        const m = out.map
        const lgg = out.lgg
        // Label formatter
        const formatLabel = out.labelFormatter || (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.format)(`.${out.decimals}f`)
        let baseY = out.boxPadding
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding
        for (let i = 0; i < m.numberOfClasses_; i++) {
            const y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? m.numberOfClasses() - i - 1 : i
            const fillColor = m.classToFillStyle()(ecl, m.numberOfClasses_)

            // Append rectangle for each class
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append tick line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.boxPadding + out.sepLineLength)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength + out.tickLength)
                    .attr('y2', y)
            }

            // Append label
            if (i < m.numberOfClasses() - 1) {
                // mark label so we can move it in drawDivergingLine
                const label = lgg
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                    .attr('y', y + out.shapeHeight)
                    .attr('dominant-baseline', 'middle')
                    .text(out.labels ? out.labels[i] : formatLabel(m.classifier().invertExtent(ecl)[out.ascending ? 0 : 1]))

                // mark label so we can move it in drawDivergingLine
                if (out.pointOfDivergenceLabel && i == out.pointOfDivergence - 1) label.attr('class', 'em-legend-label em-legend-label-divergence')
            }
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const y = baseY + m.numberOfClasses() * out.shapeHeight + out.boxPadding
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dominant-baseline', 'middle')
                .text(out.noDataText)
        }
    }

    function createRangesLegend() {
        const map = out.map
        const container = out.lgg
        const thresholds = getThresholds()
        const defaultLabeller = (label, i) => {
            if (i === 0) return `> ${thresholds[thresholds.length - 1]}` //top
            if (i === thresholds.length) return `< ${thresholds[0]}` //bottom
            return `${thresholds[thresholds.length - i - 1]} - < ${thresholds[thresholds.length - i]}  ` //in-between
        }
        const labelFormatter = out.labelFormatter || defaultLabeller

        let baseY = out.boxPadding
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding

        // for each class
        for (let i = 0; i < map.numberOfClasses_; i++) {
            let y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? map.numberOfClasses() - i - 1 : i
            const fillColor = map.classToFillStyle()(ecl, map.numberOfClasses_)
            const itemContainer = container.append('g').attr('class', 'em-legend-item')

            // shift legend items down after point of divergence if applicable
            if (out.pointOfDivergenceLabel && i >= out.pointOfDivergence) y += out.pointOfDivergencePadding

            // Append rectangle
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).raise()
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append labels
            itemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                .attr('y', y + out.shapeHeight / 2)
                .attr('dominant-baseline', 'middle')
                .text(out.labels ? out.labels[i] : labelFormatter(map.classifier().invertExtent(ecl)[out.ascending ? 0 : 1], i))
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const noDataItemContainer = container.append('g').attr('class', 'em-legend-item')
            let y = baseY + map.numberOfClasses() * out.shapeHeight + out.boxPadding
            if (out.pointOfDivergence) y += out.pointOfDivergencePadding // shift legend items down after point of divergence
            noDataItemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).raise()
                    highlightRegions(map, 'nd')
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(map)
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, map.svgId, unhighlightRegions)
                    }
                })

            noDataItemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dominant-baseline', 'middle')
                .text(out.noDataText)
        }
    }

    function drawDivergingLine(y) {
        const container = out.lgg.append('g').attr('class', 'em-legend-divergence-container')
        const markerHeight = 6
        const x = out.boxPadding
        if (out.labelType == 'ranges') y = y + out.pointOfDivergencePadding / 2 // move to the middle of the space between legend item
        let maxLabelLength = out.lgg
            .selectAll('.em-legend-label')
            .nodes()
            .reduce((max, node) => Math.max(max, node.getBBox().width), 0)
        const lineLength = out.divergingLineLength || maxLabelLength + out.boxPadding + out.shapeWidth + 10 // + padding

        // Draw the horizontal divergence line
        container
            .append('line')
            .attr('x1', x)
            .attr('y1', y)
            .attr('x2', x + lineLength)
            .attr('y2', y)
            .attr('class', 'em-legend-diverging-line')

        // divergence line with up and down arrows
        const labels = out.pointOfDivergenceLabel.split('|')
        if (labels.length > 1) {
            const directionLineLength = out.divergingArrowLength || 30
            const directionLineX = x + lineLength
            // Add arrowhead marker definition
            const defs = container.append('defs')
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('markerWidth', markerHeight)
                .attr('markerHeight', markerHeight)
                .attr('refX', 0)
                .attr('refY', markerHeight / 2)
                .attr('orient', 'auto')
                .append('polygon')
                .attr('points', `0 0, ${markerHeight} ${markerHeight / 2}, 0 ${markerHeight}`)
                .attr('fill', 'black')

            // Upward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y - directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Downward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y + directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Labels for upward and downward lines
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y - directionLineLength + 10)
                .text(labels[0])

            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y + directionLineLength - 10)
                .text(labels[1])
        } else {
            // just the single label
            container
                .append('text')
                .attr('class', 'em-legend-diverging-label em-legend-label')
                .attr('x', x + lineLength + 5)
                .attr('y', y)
                .text(out.pointOfDivergenceLabel)
        }

        //move threshold label out of the way of the line
        if (out.labelType == 'thresholds') {
            if (labels.length > 1) {
                // move it to end of line
                out.lgg.selectAll('.em-legend-label-divergence').attr('x', x + lineLength + 10)
                // Append tick line
                // container
                //     .append('line')
                //     .attr('class', 'em-legend-tick')
                //     .attr('x1', x + lineLength)
                //     .attr('y1', y)
                //     .attr('x2', x + lineLength + 5)
                //     .attr('y2', y)
            } else {
                //remove it so it doesnt clash with pointOfDivergenceLabel
                out.lgg.selectAll('.em-legend-label-divergence').remove()
            }
        }
    }

    function createBarChartLegend() {
        const map = out.map
        const thresholds = getThresholds()
        const colors = getColors()
        const data = getData()
        // Calculate counts for each threshold range
        let counts = new Array(map.numberOfClasses_).fill(0)
        data.forEach((value) => {
            // Use m.classifier() to get the class index
            const classIndex = map.classifier()(value)

            // Check if classIndex is valid and increment the count
            if (typeof classIndex === 'number' && classIndex >= 0 && classIndex < counts.length) {
                counts[classIndex]++
            }
        })

        // Reverse the counts array for highest classes on top
        const reversedCounts = counts.slice().reverse()

        // Ensure that the number of colors matches the number of bars
        const colorCount = reversedCounts.length
        if (colors.length !== colorCount) {
            console.warn(`Mismatch between number of colors (${colors.length}) and number of bars (${colorCount})`)
        }

        const lgg = out.lgg
        let baseY = out.boxPadding + 30
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding

        // Set up dimensions
        const svgWidth = 300
        const svgHeight = 300
        const margin = { top: 20, right: 60, bottom: 20, left: 150 } // Increased left margin
        // Set up scales with reversedCounts
        const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])()
            .domain(reversedCounts.map((_, i) => i))
            .range([margin.top, svgHeight - margin.bottom])
            .padding(0.1)

        const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__["default"])()
            .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])(reversedCounts)])
            .nice()
            .range([margin.left, svgWidth - margin.right])

        // Create a new <g> element for the bars
        const barGroup = lgg.append('g').attr('class', 'em-legend-barchart').style('transform', 'translate(0px, 10px)') // Add a class to this group for easy reference

        // Draw bars with mouseover highlight and styling
        barGroup
            .selectAll('rect')
            .data(reversedCounts)
            .join('rect')
            .attr('y', (_, i) => yScale(i))
            .attr('x', margin.left)
            .attr('height', yScale.bandwidth())
            .attr('width', (d) => xScale(d) - margin.left)
            .attr('ecl', (_, i) => i)
            .attr('fill', (_, i) => colors[colors.length - i - 1]) // Reverse color order to match counts
            .style('cursor', 'pointer') // Set cursor to pointer
            .on('mouseover', function (_, i) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this)
                sel.style('stroke', 'black')
                const ecl = sel.attr('ecl')
                const currentIndex = parseInt(ecl, 10)
                const reversedIndex = colors.length - 1 - currentIndex // reverse
                highlightRegions(out.map, reversedIndex)
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                }
            })
            .on('mouseout', function (_, i) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this)
                sel.style('stroke', 'none')
                unhighlightRegions(out.map)
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                }
            })

        // Add count labels next to bars
        if (out.barChartCounts) {
            barGroup
                .selectAll('text.count-label')
                .data(reversedCounts)
                .join('text')
                .attr('class', 'count-label')
                .attr('x', (d) => xScale(d) + 5)
                .attr('y', (_, i) => yScale(i) + yScale.bandwidth() / 2)
                .attr('text-anchor', 'start')
                .attr('alignment-baseline', 'middle')
                .attr('font-size', '14px') // Set label font size to 14px
                .text((d) => d)
        }

        // Add Y axis with custom tick labels in reversed order at 14px
        const yAxis = barGroup
            .append('g')
            .attr('transform', `translate(${margin.left}, 0)`)
            .call(
                (0,d3_axis__WEBPACK_IMPORTED_MODULE_7__.axisLeft)(yScale)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickFormat(
                        out.barChartLabelFormat
                            ? out.barChartLabelFormat
                            : (_, i) => {
                                  if (i === 0) return `> ${thresholds[thresholds.length - 1]}` //top
                                  if (i === thresholds.length) return `< ${thresholds[0]}` //bottom
                                  return `${thresholds[thresholds.length - i - 1]} - < ${thresholds[thresholds.length - i]}  ` //in-between
                              }
                    )
            )
            .selectAll('text')
            .attr('font-size', '14px') // Set Y-axis tick label font size to 14px
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    //deprecated
    out.labelDecNb = (v) => (console.warn('labelDecNb is now DEPRECATED. Please use decimals instead.'), out)

    return out
}


/***/ }),

/***/ "./src/legend/legend-flow.js":
/*!***********************************!*\
  !*** ./src/legend/legend-flow.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");





//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const lgg = out.lgg

        // update legend parameters if necessary
        if (m.legend_)
            for (let key in m.legend_) {
                if (key == 'colorLegend' || key == 'sizeLegend') {
                    for (let p in out[key]) {
                        //override each property in size and color legend m.legend_
                        if (m.legend_[key][p] !== undefined) {
                            out[key][p] = m.legend_[key][p]
                        }
                    }
                } else {
                    out[key] = m.legend_[key]
                }
            }

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        buildFlowLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different flow symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildFlowLegend(m) {}

    return out
}


/***/ }),

/***/ "./src/legend/legend-piecharts.js":
/*!****************************************!*\
  !*** ./src/legend/legend-piecharts.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");






/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //spacing between color & size legends (if applicable)
    out.legendSpacing = 15

    //size legend config (legend illustrating the values of different pie sizes)
    out.sizeLegend = {
        title: null,
        titlePadding: 30, //padding between title and body
        values: null,
    }

    //colour legend config (legend illustrating the values of different pie colours)
    out.colorLegend = {
        title: null,
        labelOffset: 5, //the distance between the legend box elements to the corresponding text label
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 5, //the distance between consecutive legend box elements
        noData: true, //show no data
        noDataText: 'No data', //no data label text
    }

    out._sizeLegendHeight = 0

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const map = out.map
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        // legend for sizes
        if (map.sizeClassifier_) {
            buildSizeLegend()
        }

        // legend for ps color values
        buildColorLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different pie chart sizes
     *
     * @param {*} m map
     * @param {*} lgg parent legend object from core/legend.js
     * @param {*} config size legend config object (sizeLegend object specified as property of legend() config object)
     */
    function buildSizeLegend() {
        const map = out.map
        const config = out.sizeLegend
        const container = out.lgg.append('g').attr('class', 'em-pie-size-legend')

        const domain = map.sizeClassifier_.domain()

        // Assign default circle radii if none specified by user
        if (!config.values) {
            config.values = [Math.floor(domain[1]), Math.floor(domain[0])]
        }

        // Calculate the maximum circle size to be displayed in the legend
        let maxSize = map.sizeClassifier_((0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(config.values))

        // Add the title to the container if available
        if (!config.title && out.title) config.title = out.title // Allow root legend title
        let titleHeight = 0 // This will be adjusted based on whether the title exists
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Position the title at the left edge
                .attr('y', out.boxPadding + out.titleFontSize) // Title at top, within padding
                .text(config.title)

            // Adjust title height (using the title font size as a proxy)
            titleHeight = out.titleFontSize + out.boxPadding + config.titlePadding
        }

        // Now position the circles **below** the title
        let y = titleHeight + out.boxPadding + maxSize * 2 // Position circles after title height

        // Append the legend circles
        const legendItems = container
            .selectAll('g')
            .data(config.values)
            .join('g')
            .attr('class', 'em-pie-size-legend-item')
            .attr('transform', `translate(${maxSize + out.boxPadding}, ${y})`) // Dynamically move the circles down

        // Append circles to each group
        legendItems
            .append('circle')
            .attr('class', 'em-pie-size-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -map.sizeClassifier_(d)) // Position circles based on their size
            .attr('r', map.sizeClassifier_) // Radius is calculated from size classifier

        // Append labels to each group
        legendItems
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('y', (d) => -2 * map.sizeClassifier_(d) - out.labelFontSize - 2) // Position labels relative to circles
            .attr('x', 30) // Set the x-position for the labels
            .attr('dy', '1.2em')
            .attr('xml:space', 'preserve')
            .text((d) => d.toLocaleString('en').replace(/,/gi, ' ')) // Format the label text

        // Add lines pointing to the top of the corresponding circle
        legendItems
            .append('line')
            .attr('class', 'em-pie-size-legend-line')
            .attr('x1', 2)
            .attr('x2', 30)
            .attr('y1', (d) => -2 * map.sizeClassifier_(d)) // Position lines relative to circles
            .attr('y2', (d) => -2 * map.sizeClassifier_(d)) // Same position for the y2 to make a horizontal line

        // Save the height value for positioning the color legend (if needed)
        out._sizeLegendHeight = y
        return out
    }

    /**
     * Builds a legend illustrating the statistical values of the pie charts' different colours
     *
     */
    function buildColorLegend() {
        const map = out.map
        const config = out.colorLegend
        //container
        const container = out.lgg.append('g').attr('class', 'em-pie-color-legend')

        //draw title
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out._sizeLegendHeight + out.legendSpacing + out.boxPadding + out.titleFontSize)
                .text(config.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = map.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)
            //the color
            const col = map.catColors()[code] || 'lightgray'

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, code)
                    }
                })

            //label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .attr('dominant-baseline', 'middle')
                .text(map.catLabels()[code] || code)

            i++
        }

        //'no data' legend box
        if (config.noData) {
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', map.noDataFillStyle())
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                    }
                })

            //'no data' label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .text(config.noDataText)
        }
    }

    // Highlight selected segments on mouseover
    function highlightRegions(map, code) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Set all segments to white
        allSegments.style('fill', 'white')

        // Highlight only the selected segments by restoring their original color
        const selectedSegments = allSegments.filter("path[code='" + code + "']")
        selectedSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected segments
        })
    }

    // Reset all segments to their original colors on mouseout
    function unhighlightRegions(map) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Restore each segments's original color from the fill___ attribute
        allSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-proportional-symbols.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-proportional-symbols.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");









//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_3__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    out.ascending = false //the order of the legend elements. Set to false to invert.
    out.legendSpacing = 35 //spacing between color & size legends (if applicable)
    out.labelFontSize = 12 //the font size of the legend labels

    out.noDataShapeWidth = 25
    out.noDataShapeHeight = 20

    //size legend config (legend illustrating the values of different symbol sizes)
    out.sizeLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 5, //padding between title and legend body
        values: undefined, //manually define raw data values
        cellNb: 3, //number of elements in the legend
        shapePadding: 5, //the y distance between consecutive legend shape elements
        shapeOffset: { x: 0, y: 0 },
        shapeFill: 'white',
        shapeStroke: null,
        labelOffset: { x: 10, y: 0 }, //the distance between the legend box elements to the corresponding text label
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined,
        _totalBarsHeight: 0,
        _totalD3SymbolsHeight: 0,
        noData: false, // show no data legend item
        noDataText: 'No data', //no data text label
    }

    // color legend config (legend illustrating the data-driven colour classes)
    out.colorLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 10, //padding between title and legend body
        marginTop: 30, // margin top (distance between color and size legend)
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 1, //the distance between consecutive legend shape elements in the color legend
        labelOffset: { x: 5, y: 0 }, //distance (x) between label text and its corresponding shape element
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined, // user-defined d3 format function
        noData: true, //show no data
        noDataText: 'No data', //no data text label
        sepLineLength: 24, // //the separation line length
        sepLineStroke: 'black', //the separation line color
        sepLineStrokeWidth: 1, //the separation line width
        tickLength: 5, // threshold ticks length in px
    }

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const m = out.map
            const lgg = out.lgg

            //remove previous content
            lgg.selectAll('*').remove()

            //draw legend background box
            out.makeBackgroundBox()

            // reset height counters
            out.sizeLegend._totalBarsHeight = 0
            out.sizeLegend._totalD3SymbolsHeight = 0

            // legend for size
            out._sizeLegendNode = lgg.append('g').attr('class', 'size-legend-container')
            if (m.classifierSize_) {
                buildSizeLegend(m, out.sizeLegend)
            }
            // legend for ps color values
            out._colorLegendNode = lgg.append('g').attr('class', 'color-legend-container')

            // position it below size legend
            if (out._sizeLegendNode) {
                out._colorLegendNode.attr('transform', `translate(0,${out._sizeLegendNode.node().getBBox().height})`)
            }

            if (m.classifierColor_ && out.colorLegend) {
                buildColorLegend(m, out.colorLegend)
            }

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    /**
     * Builds a legend which illustrates the statistical values of different symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildSizeLegend(m) {
        if (!m.psCustomSVG_ && m.psShape_ == 'circle') {
            buildCircleLegend(m, out.sizeLegend)
            if (out.sizeLegend.noData) {
                let y = out._sizeLegendNode.node().getBBox().height + 25
                let x = out.boxPadding
                let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)
                buildNoDataLegend(container, out.sizeLegend.noDataText)
            }
            return
        } else if (m.psShape_ == 'spike') {
            buildSpikeLegend(m, out.sizeLegend)
            return
        }

        //define format for labels
        let labelFormatter = out.sizeLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        //draw title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let domain = m.classifierSize_.domain()
        let maxVal = domain[1] //maximum value of dataset (used for first or last symbol by default)

        // if user defines values for legend manually
        if (out.sizeLegend.values) {
            out.sizeLegend.cellNb = out.sizeLegend.values.length
        }

        //draw legend elements for classes: symbol + label

        // for custom paths
        m.customSymbols = { nodeHeights: 0 } // save some custom settings for buildCustomSVGItem

        for (let i = 1; i < out.sizeLegend.cellNb + 1; i++) {
            //define class number
            const c = out.ascending ? out.sizeLegend.cellNb - i + 1 : i
            //define raw value
            let val = out.sizeLegend.values ? out.sizeLegend.values[c - 1] : maxVal / c
            //calculate shape size
            let symbolSize = m.classifierSize_(val)

            if (m.psShape_ == 'bar') {
                buildBarsItem(map, val, symbolSize, i, labelFormatter)
            } else if (m.psShape_ == 'custom' || m.psCustomSVG_) {
                buildCustomSVGItem(map, val, symbolSize, i, labelFormatter)
            } else {
                buildD3SymbolItem(map, val, symbolSize, i, labelFormatter)
            }
        }

        if (out.sizeLegend.noData) {
            let y = out._sizeLegendNode.node().getBBox().height
            if (out.colorLegend) {
                y += out.colorLegend.shapeHeight + 5
            }
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    function buildSpikeLegend(map, sizeLegendConfig) {
        const spike = (length, width = map.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`

        let maxSize = map.classifierSize_(map.classifierSize_.domain()[1])

        // Determine values for the legend
        let legendValues = out.sizeLegend.values || map.classifierSize_.ticks(4).slice(1) // Use user-defined values or default ticks

        const fontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-label') // Adjust font size
        const labelSpacing = fontSize - 2 // Ensure labels are just below the spikes

        const legend = out._sizeLegendNode
            .append('g')
            .attr('id', 'em-spike-legend')
            .attr('transform', `translate(${out.boxPadding + 5},0)`)
            .attr('fill', 'black')
            .attr('text-anchor', 'middle')
            .style('font-size', `${fontSize}px`)
            .selectAll()
            .data(legendValues) // Now uses user-defined values if provided
            .join('g')
            .attr('transform', (d, i) => `translate(${40 * i + out.boxPadding},${maxSize + 5})`) // Increase spacing

        // Append spikes
        legend
            .append('path')
            .attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)
            .attr('d', (d) => spike(map.classifierSize_(d))) // Correctly maps values to spike size

        // Append labels directly below each spike
        legend
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', labelSpacing) // Ensure text is right below spikes
            .text((d) => map.classifierSize_.tickFormat(4, 's')(d))

        // 🔹 Add "No Data" item with more spacing
        if (out.sizeLegend.noData) {
            let lastLabelY = maxSize + labelSpacing + fontSize + 5 // Adjust position below the labels
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${lastLabelY})`)
            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    //'no data' legend box
    function buildNoDataLegend(container, noDataText) {
        let m = out.map

        //append symbol & style
        container
            .append('rect')
            .attr('class', 'em-legend-rect')
            .style('fill', m.noDataFillStyle())
            .attr('width', out.colorLegend ? out.colorLegend.shapeWidth : out.noDataShapeWidth)
            .attr('height', out.colorLegend ? out.colorLegend.shapeHeight : out.noDataShapeHeight)
            .on('mouseover', function () {
                highlightRegions(out.map, 'nd')
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                }
            })
            .on('mouseout', function () {
                unhighlightRegions(out.map)
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                }
            })

        //'no data' label
        container
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('x', out.colorLegend ? out.colorLegend.shapeWidth + out.colorLegend.labelOffset.x : out.noDataShapeWidth + 5)
            .attr('y', out.colorLegend ? out.colorLegend.shapeHeight / 2 : out.noDataShapeHeight / 2)
            .text(noDataText)
    }

    function highlightRegions(map, ecl) {
        // TODO: change this to estat logic of making all other classes transparent?
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', map.hoverColor())
        sel.attr('fill___', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).style('fill')
        })
    }

    function unhighlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill___')
        })
    }

    /**
     * @description builds a size legend item for proportional D3 shapes (e.g. square, triangle, star)
     * @param {*} m map instance
     * @param {number} symbolSize the size of the symbol item
     */
    function buildD3SymbolItem(m, value, symbolSize, index, labelFormatter) {
        let symbolHeight = out.map.psShape_ == 'triangle' || out.map.psShape_ == 'diamond' ? symbolSize : symbolSize / 2
        if (out.sizeLegend._totalD3SymbolsHeight == 0) out.sizeLegend._totalD3SymbolsHeight += symbolHeight + out.boxPadding //add first item height to y
        let maxSize = m.classifierSize_(m.classifierSize_.domain()[1])
        // x and y position of item in legend
        let x = maxSize
        let y =
            (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) +
            out.sizeLegend._totalD3SymbolsHeight +
            (out.sizeLegend.shapePadding * index - 1)

        out.sizeLegend._totalD3SymbolsHeight += symbolSize

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw D3 symbol
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()
        itemContainer
            .append('g')
            // .attr('transform', `translate(${x},${y})`)
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = maxSize / 2 + out.sizeLegend.labelOffset.x + out.boxPadding

        //append label
        itemContainer.append('text').attr('class', 'em-legend-label').attr('x', labelX).attr('y', 0).text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} value
     * @param {*} symbolSize
     * @param {*} index
     * @param {*} labelFormatter
     */
    function buildCustomSVGItem(m, value, symbolSize, index, labelFormatter) {
        let x = out.boxPadding //set X offset
        let y

        //first item
        if (!m.customSymbols.prevSymb) {
            y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20
            m.customSymbols.initialTranslateY = y
            m.customSymbols.prevScale = symbolSize
        }

        //following items
        if (m.customSymbols.prevSymb) {
            let prevNode = m.customSymbols.prevSymb.node()
            let bbox = prevNode.getBBox()
            m.customSymbols.nodeHeights = m.customSymbols.nodeHeights + bbox.height * m.customSymbols.prevScale
            y = m.customSymbols.initialTranslateY + m.customSymbols.nodeHeights + out.sizeLegend.shapePadding * (index - 1)
            m.customSymbols.prevScale = symbolSize
        }

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw standard symbol
        m.customSymbols.prevSymb = itemContainer
            .append('g')
            .attr('class', 'em-size-legend-symbol')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('g')
            .html(out.map.psCustomSVG_)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = x + m.classifierSize_(m.classifierSize_.domain()[0]) + out.sizeLegend.labelOffset.x
        let labelY = out.sizeLegend.shapeOffset.y / 2 + 1 //y + out.sizeLegend.labelOffset.y

        //append label
        itemContainer.append('text').attr('class', 'em-legend-label').attr('x', labelX).attr('y', labelY).text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} symbolSize
     */
    function buildBarsItem(m, value, symbolSize, index, labelFormatter) {
        // for vertical bars we dont use a dynamic X offset because all bars have the same width
        let x = out.boxPadding
        //we also dont need the y offset
        let y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + out.sizeLegend._totalBarsHeight + 10

        out.sizeLegend._totalBarsHeight += symbolSize + 10

        //set shape size and define 'd' attribute
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw bar symbol
        itemContainer
            .append('g')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })
        //label position
        let labelX = x + out.map.psBarWidth_ + out.sizeLegend.labelOffset.x
        let labelY = symbolSize / 2 + out.sizeLegend.labelOffset.y

        //append label
        itemContainer.append('text').attr('class', 'em-legend-label').attr('x', labelX).attr('y', labelY).text(labelFormatter(value))
    }

    /**
     * @description builds a nested circle legend for proportional circles
     * @param {*} m map
     */
    function buildCircleLegend(m) {
        //assign default circle radiuses if none specified by user
        let domain = m.classifierSize_.domain()
        if (!out.sizeLegend.values) {
            // default legend values
            out._sizeLegendValues = [Math.floor(domain[1]), Math.floor(domain[1] / 2), Math.floor(domain[0])]
        } else {
            // user defined legend values
            out._sizeLegendValues = out.sizeLegend.values
        }

        //draw title
        if (!out.sizeLegend.title && out.title) out.sizeLegend.title = out.title //if unspecified, set size legend title as root legend title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let maxRadius = m.classifierSize_((0,d3_array__WEBPACK_IMPORTED_MODULE_5__["default"])(out._sizeLegendValues)) //maximum circle radius to be shown in legend
        let x = out.boxPadding + maxRadius
        let y = out.boxPadding + maxRadius * 2 + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20

        let itemContainer = out._sizeLegendNode
            .append('g')
            .attr('transform', `translate(${x},${y})`)
            .attr('class', 'circle-legend')
            .attr('text-anchor', 'right')
            .style('fill', 'black')
            .selectAll('g')
            .data(out._sizeLegendValues.filter((d) => m.classifierSize_(d))) // Filter data before binding
            .join('g')
            .attr('class', 'em-legend-item')

        //circles
        itemContainer
            .append('circle')
            .attr('class', 'em-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -m.classifierSize_(d))
            .attr('r', m.classifierSize_)

        //labels
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('y', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x', maxRadius + 5)
            .text((d) => {
                return d.toLocaleString('en').replace(/,/gi, ' ')
            })
        //line pointing to top of corresponding circle:
        itemContainer
            .append('line')
            .style('stroke-dasharray', 2)
            .style('stroke', 'grey')
            .attr('x1', 2)
            .attr('y1', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x2', maxRadius + 5)
            .attr('y2', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })

        return out
    }

    /**
     * Builds a legend illustrating the statistical values of different symbol colours
     *
     * @param {*} m map
     */
    function buildColorLegend(m) {
        //define format for labels
        let f = out.colorLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        const svgMap = m.svg()

        //title
        if (out.colorLegend.title) {
            out._colorLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.titleFontSize + out.colorLegend.marginTop)
                .text(out.colorLegend.title)
        }

        // x position of color legend cells
        let x = out.boxPadding

        //draw legend elements for classes: rectangle + label
        let numberOfClasses = m.psClasses_

        for (let i = 0; i < numberOfClasses; i++) {
            //the vertical position of the legend element
            let y = out.titleFontSize + out.colorLegend.titlePadding + out.colorLegend.marginTop + i * out.colorLegend.shapeHeight // account for title + margin

            //the class number, depending on order
            const ecl = out.ascending ? i : numberOfClasses - i - 1

            let itemContainer = out._colorLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-legend-item')

            //append symbol & style
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .style('fill', m.psClassToFillStyle()(ecl, numberOfClasses))
                .attr('width', out.colorLegend.shapeWidth)
                .attr('height', out.colorLegend.shapeHeight)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            //separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', 0 + out.colorLegend.sepLineLength)
                    .attr('y2', 0)
            }

            // Append tick line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.colorLegend.shapeWidth)
                    .attr('y1', 0)
                    .attr('x2', out.colorLegend.sepLineLength + out.colorLegend.tickLength)
                    .attr('y2', 0)
            }

            //label
            if (i < numberOfClasses - 1) {
                itemContainer
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.colorLegend.sepLineLength + out.colorLegend.tickLength + out.colorLegend.labelOffset.x)
                    .attr('y', out.colorLegend.shapeHeight)
                    .text((d) => {
                        let text = f(m.classifierColor_.invertExtent(out.ascending ? ecl + 1 : ecl - 1)[out.ascending ? 0 : 1])
                        return text
                    })
            }
        }

        //'no data' legend box
        if (out.colorLegend.noData) {
            let y = out.titleFontSize + out.colorLegend.marginTop + numberOfClasses * out.colorLegend.shapeHeight + 20 // add 20 to separate it from the rest
            let container = out._colorLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.colorLegend.noDataText)
        }
    }

    /**
     * @description returns the d3.symbol object chosen by the user
     * @return {d3.shape || SVG}
     */
    function getShape() {
        let shape
        if (out.map.psCustomSVG_) {
            shape = out.map.psCustomSVG_
        } else if (out.map.psCustomShape_) {
            shape = out.map.psCustomShape_
        } else if (out.map.psShape_ == 'bar') {
            //for rectangles, we use a custom d3 symbol
            let drawRectangle = (context, size) => {
                let height = Math.sqrt(size)
                context.moveTo(0, 0)
                context.lineTo(0, height)
                context.lineTo(out.map.psBarWidth_, height)
                context.lineTo(out.map.psBarWidth_, 0)
                context.lineTo(0, 0)
                context.closePath()
            }
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().type({ draw: drawRectangle })
        } else {
            let symbolType = _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary[out.map.psShape_] || _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary['circle']
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().type(symbolType)
        }
        return shape
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Set all symbols to white
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.childNodes[0])
            symbol.style('fill', 'white')
        })

        // Highlight only the selected regions by restoring their original color
        const selectedSymbols = allSymbols.filter("[ecl='" + ecl + "']")
        selectedSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-stripe-composition.js":
/*!*************************************************!*\
  !*** ./src/legend/legend-stripe-composition.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const svgMap = m.svg()
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        //draw title
        if (out.title) {
            lgg.append('text')
                .attr('class', 'em-legnd-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = m.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //the color
            const col = m.catColors()[code] || 'lightgray'

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this)
                    sel.raise()
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            //label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(m.catLabels()[code] || code)
                .on('mouseover', function () {
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const col = m.catColors()[code] || 'lightgray'
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', col)
                })

            i++
        }

        //'no data' legend box
        if (out.noData) {
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', m.noDataFillStyle())
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.noDataFillStyle())
                })

            //'no data' label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(out.noDataText)
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                })
        }

        //set legend box dimensions
        out.setBoxDimension()
    }

    function highlightRegions(map, code) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Save original colors if not already stored
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            if (!el.attr('data-original-fill')) {
                el.attr('data-original-fill', el.style('fill'));
            }
            el.style('fill', 'white'); // Set all regions to white
        });
    
        // Highlight only the selected regions by restoring their original color
        const selectedRegions = map.svg_.selectAll("pattern").selectAll("rect[code='" + code + "']");
        selectedRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            el.style('fill', el.attr('data-original-fill')); // Restore original fill
        });
    }
    
    function unhighlightRegions(map) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Restore each region's original color from the stored attribute
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            const originalFill = el.attr('data-original-fill');
            if (originalFill) {
                el.style('fill', originalFill);
            }
        });
    }
    
    return out
}


/***/ }),

/***/ "./src/legend/legend.js":
/*!******************************!*\
  !*** ./src/legend/legend.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



/**
 * A eurostat-map legend. This is an abstract method.
 */
const legend = function (map) {
    //build legend object
    const out = {}

    //link map to legend
    out.map = map

    //the SVG where to make the legend
    out.svgId = 'legend_' + Math.round(10e15 * Math.random())
    out.svg = undefined
    out.lgg = undefined

    //the legend element position, in case it is embeded within the map SVG
    out.x = undefined
    out.y = undefined

    //the legend box
    out.boxPadding = 7
    out.boxOpacity = 0.7

    //legend title
    out.title = ''
    // we now use CSS instead of inline styles
    out.titleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-title')
    // we now use CSS instead of inline styles
    out.labelFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-label')

    /** Build legend. */
    out.build = function () {
        //set SVG element and add main drawing group
        out.svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId)
        // clear previous legend(s)
        out.svg.selectAll('#em-legend-' + out.svgId).remove()
        // append new legend group
        out.lgg = out.svg
            .append('g')
            .attr('id', 'em-legend-' + out.svgId)
            .attr('class', 'em-legend')
    }

    /**
     * Update the legend element.
     * This is an abstract method to be defined for each specific legend.
     */
    out.update = function () {
        console.log('Legend update function not implemented')
        return out
    }

    out.updateContainer = function () {
        const map = out.map
        const container = out.lgg
        // Remove previous content
        container.selectAll('*').remove()

        //check if provided external svgId has changed
        const legendSVG = out.svg
        if (legendSVG.attr('id') !== map.legend_.svgId) {
            out.build() // sets new svg and lgg
        }
    }

    out.updateConfig = function () {
        const map = out.map
        // Update legend parameters if necessary
        if (map.legend_) {
            deepMergeExistingKeys(out, map.legend_)
        }

        //ps
        // // update legend parameters if necessary
        // if (m.legend_)
        //     for (let key in m.legend_) {
        //         if (key == 'colorLegend' || key == 'sizeLegend') {
        //             for (let p in out[key]) {
        //                 //override each property in size and color legend m.legend_
        //                 if (m.legend_[key][p] !== undefined) {
        //                     out[key][p] = m.legend_[key][p]
        //                 }
        //             }
        //         } else {
        //             out[key] = m.legend_[key]
        //         }
        //     }
    }

    //It performs a shallow copy — nested objects will be copied by reference, not duplicated.
    //It modifies the target object (out) in place.
    //Useful for merging objects or extending existing ones.
    function deepMergeExistingKeys(target, source, options = {}, seen = new WeakSet(), depth = 0) {
        const MAX_DEPTH = options.maxDepth || 100

        if (seen.has(target)) return target
        seen.add(target)

        if (depth > MAX_DEPTH) {
            console.warn(`Max recursion depth (${MAX_DEPTH}) reached.`)
            return target
        }

        for (const key in source) {
            if (source.hasOwnProperty(key) && target.hasOwnProperty(key)) {
                const sourceVal = source[key]
                const targetVal = target[key]

                // Handle functions: overwrite directly
                if (typeof sourceVal === 'function') {
                    target[key] = sourceVal

                    // Handle nested plain objects
                } else if (isPlainObject(sourceVal) && isPlainObject(targetVal)) {
                    deepMergeExistingKeys(targetVal, sourceVal, options, seen, depth + 1)

                    // Handle arrays: overwrite (or merge if option set)
                } else if (Array.isArray(sourceVal) && Array.isArray(targetVal)) {
                    target[key] = options.mergeArrays ? [...new Set([...targetVal, ...sourceVal])] : [...sourceVal]

                    // Handle Dates
                } else if (sourceVal instanceof Date) {
                    target[key] = new Date(sourceVal.getTime())

                    // Handle RegExp
                } else if (sourceVal instanceof RegExp) {
                    target[key] = new RegExp(sourceVal)

                    // Handle Map and Set
                } else if (sourceVal instanceof Map) {
                    target[key] = new Map(sourceVal)
                } else if (sourceVal instanceof Set) {
                    target[key] = new Set(sourceVal)

                    // Overwrite primitives and other types
                } else {
                    target[key] = sourceVal
                }
            }
        }

        return target
    }

    // Helper to check for plain objects
    function isPlainObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]'
    }

    /** Draw legend background box */
    out.makeBackgroundBox = function () {
        out.lgg.append('rect').attr('id', 'legendBR').attr('class', 'em-legend-background').style('opacity', out.boxOpacity)
    }

    /** Set legend box dimensions, ensuring it has suitable dimensions to fit to all legend graphic elements */
    out.setBoxDimension = function () {
        if (out.lgg.node()) {
            //get legend elements bounding box
            const bb = out.lgg.node().getBBox({ stroke: true })
            //apply to legend box dimensions
            const p = out.boxPadding
            out.svg
                .select('#legendBR')
                .attr('x', bb.x - p)
                .attr('y', bb.y - p)
                .attr('width', bb.width + 2 * p)
                .attr('height', bb.height + 2 * p)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-categorical.js":
/*!*****************************************!*\
  !*** ./src/maptypes/map-categorical.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-categorical */ "./src/legend/legend-categorical.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Returns a categorical map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'ct')

    /** Fill style for each category/class. Ex.: { urb: "#fdb462", int: "#ffffb3", rur: "#ccebc5" } */
    out.classToFillStyle_ = undefined
    /** Text label for each category/class. Ex.: { "urb": "Urban", "int": "Intermediate", "rur": "Rural" } */
    out.classToText_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunCat

    //the classifier: a function which returns a class number from a stat value.
    out.classifier_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['classToFillStyle_', 'classToText_', 'noDataFillStyle_', 'tooltipText_', 'classifier_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['classToFillStyle', 'classToText', 'noDataFillStyle', 'tooltipText', 'classifier'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //get domain (unique values)
        const domain = out.statData().getUniqueValues()

        //get range [0,1,2,3,...,domain.length-1]
        const range = [...Array(domain.length).keys()]

        //make classifier
        //only use user-define classes
        const ctfs = out.classToFillStyle_ ? out.classToFillStyle() : undefined
        if (ctfs) {
            const categories = Object.keys(ctfs)
            out.classifier(
                (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])()
                    .domain(categories) // Only classify known categories
                    .range(categories.map((_, i) => i)) // Assign numerical classes
            )
        } else {
            // Use all unique values if no user-defined classes exist
            out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(domain).range(range))
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const sv = out.statData().get(rg.properties.id)
                if (!sv) return

                const v = sv.value
                if (v === ':') return 'nd' // No data

                const value = isNaN(v) ? v : +v // Convert numbers, keep strings as is

                // 🔹 Ensure only known values are classified
                const classifierDomain = out.classifier().domain()
                if (!classifierDomain.includes(value)) return // Skip unknown values

                return out.classifier()(value)
            })
        }

        let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        classifyRegions(map.svg().selectAll(selector))

        // Handle mixed NUTS level, separating NUTS level 0
        if (map.nutsLevel_ === 'mixed') {
            const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
            classifyRegions(nuts0Regions)
        }
    }

    //@override
    out.updateStyle = function () {
        //if no color specified, use some default colors
        if (!out.classToFillStyle()) {
            const ctfs = {}
            const dom = out.classifier().domain()
            for (let i = 0; i < dom.length; i++) ctfs[dom[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__["default"][i % 12]
            out.classToFillStyle(ctfs)
        }

        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)
        return out
    }

    function applyStyleToMap(map) {
        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .style('display', function (rg) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')
                return ecl || lvl === '0' ? 'block' : 'none'
            })
            .style('stroke', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const stroke = sel.style('stroke')
                return ecl && lvl !== '0' ? stroke || '#777' : null
            })
            .style('stroke-width', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const strokeWidth = sel.style('stroke-width')
                return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle_[out.classifier().domain()[ecl]]
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_[out.classifier().domain()[ecl]]
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle_[out.classifier().domain()[ecl]]
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        // Set up mouse events
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunCat = function (rg, map) {
    const buf = []
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + '</div>')
    }
    //get stat value
    const sv = map.statData().get(rg.properties.id)
    //case when no data available
    if (!sv || (sv.value != 0 && !sv.value)) {
        buf.push(map.noDataText_)
        return buf.join('')
    }
    const val = sv.value
    if (map.classToText_) {
        const lbl = map.classToText_[val]
        //display label and value
        buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${lbl ? lbl : val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
        return buf.join('')
    }
    //display just value
    buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-bivariate.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-choropleth-bivariate.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-bivariate */ "./src/legend/legend-choropleth-bivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a bivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chbi')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#73ae80'
    out.color2_ = '#6c83b5'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined

    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunBiv

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        const setupClassifiers = () => {
            let stat1 = out.statData('v1').getArray()
            let stat2 = out.statData('v2').getArray()

            const range = [...Array(out.numberOfClasses()).keys()]
            if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
            if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))

            //define bivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleBivariate(out.numberOfClasses(), out.startColor(), out.color1(), out.color2(), out.endColor())
                out.classToFillStyle(scale)
            }
        }

        const classifyRegions = (regions) => {
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    if (rg.properties.id.length == 4) console.log(rg)
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('nd', function (rg) {
                    const sv1 = out.statData('v1').get(rg.properties.id)
                    const sv2 = out.statData('v2').get(rg.properties.id)
                    if (!sv1 || !sv2) return
                    let v = sv1.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    v = sv2.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return ''
                })
        }

        // Initialize classifier
        setupClassifiers()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    if (!ecl1 && !ecl2) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    let color = out.classToFillStyle()(+ecl1, +ecl2)
                    return color
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        // Set up mouse events
                        addMouseEventsToRegions(map, regions)

                        // update font color for grid cartograms (contrast)
                        if (out.gridCartogram_) {
                            map.svg()
                                .selectAll('.em-grid-text')
                                .each(function () {
                                    const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.parentNode).style('fill')
                                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                                })
                        }
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                const ecl1 = sel.attr('ecl1')
                const ecl2 = sel.attr('ecl2')
                const lvl = sel.attr('lvl')

                // Determine display visibilitys
                const isVisible = ecl1 || ecl2 || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if ((ecl1 || ecl2) && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.style('fill', map.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const scaleBivariate = function (numberOfClasses, startColor, color1, color2, endColor) {
    //color ramps, by row
    const cs = []
    //interpolate from first and last columns
    const rampS1 = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(startColor, color1)
    const ramp2E = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(color2, endColor)
    for (let i = 0; i < numberOfClasses; i++) {
        const t = i / (numberOfClasses - 1)
        const colFun = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(rampS1(t), ramp2E(t))
        const row = []
        for (let j = 0; j < numberOfClasses; j++) row.push(colFun(j / (numberOfClasses - 1)))
        cs.push(row)
    }
    //TODO compute other matrix based on rows, and average both?

    return function (ecl1, ecl2) {
        return cs[ecl1][ecl2]
    }
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunBiv = function (rg, map) {
    const buf = []
    //region name
    const regionName = rg.properties.na || rg.properties.name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
        ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-trivariate.js":
/*!***************************************************!*\
  !*** ./src/maptypes/map-choropleth-trivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-trivariate */ "./src/legend/legend-choropleth-trivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a trivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chtri')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#09F8FF'
    out.color2_ = '#F5D300'
    out.color3_ = '#FF1493'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined
    out.classifier3_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunctionTrivariate

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'color3_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
        'classifier3_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'color3', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        let stat1 = out.statData('v1').getArray()
        let stat2 = out.statData('v2').getArray()
        let stat3 = out.statData('v3').getArray()

        const range = [...Array(7).keys()]
        if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
        if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))
        if (!out.classifier3_) out.classifier3((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat3).range(range))

        //assign class to nuts regions, based on their value
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        if (map.svg_) {
            let regions = map.svg().selectAll(selector)
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('ecl3', function (rg) {
                    const sv = out.statData('v3').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier3_(+v)
                })
                .attr('regionClass', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')

                    if (ecl1 === 'nd' || ecl2 === 'nd' || ecl3 === 'nd') return 'nd' // Handle 'no data'

                    // Combine the classifier results into a single class (1-7)
                    if (ecl1 && !ecl2 && !ecl3) return 1 // only variable 1 present
                    if (!ecl1 && ecl2 && !ecl3) return 2 // only variable 2 present
                    if (!ecl1 && !ecl2 && ecl3) return 3 // only variable 3 present
                    if (ecl1 && ecl2 && !ecl3) return 4 // variables 1 & 2 present
                    if (ecl1 && !ecl2 && ecl3) return 5 // variables 1 & 3 present
                    if (!ecl1 && ecl2 && ecl3) return 6 // variables 2 & 3 present
                    if (ecl1 && ecl2 && ecl3) return 7 // all present
                })
            // .attr('nd', function (rg) {
            //     const sv1 = out.statData('v1').get(rg.properties.id) || out.statData().get(rg.properties.id)
            //     const sv2 = out.statData('v2').get(rg.properties.id)
            //     if (!sv1 || !sv2) return
            //     let v = sv1.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     v = sv2.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     return ''
            // })

            //when mixing NUTS, level 0 is separated from the rest (class nutsrg0)
            if (map.nutsLevel_ == 'mixed') {
                map.svg()
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v1').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }

            //define trivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleTrivariate(out.color1(), out.color2(), out.color3())
                out.classToFillStyle(scale)
            }

            //when mixing NUTS, level 0 is separated from the rest (using class nutsrg0)
            if (out.nutsLevel_ == 'mixed') {
                map.svg_
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }
        }
    }

    const scaleTrivariate = function (color1, color2, color3) {
        // Blending primary colors and their overlaps
        const overlapColors = [
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2]), // Class 4 (Overlap of color1 and color2)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color2, color3]), // Class 5 (Overlap of color2 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color3]), // Class 6 (Overlap of color1 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2, color3]), // Class 7 (Overlap of all three)
        ]

        // Class-to-color mapping
        const classColors = [
            color1, // Class 1 (First color)
            color2, // Class 2 (Second color)
            color3, // Class 3 (Third color)
            overlapColors[0], // Class 4 (Overlap of color1 and color2)
            overlapColors[1], // Class 5 (Overlap of color2 and color3)
            overlapColors[2], // Class 6 (Overlap of color1 and color3)
            overlapColors[3], // Class 7 (Overlap of all three)
        ]

        // Return function to get color based on region's class (1 to 7)
        return function (classIndex) {
            if (classIndex >= 1 && classIndex <= 7) {
                return classColors[classIndex - 1]
            } else {
                return null // Return null or a default color if the classIndex is out of range
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl3 === 'nd') return out.noDataFillStyle() || 'gray'

                    if (!ecl1 && !ecl2 && !ecl3) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.

                    let regionClass = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('regionClass')
                    let color = out.classToFillStyle_(regionClass)
                    return color

                    //return getCSSPropertyFromClass('em-nutsrg', 'fill')
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        regions
                            .on('mouseover', function (e, rg) {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                sel.style('fill', map.hoverColor_)
                                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                            })
                            .on('mousemove', function (e, rg) {
                                if (out._tooltip) out._tooltip.mousemove(e)
                            })
                            .on('mouseout', function () {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                let newFill = sel.attr('fill___')
                                if (newFill) {
                                    sel.style('fill', sel.attr('fill___'))
                                    if (out._tooltip) out._tooltip.mouseout()
                                }
                            })
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const styleMixedNUTS = function (map) {
    map.svg()
        .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
        .style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const ecl = sel.attr('ecl')
            const lvl = sel.attr('lvl')
            const countryId = rg.properties.id.slice(0, 2)
            return ecl || lvl === '0' ? 'block' : 'none'
        })
        .style('stroke', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const stroke = sel.style('stroke')
            return ecl && lvl !== '0' ? stroke || '#777' : null
        })
        .style('stroke-width', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const strokeWidth = sel.style('stroke-width')
            return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
        })
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunctionTrivariate = function (rg, map) {
    const buf = []
    //region name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()
    //stat 3 value
    const sv3 = map.statData('v3').get(rg.properties.id)
    const unit3 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        Variable 1: ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 2: ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 3: ${sv3 && sv3.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv3.value) : ''} ${unit3 && sv3 && sv3.value ? unit3 : ''}
        ${!sv3 || (sv3.value != 0 && !sv3.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-choropleth.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   getFillPatternLegend: () => (/* binding */ getFillPatternLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var simple_statistics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! simple-statistics */ "./node_modules/simple-statistics/dist/simple-statistics.mjs");











/**
 * Returns a chroropleth map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'ch')

    //the number of classes
    out.numberOfClasses_ = 7
    //the classification method
    out.classificationMethod_ = 'quantile' // or: equinter, threshold
    //the threshold, when the classification method is 'threshold'
    out.thresholds_ = [0]
    //colors to use for classes
    out.colors_ = null
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //the color function [0,1] -> color
    let eurostatMultihue = ['#FFEB99', '#D1E9B0', '#8DD6B9', '#58C1C0', '#3792B6', '#134891', '#1d2b6f']
    out.colorFunction_ = (t) => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_4__["default"])(d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"], eurostatMultihue)(Math.min(Math.max(0, t), 1)) // default
    //a function returning the color from the class i
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier_ = undefined
    // set tooltip function
    out.tooltip_.textFunction = choroplethTooltipFunction

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'classificationMethod_',
        'thresholds_',
        'makeClassifNice_',
        'colorFunction_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier_',
        'colors_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override of some special getters/setters
    out.colorFunction = function (v) {
        if (!arguments.length) {
            return out.colorFunction_
        }
        out.colorFunction_ = v
        // update class style function
        if (out.filtersDefinitionFunction_) {
            // if dot density
            out.classToFillStyle(getFillPatternLegend())
        } else {
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }
        return out
    }
    out.threshold = function (v) {
        if (!arguments.length) return out.thresholds_
        out.thresholds_ = v
        out.numberOfClasses(v.length + 1)
        return out
    }
    out.filtersDefinitionFunction = function (v) {
        if (!arguments.length) return out.filtersDefinitionFunction_
        out.filtersDefinitionFunction_ = v
        if (out.svg()) out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        return out
    }

    //override attribute values with config values
    if (config)
        [
            'numberOfClasses',
            'classificationMethod',
            'threshold',
            'makeClassifNice',
            'colorFunction',
            'classToFillStyle',
            'noDataFillStyle',
            'colors_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        // Helper function to generate a range [0, 1, 2, ..., nb-1]
        const generateRange = (nb) => [...Array(nb).keys()]

        // Configure classifier based on the selected classification method
        const setupClassifier = () => {
            const dataArray = out.statData().getArray()
            const range = generateRange(out.numberOfClasses_)

            switch (out.classificationMethod_) {
                case 'quantile': {
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])().domain(dataArray).range(range))
                    break
                }
                case 'equal-interval':
                case 'equinter': {
                    out.classifier(
                        (0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])()
                            .domain([(0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(dataArray), (0,d3_array__WEBPACK_IMPORTED_MODULE_9__["default"])(dataArray)])
                            .range(range)
                    )
                    if (out.makeClassifNice_) out.classifier().nice()
                    break
                }
                case 'threshold': {
                    out.numberOfClasses(out.thresholds_.length + 1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(out.thresholds_).range(generateRange(out.numberOfClasses_)))
                    break
                }
                case 'jenks': {
                    const jenksBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_3__.jenks)(dataArray, out.numberOfClasses_) // Calculate breaks for Jenks
                    const domain = jenksBreaks.slice(1, -1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(domain).range(range)) // Use Jenks breaks in scale
                    break
                }
                case 'ckmeans': {
                    // Calculate ckmeans breaks, extracting the maximum value from each cluster
                    const ckmeansBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_3__.ckmeans)(dataArray, out.numberOfClasses_).map((cluster) => cluster.pop())

                    // Set the domain for scaleThreshold excluding the last value, as it serves as the upper bound
                    const domain = ckmeansBreaks.slice(0, -1)

                    // Use the ckmeans breaks in the scaleThreshold and set the classifier
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(domain).range(range))
                    break
                }
            }
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const regionData = out.statData().get(rg.properties.id)
                if (!regionData) return // Lack of data is handled explicitly
                const value = regionData.value
                if (value === ':' || value === null) return 'nd'
                return value != null ? +out.classifier_(value) : undefined
            })
        }

        // Initialize classifier
        setupClassifier()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        // Define function to get a class' color
        if (out.filtersDefinitionFunction_) {
            // Dot density style
            out.classToFillStyle(getFillPatternLegend())
        } else {
            // Color legend style
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }

        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')

                // Determine display visibility
                const isVisible = ecl || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if (ecl && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle()(ecl, out.numberOfClasses_)
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_(ecl, out.numberOfClasses_)
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle()(ecl, out.numberOfClasses_)
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFunction, colorArray) {
    colorFunction = colorFunction || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_12__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFunction(ecl / (numberOfClasses - 1))
    }
}

/**
 * Build a fill pattern legend object { nd:"white", 0:"url(#pattern_0)", 1:"url(#pattern_1)", ... }
 */
const getFillPatternLegend = function () {
    return function (ecl) {
        return 'url(#pattern_' + ecl + ')'
    }
}

const choroplethTooltipFunction = function (region, map) {
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na || region.properties.name
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    // Retrieve region's data value and unit
    const statData = map.statData()
    const sv = statData.get(regionId)
    const unit = statData.unitText() || ''

    // No data case
    if (!sv || (sv.value !== 0 && !sv.value) || sv.value === ':') {
        buf.push(`
            <div class="estat-vis-tooltip-text no-data">
                <table class="nuts-table">
                    <tbody>
                        <tr><td>${map.noDataText_}</td></tr>
                    </tbody>
                </table>
            </div>
        `)
        return buf.join('')
    }

    // Data display
    buf.push(`
        <div class="estat-vis-tooltip-text">
            <table class="nuts-table">
                <tbody>
                    <tr><td>${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv.value)} ${unit}</td></tr>
                </tbody>
            </table>
        </div>
    `)

    // Optional status flag
    const statusFlag = sv.status
    if (statusFlag && map.tooltip_.showFlags) {
        const flagText = map.tooltip_.showFlags === 'short' ? statusFlag : flags[statusFlag] || statusFlag
        buf.push(` <span class="status-flag">${flagText}</span>`)
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-flow.js":
/*!**********************************!*\
  !*** ./src/maptypes/map-flow.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/link.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-flow */ "./src/legend/legend-flow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
// Import required D3 modules
// import { sankey, sankeyLinkHorizontal } from 'd3-sankey'









/**
 * Returns a flow map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'flow')
    out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])()
    out.labelOffsetX = 15
    out.labelOffsetY = 5
    out.labelFormatter = (d) => (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)('.2s')(d)
    out.tooltip_.textFunction = flowMapTooltipFunction
    out.flowColor_ = '#72bb6f'
    out.flowOverlayColors_ = ['#bbd7ee', '#c7e3c6'] // exporter, importers

    /**
     * flowmap-specific setters/getters
     */
    ;['flowGraph_', 'flowColor_', 'flowOverlayColors_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //@override
    out.updateStyle = function () {
        // type: "Feature"
        // properties: Object {id: "ES", na: "España"}
        // geometry: Object {type: "MultiPolygon", coordinates: Array(7)}
        // source: "FR"
        // target: "ES"
        // value: 45422327.56

        // update stroke width function
        const data = out.flowGraph_.links
        out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])()
            .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_5__["default"])(data, (d) => d.value)])
            .range([2, 10])

        createFlowMapSVG(out.flowGraph_)
    }

    //@override
    out.updateClassification = function () {}

    //@override
    out.getLegendConstructor = function () {
        //TODO: define legend
        return _legend_legend_flow__WEBPACK_IMPORTED_MODULE_1__.legend
    }
    /**
     * Function to create a map with Sankey diagram and other elements
     * @param {Object} graph - Configuration options and data for the map
     * exampleGraph = {
                nodes: [
                    { id: 'FR', x: 681.1851800759263, y: 230.31124763648583 },
                    { id: 'DE', x: 824.5437782154489, y: 123.70302649032199 },
                ],
                links: [
                    { source: 'FR', target: 'DE', value: 82018369.72 },
                ],
            }
     */
    function createFlowMapSVG(graph) {
        const svg = out.svg_

        // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
        addCoordinatesToGraph(graph)

        var { nodes, links } = sankey(graph)

        // Define marker and gradient IDs
        const defs = svg.append('defs')
        const arrowId = generateUniqueId('arrow')
        const arrowOutlineId = generateUniqueId('arrow-outline')
        const gradientIds = links.map(() => generateUniqueId('gradient'))

        // Add arrow markers
        addArrowMarker(defs, arrowId, out.flowColor_)
        addArrowMarker(defs, arrowOutlineId, '#ffffff')

        // Add flow gradients
        addFlowGradients(defs, gradientIds, links)

        // Define our container SVG
        const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])('#em-zoom-group-' + out.svgId_)
        const sankeyContainer = zoomGroup.append('g').attr('class', 'em-flow-container')

        // Add geographical layers
        addOverlayPolygons(sankeyContainer, graph)

        // Add Sankey flows
        addSankeyFlows(sankeyContainer, links, arrowId, arrowOutlineId, gradientIds)

        // Add additional nodes (fill gaps)
        addFillGaps(sankeyContainer, nodes)

        // Add labels to nodes
        if (out.labels_) addLabels(sankeyContainer, nodes)

        return svg.node()
    }

    /**
     * Adds geographical layers (regions, POI overlay, borders)
     * @param {Object} svg - D3 selection of SVG container
     */
    function addOverlayPolygons(svg, graph) {
        const importerIds = []
        const exporterIds = []
        const features = out.Geometries.getRegionFeatures()
        if (features) {
            graph.nodes.forEach((node) => {
                const overlay = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (overlay) {
                    let isImporter = graph.links.some((link) => link.source == node.id)
                    if (isImporter) {
                        importerIds.push(node.id)
                    } else {
                        exporterIds.push(node.id)
                    }
                } else {
                    console.error('could not find geometry for', node.id)
                }
            })

            //update existing region fills
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
            const allRegions = out.svg_.selectAll(selector)

            allRegions.each(function () {
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).style('fill', (region) => {
                    if (importerIds.includes(region.properties.id)) return out.flowOverlayColors_[0]
                    if (exporterIds.includes(region.properties.id)) return out.flowOverlayColors_[1]
                })
            })
        }
    }

    // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
    function addCoordinatesToGraph(graph) {
        graph.nodes.forEach((node) => {
            if (!node.x && !node.y && out.Geometries.centroidFeatures) {
                const centroid = out.Geometries.centroidFeatures.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (centroid) {
                    const screenCoords = out._projection([centroid.geometry.coordinates[0], centroid.geometry.coordinates[1]])
                    node.x = screenCoords[0]
                    node.y = screenCoords[1]
                } else {
                    console.error('could not find coordinates for', node.id)
                }
            } else {
                // no centroids data, calculate on the fly
                const features = out.Geometries.getRegionFeatures()
                const feature = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })
                const centroid = feature.properties.centroid || out._pathFunction.centroid(feature)
                const screenCoords = out._projection([centroid[0], centroid[1]])
                node.x = screenCoords[0]
                node.y = screenCoords[1]
            }
        })
        console.log(graph)
    }

    /**
     * Generates a unique DOM ID
     * @param {string} prefix - Prefix for the ID
     * @returns {string} Unique ID
     */
    function generateUniqueId(prefix) {
        return `${prefix}-${Math.random().toString(36).substr(2, 9)}`
    }

    /**
     * Adds an arrow marker to the defs section
     * @param {Object} defs - D3 selection of defs
     * @param {string} id - Marker ID
     * @param {string} color - Fill color of the marker
     */
    function addArrowMarker(defs, id, color) {
        defs.append('marker')
            .attr('id', id)
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', color)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')

        // add a copy for mouseover with hovered color
        defs.append('marker')
            .attr('id', id + 'mouseover')
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', out.hoverColor_)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')
    }

    /**
     * Adds linear gradient definitions for flow links
     * @param {Object} defs - D3 selection of defs
     * @param {Array} gradientIds - Array of gradient IDs
     * @param {Array} links - Sankey links data
     */
    function addFlowGradients(defs, gradientIds, links) {
        defs.selectAll('linearGradient')
            .data(links)
            .join('linearGradient')
            .attr('id', (_, i) => gradientIds[i])
            .attr('gradientUnits', 'userSpaceOnUse')
            .attr('x1', (d) => d.source.x1)
            .attr('x2', (d) => d.target.x0)
            .attr('y1', (d) => d.y0)
            .attr('y2', (d) => d.y1)
            .call((g) => g.append('stop').attr('offset', '5%').attr('stop-color', out.flowOverlayColors_[0]))
            .call((g) => g.append('stop').attr('offset', '50%').attr('stop-color', out.flowColor_))
    }

    /**
     * Adds Sankey flows (links with markers and gradients)
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} links - Sankey links data
     * @param {string} arrowId - Arrow marker ID
     * @param {string} arrowOutlineId - Arrow outline marker ID
     * @param {Array} gradientIds - Gradient IDs
     */
    function addSankeyFlows(svg, links, arrowId, arrowOutlineId, gradientIds) {
        const flowsGroup = svg.append('g').attr('class', 'em-flows-group')

        links.forEach((link, i) => {
            // Outline path
            flowsGroup
                .append('path')
                .attr('d', sankeyLinkHorizontal()(link))
                .attr('fill', 'none')
                .attr('stroke', '#ffffff')
                .attr('class', 'em-flow-link-outline')
                .attr('stroke-width', link.width + 1.5)
                .attr('marker-end', `url(#${arrowOutlineId})`)

            // Main path
            flowsGroup
                .append('path')
                .attr('d', sankeyLinkHorizontal()(link))
                .attr('fill', 'none')
                .attr('class', 'em-flow-link')
                .attr('stroke', `url(#${gradientIds[i]})`)
                .attr('stroke-width', link.width)
                .attr('marker-end', `url(#${arrowId})`)
                // add hover effect
                .on('mouseover', function (e) {
                    const hoveredColor = out.hoverColor_

                    // Change the stroke color
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', hoveredColor)

                    // Update the marker-end dynamically
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId + 'mouseover'})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(link, out))
                })
                .on('mousemove', function (e) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    // Revert the stroke color
                    (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', `url(#${gradientIds[i]})`)

                    // Revert the marker-end to the original
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    /**
     * Adds rectangles to fill gaps left by Sankey links
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} nodes - Sankey nodes data
     */
    function addFillGaps(svg, nodes) {
        svg.append('g')
            .attr('class', 'em-flow-fill-in-gaps')
            .selectAll('rect')
            .data(nodes)
            .join('rect')
            .filter((d) => d.depth && d.height)
            .attr('x', (d) => d.x0 - 0.5)
            .attr('y', (d) => d.y0)
            .attr('width', 1)
            .attr('height', (d) => d.y1 - d.y0)
            .attr('fill', out.flowColor_)
    }

    /**
     * Add labels for data points.
     * @param {Object} svg - D3 selection of the SVG element.
     */
    function addLabels(svg, nodes) {
        // Filter the nodes
        const filteredNodes = nodes.filter((node) => node.targetLinks && node.sourceLinks.length === 0)
        const container = svg.append('g').attr('class', 'em-flow-labels')

        // Add halo effect
        if (out.labels_?.shadows) {
            const labelsShadowGroup = container.append('g').attr('class', 'em-flow-label-shadow')
            labelsShadowGroup
                .selectAll('text')
                .data(filteredNodes)
                .join('text')
                .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
                .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? d.x + out.labelOffsetX : d.x - out.labelOffsetX))
                .attr('y', (d) => d.y + out.labelOffsetY)
                .text((d) => out.labelFormatter(d.value))
        }

        // Add labels
        const labelsGroup = container.append('g').attr('class', 'em-flow-label')
        //add background
        // Add background rectangles and text
        const labelElements = labelsGroup
            .selectAll('g') // Use a group for each label to combine rect and text
            .data(filteredNodes)
            .join('g') // Append a group for each label
            .attr('transform', (d) => `translate(${d.x}, ${d.y})`) // Position group at the node

        // Add text first to calculate its size
        labelElements
            .append('text')
            .attr('class', 'em-label-text')
            .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
            .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? out.labelOffsetX : -out.labelOffsetX))
            .attr('y', out.labelOffsetY)
            .text((d) => out.labelFormatter(d.value))

        // Add background rectangles after text is rendered

        if (out.labels_.backgrounds) {
            labelElements.each(function () {
                const textElement = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).select('text')
                const bbox = textElement.node().getBBox() // Get bounding box of the text

                const paddingX = 5 // Horizontal padding
                const paddingY = 2 // Vertical padding

                // Add rectangle centered behind the text
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                    .insert('rect', 'text') // Insert rect before text in DOM
                    .attr('class', 'em-label-background')
                    .attr('x', bbox.x - paddingX)
                    .attr('y', bbox.y - paddingY)
                    .attr('width', bbox.width + 2 * paddingX)
                    .attr('height', bbox.height + 2 * paddingY)
            })
        }
    }

    // Function to append a rectangle behind the label
    function appendLabelRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    // From this point on all code is related with spatial sankey. Adopted from this notebook: https://observablehq.com/@bayre/deconstructed-sankey-diagram
    // See https://observablehq.com/@joewdavies/flow-map-of-europe
    function clone({ nodes, links }) {
        return { nodes: nodes.map((d) => Object.assign({}, d)), links: links.map((d) => Object.assign({}, d)) }
    }

    function sankey({ nodes, links }) {
        const graph = clone({ nodes, links })
        computeNodeLinks(graph)
        computeNodeValues(graph)
        computeNodeDepths(graph)
        computeNodeHeights(graph)
        computeNodeBreadths(graph)
        computeLinkBreadths(graph)
        return graph
    }

    function computeNodeLinks({ nodes, links }) {
        for (const [i, node] of nodes.entries()) {
            node.index = i
            node.sourceLinks = []
            node.targetLinks = []
        }
        const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]))
        for (const [i, link] of links.entries()) {
            link.index = i
            let { source, target } = link
            if (typeof source !== 'object') source = link.source = find(nodeById, source)
            if (typeof target !== 'object') target = link.target = find(nodeById, target)
            source.sourceLinks.push(link)
            target.targetLinks.push(link)
        }
        // if (linkSort != null) {
        //     for (const { sourceLinks, targetLinks } of nodes) {
        //         sourceLinks.sort(linkSort)
        //         targetLinks.sort(linkSort)
        //     }
        // }
    }

    function find(nodeById, id) {
        const node = nodeById.get(id)
        if (!node) throw new Error('missing: ' + id)
        return node
    }

    function computeNodeDepths({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.depth = x
                for (const { target } of node.sourceLinks) {
                    next.add(target)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    function computeNodeHeights({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.height = x
                for (const { source } of node.targetLinks) {
                    next.add(source)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    // vertically stacks links with the same origin. Causes issues on world maps
    // function computeLinkBreadths({ nodes }) {
    //     for (const node of nodes) {
    //         let y0 = node.y0;  // Initial y0 position
    //         let y1 = y0;
    //         for (const link of node.sourceLinks) {
    //             link.y0 = y0 + link.width / 2;  // Adjusting y0 dynamically
    //             y0 += link.width;  // Moving y0 down for the next link
    //         }
    //         for (const link of node.targetLinks) {
    //             link.y1 = y1 + link.width / 2;
    //             y1 += link.width;
    //         }
    //     }
    // }

    function computeLinkBreadths({ nodes }) {
        for (const node of nodes) {
            if (node.sourceLinks.length > 1) {
                // If multiple links originate from the same source, set them to the same y0
                const fixedY0 = node.y // Use the node's y position
                node.sourceLinks.forEach((link) => {
                    link.y0 = fixedY0 // Force all links to use the same y0
                })
            } else {
                // Default behavior for other nodes
                let y0 = node.y0
                let y1 = y0
                for (const link of node.sourceLinks) {
                    link.y0 = y0 + link.width / 2
                    y0 += link.width
                }
                for (const link of node.targetLinks) {
                    link.y1 = y1 + link.width / 2
                    y1 += link.width
                }
            }
        }
    }

    function horizontalSource(d) {
        return [d.source.x1, d.y0]
    }

    function horizontalTarget(d) {
        return [d.target.x0, d.y1]
    }

    function computeNodeValues({ nodes }) {
        for (const node of nodes) {
            node.value = Math.max(
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.sourceLinks, (d) => d.value),
                (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(node.targetLinks, (d) => d.value)
            )
        }
    }

    function reorderLinks(nodes) {
        for (const { sourceLinks, targetLinks } of nodes) {
            sourceLinks.sort(ascendingTargetY)
            targetLinks.sort(ascendingSourceY)
        }
    }

    const ascendingTargetY = (a, b) => a.target.y - b.target.y
    const ascendingSourceY = (a, b) => a.source.y - b.source.y

    function computeNodeBreadths({ nodes }) {
        for (const node of nodes) {
            const height = out.strokeWidthScale(node.value)
            node.x0 = node.x1 = node.x
            node.y0 = node.y - height / 2
            node.y1 = node.y0 + height
            for (const link of node.sourceLinks) {
                link.width = out.strokeWidthScale(link.value)
            }
        }
        reorderLinks(nodes)
    }

    const id = (d) => d.id // used in sankey import

    const sankeyLinkHorizontal = function () {
        return (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__.linkHorizontal)().source(horizontalSource).target(horizontalTarget)
    }

    return out
}

const flowMapTooltipFunction = function (link, map) {
    const buf = []

    // Header with region name and ID
    const title = `${link.source.id} > ${link.target.id}`
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${title}</b>
        </div>
    `)

    // Value
    buf.push(`<div class='estat-vis-tooltip-text'>
        ${link.target.value}
        </div>`)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-piecharts.js":
/*!***************************************!*\
  !*** ./src/maptypes/map-piecharts.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-piecharts */ "./src/legend/legend-piecharts.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");









/**
 * Returns a proportional pie chart map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'pie')

    // pie charts
    out.pieMinRadius_ = 5
    out.pieMaxRadius_ = 15
    out.pieChartInnerRadius_ = 0
    out.pieStrokeFill_ = 'white'
    out.pieStrokeWidth_ = 0.3

    //tooltip pie chart
    out.tooltipPieRadius_ = 40
    out.tooltipPieInnerRadius_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    // 'other' section of the pie chart for when 'out.totalCode_' is defined with statPie()
    out.pieOtherColor_ = '#FFCC80'
    out.pieOtherText_ = 'Other'

    //show piecharts only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    out.sizeClassifier_ = null //d3 scale for scaling pie sizes
    out.statPie_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieMaxRadius_',
        'pieMinRadius_',
        'pieChartInnerRadius_',
        'pieOtherColor_',
        'pieOtherText_',
        'pieStrokeFill_',
        'pieStrokeWidth_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieMaxRadius',
            'pieMinRadius',
            'pieChartInnerRadius',
            'pieOtherColor',
            'pieOtherText',
            'pieStrokeFill',
            'pieStrokeWidth',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /** The codes of the categories to consider for the composition. */
    out.statCodes_ = undefined
    /** The code of the "total" category in the eurostat database */
    out.totalCode__ = undefined

    /**
     * A function to define a pie chart map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension (defined in eurostat REST API) of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     * @param {string} tCode Optional: The category code of the total (used to calculate total & "other" values if codes array dont represent all possible categories)
     */
    out.statPie = function (stat, dim, codes, labels, colors, tCode) {
        //add one dataset (stat) config for each category (code)
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) {
                sc_[key] = stat[key]
            }
            sc_.filters = {}
            for (let key in stat.filters) {
                sc_.filters[key] = stat.filters[key]
            }
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set out.statCodes_
        out.statCodes_ = codes

        //set out.totalCode_
        if (tCode) {
            out.totalCode_ = tCode
            stat.filters[dim] = tCode
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(tCode, sc_)

            //when total code is used, an 'other' section is added to the pie
            out.catColors_['other'] = out.pieOtherColor_
            out.catLabels_['other'] = out.pieOtherText_
        }

        return out
    }

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //if not provided, get list of stat codes from the map stat data
        if (!out.statCodes_) {
            //get list of stat codes.
            out.statCodes_ = Object.keys(out.statData_)
            //remove "default", if present
            const index = out.statCodes_.indexOf('default')
            if (index > -1) out.statCodes_.splice(index, 1)
        }

        //define size scaling function
        let domain = getDatasetMaxMin()
        if (!isNaN(domain[0])) {
            out.sizeClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__.sqrt)().domain(domain).range([out.pieMinRadius_, out.pieMaxRadius_])
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors_) {
            out.catColors({})
            for (let i = 0; i < out.statCodes_.length; i++) out.catColors_[out.statCodes_[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_4__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of sharing regions with pies
        let regionFeatures = []
        if (out.svg_) {
            let s = out.svg_.selectAll('#em-prop-symbols')
            if (s) {
                let sym = s.selectAll('g.em-centroid')
                sym.append('g')
                    .attr('class', 'em-pie')
                    .attr('id', (rg) => {
                        regionFeatures.push(rg)
                        return 'pie_' + rg.properties.id
                    })

                // set region hover function
                const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
                let regions = out.svg().selectAll(selector)
                regions
                    .on('mouseover', function (e, rg) {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                        sel.style('fill', out.hoverColor_)
                        if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                    })
                    .on('mousemove', function (e, rg) {
                        if (out._tooltip) out._tooltip.mousemove(e)
                    })
                    .on('mouseout', function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                        let newFill = sel.attr('fill___')
                        if (newFill) {
                            sel.style('fill', sel.attr('fill___'))
                            if (out._tooltip) out._tooltip.mouseout()
                        }
                    })

                addPieChartsToMap(regionFeatures)
            }
        }
        return out
    }

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < out.statCodes_.length; i++) {
            //retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        // when out.totalCode_ is specified, use it as the sum instead of the sum of the specified categories.
        if (out.totalCode_) {
            let s = out.statData(out.totalCode_).get(id)
            if (s) {
                sum = s.value
            } else {
                sum == 0
            }
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < out.statCodes_.length; i++) {
            comp[out.statCodes_[i]] /= sum
        }

        //add "other" category when out.totalCode_ is used
        if (out.totalCode_) {
            let totalPerc = 0
            for (let key in comp) {
                totalPerc = totalPerc + comp[key]
            }
            comp['other'] = 1 - totalPerc
        }

        return comp
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum total of all dimensions combined for each region. Used to define the domain of the pie size scaling function.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        let totals = []
        let sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            let id = rg.properties.id
            let total = getRegionTotal(id)
            if (total) {
                totals.push(total)
            }
        })

        let minmax = (0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])(totals)
        return minmax
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionTotal = function (id) {
        let sum = 0
        let s
        if (out.totalCode_) {
            //when total is a stat code
            s = out.statData(out.totalCode_).get(id)
            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) {
                    sum = undefined
                }
            } else {
                sum = s.value
            }
        } else {
            //get stat value for each category. Compute the sum.
            for (let i = 0; i < out.statCodes_.length; i++) {
                //retrieve code and stat value
                const sc = out.statCodes_[i]
                s = out.statData(sc).get(id)
                //case when some data is missing
                if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                    if (out.showOnlyWhenComplete()) return undefined
                    else continue
                }
                sum += s.value
            }
        }

        //case when no data
        if (sum == 0) return undefined
        return sum
    }

    function addPieChartsToMap(regionFeatures) {
        regionFeatures.forEach((region) => {
            const regionId = region.properties.id
            //prepare data for pie chart
            const data = []
            const comp = getComposition(regionId)
            for (const key in comp) data.push({ code: key, value: comp[key] })

            //case of regions with no data
            if (!data || data.length == 0) {
                return
            }

            //create svg for pie chart
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let nodes = out.svg().selectAll('#pie_' + regionId)

            // define radius
            const r = out.sizeClassifier_(getRegionTotal(regionId))
            const ir = out.pieChartInnerRadius_

            //make pie chart. See https://observablehq.com/@d3/pie-chart
            const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
                .sort(null)
                .value((d) => d.value)
            nodes
                .append('g')
                .attr('stroke', out.pieStrokeFill_)
                .attr('stroke-width', out.pieStrokeWidth_ + 'px')
                .attr('class', 'piechart')
                .selectAll('path')
                .data(pie_(data))
                .join('path')
                .style('fill', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('fill___', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('code', (d) => d.data.code) //for mouseover legend highlighting function
                .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])().innerRadius(ir).outerRadius(r))
                .on('mouseover', function (e, rg) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    // Apply a thick stroke width to the parent element
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', '1px').style('stroke', 'black') // Set stroke
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(region, out))
                })
                .on('mousemove', function (e, rg) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this)
                    // Reset stroke
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', out.pieStrokeWidth_).style('stroke', out.pieStrokeFill_) // Set stroke
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        if (rg.properties.id) {
            //name and code
            tp.append('div')
                .attr('class', 'estat-vis-tooltip-bar')
                .html(rg.properties.na + ' (' + rg.properties.id + ')')
        } else {
            //region name
            tp.append('div').attr('class', 'estat-vis-tooltip-bar').html(rg.properties.na)
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        // set the dimensions and margins of the graph
        let width = 150
        let height = 150
        let margin = 25

        // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
        const radius = Math.min(width, height) / 2 - margin

        //width = tp.node().getBoundingClientRect().width
        const container = tp.append('div').attr('class', 'em-tooltip-piechart-container')
        const svg = container
            .append('svg')
            .attr('class', 'em-tooltip-piechart-svg')
            .attr('viewbox', `0, 0, ${width}, ${height}`)
            .attr('width', width)
            .attr('height', height - margin / 2)
            .append('g')
            .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
            .sort(null)
            .value((d) => d.value)

        const innerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(0) // This is the size of the donut hole
            .outerRadius(radius * 0.8)

        // Another arc that won't be drawn. Just for labels positioning
        const outerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(radius * 0.9)
            .outerRadius(radius * 0.9)

        const pieData = pie_(data)
        svg.selectAll('allSlices')
            .data(pieData)
            .enter()
            .append('path')
            .attr('d', innerArc)
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('stroke', 'white')
            .style('stroke-width', '1px')
            .style('opacity', 0.7)

        // Add the polylines between chart and labels:
        svg.selectAll('allPolylines')
            .data(pieData)
            .enter()
            .append('polyline')
            .attr('stroke', 'black')
            .style('fill', 'none')
            .attr('stroke-width', 1)
            .attr('points', function (d) {
                if (d.data.value > 0.02) {
                    const posA = innerArc.centroid(d) // line insertion in the slice
                    const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                    const posC = outerArc.centroid(d) // Label position = almost the same as posB
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                    posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1) // multiply by 1 or -1 to put it on the right or on the left
                    return [posA, posB, posC]
                }
            })

        // Add the labels:
        svg.selectAll('allLabels')
            .data(pieData)
            .enter()
            .append('text')
            .text(function (d) {
                if (d.data.value > 0.02) {
                    let n = (d.data.value * 100).toFixed()
                    if (!isNaN(n)) return n + '%'
                }
            })
            .attr('transform', function (d) {
                var pos = outerArc.centroid(d)
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1)
                return 'translate(' + pos + ')'
            })
            .style('text-anchor', function (d) {
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                return midangle < Math.PI ? 'start' : 'end'
            })
            .style('font-size', '12px')

        // add region values to tooltip
        let breakdownDiv = tp.append('div').attr('class', 'em-tooltip-piechart-breakdown')

        // show value for each category
        for (let i = 0; i < out.statCodes_.length; i++) {
            // retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(rg.properties.id)

            // check if s and s.value are valid (handle null, undefined, or 0)
            if (s && s.value !== undefined && s.value !== null) {
                let string = `<strong>${out.catLabels_[sc]}</strong>: ${s.value.toFixed()}<br>`
                breakdownDiv.html(breakdownDiv.html() + string) // safely update the HTML
            }
        }

        // write total (handle null, undefined, or 0 values for total)
        let total = getRegionTotal(rg.properties.id)
        if (total !== undefined && total !== null) {
            breakdownDiv.html(breakdownDiv.html() + `<strong>Total</strong>: ${total.toFixed()}<br>`)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-proportional-symbols.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-proportional-symbols.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   symbolsLibrary: () => (/* binding */ symbolsLibrary)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-proportional-symbols */ "./src/legend/legend-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");

// import {extent} from 'd3-array'








/**
 * Returns a proportional symbol map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'ps')

    //shape
    out.psShape_ = 'circle' // accepted values: circle, bar, square, star, diamond, wye, cross
    out.psCustomShape_ // see http://using-d3js.com/05_10_symbols.html#h_66iIQ5sJIT
    out.psCustomSVG_ // see http://bl.ocks.org/jessihamel/9648495
    out.psSpikeWidth_ = 7 // 'spike' shape widths
    out.psOffset_ = { x: 0, y: 0 }

    //size
    out.psMaxSize_ = 30 // max symbol size
    out.psMinSize_ = 5 // min symbol size
    out.psBarWidth_ = 10 //for vertical bars
    out.psMaxValue_ = undefined // allow the user to manually define the domain of the sizing scale. E.g. if the user wants to use the same scale across different maps.
    out.psMinValue_ = undefined
    out.psSizeScale_ = undefined // 'sqrt' or 'linear'

    //colour
    out.psFill_ = '#2d50a0' //same fill for all symbols when no visual variable (setData()) for 'color' is specified
    out.psFillOpacity_ = 1
    out.psStroke_ = '#ffffff'
    out.psStrokeWidth_ = 0.2
    out.psClasses_ = 5 // number of classes to use for colouring
    out.psColors_ = null //colours to use for threshold colouring
    out.psColorFun_ = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"]
    out.psClassToFillStyle_ = undefined //a function returning the color from the class i

    //the threshold, when the classification method is 'threshold'
    out.psThreshold_ = [0]
    //the classification method
    out.psClassificationMethod_ = 'quantile' // or: equinter, threshold
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //
    //the classifier: a function which return the symbol size/color from the stat value.
    out.classifierSize_ = undefined
    out.classifierColor_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunPs

    //dorling cartogram
    out.dorling_ = false
    out.dorlingStrength_ = { x: 1, y: 1 }
    out.dorlingIterations_ = 1
    out.psCodeLabels_ = false // show country codes in symbols

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'psMaxSize_',
        'psMinSize_',
        'psMaxValue_',
        'psMinValue_',
        'psFill_',
        'psFillOpacity_',
        'psStroke_',
        'psStrokeWidth_',
        'classifierSize_',
        'classifierColor_',
        'psShape_',
        'psCustomShape_',
        'psBarWidth_',
        'psClassToFillStyle_',
        'psColorFun_',
        'psSizeScale_',
        'noDataFillStyle_',
        'psThreshold_',
        'psColors_',
        'psCustomSVG_',
        'psOffset_',
        'psClassificationMethod_',
        'psClasses_',
        'dorling_',
        'dorlingStrength_',
        'psSpikeWidth_',
        'psCodeLabels_',
        'dorlingIterations_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'psMaxSize',
            'psMinSize',
            'psFill',
            'psFillOpacity',
            'psStroke',
            'psStrokeWidth',
            'classifierSize',
            'classifierColor',
            'psShape',
            'psCustomShape',
            'psBarWidth',
            'psClassToFillStyle',
            'psColorFun',
            'noDataFillStyle',
            'psThreshold',
            'psColors',
            'psCustomSVG',
            'psOffset',
            'psClassificationMethod',
            'psClasses',
            'dorlingIterations_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //override of some special getters/setters
    out.psColorFun = function (v) {
        if (!arguments.length) return out.psColorFun_
        out.psColorFun_ = v
        out.psClassToFillStyle_ = getColorLegend(out.psColorFun_, out.psColors_)
        return out
    }
    out.psThreshold = function (v) {
        if (!arguments.length) return out.psThreshold_
        out.psThreshold_ = v
        out.psClasses(v.length + 1)
        return out
    }

    //@override
    out.updateClassification = function () {
        //define classifiers for sizing and colouring (out.classifierSize_ & out.classifierColor_)
        defineClassifiers()

        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    /**
     * @description assigns a color to each symbol, based on their statistical value
     * @param {*} map
     */
    function applyClassificationToMap(map) {
        if (map.svg_) {
            if (out.classifierColor_) {
                //assign color class to each symbol, based on their value
                // at this point, the symbol path hasnt been appended. Only the parent g.em-centroid element (in map-template)
                let colorData = map.statData('color')
                map.svg_.selectAll('.em-centroid').attr('ecl', function (rg) {
                    const sv = colorData.get(rg.properties.id)
                    if (!sv) {
                        return 'nd'
                    }
                    const v = sv.value
                    if (v !== 0 && !v) {
                        return 'nd'
                    }
                    let c = +out.classifierColor_(+v)
                    return c
                })
            }
        }
    }

    /**
     * @description defines classifier functions (out.classifierColor and out.classifierSize) for both symbol size and color
     */
    function defineClassifiers() {
        // set default scale
        if (!out.psSizeScale_) {
            if (out.psShape_ == 'spike') {
                out.psSizeScale_ = 'linear'
            } else {
                out.psSizeScale_ = 'sqrt'
            }
        }

        //simply return the array [0,1,2,3,...,nb-1]
        const getA = function (nb) {
            return [...Array(nb).keys()]
        }

        // use size dataset
        let sizeDomain
        let data = out.statData('size').getArray()
        // let domain = extent(data)
        let min = out.psMinValue_ ? out.psMinValue_ : out.statData('size').getMin()
        let max = out.psMaxValue_ ? out.psMaxValue_ : out.statData('size').getMax()

        sizeDomain = data ? [min, max] : [out.statData().getMin(), out.statData().getMax()]

        let scale = out.psSizeScale_ == 'sqrt' ? d3_scale__WEBPACK_IMPORTED_MODULE_4__.sqrt : d3_scale__WEBPACK_IMPORTED_MODULE_5__["default"]
        out.classifierSize(scale().domain(sizeDomain).range([out.psMinSize_, out.psMaxSize_]))

        // colour
        if (out.statData('color').getArray()) {
            //use suitable classification type for colouring
            if (out.psClassificationMethod_ === 'quantile') {
                //https://github.com/d3/d3-scale#quantile-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])().domain(domain).range(range))
            } else if (out.psClassificationMethod_ === 'equinter') {
                //https://github.com/d3/d3-scale#quantize-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor(
                    (0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])()
                        .domain([min(domain), max(domain)])
                        .range(range)
                )
                if (out.makeClassifNice_) out.classifierColor().nice()
            } else if (out.psClassificationMethod_ === 'threshold') {
                //https://github.com/d3/d3-scale#threshold-scales
                out.psClasses(out.psThreshold().length + 1)
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])().domain(out.psThreshold()).range(range))
            }
        }
    }

    /**
     * Applies proportional symbol styling to a map object
     *
     * @param {*} map
     * @returns
     */
    function applyStyleToMap(map) {
        //see https://bl.ocks.org/mbostock/4342045 and https://bost.ocks.org/mike/bubble-map/
        //define style per class
        if (!out.psClassToFillStyle()) out.psClassToFillStyle(getColorLegend(out.psColorFun_, out.psColors_))

        // if size dataset not defined then use default
        let sizeData = map.statData('size').getArray() ? map.statData('size') : map.statData()

        if (map.svg_) {
            //clear previous symbols
            let prevSymbols = map.svg_.selectAll(':not(#em-insets-group) g.em-centroid > *')
            prevSymbols.remove()

            //change draw order according to size, then reclassify (there was an issue with nodes changing ecl attributes)
            if (map.Geometries.centroidFeatures) {
                updateSymbolsDrawOrder(map)
                applyClassificationToMap(map)
            }

            // append symbols
            let symb
            if (out.psCustomSVG_) {
                symb = appendCustomSymbolsToMap(map, sizeData)
            } else if (out.psShape_ == 'bar') {
                symb = appendBarsToMap(map, sizeData)
            } else if (out.psShape_ == 'circle') {
                symb = appendCirclesToMap(map, sizeData)
            } else if (out.psShape_ == 'spike') {
                symb = appendSpikesToMap(map, sizeData)
            } else {
                // circle, cross, star, triangle, diamond, square, wye or custom
                symb = appendD3SymbolsToMap(map, sizeData)
            }

            // dorling cartogram
            if (out.dorling_) {
                applyDorlingForce(map, sizeData)
            } else {
                if (out.simulation) stopSimulation()
            }

            appendLabelsToSymbols(map, sizeData)

            // set style of symbols
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)

            if (map.geo_ !== 'WORLD') {
                if (map.nutsLevel_ == 'mixed') {
                    addSymbolsToMixedNUTS(map, sizeData, regions)
                }

                // nuts regions fill colour only for those with sizeData
                // regions.style('fill', function (rg) {
                //     if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                //     const sv = sizeData.get(rg.properties.id)
                //     if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                //         // NO INPUT
                //         return out.noDataFillStyle_
                //     } else if ((sv && sv.value) || (sv && sv.value == 0)) {
                //         if (sv.value == ':') {
                //             // DATA NOT AVAILABLE
                //             return out.noDataFillStyle_
                //         }
                //         // DATA
                //         return getCSSPropertyFromClass('em-nutsrg', 'fill')
                //     }
                // })

                // apply 'nd' class to no data for legend item hover
                regions.attr('ecl', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                        // NO INPUT
                        return 'nd'
                    } else if ((sv && sv.value) || (sv && sv.value == 0)) {
                        if (sv.value == ':') {
                            // DATA NOT AVAILABLE
                            return 'nd'
                        }
                    }
                })
            } else {
                // world countries fill only those with data
                // regions.style('fill', function (rg) {
                //     const sv = sizeData.get(rg.properties.id)
                //     if (!sv || (!sv.value && sv !== 0 && sv.value !== 0) || sv.value == ':') {
                //         return out.worldFillStyle_
                //     } else {
                //         return getCSSPropertyFromClass('em-nutsrg', 'fill')
                //     }
                // })
            }

            // set color/stroke/opacity styles
            setSymbolStyles(symb)

            addMouseEvents(map)

            // Update labels for statistical values if required
            if (out.labels_?.values) {
                out.updateValuesLabels(map)
            }
        }
        return map
    }

    const appendLabelsToSymbols = function (map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')
        //country code labels
        if (out.psCodeLabels_) {
            const countryCodeLabel = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-code-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value === ':' ? '' : d.properties.id // Hide text if value is ':'
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    // size adjustment factor depends on symbol type, and whether stat values are also added to the circles
                    let factor = out.labels_?.values && sizeData.get(d.properties.id)?.value ? 0.8 : 0.9
                    if (out.psShape_ === 'square') factor = factor - 0.4
                    return `${radius * factor}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.labels_?.values && sizeData.get(d.properties.id)?.value ? '-0.3em' : '0'))
        }

        //stat labels
        if (out.labels_?.values) {
            const statLabels = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-stat-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    if (datum?.value) return datum.value
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    return `${radius * 0.4}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.psCodeLabels_ ? '0.6em' : '0'))
        }
    }

    const addMouseEvents = function (map) {
        let symbols = map.svg().selectAll('g.em-centroid')
        symbols
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_9__["default"])(this.childNodes[0])
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_9__["default"])(this.childNodes[0])
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', newFill)
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    /**
     * @description sets color/stroke/opacity styles of all symbols
     * @param {d3.selection} symb symbols d3 selection
     */
    function setSymbolStyles(symb) {
        symb.style('fill-opacity', out.psFillOpacity())
            .style('stroke', out.psStroke())
            .style('stroke-width', out.psStrokeWidth())
            .style('fill', function () {
                if (out.classifierColor_) {
                    //for ps, ecl attribute belongs to the parent g.em-centroid node created in map-template
                    const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_9__["default"])(this.parentNode).attr('ecl')
                    if (!ecl || ecl === 'nd') return out.noDataFillStyle_ || 'gray'
                    let color = out.psClassToFillStyle_(ecl, out.psClasses_)
                    return color
                } else {
                    return out.psFill_
                }
            })
            .attr('fill___', function () {
                let fill = (0,d3_selection__WEBPACK_IMPORTED_MODULE_9__["default"])(this).style('fill')
                return fill // save for legend mouseover
            })
    }

    /**
     * @description Updates the draw order of the symbols according to their data values
     * @param {*} map map instance
     */
    function updateSymbolsDrawOrder(map) {
        let zoomGroup = map.svg_ ? map.svg_.select('#zoomgroup' + map.svgId_) : null
        const gcp = zoomGroup.select('#em-prop-symbols')
        let sizeData = map.statData('size').getArray() ? map.statData('size') : map.statData()

        map.Geometries.centroidFeatures.sort(function (a, b) {
            // A negative value indicates that a should come before b.
            // A positive value indicates that a should come after b.
            // Zero or NaN indicates that a and b are considered equal.
            let valA = sizeData.get(a.properties.id)
            let valB = sizeData.get(b.properties.id)

            if (valA || valA?.value == 0 || valB || valB?.value == 0) {
                if ((valA || valA?.value == 0) && (valB || valB?.value == 0)) {
                    // Both values exist
                    // Biggest circles at the bottom
                    return valB.value - valA.value
                } else if ((valA || valA?.value == 0) && (!valB || !valB?.value == 0)) {
                    // Only valA exists
                    return -1
                } else if ((valB || valB?.value == 0) && (!valA || !valA?.value == 0)) {
                    // Only valB exists
                    return 1
                }
            } else {
                return 0
            }
        })

        let centroids = gcp
            .selectAll('g.em-centroid')
            .data(map.Geometries.centroidFeatures)
            .join('g')
            .attr('transform', function (d) {
                return 'translate(' + d.properties.centroid[0].toFixed(3) + ',' + d.properties.centroid[1].toFixed(3) + ')'
            })

        // update colors
        //setSymbolStyles(symbols)
    }

    function appendSpikesToMap(map, sizeData) {
        //The spike function creates a triangular path of the given length (height) with a base width of 7 pixels.
        const spike = (length, width = out.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        // Append circles to each symbol container
        const spikes = symbolContainers
            .append('path')
            .attr('d', (d) => {
                const datum = sizeData.get(d.properties.id)
                const value = datum ? out.classifierSize_(datum.value) : 0
                let path = spike(value)
                return path
            })
            .style('fill', (d) => d.color || 'steelblue') // Adjust color as needed
            //.attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)

        return spikes
    }

    /**
     * @description Appends <circle> elements for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData statistical data for size e.g. map.statData('size')
     * @return {void}
     */
    function appendCirclesToMap(map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        // Append circles to each symbol container
        const circles = symbolContainers
            .append('circle')
            .attr('r', function (d) {
                // calculate radius
                const datum = sizeData.get(d.properties.id)
                const radius = datum ? out.classifierSize_(datum.value) : 0
                return radius
            })
            .style('fill', (d) => d.color || 'steelblue') // Adjust color as needed

        return circles
    }

    function applyDorlingForce(map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        if (out.simulation) {
            stopSimulation()
        }

        // Initialize the force simulation
        console.log('new dorling simulation')
        out.simulation = (0,d3_force__WEBPACK_IMPORTED_MODULE_10__["default"])(map.Geometries.centroidFeatures)
            .force(
                'x',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_11__["default"])((d) => d.properties.centroid[0]).strength(out.dorlingStrength_.x) // Stronger pull to original x
            )
            .force(
                'y',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_12__["default"])((d) => d.properties.centroid[1]).strength(out.dorlingStrength_.y) // Stronger pull to original y
            )
            .force(
                'collide',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_13__["default"])((d) => {
                    const datum = sizeData.get(d.properties.id)
                    let size = datum ? out.classifierSize_(datum.value) : 0

                    if (out.psShape_ === 'square') {
                        return (size / 2) * Math.SQRT2 // Adjust for diagonal size
                    }

                    return size // Default for circles
                }).iterations(out.dorlingIterations_) // More iterations to improve collision handling
            )
            //.alphaTarget(0.3) // Helps keep centroids anchored
            .on('tick', () => {
                // Update elements with the new positions and radii
                symbolContainers.attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')')
            })

        //out.simulation.alpha(1).restart() // Ensures simulation starts with full strength
    }

    function stopSimulation() {
        out.simulation.stop() // Stops the internal tick loop
        out.simulation.on('tick', null) // Remove tick event listener
        out.simulation.on('end', null) // Remove end event listener
        out.simulation = null // Remove reference
    }

    /**
     * @description Appends <path> elements containing symbols for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendD3SymbolsToMap(map, sizeData) {
        return map
            .svg()
            .selectAll('g.em-centroid')
            .append('path')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .attr('d', (rg) => {
                //calculate size
                if (!sizeData) return
                const sv = sizeData.get(rg.properties.id)
                if (sv != 0 && !sv) return
                let size = out.classifierSize_(+sv.value) || 0

                //apply size to shape
                if (out.psCustomShape_) {
                    return out.psCustomShape_.size(size * size)()
                } else {
                    const symbolType = symbolsLibrary[out.psShape_] || symbolsLibrary['circle']
                    return (0,d3_shape__WEBPACK_IMPORTED_MODULE_14__["default"])()
                        .type(symbolType)
                        .size(size * size)()
                }
            })
    }

    /**
     * @description Appends <rect> elements containing bars for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendBarsToMap(map, sizeData) {
        return (
            map
                .svg()
                .select('#em-prop-symbols')
                .selectAll('g.em-centroid')
                .append('rect')
                .filter((rg) => {
                    const sv = sizeData.get(rg.properties.id)
                    if (sv && sv.value !== ':') return rg
                })
                .attr('width', out.psBarWidth_)
                //for vertical bars we scale the height attribute using the classifier
                .attr('height', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || !sv.value) {
                        return 0
                    }
                    let v = out.classifierSize_(+sv.value)
                    return v
                })
                .attr('transform', function () {
                    let bRect = this.getBoundingClientRect()
                    return `translate(${-this.getAttribute('width') / 2}` + `, -${this.getAttribute('height')})`
                })
            // to use transitions we need to refactor the drawing functions to promises e.g. appendBarsToMap().then(()=>{})
            //this is because .attr('fill___', function () {select(this).style('fill')}) doesnt work unless you execute it after the transition ends.
            // e.g.
            // .transition()
            // .duration(out.transitionDuration())
            // .style('fill', function (rg) {})
            // .end()
            // .then()
        )
    }

    /**
     * @description Appends custom SVG symbols for each region in the map
     * @param {*} map
     * @param {*} sizeData
     * @return {*}
     */
    function appendCustomSymbolsToMap(map, sizeData) {
        return map
            .svg()
            .select('#em-prop-symbols')
            .selectAll('g.em-centroid')
            .append('g')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .html(out.psCustomSVG_)
            .attr('transform', (rg) => {
                //calculate size
                const sv = sizeData.get(rg.properties.id)
                let size = out.classifierSize_(+sv.value)
                if (size) {
                    return `translate(${out.psOffset_.x * size},${out.psOffset_.y * size}) scale(${size})`
                }
            })
    }

    /**
     * @description adds proportional symbols to each regions in a map with mixed NUTS levels (IMAGE)
     * @param {*} map
     * @param {*} sizeData
     * @param {*} regions
     * @return {*}
     */
    function addSymbolsToMixedNUTS(map, sizeData, regions) {
        // Toggle symbol visibility - only show regions with sizeData stat values when mixing different NUTS levels
        let symb = map
            .svg()
            .selectAll('g.em-centroid')
            .style('display', function (rg) {
                const sv = sizeData.get(rg.properties.id)
                if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                    // no symbol for no input
                    return 'none'
                } else if (map.geo_ == 'WORLD') {
                    return 'block'
                }
            })

        // toggle display of mixed NUTS levels
        regions.style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sv = sizeData.get(rg.properties.id)
            if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                // no symbol for no data
                return 'none'
            } else if (map.geo_ == 'WORLD') {
                return 'block'
            }
        })

        // nuts border stroke
        regions
            .style('stroke', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_9__["default"])(this)
                const lvl = sel.attr('lvl')
                const stroke = sel.style('stroke')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else {
                    if (lvl !== '0') {
                        return stroke || '#777'
                    }
                }
            })

            // nuts border stroke width
            .style('stroke-width', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_9__["default"])(this)
                const lvl = sel.attr('lvl')
                const strokeWidth = sel.style('stroke-width')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else if (out.geo_ == 'WORLD') {
                    if (lvl !== '0') {
                        return strokeWidth || '#777'
                    }
                }
            })

        return symb
    }

    //@override
    out.updateStyle = function () {
        // apply to main map
        applyStyleToMap(out)

        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            for (const geo in out.insetTemplates_) {
                if (Array.isArray(out.insetTemplates_[geo])) {
                    for (var i = 0; i < out.insetTemplates_[geo].length; i++) {
                        // insets with same geo that do not share the same parent inset
                        if (Array.isArray(out.insetTemplates_[geo][i])) {
                            // this is the case when there are more than 2 different insets with the same geo. E.g. 3 insets for PT20
                            for (var c = 0; c < out.insetTemplates_[geo][i].length; c++) {
                                if (out.insetTemplates_[geo][i][c].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i][c])
                            }
                        } else {
                            if (out.insetTemplates_[geo][i].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i])
                        }
                    }
                } else {
                    // unique inset geo_
                    if (out.insetTemplates_[geo].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo])
                }
            }
        }

        return out
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun, colorArray) {
    colorFun = colorFun || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}

/**
 * @description give a d3 symbol from a shape name
 */
const symbolsLibrary = {
    cross: d3_shape__WEBPACK_IMPORTED_MODULE_15__["default"],
    square: d3_shape__WEBPACK_IMPORTED_MODULE_16__["default"],
    diamond: d3_shape__WEBPACK_IMPORTED_MODULE_17__["default"],
    triangle: d3_shape__WEBPACK_IMPORTED_MODULE_18__["default"],
    star: d3_shape__WEBPACK_IMPORTED_MODULE_19__["default"],
    wye: d3_shape__WEBPACK_IMPORTED_MODULE_20__["default"],
    circle: d3_shape__WEBPACK_IMPORTED_MODULE_21__["default"],
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunPs = function (region, map) {
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    //stat 1 value
    const v1 = map.statData('size').getArray() ? map.statData('size') : map.statData()
    const sv1 = v1.get(region.properties.id)
    if (!sv1 || (sv1.value != 0 && !sv1.value)) buf.push(map.noDataText_)
    else {
        //unit 1
        const unit1 = v1.unitText()
        buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value)} ${unit1 ? unit1 : ' '}</div>`)
    }

    //stat 2 value
    if (map.statData('color').getArray()) {
        const sv2 = map.statData('color').get(region.properties.id)
        if (!sv2 || (sv2.value != 0 && !sv2.value)) buf.push(map.noDataText_)
        else {
            //stat 2
            const unit2 = map.statData('color').unitText()
            buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value)} ${unit2 ? unit2 : ' '}</div>`)
        }
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-sparklines.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-sparklines.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/create.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");










/**
 * Returns a sparkline map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, true, 'spark')

    out.sparkLineColor_ = 'black'
    out.sparkAreaColor_ = '#41afaa'
    out.sparkLineWidth_ = 30
    out.sparkLineHeight_ = 20
    out.sparkLineStrokeWidth_ = 0.4
    out.sparkLineOpacity_ = 0.6
    out.sparkType_ = 'line'
    out.sparkLineCircleRadius_ = 0
    out.sparkTooltipChart_ = {
        width: 100,
        height: 50,
        margin: { left: 60, right: 40, top: 40, bottom: 40 },
        circleRadius: 1.5,
    }

    //show sparklines only when data for all dates is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false
    out.sparkPercentageChange_ = false // show percentage change instead of raw counts

    out.statSpark_ = null
    out.sparkHeightClassifier_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'sparkLineColor_',
        'showOnlyWhenComplete_',
        'sparkType_',
        'sparkLineWidth_',
        'sparkLineHeight_',
        'sparkLineStrokeWidth_',
        'sparkLineOpacity_',
        'sparkLineCircleRadius_',
        'sparkLineAreaColor_',
        'sparkTooltipChart_',
        'sparkPercentageChange_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'sparkLineColor',
            'showOnlyWhenComplete',
            'sparkType',
            'sparkLineWidth',
            'sparkLineHeight',
            'sparkLineStrokeWidth',
            'sparkLineOpacity',
            'sparkLineCircleRadius_',
            'sparkLineAreaColor',
            'sparkTooltipChart_',
            'sparkPercentageChange_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /**
     * A function to define a sparkline map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {Array} dates The dates of the composition (time parameter)
     * @param {Array} labels Optional: The labels for the dates
     */
    out.statSpark = function (stat, dates, labels) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < dates.length; i++) {
            //category code
            const date = dates[i]
            stat.filters.time = date
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(date, sc_)

            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[date] = labels[i]
            }
        }

        //set statCodes
        out._statDates = dates

        return out
    }

    /** The codes of the categories to consider for the composition. */
    out._statDates = undefined

    /**
     * Function to compute composition for region id, for each date.
     * Return an object with, for each date, its statistical value for the region
     * @param {*} id
     * @returns [{date,value}]
     */
    const getComposition = function (id) {
        let comp = [],
            sum = 0

        // Get stat value for each category and compute the sum.
        for (let i = 0; i < out._statDates.length; i++) {
            // Retrieve code and stat value
            const date = out._statDates[i]
            const s = out.statData(date).get(id)

            // Case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp.push({ date: date, value: s.value })
            sum += s.value
        }

        // Case when no data
        if (sum == 0) return undefined

        // Calculate year-on-year percentage change
        for (let i = 1; i < comp.length; i++) {
            const previousValue = comp[i - 1].value
            const currentValue = comp[i].value

            // Calculate percentage change from previous value
            comp[i].percentageChange = previousValue === 0 ? 0.001 : ((currentValue - previousValue) / previousValue) * 100
        }

        // The first data point doesn't have a previous value to compare with
        //comp[0].percentageChange = 0.001 // or you can leave it undefined or null, depending on how you want to handle it

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!out._statDates) {
            //get list of stat codes.
            out._statDates = Object.keys(out.statData_)
            //remove "default", if present
            const index = out._statDates.indexOf('default')
            if (index > -1) out._statDates.splice(index, 1)
        }

        // define size scaling function
        // Define the domain correctly for the log scale
        out.domain = out.sparkPercentageChange_ ? [1e-3, 10] : getDatasetMaxMin() // Avoid 0 for log scale

        // for area charts
        out.widthClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__.sqrt)().domain(out.domain).range([0, out.sparkLineWidth_])
        out.heightClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_3__.sqrt)().domain(out.domain).range([0, out.sparkLineHeight_])

        return out
    }

    //@override
    out.updateStyle = function () {
        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of getting IDs
        let nutsIds = []
        let s = out.svg().selectAll('#em-prop-symbols')
        let sym = s.selectAll('g.em-centroid').attr('id', (rg) => {
            nutsIds.push(rg.properties.id)
            return 'spark_' + rg.properties.id
        })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                    sel.attr('fill___', sel.style('fill'))
                    sel.style('fill', out.hoverColor_)
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                }
            })
            .on('mousemove', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                }
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        addSparkLinesToMap(nutsIds)
        return out
    }

    function addSparkLinesToMap(ids) {
        ids.forEach((nutsid) => {
            //create svg for sparkline
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let node = out.svg().select('#spark_' + nutsid)
            let data = getComposition(nutsid)

            if (data) {
                createSparkLineChart(node, data, out.sparkLineWidth_, out.sparkLineHeight_)
            }
        })
    }

    function createSparkLineChart(node, data, w, h, isForTooltip = false) {
        // Get the extent of the whole dataset
        let ext = out.domain
        let height = out.sparkType_ === 'area' ? out.widthClassifier_(ext[1]) : h
        let width = out.sparkType_ === 'area' ? out.heightClassifier_(ext[1]) : w

        let scaledData

        // Define X scale
        let xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__["default"])()
            .domain([out._statDates[0], out._statDates[out._statDates.length - 1]])
            .range([0.5, width - 0.5])

        // Precompute the scaled values for the data points
        if (out.sparkPercentageChange_) {
            const sanitizeLogValue = (value) => {
                if (value === 0) return 0.001 // Avoid zero
                return value
            }

            const centerPosition = height / 2

            // Separate positive and negative values for scaling
            const positiveData = data.filter((d) => d.percentageChange > 0).map((d) => sanitizeLogValue(d.percentageChange))
            const negativeData = data.filter((d) => d.percentageChange < 0).map((d) => sanitizeLogValue(d.percentageChange))

            // Handling positive values using a positive log scale
            const maxPositive = (0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])(positiveData) || 1
            const minPositive = 0.0001
            const minNegative = (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(negativeData) || -1

            const scaleLogPositive = (0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])()
                .domain([minPositive, maxPositive]) // For positive values
                .range([height / 2, 0]) // Positive values above center

            const scaleLogNegative = (0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])()
                .domain([-0.01, minNegative]) // For negative values
                .range([height / 2, height]) // Negative values below center

            if (!positiveData.length || !negativeData.length) {
                console.log('no data')
            }

            // Precompute scaled Y data
            scaledData = data.map((d) => {
                d.scaledYValue =
                    d.percentageChange < 0
                        ? scaleLogNegative(sanitizeLogValue(d.percentageChange))
                        : scaleLogPositive(sanitizeLogValue(d.percentageChange))

                d.scaledXValue = xScale(d.date)

                if (isNaN(d.scaledYValue)) {
                    console.error('NaN detected in scaledValue:', d)
                    d.scaledYValue = 0.01
                }
                return d
            })

            // Draw the axis
            if (isForTooltip) {
                // Add the X Axis
                node.append('g')
                    .attr('class', 'axis')
                    .attr('transform', 'translate(0,' + height + ')')
                    .call((0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisBottom)(xScale).ticks(out._statDates.length).tickFormat((0,d3_format__WEBPACK_IMPORTED_MODULE_10__.format)('.0f')))
                    .selectAll('text')
                    .style('text-anchor', 'end')
                    .attr('dx', '-.8em')
                    .attr('dy', '.15em')
                    .attr('transform', 'rotate(-65)')

                // Add the Y Axis for positive values
                const positiveTickValuesY = [1]
                const negativeTickValuesY = [-0.5]
                node.append('g')
                    .attr('class', 'y-axis-negative')
                    .attr('transform', `translate(-10, ${0})`) // Position for negative axis
                    .call((0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisLeft)(scaleLogNegative).tickValues(negativeTickValuesY).tickFormat((0,d3_format__WEBPACK_IMPORTED_MODULE_10__.format)(',.2r')))

                node.append('g')
                    .attr('class', 'y-axis-positive')
                    .attr('transform', `translate(${-10}, 0)`)
                    .call((0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisLeft)(scaleLogPositive).tickValues(positiveTickValuesY).tickFormat((0,d3_format__WEBPACK_IMPORTED_MODULE_10__.format)(',.2r')))
                    // Manually add a custom label for 0
                    .append('g')
                    .attr('class', 'tick')
                    .attr('transform', `translate(0, ${height / 2})`)
                    .append('text')
                    .attr('fill', 'currentColor')
                    .attr('x', -12)
                    .style('text-anchor', 'middle')
                    .text('0') // Custom label for small value (0.10)

                console.log(positiveTickValuesY, negativeTickValuesY)
            }
        } else {
            // Raw counts (linear scale for both positive and negative)

            const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__["default"])()
                .domain(ext)
                .range([height - 0.5, 0])

            scaledData = data.map((d) => {
                d.scaledXValue = xScale(d.date)
                d.scaledYValue = yScale(d.value)
                return d
            })

            //Draw axis
            if (isForTooltip) {
                // Add the X Axis
                node.append('g')
                    .attr('class', 'axis')
                    .attr('transform', 'translate(0,' + height + ')')
                    .call((0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisBottom)(xScale).ticks(out._statDates.length).tickFormat((0,d3_format__WEBPACK_IMPORTED_MODULE_10__.format)('.0f')))
                    .selectAll('text')
                    .style('text-anchor', 'end')
                    .attr('dx', '-.8em')
                    .attr('dy', '.15em')
                    .attr('transform', 'rotate(-65)')

                // Add the Y Axis
                let domainY = yScale.domain()
                let tickValues = [domainY[0], ((domainY[0] + domainY[1]) / 2).toFixed(1), domainY[1]]
                node.append('g')
                    .attr('class', 'axis')
                    .call((0,d3_axis__WEBPACK_IMPORTED_MODULE_9__.axisLeft)(yScale).tickValues(tickValues).tickFormat((0,d3_format__WEBPACK_IMPORTED_MODULE_10__.format)(',.2r')))
            }
        }

        const lineGenerator = (0,d3_shape__WEBPACK_IMPORTED_MODULE_11__["default"])()
            .x((d, i) => d.scaledXValue)
            .y((d) => d.scaledYValue)

        // Draw the area (for area chart)
        if (out.sparkType_ === 'area') {
            node.append('path')
                .datum(data)
                .attr('fill', typeof out.sparkAreaColor_ === 'function' ? (d, i) => out.sparkAreaColor_(d, i) : out.sparkAreaColor_)
                .attr('stroke', typeof out.sparkLineColor_ === 'function' ? (d, i) => out.sparkLineColor_(d, i) : out.sparkLineColor_)
                .attr(
                    'stroke-width',
                    typeof out.sparkLineStrokeWidth_ === 'function' ? (d, i) => out.sparkLineStrokeWidth_(d, i) : out.sparkLineStrokeWidth_ + 'px'
                )
                .attr('opacity', out.sparkLineOpacity_)
                .attr('fill-opacity', 0.3)
                .attr('stroke', 'none')
                .attr(
                    'd',
                    (0,d3_shape__WEBPACK_IMPORTED_MODULE_12__["default"])()
                        .x((d, i) => d.scaledXValue)
                        .y0(height) // Baseline
                        .y1((d) => d.scaledYValue)
                )
                .attr('transform', (d) => `translate(0,-${height / 2})`)
        }

        // Draw the line
        node.append('path')
            .datum(scaledData)
            .style('fill', 'none')
            .attr('opacity', out.sparkLineOpacity_)
            .attr('stroke', typeof out.sparkLineColor_ === 'function' ? (d, i) => out.sparkLineColor_(d, i) : out.sparkLineColor_)
            .attr(
                'stroke-width',
                typeof out.sparkLineStrokeWidth_ === 'function' ? (d, i) => out.sparkLineStrokeWidth_(d, i) : out.sparkLineStrokeWidth_ + 'px'
            )
            .attr('d', lineGenerator)
            .attr('transform', (d) => (isForTooltip ? null : `translate(0,${out.sparkPercentageChange_ ? -d[0].scaledYValue : -d[0].scaledYValue})`)) //origin of line is first data point location

        // Add the dots
        node.selectAll('myCircles')
            .data(data)
            .enter()
            .append('circle')
            .style('fill', 'red')
            .attr('stroke', 'none')
            .attr('cx', (d, i) => d.scaledXValue)
            .attr('cy', (d) => d.scaledYValue)
            .attr('r', out.sparkLineCircleRadius_)
            .attr('transform', (d) => (isForTooltip ? null : `translate(0,-${height / 2})`))
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum values of all dates for each region. Used to define the domain of the sparkline Y axis.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        let maxs = []
        let sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            let id = rg.properties.id
            let max = getRegionMax(id)
            if (max) {
                maxs.push(max)
            }
        })

        let minmax = (0,d3_array__WEBPACK_IMPORTED_MODULE_13__["default"])(maxs)
        return minmax
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionMax = function (id) {
        let max = 0
        let s

        //get stat value for each date and find the max
        for (let i = 0; i < out._statDates.length; i++) {
            //retrieve code and stat value
            const sc = out._statDates[i]
            s = out.statData(sc).get(id)
            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }
            if (s.value > max) max = s.value
        }

        //case when no data
        if (max == 0) return undefined
        return max
    }

    //@override
    out.getLegendConstructor = function () {
        //TODO define legend
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (region, map) {
        const buf = []

        // Header with region name and ID
        const regionName = region.properties.na
        const regionId = region.properties.id
        buf.push(`
            <div class="estat-vis-tooltip-bar">
                <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
            </div>
        `)

        // Prepare data for sparkline chart
        const height = out.sparkTooltipChart_.height
        const width = out.sparkTooltipChart_.width
        const margin = out.sparkTooltipChart_.margin
        const data = getComposition(region.properties.id)

        if (data) {
            // Create an SVG element detached from the document
            const container = (0,d3_selection__WEBPACK_IMPORTED_MODULE_14__["default"])('div').attr('class', 'em-tooltip-chart-container')
            const svg = container
                .append('svg')
                .attr('class', 'em-tooltip-chart-svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)

            const g = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`)

            // Generate the chart within the SVG
            createSparkLineChart(g, data, width, height, true)

            // Convert the SVG node to an HTML string and add it to the buffer
            buf.push(container.node().outerHTML)
        }

        // Return the buffer as a single string
        return buf.join('')
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun) {
    colorFun = colorFun || interpolateYlOrRd
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}


/***/ }),

/***/ "./src/maptypes/map-stripe-composition.js":
/*!************************************************!*\
  !*** ./src/maptypes/map-stripe-composition.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-stripe-composition */ "./src/legend/legend-stripe-composition.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



//schemeSet3 schemeDark2 schemePastel1 schemeTableau10



/**
 * Return a stripe composition map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'scomp')

    //width of the stripes serie
    out.stripeWidth_ = 50
    //orientation - vertical by default
    out.stripeOrientation_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    //show stripes only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    //tooltip pie chart
    out.pieChartRadius_ = 40
    out.pieChartInnerRadius_ = 15

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'stripeWidth_',
        'stripeOrientation_',
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieChartRadius_',
        'pieChartInnerRadius_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'stripeWidth',
            'stripeOrientation',
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieChartRadius',
            'pieChartInnerRadius',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /**
     * A function to define a stripe map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     */
    out.statComp = function (stat, dim, codes, labels, colors) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set statCodes
        statCodes = codes

        return out
    }

    /** The codes of the categories to consider for the composition. */
    let statCodes = undefined

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < statCodes.length; i++) {
            //retrieve code and stat value
            const sc = statCodes[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < statCodes.length; i++) comp[statCodes[i]] /= sum

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!statCodes) {
            //get list of stat codes.
            statCodes = Object.keys(out.statData_)
            //remove "default", if present
            const index = statCodes.indexOf('default')
            if (index > -1) statCodes.splice(index, 1)
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors()) {
            out.catColors({})
            for (let i = 0; i < statCodes.length; i++) out.catColors()[statCodes[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign texture to the regions
        out.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out))
            .style('fill', function (d) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const id = d.properties.id

                //compute composition
                const composition = getComposition(id)

                //case when no or missing data
                if (!composition) return out.noDataFillStyle() || 'gray'

                //make stripe pattern
                const patt = out
                    .svg()
                    .append('pattern')
                    .attr('id', 'pattern_' + id)
                    .attr('x', '0')
                    .attr('y', '0')
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .attr('patternUnits', 'userSpaceOnUse')
                //use orientation, if specified
                if (out.stripeOrientation()) patt.attr('patternTransform', 'rotate(' + out.stripeOrientation() + ')')

                //background
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .style('stroke', 'none')
                    .style('fill', 'lightgray')

                //make stripes, one per category
                let x = 0
                for (let code in composition) {
                    //get stripe size
                    let dx = composition[code]
                    if (!dx) continue
                    dx *= out.stripeWidth()

                    //get stripe color
                    const col = out.catColors()[code] || 'lightgray'

                    //add stripe to pattern: a thin rectangle
                    patt.append('rect')
                        .attr('x', x)
                        .attr('y', 0)
                        .attr('height', 1)
                        .style('stroke', 'none')
                        .attr('code', code)
                        .style('fill', col)
                        //transition along x
                        .transition()
                        .duration(out.transitionDuration())
                        .attr('width', dx)
                    x += dx
                }

                //return pattern reference
                return 'url(#pattern_' + id + ')'
            })
            .attr('nd', function (d) {
                return !getComposition(d.properties.id) ? 'nd' : ''
            })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        return out
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        //write region name
        const regionName = rg.properties.na || rg.properties.name
        if (rg.properties.id) {
            //name and code
            tp.append('div').html('<b>' + regionName + '</b> (' + rg.properties.id + ') <br>')
        } else {
            //region name
            tp.append('div').html('<b>' + regionName + '</b><br>')
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        const r = out.pieChartRadius(),
            ir = out.pieChartInnerRadius()
        const svg = tp
            .append('svg')
            .attr('viewBox', [-r, -r, 2 * r, 2 * r])
            .attr('width', 2 * r)

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_5__["default"])()
            .sort(null)
            .value((d) => d.value)
        svg.append('g')
            .attr('stroke', 'darkgray')
            .selectAll('path')
            .data(pie_(data))
            .join('path')
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().innerRadius(ir).outerRadius(r))
    }

    return out
}


/***/ }),

/***/ "./src/tooltip/tooltip.js":
/*!********************************!*\
  !*** ./src/tooltip/tooltip.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tooltip: () => (/* binding */ tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * @param {*} config
 * @returns
 */
const tooltip = function (config) {
    config = config || {}
    config.containerId = config.containerId || 'map'
    config.div = config.div || 'tooltip_eurostat'
    config.maxWidth = config.maxWidth || '200px'
    config.fontSize = config.fontSize || '14px'
    config.background = config.background || 'white'
    config.padding = config.padding || '0px'
    config.border = config.border || '0px'
    config.borderRadius = config.borderRadius || '0px'
    config.boxShadow = config.boxShadow || '0px 0px 0px grey'

    config.transitionDuration = config.transitionDuration || 0
    config.xOffset = config.xOffset || 30
    config.yOffset = config.yOffset || 20

    let tooltip

    function my() {
        tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + config.div)
        if (tooltip.empty()) tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('body').append('div').attr('id', config.div)

        tooltip.attr('class', 'tooltip-eurostat')
    }

    my.mouseover = function (html) {
        if (html) tooltip.html(html)
        let x = event.pageX
        let y = event.pageY
        my.ensureTooltipOnScreen(x, y)
    }

    my.mousemove = function (event) {
        let x = event.pageX
        let y = event.pageY
        this.ensureTooltipOnScreen(x, y)
    }

    my.mouseout = function () {
        tooltip.style('opacity', 0)
    }

    my.style = function (k, v) {
        if (arguments.length == 1) return tooltip.style(k)
        tooltip.style(k, v)
        return my
    }

    my.attr = function (k, v) {
        if (arguments.length == 1) return tooltip.attr(k)
        tooltip.attr(k, v)
        return my
    }

    /**
     * @function ensureTooltipOnScreen
     * @description Prevents the tooltip from overflowing off screen
     */
    my.ensureTooltipOnScreen = function (eventX, eventY) {
        tooltip.style('opacity', 1)
        let node = tooltip.node()

        node.style.left = eventX + config.xOffset + 'px'
        node.style.top = eventY - config.yOffset + 'px'

        let parent = document.getElementById(config.containerId)
        let rect = parent.getBoundingClientRect() // get the bounding rectangle
        let parentWidth = rect.width
        let parentHeight = rect.height

        //too far right
        //taking into account off screen space but shouldnt be
        if (node.offsetLeft > rect.left + parentWidth - node.clientWidth) {
            let left = eventX - node.clientWidth - config.xOffset
            node.style.left = left + 'px'
            // check if mouse covers tooltip
            if (node.offsetLeft + node.clientWidth > eventX) {
                //move tooltip left so it doesnt cover mouse
                let left2 = eventX - node.clientWidth - config.xOffset
                node.style.left = left2 + 'px'
            }
            // node.style.top = node.offsetTop + config.yOffset + "px";
        }

        //too far down
        if (node.offsetTop + node.clientHeight > rect.top + parentHeight) {
            node.style.top = node.offsetTop - node.clientHeight + 'px'
        }
    }

    my()
    return my
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFun: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getFillPatternDefinitionFun),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.map)
/* harmony export */ });
/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/index.css */ "./src/css/index.css");
/* harmony import */ var _eurostat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eurostat-map */ "./src/eurostat-map.js");


//export { statData } from "./core/stat-data.js";

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8seUZBQXlGLE1BQU0sWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLFVBQVUsTUFBTSxZQUFZLE9BQU8sWUFBWSxNQUFNLFlBQVksYUFBYSxhQUFhLFdBQVcsVUFBVSxZQUFZLE9BQU8sWUFBWSxPQUFPLFVBQVUsVUFBVSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLE9BQU8sTUFBTSxVQUFV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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQU0sV0FBVyxrREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsYUFBYSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlB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QUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjs7QUFFOUQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCOztBQUV4RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0MsZ0NBQWdDO0FBQzFGLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLHVEQUF1RDtBQUNwRzs7QUFFQTtBQUNBLDZDQUE2QyxxREFBcUQ7QUFDbEc7O0FBRUE7QUFDQSw2Q0FBNkMsd0RBQXdEO0FBQ3JHOztBQUVBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLFFBQVE7O0FBRXBCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUxBQW1MLDZDQUFJLGFBQWEsb0RBQU07QUFDMU07QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0NBQWtDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhOztBQUUxRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaURBQVc7QUFDcEQ7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiw4Q0FBSTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsNkNBQUc7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsMkJBQTJCLG9DQUFvQztBQUMxRSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsV0FBVywyQkFBMkIsb0NBQW9DO0FBQzFFLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkIsb0NBQW9DO0FBQzFFLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxXQUFXLDJCQUEyQixvQ0FBb0M7QUFDMUUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQWU7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0Isb0JBQW9CLEtBQUssVUFBVTtBQUMzRSxLQUFLOztBQUVMO0FBQ0Esd0NBQXdDLCtDQUFLO0FBQzdDLHdDQUF3QywrQ0FBSztBQUM3QztBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFlBQVksdUNBQXVDO0FBQzNFLEtBQUs7QUFDTDs7QUFFQSx5QkFBeUIsc0NBQXNDO0FBQy9EO0FBQ0Esa0NBQWtDLGdFQUFnRTs7QUFFbEcsV0FBVztBQUNYLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIOztBQUVBLFdBQVc7QUFDWCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIseUNBQXlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0NBQWtDLCtDQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQkFBK0IsVUFBVSw4Q0FBOEM7QUFDdkY7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVc7QUFDWCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDJCQUEyQixrQ0FBa0M7O0FBRTdEO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQUs7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLCtDQUFLO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsdURBQXVELElBQUksd0RBQXdEOztBQUV6STtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDJCQUEyQixrQ0FBa0M7QUFDeEUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw4QkFBOEIsa0JBQWtCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQUssNEJBQTRCLCtDQUFLO0FBQzVELHNCQUFzQiwrQ0FBSywyQkFBMkIsK0NBQUs7O0FBRTNEO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BELGdCQUFnQiw4Q0FBOEM7QUFDOUQsZ0JBQWdCLDBDQUEwQztBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIseURBQXlEO0FBQ2hGLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0Esb0VBQW9FLCtEQUErRCx5RUFBeUU7O0FBRTVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esb0RBQW9ELG1DQUFtQztBQUN2RiwwQkFBMEIsa0NBQWtDO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQSx3RUFBd0UsdUVBQXVFO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsNkJBQTZCLDhDQUE4QztBQUMzRSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELGtDQUFrQztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakYsMEJBQTBCLGtDQUFrQzs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFJLGFBQWEsb0RBQU07QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxxRkFBcUYsWUFBWTtBQUNqRyxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwrQ0FBSztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQUs7QUFDekIsb0JBQW9CLCtDQUFLO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtDQUFLO0FBQ3ZCLGtCQUFrQiwrQ0FBSztBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsNklBQTZJO0FBQzdJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsK0lBQStJO0FBQy9JO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMElBQTBJO0FBQzFJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpSkFBaUo7QUFDako7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGVBQWU7QUFDZixDQUFDOztBQUVEO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsVUFBVSx3QkFBd0I7QUFDbEMsZUFBZTtBQUNmLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixVQUFVLHdCQUF3QjtBQUNsQyxlQUFlO0FBQ2YsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvREFBTTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJLGlDQUFpQztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQVE7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsb0RBQU07O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4WCxpRUFBZSxLQUFLLEVBQUM7QUFDblo7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0bUVtRDs7Ozs7Ozs7Ozs7Ozs7O0FDQW5ELFlBQVk7O0FBRVo7QUFDQSw4Q0FBOEMsS0FBSyxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUyxFQUFFLFNBQVMsRUFBRSxXQUFXO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUF3QjtBQUN6QyxlQUFlLGdEQUF3QjtBQUN2QyxjQUFjLGdEQUF3QjtBQUN0QyxZQUFZLGdEQUF3QjtBQUNwQyxZQUFZLGdEQUF3QjtBQUNwQyxZQUFZLGdEQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQVU7QUFDckMsVUFBVTtBQUNWO0FBQ0EsMkJBQTJCLHFEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxlQUFlLElBQUksZUFBZTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJLEVBQUU7QUFDaEMsaUJBQWlCLFdBQVcsRUFBRSxXQUFXLFFBQVEsSUFBSSxFQUFFO0FBQ3ZELGlCQUFpQixXQUFXLEVBQUUsV0FBVyxRQUFRLElBQUksRUFBRTtBQUN2RCxpQkFBaUIsV0FBVyxFQUFFLFdBQVcsUUFBUSxJQUFJLEVBQUUsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJLEVBQUU7QUFDaEMsaUJBQWlCLFdBQVcsRUFBRSxXQUFXLFFBQVEsSUFBSSxFQUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O1VDbEdBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQXdCO0FBQ007QUFDOUIsV0FBVyxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9OVVRTLmNzcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvYW5ub3RhdGlvbnMuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9pbmRleC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL2xhYmVscy5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL2xlZ2VuZC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL21hcC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL3Rvb2x0aXAuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy93b3JsZC5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9mc3VtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9ncmVhdGVzdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tYXhJbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWluSW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcGVybXV0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1aWNrc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9yYW5nZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc29ydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc3VtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aWNrcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1heGlzL3NyYy9heGlzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWF4aXMvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvc3JjL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL25vZHJhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvY3N2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvZHN2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvdHN2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2N1YmljLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZldGNoL3NyYy9kc3YuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL2pzb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL3RleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2NvbGxpZGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9qaWdnbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2xjZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvc2ltdWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMveS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9leHBvbmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdERlY2ltYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRHcm91cC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdE51bWVyYWxzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0UHJlZml4QXV0by5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFJvdW5kZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRTcGVjaWZpZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUcmltLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2xvY2FsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvbkZpeGVkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uUHJlZml4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uUm91bmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9mc3VtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2FydGVzaWFuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2FudGltZXJpZGlhbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvbGluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3Jlam9pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jb21wb3NlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvbm9vcC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2JvdW5kcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wb2ludEVxdWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BvbHlnb25Db250YWlucy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2ZpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vcmVzYW1wbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvc3RyZWFtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvcm9iaW5zb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jZW50cm9pZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvYnVmZmVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9yZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3Jlam9pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2dyYXRpY3VsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2FyZWEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2JvdW5kcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvY2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9tZWFzdXJlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wb2ludEVxdWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9maXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvc3RyZWFtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2xhYi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvb2JqZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy96b29tLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2FkZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvY292ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2RhdGEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZmluZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZHRyZWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcm9vdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvc2l6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvdmlzaXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0QWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9jYXRlZ29yaWNhbC9TZXQzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlLWNocm9tYXRpYy9zcmMvY2F0ZWdvcmljYWwvY2F0ZWdvcnkxMC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL2NvbG9ycy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL3JhbXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9zZXF1ZW50aWFsLW11bHRpL09yUmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9zZXF1ZW50aWFsLW11bHRpL1lsR25CdS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYmFuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnRpbnVvdXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luaXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbG9nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9uaWNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL29yZGluYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3Bvdy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aXplLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aHJlc2hvbGQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL21hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXR0ci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NsYXNzZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xvbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXR1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VtcHR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VudGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2h0bWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5zZXJ0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbG93ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2Rlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yYWlzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zaXplLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3BhcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yQWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FyYy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJlYS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9idW1wLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2Rlc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5rLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9tYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9waWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3BvaW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludFJhZGlhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvYXN0ZXJpc2suanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jaXJjbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jcm9zcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9kaWFtb25kMi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3BsdXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zcXVhcmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zcXVhcmUyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3Rhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3RpbWVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC90cmlhbmdsZTIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC93eWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vaW5kZXhSb2xsdXBOZXh0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvc3JjL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvZHJhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2RyYWcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL25vZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbG9jYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tb3VzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NhbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NsYXNzZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Nsb25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXRhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXR1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VhY2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VtcHR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbnRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZXhpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9odG1sLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5zZXJ0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9qb2luLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9sb3dlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb3JkZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3Byb3BlcnR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yYWlzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmVtb3ZlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2l6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc29ydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3BhcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3RvckFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zb3VyY2VFdmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy90b3VjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy90b3VjaGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmVhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2Jhc2lzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpc09wZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9idW5kbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2FyZGluYWxPcGVuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tT3Blbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhckNsb3NlZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL21vbm90b25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbmF0dXJhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL3JhZGlhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL3N0ZXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvZXhwYW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb2Zmc2V0L25vbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvc2lsaG91ZXR0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC93aWdnbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9hc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvaW5zaWRlT3V0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvbm9uZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9waWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3JhZGlhbEFyZWEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9yYWRpYWxMaW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3RhY2suanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2Nyb3NzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3N0YXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lb3V0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW50ZXJydXB0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW50ZXJydXB0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0ci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHJUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2RlbGF5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9lYXNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZVZhcnlpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9lbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ludGVycG9sYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NjaGVkdWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zdHlsZVR3ZWVuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHRUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90d2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ldmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy96b29tLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2ludGVybm1hcC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvanNvbnN0YXQtdG9vbGtpdC9pbXBvcnQubWpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3NpbXBsZS1zdGF0aXN0aWNzL2Rpc3Qvc2ltcGxlLXN0YXRpc3RpY3MubWpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9iYm94LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvZmVhdHVyZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL21lc2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9uZWlnaGJvcnMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9zdGl0Y2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy91bnRyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2Fubm90YXRpb25zLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvY2FydG9ncmFtcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2RlcHJlY2F0ZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS9nZW9tZXRyaWVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvaW5zZXRzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUva29zb3ZvLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvbGFiZWxzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvbWFwLXRlbXBsYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvc3RhbXBzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvc3RhdC1kYXRhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvc3RhdC1tYXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS91dGlscy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvaW5kZXguY3NzP2Y3ZWEiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvZXVyb3N0YXQtbWFwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtY2F0ZWdvcmljYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLWJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGgtdHJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1mbG93LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcGllY2hhcnRzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcHJvcG9ydGlvbmFsLXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1zdHJpcGUtY29tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9tYXB0eXBlcy9tYXAtY2F0ZWdvcmljYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWNob3JvcGxldGgtYml2YXJpYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLXRyaXZhcmlhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWNob3JvcGxldGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWZsb3cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXBpZWNoYXJ0cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXNwYXJrbGluZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXN0cmlwZS1jb21wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy90b29sdGlwL3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZXVyb3N0YXRtYXBcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXVyb3N0YXRtYXBcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC8qIFNUWUxJTkcgT0YgTlVUUyBSRUdJT05TIEFORCBCT1VOREFSSUVTICovXHJcbi8qIERlZmF1bHQgcmVnaW9uIGZpbGwgKi9cclxuLmVtLWNudHJnLFxyXG4uZW0tbnV0c3JnLFxyXG4uZW0tZ3JpZC1jZWxsIHtcclxuICAgIGZpbGw6ICNlMWUxZTE7XHJcbn1cclxuXHJcbi5lbS1udXRzcmcsXHJcbi5lbS1jbnRyZyxcclxuLmVtLWdyaWQtY2VsbCxcclxuI2VtLXVzZXItcmVnaW9ucyB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuXHJcbi8qICBib3VuZGFyaWVzIHN0cm9rZS13aWR0aCAqL1xyXG4uZW0tYm4tMCB7XHJcbiAgICBzdHJva2U6IG5vbmU7XHJcbn1cclxuLmVtLWJuLTEsXHJcbi5lbS1ibi0yLFxyXG4uZW0tYm4tMyxcclxuLyogd2hlbiB1c2luZyBNSVhFRCBOVVRTIGxldmVscywgd2UgYWRkIHN0cm9rZSB0byB0aGUgcmVnaW9ucywgdGhlbiBzaG93L2hpZGUgdGhvc2UgdGhhdCBoYXZlL2RvbnQgaGF2ZSBkYXRhICovXHJcbi5lbS1udXRzcmcgW2x2bD0nMyddLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcclxuLmVtLW51dHNyZyBbbHZsPScxJ10sXHJcbi5lbS1ibi1jbyB7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuMjtcclxufVxyXG5cclxuLyogYWxsIGJvdWRuYXJpZXMgYW5kIHJlZ2lvbnMgbGluZWNhcC9saW5lam9pbiAqL1xyXG4jZW0tbnV0c2JuLFxyXG4uZW0tY250Ym4sXHJcbi5lbS1ibi0wLFxyXG4uZW0tYm4tMSxcclxuLmVtLWJuLTIsXHJcbi5lbS1ibi0zLFxyXG4uZW0ta29zb3ZvLWJuLFxyXG4uZW0tYm4tZCxcclxuLmVtLWJuLWNvLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcclxuLmVtLW51dHNyZyBbbHZsPScyJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMSddLFxyXG4uZW0tY250cmcsXHJcbi5lbS1udXRzcmcsXHJcbi5lbS1ncmlkLWNlbGwge1xyXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxufVxyXG5cclxuLyogbmF0aW9uYWwgYm91bmRhcmllcyAqL1xyXG4uZW0tY250Ym4ge1xyXG4gICAgc3Ryb2tlOiAjMDAwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjZweDtcclxufVxyXG5cclxuLyogTlVUUyBib3VuZGFyaWVzIHN0cm9rZSBjb2xvciAqL1xyXG4uZW0tYm4tMSxcclxuLmVtLWJuLTIsXHJcbi5lbS1ibi0zLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcclxuLmVtLW51dHNyZyBbbHZsPScyJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMSddIHtcclxuICAgIHN0cm9rZTogIzY5Njk2OTtcclxufVxyXG5cclxuLyogY29hc3RhbCBib3VuZGFyaWVzICovXHJcbi5lbS1ibi1jbyB7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcblxyXG4vKiBrb3Nvdm8gKi9cclxuLmVtLWtvc292by1ibiB7XHJcbiAgICBzdHJva2U6ICMwMDA7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuMTU7XHJcbn1cclxuXHJcbi8qIGRpc3B1dGVkICovXHJcbi5lbS1ibi1kIHtcclxuICAgIHN0cm9rZTogIzAwMDtcclxuICAgIHN0cm9rZS13aWR0aDogMC4yO1xyXG59XHJcblxyXG4vKiBkb250IGZpbGwgY2VydGFpbiBlbGVtZW50cyAqL1xyXG4uZW0tZnJhbWUsXHJcbi5lbS1ncmF0aWN1bGUsXHJcbi5lbS1jbnRibixcclxuLmVtLWJuLTAsXHJcbi5lbS1ibi0xLFxyXG4uZW0tYm4tMixcclxuLmVtLWJuLTMsXHJcbi5lbS1rb3Nvdm8tYm4sXHJcbi5lbS1ibi1kLFxyXG4uZW0tYm4tY28ge1xyXG4gICAgZmlsbDogbm9uZTtcclxufVxyXG5cclxuLyogdGFyZ2V0IG5vbiBjYy9ldS9lZnRhIGJvcmRlcnMgKi9cclxuLyogLmVtLWJuLW90aDpub3QoLmVtLWJuLWNvKTpub3QoLmVtLWJuLWNjKTpub3QoLmVtLWJuLWV1KTpub3QoLmVtLWJuLWVmdGEpIHtcclxuICAgIHN0cm9rZS13aWR0aDogMDtcclxufSAqL1xyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvTlVUUy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsMkNBQTJDO0FBQzNDLHdCQUF3QjtBQUN4Qjs7O0lBR0ksYUFBYTtBQUNqQjs7QUFFQTs7OztJQUlJLGVBQWU7QUFDbkI7O0FBRUEsNkJBQTZCO0FBQzdCO0lBQ0ksWUFBWTtBQUNoQjtBQUNBOzs7Ozs7OztJQVFJLGlCQUFpQjtBQUNyQjs7QUFFQSxnREFBZ0Q7QUFDaEQ7Ozs7Ozs7Ozs7Ozs7OztJQWVJLHFCQUFxQjtJQUNyQixzQkFBc0I7QUFDMUI7O0FBRUEsd0JBQXdCO0FBQ3hCO0lBQ0ksWUFBWTtJQUNaLG1CQUFtQjtBQUN2Qjs7QUFFQSxpQ0FBaUM7QUFDakM7Ozs7OztJQU1JLGVBQWU7QUFDbkI7O0FBRUEsdUJBQXVCO0FBQ3ZCO0lBQ0ksYUFBYTtBQUNqQjs7QUFFQSxXQUFXO0FBQ1g7SUFDSSxZQUFZO0lBQ1osa0JBQWtCO0FBQ3RCOztBQUVBLGFBQWE7QUFDYjtJQUNJLFlBQVk7SUFDWixpQkFBaUI7QUFDckI7O0FBRUEsK0JBQStCO0FBQy9COzs7Ozs7Ozs7O0lBVUksVUFBVTtBQUNkOztBQUVBLGtDQUFrQztBQUNsQzs7R0FFR1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBTVFlMSU5HIE9GIE5VVFMgUkVHSU9OUyBBTkQgQk9VTkRBUklFUyAqL1xcclxcbi8qIERlZmF1bHQgcmVnaW9uIGZpbGwgKi9cXHJcXG4uZW0tY250cmcsXFxyXFxuLmVtLW51dHNyZyxcXHJcXG4uZW0tZ3JpZC1jZWxsIHtcXHJcXG4gICAgZmlsbDogI2UxZTFlMTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLW51dHNyZyxcXHJcXG4uZW0tY250cmcsXFxyXFxuLmVtLWdyaWQtY2VsbCxcXHJcXG4jZW0tdXNlci1yZWdpb25zIHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4vKiAgYm91bmRhcmllcyBzdHJva2Utd2lkdGggKi9cXHJcXG4uZW0tYm4tMCB7XFxyXFxuICAgIHN0cm9rZTogbm9uZTtcXHJcXG59XFxyXFxuLmVtLWJuLTEsXFxyXFxuLmVtLWJuLTIsXFxyXFxuLmVtLWJuLTMsXFxyXFxuLyogd2hlbiB1c2luZyBNSVhFRCBOVVRTIGxldmVscywgd2UgYWRkIHN0cm9rZSB0byB0aGUgcmVnaW9ucywgdGhlbiBzaG93L2hpZGUgdGhvc2UgdGhhdCBoYXZlL2RvbnQgaGF2ZSBkYXRhICovXFxyXFxuLmVtLW51dHNyZyBbbHZsPSczJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScyJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScxJ10sXFxyXFxuLmVtLWJuLWNvIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjI7XFxyXFxufVxcclxcblxcclxcbi8qIGFsbCBib3VkbmFyaWVzIGFuZCByZWdpb25zIGxpbmVjYXAvbGluZWpvaW4gKi9cXHJcXG4jZW0tbnV0c2JuLFxcclxcbi5lbS1jbnRibixcXHJcXG4uZW0tYm4tMCxcXHJcXG4uZW0tYm4tMSxcXHJcXG4uZW0tYm4tMixcXHJcXG4uZW0tYm4tMyxcXHJcXG4uZW0ta29zb3ZvLWJuLFxcclxcbi5lbS1ibi1kLFxcclxcbi5lbS1ibi1jbyxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzEnXSxcXHJcXG4uZW0tY250cmcsXFxyXFxuLmVtLW51dHNyZyxcXHJcXG4uZW0tZ3JpZC1jZWxsIHtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBuYXRpb25hbCBib3VuZGFyaWVzICovXFxyXFxuLmVtLWNudGJuIHtcXHJcXG4gICAgc3Ryb2tlOiAjMDAwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuNnB4O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBOVVRTIGJvdW5kYXJpZXMgc3Ryb2tlIGNvbG9yICovXFxyXFxuLmVtLWJuLTEsXFxyXFxuLmVtLWJuLTIsXFxyXFxuLmVtLWJuLTMsXFxyXFxuLmVtLW51dHNyZyBbbHZsPSczJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScyJ10sXFxyXFxuLmVtLW51dHNyZyBbbHZsPScxJ10ge1xcclxcbiAgICBzdHJva2U6ICM2OTY5Njk7XFxyXFxufVxcclxcblxcclxcbi8qIGNvYXN0YWwgYm91bmRhcmllcyAqL1xcclxcbi5lbS1ibi1jbyB7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbi8qIGtvc292byAqL1xcclxcbi5lbS1rb3Nvdm8tYm4ge1xcclxcbiAgICBzdHJva2U6ICMwMDA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4xNTtcXHJcXG59XFxyXFxuXFxyXFxuLyogZGlzcHV0ZWQgKi9cXHJcXG4uZW0tYm4tZCB7XFxyXFxuICAgIHN0cm9rZTogIzAwMDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjI7XFxyXFxufVxcclxcblxcclxcbi8qIGRvbnQgZmlsbCBjZXJ0YWluIGVsZW1lbnRzICovXFxyXFxuLmVtLWZyYW1lLFxcclxcbi5lbS1ncmF0aWN1bGUsXFxyXFxuLmVtLWNudGJuLFxcclxcbi5lbS1ibi0wLFxcclxcbi5lbS1ibi0xLFxcclxcbi5lbS1ibi0yLFxcclxcbi5lbS1ibi0zLFxcclxcbi5lbS1rb3Nvdm8tYm4sXFxyXFxuLmVtLWJuLWQsXFxyXFxuLmVtLWJuLWNvIHtcXHJcXG4gICAgZmlsbDogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLyogdGFyZ2V0IG5vbiBjYy9ldS9lZnRhIGJvcmRlcnMgKi9cXHJcXG4vKiAuZW0tYm4tb3RoOm5vdCguZW0tYm4tY28pOm5vdCguZW0tYm4tY2MpOm5vdCguZW0tYm4tZXUpOm5vdCguZW0tYm4tZWZ0YSkge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDA7XFxyXFxufSAqL1xcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLmVtLWFubm90YXRpb24tZ3JvdXAge1xyXG4gICAgLyogcG9pbnRlci1ldmVudHM6IG5vbmU7ICovXHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL2Fubm90YXRpb25zLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLDBCQUEwQjtBQUM5QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZW0tYW5ub3RhdGlvbi1ncm91cCB7XFxyXFxuICAgIC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFwLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3Rvb2x0aXAuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8yX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVnZW5kLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfM19fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xhYmVscy5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzRfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9hbm5vdGF0aW9ucy5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzVfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9OVVRTLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfNl9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3dvcmxkLmNzc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzFfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzJfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzNfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzRfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzVfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzZfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBcclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYCNlbS1sYWJlbHMge1xyXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbiAgICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcclxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBjZW50cmFsO1xyXG59XHJcblxyXG4uZW0tbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG59XHJcbi5lbS1sYWJlbC1iYWNrZ3JvdW5kIHtcclxuICAgIGZpbGw6ICNmZmZmZmY7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG4uZW0tbGFiZWwtc2hhZG93IHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZS13aWR0aDogMnB4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG4uZW0tc3RhdC1sYWJlbCB7XHJcbiAgICBvcGFjaXR5OiAwLjk7XHJcbiAgICBmb250LXNpemU6IDEzcHg7XHJcbiAgICBmaWxsOiAjMzEzMTMxO1xyXG4gICAgc3Ryb2tlOiAjMzEzMTMxO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjJweDtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG59XHJcbi5lbS1zdGF0LWxhYmVsLXNoYWRvdyB7XHJcbiAgICBvcGFjaXR5OiAwLjk7XHJcbiAgICBmb250LXNpemU6IDEzcHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDMuM3B4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG4uZW0tbGFiZWwtY2Mge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgc3Ryb2tlOiAjNTA1MDUwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjVweDtcclxufVxyXG4uZW0tbGFiZWwtc2hhZG93LWNjIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcclxufVxyXG4uZW0tbGFiZWwtY291bnRyaWVzIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHN0cm9rZTogIzUwNTA1MDtcclxuICAgIHN0cm9rZS13aWR0aDogMC41cHg7XHJcbn1cclxuLmVtLWxhYmVsLXNoYWRvdy1jb3VudHJpZXMge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xyXG59XHJcbi5lbS1sYWJlbC1zZWFzIHtcclxuICAgIGZvbnQtc2l6ZTogOXB4O1xyXG4gICAgZmlsbDogIzAwMzM5OTtcclxuICAgIHN0cm9rZTogIzAwMzM5OTtcclxuICAgIHN0cm9rZS13aWR0aDogMC4ycHg7XHJcbiAgICBsZXR0ZXItc3BhY2luZzogM3B4O1xyXG59XHJcbi5lbS1sYWJlbC1zaGFkb3ctc2VhcyB7XHJcbiAgICBmb250LXNpemU6IDlweDtcclxuICAgIGxldHRlci1zcGFjaW5nOiAzcHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XHJcbn1cclxuXHJcbi5lbS1mbG93LWxhYmVscyB7XHJcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xyXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IGNlbnRyYWw7XHJcbn1cclxuLmVtLWZsb3ctbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiAxM3B4O1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxufVxyXG4uZW0tZmxvdy1sYWJlbC1zaGFkb3cge1xyXG4gICAgZm9udC1zaXplOiAxM3B4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiA0cHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy9sYWJlbHMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksbUJBQW1CO0lBQ25CLHNCQUFzQjtJQUN0Qix5Q0FBeUM7SUFDekMsMEJBQTBCO0FBQzlCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjtBQUNBO0lBQ0ksYUFBYTtJQUNiLG9CQUFvQjtBQUN4QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixhQUFhO0FBQ2pCO0FBQ0E7SUFDSSxZQUFZO0lBQ1osZUFBZTtJQUNmLGFBQWE7SUFDYixlQUFlO0lBQ2YsbUJBQW1CO0lBQ25CLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksWUFBWTtJQUNaLGVBQWU7SUFDZixtQkFBbUI7SUFDbkIsYUFBYTtBQUNqQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGVBQWU7SUFDZixtQkFBbUI7QUFDdkI7QUFDQTtJQUNJLGVBQWU7SUFDZixhQUFhO0lBQ2IsaUJBQWlCO0FBQ3JCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsZUFBZTtJQUNmLG1CQUFtQjtBQUN2QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGFBQWE7SUFDYixpQkFBaUI7QUFDckI7QUFDQTtJQUNJLGNBQWM7SUFDZCxhQUFhO0lBQ2IsZUFBZTtJQUNmLG1CQUFtQjtJQUNuQixtQkFBbUI7QUFDdkI7QUFDQTtJQUNJLGNBQWM7SUFDZCxtQkFBbUI7SUFDbkIsYUFBYTtJQUNiLGlCQUFpQjtBQUNyQjs7QUFFQTtJQUNJLG1CQUFtQjtJQUNuQixzQkFBc0I7SUFDdEIseUNBQXlDO0lBQ3pDLDBCQUEwQjtBQUM5QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLFdBQVc7SUFDWCxpQkFBaUI7QUFDckI7QUFDQTtJQUNJLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsYUFBYTtBQUNqQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIjZW0tbGFiZWxzIHtcXHJcXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxyXFxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBjZW50cmFsO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tbGFiZWwge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1iYWNrZ3JvdW5kIHtcXHJcXG4gICAgZmlsbDogI2ZmZmZmZjtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zaGFkb3cge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMnB4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbn1cXHJcXG4uZW0tc3RhdC1sYWJlbCB7XFxyXFxuICAgIG9wYWNpdHk6IDAuOTtcXHJcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcclxcbiAgICBmaWxsOiAjMzEzMTMxO1xcclxcbiAgICBzdHJva2U6ICMzMTMxMzE7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4ycHg7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbn1cXHJcXG4uZW0tc3RhdC1sYWJlbC1zaGFkb3cge1xcclxcbiAgICBvcGFjaXR5OiAwLjk7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAzLjNweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLWNjIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2U6ICM1MDUwNTA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC41cHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zaGFkb3ctY2Mge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtY291bnRyaWVzIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2U6ICM1MDUwNTA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC41cHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zaGFkb3ctY291bnRyaWVzIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLXNlYXMge1xcclxcbiAgICBmb250LXNpemU6IDlweDtcXHJcXG4gICAgZmlsbDogIzAwMzM5OTtcXHJcXG4gICAgc3Ryb2tlOiAjMDAzMzk5O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuMnB4O1xcclxcbiAgICBsZXR0ZXItc3BhY2luZzogM3B4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtc2hhZG93LXNlYXMge1xcclxcbiAgICBmb250LXNpemU6IDlweDtcXHJcXG4gICAgbGV0dGVyLXNwYWNpbmc6IDNweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XFxyXFxufVxcclxcblxcclxcbi5lbS1mbG93LWxhYmVscyB7XFxyXFxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcbiAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGFiZWwge1xcclxcbiAgICBmb250LXNpemU6IDEzcHg7XFxyXFxuICAgIGZpbGw6IGJsYWNrO1xcclxcbiAgICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGFiZWwtc2hhZG93IHtcXHJcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDRweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuZW0tbGVnZW5kLWJhY2tncm91bmQge1xyXG4gICAgZmlsbDogd2hpdGU7XHJcbiAgICBvcGFjaXR5OiAwLjc7XHJcbiAgICByeDogMDtcclxuICAgIHJ5OiAwO1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuLmVtLWxlZ2VuZC1sYWJlbCB7XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbiAgICBzdHJva2U6IG5vbmU7XHJcbiAgICBmaWxsOiBibGFjaztcclxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBjZW50cmFsO1xyXG59XHJcbi5lbS1sZWdlbmQtdGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbn1cclxuLmVtLWxlZ2VuZC1zZXBhcmF0b3Ige1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxuICAgIHN0cm9rZS13aWR0aDogMTtcclxufVxyXG4uZW0tbGVnZW5kLXRpY2sge1xyXG4gICAgc3Ryb2tlOiBncmV5O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtZnJhbWUge1xyXG4gICAgZmlsbDogbm9uZTtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS1ub2RhdGEge1xyXG4gICAgc3Ryb2tlOiBibGFjaztcclxuICAgIHN0cm9rZS13aWR0aDogMC41O1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtYXhpcy10aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS1ub2RhdGEtbGFiZWwge1xyXG4gICAgZm9udC1zaXplOiAxNHB4O1xyXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcclxufVxyXG4uZW0tYml2YXJpYXRlLXRpY2sge1xyXG4gICAgc3Ryb2tlOiBibGFjaztcclxuICAgIHN0cm9rZS13aWR0aDogMTtcclxufVxyXG4uZW0tYml2YXJpYXRlLXRpY2stbGFiZWwge1xyXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxufVxyXG4uZW0tYml2YXJpYXRlLXNxdWFyZSxcclxuLmVtLWxlZ2VuZC1yZWN0IHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbn1cclxuXHJcbi5lbS1iaXZhcmlhdGUtc3F1YXJlOmhvdmVyLFxyXG4uZW0tbGVnZW5kLXJlY3Q6aG92ZXIge1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAyO1xyXG4gICAgc3Ryb2tlOiByZWQ7XHJcbn1cclxuXHJcbi5lbS1waWUtc2l6ZS1sZWdlbmQtbGluZSB7XHJcbiAgICBzdHJva2UtZGFzaGFycmF5OiAyO1xyXG4gICAgc3Ryb2tlOiBncmV5O1xyXG59XHJcblxyXG4uZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lIHtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL2xlZ2VuZC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxXQUFXO0lBQ1gsWUFBWTtJQUNaLEtBQUs7SUFDTCxLQUFLO0lBQ0wsb0JBQW9CO0FBQ3hCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsWUFBWTtJQUNaLFdBQVc7SUFDWCwwQkFBMEI7QUFDOUI7QUFDQTtJQUNJLGVBQWU7SUFDZixXQUFXO0FBQ2Y7QUFDQTtJQUNJLGFBQWE7SUFDYixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxZQUFZO0lBQ1osZUFBZTtBQUNuQjtBQUNBO0lBQ0ksVUFBVTtJQUNWLGFBQWE7QUFDakI7QUFDQTtJQUNJLGFBQWE7SUFDYixpQkFBaUI7SUFDakIsZUFBZTtBQUNuQjtBQUNBO0lBQ0ksZUFBZTtBQUNuQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLHlCQUF5QjtBQUM3QjtBQUNBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7QUFDQTtJQUNJLG1CQUFtQjtJQUNuQixlQUFlO0FBQ25CO0FBQ0E7O0lBRUksZUFBZTtJQUNmLGFBQWE7QUFDakI7O0FBRUE7O0lBRUksZUFBZTtJQUNmLFdBQVc7QUFDZjs7QUFFQTtJQUNJLG1CQUFtQjtJQUNuQixZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksYUFBYTtBQUNqQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZW0tbGVnZW5kLWJhY2tncm91bmQge1xcclxcbiAgICBmaWxsOiB3aGl0ZTtcXHJcXG4gICAgb3BhY2l0eTogMC43O1xcclxcbiAgICByeDogMDtcXHJcXG4gICAgcnk6IDA7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4uZW0tbGVnZW5kLWxhYmVsIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbiAgICBzdHJva2U6IG5vbmU7XFxyXFxuICAgIGZpbGw6IGJsYWNrO1xcclxcbiAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDtcXHJcXG59XFxyXFxuLmVtLWxlZ2VuZC10aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXHJcXG4gICAgZmlsbDogYmxhY2s7XFxyXFxufVxcclxcbi5lbS1sZWdlbmQtc2VwYXJhdG9yIHtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xcclxcbn1cXHJcXG4uZW0tbGVnZW5kLXRpY2sge1xcclxcbiAgICBzdHJva2U6IGdyZXk7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMTtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS1mcmFtZSB7XFxyXFxuICAgIGZpbGw6IG5vbmU7XFxyXFxuICAgIHN0cm9rZTogYmxhY2s7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtbm9kYXRhIHtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjU7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS1heGlzLXRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLW5vZGF0YS1sYWJlbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS10aWNrIHtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLXRpY2stbGFiZWwge1xcclxcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtc3F1YXJlLFxcclxcbi5lbS1sZWdlbmQtcmVjdCB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWJpdmFyaWF0ZS1zcXVhcmU6aG92ZXIsXFxyXFxuLmVtLWxlZ2VuZC1yZWN0OmhvdmVyIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAyO1xcclxcbiAgICBzdHJva2U6IHJlZDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXBpZS1zaXplLWxlZ2VuZC1saW5lIHtcXHJcXG4gICAgc3Ryb2tlLWRhc2hhcnJheTogMjtcXHJcXG4gICAgc3Ryb2tlOiBncmV5O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lIHtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAvKiBHZW5lcmFsIHRleHQgc2V0dGluZ3MgKi9cclxudGV4dCB7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG5cclxuYSB0ZXh0IHtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbn1cclxuXHJcbi8qIE1haW4gbWFwICovXHJcbi5lbS1tYXAsXHJcbi5lbS1sZWdlbmQge1xyXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XHJcbn1cclxuXHJcbi8qIENvYXN0YWwgbWFyZ2luICovXHJcbiNlbS1jb2FzdC1tYXJnaW4ge1xyXG4gICAgZmlsdGVyOiB1cmwoI2VtLWNvYXN0YWwtYmx1cik7XHJcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xyXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xyXG4gICAgZmlsbDogbm9uZTtcclxuICAgIHN0cm9rZS13aWR0aDogNTtcclxuICAgIHN0cm9rZTogcmdiKDE2MSwgMTk4LCAyMzcpO1xyXG59XHJcblxyXG4vKiBUaXRsZSBhbmQgc3VidGl0bGUgc3R5bGluZyAqL1xyXG4uZW0tdGl0bGUsXHJcbi5lbS1pbnNldC10aXRsZSB7XHJcbiAgICBmaWxsOiBibGFjaztcclxuICAgIHN0cm9rZTogbm9uZTtcclxufVxyXG5cclxuLmVtLXRpdGxlIHtcclxuICAgIGZvbnQtc2l6ZTogMjFweDtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG59XHJcblxyXG4uZW0taW5zZXQtdGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG59XHJcblxyXG4uZW0tc3VidGl0bGUsXHJcbi5lbS1pbnNldC1zdWJ0aXRsZSB7XHJcbiAgICBmaWxsOiAjODQ4MjgwO1xyXG4gICAgc3Ryb2tlOiBub25lO1xyXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxuICAgIHBhaW50LW9yZGVyOiBzdHJva2U7XHJcbn1cclxuXHJcbi5lbS1zdWJ0aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDE4cHg7XHJcbiAgICBmb250LXdlaWdodDogMTAwO1xyXG59XHJcblxyXG4uZW0taW5zZXQtc3VidGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG59XHJcblxyXG4uZW0tc291cmNlLXByZXRleHQge1xyXG4gICAgZm9udC1zaXplOiAxMXB4O1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTVweCwgLTVweCk7XHJcbn1cclxuLmVtLXNvdXJjZS1kYXRhc2V0LWxpbmsge1xyXG4gICAgZm9udC1zaXplOiAxMXB4O1xyXG4gICAgZmlsbDogIzBlNDdjYjtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTVweCwgLTVweCk7XHJcbn1cclxuLmVtLXNvdXJjZS1kYXRhc2V0LWxpbms6aG92ZXIge1xyXG4gICAgZmlsbDogIzA4MmI3YTtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG59XHJcblxyXG4uZW0tZnJhbWUge1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xyXG4gICAgc3Ryb2tlOiBncmV5O1xyXG59XHJcblxyXG4uZW0taW5zZXRzIC5lbS1mcmFtZSB7XHJcbiAgICAvKiB0aGlzIHdpbGwgZ2l2ZSBhIGZyYW1lIHRvIGluc2V0IG1hcHMgKi9cclxuICAgIHN0cm9rZTogZ3JleTtcclxuICAgIHN0cm9rZS13aWR0aDogMC4zcHggIWltcG9ydGFudDtcclxufVxyXG5cclxuLmVtLXNlYSB7XHJcbiAgICBmaWxsOiB3aGl0ZTtcclxuICAgIC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xyXG59XHJcbi5lbS1zY2FsZWJhci1saW5lIHtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuOHB4O1xyXG59XHJcbi5lbS1zY2FsZWJhci1sYWJlbCB7XHJcbiAgICBmb250LXNpemU6IDlweDtcclxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XHJcbn1cclxuXHJcbi8qIEJvdHRvbSB0ZXh0IGFuZCBzeW1ib2wgc3R5bGluZyAqL1xyXG4uZW0tZm9vdG5vdGUge1xyXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcclxuICAgIGN1cnNvcjogZGVmYXVsdDtcclxuICAgIGZvbnQtc2l6ZTogMTFweDtcclxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDVweCwgLTVweCk7XHJcbn1cclxuLmVtLWZvb3Rub3RlIGEge1xyXG4gICAgZmlsbDogIzBlNDdjYjtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG59XHJcbi5lbS1mb290bm90ZSBhOmhvdmVyIHtcclxuICAgIGZpbGw6ICMwYTMyOGU7XHJcbn1cclxuXHJcbi5lbS1jZW50cm9pZCB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuXHJcbi8qIEdyYXRpY3VsZSBzdHlsaW5nICovXHJcbi5lbS1ncmF0aWN1bGUge1xyXG4gICAgc3Ryb2tlOiBsaWdodGdyYXk7XHJcbiAgICBzdHJva2Utd2lkdGg6IDE7XHJcbn1cclxuXHJcbi5lbS1mbG93LWxpbmsge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcbi5lbS1mbG93LWxpbmstb3V0bGluZSB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuLmVtLWZsb3ctbGFiZWxzIHtcclxuICAgIGZvbnQtc2l6ZTogMTVweDtcclxuICAgIHN0cm9rZS13aWR0aDogMXB4O1xyXG4gICAgZmlsbDogYmxhY2s7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG4uZW0tZmxvdy1sYWJlbHMtaGFsbyB7XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDJweDtcclxuICAgIGZpbGw6IHdoaXRlO1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuXHJcbi5lbS1ncmlkLXJlY3QsXHJcbi5lbS1ncmlkLWhleGFnb24ge1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3MvbWFwLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSwwQkFBMEI7QUFDMUI7SUFDSSxvQkFBb0I7QUFDeEI7O0FBRUE7SUFDSSxtQkFBbUI7QUFDdkI7O0FBRUEsYUFBYTtBQUNiOztJQUVJLHlDQUF5QztBQUM3Qzs7QUFFQSxtQkFBbUI7QUFDbkI7SUFDSSw2QkFBNkI7SUFDN0Isc0JBQXNCO0lBQ3RCLHFCQUFxQjtJQUNyQixVQUFVO0lBQ1YsZUFBZTtJQUNmLDBCQUEwQjtBQUM5Qjs7QUFFQSwrQkFBK0I7QUFDL0I7O0lBRUksV0FBVztJQUNYLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjs7QUFFQTs7SUFFSSxhQUFhO0lBQ2IsWUFBWTtJQUNaLHNCQUFzQjtJQUN0QixtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjs7QUFFQTtJQUNJLGVBQWU7SUFDZixnQ0FBZ0M7QUFDcEM7QUFDQTtJQUNJLGVBQWU7SUFDZixhQUFhO0lBQ2IsZUFBZTtJQUNmLDBCQUEwQjtJQUMxQixnQ0FBZ0M7QUFDcEM7QUFDQTtJQUNJLGFBQWE7SUFDYixlQUFlO0lBQ2YsMEJBQTBCO0FBQzlCOztBQUVBO0lBQ0ksZUFBZTtJQUNmLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSx5Q0FBeUM7SUFDekMsWUFBWTtJQUNaLDhCQUE4QjtBQUNsQzs7QUFFQTtJQUNJLFdBQVc7SUFDWCwwQkFBMEI7QUFDOUI7QUFDQTtJQUNJLGFBQWE7SUFDYixtQkFBbUI7QUFDdkI7QUFDQTtJQUNJLGNBQWM7SUFDZCxtQkFBbUI7QUFDdkI7O0FBRUEsbUNBQW1DO0FBQ25DO0lBQ0ksbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixlQUFlO0lBQ2YsK0JBQStCO0FBQ25DO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsMEJBQTBCO0FBQzlCO0FBQ0E7SUFDSSxhQUFhO0FBQ2pCOztBQUVBO0lBQ0ksZUFBZTtBQUNuQjs7QUFFQSxzQkFBc0I7QUFDdEI7SUFDSSxpQkFBaUI7SUFDakIsZUFBZTtBQUNuQjs7QUFFQTtJQUNJLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsV0FBVztJQUNYLG9CQUFvQjtBQUN4QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixXQUFXO0lBQ1gsb0JBQW9CO0FBQ3hCOztBQUVBOztJQUVJLGFBQWE7QUFDakJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogR2VuZXJhbCB0ZXh0IHNldHRpbmdzICovXFxyXFxudGV4dCB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG5hIHRleHQge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBNYWluIG1hcCAqL1xcclxcbi5lbS1tYXAsXFxyXFxuLmVtLWxlZ2VuZCB7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBDb2FzdGFsIG1hcmdpbiAqL1xcclxcbiNlbS1jb2FzdC1tYXJnaW4ge1xcclxcbiAgICBmaWx0ZXI6IHVybCgjZW0tY29hc3RhbC1ibHVyKTtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDU7XFxyXFxuICAgIHN0cm9rZTogcmdiKDE2MSwgMTk4LCAyMzcpO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBUaXRsZSBhbmQgc3VidGl0bGUgc3R5bGluZyAqL1xcclxcbi5lbS10aXRsZSxcXHJcXG4uZW0taW5zZXQtdGl0bGUge1xcclxcbiAgICBmaWxsOiBibGFjaztcXHJcXG4gICAgc3Ryb2tlOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tdGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDIxcHg7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0taW5zZXQtdGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxufVxcclxcblxcclxcbi5lbS1zdWJ0aXRsZSxcXHJcXG4uZW0taW5zZXQtc3VidGl0bGUge1xcclxcbiAgICBmaWxsOiAjODQ4MjgwO1xcclxcbiAgICBzdHJva2U6IG5vbmU7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxuICAgIHBhaW50LW9yZGVyOiBzdHJva2U7XFxyXFxufVxcclxcblxcclxcbi5lbS1zdWJ0aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWluc2V0LXN1YnRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tc291cmNlLXByZXRleHQge1xcclxcbiAgICBmb250LXNpemU6IDExcHg7XFxyXFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01cHgsIC01cHgpO1xcclxcbn1cXHJcXG4uZW0tc291cmNlLWRhdGFzZXQtbGluayB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXHJcXG4gICAgZmlsbDogIzBlNDdjYjtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTVweCwgLTVweCk7XFxyXFxufVxcclxcbi5lbS1zb3VyY2UtZGF0YXNldC1saW5rOmhvdmVyIHtcXHJcXG4gICAgZmlsbDogIzA4MmI3YTtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWZyYW1lIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xcclxcbiAgICBzdHJva2U6IGdyZXk7XFxyXFxufVxcclxcblxcclxcbi5lbS1pbnNldHMgLmVtLWZyYW1lIHtcXHJcXG4gICAgLyogdGhpcyB3aWxsIGdpdmUgYSBmcmFtZSB0byBpbnNldCBtYXBzICovXFxyXFxuICAgIHN0cm9rZTogZ3JleTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjNweCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tc2VhIHtcXHJcXG4gICAgZmlsbDogd2hpdGU7XFxyXFxuICAgIC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xcclxcbn1cXHJcXG4uZW0tc2NhbGViYXItbGluZSB7XFxyXFxuICAgIHN0cm9rZTogYmxhY2s7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC44cHg7XFxyXFxufVxcclxcbi5lbS1zY2FsZWJhci1sYWJlbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogOXB4O1xcclxcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBCb3R0b20gdGV4dCBhbmQgc3ltYm9sIHN0eWxpbmcgKi9cXHJcXG4uZW0tZm9vdG5vdGUge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoNXB4LCAtNXB4KTtcXHJcXG59XFxyXFxuLmVtLWZvb3Rub3RlIGEge1xcclxcbiAgICBmaWxsOiAjMGU0N2NiO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG59XFxyXFxuLmVtLWZvb3Rub3RlIGE6aG92ZXIge1xcclxcbiAgICBmaWxsOiAjMGEzMjhlO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tY2VudHJvaWQge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi8qIEdyYXRpY3VsZSBzdHlsaW5nICovXFxyXFxuLmVtLWdyYXRpY3VsZSB7XFxyXFxuICAgIHN0cm9rZTogbGlnaHRncmF5O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDE7XFxyXFxufVxcclxcblxcclxcbi5lbS1mbG93LWxpbmsge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcbi5lbS1mbG93LWxpbmstb3V0bGluZSB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGFiZWxzIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDFweDtcXHJcXG4gICAgZmlsbDogYmxhY2s7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4uZW0tZmxvdy1sYWJlbHMtaGFsbyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XFxyXFxuICAgIGZpbGw6IHdoaXRlO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWdyaWQtcmVjdCxcXHJcXG4uZW0tZ3JpZC1oZXhhZ29uIHtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuZXN0YXQtdmlzLXRvb2x0aXAtdGV4dCB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xyXG4gICAgY29sb3I6ICMxNzFhMjI7XHJcbiAgICBwYWRkaW5nOiA0cHg7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbn1cclxuLmVzdGF0LXZpcy10b29sdGlwLWJhciB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjNTE1NTYwO1xyXG4gICAgY29sb3I6ICNmZmZmZmY7XHJcbiAgICBwYWRkaW5nOiA2cHg7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbn1cclxuLnRvb2x0aXAtZXVyb3N0YXQge1xyXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsO1xyXG4gICAgbWF4LXdpZHRoOiAyNTBweDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICAgIHBhZGRpbmc6IDBweDtcclxuICAgIGJvcmRlcjogMHB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xyXG4gICAgYm94LXNoYWRvdzogMHB4IDRweCA2cHggcmdiYSgwLCAwLCAwLCAwLjEpLCAwcHggMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIG9wYWNpdHk6IDA7XHJcbiAgICB6LWluZGV4OiA5OTk5OTk5OTtcclxufVxyXG4uZW0tdG9vbHRpcC1waWVjaGFydC1icmVha2Rvd24ge1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIGZvbnQtc2l6ZTogMTRweDtcclxufVxyXG4uZW0tdG9vbHRpcC1waWVjaGFydC1jb250YWluZXIge1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy90b29sdGlwLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLG1CQUFtQjtJQUNuQixjQUFjO0lBQ2QsWUFBWTtJQUNaLGVBQWU7QUFDbkI7QUFDQTtJQUNJLG1CQUFtQjtJQUNuQixjQUFjO0lBQ2QsWUFBWTtJQUNaLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGtCQUFrQjtJQUNsQixnQkFBZ0I7SUFDaEIsZ0JBQWdCO0lBQ2hCLGlCQUFpQjtJQUNqQixZQUFZO0lBQ1osV0FBVztJQUNYLGtCQUFrQjtJQUNsQiwyRUFBMkU7SUFDM0Usa0JBQWtCO0lBQ2xCLHlDQUF5QztJQUN6QyxvQkFBb0I7SUFDcEIsVUFBVTtJQUNWLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGtCQUFrQjtBQUN0QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZXN0YXQtdmlzLXRvb2x0aXAtdGV4dCB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxyXFxuICAgIGNvbG9yOiAjMTcxYTIyO1xcclxcbiAgICBwYWRkaW5nOiA0cHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXHJcXG59XFxyXFxuLmVzdGF0LXZpcy10b29sdGlwLWJhciB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICM1MTU1NjA7XFxyXFxuICAgIGNvbG9yOiAjZmZmZmZmO1xcclxcbiAgICBwYWRkaW5nOiA2cHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXHJcXG59XFxyXFxuLnRvb2x0aXAtZXVyb3N0YXQge1xcclxcbiAgICBmb250LWZhbWlseTogQXJpYWw7XFxyXFxuICAgIG1heC13aWR0aDogMjUwcHg7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcclxcbiAgICBwYWRkaW5nOiAwcHg7XFxyXFxuICAgIGJvcmRlcjogMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAwcHg7XFxyXFxuICAgIGJveC1zaGFkb3c6IDBweCA0cHggNnB4IHJnYmEoMCwgMCwgMCwgMC4xKSwgMHB4IDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBmb250LWZhbWlseTogSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIHotaW5kZXg6IDk5OTk5OTk5O1xcclxcbn1cXHJcXG4uZW0tdG9vbHRpcC1waWVjaGFydC1icmVha2Rvd24ge1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgICBmb250LXNpemU6IDE0cHg7XFxyXFxufVxcclxcbi5lbS10b29sdGlwLXBpZWNoYXJ0LWNvbnRhaW5lciB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAjZ193b3JsZGJuLC5lbS13b3JsZHJnLC5lbS13b3JsZGJuIHtcclxuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbn1cclxuXHJcbi5lbS13b3JsZGJuIHtcclxuICAgIHN0cm9rZTogIzAwMDtcclxuICAgIHN0cm9rZS13aWR0aDogMC4zcHg7XHJcbn1cclxuXHJcbi5lbS13b3JsZGJuIHtcclxuICAgIGZpbGw6IG5vbmU7XHJcbn1cclxuXHJcbi5lbS13b3JsZHJnIHtcclxuICAgIGZpbGw6ICNlZmVmZWY7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jc3Mvd29ybGQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0kscUJBQXFCO0lBQ3JCLHNCQUFzQjtBQUMxQjs7QUFFQTtJQUNJLFlBQVk7SUFDWixtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSSxVQUFVO0FBQ2Q7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsZUFBZTtBQUNuQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIjZ193b3JsZGJuLC5lbS13b3JsZHJnLC5lbS13b3JsZGJuIHtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0td29ybGRibiB7XFxyXFxuICAgIHN0cm9rZTogIzAwMDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjNweDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXdvcmxkYm4ge1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0td29ybGRyZyB7XFxyXFxuICAgIGZpbGw6ICNlZmVmZWY7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA9PSBudWxsIHx8IGIgPT0gbnVsbCA/IE5hTiA6IGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBiaXNlY3RvciBmcm9tIFwiLi9iaXNlY3Rvci5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxuY29uc3QgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbmV4cG9ydCBjb25zdCBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbmV4cG9ydCBjb25zdCBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5leHBvcnQgY29uc3QgYmlzZWN0Q2VudGVyID0gYmlzZWN0b3IobnVtYmVyKS5jZW50ZXI7XG5leHBvcnQgZGVmYXVsdCBiaXNlY3RSaWdodDtcbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgZGVzY2VuZGluZyBmcm9tIFwiLi9kZXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpc2VjdG9yKGYpIHtcbiAgbGV0IGNvbXBhcmUxLCBjb21wYXJlMiwgZGVsdGE7XG5cbiAgLy8gSWYgYW4gYWNjZXNzb3IgaXMgc3BlY2lmaWVkLCBwcm9tb3RlIGl0IHRvIGEgY29tcGFyYXRvci4gSW4gdGhpcyBjYXNlIHdlXG4gIC8vIGNhbiB0ZXN0IHdoZXRoZXIgdGhlIHNlYXJjaCB2YWx1ZSBpcyAoc2VsZi0pIGNvbXBhcmFibGUuIFdlIGNhbuKAmXQgZG8gdGhpc1xuICAvLyBmb3IgYSBjb21wYXJhdG9yIChleGNlcHQgZm9yIHNwZWNpZmljLCBrbm93biBjb21wYXJhdG9ycykgYmVjYXVzZSB3ZSBjYW7igJl0XG4gIC8vIHRlbGwgaWYgdGhlIGNvbXBhcmF0b3IgaXMgc3ltbWV0cmljLCBhbmQgYW4gYXN5bW1ldHJpYyBjb21wYXJhdG9yIGNhbuKAmXQgYmVcbiAgLy8gdXNlZCB0byB0ZXN0IHdoZXRoZXIgYSBzaW5nbGUgdmFsdWUgaXMgY29tcGFyYWJsZS5cbiAgaWYgKGYubGVuZ3RoICE9PSAyKSB7XG4gICAgY29tcGFyZTEgPSBhc2NlbmRpbmc7XG4gICAgY29tcGFyZTIgPSAoZCwgeCkgPT4gYXNjZW5kaW5nKGYoZCksIHgpO1xuICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4O1xuICB9IGVsc2Uge1xuICAgIGNvbXBhcmUxID0gZiA9PT0gYXNjZW5kaW5nIHx8IGYgPT09IGRlc2NlbmRpbmcgPyBmIDogemVybztcbiAgICBjb21wYXJlMiA9IGY7XG4gICAgZGVsdGEgPSBmO1xuICB9XG5cbiAgZnVuY3Rpb24gbGVmdChhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBpZiAobG8gPCBoaSkge1xuICAgICAgaWYgKGNvbXBhcmUxKHgsIHgpICE9PSAwKSByZXR1cm4gaGk7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9IHdoaWxlIChsbyA8IGhpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmlnaHQoYSwgeCwgbG8gPSAwLCBoaSA9IGEubGVuZ3RoKSB7XG4gICAgaWYgKGxvIDwgaGkpIHtcbiAgICAgIGlmIChjb21wYXJlMSh4LCB4KSAhPT0gMCkgcmV0dXJuIGhpO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlMihhW21pZF0sIHgpIDw9IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH0gd2hpbGUgKGxvIDwgaGkpO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8gPSAwLCBoaSA9IGEubGVuZ3RoKSB7XG4gICAgY29uc3QgaSA9IGxlZnQoYSwgeCwgbG8sIGhpIC0gMSk7XG4gICAgcmV0dXJuIGkgPiBsbyAmJiBkZWx0YShhW2kgLSAxXSwgeCkgPiAtZGVsdGEoYVtpXSwgeCkgPyBpIC0gMSA6IGk7XG4gIH1cblxuICByZXR1cm4ge2xlZnQsIGNlbnRlciwgcmlnaHR9O1xufVxuXG5mdW5jdGlvbiB6ZXJvKCkge1xuICByZXR1cm4gMDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA9PSBudWxsIHx8IGIgPT0gbnVsbCA/IE5hTlxuICAgIDogYiA8IGEgPyAtMVxuICAgIDogYiA+IGEgPyAxXG4gICAgOiBiID49IGEgPyAwXG4gICAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHRlbnQodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGxldCBtYXg7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24vY3B5dGhvbi9ibG9iL2E3NGVlYTIzOGY1YmFiYTE1Nzk3ZTJlOGI1NzBkMTUzYmM4NjkwYTcvTW9kdWxlcy9tYXRobW9kdWxlLmMjTDE0MjNcbmV4cG9ydCBjbGFzcyBBZGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnRpYWxzID0gbmV3IEZsb2F0NjRBcnJheSgzMik7XG4gICAgdGhpcy5fbiA9IDA7XG4gIH1cbiAgYWRkKHgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbiAmJiBqIDwgMzI7IGorKykge1xuICAgICAgY29uc3QgeSA9IHBbal0sXG4gICAgICAgIGhpID0geCArIHksXG4gICAgICAgIGxvID0gTWF0aC5hYnMoeCkgPCBNYXRoLmFicyh5KSA/IHggLSAoaGkgLSB5KSA6IHkgLSAoaGkgLSB4KTtcbiAgICAgIGlmIChsbykgcFtpKytdID0gbG87XG4gICAgICB4ID0gaGk7XG4gICAgfVxuICAgIHBbaV0gPSB4O1xuICAgIHRoaXMuX24gPSBpICsgMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YWx1ZU9mKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wYXJ0aWFscztcbiAgICBsZXQgbiA9IHRoaXMuX24sIHgsIHksIGxvLCBoaSA9IDA7XG4gICAgaWYgKG4gPiAwKSB7XG4gICAgICBoaSA9IHBbLS1uXTtcbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICB4ID0gaGk7XG4gICAgICAgIHkgPSBwWy0tbl07XG4gICAgICAgIGhpID0geCArIHk7XG4gICAgICAgIGxvID0geSAtIChoaSAtIHgpO1xuICAgICAgICBpZiAobG8pIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG4gPiAwICYmICgobG8gPCAwICYmIHBbbiAtIDFdIDwgMCkgfHwgKGxvID4gMCAmJiBwW24gLSAxXSA+IDApKSkge1xuICAgICAgICB5ID0gbG8gKiAyO1xuICAgICAgICB4ID0gaGkgKyB5O1xuICAgICAgICBpZiAoeSA9PSB4IC0gaGkpIGhpID0geDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBjb25zdCBhZGRlciA9IG5ldyBBZGRlcigpO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgICAgYWRkZXIuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkge1xuICAgICAgICBhZGRlci5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gK2FkZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmN1bXN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgYWRkZXIgPSBuZXcgQWRkZXIoKTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIHJldHVybiBGbG9hdDY0QXJyYXkuZnJvbSh2YWx1ZXMsIHZhbHVlb2YgPT09IHVuZGVmaW5lZFxuICAgICAgPyB2ID0+IGFkZGVyLmFkZCgrdiB8fCAwKVxuICAgICAgOiB2ID0+IGFkZGVyLmFkZCgrdmFsdWVvZih2LCArK2luZGV4LCB2YWx1ZXMpIHx8IDApXG4gICk7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmVhdGVzdCh2YWx1ZXMsIGNvbXBhcmUgPSBhc2NlbmRpbmcpIHtcbiAgbGV0IG1heDtcbiAgbGV0IGRlZmluZWQgPSBmYWxzZTtcbiAgaWYgKGNvbXBhcmUubGVuZ3RoID09PSAxKSB7XG4gICAgbGV0IG1heFZhbHVlO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB2YWx1ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY29tcGFyZShlbGVtZW50KTtcbiAgICAgIGlmIChkZWZpbmVkXG4gICAgICAgICAgPyBhc2NlbmRpbmcodmFsdWUsIG1heFZhbHVlKSA+IDBcbiAgICAgICAgICA6IGFzY2VuZGluZyh2YWx1ZSwgdmFsdWUpID09PSAwKSB7XG4gICAgICAgIG1heCA9IGVsZW1lbnQ7XG4gICAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRlZmluZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKGRlZmluZWRcbiAgICAgICAgICA/IGNvbXBhcmUodmFsdWUsIG1heCkgPiAwXG4gICAgICAgICAgOiBjb21wYXJlKHZhbHVlLCB2YWx1ZSkgPT09IDApIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIGRlZmluZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWF4KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWF4O1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWF4SW5kZXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtYXg7XG4gIGxldCBtYXhJbmRleCA9IC0xO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWUsIG1heEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWUsIG1heEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhJbmRleDtcbn1cbiIsImZ1bmN0aW9uKiBmbGF0dGVuKGFycmF5cykge1xuICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgIHlpZWxkKiBhcnJheTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZmxhdHRlbihhcnJheXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1pbjtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pbkluZGV4KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBsZXQgbWluSW5kZXggPSAtMTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgKytpbmRleDtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlLCBtaW5JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlLCBtaW5JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluSW5kZXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBudW1iZXIoeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBlcm11dGUoc291cmNlLCBrZXlzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGtleXMsIGtleSA9PiBzb3VyY2Vba2V5XSk7XG59XG4iLCJpbXBvcnQgbWF4IGZyb20gXCIuL21heC5qc1wiO1xuaW1wb3J0IG1heEluZGV4IGZyb20gXCIuL21heEluZGV4LmpzXCI7XG5pbXBvcnQgbWluIGZyb20gXCIuL21pbi5qc1wiO1xuaW1wb3J0IG1pbkluZGV4IGZyb20gXCIuL21pbkluZGV4LmpzXCI7XG5pbXBvcnQgcXVpY2tzZWxlY3QgZnJvbSBcIi4vcXVpY2tzZWxlY3QuanNcIjtcbmltcG9ydCBudW1iZXIsIHtudW1iZXJzfSBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCB7YXNjZW5kaW5nRGVmaW5lZH0gZnJvbSBcIi4vc29ydC5qc1wiO1xuaW1wb3J0IGdyZWF0ZXN0IGZyb20gXCIuL2dyZWF0ZXN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKHZhbHVlcywgcCwgdmFsdWVvZikge1xuICB2YWx1ZXMgPSBGbG9hdDY0QXJyYXkuZnJvbShudW1iZXJzKHZhbHVlcywgdmFsdWVvZikpO1xuICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkgfHwgaXNOYU4ocCA9ICtwKSkgcmV0dXJuO1xuICBpZiAocCA8PSAwIHx8IG4gPCAyKSByZXR1cm4gbWluKHZhbHVlcyk7XG4gIGlmIChwID49IDEpIHJldHVybiBtYXgodmFsdWVzKTtcbiAgdmFyIG4sXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXG4gICAgICBpMCA9IE1hdGguZmxvb3IoaSksXG4gICAgICB2YWx1ZTAgPSBtYXgocXVpY2tzZWxlY3QodmFsdWVzLCBpMCkuc3ViYXJyYXkoMCwgaTAgKyAxKSksXG4gICAgICB2YWx1ZTEgPSBtaW4odmFsdWVzLnN1YmFycmF5KGkwICsgMSkpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aWxlU29ydGVkKHZhbHVlcywgcCwgdmFsdWVvZiA9IG51bWJlcikge1xuICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkgfHwgaXNOYU4ocCA9ICtwKSkgcmV0dXJuO1xuICBpZiAocCA8PSAwIHx8IG4gPCAyKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzW24gLSAxXSwgbiAtIDEsIHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXG4gICAgICB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aWxlSW5kZXgodmFsdWVzLCBwLCB2YWx1ZW9mID0gbnVtYmVyKSB7XG4gIGlmIChpc05hTihwID0gK3ApKSByZXR1cm47XG4gIG51bWJlcnMgPSBGbG9hdDY0QXJyYXkuZnJvbSh2YWx1ZXMsIChfLCBpKSA9PiBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKTtcbiAgaWYgKHAgPD0gMCkgcmV0dXJuIG1pbkluZGV4KG51bWJlcnMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gbWF4SW5kZXgobnVtYmVycyk7XG4gIHZhciBudW1iZXJzLFxuICAgICAgaW5kZXggPSBVaW50MzJBcnJheS5mcm9tKHZhbHVlcywgKF8sIGkpID0+IGkpLFxuICAgICAgaiA9IG51bWJlcnMubGVuZ3RoIC0gMSxcbiAgICAgIGkgPSBNYXRoLmZsb29yKGogKiBwKTtcbiAgcXVpY2tzZWxlY3QoaW5kZXgsIGksIDAsIGosIChpLCBqKSA9PiBhc2NlbmRpbmdEZWZpbmVkKG51bWJlcnNbaV0sIG51bWJlcnNbal0pKTtcbiAgaSA9IGdyZWF0ZXN0KGluZGV4LnN1YmFycmF5KDAsIGkgKyAxKSwgKGkpID0+IG51bWJlcnNbaV0pO1xuICByZXR1cm4gaSA+PSAwID8gaSA6IC0xO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmdEZWZpbmVkLCBjb21wYXJlRGVmaW5lZH0gZnJvbSBcIi4vc29ydC5qc1wiO1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9xdWlja3NlbGVjdFxuLy8gSVNDIGxpY2Vuc2UsIENvcHlyaWdodCAyMDE4IFZsYWRpbWlyIEFnYWZvbmtpbi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFycmF5LCBrLCBsZWZ0ID0gMCwgcmlnaHQgPSBJbmZpbml0eSwgY29tcGFyZSkge1xuICBrID0gTWF0aC5mbG9vcihrKTtcbiAgbGVmdCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgbGVmdCkpO1xuICByaWdodCA9IE1hdGguZmxvb3IoTWF0aC5taW4oYXJyYXkubGVuZ3RoIC0gMSwgcmlnaHQpKTtcblxuICBpZiAoIShsZWZ0IDw9IGsgJiYgayA8PSByaWdodCkpIHJldHVybiBhcnJheTtcblxuICBjb21wYXJlID0gY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gYXNjZW5kaW5nRGVmaW5lZCA6IGNvbXBhcmVEZWZpbmVkKGNvbXBhcmUpO1xuXG4gIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICBjb25zdCBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICBjb25zdCB6ID0gTWF0aC5sb2cobik7XG4gICAgICBjb25zdCBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgIGNvbnN0IHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgY29uc3QgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICBjb25zdCBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgcXVpY2tzZWxlY3QoYXJyYXksIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ID0gYXJyYXlba107XG4gICAgbGV0IGkgPSBsZWZ0O1xuICAgIGxldCBqID0gcmlnaHQ7XG5cbiAgICBzd2FwKGFycmF5LCBsZWZ0LCBrKTtcbiAgICBpZiAoY29tcGFyZShhcnJheVtyaWdodF0sIHQpID4gMCkgc3dhcChhcnJheSwgbGVmdCwgcmlnaHQpO1xuXG4gICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICBzd2FwKGFycmF5LCBpLCBqKSwgKytpLCAtLWo7XG4gICAgICB3aGlsZSAoY29tcGFyZShhcnJheVtpXSwgdCkgPCAwKSArK2k7XG4gICAgICB3aGlsZSAoY29tcGFyZShhcnJheVtqXSwgdCkgPiAwKSAtLWo7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBhcmUoYXJyYXlbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFycmF5LCBsZWZ0LCBqKTtcbiAgICBlbHNlICsraiwgc3dhcChhcnJheSwgaiwgcmlnaHQpO1xuXG4gICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyYXksIGksIGopIHtcbiAgY29uc3QgdCA9IGFycmF5W2ldO1xuICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICBhcnJheVtqXSA9IHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuaW1wb3J0IHBlcm11dGUgZnJvbSBcIi4vcGVybXV0ZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzb3J0KHZhbHVlcywgLi4uRikge1xuICBpZiAodHlwZW9mIHZhbHVlc1tTeW1ib2wuaXRlcmF0b3JdICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWx1ZXMgaXMgbm90IGl0ZXJhYmxlXCIpO1xuICB2YWx1ZXMgPSBBcnJheS5mcm9tKHZhbHVlcyk7XG4gIGxldCBbZl0gPSBGO1xuICBpZiAoKGYgJiYgZi5sZW5ndGggIT09IDIpIHx8IEYubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGluZGV4ID0gVWludDMyQXJyYXkuZnJvbSh2YWx1ZXMsIChkLCBpKSA9PiBpKTtcbiAgICBpZiAoRi5sZW5ndGggPiAxKSB7XG4gICAgICBGID0gRi5tYXAoZiA9PiB2YWx1ZXMubWFwKGYpKTtcbiAgICAgIGluZGV4LnNvcnQoKGksIGopID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIEYpIHtcbiAgICAgICAgICBjb25zdCBjID0gYXNjZW5kaW5nRGVmaW5lZChmW2ldLCBmW2pdKTtcbiAgICAgICAgICBpZiAoYykgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmID0gdmFsdWVzLm1hcChmKTtcbiAgICAgIGluZGV4LnNvcnQoKGksIGopID0+IGFzY2VuZGluZ0RlZmluZWQoZltpXSwgZltqXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGVybXV0ZSh2YWx1ZXMsIGluZGV4KTtcbiAgfVxuICByZXR1cm4gdmFsdWVzLnNvcnQoY29tcGFyZURlZmluZWQoZikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZURlZmluZWQoY29tcGFyZSA9IGFzY2VuZGluZykge1xuICBpZiAoY29tcGFyZSA9PT0gYXNjZW5kaW5nKSByZXR1cm4gYXNjZW5kaW5nRGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBjb21wYXJlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb21wYXJlIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICBjb25zdCB4ID0gY29tcGFyZShhLCBiKTtcbiAgICBpZiAoeCB8fCB4ID09PSAwKSByZXR1cm4geDtcbiAgICByZXR1cm4gKGNvbXBhcmUoYiwgYikgPT09IDApIC0gKGNvbXBhcmUoYSwgYSkgPT09IDApO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNjZW5kaW5nRGVmaW5lZChhLCBiKSB7XG4gIHJldHVybiAoYSA9PSBudWxsIHx8ICEoYSA+PSBhKSkgLSAoYiA9PSBudWxsIHx8ICEoYiA+PSBiKSkgfHwgKGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IHN1bSA9IDA7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZSkge1xuICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpIHtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuIiwiY29uc3QgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmZ1bmN0aW9uIHRpY2tTcGVjKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBjb25zdCBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChzdGVwKSksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpLFxuICAgICAgZmFjdG9yID0gZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxO1xuICBsZXQgaTEsIGkyLCBpbmM7XG4gIGlmIChwb3dlciA8IDApIHtcbiAgICBpbmMgPSBNYXRoLnBvdygxMCwgLXBvd2VyKSAvIGZhY3RvcjtcbiAgICBpMSA9IE1hdGgucm91bmQoc3RhcnQgKiBpbmMpO1xuICAgIGkyID0gTWF0aC5yb3VuZChzdG9wICogaW5jKTtcbiAgICBpZiAoaTEgLyBpbmMgPCBzdGFydCkgKytpMTtcbiAgICBpZiAoaTIgLyBpbmMgPiBzdG9wKSAtLWkyO1xuICAgIGluYyA9IC1pbmM7XG4gIH0gZWxzZSB7XG4gICAgaW5jID0gTWF0aC5wb3coMTAsIHBvd2VyKSAqIGZhY3RvcjtcbiAgICBpMSA9IE1hdGgucm91bmQoc3RhcnQgLyBpbmMpO1xuICAgIGkyID0gTWF0aC5yb3VuZChzdG9wIC8gaW5jKTtcbiAgICBpZiAoaTEgKiBpbmMgPCBzdGFydCkgKytpMTtcbiAgICBpZiAoaTIgKiBpbmMgPiBzdG9wKSAtLWkyO1xuICB9XG4gIGlmIChpMiA8IGkxICYmIDAuNSA8PSBjb3VudCAmJiBjb3VudCA8IDIpIHJldHVybiB0aWNrU3BlYyhzdGFydCwgc3RvcCwgY291bnQgKiAyKTtcbiAgcmV0dXJuIFtpMSwgaTIsIGluY107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKCEoY291bnQgPiAwKSkgcmV0dXJuIFtdO1xuICBpZiAoc3RhcnQgPT09IHN0b3ApIHJldHVybiBbc3RhcnRdO1xuICBjb25zdCByZXZlcnNlID0gc3RvcCA8IHN0YXJ0LCBbaTEsIGkyLCBpbmNdID0gcmV2ZXJzZSA/IHRpY2tTcGVjKHN0b3AsIHN0YXJ0LCBjb3VudCkgOiB0aWNrU3BlYyhzdGFydCwgc3RvcCwgY291bnQpO1xuICBpZiAoIShpMiA+PSBpMSkpIHJldHVybiBbXTtcbiAgY29uc3QgbiA9IGkyIC0gaTEgKyAxLCB0aWNrcyA9IG5ldyBBcnJheShuKTtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAoaW5jIDwgMCkgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRpY2tzW2ldID0gKGkyIC0gaSkgLyAtaW5jO1xuICAgIGVsc2UgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRpY2tzW2ldID0gKGkyIC0gaSkgKiBpbmM7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGluYyA8IDApIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB0aWNrc1tpXSA9IChpMSArIGkpIC8gLWluYztcbiAgICBlbHNlIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB0aWNrc1tpXSA9IChpMSArIGkpICogaW5jO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHN0b3AgPSArc3RvcCwgc3RhcnQgPSArc3RhcnQsIGNvdW50ID0gK2NvdW50O1xuICByZXR1cm4gdGlja1NwZWMoc3RhcnQsIHN0b3AsIGNvdW50KVsyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgY29uc3QgcmV2ZXJzZSA9IHN0b3AgPCBzdGFydCwgaW5jID0gcmV2ZXJzZSA/IHRpY2tJbmNyZW1lbnQoc3RvcCwgc3RhcnQsIGNvdW50KSA6IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgcmV0dXJuIChyZXZlcnNlID8gLTEgOiAxKSAqIChpbmMgPCAwID8gMSAvIC1pbmMgOiBpbmMpO1xufVxuIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5cbnZhciB0b3AgPSAxLFxuICAgIHJpZ2h0ID0gMixcbiAgICBib3R0b20gPSAzLFxuICAgIGxlZnQgPSA0LFxuICAgIGVwc2lsb24gPSAxZS02O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGVYKHgpIHtcbiAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLDApXCI7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVkoeSkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArIHkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHNjYWxlKSB7XG4gIHJldHVybiBkID0+ICtzY2FsZShkKTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHNjYWxlLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgc2NhbGUuYmFuZHdpZHRoKCkgLSBvZmZzZXQgKiAyKSAvIDI7XG4gIGlmIChzY2FsZS5yb3VuZCgpKSBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gIHJldHVybiBkID0+ICtzY2FsZShkKSArIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZW50ZXJpbmcoKSB7XG4gIHJldHVybiAhdGhpcy5fX2F4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXMob3JpZW50LCBzY2FsZSkge1xuICB2YXIgdGlja0FyZ3VtZW50cyA9IFtdLFxuICAgICAgdGlja1ZhbHVlcyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgIHRpY2tTaXplSW5uZXIgPSA2LFxuICAgICAgdGlja1NpemVPdXRlciA9IDYsXG4gICAgICB0aWNrUGFkZGluZyA9IDMsXG4gICAgICBvZmZzZXQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMSA/IDAgOiAwLjUsXG4gICAgICBrID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBsZWZ0ID8gLTEgOiAxLFxuICAgICAgeCA9IG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT09IHJpZ2h0ID8gXCJ4XCIgOiBcInlcIixcbiAgICAgIHRyYW5zZm9ybSA9IG9yaWVudCA9PT0gdG9wIHx8IG9yaWVudCA9PT0gYm90dG9tID8gdHJhbnNsYXRlWCA6IHRyYW5zbGF0ZVk7XG5cbiAgZnVuY3Rpb24gYXhpcyhjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbCA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKSA6IHRpY2tWYWx1ZXMsXG4gICAgICAgIGZvcm1hdCA9IHRpY2tGb3JtYXQgPT0gbnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBpZGVudGl0eSkgOiB0aWNrRm9ybWF0LFxuICAgICAgICBzcGFjaW5nID0gTWF0aC5tYXgodGlja1NpemVJbm5lciwgMCkgKyB0aWNrUGFkZGluZyxcbiAgICAgICAgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpLFxuICAgICAgICByYW5nZTAgPSArcmFuZ2VbMF0gKyBvZmZzZXQsXG4gICAgICAgIHJhbmdlMSA9ICtyYW5nZVtyYW5nZS5sZW5ndGggLSAxXSArIG9mZnNldCxcbiAgICAgICAgcG9zaXRpb24gPSAoc2NhbGUuYmFuZHdpZHRoID8gY2VudGVyIDogbnVtYmVyKShzY2FsZS5jb3B5KCksIG9mZnNldCksXG4gICAgICAgIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQsXG4gICAgICAgIHBhdGggPSBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFtudWxsXSksXG4gICAgICAgIHRpY2sgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YSh2YWx1ZXMsIHNjYWxlKS5vcmRlcigpLFxuICAgICAgICB0aWNrRXhpdCA9IHRpY2suZXhpdCgpLFxuICAgICAgICB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpLFxuICAgICAgICBsaW5lID0gdGljay5zZWxlY3QoXCJsaW5lXCIpLFxuICAgICAgICB0ZXh0ID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpO1xuXG4gICAgcGF0aCA9IHBhdGgubWVyZ2UocGF0aC5lbnRlcigpLmluc2VydChcInBhdGhcIiwgXCIudGlja1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpKTtcblxuICAgIHRpY2sgPSB0aWNrLm1lcmdlKHRpY2tFbnRlcik7XG5cbiAgICBsaW5lID0gbGluZS5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKVxuICAgICAgICAuYXR0cih4ICsgXCIyXCIsIGsgKiB0aWNrU2l6ZUlubmVyKSk7XG5cbiAgICB0ZXh0ID0gdGV4dC5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJjdXJyZW50Q29sb3JcIilcbiAgICAgICAgLmF0dHIoeCwgayAqIHNwYWNpbmcpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgb3JpZW50ID09PSB0b3AgPyBcIjBlbVwiIDogb3JpZW50ID09PSBib3R0b20gPyBcIjAuNzFlbVwiIDogXCIwLjMyZW1cIikpO1xuXG4gICAgaWYgKGNvbnRleHQgIT09IHNlbGVjdGlvbikge1xuICAgICAgcGF0aCA9IHBhdGgudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIHRpY2sgPSB0aWNrLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICBsaW5lID0gbGluZS50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgdGV4dCA9IHRleHQudHJhbnNpdGlvbihjb250ZXh0KTtcblxuICAgICAgdGlja0V4aXQgPSB0aWNrRXhpdC50cmFuc2l0aW9uKGNvbnRleHQpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIGVwc2lsb24pXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gaXNGaW5pdGUoZCA9IHBvc2l0aW9uKGQpKSA/IHRyYW5zZm9ybShkICsgb2Zmc2V0KSA6IHRoaXMuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpOyB9KTtcblxuICAgICAgdGlja0VudGVyXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIGVwc2lsb24pXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyB2YXIgcCA9IHRoaXMucGFyZW50Tm9kZS5fX2F4aXM7IHJldHVybiB0cmFuc2Zvcm0oKHAgJiYgaXNGaW5pdGUocCA9IHAoZCkpID8gcCA6IHBvc2l0aW9uKGQpKSArIG9mZnNldCk7IH0pO1xuICAgIH1cblxuICAgIHRpY2tFeGl0LnJlbW92ZSgpO1xuXG4gICAgcGF0aFxuICAgICAgICAuYXR0cihcImRcIiwgb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PT0gcmlnaHRcbiAgICAgICAgICAgID8gKHRpY2tTaXplT3V0ZXIgPyBcIk1cIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCIsXCIgKyByYW5nZTAgKyBcIkhcIiArIG9mZnNldCArIFwiVlwiICsgcmFuZ2UxICsgXCJIXCIgKyBrICogdGlja1NpemVPdXRlciA6IFwiTVwiICsgb2Zmc2V0ICsgXCIsXCIgKyByYW5nZTAgKyBcIlZcIiArIHJhbmdlMSlcbiAgICAgICAgICAgIDogKHRpY2tTaXplT3V0ZXIgPyBcIk1cIiArIHJhbmdlMCArIFwiLFwiICsgayAqIHRpY2tTaXplT3V0ZXIgKyBcIlZcIiArIG9mZnNldCArIFwiSFwiICsgcmFuZ2UxICsgXCJWXCIgKyBrICogdGlja1NpemVPdXRlciA6IFwiTVwiICsgcmFuZ2UwICsgXCIsXCIgKyBvZmZzZXQgKyBcIkhcIiArIHJhbmdlMSkpO1xuXG4gICAgdGlja1xuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNmb3JtKHBvc2l0aW9uKGQpICsgb2Zmc2V0KTsgfSk7XG5cbiAgICBsaW5lXG4gICAgICAgIC5hdHRyKHggKyBcIjJcIiwgayAqIHRpY2tTaXplSW5uZXIpO1xuXG4gICAgdGV4dFxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLnRleHQoZm9ybWF0KTtcblxuICAgIHNlbGVjdGlvbi5maWx0ZXIoZW50ZXJpbmcpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgLmF0dHIoXCJmb250LXNpemVcIiwgMTApXG4gICAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJzYW5zLXNlcmlmXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgb3JpZW50ID09PSByaWdodCA/IFwic3RhcnRcIiA6IG9yaWVudCA9PT0gbGVmdCA/IFwiZW5kXCIgOiBcIm1pZGRsZVwiKTtcblxuICAgIHNlbGVjdGlvblxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHsgdGhpcy5fX2F4aXMgPSBwb3NpdGlvbjsgfSk7XG4gIH1cblxuICBheGlzLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlID0gXywgYXhpcykgOiBzY2FsZTtcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRpY2tBcmd1bWVudHMgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyksIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrQXJndW1lbnRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tBcmd1bWVudHMgPSBfID09IG51bGwgPyBbXSA6IEFycmF5LmZyb20oXyksIGF4aXMpIDogdGlja0FyZ3VtZW50cy5zbGljZSgpO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrVmFsdWVzID0gXyA9PSBudWxsID8gbnVsbCA6IEFycmF5LmZyb20oXyksIGF4aXMpIDogdGlja1ZhbHVlcyAmJiB0aWNrVmFsdWVzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tGb3JtYXQgPSBfLCBheGlzKSA6IHRpY2tGb3JtYXQ7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZUlubmVyID0gdGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZUlubmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZUlubmVyO1xuICB9O1xuXG4gIGF4aXMudGlja1NpemVPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVPdXRlcjtcbiAgfTtcblxuICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tQYWRkaW5nID0gK18sIGF4aXMpIDogdGlja1BhZGRpbmc7XG4gIH07XG5cbiAgYXhpcy5vZmZzZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob2Zmc2V0ID0gK18sIGF4aXMpIDogb2Zmc2V0O1xuICB9O1xuXG4gIHJldHVybiBheGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXhpc1RvcChzY2FsZSkge1xuICByZXR1cm4gYXhpcyh0b3AsIHNjYWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4aXNSaWdodChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhyaWdodCwgc2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXhpc0JvdHRvbShzY2FsZSkge1xuICByZXR1cm4gYXhpcyhib3R0b20sIHNjYWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4aXNMZWZ0KHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGxlZnQsIHNjYWxlKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENvbG9yKCkge31cblxuZXhwb3J0IHZhciBkYXJrZXIgPSAwLjc7XG5leHBvcnQgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIixcbiAgICByZUhleCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLFxuICAgIHJlUmdiSW50ZWdlciA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7cmVJfSwke3JlSX0sJHtyZUl9XFxcXCkkYCksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChgXnJnYlxcXFwoJHtyZVB9LCR7cmVQfSwke3JlUH1cXFxcKSRgKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7cmVJfSwke3JlSX0sJHtyZUl9LCR7cmVOfVxcXFwpJGApLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHtyZVB9LCR7cmVQfSwke3JlUH0sJHtyZU59XFxcXCkkYCksXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChgXmhzbFxcXFwoJHtyZU59LCR7cmVQfSwke3JlUH1cXFxcKSRgKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChgXmhzbGFcXFxcKCR7cmVOfSwke3JlUH0sJHtyZVB9LCR7cmVOfVxcXFwpJGApO1xuXG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcblxuZGVmaW5lKENvbG9yLCBjb2xvciwge1xuICBjb3B5KGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHRoaXMuY29uc3RydWN0b3IsIHRoaXMsIGNoYW5uZWxzKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIZXg4OiBjb2xvcl9mb3JtYXRIZXg4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXg4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXg4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhzbCgpIHtcbiAgcmV0dXJuIGhzbENvbnZlcnQodGhpcykuZm9ybWF0SHNsKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdFJnYigpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICB2YXIgbSwgbDtcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKG0gPSByZUhleC5leGVjKGZvcm1hdCkpID8gKGwgPSBtWzFdLmxlbmd0aCwgbSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbCA9PT0gNiA/IHJnYm4obSkgLy8gI2ZmMDAwMFxuICAgICAgOiBsID09PSAzID8gbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpLCAxKSAvLyAjZjAwXG4gICAgICA6IGwgPT09IDggPyByZ2JhKG0gPj4gMjQgJiAweGZmLCBtID4+IDE2ICYgMHhmZiwgbSA+PiA4ICYgMHhmZiwgKG0gJiAweGZmKSAvIDB4ZmYpIC8vICNmZjAwMDAwMFxuICAgICAgOiBsID09PSA0ID8gcmdiYSgobSA+PiAxMiAmIDB4ZikgfCAobSA+PiA4ICYgMHhmMCksIChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSAvIDB4ZmYpIC8vICNmMDAwXG4gICAgICA6IG51bGwpIC8vIGludmFsaWQgaGV4XG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjbGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IFJnYihjbGFtcGkodGhpcy5yKSwgY2xhbXBpKHRoaXMuZyksIGNsYW1waSh0aGlzLmIpLCBjbGFtcGEodGhpcy5vcGFjaXR5KSk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0SGV4ODogcmdiX2Zvcm1hdEhleDgsXG4gIGZvcm1hdFJnYjogcmdiX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IHJnYl9mb3JtYXRSZ2Jcbn0pKTtcblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIGAjJHtoZXgodGhpcy5yKX0ke2hleCh0aGlzLmcpfSR7aGV4KHRoaXMuYil9YDtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleDgoKSB7XG4gIHJldHVybiBgIyR7aGV4KHRoaXMucil9JHtoZXgodGhpcy5nKX0ke2hleCh0aGlzLmIpfSR7aGV4KChpc05hTih0aGlzLm9wYWNpdHkpID8gMSA6IHRoaXMub3BhY2l0eSkgKiAyNTUpfWA7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIGNvbnN0IGEgPSBjbGFtcGEodGhpcy5vcGFjaXR5KTtcbiAgcmV0dXJuIGAke2EgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIn0ke2NsYW1waSh0aGlzLnIpfSwgJHtjbGFtcGkodGhpcy5nKX0sICR7Y2xhbXBpKHRoaXMuYil9JHthID09PSAxID8gXCIpXCIgOiBgLCAke2F9KWB9YDtcbn1cblxuZnVuY3Rpb24gY2xhbXBhKG9wYWNpdHkpIHtcbiAgcmV0dXJuIGlzTmFOKG9wYWNpdHkpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG9wYWNpdHkpKTtcbn1cblxuZnVuY3Rpb24gY2xhbXBpKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodmFsdWUpIHx8IDApKTtcbn1cblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gY2xhbXBpKHZhbHVlKTtcbiAgcmV0dXJuICh2YWx1ZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIHZhbHVlLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gaHNsYShoLCBzLCBsLCBhKSB7XG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcbiAgZWxzZSBpZiAobCA8PSAwIHx8IGwgPj0gMSkgaCA9IHMgPSBOYU47XG4gIGVsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBIc2woY2xhbXBoKHRoaXMuaCksIGNsYW1wdCh0aGlzLnMpLCBjbGFtcHQodGhpcy5sKSwgY2xhbXBhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsKCkge1xuICAgIGNvbnN0IGEgPSBjbGFtcGEodGhpcy5vcGFjaXR5KTtcbiAgICByZXR1cm4gYCR7YSA9PT0gMSA/IFwiaHNsKFwiIDogXCJoc2xhKFwifSR7Y2xhbXBoKHRoaXMuaCl9LCAke2NsYW1wdCh0aGlzLnMpICogMTAwfSUsICR7Y2xhbXB0KHRoaXMubCkgKiAxMDB9JSR7YSA9PT0gMSA/IFwiKVwiIDogYCwgJHthfSlgfWA7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24gY2xhbXBoKHZhbHVlKSB7XG4gIHZhbHVlID0gKHZhbHVlIHx8IDApICUgMzYwO1xuICByZXR1cm4gdmFsdWUgPCAwID8gdmFsdWUgKyAzNjAgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xhbXB0KHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSB8fCAwKSk7XG59XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2J9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxuLy8gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxuY29uc3QgSyA9IDE4LFxuICAgIFhuID0gMC45NjQyMixcbiAgICBZbiA9IDEsXG4gICAgWm4gPSAwLjgyNTIxLFxuICAgIHQwID0gNCAvIDI5LFxuICAgIHQxID0gNiAvIDI5LFxuICAgIHQyID0gMyAqIHQxICogdDEsXG4gICAgdDMgPSB0MSAqIHQxICogdDE7XG5cbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIExhYikgcmV0dXJuIG5ldyBMYWIoby5sLCBvLmEsIG8uYiwgby5vcGFjaXR5KTtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBoY2wybGFiKG8pO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gcmdiMmxyZ2Ioby5yKSxcbiAgICAgIGcgPSByZ2IybHJnYihvLmcpLFxuICAgICAgYiA9IHJnYjJscmdiKG8uYiksXG4gICAgICB5ID0geHl6MmxhYigoMC4yMjI1MDQ1ICogciArIDAuNzE2ODc4NiAqIGcgKyAwLjA2MDYxNjkgKiBiKSAvIFluKSwgeCwgejtcbiAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikgeCA9IHogPSB5OyBlbHNlIHtcbiAgICB4ID0geHl6MmxhYigoMC40MzYwNzQ3ICogciArIDAuMzg1MDY0OSAqIGcgKyAwLjE0MzA4MDQgKiBiKSAvIFhuKTtcbiAgICB6ID0geHl6MmxhYigoMC4wMTM5MzIyICogciArIDAuMDk3MTA0NSAqIGcgKyAwLjcxNDE3MzMgKiBiKSAvIFpuKTtcbiAgfVxuICByZXR1cm4gbmV3IExhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geiksIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxuICAgICAgbHJnYjJyZ2IoLTAuOTc4NzY4NCAqIHggKyAxLjkxNjE0MTUgKiB5ICsgMC4wMzM0NTQwICogeiksXG4gICAgICBscmdiMnJnYiggMC4wNzE5NDUzICogeCAtIDAuMjI4OTkxNCAqIHkgKyAxLjQwNTI0MjcgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiBscmdiMnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IybHJnYih4KSB7XG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBuZXcgSGNsKG8uaCwgby5jLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMYWIpKSBvID0gbGFiQ29udmVydChvKTtcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCA8IG8ubCAmJiBvLmwgPCAxMDAgPyAwIDogTmFOLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiBkZWdyZWVzO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGNoKGwsIGMsIGgsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQoaCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBoY2wybGFiKG8pIHtcbiAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBvLmggKiByYWRpYW5zO1xuICByZXR1cm4gbmV3IExhYihvLmwsIE1hdGguY29zKGgpICogby5jLCBNYXRoLnNpbihoKSAqIG8uYywgby5vcGFjaXR5KTtcbn1cblxuZGVmaW5lKEhjbCwgaGNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICByZXR1cm4gaGNsMmxhYih0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuIiwiZXhwb3J0IGNvbnN0IHJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuIiwidmFyIG5vb3AgPSB7dmFsdWU6ICgpID0+IHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pIHx8IC9bXFxzLl0vLnRlc3QodCkpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlzcGF0Y2g7XG4iLCJpbXBvcnQge3NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IG5vZXZlbnQsIHtub25wYXNzaXZlY2FwdHVyZX0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fX25vc2VsZWN0ID0gcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0O1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuIiwiLy8gVGhlc2UgYXJlIHR5cGljYWxseSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggbm9ldmVudCB0byBlbnN1cmUgdGhhdCB3ZSBjYW5cbi8vIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudC5cbmV4cG9ydCBjb25zdCBub25wYXNzaXZlID0ge3Bhc3NpdmU6IGZhbHNlfTtcbmV4cG9ydCBjb25zdCBub25wYXNzaXZlY2FwdHVyZSA9IHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZX07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsImltcG9ydCBkc3YgZnJvbSBcIi4vZHN2LmpzXCI7XG5cbnZhciBjc3YgPSBkc3YoXCIsXCIpO1xuXG5leHBvcnQgdmFyIGNzdlBhcnNlID0gY3N2LnBhcnNlO1xuZXhwb3J0IHZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xuZXhwb3J0IHZhciBjc3ZGb3JtYXQgPSBjc3YuZm9ybWF0O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRCb2R5ID0gY3N2LmZvcm1hdEJvZHk7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFJvd3MgPSBjc3YuZm9ybWF0Um93cztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Um93ID0gY3N2LmZvcm1hdFJvdztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0VmFsdWUgPSBjc3YuZm9ybWF0VmFsdWU7XG4iLCJ2YXIgRU9MID0ge30sXG4gICAgRU9GID0ge30sXG4gICAgUVVPVEUgPSAzNCxcbiAgICBORVdMSU5FID0gMTAsXG4gICAgUkVUVVJOID0gMTM7XG5cbmZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl0gfHwgXFxcIlxcXCJcIjtcbiAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gIH07XG59XG5cbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuZnVuY3Rpb24gaW5mZXJDb2x1bW5zKHJvd3MpIHtcbiAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBjb2x1bW5zID0gW107XG5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29sdW1ucztcbn1cblxuZnVuY3Rpb24gcGFkKHZhbHVlLCB3aWR0aCkge1xuICB2YXIgcyA9IHZhbHVlICsgXCJcIiwgbGVuZ3RoID0gcy5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oMCkgKyBzIDogcztcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyIDwgMCA/IFwiLVwiICsgcGFkKC15ZWFyLCA2KVxuICAgIDogeWVhciA+IDk5OTkgPyBcIitcIiArIHBhZCh5ZWFyLCA2KVxuICAgIDogcGFkKHllYXIsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgbWludXRlcyA9IGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgc2Vjb25kcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gXCJJbnZhbGlkIERhdGVcIlxuICAgICAgOiBmb3JtYXRZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNCkgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpLCAyKVxuICAgICAgKyAobWlsbGlzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiLlwiICsgcGFkKG1pbGxpc2Vjb25kcywgMykgKyBcIlpcIlxuICAgICAgOiBzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiWlwiXG4gICAgICA6IG1pbnV0ZXMgfHwgaG91cnMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiWlwiXG4gICAgICA6IFwiXCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWxpbWl0ZXIpIHtcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXG4gICAgICBERUxJTUlURVIgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcblxuICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgdmFyIGNvbnZlcnQsIGNvbHVtbnMsIHJvd3MgPSBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICBpZiAoY29udmVydCkgcmV0dXJuIGNvbnZlcnQocm93LCBpIC0gMSk7XG4gICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XG4gICAgfSk7XG4gICAgcm93cy5jb2x1bW5zID0gY29sdW1ucyB8fCBbXTtcbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XG4gICAgdmFyIHJvd3MgPSBbXSwgLy8gb3V0cHV0IHJvd3NcbiAgICAgICAgTiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgbiA9IDAsIC8vIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgdCwgLy8gY3VycmVudCB0b2tlblxuICAgICAgICBlb2YgPSBOIDw9IDAsIC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9GP1xuICAgICAgICBlb2wgPSBmYWxzZTsgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gTkVXTElORSkgLS1OO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBSRVRVUk4pIC0tTjtcblxuICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgaWYgKGVvZikgcmV0dXJuIEVPRjtcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuXG4gICAgICAvLyBVbmVzY2FwZSBxdW90ZXMuXG4gICAgICB2YXIgaSwgaiA9IEksIGM7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSBRVU9URSkge1xuICAgICAgICB3aGlsZSAoSSsrIDwgTiAmJiB0ZXh0LmNoYXJDb2RlQXQoSSkgIT09IFFVT1RFIHx8IHRleHQuY2hhckNvZGVBdCgrK0kpID09PSBRVU9URSk7XG4gICAgICAgIGlmICgoaSA9IEkpID49IE4pIGVvZiA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cbiAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSA9IEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IERFTElNSVRFUikgY29udGludWU7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gbGFzdCB0b2tlbiBiZWZvcmUgRU9GLlxuICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XG4gICAgfVxuXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHJvdy5wdXNoKHQpLCB0ID0gdG9rZW4oKTtcbiAgICAgIGlmIChmICYmIChyb3cgPSBmKHJvdywgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICByb3dzLnB1c2gocm93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tjb2x1bW5dKTtcbiAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCJcbiAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBmb3JtYXREYXRlKHZhbHVlKVxuICAgICAgICA6IHJlRm9ybWF0LnRlc3QodmFsdWUgKz0gXCJcIikgPyBcIlxcXCJcIiArIHZhbHVlLnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIlxuICAgICAgICA6IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0Qm9keTogZm9ybWF0Qm9keSxcbiAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzLFxuICAgIGZvcm1hdFJvdzogZm9ybWF0Um93LFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXRWYWx1ZVxuICB9O1xufVxuIiwiaW1wb3J0IGRzdiBmcm9tIFwiLi9kc3YuanNcIjtcblxudmFyIHRzdiA9IGRzdihcIlxcdFwiKTtcblxuZXhwb3J0IHZhciB0c3ZQYXJzZSA9IHRzdi5wYXJzZTtcbmV4cG9ydCB2YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0ID0gdHN2LmZvcm1hdDtcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Qm9keSA9IHRzdi5mb3JtYXRCb2R5O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRSb3dzID0gdHN2LmZvcm1hdFJvd3M7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFJvdyA9IHRzdi5mb3JtYXRSb3c7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFZhbHVlID0gdHN2LmZvcm1hdFZhbHVlO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG4iLCJpbXBvcnQge2NzdlBhcnNlLCBkc3ZGb3JtYXQsIHRzdlBhcnNlfSBmcm9tIFwiZDMtZHN2XCI7XG5pbXBvcnQgdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5cbmZ1bmN0aW9uIGRzdlBhcnNlKHBhcnNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaW5pdCwgcm93KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkc3YoZGVsaW1pdGVyLCBpbnB1dCwgaW5pdCwgcm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gIHZhciBmb3JtYXQgPSBkc3ZGb3JtYXQoZGVsaW1pdGVyKTtcbiAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZm9ybWF0LnBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBjc3YgPSBkc3ZQYXJzZShjc3ZQYXJzZSk7XG5leHBvcnQgdmFyIHRzdiA9IGRzdlBhcnNlKHRzdlBhcnNlKTtcbiIsImZ1bmN0aW9uIHJlc3BvbnNlSnNvbihyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA1KSByZXR1cm47XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBmZXRjaChpbnB1dCwgaW5pdCkudGhlbihyZXNwb25zZUpzb24pO1xufVxuIiwiZnVuY3Rpb24gcmVzcG9uc2VUZXh0KHJlc3BvbnNlKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VUZXh0KTtcbn1cbiIsImltcG9ydCB7cXVhZHRyZWV9IGZyb20gXCJkMy1xdWFkdHJlZVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgamlnZ2xlIGZyb20gXCIuL2ppZ2dsZS5qc1wiO1xuXG5mdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueCArIGQudng7XG59XG5cbmZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55ICsgZC52eTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIHJhZGlpLFxuICAgICAgcmFuZG9tLFxuICAgICAgc3RyZW5ndGggPSAxLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQocmFkaXVzID09IG51bGwgPyAxIDogK3JhZGl1cyk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHhpLFxuICAgICAgICB5aSxcbiAgICAgICAgcmksXG4gICAgICAgIHJpMjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICB0cmVlID0gcXVhZHRyZWUobm9kZXMsIHgsIHkpLnZpc2l0QWZ0ZXIocHJlcGFyZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgcmkgPSByYWRpaVtub2RlLmluZGV4XSwgcmkyID0gcmkgKiByaTtcbiAgICAgICAgeGkgPSBub2RlLnggKyBub2RlLnZ4O1xuICAgICAgICB5aSA9IG5vZGUueSArIG5vZGUudnk7XG4gICAgICAgIHRyZWUudmlzaXQoYXBwbHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5KHF1YWQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICB2YXIgZGF0YSA9IHF1YWQuZGF0YSwgcmogPSBxdWFkLnIsIHIgPSByaSArIHJqO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaW5kZXggPiBub2RlLmluZGV4KSB7XG4gICAgICAgICAgdmFyIHggPSB4aSAtIGRhdGEueCAtIGRhdGEudngsXG4gICAgICAgICAgICAgIHkgPSB5aSAtIGRhdGEueSAtIGRhdGEudnksXG4gICAgICAgICAgICAgIGwgPSB4ICogeCArIHkgKiB5O1xuICAgICAgICAgIGlmIChsIDwgciAqIHIpIHtcbiAgICAgICAgICAgIGlmICh4ID09PSAwKSB4ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geCAqIHg7XG4gICAgICAgICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZShyYW5kb20pLCBsICs9IHkgKiB5O1xuICAgICAgICAgICAgbCA9IChyIC0gKGwgPSBNYXRoLnNxcnQobCkpKSAvIGwgKiBzdHJlbmd0aDtcbiAgICAgICAgICAgIG5vZGUudnggKz0gKHggKj0gbCkgKiAociA9IChyaiAqPSByaikgLyAocmkyICsgcmopKTtcbiAgICAgICAgICAgIG5vZGUudnkgKz0gKHkgKj0gbCkgKiByO1xuICAgICAgICAgICAgZGF0YS52eCAtPSB4ICogKHIgPSAxIC0gcik7XG4gICAgICAgICAgICBkYXRhLnZ5IC09IHkgKiByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4geDAgPiB4aSArIHIgfHwgeDEgPCB4aSAtIHIgfHwgeTAgPiB5aSArIHIgfHwgeTEgPCB5aSAtIHI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZShxdWFkKSB7XG4gICAgaWYgKHF1YWQuZGF0YSkgcmV0dXJuIHF1YWQuciA9IHJhZGlpW3F1YWQuZGF0YS5pbmRleF07XG4gICAgZm9yICh2YXIgaSA9IHF1YWQuciA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChxdWFkW2ldICYmIHF1YWRbaV0uciA+IHF1YWQucikge1xuICAgICAgICBxdWFkLnIgPSBxdWFkW2ldLnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG4gICAgcmFkaWkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCByYWRpaVtub2RlLmluZGV4XSA9ICtyYWRpdXMobm9kZSwgaSwgbm9kZXMpO1xuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF9ub2RlcywgX3JhbmRvbSkge1xuICAgIG5vZGVzID0gX25vZGVzO1xuICAgIHJhbmRvbSA9IF9yYW5kb207XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLml0ZXJhdGlvbnMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaXRlcmF0aW9ucyA9ICtfLCBmb3JjZSkgOiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gK18sIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYW5kb20pIHtcbiAgcmV0dXJuIChyYW5kb20oKSAtIDAuNSkgKiAxZS02O1xufVxuIiwiLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2NvbmdydWVudGlhbF9nZW5lcmF0b3IjUGFyYW1ldGVyc19pbl9jb21tb25fdXNlXG5jb25zdCBhID0gMTY2NDUyNTtcbmNvbnN0IGMgPSAxMDEzOTA0MjIzO1xuY29uc3QgbSA9IDQyOTQ5NjcyOTY7IC8vIDJeMzJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGxldCBzID0gMTtcbiAgcmV0dXJuICgpID0+IChzID0gKGEgKiBzICsgYykgJSBtKSAvIG07XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7dGltZXJ9IGZyb20gXCJkMy10aW1lclwiO1xuaW1wb3J0IGxjZyBmcm9tIFwiLi9sY2cuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZC54O1xufVxuXG5leHBvcnQgZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnk7XG59XG5cbnZhciBpbml0aWFsUmFkaXVzID0gMTAsXG4gICAgaW5pdGlhbEFuZ2xlID0gTWF0aC5QSSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZXMpIHtcbiAgdmFyIHNpbXVsYXRpb24sXG4gICAgICBhbHBoYSA9IDEsXG4gICAgICBhbHBoYU1pbiA9IDAuMDAxLFxuICAgICAgYWxwaGFEZWNheSA9IDEgLSBNYXRoLnBvdyhhbHBoYU1pbiwgMSAvIDMwMCksXG4gICAgICBhbHBoYVRhcmdldCA9IDAsXG4gICAgICB2ZWxvY2l0eURlY2F5ID0gMC42LFxuICAgICAgZm9yY2VzID0gbmV3IE1hcCgpLFxuICAgICAgc3RlcHBlciA9IHRpbWVyKHN0ZXApLFxuICAgICAgZXZlbnQgPSBkaXNwYXRjaChcInRpY2tcIiwgXCJlbmRcIiksXG4gICAgICByYW5kb20gPSBsY2coKTtcblxuICBpZiAobm9kZXMgPT0gbnVsbCkgbm9kZXMgPSBbXTtcblxuICBmdW5jdGlvbiBzdGVwKCkge1xuICAgIHRpY2soKTtcbiAgICBldmVudC5jYWxsKFwidGlja1wiLCBzaW11bGF0aW9uKTtcbiAgICBpZiAoYWxwaGEgPCBhbHBoYU1pbikge1xuICAgICAgc3RlcHBlci5zdG9wKCk7XG4gICAgICBldmVudC5jYWxsKFwiZW5kXCIsIHNpbXVsYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soaXRlcmF0aW9ucykge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuXG4gICAgaWYgKGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgaXRlcmF0aW9ucyA9IDE7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xuICAgICAgYWxwaGEgKz0gKGFscGhhVGFyZ2V0IC0gYWxwaGEpICogYWxwaGFEZWNheTtcblxuICAgICAgZm9yY2VzLmZvckVhY2goZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgZm9yY2UoYWxwaGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5meCA9PSBudWxsKSBub2RlLnggKz0gbm9kZS52eCAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgICBlbHNlIG5vZGUueCA9IG5vZGUuZngsIG5vZGUudnggPSAwO1xuICAgICAgICBpZiAobm9kZS5meSA9PSBudWxsKSBub2RlLnkgKz0gbm9kZS52eSAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgICBlbHNlIG5vZGUueSA9IG5vZGUuZnksIG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaW11bGF0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVzKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUuaW5kZXggPSBpO1xuICAgICAgaWYgKG5vZGUuZnggIT0gbnVsbCkgbm9kZS54ID0gbm9kZS5meDtcbiAgICAgIGlmIChub2RlLmZ5ICE9IG51bGwpIG5vZGUueSA9IG5vZGUuZnk7XG4gICAgICBpZiAoaXNOYU4obm9kZS54KSB8fCBpc05hTihub2RlLnkpKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBpbml0aWFsUmFkaXVzICogTWF0aC5zcXJ0KDAuNSArIGkpLCBhbmdsZSA9IGkgKiBpbml0aWFsQW5nbGU7XG4gICAgICAgIG5vZGUueCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgbm9kZS55ID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmFOKG5vZGUudngpIHx8IGlzTmFOKG5vZGUudnkpKSB7XG4gICAgICAgIG5vZGUudnggPSBub2RlLnZ5ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplRm9yY2UoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UuaW5pdGlhbGl6ZSkgZm9yY2UuaW5pdGlhbGl6ZShub2RlcywgcmFuZG9tKTtcbiAgICByZXR1cm4gZm9yY2U7XG4gIH1cblxuICBpbml0aWFsaXplTm9kZXMoKTtcblxuICByZXR1cm4gc2ltdWxhdGlvbiA9IHtcbiAgICB0aWNrOiB0aWNrLFxuXG4gICAgcmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5yZXN0YXJ0KHN0ZXApLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnN0b3AoKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgbm9kZXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVzID0gXywgaW5pdGlhbGl6ZU5vZGVzKCksIGZvcmNlcy5mb3JFYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogbm9kZXM7XG4gICAgfSxcblxuICAgIGFscGhhOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhO1xuICAgIH0sXG5cbiAgICBhbHBoYU1pbjogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFNaW4gPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYU1pbjtcbiAgICB9LFxuXG4gICAgYWxwaGFEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFEZWNheSA9ICtfLCBzaW11bGF0aW9uKSA6ICthbHBoYURlY2F5O1xuICAgIH0sXG5cbiAgICBhbHBoYVRhcmdldDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFUYXJnZXQgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYVRhcmdldDtcbiAgICB9LFxuXG4gICAgdmVsb2NpdHlEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmVsb2NpdHlEZWNheSA9IDEgLSBfLCBzaW11bGF0aW9uKSA6IDEgLSB2ZWxvY2l0eURlY2F5O1xuICAgIH0sXG5cbiAgICByYW5kb21Tb3VyY2U6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmRvbSA9IF8sIGZvcmNlcy5mb3JFYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogcmFuZG9tO1xuICAgIH0sXG5cbiAgICBmb3JjZTogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKChfID09IG51bGwgPyBmb3JjZXMuZGVsZXRlKG5hbWUpIDogZm9yY2VzLnNldChuYW1lLCBpbml0aWFsaXplRm9yY2UoXykpKSwgc2ltdWxhdGlvbikgOiBmb3JjZXMuZ2V0KG5hbWUpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgIGR4LFxuICAgICAgICAgIGR5LFxuICAgICAgICAgIGQyLFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgY2xvc2VzdDtcblxuICAgICAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgICAgIGVsc2UgcmFkaXVzICo9IHJhZGl1cztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGR4ID0geCAtIG5vZGUueDtcbiAgICAgICAgZHkgPSB5IC0gbm9kZS55O1xuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZDIgPCByYWRpdXMpIGNsb3Nlc3QgPSBub2RlLCByYWRpdXMgPSBkMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoZXZlbnQub24obmFtZSwgXyksIHNpbXVsYXRpb24pIDogZXZlbnQub24obmFtZSk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeHo7XG5cbiAgaWYgKHR5cGVvZiB4ICE9PSBcImZ1bmN0aW9uXCIpIHggPSBjb25zdGFudCh4ID09IG51bGwgPyAwIDogK3gpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eCArPSAoeHpbaV0gLSBub2RlLngpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHh6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHh6W2ldID0gK3gobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeDtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeSkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB5ejtcblxuICBpZiAodHlwZW9mIHkgIT09IFwiZnVuY3Rpb25cIikgeSA9IGNvbnN0YW50KHkgPT0gbnVsbCA/IDAgOiAreSk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ5ICs9ICh5eltpXSAtIG5vZGUueSkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeXogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeXpbaV0gPSAreShub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB5O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCBmb3JtYXRMb2NhbGUgZnJvbSBcIi4vbG9jYWxlLmpzXCI7XG5cbnZhciBsb2NhbGU7XG5leHBvcnQgdmFyIGZvcm1hdDtcbmV4cG9ydCB2YXIgZm9ybWF0UHJlZml4O1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICBmb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBmb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWxQYXJ0cyhNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gTWF0aC5hYnMoeCA9IE1hdGgucm91bmQoeCkpID49IDFlMjFcbiAgICAgID8geC50b0xvY2FsZVN0cmluZyhcImVuXCIpLnJlcGxhY2UoLywvZywgXCJcIilcbiAgICAgIDogeC50b1N0cmluZygxMCk7XG59XG5cbi8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbi8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuLy8gRm9yIGV4YW1wbGUsIGZvcm1hdERlY2ltYWxQYXJ0cygxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICB0ID0gW10sXG4gICAgICAgIGogPSAwLFxuICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1lcmFscykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCB2YXIgcHJlZml4RXhwb25lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV07XG4gIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn1cbiIsIi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cbnZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG4gIHZhciBtYXRjaDtcbiAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoe1xuICAgIGZpbGw6IG1hdGNoWzFdLFxuICAgIGFsaWduOiBtYXRjaFsyXSxcbiAgICBzaWduOiBtYXRjaFszXSxcbiAgICBzeW1ib2w6IG1hdGNoWzRdLFxuICAgIHplcm86IG1hdGNoWzVdLFxuICAgIHdpZHRoOiBtYXRjaFs2XSxcbiAgICBjb21tYTogbWF0Y2hbN10sXG4gICAgcHJlY2lzaW9uOiBtYXRjaFs4XSAmJiBtYXRjaFs4XS5zbGljZSgxKSxcbiAgICB0cmltOiBtYXRjaFs5XSxcbiAgICB0eXBlOiBtYXRjaFsxMF1cbiAgfSk7XG59XG5cbmZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUgPSBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlOyAvLyBpbnN0YW5jZW9mXG5cbmV4cG9ydCBmdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIHRoaXMuZmlsbCA9IHNwZWNpZmllci5maWxsID09PSB1bmRlZmluZWQgPyBcIiBcIiA6IHNwZWNpZmllci5maWxsICsgXCJcIjtcbiAgdGhpcy5hbGlnbiA9IHNwZWNpZmllci5hbGlnbiA9PT0gdW5kZWZpbmVkID8gXCI+XCIgOiBzcGVjaWZpZXIuYWxpZ24gKyBcIlwiO1xuICB0aGlzLnNpZ24gPSBzcGVjaWZpZXIuc2lnbiA9PT0gdW5kZWZpbmVkID8gXCItXCIgOiBzcGVjaWZpZXIuc2lnbiArIFwiXCI7XG4gIHRoaXMuc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci5zeW1ib2wgKyBcIlwiO1xuICB0aGlzLnplcm8gPSAhIXNwZWNpZmllci56ZXJvO1xuICB0aGlzLndpZHRoID0gc3BlY2lmaWVyLndpZHRoID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLndpZHRoO1xuICB0aGlzLmNvbW1hID0gISFzcGVjaWZpZXIuY29tbWE7XG4gIHRoaXMucHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci5wcmVjaXNpb247XG4gIHRoaXMudHJpbSA9ICEhc3BlY2lmaWVyLnRyaW07XG4gIHRoaXMudHlwZSA9IHNwZWNpZmllci50eXBlID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnR5cGUgKyBcIlwiO1xufVxuXG5Gb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICsgdGhpcy5hbGlnblxuICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICArICh0aGlzLnRyaW0gPyBcIn5cIiA6IFwiXCIpXG4gICAgICArIHRoaXMudHlwZTtcbn07XG4iLCIvLyBUcmltcyBpbnNpZ25pZmljYW50IHplcm9zLCBlLmcuLCByZXBsYWNlcyAxLjIwMDBrIHdpdGggMS4yay5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHMpIHtcbiAgb3V0OiBmb3IgKHZhciBuID0gcy5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgIHN3aXRjaCAoc1tpXSkge1xuICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpMCA+IDAgPyBzLnNsaWNlKDAsIGkwKSArIHMuc2xpY2UoaTEgKyAxKSA6IHM7XG59XG4iLCJpbXBvcnQgZm9ybWF0RGVjaW1hbCBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5pbXBvcnQgZm9ybWF0UHJlZml4QXV0byBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgZm9ybWF0Um91bmRlZCBmcm9tIFwiLi9mb3JtYXRSb3VuZGVkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgXCIlXCI6ICh4LCBwKSA9PiAoeCAqIDEwMCkudG9GaXhlZChwKSxcbiAgXCJiXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpLFxuICBcImNcIjogKHgpID0+IHggKyBcIlwiLFxuICBcImRcIjogZm9ybWF0RGVjaW1hbCxcbiAgXCJlXCI6ICh4LCBwKSA9PiB4LnRvRXhwb25lbnRpYWwocCksXG4gIFwiZlwiOiAoeCwgcCkgPT4geC50b0ZpeGVkKHApLFxuICBcImdcIjogKHgsIHApID0+IHgudG9QcmVjaXNpb24ocCksXG4gIFwib1wiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KSxcbiAgXCJwXCI6ICh4LCBwKSA9PiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApLFxuICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gIFwiWFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcbiAgXCJ4XCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcbmltcG9ydCBmb3JtYXRHcm91cCBmcm9tIFwiLi9mb3JtYXRHcm91cC5qc1wiO1xuaW1wb3J0IGZvcm1hdE51bWVyYWxzIGZyb20gXCIuL2Zvcm1hdE51bWVyYWxzLmpzXCI7XG5pbXBvcnQgZm9ybWF0U3BlY2lmaWVyIGZyb20gXCIuL2Zvcm1hdFNwZWNpZmllci5qc1wiO1xuaW1wb3J0IGZvcm1hdFRyaW0gZnJvbSBcIi4vZm9ybWF0VHJpbS5qc1wiO1xuaW1wb3J0IGZvcm1hdFR5cGVzIGZyb20gXCIuL2Zvcm1hdFR5cGVzLmpzXCI7XG5pbXBvcnQge3ByZWZpeEV4cG9uZW50fSBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxudmFyIG1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAsXG4gICAgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihsb2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nID09PSB1bmRlZmluZWQgfHwgbG9jYWxlLnRob3VzYW5kcyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXRHcm91cChtYXAuY2FsbChsb2NhbGUuZ3JvdXBpbmcsIE51bWJlciksIGxvY2FsZS50aG91c2FuZHMgKyBcIlwiKSxcbiAgICAgIGN1cnJlbmN5UHJlZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzBdICsgXCJcIixcbiAgICAgIGN1cnJlbmN5U3VmZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzFdICsgXCJcIixcbiAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCA9PT0gdW5kZWZpbmVkID8gXCIuXCIgOiBsb2NhbGUuZGVjaW1hbCArIFwiXCIsXG4gICAgICBudW1lcmFscyA9IGxvY2FsZS5udW1lcmFscyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXROdW1lcmFscyhtYXAuY2FsbChsb2NhbGUubnVtZXJhbHMsIFN0cmluZykpLFxuICAgICAgcGVyY2VudCA9IGxvY2FsZS5wZXJjZW50ID09PSB1bmRlZmluZWQgPyBcIiVcIiA6IGxvY2FsZS5wZXJjZW50ICsgXCJcIixcbiAgICAgIG1pbnVzID0gbG9jYWxlLm1pbnVzID09PSB1bmRlZmluZWQgPyBcIuKIklwiIDogbG9jYWxlLm1pbnVzICsgXCJcIixcbiAgICAgIG5hbiA9IGxvY2FsZS5uYW4gPT09IHVuZGVmaW5lZCA/IFwiTmFOXCIgOiBsb2NhbGUubmFuICsgXCJcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkICYmIChwcmVjaXNpb24gPSAxMiksIHRyaW0gPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lQcmVmaXggOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVN1ZmZpeCA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XG5cbiAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2XG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgc2lnbi4gLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFsdWUgPSBpc05hTih2YWx1ZSkgPyBuYW4gOiBmb3JtYXRUeXBlKE1hdGguYWJzKHZhbHVlKSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXG4gICAgICAgIGlmICh0cmltKSB2YWx1ZSA9IGZvcm1hdFRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gYWZ0ZXIgZm9ybWF0dGluZywgYW5kIG5vIGV4cGxpY2l0IHBvc2l0aXZlIHNpZ24gaXMgcmVxdWVzdGVkLCBoaWRlIHRoZSBzaWduLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDAgJiYgc2lnbiAhPT0gXCIrXCIpIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBtaW51cykgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgLWV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGVwLCBtYXgpIHtcbiAgc3RlcCA9IE1hdGguYWJzKHN0ZXApLCBtYXggPSBNYXRoLmFicyhtYXgpIC0gc3RlcDtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50KG1heCkgLSBleHBvbmVudChzdGVwKSkgKyAxO1xufVxuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvYTc0ZWVhMjM4ZjViYWJhMTU3OTdlMmU4YjU3MGQxNTNiYzg2OTBhNy9Nb2R1bGVzL21hdGhtb2R1bGUuYyNMMTQyM1xuZXhwb3J0IGNsYXNzIEFkZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGFydGlhbHMgPSBuZXcgRmxvYXQ2NEFycmF5KDMyKTtcbiAgICB0aGlzLl9uID0gMDtcbiAgfVxuICBhZGQoeCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wYXJ0aWFscztcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9uICYmIGogPCAzMjsgaisrKSB7XG4gICAgICBjb25zdCB5ID0gcFtqXSxcbiAgICAgICAgaGkgPSB4ICsgeSxcbiAgICAgICAgbG8gPSBNYXRoLmFicyh4KSA8IE1hdGguYWJzKHkpID8geCAtIChoaSAtIHkpIDogeSAtIChoaSAtIHgpO1xuICAgICAgaWYgKGxvKSBwW2krK10gPSBsbztcbiAgICAgIHggPSBoaTtcbiAgICB9XG4gICAgcFtpXSA9IHg7XG4gICAgdGhpcy5fbiA9IGkgKyAxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhbHVlT2YoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX3BhcnRpYWxzO1xuICAgIGxldCBuID0gdGhpcy5fbiwgeCwgeSwgbG8sIGhpID0gMDtcbiAgICBpZiAobiA+IDApIHtcbiAgICAgIGhpID0gcFstLW5dO1xuICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgIHggPSBoaTtcbiAgICAgICAgeSA9IHBbLS1uXTtcbiAgICAgICAgaGkgPSB4ICsgeTtcbiAgICAgICAgbG8gPSB5IC0gKGhpIC0geCk7XG4gICAgICAgIGlmIChsbykgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobiA+IDAgJiYgKChsbyA8IDAgJiYgcFtuIC0gMV0gPCAwKSB8fCAobG8gPiAwICYmIHBbbiAtIDFdID4gMCkpKSB7XG4gICAgICAgIHkgPSBsbyAqIDI7XG4gICAgICAgIHggPSBoaSArIHk7XG4gICAgICAgIGlmICh5ID09IHggLSBoaSkgaGkgPSB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZzdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGNvbnN0IGFkZGVyID0gbmV3IEFkZGVyKCk7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZSkge1xuICAgICAgICBhZGRlci5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSB7XG4gICAgICAgIGFkZGVyLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiArYWRkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmY3Vtc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBjb25zdCBhZGRlciA9IG5ldyBBZGRlcigpO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgcmV0dXJuIEZsb2F0NjRBcnJheS5mcm9tKHZhbHVlcywgdmFsdWVvZiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHYgPT4gYWRkZXIuYWRkKCt2IHx8IDApXG4gICAgICA6IHYgPT4gYWRkZXIuYWRkKCt2YWx1ZW9mKHYsICsraW5kZXgsIHZhbHVlcykgfHwgMClcbiAgKTtcbn1cbiIsImZ1bmN0aW9uKiBmbGF0dGVuKGFycmF5cykge1xuICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgIHlpZWxkKiBhcnJheTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZmxhdHRlbihhcnJheXMpKTtcbn1cbiIsImltcG9ydCB7YXNpbiwgYXRhbjIsIGNvcywgc2luLCBzcXJ0fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gIHJldHVybiBbYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pLCBhc2luKGNhcnRlc2lhblsyXSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuKHNwaGVyaWNhbCkge1xuICB2YXIgbGFtYmRhID0gc3BoZXJpY2FsWzBdLCBwaGkgPSBzcGhlcmljYWxbMV0sIGNvc1BoaSA9IGNvcyhwaGkpO1xuICByZXR1cm4gW2Nvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgcmV0dXJuIFthWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gYVxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkFkZEluUGxhY2UoYSwgYikge1xuICBhWzBdICs9IGJbMF0sIGFbMV0gKz0gYlsxXSwgYVsyXSArPSBiWzJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuU2NhbGUodmVjdG9yLCBrKSB7XG4gIHJldHVybiBbdmVjdG9yWzBdICogaywgdmVjdG9yWzFdICogaywgdmVjdG9yWzJdICoga107XG59XG5cbi8vIFRPRE8gcmV0dXJuIGRcbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGQpIHtcbiAgdmFyIGwgPSBzcXJ0KGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV0gKyBkWzJdICogZFsyXSk7XG4gIGRbMF0gLz0gbCwgZFsxXSAvPSBsLCBkWzJdIC89IGw7XG59XG4iLCJpbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZSwgc3BoZXJpY2FsfSBmcm9tIFwiLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHthY29zLCBjb3MsIGRlZ3JlZXMsIGVwc2lsb24sIHJhZGlhbnMsIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQge3JvdGF0ZVJhZGlhbnN9IGZyb20gXCIuL3JvdGF0aW9uLmpzXCI7XG5cbi8vIEdlbmVyYXRlcyBhIGNpcmNsZSBjZW50ZXJlZCBhdCBbMMKwLCAwwrBdLCB3aXRoIGEgZ2l2ZW4gcmFkaXVzIGFuZCBwcmVjaXNpb24uXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCB0MCwgdDEpIHtcbiAgaWYgKCFkZWx0YSkgcmV0dXJuO1xuICB2YXIgY29zUmFkaXVzID0gY29zKHJhZGl1cyksXG4gICAgICBzaW5SYWRpdXMgPSBzaW4ocmFkaXVzKSxcbiAgICAgIHN0ZXAgPSBkaXJlY3Rpb24gKiBkZWx0YTtcbiAgaWYgKHQwID09IG51bGwpIHtcbiAgICB0MCA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIHRhdTtcbiAgICB0MSA9IHJhZGl1cyAtIHN0ZXAgLyAyO1xuICB9IGVsc2Uge1xuICAgIHQwID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDApO1xuICAgIHQxID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDEpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwID8gdDAgPCB0MSA6IHQwID4gdDEpIHQwICs9IGRpcmVjdGlvbiAqIHRhdTtcbiAgfVxuICBmb3IgKHZhciBwb2ludCwgdCA9IHQwOyBkaXJlY3Rpb24gPiAwID8gdCA+IHQxIDogdCA8IHQxOyB0IC09IHN0ZXApIHtcbiAgICBwb2ludCA9IHNwaGVyaWNhbChbY29zUmFkaXVzLCAtc2luUmFkaXVzICogY29zKHQpLCAtc2luUmFkaXVzICogc2luKHQpXSk7XG4gICAgc3RyZWFtLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgc2lnbmVkIGFuZ2xlIG9mIGEgY2FydGVzaWFuIHBvaW50IHJlbGF0aXZlIHRvIFtjb3NSYWRpdXMsIDAsIDBdLlxuZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcbiAgcG9pbnQgPSBjYXJ0ZXNpYW4ocG9pbnQpLCBwb2ludFswXSAtPSBjb3NSYWRpdXM7XG4gIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UocG9pbnQpO1xuICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xuICByZXR1cm4gKCgtcG9pbnRbMl0gPCAwID8gLXJhZGl1cyA6IHJhZGl1cykgKyB0YXUgLSBlcHNpbG9uKSAlIHRhdTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjZW50ZXIgPSBjb25zdGFudChbMCwgMF0pLFxuICAgICAgcmFkaXVzID0gY29uc3RhbnQoOTApLFxuICAgICAgcHJlY2lzaW9uID0gY29uc3RhbnQoNiksXG4gICAgICByaW5nLFxuICAgICAgcm90YXRlLFxuICAgICAgc3RyZWFtID0ge3BvaW50OiBwb2ludH07XG5cbiAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICB4WzBdICo9IGRlZ3JlZXMsIHhbMV0gKj0gZGVncmVlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICB2YXIgYyA9IGNlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByID0gcmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zLFxuICAgICAgICBwID0gcHJlY2lzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zO1xuICAgIHJpbmcgPSBbXTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKC1jWzBdICogcmFkaWFucywgLWNbMV0gKiByYWRpYW5zLCAwKS5pbnZlcnQ7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgciwgcCwgMSk7XG4gICAgYyA9IHt0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtyaW5nXX07XG4gICAgcmluZyA9IHJvdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBjaXJjbGUuY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoWytfWzBdLCArX1sxXV0pLCBjaXJjbGUpIDogY2VudGVyO1xuICB9O1xuXG4gIGNpcmNsZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjaXNpb24gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHByZWNpc2lvbjtcbiAgfTtcblxuICByZXR1cm4gY2lyY2xlO1xufVxuIiwiaW1wb3J0IGNsaXAgZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7YWJzLCBhdGFuLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgcGksIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xpcChcbiAgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICBjbGlwQW50aW1lcmlkaWFuTGluZSxcbiAgY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLFxuICBbLXBpLCAtaGFsZlBpXVxuKTtcblxuLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlczogMCAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm8gaW50ZXJzZWN0aW9uczsgMiAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgc2hvdWxkIGJlIHJlam9pbmVkLlxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkxpbmUoc3RyZWFtKSB7XG4gIHZhciBsYW1iZGEwID0gTmFOLFxuICAgICAgcGhpMCA9IE5hTixcbiAgICAgIHNpZ24wID0gTmFOLFxuICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcblxuICByZXR1cm4ge1xuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICBjbGVhbiA9IDE7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhMSwgcGhpMSkge1xuICAgICAgdmFyIHNpZ24xID0gbGFtYmRhMSA+IDAgPyBwaSA6IC1waSxcbiAgICAgICAgICBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XG4gICAgICBpZiAoYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbikgeyAvLyBsaW5lIGNyb3NzZXMgYSBwb2xlXG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwLCBwaGkwID0gKHBoaTAgKyBwaGkxKSAvIDIgPiAwID8gaGFsZlBpIDogLWhhbGZQaSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24wICE9PSBzaWduMSAmJiBkZWx0YSA+PSBwaSkgeyAvLyBsaW5lIGNyb3NzZXMgYW50aW1lcmlkaWFuXG4gICAgICAgIGlmIChhYnMobGFtYmRhMCAtIHNpZ24wKSA8IGVwc2lsb24pIGxhbWJkYTAgLT0gc2lnbjAgKiBlcHNpbG9uOyAvLyBoYW5kbGUgZGVnZW5lcmFjaWVzXG4gICAgICAgIGlmIChhYnMobGFtYmRhMSAtIHNpZ24xKSA8IGVwc2lsb24pIGxhbWJkYTEgLT0gc2lnbjEgKiBlcHNpbG9uO1xuICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9XG4gICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCA9IGxhbWJkYTEsIHBoaTAgPSBwaGkxKTtcbiAgICAgIHNpZ24wID0gc2lnbjE7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICBsYW1iZGEwID0gcGhpMCA9IE5hTjtcbiAgICB9LFxuICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAyIC0gY2xlYW47IC8vIGlmIGludGVyc2VjdGlvbnMsIHJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKSB7XG4gIHZhciBjb3NQaGkwLFxuICAgICAgY29zUGhpMSxcbiAgICAgIHNpbkxhbWJkYTBMYW1iZGExID0gc2luKGxhbWJkYTAgLSBsYW1iZGExKTtcbiAgcmV0dXJuIGFicyhzaW5MYW1iZGEwTGFtYmRhMSkgPiBlcHNpbG9uXG4gICAgICA/IGF0YW4oKHNpbihwaGkwKSAqIChjb3NQaGkxID0gY29zKHBoaTEpKSAqIHNpbihsYW1iZGExKVxuICAgICAgICAgIC0gc2luKHBoaTEpICogKGNvc1BoaTAgPSBjb3MocGhpMCkpICogc2luKGxhbWJkYTApKVxuICAgICAgICAgIC8gKGNvc1BoaTAgKiBjb3NQaGkxICogc2luTGFtYmRhMExhbWJkYTEpKVxuICAgICAgOiAocGhpMCArIHBoaTEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICB2YXIgcGhpO1xuICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgcGhpID0gZGlyZWN0aW9uICogaGFsZlBpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgfSBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IGVwc2lsb24pIHtcbiAgICB2YXIgbGFtYmRhID0gZnJvbVswXSA8IHRvWzBdID8gcGkgOiAtcGk7XG4gICAgcGhpID0gZGlyZWN0aW9uICogbGFtYmRhIC8gMjtcbiAgICBzdHJlYW0ucG9pbnQoLWxhbWJkYSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICB9XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmVzID0gW10sXG4gICAgICBsaW5lO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5LCBtKSB7XG4gICAgICBsaW5lLnB1c2goW3gsIHksIG1dKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBub29wLFxuICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsaW5lcztcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBsaW5lID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbkFkZEluUGxhY2UsIGNhcnRlc2lhbkNyb3NzLCBjYXJ0ZXNpYW5Eb3QsIGNhcnRlc2lhblNjYWxlLCBzcGhlcmljYWx9IGZyb20gXCIuLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7Y2lyY2xlU3RyZWFtfSBmcm9tIFwiLi4vY2lyY2xlLmpzXCI7XG5pbXBvcnQge2FicywgY29zLCBlcHNpbG9uLCBwaSwgcmFkaWFucywgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBwb2ludEVxdWFsIGZyb20gXCIuLi9wb2ludEVxdWFsLmpzXCI7XG5pbXBvcnQgY2xpcCBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIGNyID0gY29zKHJhZGl1cyksXG4gICAgICBkZWx0YSA9IDYgKiByYWRpYW5zLFxuICAgICAgc21hbGxSYWRpdXMgPSBjciA+IDAsXG4gICAgICBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IGVwc2lsb247IC8vIFRPRE8gb3B0aW1pc2UgZm9yIHRoaXMgY29tbW9uIGNhc2VcblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIGZyb20sIHRvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGUobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gY29zKGxhbWJkYSkgKiBjb3MocGhpKSA+IGNyO1xuICB9XG5cbiAgLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlcyB1c2VkIGZvciBwb2x5Z29uXG4gIC8vIGNsaXBwaW5nOiAwIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vXG4gIC8vIGludGVyc2VjdGlvbnMgMiAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAvLyBzaG91bGQgYmUgcmVqb2luZWQuXG4gIGZ1bmN0aW9uIGNsaXBMaW5lKHN0cmVhbSkge1xuICAgIHZhciBwb2ludDAsIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGMwLCAvLyBjb2RlIGZvciBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MCwgLy8gdmlzaWJpbGl0eSBvZiBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MDAsIC8vIHZpc2liaWxpdHkgb2YgZmlyc3QgcG9pbnRcbiAgICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgcG9pbnQxID0gW2xhbWJkYSwgcGhpXSxcbiAgICAgICAgICAgIHBvaW50MixcbiAgICAgICAgICAgIHYgPSB2aXNpYmxlKGxhbWJkYSwgcGhpKSxcbiAgICAgICAgICAgIGMgPSBzbWFsbFJhZGl1c1xuICAgICAgICAgICAgICA/IHYgPyAwIDogY29kZShsYW1iZGEsIHBoaSlcbiAgICAgICAgICAgICAgOiB2ID8gY29kZShsYW1iZGEgKyAobGFtYmRhIDwgMCA/IHBpIDogLXBpKSwgcGhpKSA6IDA7XG4gICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgaWYgKCFwb2ludDIgfHwgcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MikgfHwgcG9pbnRFcXVhbChwb2ludDEsIHBvaW50MikpXG4gICAgICAgICAgICBwb2ludDFbMl0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgLy8gb3V0c2lkZSBnb2luZyBpblxuICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2lkZSBnb2luZyBvdXRcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0sIDIpO1xuICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgIHZhciB0O1xuICAgICAgICAgIC8vIElmIHRoZSBjb2RlcyBmb3IgdHdvIHBvaW50cyBhcmUgZGlmZmVyZW50LCBvciBhcmUgYm90aCB6ZXJvLFxuICAgICAgICAgIC8vIGFuZCB0aGVyZSB0aGlzIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzbWFsbCBjaXJjbGUuXG4gICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2MCkgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIGFuZCBsYXN0IHBvaW50cyB3ZXJlIHZpc2libGUuXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJzZWN0cyB0aGUgZ3JlYXQgY2lyY2xlIGJldHdlZW4gYSBhbmQgYiB3aXRoIHRoZSBjbGlwIGNpcmNsZS5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgIHZhciBwYSA9IGNhcnRlc2lhbihhKSxcbiAgICAgICAgcGIgPSBjYXJ0ZXNpYW4oYik7XG5cbiAgICAvLyBXZSBoYXZlIHR3byBwbGFuZXMsIG4xLnAgPSBkMSBhbmQgbjIucCA9IGQyLlxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIGxpbmUgcCh0KSA9IGMxIG4xICsgYzIgbjIgKyB0IChuMSDiqK8gbjIpLlxuICAgIHZhciBuMSA9IFsxLCAwLCAwXSwgLy8gbm9ybWFsXG4gICAgICAgIG4yID0gY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSxcbiAgICAgICAgbjJuMiA9IGNhcnRlc2lhbkRvdChuMiwgbjIpLFxuICAgICAgICBuMW4yID0gbjJbMF0sIC8vIGNhcnRlc2lhbkRvdChuMSwgbjIpLFxuICAgICAgICBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcblxuICAgIC8vIFR3byBwb2xhciBwb2ludHMuXG4gICAgaWYgKCFkZXRlcm1pbmFudCkgcmV0dXJuICF0d28gJiYgYTtcblxuICAgIHZhciBjMSA9ICBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIG4xeG4yID0gY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSxcbiAgICAgICAgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksXG4gICAgICAgIEIgPSBjYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UoQSwgQik7XG5cbiAgICAvLyBTb2x2ZSB8cCh0KXxeMiA9IDEuXG4gICAgdmFyIHUgPSBuMXhuMixcbiAgICAgICAgdyA9IGNhcnRlc2lhbkRvdChBLCB1KSxcbiAgICAgICAgdXUgPSBjYXJ0ZXNpYW5Eb3QodSwgdSksXG4gICAgICAgIHQyID0gdyAqIHcgLSB1dSAqIChjYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcblxuICAgIGlmICh0MiA8IDApIHJldHVybjtcblxuICAgIHZhciB0ID0gc3FydCh0MiksXG4gICAgICAgIHEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHEsIEEpO1xuICAgIHEgPSBzcGhlcmljYWwocSk7XG5cbiAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG5cbiAgICAvLyBUd28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICB2YXIgbGFtYmRhMCA9IGFbMF0sXG4gICAgICAgIGxhbWJkYTEgPSBiWzBdLFxuICAgICAgICBwaGkwID0gYVsxXSxcbiAgICAgICAgcGhpMSA9IGJbMV0sXG4gICAgICAgIHo7XG5cbiAgICBpZiAobGFtYmRhMSA8IGxhbWJkYTApIHogPSBsYW1iZGEwLCBsYW1iZGEwID0gbGFtYmRhMSwgbGFtYmRhMSA9IHo7XG5cbiAgICB2YXIgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgcG9sYXIgPSBhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uLFxuICAgICAgICBtZXJpZGlhbiA9IHBvbGFyIHx8IGRlbHRhIDwgZXBzaWxvbjtcblxuICAgIGlmICghcG9sYXIgJiYgcGhpMSA8IHBoaTApIHogPSBwaGkwLCBwaGkwID0gcGhpMSwgcGhpMSA9IHo7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBwb2ludCBpcyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgaWYgKG1lcmlkaWFuXG4gICAgICAgID8gcG9sYXJcbiAgICAgICAgICA/IHBoaTAgKyBwaGkxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSBsYW1iZGEwKSA8IGVwc2lsb24gPyBwaGkwIDogcGhpMSlcbiAgICAgICAgICA6IHBoaTAgPD0gcVsxXSAmJiBxWzFdIDw9IHBoaTFcbiAgICAgICAgOiBkZWx0YSA+IHBpIF4gKGxhbWJkYTAgPD0gcVswXSAmJiBxWzBdIDw9IGxhbWJkYTEpKSB7XG4gICAgICB2YXIgcTEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocTEsIEEpO1xuICAgICAgcmV0dXJuIFtxLCBzcGhlcmljYWwocTEpXTtcbiAgICB9XG4gIH1cblxuICAvLyBHZW5lcmF0ZXMgYSA0LWJpdCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IHJlbGF0aXZlIHRvXG4gIC8vIHRoZSBzbWFsbCBjaXJjbGUncyBib3VuZGluZyBib3guXG4gIGZ1bmN0aW9uIGNvZGUobGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogcGkgLSByYWRpdXMsXG4gICAgICAgIGNvZGUgPSAwO1xuICAgIGlmIChsYW1iZGEgPCAtcikgY29kZSB8PSAxOyAvLyBsZWZ0XG4gICAgZWxzZSBpZiAobGFtYmRhID4gcikgY29kZSB8PSAyOyAvLyByaWdodFxuICAgIGlmIChwaGkgPCAtcikgY29kZSB8PSA0OyAvLyBiZWxvd1xuICAgIGVsc2UgaWYgKHBoaSA+IHIpIGNvZGUgfD0gODsgLy8gYWJvdmVcbiAgICByZXR1cm4gY29kZTtcbiAgfVxuXG4gIHJldHVybiBjbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbMCwgLXJhZGl1c10gOiBbLXBpLCByYWRpdXMgLSBwaV0pO1xufVxuIiwiaW1wb3J0IGNsaXBCdWZmZXIgZnJvbSBcIi4vYnVmZmVyLmpzXCI7XG5pbXBvcnQgY2xpcFJlam9pbiBmcm9tIFwiLi9yZWpvaW4uanNcIjtcbmltcG9ydCB7ZXBzaWxvbiwgaGFsZlBpfSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHBvbHlnb25Db250YWlucyBmcm9tIFwiLi4vcG9seWdvbkNvbnRhaW5zLmpzXCI7XG5pbXBvcnQge21lcmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHN0YXJ0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzaW5rKSB7XG4gICAgdmFyIGxpbmUgPSBjbGlwTGluZShzaW5rKSxcbiAgICAgICAgcmluZ0J1ZmZlciA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgcmluZ1NpbmsgPSBjbGlwTGluZShyaW5nQnVmZmVyKSxcbiAgICAgICAgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHJpbmc7XG5cbiAgICB2YXIgY2xpcCA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uQ29udGFpbnMocG9seWdvbiwgc3RhcnQpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc2luayk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgc2luay5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBpZiAocG9pbnRWaXNpYmxlKGxhbWJkYSwgcGhpKSkgc2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgbGluZS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRSaW5nKGxhbWJkYSwgcGhpKSB7XG4gICAgICByaW5nLnB1c2goW2xhbWJkYSwgcGhpXSk7XG4gICAgICByaW5nU2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgcmluZ1NpbmsubGluZVN0YXJ0KCk7XG4gICAgICByaW5nID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgIHJpbmdTaW5rLmxpbmVFbmQoKTtcblxuICAgICAgdmFyIGNsZWFuID0gcmluZ1NpbmsuY2xlYW4oKSxcbiAgICAgICAgICByaW5nU2VnbWVudHMgPSByaW5nQnVmZmVyLnJlc3VsdCgpLFxuICAgICAgICAgIGksIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoLCBtLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgcG9pbnQ7XG5cbiAgICAgIHJpbmcucG9wKCk7XG4gICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICByaW5nID0gbnVsbDtcblxuICAgICAgaWYgKCFuKSByZXR1cm47XG5cbiAgICAgIC8vIE5vIGludGVyc2VjdGlvbnMuXG4gICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgIGlmICgobSA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPiAwKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc2luay5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVqb2luIGNvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgIC8vIFRPRE8gcmV1c2UgcmluZ0J1ZmZlci5yZWpvaW4oKT9cbiAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcblxuICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKHZhbGlkU2VnbWVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudC5sZW5ndGggPiAxO1xufVxuXG4vLyBJbnRlcnNlY3Rpb25zIGFyZSBzb3J0ZWQgYWxvbmcgdGhlIGNsaXAgZWRnZS4gRm9yIGJvdGggYW50aW1lcmlkaWFuIGN1dHRpbmdcbi8vIGFuZCBjaXJjbGUgY2xpcHBpbmcsIHRoZSBzYW1lIGNvbXBhcmlzb24gaXMgdXNlZC5cbmZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGFbMV0pXG4gICAgICAgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYlsxXSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgdDAgPSAwLFxuICAgICAgdDEgPSAxLFxuICAgICAgZHggPSBieCAtIGF4LFxuICAgICAgZHkgPSBieSAtIGF5LFxuICAgICAgcjtcblxuICByID0geDAgLSBheDtcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHgxIC0gYXg7XG4gIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIHIgPSB5MCAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geTEgLSBheTtcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgaWYgKHQwID4gMCkgYVswXSA9IGF4ICsgdDAgKiBkeCwgYVsxXSA9IGF5ICsgdDAgKiBkeTtcbiAgaWYgKHQxIDwgMSkgYlswXSA9IGF4ICsgdDEgKiBkeCwgYlsxXSA9IGF5ICsgdDEgKiBkeTtcbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBjbGlwQnVmZmVyIGZyb20gXCIuL2J1ZmZlci5qc1wiO1xuaW1wb3J0IGNsaXBMaW5lIGZyb20gXCIuL2xpbmUuanNcIjtcbmltcG9ydCBjbGlwUmVqb2luIGZyb20gXCIuL3Jlam9pbi5qc1wiO1xuaW1wb3J0IHttZXJnZX0gZnJvbSBcImQzLWFycmF5XCI7XG5cbnZhciBjbGlwTWF4ID0gMWU5LCBjbGlwTWluID0gLWNsaXBNYXg7XG5cbi8vIFRPRE8gVXNlIGQzLXBvbHlnb27igJlzIHBvbHlnb25Db250YWlucyBoZXJlIGZvciB0aGUgcmluZyBjaGVjaz9cbi8vIFRPRE8gRWxpbWluYXRlIGR1cGxpY2F0ZSBidWZmZXJpbmcgaW4gY2xpcEJ1ZmZlciBhbmQgcG9seWdvbi5wdXNoP1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjbGlwUmVjdGFuZ2xlKHgwLCB5MCwgeDEsIHkxKSB7XG5cbiAgZnVuY3Rpb24gdmlzaWJsZSh4LCB5KSB7XG4gICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICB2YXIgYSA9IDAsIGExID0gMDtcbiAgICBpZiAoZnJvbSA9PSBudWxsXG4gICAgICAgIHx8IChhID0gY29ybmVyKGZyb20sIGRpcmVjdGlvbikpICE9PSAoYTEgPSBjb3JuZXIodG8sIGRpcmVjdGlvbikpXG4gICAgICAgIHx8IGNvbXBhcmVQb2ludChmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgZG8gc3RyZWFtLnBvaW50KGEgPT09IDAgfHwgYSA9PT0gMyA/IHgwIDogeDEsIGEgPiAxID8geTEgOiB5MCk7XG4gICAgICB3aGlsZSAoKGEgPSAoYSArIGRpcmVjdGlvbiArIDQpICUgNCkgIT09IGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBhYnMocFswXSAtIHgwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMCA6IDNcbiAgICAgICAgOiBhYnMocFswXSAtIHgxKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMiA6IDFcbiAgICAgICAgOiBhYnMocFsxXSAtIHkwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMSA6IDBcbiAgICAgICAgOiBkaXJlY3Rpb24gPiAwID8gMyA6IDI7IC8vIGFicyhwWzFdIC0geTEpIDwgZXBzaWxvblxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVQb2ludChhLngsIGIueCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlUG9pbnQoYSwgYikge1xuICAgIHZhciBjYSA9IGNvcm5lcihhLCAxKSxcbiAgICAgICAgY2IgPSBjb3JuZXIoYiwgMSk7XG4gICAgcmV0dXJuIGNhICE9PSBjYiA/IGNhIC0gY2JcbiAgICAgICAgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdXG4gICAgICAgIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXVxuICAgICAgICA6IGNhID09PSAyID8gYVsxXSAtIGJbMV1cbiAgICAgICAgOiBiWzBdIC0gYVswXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgYWN0aXZlU3RyZWFtID0gc3RyZWFtLFxuICAgICAgICBidWZmZXJTdHJlYW0gPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICByaW5nLFxuICAgICAgICB4X18sIHlfXywgdl9fLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICB4XywgeV8sIHZfLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICBmaXJzdCxcbiAgICAgICAgY2xlYW47XG5cbiAgICB2YXIgY2xpcFN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogcG9seWdvblN0YXJ0LFxuICAgICAgcG9seWdvbkVuZDogcG9seWdvbkVuZFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBpZiAodmlzaWJsZSh4LCB5KSkgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25JbnNpZGUoKSB7XG4gICAgICB2YXIgd2luZGluZyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgcmluZyA9IHBvbHlnb25baV0sIGogPSAxLCBtID0gcmluZy5sZW5ndGgsIHBvaW50ID0gcmluZ1swXSwgYTAsIGExLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgYTAgPSBiMCwgYTEgPSBiMSwgcG9pbnQgPSByaW5nW2pdLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdO1xuICAgICAgICAgIGlmIChhMSA8PSB5MSkgeyBpZiAoYjEgPiB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPiAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpICsrd2luZGluZzsgfVxuICAgICAgICAgIGVsc2UgeyBpZiAoYjEgPD0geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpIDwgKGIxIC0gYTEpICogKHgwIC0gYTApKSAtLXdpbmRpbmc7IH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2luZGluZztcbiAgICB9XG5cbiAgICAvLyBCdWZmZXIgZ2VvbWV0cnkgd2l0aGluIGEgcG9seWdvbiBhbmQgdGhlbiBjbGlwIGl0IGVuIG1hc3NlLlxuICAgIGZ1bmN0aW9uIHBvbHlnb25TdGFydCgpIHtcbiAgICAgIGFjdGl2ZVN0cmVhbSA9IGJ1ZmZlclN0cmVhbSwgc2VnbWVudHMgPSBbXSwgcG9seWdvbiA9IFtdLCBjbGVhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkVuZCgpIHtcbiAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25JbnNpZGUoKSxcbiAgICAgICAgICBjbGVhbkluc2lkZSA9IGNsZWFuICYmIHN0YXJ0SW5zaWRlLFxuICAgICAgICAgIHZpc2libGUgPSAoc2VnbWVudHMgPSBtZXJnZShzZWdtZW50cykpLmxlbmd0aDtcbiAgICAgIGlmIChjbGVhbkluc2lkZSB8fCB2aXNpYmxlKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgaWYgKGNsZWFuSW5zaWRlKSB7XG4gICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHN0cmVhbSk7XG4gICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgICAgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgdl8gPSBmYWxzZTtcbiAgICAgIHhfID0geV8gPSBOYU47XG4gICAgfVxuXG4gICAgLy8gVE9ETyByYXRoZXIgdGhhbiBzcGVjaWFsLWNhc2UgcG9seWdvbnMsIHNpbXBseSBoYW5kbGUgdGhlbSBzZXBhcmF0ZWx5LlxuICAgIC8vIElkZWFsbHksIGNvaW5jaWRlbnQgaW50ZXJzZWN0aW9uIHBvaW50cyBzaG91bGQgYmUgaml0dGVyZWQgdG8gYXZvaWRcbiAgICAvLyBjbGlwcGluZyBpc3N1ZXMuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICBpZiAodl9fICYmIHZfKSBidWZmZXJTdHJlYW0ucmVqb2luKCk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyU3RyZWFtLnJlc3VsdCgpKTtcbiAgICAgIH1cbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIGlmICh2XykgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgdmFyIHYgPSB2aXNpYmxlKHgsIHkpO1xuICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbeCwgeV0pO1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgJiYgdl8pIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGEgPSBbeF8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4XykpLCB5XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHlfKSldLFxuICAgICAgICAgICAgICBiID0gW3ggPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4KSksIHkgPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5KSldO1xuICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcbiAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYVswXSwgYVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYlswXSwgYlsxXSk7XG4gICAgICAgICAgICBpZiAoIXYpIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBTdHJlYW07XG4gIH07XG59XG4iLCJpbXBvcnQgcG9pbnRFcXVhbCBmcm9tIFwiLi4vcG9pbnRFcXVhbC5qc1wiO1xuaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gIHRoaXMueCA9IHBvaW50O1xuICB0aGlzLnogPSBwb2ludHM7XG4gIHRoaXMubyA9IG90aGVyOyAvLyBhbm90aGVyIGludGVyc2VjdGlvblxuICB0aGlzLmUgPSBlbnRyeTsgLy8gaXMgYW4gZW50cnk/XG4gIHRoaXMudiA9IGZhbHNlOyAvLyB2aXNpdGVkXG4gIHRoaXMubiA9IHRoaXMucCA9IG51bGw7IC8vIG5leHQgJiBwcmV2aW91c1xufVxuXG4vLyBBIGdlbmVyYWxpemVkIHBvbHlnb24gY2xpcHBpbmcgYWxnb3JpdGhtOiBnaXZlbiBhIHBvbHlnb24gdGhhdCBoYXMgYmVlbiBjdXRcbi8vIGludG8gaXRzIHZpc2libGUgbGluZSBzZWdtZW50cywgYW5kIHJlam9pbnMgdGhlIHNlZ21lbnRzIGJ5IGludGVycG9sYXRpbmdcbi8vIGFsb25nIHRoZSBjbGlwIGVkZ2UuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pIHtcbiAgdmFyIHN1YmplY3QgPSBbXSxcbiAgICAgIGNsaXAgPSBbXSxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMCkgcmV0dXJuO1xuICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXSwgeDtcblxuICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgIGlmICghcDBbMl0gJiYgIXAxWzJdKSB7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBkZWdlbmVyYXRlIGNhc2VzIGJ5IG1vdmluZyB0aGUgcG9pbnRcbiAgICAgIHAxWzBdICs9IDIgKiBlcHNpbG9uO1xuICAgIH1cblxuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBudWxsLCB4LCBmYWxzZSkpO1xuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMSwgc2VnbWVudCwgbnVsbCwgZmFsc2UpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMSwgbnVsbCwgeCwgdHJ1ZSkpO1xuICB9KTtcblxuICBpZiAoIXN1YmplY3QubGVuZ3RoKSByZXR1cm47XG5cbiAgY2xpcC5zb3J0KGNvbXBhcmVJbnRlcnNlY3Rpb24pO1xuICBsaW5rKHN1YmplY3QpO1xuICBsaW5rKGNsaXApO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNsaXBbaV0uZSA9IHN0YXJ0SW5zaWRlID0gIXN0YXJ0SW5zaWRlO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvaW50O1xuXG4gIHdoaWxlICgxKSB7XG4gICAgLy8gRmluZCBmaXJzdCB1bnZpc2l0ZWQgaW50ZXJzZWN0aW9uLlxuICAgIHZhciBjdXJyZW50ID0gc3RhcnQsXG4gICAgICAgIGlzU3ViamVjdCA9IHRydWU7XG4gICAgd2hpbGUgKGN1cnJlbnQudikgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpIHJldHVybjtcbiAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICBmb3IgKGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGluayhhcnJheSkge1xuICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgYSA9IGFycmF5WzBdLFxuICAgICAgYjtcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgYi5wID0gYTtcbiAgICBhID0gYjtcbiAgfVxuICBhLm4gPSBiID0gYXJyYXlbMF07XG4gIGIucCA9IGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG5cbiAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xuICB9XG5cbiAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KSBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICB9O1xuXG4gIHJldHVybiBjb21wb3NlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+IHg7XG4iLCJleHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuZXhwb3J0IHZhciB0YXUgPSBwaSAqIDI7XG5cbmV4cG9ydCB2YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xuZXhwb3J0IHZhciByYWRpYW5zID0gcGkgLyAxODA7XG5cbmV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG5leHBvcnQgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCB2YXIgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5leHBvcnQgdmFyIGV4cCA9IE1hdGguZXhwO1xuZXhwb3J0IHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5leHBvcnQgdmFyIGh5cG90ID0gTWF0aC5oeXBvdDtcbmV4cG9ydCB2YXIgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgdmFyIHBvdyA9IE1hdGgucG93O1xuZXhwb3J0IHZhciBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbmV4cG9ydCB2YXIgc3FydCA9IE1hdGguc3FydDtcbmV4cG9ydCB2YXIgdGFuID0gTWF0aC50YW47XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXZlcnNpbih4KSB7XG4gIHJldHVybiAoeCA9IHNpbih4IC8gMikpICogeDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIHgwID0gSW5maW5pdHksXG4gICAgeTAgPSB4MCxcbiAgICB4MSA9IC14MCxcbiAgICB5MSA9IHgxO1xuXG52YXIgYm91bmRzU3RyZWFtID0ge1xuICBwb2ludDogYm91bmRzUG9pbnQsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBub29wLFxuICBwb2x5Z29uRW5kOiBub29wLFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib3VuZHMgPSBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB4MSA9IHkxID0gLSh5MCA9IHgwID0gSW5maW5pdHkpO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJvdW5kc1BvaW50KHgsIHkpIHtcbiAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gIGlmICh5IDwgeTApIHkwID0geTtcbiAgaWYgKHkgPiB5MSkgeTEgPSB5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBib3VuZHNTdHJlYW07XG4iLCJpbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbjtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbkNyb3NzLCBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlfSBmcm9tIFwiLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBlcHNpbG9uMiwgaGFsZlBpLCBwaSwgcXVhcnRlclBpLCBzaWduLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBsb25naXR1ZGUocG9pbnQpIHtcbiAgaWYgKGFicyhwb2ludFswXSkgPD0gcGkpXG4gICAgcmV0dXJuIHBvaW50WzBdO1xuICBlbHNlXG4gICAgcmV0dXJuIHNpZ24ocG9pbnRbMF0pICogKChhYnMocG9pbnRbMF0pICsgcGkpICUgdGF1IC0gcGkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwb2x5Z29uLCBwb2ludCkge1xuICB2YXIgbGFtYmRhID0gbG9uZ2l0dWRlKHBvaW50KSxcbiAgICAgIHBoaSA9IHBvaW50WzFdLFxuICAgICAgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBub3JtYWwgPSBbc2luKGxhbWJkYSksIC1jb3MobGFtYmRhKSwgMF0sXG4gICAgICBhbmdsZSA9IDAsXG4gICAgICB3aW5kaW5nID0gMDtcblxuICB2YXIgc3VtID0gbmV3IEFkZGVyKCk7XG5cbiAgaWYgKHNpblBoaSA9PT0gMSkgcGhpID0gaGFsZlBpICsgZXBzaWxvbjtcbiAgZWxzZSBpZiAoc2luUGhpID09PSAtMSkgcGhpID0gLWhhbGZQaSAtIGVwc2lsb247XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKG0gPSAocmluZyA9IHBvbHlnb25baV0pLmxlbmd0aCkpIGNvbnRpbnVlO1xuICAgIHZhciByaW5nLFxuICAgICAgICBtLFxuICAgICAgICBwb2ludDAgPSByaW5nW20gLSAxXSxcbiAgICAgICAgbGFtYmRhMCA9IGxvbmdpdHVkZShwb2ludDApLFxuICAgICAgICBwaGkwID0gcG9pbnQwWzFdIC8gMiArIHF1YXJ0ZXJQaSxcbiAgICAgICAgc2luUGhpMCA9IHNpbihwaGkwKSxcbiAgICAgICAgY29zUGhpMCA9IGNvcyhwaGkwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqLCBsYW1iZGEwID0gbGFtYmRhMSwgc2luUGhpMCA9IHNpblBoaTEsIGNvc1BoaTAgPSBjb3NQaGkxLCBwb2ludDAgPSBwb2ludDEpIHtcbiAgICAgIHZhciBwb2ludDEgPSByaW5nW2pdLFxuICAgICAgICAgIGxhbWJkYTEgPSBsb25naXR1ZGUocG9pbnQxKSxcbiAgICAgICAgICBwaGkxID0gcG9pbnQxWzFdIC8gMiArIHF1YXJ0ZXJQaSxcbiAgICAgICAgICBzaW5QaGkxID0gc2luKHBoaTEpLFxuICAgICAgICAgIGNvc1BoaTEgPSBjb3MocGhpMSksXG4gICAgICAgICAgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgICBzaWduID0gZGVsdGEgPj0gMCA/IDEgOiAtMSxcbiAgICAgICAgICBhYnNEZWx0YSA9IHNpZ24gKiBkZWx0YSxcbiAgICAgICAgICBhbnRpbWVyaWRpYW4gPSBhYnNEZWx0YSA+IHBpLFxuICAgICAgICAgIGsgPSBzaW5QaGkwICogc2luUGhpMTtcblxuICAgICAgc3VtLmFkZChhdGFuMihrICogc2lnbiAqIHNpbihhYnNEZWx0YSksIGNvc1BoaTAgKiBjb3NQaGkxICsgayAqIGNvcyhhYnNEZWx0YSkpKTtcbiAgICAgIGFuZ2xlICs9IGFudGltZXJpZGlhbiA/IGRlbHRhICsgc2lnbiAqIHRhdSA6IGRlbHRhO1xuXG4gICAgICAvLyBBcmUgdGhlIGxvbmdpdHVkZXMgZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW504oCZcyBtZXJpZGlhbiAobGFtYmRhKSxcbiAgICAgIC8vIGFuZCBhcmUgdGhlIGxhdGl0dWRlcyBzbWFsbGVyIHRoYW4gdGhlIHBhcmFsbGVsIChwaGkpP1xuICAgICAgaWYgKGFudGltZXJpZGlhbiBeIGxhbWJkYTAgPj0gbGFtYmRhIF4gbGFtYmRhMSA+PSBsYW1iZGEpIHtcbiAgICAgICAgdmFyIGFyYyA9IGNhcnRlc2lhbkNyb3NzKGNhcnRlc2lhbihwb2ludDApLCBjYXJ0ZXNpYW4ocG9pbnQxKSk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoYXJjKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKG5vcm1hbCwgYXJjKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICB2YXIgcGhpQXJjID0gKGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAtMSA6IDEpICogYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICBpZiAocGhpID4gcGhpQXJjIHx8IHBoaSA9PT0gcGhpQXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0LCBkZXRlcm1pbmUgd2hldGhlciB0aGUgU291dGggcG9sZSBpcyBpbnNpZGUgb3Igb3V0c2lkZTpcbiAgLy9cbiAgLy8gSXQgaXMgaW5zaWRlIGlmOlxuICAvLyAqIHRoZSBwb2x5Z29uIHdpbmRzIGFyb3VuZCBpdCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gIC8vICogdGhlIHBvbHlnb24gZG9lcyBub3QgKGN1bXVsYXRpdmVseSkgd2luZCBhcm91bmQgaXQsIGJ1dCBoYXMgYSBuZWdhdGl2ZVxuICAvLyAgIChjb3VudGVyLWNsb2Nrd2lzZSkgYXJlYS5cbiAgLy9cbiAgLy8gU2Vjb25kLCBjb3VudCB0aGUgKHNpZ25lZCkgbnVtYmVyIG9mIHRpbWVzIGEgc2VnbWVudCBjcm9zc2VzIGEgbGFtYmRhXG4gIC8vIGZyb20gdGhlIHBvaW50IHRvIHRoZSBTb3V0aCBwb2xlLiAgSWYgaXQgaXMgemVybywgdGhlbiB0aGUgcG9pbnQgaXMgdGhlXG4gIC8vIHNhbWUgc2lkZSBhcyB0aGUgU291dGggcG9sZS5cblxuICByZXR1cm4gKGFuZ2xlIDwgLWVwc2lsb24gfHwgYW5nbGUgPCBlcHNpbG9uICYmIHN1bSA8IC1lcHNpbG9uMikgXiAod2luZGluZyAmIDEpO1xufVxuIiwiaW1wb3J0IHtkZWZhdWx0IGFzIGdlb1N0cmVhbX0gZnJvbSBcIi4uL3N0cmVhbS5qc1wiO1xuaW1wb3J0IGJvdW5kc1N0cmVhbSBmcm9tIFwiLi4vcGF0aC9ib3VuZHMuanNcIjtcblxuZnVuY3Rpb24gZml0KHByb2plY3Rpb24sIGZpdEJvdW5kcywgb2JqZWN0KSB7XG4gIHZhciBjbGlwID0gcHJvamVjdGlvbi5jbGlwRXh0ZW50ICYmIHByb2plY3Rpb24uY2xpcEV4dGVudCgpO1xuICBwcm9qZWN0aW9uLnNjYWxlKDE1MCkudHJhbnNsYXRlKFswLCAwXSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChudWxsKTtcbiAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvbi5zdHJlYW0oYm91bmRzU3RyZWFtKSk7XG4gIGZpdEJvdW5kcyhib3VuZHNTdHJlYW0ucmVzdWx0KCkpO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoY2xpcCk7XG4gIHJldHVybiBwcm9qZWN0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdLFxuICAgICAgICBoID0gZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdLFxuICAgICAgICBrID0gTWF0aC5taW4odyAvIChiWzFdWzBdIC0gYlswXVswXSksIGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pKSxcbiAgICAgICAgeCA9ICtleHRlbnRbMF1bMF0gKyAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSArZXh0ZW50WzBdWzFdICsgKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xuICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIFtbMCwgMF0sIHNpemVdLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9ICt3aWR0aCxcbiAgICAgICAgayA9IHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLFxuICAgICAgICB4ID0gKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gLWsgKiBiWzBdWzFdO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIGggPSAraGVpZ2h0LFxuICAgICAgICBrID0gaCAvIChiWzFdWzFdIC0gYlswXVsxXSksXG4gICAgICAgIHggPSAtayAqIGJbMF1bMF0sXG4gICAgICAgIHkgPSAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cbiIsImltcG9ydCBjbGlwQW50aW1lcmlkaWFuIGZyb20gXCIuLi9jbGlwL2FudGltZXJpZGlhbi5qc1wiO1xuaW1wb3J0IGNsaXBDaXJjbGUgZnJvbSBcIi4uL2NsaXAvY2lyY2xlLmpzXCI7XG5pbXBvcnQgY2xpcFJlY3RhbmdsZSBmcm9tIFwiLi4vY2xpcC9yZWN0YW5nbGUuanNcIjtcbmltcG9ydCBjb21wb3NlIGZyb20gXCIuLi9jb21wb3NlLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQge2NvcywgZGVncmVlcywgcmFkaWFucywgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtyb3RhdGVSYWRpYW5zfSBmcm9tIFwiLi4vcm90YXRpb24uanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCB7Zml0RXh0ZW50LCBmaXRTaXplLCBmaXRXaWR0aCwgZml0SGVpZ2h0fSBmcm9tIFwiLi9maXQuanNcIjtcbmltcG9ydCByZXNhbXBsZSBmcm9tIFwiLi9yZXNhbXBsZS5qc1wiO1xuXG52YXIgdHJhbnNmb3JtUmFkaWFucyA9IHRyYW5zZm9ybWVyKHtcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgciA9IHJvdGF0ZSh4LCB5KTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb2ludChyWzBdLCByWzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHksIHN4LCBzeSkge1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHggKj0gc3g7IHkgKj0gc3k7XG4gICAgcmV0dXJuIFtkeCArIGsgKiB4LCBkeSAtIGsgKiB5XTtcbiAgfVxuICB0cmFuc2Zvcm0uaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbKHggLSBkeCkgLyBrICogc3gsIChkeSAtIHkpIC8gayAqIHN5XTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgZHgsIGR5LCBzeCwgc3ksIGFscGhhKSB7XG4gIGlmICghYWxwaGEpIHJldHVybiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHksIHN4LCBzeSk7XG4gIHZhciBjb3NBbHBoYSA9IGNvcyhhbHBoYSksXG4gICAgICBzaW5BbHBoYSA9IHNpbihhbHBoYSksXG4gICAgICBhID0gY29zQWxwaGEgKiBrLFxuICAgICAgYiA9IHNpbkFscGhhICogayxcbiAgICAgIGFpID0gY29zQWxwaGEgLyBrLFxuICAgICAgYmkgPSBzaW5BbHBoYSAvIGssXG4gICAgICBjaSA9IChzaW5BbHBoYSAqIGR5IC0gY29zQWxwaGEgKiBkeCkgLyBrLFxuICAgICAgZmkgPSAoc2luQWxwaGEgKiBkeCArIGNvc0FscGhhICogZHkpIC8gaztcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICB4ICo9IHN4OyB5ICo9IHN5O1xuICAgIHJldHVybiBbYSAqIHggLSBiICogeSArIGR4LCBkeSAtIGIgKiB4IC0gYSAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFtzeCAqIChhaSAqIHggLSBiaSAqIHkgKyBjaSksIHN5ICogKGZpIC0gYmkgKiB4IC0gYWkgKiB5KV07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByb2plY3Rpb24ocHJvamVjdCkge1xuICByZXR1cm4gcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24oKSB7IHJldHVybiBwcm9qZWN0OyB9KSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gIHZhciBwcm9qZWN0LFxuICAgICAgayA9IDE1MCwgLy8gc2NhbGVcbiAgICAgIHggPSA0ODAsIHkgPSAyNTAsIC8vIHRyYW5zbGF0ZVxuICAgICAgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXG4gICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgLy8gcHJlLXJvdGF0ZVxuICAgICAgYWxwaGEgPSAwLCAvLyBwb3N0LXJvdGF0ZSBhbmdsZVxuICAgICAgc3ggPSAxLCAvLyByZWZsZWN0WFxuICAgICAgc3kgPSAxLCAvLyByZWZsZWN0WFxuICAgICAgdGhldGEgPSBudWxsLCBwcmVjbGlwID0gY2xpcEFudGltZXJpZGlhbiwgLy8gcHJlLWNsaXAgYW5nbGVcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgcG9zdGNsaXAgPSBpZGVudGl0eSwgLy8gcG9zdC1jbGlwIGV4dGVudFxuICAgICAgZGVsdGEyID0gMC41LCAvLyBwcmVjaXNpb25cbiAgICAgIHByb2plY3RSZXNhbXBsZSxcbiAgICAgIHByb2plY3RUcmFuc2Zvcm0sXG4gICAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbTtcblxuICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0ocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLmludmVydChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgIHJldHVybiBwb2ludCAmJiBbcG9pbnRbMF0gKiBkZWdyZWVzLCBwb2ludFsxXSAqIGRlZ3JlZXNdO1xuICB9XG5cbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm1SYWRpYW5zKHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpKHByZWNsaXAocHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSkpKSk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSBfLCB0aGV0YSA9IHVuZGVmaW5lZCwgcmVzZXQoKSkgOiBwcmVjbGlwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucG9zdGNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9ICtfID8gY2xpcENpcmNsZSh0aGV0YSA9IF8gKiByYWRpYW5zKSA6ICh0aGV0YSA9IG51bGwsIGNsaXBBbnRpbWVyaWRpYW4pLCByZXNldCgpKSA6IHRoZXRhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gK18sIHJlY2VudGVyKCkpIDogaztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIHBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWx0YUxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YVBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YUdhbW1hID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIHJhZGlhbnMgOiAwLCByZWNlbnRlcigpKSA6IFtkZWx0YUxhbWJkYSAqIGRlZ3JlZXMsIGRlbHRhUGhpICogZGVncmVlcywgZGVsdGFHYW1tYSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yZWZsZWN0WCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeCA9IF8gPyAtMSA6IDEsIHJlY2VudGVyKCkpIDogc3ggPCAwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucmVmbGVjdFkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3kgPSBfID8gLTEgOiAxLCByZWNlbnRlcigpKSA6IHN5IDwgMDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIgPSBfICogXyksIHJlc2V0KCkpIDogc3FydChkZWx0YTIpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWNlbnRlcigpIHtcbiAgICB2YXIgY2VudGVyID0gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgMCwgMCwgc3gsIHN5LCBhbHBoYSkuYXBwbHkobnVsbCwgcHJvamVjdChsYW1iZGEsIHBoaSkpLFxuICAgICAgICB0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCB4IC0gY2VudGVyWzBdLCB5IC0gY2VudGVyWzFdLCBzeCwgc3ksIGFscGhhKTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSk7XG4gICAgcHJvamVjdFRyYW5zZm9ybSA9IGNvbXBvc2UocHJvamVjdCwgdHJhbnNmb3JtKTtcbiAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtID0gY29tcG9zZShyb3RhdGUsIHByb2plY3RUcmFuc2Zvcm0pO1xuICAgIHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMik7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgcmV0dXJuIHJlY2VudGVyKCk7XG4gIH07XG59XG4iLCJpbXBvcnQge2NhcnRlc2lhbn0gZnJvbSBcIi4uL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIHJhZGlhbnMsIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge3RyYW5zZm9ybWVyfSBmcm9tIFwiLi4vdHJhbnNmb3JtLmpzXCI7XG5cbnZhciBtYXhEZXB0aCA9IDE2LCAvLyBtYXhpbXVtIGRlcHRoIG9mIHN1YmRpdmlzaW9uXG4gICAgY29zTWluRGlzdGFuY2UgPSBjb3MoMzAgKiByYWRpYW5zKTsgLy8gY29zKG1pbmltdW0gYW5ndWxhciBkaXN0YW5jZSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocHJvamVjdCwgZGVsdGEyKSB7XG4gIHJldHVybiArZGVsdGEyID8gcmVzYW1wbGUocHJvamVjdCwgZGVsdGEyKSA6IHJlc2FtcGxlTm9uZShwcm9qZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVzYW1wbGVOb25lKHByb2plY3QpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZShwcm9qZWN0LCBkZWx0YTIpIHtcblxuICBmdW5jdGlvbiByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSkge1xuICAgIHZhciBkeCA9IHgxIC0geDAsXG4gICAgICAgIGR5ID0geTEgLSB5MCxcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBpZiAoZDIgPiA0ICogZGVsdGEyICYmIGRlcHRoLS0pIHtcbiAgICAgIHZhciBhID0gYTAgKyBhMSxcbiAgICAgICAgICBiID0gYjAgKyBiMSxcbiAgICAgICAgICBjID0gYzAgKyBjMSxcbiAgICAgICAgICBtID0gc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpLFxuICAgICAgICAgIHBoaTIgPSBhc2luKGMgLz0gbSksXG4gICAgICAgICAgbGFtYmRhMiA9IGFicyhhYnMoYykgLSAxKSA8IGVwc2lsb24gfHwgYWJzKGxhbWJkYTAgLSBsYW1iZGExKSA8IGVwc2lsb24gPyAobGFtYmRhMCArIGxhbWJkYTEpIC8gMiA6IGF0YW4yKGIsIGEpLFxuICAgICAgICAgIHAgPSBwcm9qZWN0KGxhbWJkYTIsIHBoaTIpLFxuICAgICAgICAgIHgyID0gcFswXSxcbiAgICAgICAgICB5MiA9IHBbMV0sXG4gICAgICAgICAgZHgyID0geDIgLSB4MCxcbiAgICAgICAgICBkeTIgPSB5MiAtIHkwLFxuICAgICAgICAgIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcbiAgICAgIGlmIChkeiAqIGR6IC8gZDIgPiBkZWx0YTIgLy8gcGVycGVuZGljdWxhciBwcm9qZWN0ZWQgZGlzdGFuY2VcbiAgICAgICAgICB8fCBhYnMoKGR4ICogZHgyICsgZHkgKiBkeTIpIC8gZDIgLSAwLjUpID4gMC4zIC8vIG1pZHBvaW50IGNsb3NlIHRvIGFuIGVuZFxuICAgICAgICAgIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7IC8vIGFuZ3VsYXIgZGlzdGFuY2VcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MiwgeTIsIGxhbWJkYTIsIGEgLz0gbSwgYiAvPSBtLCBjLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHgyLCB5Mik7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgbGFtYmRhMiwgYSwgYiwgYywgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBsYW1iZGEwMCwgeDAwLCB5MDAsIGEwMCwgYjAwLCBjMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIGxhbWJkYTAsIHgwLCB5MCwgYTAsIGIwLCBjMDsgLy8gcHJldmlvdXMgcG9pbnRcblxuICAgIHZhciByZXNhbXBsZVN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gcmluZ1N0YXJ0OyB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7IHN0cmVhbS5wb2x5Z29uRW5kKCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IGxpbmVTdGFydDsgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICB4MCA9IE5hTjtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgdmFyIGMgPSBjYXJ0ZXNpYW4oW2xhbWJkYSwgcGhpXSksIHAgPSBwcm9qZWN0KGxhbWJkYSwgcGhpKTtcbiAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDAgPSBwWzBdLCB5MCA9IHBbMV0sIGxhbWJkYTAgPSBsYW1iZGEsIGEwID0gY1swXSwgYjAgPSBjWzFdLCBjMCA9IGNbMl0sIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgc3RyZWFtLnBvaW50KHgwLCB5MCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIGxpbmVTdGFydCgpO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gcmluZ0VuZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIGxpbmVQb2ludChsYW1iZGEwMCA9IGxhbWJkYSwgcGhpKSwgeDAwID0geDAsIHkwMCA9IHkwLCBhMDAgPSBhMCwgYjAwID0gYjAsIGMwMCA9IGMwO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDAwLCB5MDAsIGxhbWJkYTAwLCBhMDAsIGIwMCwgYzAwLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgbGluZUVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNhbXBsZVN0cmVhbTtcbiAgfTtcbn1cbiIsImltcG9ydCBjb21wb3NlIGZyb20gXCIuL2NvbXBvc2UuanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBkZWdyZWVzLCBwaSwgcmFkaWFucywgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gcm90YXRpb25JZGVudGl0eShsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2FicyhsYW1iZGEpID4gcGkgPyBsYW1iZGEgKyBNYXRoLnJvdW5kKC1sYW1iZGEgLyB0YXUpICogdGF1IDogbGFtYmRhLCBwaGldO1xufVxuXG5yb3RhdGlvbklkZW50aXR5LmludmVydCA9IHJvdGF0aW9uSWRlbnRpdHk7XG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICByZXR1cm4gKGRlbHRhTGFtYmRhICU9IHRhdSkgPyAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IGNvbXBvc2Uocm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpLCByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSlcbiAgICA6IHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSlcbiAgICA6IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSlcbiAgICA6IHJvdGF0aW9uSWRlbnRpdHkpO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGxhbWJkYSArPSBkZWx0YUxhbWJkYSwgW2xhbWJkYSA+IHBpID8gbGFtYmRhIC0gdGF1IDogbGFtYmRhIDwgLXBpID8gbGFtYmRhICsgdGF1IDogbGFtYmRhLCBwaGldO1xuICB9O1xufVxuXG5mdW5jdGlvbiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICB2YXIgcm90YXRpb24gPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpO1xuICByb3RhdGlvbi5pbnZlcnQgPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoLWRlbHRhTGFtYmRhKTtcbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5mdW5jdGlvbiByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHZhciBjb3NEZWx0YVBoaSA9IGNvcyhkZWx0YVBoaSksXG4gICAgICBzaW5EZWx0YVBoaSA9IHNpbihkZWx0YVBoaSksXG4gICAgICBjb3NEZWx0YUdhbW1hID0gY29zKGRlbHRhR2FtbWEpLFxuICAgICAgc2luRGVsdGFHYW1tYSA9IHNpbihkZWx0YUdhbW1hKTtcblxuICBmdW5jdGlvbiByb3RhdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YVBoaSArIHggKiBzaW5EZWx0YVBoaTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgLSBrICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpIC0geiAqIHNpbkRlbHRhUGhpKSxcbiAgICAgIGFzaW4oayAqIGNvc0RlbHRhR2FtbWEgKyB5ICogc2luRGVsdGFHYW1tYSlcbiAgICBdO1xuICB9XG5cbiAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICAgIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB6ID0gc2luKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFHYW1tYSAtIHkgKiBzaW5EZWx0YUdhbW1hO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSArIHogKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgKyBrICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXG4gICAgXTtcbiAgfTtcblxuICByZXR1cm4gcm90YXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJvdGF0ZSkge1xuICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKHJvdGF0ZVswXSAqIHJhZGlhbnMsIHJvdGF0ZVsxXSAqIHJhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogcmFkaWFucyA6IDApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuIiwiZnVuY3Rpb24gc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIHN0cmVhbSkge1xuICBpZiAoZ2VvbWV0cnkgJiYgc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59XG5cbnZhciBzdHJlYW1PYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59O1xuXG52YXIgc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtLnNwaGVyZSgpO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xuICB9LFxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gIH0sXG4gIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgc3RyZWFtKTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBzdHJlYW0sIGNsb3NlZCkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgc3RyZWFtLmxpbmVFbmQoKTtcbn1cblxuZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMSk7XG4gIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gIGlmIChvYmplY3QgJiYgc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICBzdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBzdHJlYW0pO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtZXRob2RzKSB7XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtZXIobWV0aG9kcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSBzW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHt9XG5cblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpOyB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCk7IH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG59O1xuIiwiZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgZXhwID0gTWF0aC5leHA7XG5leHBvcnQgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbmV4cG9ydCB2YXIgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbmV4cG9ydCB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuZXhwb3J0IHZhciBzcXJ0MV8yID0gTWF0aC5TUVJUMV8yO1xuZXhwb3J0IHZhciBzcXJ0MiA9IHNxcnQoMik7XG5leHBvcnQgdmFyIHNxcnRQaSA9IHNxcnQocGkpO1xuZXhwb3J0IHZhciB0YXUgPSBwaSAqIDI7XG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgZnVuY3Rpb24gc2luY2koeCkge1xuICByZXR1cm4geCA/IHggLyBNYXRoLnNpbih4KSA6IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIHggPiAwID8gTWF0aC5zcXJ0KHgpIDogMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhbmgoeCkge1xuICB4ID0gZXhwKDIgKiB4KTtcbiAgcmV0dXJuICh4IC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpIC0gZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpICsgZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJzaW5oKHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyY29zaCh4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxKSk7XG59XG4iLCJpbXBvcnQge2dlb1Byb2plY3Rpb24gYXMgcHJvamVjdGlvbn0gZnJvbSBcImQzLWdlb1wiO1xuaW1wb3J0IHthYnMsIGRlZ3JlZXMsIGVwc2lsb24yLCBmbG9vciwgaGFsZlBpLCBtYXgsIG1pbiwgcGksIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxudmFyIEsgPSBbXG4gIFswLjk5ODYsIC0wLjA2Ml0sXG4gIFsxLjAwMDAsIDAuMDAwMF0sXG4gIFswLjk5ODYsIDAuMDYyMF0sXG4gIFswLjk5NTQsIDAuMTI0MF0sXG4gIFswLjk5MDAsIDAuMTg2MF0sXG4gIFswLjk4MjIsIDAuMjQ4MF0sXG4gIFswLjk3MzAsIDAuMzEwMF0sXG4gIFswLjk2MDAsIDAuMzcyMF0sXG4gIFswLjk0MjcsIDAuNDM0MF0sXG4gIFswLjkyMTYsIDAuNDk1OF0sXG4gIFswLjg5NjIsIDAuNTU3MV0sXG4gIFswLjg2NzksIDAuNjE3Nl0sXG4gIFswLjgzNTAsIDAuNjc2OV0sXG4gIFswLjc5ODYsIDAuNzM0Nl0sXG4gIFswLjc1OTcsIDAuNzkwM10sXG4gIFswLjcxODYsIDAuODQzNV0sXG4gIFswLjY3MzIsIDAuODkzNl0sXG4gIFswLjYyMTMsIDAuOTM5NF0sXG4gIFswLjU3MjIsIDAuOTc2MV0sXG4gIFswLjUzMjIsIDEuMDAwMF1cbl07XG5cbksuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gIGRbMV0gKj0gMS4wMTQ0O1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByb2JpbnNvblJhdyhsYW1iZGEsIHBoaSkge1xuICB2YXIgaSA9IG1pbigxOCwgYWJzKHBoaSkgKiAzNiAvIHBpKSxcbiAgICAgIGkwID0gZmxvb3IoaSksXG4gICAgICBkaSA9IGkgLSBpMCxcbiAgICAgIGF4ID0gKGsgPSBLW2kwXSlbMF0sXG4gICAgICBheSA9IGtbMV0sXG4gICAgICBieCA9IChrID0gS1srK2kwXSlbMF0sXG4gICAgICBieSA9IGtbMV0sXG4gICAgICBjeCA9IChrID0gS1ttaW4oMTksICsraTApXSlbMF0sXG4gICAgICBjeSA9IGtbMV0sXG4gICAgICBrO1xuICByZXR1cm4gW1xuICAgIGxhbWJkYSAqIChieCArIGRpICogKGN4IC0gYXgpIC8gMiArIGRpICogZGkgKiAoY3ggLSAyICogYnggKyBheCkgLyAyKSxcbiAgICAocGhpID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpICogKGJ5ICsgZGkgKiAoY3kgLSBheSkgLyAyICsgZGkgKiBkaSAqIChjeSAtIDIgKiBieSArIGF5KSAvIDIpXG4gIF07XG59XG5cbnJvYmluc29uUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHl5ID0geSAvIGhhbGZQaSxcbiAgICAgIHBoaSA9IHl5ICogOTAsXG4gICAgICBpID0gbWluKDE4LCBhYnMocGhpIC8gNSkpLFxuICAgICAgaTAgPSBtYXgoMCwgZmxvb3IoaSkpO1xuICBkbyB7XG4gICAgdmFyIGF5ID0gS1tpMF1bMV0sXG4gICAgICAgIGJ5ID0gS1tpMCArIDFdWzFdLFxuICAgICAgICBjeSA9IEtbbWluKDE5LCBpMCArIDIpXVsxXSxcbiAgICAgICAgdSA9IGN5IC0gYXksXG4gICAgICAgIHYgPSBjeSAtIDIgKiBieSArIGF5LFxuICAgICAgICB0ID0gMiAqIChhYnMoeXkpIC0gYnkpIC8gdSxcbiAgICAgICAgYyA9IHYgLyB1LFxuICAgICAgICBkaSA9IHQgKiAoMSAtIGMgKiB0ICogKDEgLSAyICogYyAqIHQpKTtcbiAgICBpZiAoZGkgPj0gMCB8fCBpMCA9PT0gMSkge1xuICAgICAgcGhpID0gKHkgPj0gMCA/IDUgOiAtNSkgKiAoZGkgKyBpKTtcbiAgICAgIHZhciBqID0gNTAsIGRlbHRhO1xuICAgICAgZG8ge1xuICAgICAgICBpID0gbWluKDE4LCBhYnMocGhpKSAvIDUpO1xuICAgICAgICBpMCA9IGZsb29yKGkpO1xuICAgICAgICBkaSA9IGkgLSBpMDtcbiAgICAgICAgYXkgPSBLW2kwXVsxXTtcbiAgICAgICAgYnkgPSBLW2kwICsgMV1bMV07XG4gICAgICAgIGN5ID0gS1ttaW4oMTksIGkwICsgMildWzFdO1xuICAgICAgICBwaGkgLT0gKGRlbHRhID0gKHkgPj0gMCA/IGhhbGZQaSA6IC1oYWxmUGkpICogKGJ5ICsgZGkgKiAoY3kgLSBheSkgLyAyICsgZGkgKiBkaSAqIChjeSAtIDIgKiBieSArIGF5KSAvIDIpIC0geSkgKiBkZWdyZWVzO1xuICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24yICYmIC0taiA+IDApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IHdoaWxlICgtLWkwID49IDApO1xuICB2YXIgYXggPSBLW2kwXVswXSxcbiAgICAgIGJ4ID0gS1tpMCArIDFdWzBdLFxuICAgICAgY3ggPSBLW21pbigxOSwgaTAgKyAyKV1bMF07XG4gIHJldHVybiBbXG4gICAgeCAvIChieCArIGRpICogKGN4IC0gYXgpIC8gMiArIGRpICogZGkgKiAoY3ggLSAyICogYnggKyBheCkgLyAyKSxcbiAgICBwaGkgKiByYWRpYW5zXG4gIF07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24ocm9iaW5zb25SYXcpXG4gICAgICAuc2NhbGUoMTUyLjYzKTtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthc2luLCBhdGFuMiwgY29zLCBkZWdyZWVzLCBlcHNpbG9uLCBlcHNpbG9uMiwgaHlwb3QsIHJhZGlhbnMsIHNpbiwgc3FydH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4vbm9vcC5qc1wiO1xuaW1wb3J0IHN0cmVhbSBmcm9tIFwiLi9zdHJlYW0uanNcIjtcblxudmFyIFcwLCBXMSxcbiAgICBYMCwgWTAsIFowLFxuICAgIFgxLCBZMSwgWjEsXG4gICAgWDIsIFkyLCBaMixcbiAgICBsYW1iZGEwMCwgcGhpMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgeDAsIHkwLCB6MDsgLy8gcHJldmlvdXMgcG9pbnRcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBzcGhlcmU6IG5vb3AsXG4gIHBvaW50OiBjZW50cm9pZFBvaW50LFxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZDtcbiAgfVxufTtcblxuLy8gQXJpdGhtZXRpYyBtZWFuIG9mIENhcnRlc2lhbiB2ZWN0b3JzLlxuZnVuY3Rpb24gY2VudHJvaWRQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbihjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludENhcnRlc2lhbih4LCB5LCB6KSB7XG4gICsrVzA7XG4gIFgwICs9ICh4IC0gWDApIC8gVzA7XG4gIFkwICs9ICh5IC0gWTApIC8gVzA7XG4gIFowICs9ICh6IC0gWjApIC8gVzA7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gIHowID0gc2luKHBoaSk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnQ7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLFxuICAgICAgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLFxuICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgdyA9IGF0YW4yKHNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kKCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbi8vIFNlZSBKLiBFLiBCcm9jaywgVGhlIEluZXJ0aWEgVGVuc29yIGZvciBhIFNwaGVyaWNhbCBUcmlhbmdsZSxcbi8vIEouIEFwcGxpZWQgTWVjaGFuaWNzIDQyLCAyMzkgKDE5NzUpLlxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xuICBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEwMCwgcGhpMDApO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnQ7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICBjeCA9IHkwICogeiAtIHowICogeSxcbiAgICAgIGN5ID0gejAgKiB4IC0geDAgKiB6LFxuICAgICAgY3ogPSB4MCAqIHkgLSB5MCAqIHgsXG4gICAgICBtID0gaHlwb3QoY3gsIGN5LCBjeiksXG4gICAgICB3ID0gYXNpbihtKSwgLy8gbGluZSB3ZWlnaHQgPSBhbmdsZVxuICAgICAgdiA9IG0gJiYgLXcgLyBtOyAvLyBhcmVhIHdlaWdodCBtdWx0aXBsaWVyXG4gIFgyLmFkZCh2ICogY3gpO1xuICBZMi5hZGQodiAqIGN5KTtcbiAgWjIuYWRkKHYgKiBjeik7XG4gIFcxICs9IHc7XG4gIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCkge1xuICBXMCA9IFcxID1cbiAgWDAgPSBZMCA9IFowID1cbiAgWDEgPSBZMSA9IFoxID0gMDtcbiAgWDIgPSBuZXcgQWRkZXIoKTtcbiAgWTIgPSBuZXcgQWRkZXIoKTtcbiAgWjIgPSBuZXcgQWRkZXIoKTtcbiAgc3RyZWFtKG9iamVjdCwgY2VudHJvaWRTdHJlYW0pO1xuXG4gIHZhciB4ID0gK1gyLFxuICAgICAgeSA9ICtZMixcbiAgICAgIHogPSArWjIsXG4gICAgICBtID0gaHlwb3QoeCwgeSwgeik7XG5cbiAgLy8gSWYgdGhlIGFyZWEtd2VpZ2h0ZWQgY2NlbnRyb2lkIGlzIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIGxlbmd0aC13ZWlnaHRlZCBjY2VudHJvaWQuXG4gIGlmIChtIDwgZXBzaWxvbjIpIHtcbiAgICB4ID0gWDEsIHkgPSBZMSwgeiA9IFoxO1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIGhhcyB6ZXJvIGxlbmd0aCwgZmFsbCBiYWNrIHRvIGFyaXRobWV0aWMgbWVhbiBvZiBwb2ludCB2ZWN0b3JzLlxuICAgIGlmIChXMSA8IGVwc2lsb24pIHggPSBYMCwgeSA9IFkwLCB6ID0gWjA7XG4gICAgbSA9IGh5cG90KHgsIHksIHopO1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIHN0aWxsIGhhcyBhbiB1bmRlZmluZWQgY2NlbnRyb2lkLCB0aGVuIHJldHVybi5cbiAgICBpZiAobSA8IGVwc2lsb24yKSByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxuXG4gIHJldHVybiBbYXRhbjIoeSwgeCkgKiBkZWdyZWVzLCBhc2luKHogLyBtKSAqIGRlZ3JlZXNdO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lcyA9IFtdLFxuICAgICAgbGluZTtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSwgbSkge1xuICAgICAgbGluZS5wdXNoKFt4LCB5LCBtXSk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgIH0sXG4gICAgbGluZUVuZDogbm9vcCxcbiAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgbGluZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBkeCA9IGJ4IC0gYXgsXG4gICAgICBkeSA9IGJ5IC0gYXksXG4gICAgICByO1xuXG4gIHIgPSB4MCAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geDEgLSBheDtcbiAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgciA9IHkwIC0gYXk7XG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB5MSAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICBpZiAodDAgPiAwKSBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xuICBpZiAodDEgPCAxKSBiWzBdID0gYXggKyB0MSAqIGR4LCBiWzFdID0gYXkgKyB0MSAqIGR5O1xuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7YWJzLCBlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IGNsaXBCdWZmZXIgZnJvbSBcIi4vYnVmZmVyLmpzXCI7XG5pbXBvcnQgY2xpcExpbmUgZnJvbSBcIi4vbGluZS5qc1wiO1xuaW1wb3J0IGNsaXBSZWpvaW4gZnJvbSBcIi4vcmVqb2luLmpzXCI7XG5pbXBvcnQge21lcmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcblxudmFyIGNsaXBNYXggPSAxZTksIGNsaXBNaW4gPSAtY2xpcE1heDtcblxuLy8gVE9ETyBVc2UgZDMtcG9seWdvbuKAmXMgcG9seWdvbkNvbnRhaW5zIGhlcmUgZm9yIHRoZSByaW5nIGNoZWNrP1xuLy8gVE9ETyBFbGltaW5hdGUgZHVwbGljYXRlIGJ1ZmZlcmluZyBpbiBjbGlwQnVmZmVyIGFuZCBwb2x5Z29uLnB1c2g/XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpIHtcblxuICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcbiAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSlcbiAgICAgICAgfHwgY29tcGFyZVBvaW50KGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBkbyBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xuICAgICAgICA6IGFicyhwWzBdIC0geDEpIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMVxuICAgICAgICA6IGFicyhwWzFdIC0geTApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMFxuICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XG4gICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLFxuICAgICAgICBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxuICAgICAgICA6IGNhID09PSAwID8gYlsxXSAtIGFbMV1cbiAgICAgICAgOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdXG4gICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxuICAgICAgICA6IGJbMF0gLSBhWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sXG4gICAgICAgIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHJpbmcsXG4gICAgICAgIHhfXywgeV9fLCB2X18sIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGZpcnN0LFxuICAgICAgICBjbGVhbjtcblxuICAgIHZhciBjbGlwU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBwb2x5Z29uU3RhcnQsXG4gICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGlmICh2aXNpYmxlKHgsIHkpKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBmb3IgKHZhciByaW5nID0gcG9seWdvbltpXSwgaiA9IDEsIG0gPSByaW5nLmxlbmd0aCwgcG9pbnQgPSByaW5nWzBdLCBhMCwgYTEsIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07IGogPCBtOyArK2opIHtcbiAgICAgICAgICBhMCA9IGIwLCBhMSA9IGIxLCBwb2ludCA9IHJpbmdbal0sIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07XG4gICAgICAgICAgaWYgKGExIDw9IHkxKSB7IGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSkgKyt3aW5kaW5nOyB9XG4gICAgICAgICAgZWxzZSB7IGlmIChiMSA8PSB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPCAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpIC0td2luZGluZzsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kaW5nO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBnZW9tZXRyeSB3aXRoaW4gYSBwb2x5Z29uIGFuZCB0aGVuIGNsaXAgaXQgZW4gbWFzc2UuXG4gICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgYWN0aXZlU3RyZWFtID0gYnVmZmVyU3RyZWFtLCBzZWdtZW50cyA9IFtdLCBwb2x5Z29uID0gW10sIGNsZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkluc2lkZSgpLFxuICAgICAgICAgIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsXG4gICAgICAgICAgdmlzaWJsZSA9IChzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKSkubGVuZ3RoO1xuICAgICAgaWYgKGNsZWFuSW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBpZiAoY2xlYW5JbnNpZGUpIHtcbiAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc3RyZWFtKTtcbiAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgICBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sIHNlZ21lbnRzID0gcG9seWdvbiA9IHJpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBpZiAocG9seWdvbikgcG9seWdvbi5wdXNoKHJpbmcgPSBbXSk7XG4gICAgICBmaXJzdCA9IHRydWU7XG4gICAgICB2XyA9IGZhbHNlO1xuICAgICAgeF8gPSB5XyA9IE5hTjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIHJhdGhlciB0aGFuIHNwZWNpYWwtY2FzZSBwb2x5Z29ucywgc2ltcGx5IGhhbmRsZSB0aGVtIHNlcGFyYXRlbHkuXG4gICAgLy8gSWRlYWxseSwgY29pbmNpZGVudCBpbnRlcnNlY3Rpb24gcG9pbnRzIHNob3VsZCBiZSBqaXR0ZXJlZCB0byBhdm9pZFxuICAgIC8vIGNsaXBwaW5nIGlzc3Vlcy5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XG4gICAgICAgIGlmICh2X18gJiYgdl8pIGJ1ZmZlclN0cmVhbS5yZWpvaW4oKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChidWZmZXJTdHJlYW0ucmVzdWx0KCkpO1xuICAgICAgfVxuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgaWYgKHZfKSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgdiA9IHZpc2libGUoeCwgeSk7XG4gICAgICBpZiAocG9seWdvbikgcmluZy5wdXNoKFt4LCB5XSk7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAmJiB2XykgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYSA9IFt4XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHhfKSksIHlfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeV8pKV0sXG4gICAgICAgICAgICAgIGIgPSBbeCA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHgpKSwgeSA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHkpKV07XG4gICAgICAgICAgaWYgKGNsaXBMaW5lKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSkge1xuICAgICAgICAgICAgaWYgKCF2Xykge1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChiWzBdLCBiWzFdKTtcbiAgICAgICAgICAgIGlmICghdikgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeF8gPSB4LCB5XyA9IHksIHZfID0gdjtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcFN0cmVhbTtcbiAgfTtcbn1cbiIsImltcG9ydCBwb2ludEVxdWFsIGZyb20gXCIuLi9wb2ludEVxdWFsLmpzXCI7XG5pbXBvcnQge2Vwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIEludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgdGhpcy54ID0gcG9pbnQ7XG4gIHRoaXMueiA9IHBvaW50cztcbiAgdGhpcy5vID0gb3RoZXI7IC8vIGFub3RoZXIgaW50ZXJzZWN0aW9uXG4gIHRoaXMuZSA9IGVudHJ5OyAvLyBpcyBhbiBlbnRyeT9cbiAgdGhpcy52ID0gZmFsc2U7IC8vIHZpc2l0ZWRcbiAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDsgLy8gbmV4dCAmIHByZXZpb3VzXG59XG5cbi8vIEEgZ2VuZXJhbGl6ZWQgcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG06IGdpdmVuIGEgcG9seWdvbiB0aGF0IGhhcyBiZWVuIGN1dFxuLy8gaW50byBpdHMgdmlzaWJsZSBsaW5lIHNlZ21lbnRzLCBhbmQgcmVqb2lucyB0aGUgc2VnbWVudHMgYnkgaW50ZXJwb2xhdGluZ1xuLy8gYWxvbmcgdGhlIGNsaXAgZWRnZS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSkge1xuICB2YXIgc3ViamVjdCA9IFtdLFxuICAgICAgY2xpcCA9IFtdLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dLCB4O1xuXG4gICAgaWYgKHBvaW50RXF1YWwocDAsIHAxKSkge1xuICAgICAgaWYgKCFwMFsyXSAmJiAhcDFbMl0pIHtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIGRlZ2VuZXJhdGUgY2FzZXMgYnkgbW92aW5nIHRoZSBwb2ludFxuICAgICAgcDFbMF0gKz0gMiAqIGVwc2lsb247XG4gICAgfVxuXG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIG51bGwsIHgsIGZhbHNlKSk7XG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBudWxsLCB4LCB0cnVlKSk7XG4gIH0pO1xuXG4gIGlmICghc3ViamVjdC5sZW5ndGgpIHJldHVybjtcblxuICBjbGlwLnNvcnQoY29tcGFyZUludGVyc2VjdGlvbik7XG4gIGxpbmsoc3ViamVjdCk7XG4gIGxpbmsoY2xpcCk7XG5cbiAgZm9yIChpID0gMCwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY2xpcFtpXS5lID0gc3RhcnRJbnNpZGUgPSAhc3RhcnRJbnNpZGU7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLFxuICAgICAgcG9pbnRzLFxuICAgICAgcG9pbnQ7XG5cbiAgd2hpbGUgKDEpIHtcbiAgICAvLyBGaW5kIGZpcnN0IHVudmlzaXRlZCBpbnRlcnNlY3Rpb24uXG4gICAgdmFyIGN1cnJlbnQgPSBzdGFydCxcbiAgICAgICAgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoY3VycmVudC52KSBpZiAoKGN1cnJlbnQgPSBjdXJyZW50Lm4pID09PSBzdGFydCkgcmV0dXJuO1xuICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgZG8ge1xuICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xuICAgICAgICAgIGZvciAoaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubztcbiAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgfSB3aGlsZSAoIWN1cnJlbnQudik7XG4gICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsaW5rKGFycmF5KSB7XG4gIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBhID0gYXJyYXlbMF0sXG4gICAgICBiO1xuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEubiA9IGIgPSBhcnJheVtpXTtcbiAgICBiLnAgPSBhO1xuICAgIGEgPSBiO1xuICB9XG4gIGEubiA9IGIgPSBhcnJheVswXTtcbiAgYi5wID0gYTtcbn1cbiIsImltcG9ydCB7cmFuZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthYnMsIGNlaWwsIGVwc2lsb259IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gZ3JhdGljdWxlWCh5MCwgeTEsIGR5KSB7XG4gIHZhciB5ID0gcmFuZ2UoeTAsIHkxIC0gZXBzaWxvbiwgZHkpLmNvbmNhdCh5MSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiB5Lm1hcChmdW5jdGlvbih5KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xufVxuXG5mdW5jdGlvbiBncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgdmFyIHggPSByYW5nZSh4MCwgeDEgLSBlcHNpbG9uLCBkeCkuY29uY2F0KHgxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHkpIHsgcmV0dXJuIHgubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgdmFyIHgxLCB4MCwgWDEsIFgwLFxuICAgICAgeTEsIHkwLCBZMSwgWTAsXG4gICAgICBkeCA9IDEwLCBkeSA9IGR4LCBEWCA9IDkwLCBEWSA9IDM2MCxcbiAgICAgIHgsIHksIFgsIFksXG4gICAgICBwcmVjaXNpb24gPSAyLjU7XG5cbiAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGxpbmVzKCl9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgcmV0dXJuIHJhbmdlKGNlaWwoWDAgLyBEWCkgKiBEWCwgWDEsIERYKS5tYXAoWClcbiAgICAgICAgLmNvbmNhdChyYW5nZShjZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKVxuICAgICAgICAuY29uY2F0KHJhbmdlKGNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gYWJzKHggJSBEWCkgPiBlcHNpbG9uOyB9KS5tYXAoeCkpXG4gICAgICAgIC5jb25jYXQocmFuZ2UoY2VpbCh5MCAvIGR5KSAqIGR5LCB5MSwgZHkpLmZpbHRlcihmdW5jdGlvbih5KSB7IHJldHVybiBhYnMoeSAlIERZKSA+IGVwc2lsb247IH0pLm1hcCh5KSk7XG4gIH1cblxuICBncmF0aWN1bGUubGluZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGluZXMoKS5tYXAoZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHsgcmV0dXJuIHt0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTsgfSk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICBjb29yZGluYXRlczogW1xuICAgICAgICBYKFgwKS5jb25jYXQoXG4gICAgICAgIFkoWTEpLnNsaWNlKDEpLFxuICAgICAgICBYKFgxKS5yZXZlcnNlKCkuc2xpY2UoMSksXG4gICAgICAgIFkoWTApLnJldmVyc2UoKS5zbGljZSgxKSlcbiAgICAgIF1cbiAgICB9O1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1pbm9yKCk7XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNYWpvcihfKS5leHRlbnRNaW5vcihfKTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50TWFqb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW1tYMCwgWTBdLCBbWDEsIFkxXV07XG4gICAgWDAgPSArX1swXVswXSwgWDEgPSArX1sxXVswXTtcbiAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xuICAgIGlmIChYMCA+IFgxKSBfID0gWDAsIFgwID0gWDEsIFgxID0gXztcbiAgICBpZiAoWTAgPiBZMSkgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50TWlub3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXTtcbiAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xuICAgIGlmICh4MCA+IHgxKSBfID0geDAsIHgwID0geDEsIHgxID0gXztcbiAgICBpZiAoeTAgPiB5MSkgXyA9IHkwLCB5MCA9IHkxLCB5MSA9IF87XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUuc3RlcE1pbm9yKCk7XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWFqb3IoXykuc3RlcE1pbm9yKF8pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwTWFqb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW0RYLCBEWV07XG4gICAgRFggPSArX1swXSwgRFkgPSArX1sxXTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwTWlub3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG4gICAgZHggPSArX1swXSwgZHkgPSArX1sxXTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xuICAgIHByZWNpc2lvbiA9ICtfO1xuICAgIHggPSBncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgIHkgPSBncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcbiAgICBYID0gZ3JhdGljdWxlWChZMCwgWTEsIDkwKTtcbiAgICBZID0gZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICByZXR1cm4gZ3JhdGljdWxlXG4gICAgICAuZXh0ZW50TWFqb3IoW1stMTgwLCAtOTAgKyBlcHNpbG9uXSwgWzE4MCwgOTAgLSBlcHNpbG9uXV0pXG4gICAgICAuZXh0ZW50TWlub3IoW1stMTgwLCAtODAgLSBlcHNpbG9uXSwgWzE4MCwgODAgKyBlcHNpbG9uXV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JhdGljdWxlMTAoKSB7XG4gIHJldHVybiBncmF0aWN1bGUoKSgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiB4O1xuIiwiZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtNjtcbmV4cG9ydCB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCB2YXIgdGF1ID0gcGkgKiAyO1xuXG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgdmFyIGFicyA9IE1hdGguYWJzO1xuZXhwb3J0IHZhciBhdGFuID0gTWF0aC5hdGFuO1xuZXhwb3J0IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgdmFyIGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBleHAgPSBNYXRoLmV4cDtcbmV4cG9ydCB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuZXhwb3J0IHZhciBoeXBvdCA9IE1hdGguaHlwb3Q7XG5leHBvcnQgdmFyIGxvZyA9IE1hdGgubG9nO1xuZXhwb3J0IHZhciBwb3cgPSBNYXRoLnBvdztcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG5leHBvcnQgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5leHBvcnQgdmFyIHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICByZXR1cm4gKHggPSBzaW4oeCAvIDIpKSAqIHg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub29wKCkge31cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthYnN9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG52YXIgYXJlYVN1bSA9IG5ldyBBZGRlcigpLFxuICAgIGFyZWFSaW5nU3VtID0gbmV3IEFkZGVyKCksXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGFyZWFTdHJlYW0gPSB7XG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0O1xuICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFTdHJlYW0ucG9pbnQgPSBub29wO1xuICAgIGFyZWFTdW0uYWRkKGFicyhhcmVhUmluZ1N1bSkpO1xuICAgIGFyZWFSaW5nU3VtID0gbmV3IEFkZGVyKCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBhcmVhU3VtIC8gMjtcbiAgICBhcmVhU3VtID0gbmV3IEFkZGVyKCk7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZWFSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50Rmlyc3QoeCwgeSkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50O1xuICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50KHgsIHkpIHtcbiAgYXJlYVJpbmdTdW0uYWRkKHkwICogeCAtIHgwICogeSk7XG4gIHgwID0geCwgeTAgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgYXJlYVBvaW50KHgwMCwgeTAwKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJlYVN0cmVhbTtcbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciB4MCA9IEluZmluaXR5LFxuICAgIHkwID0geDAsXG4gICAgeDEgPSAteDAsXG4gICAgeTEgPSB4MTtcblxudmFyIGJvdW5kc1N0cmVhbSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50LFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogbm9vcCxcbiAgcG9seWdvbkVuZDogbm9vcCxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm91bmRzID0gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgeDEgPSB5MSA9IC0oeTAgPSB4MCA9IEluZmluaXR5KTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludCh4LCB5KSB7XG4gIGlmICh4IDwgeDApIHgwID0geDtcbiAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gIGlmICh5ID4geTEpIHkxID0geTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYm91bmRzU3RyZWFtO1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG4vLyBUT0RPIEVuZm9yY2UgcG9zaXRpdmUgYXJlYSBmb3IgZXh0ZXJpb3IsIG5lZ2F0aXZlIGFyZWEgZm9yIGludGVyaW9yP1xuXG52YXIgWDAgPSAwLFxuICAgIFkwID0gMCxcbiAgICBaMCA9IDAsXG4gICAgWDEgPSAwLFxuICAgIFkxID0gMCxcbiAgICBaMSA9IDAsXG4gICAgWDIgPSAwLFxuICAgIFkyID0gMCxcbiAgICBaMiA9IDAsXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBwb2ludDogY2VudHJvaWRQb2ludCxcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcbiAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjZW50cm9pZCA9IFoyID8gW1gyIC8gWjIsIFkyIC8gWjJdXG4gICAgICAgIDogWjEgPyBbWDEgLyBaMSwgWTEgLyBaMV1cbiAgICAgICAgOiBaMCA/IFtYMCAvIFowLCBZMCAvIFowXVxuICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgWDAgPSBZMCA9IFowID1cbiAgICBYMSA9IFkxID0gWjEgPVxuICAgIFgyID0gWTIgPSBaMiA9IDA7XG4gICAgcmV0dXJuIGNlbnRyb2lkO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KHgsIHkpIHtcbiAgWDAgKz0geDtcbiAgWTAgKz0geTtcbiAgKytaMDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0TGluZTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0TGluZSh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludExpbmU7XG4gIGNlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50TGluZSh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgWjEgKz0gejtcbiAgY2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RSaW5nO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUG9pbnRSaW5nKHgwMCwgeTAwKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0UmluZyh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludFJpbmc7XG4gIGNlbnRyb2lkUG9pbnQoeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50UmluZyh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCxcbiAgICAgIGR5ID0geSAtIHkwLFxuICAgICAgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gIFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gIFoxICs9IHo7XG5cbiAgeiA9IHkwICogeCAtIHgwICogeTtcbiAgWDIgKz0geiAqICh4MCArIHgpO1xuICBZMiArPSB6ICogKHkwICsgeSk7XG4gIFoyICs9IHogKiAzO1xuICBjZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2VudHJvaWRTdHJlYW07XG4iLCJpbXBvcnQge3RhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblBhdGhDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCArIHRoaXMuX3JhZGl1cywgeSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKHgsIHksIHRoaXMuX3JhZGl1cywgMCwgdGF1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXN1bHQ6IG5vb3Bcbn07XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuLi9zdHJlYW0uanNcIjtcbmltcG9ydCBwYXRoQXJlYSBmcm9tIFwiLi9hcmVhLmpzXCI7XG5pbXBvcnQgcGF0aEJvdW5kcyBmcm9tIFwiLi9ib3VuZHMuanNcIjtcbmltcG9ydCBwYXRoQ2VudHJvaWQgZnJvbSBcIi4vY2VudHJvaWQuanNcIjtcbmltcG9ydCBQYXRoQ29udGV4dCBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQgcGF0aE1lYXN1cmUgZnJvbSBcIi4vbWVhc3VyZS5qc1wiO1xuaW1wb3J0IFBhdGhTdHJpbmcgZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHByb2plY3Rpb24sIGNvbnRleHQpIHtcbiAgbGV0IGRpZ2l0cyA9IDMsXG4gICAgICBwb2ludFJhZGl1cyA9IDQuNSxcbiAgICAgIHByb2plY3Rpb25TdHJlYW0sXG4gICAgICBjb250ZXh0U3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHBhdGgob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtwb2ludFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY29udGV4dFN0cmVhbSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcbiAgfVxuXG4gIHBhdGguYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aEFyZWEpKTtcbiAgICByZXR1cm4gcGF0aEFyZWEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoTWVhc3VyZSkpO1xuICAgIHJldHVybiBwYXRoTWVhc3VyZS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aEJvdW5kcykpO1xuICAgIHJldHVybiBwYXRoQm91bmRzLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGguY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhDZW50cm9pZCkpO1xuICAgIHJldHVybiBwYXRoQ2VudHJvaWQucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByb2plY3Rpb247XG4gICAgcHJvamVjdGlvblN0cmVhbSA9IF8gPT0gbnVsbCA/IChwcm9qZWN0aW9uID0gbnVsbCwgaWRlbnRpdHkpIDogKHByb2plY3Rpb24gPSBfKS5zdHJlYW07XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcGF0aC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgY29udGV4dFN0cmVhbSA9IF8gPT0gbnVsbCA/IChjb250ZXh0ID0gbnVsbCwgbmV3IFBhdGhTdHJpbmcoZGlnaXRzKSkgOiBuZXcgUGF0aENvbnRleHQoY29udGV4dCA9IF8pO1xuICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb2ludFJhZGl1cztcbiAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcGF0aC5kaWdpdHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGlnaXRzO1xuICAgIGlmIChfID09IG51bGwpIGRpZ2l0cyA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBkID0gTWF0aC5mbG9vcihfKTtcbiAgICAgIGlmICghKGQgPj0gMCkpIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGRpZ2l0czogJHtffWApO1xuICAgICAgZGlnaXRzID0gZDtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIGNvbnRleHRTdHJlYW0gPSBuZXcgUGF0aFN0cmluZyhkaWdpdHMpO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHJldHVybiBwYXRoLnByb2plY3Rpb24ocHJvamVjdGlvbikuZGlnaXRzKGRpZ2l0cykuY29udGV4dChjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIGxlbmd0aFN1bSA9IG5ldyBBZGRlcigpLFxuICAgIGxlbmd0aFJpbmcsXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGxlbmd0aFN0cmVhbSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoUG9pbnRGaXJzdDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGxlbmd0aFJpbmcpIGxlbmd0aFBvaW50KHgwMCwgeTAwKTtcbiAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBub29wO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSB0cnVlO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhSaW5nID0gbnVsbDtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gK2xlbmd0aFN1bTtcbiAgICBsZW5ndGhTdW0gPSBuZXcgQWRkZXIoKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0KHgsIHkpIHtcbiAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoUG9pbnQ7XG4gIHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5O1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQb2ludCh4LCB5KSB7XG4gIHgwIC09IHgsIHkwIC09IHk7XG4gIGxlbmd0aFN1bS5hZGQoc3FydCh4MCAqIHgwICsgeTAgKiB5MCkpO1xuICB4MCA9IHgsIHkwID0geTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGVuZ3RoU3RyZWFtO1xuIiwiLy8gU2ltcGxlIGNhY2hpbmcgZm9yIGNvbnN0YW50LXJhZGl1cyBwb2ludHMuXG5sZXQgY2FjaGVEaWdpdHMsIGNhY2hlQXBwZW5kLCBjYWNoZVJhZGl1cywgY2FjaGVDaXJjbGU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhTdHJpbmcge1xuICBjb25zdHJ1Y3RvcihkaWdpdHMpIHtcbiAgICB0aGlzLl9hcHBlbmQgPSBkaWdpdHMgPT0gbnVsbCA/IGFwcGVuZCA6IGFwcGVuZFJvdW5kKGRpZ2l0cyk7XG4gICAgdGhpcy5fcmFkaXVzID0gNC41O1xuICAgIHRoaXMuXyA9IFwiXCI7XG4gIH1cbiAgcG9pbnRSYWRpdXMoXykge1xuICAgIHRoaXMuX3JhZGl1cyA9ICtfO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBvbHlnb25TdGFydCgpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfVxuICBwb2x5Z29uRW5kKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH1cbiAgbGluZVN0YXJ0KCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfVxuICBsaW5lRW5kKCkge1xuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl8gKz0gXCJaXCI7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH1cbiAgcG9pbnQoeCwgeSkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9hcHBlbmRgTSR7eH0sJHt5fWA7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fYXBwZW5kYEwke3h9LCR7eX1gO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5fYXBwZW5kYE0ke3h9LCR7eX1gO1xuICAgICAgICBpZiAodGhpcy5fcmFkaXVzICE9PSBjYWNoZVJhZGl1cyB8fCB0aGlzLl9hcHBlbmQgIT09IGNhY2hlQXBwZW5kKSB7XG4gICAgICAgICAgY29uc3QgciA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgICBjb25zdCBzID0gdGhpcy5fO1xuICAgICAgICAgIHRoaXMuXyA9IFwiXCI7IC8vIHN0YXNoIHRoZSBvbGQgc3RyaW5nIHNvIHdlIGNhbiBjYWNoZSB0aGUgY2lyY2xlIHBhdGggZnJhZ21lbnRcbiAgICAgICAgICB0aGlzLl9hcHBlbmRgbTAsJHtyfWEke3J9LCR7cn0gMCAxLDEgMCwkey0yICogcn1hJHtyfSwke3J9IDAgMSwxIDAsJHsyICogcn16YDtcbiAgICAgICAgICBjYWNoZVJhZGl1cyA9IHI7XG4gICAgICAgICAgY2FjaGVBcHBlbmQgPSB0aGlzLl9hcHBlbmQ7XG4gICAgICAgICAgY2FjaGVDaXJjbGUgPSB0aGlzLl87XG4gICAgICAgICAgdGhpcy5fID0gcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl8gKz0gY2FjaGVDaXJjbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXN1bHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fO1xuICAgIHRoaXMuXyA9IFwiXCI7XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZChzdHJpbmdzKSB7XG4gIGxldCBpID0gMTtcbiAgdGhpcy5fICs9IHN0cmluZ3NbMF07XG4gIGZvciAoY29uc3QgaiA9IHN0cmluZ3MubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgdGhpcy5fICs9IGFyZ3VtZW50c1tpXSArIHN0cmluZ3NbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwZW5kUm91bmQoZGlnaXRzKSB7XG4gIGNvbnN0IGQgPSBNYXRoLmZsb29yKGRpZ2l0cyk7XG4gIGlmICghKGQgPj0gMCkpIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGRpZ2l0czogJHtkaWdpdHN9YCk7XG4gIGlmIChkID4gMTUpIHJldHVybiBhcHBlbmQ7XG4gIGlmIChkICE9PSBjYWNoZURpZ2l0cykge1xuICAgIGNvbnN0IGsgPSAxMCAqKiBkO1xuICAgIGNhY2hlRGlnaXRzID0gZDtcbiAgICBjYWNoZUFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChzdHJpbmdzKSB7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICB0aGlzLl8gKz0gc3RyaW5nc1swXTtcbiAgICAgIGZvciAoY29uc3QgaiA9IHN0cmluZ3MubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIHRoaXMuXyArPSBNYXRoLnJvdW5kKGFyZ3VtZW50c1tpXSAqIGspIC8gayArIHN0cmluZ3NbaV07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2FjaGVBcHBlbmQ7XG59XG4iLCJpbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbjtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyBnZW9TdHJlYW19IGZyb20gXCIuLi9zdHJlYW0uanNcIjtcbmltcG9ydCBib3VuZHNTdHJlYW0gZnJvbSBcIi4uL3BhdGgvYm91bmRzLmpzXCI7XG5cbmZ1bmN0aW9uIGZpdChwcm9qZWN0aW9uLCBmaXRCb3VuZHMsIG9iamVjdCkge1xuICB2YXIgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgcHJvamVjdGlvbi5zY2FsZSgxNTApLnRyYW5zbGF0ZShbMCwgMF0pO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSkpO1xuICBmaXRCb3VuZHMoYm91bmRzU3RyZWFtLnJlc3VsdCgpKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KGNsaXApO1xuICByZXR1cm4gcHJvamVjdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSxcbiAgICAgICAgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSxcbiAgICAgICAgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksXG4gICAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSArd2lkdGgsXG4gICAgICAgIGsgPSB3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSxcbiAgICAgICAgeCA9ICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9IC1rICogYlswXVsxXTtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciBoID0gK2hlaWdodCxcbiAgICAgICAgayA9IGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pLFxuICAgICAgICB4ID0gLWsgKiBiWzBdWzBdLFxuICAgICAgICB5ID0gKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG4iLCJpbXBvcnQgY2xpcFJlY3RhbmdsZSBmcm9tIFwiLi4vY2xpcC9yZWN0YW5nbGUuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCB7Zml0RXh0ZW50LCBmaXRTaXplLCBmaXRXaWR0aCwgZml0SGVpZ2h0fSBmcm9tIFwiLi9maXQuanNcIjtcbmltcG9ydCB7Y29zLCBkZWdyZWVzLCByYWRpYW5zLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgayA9IDEsIHR4ID0gMCwgdHkgPSAwLCBzeCA9IDEsIHN5ID0gMSwgLy8gc2NhbGUsIHRyYW5zbGF0ZSBhbmQgcmVmbGVjdFxuICAgICAgYWxwaGEgPSAwLCBjYSwgc2EsIC8vIGFuZ2xlXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIC8vIGNsaXAgZXh0ZW50XG4gICAgICBreCA9IDEsIGt5ID0gMSxcbiAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybWVyKHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICB2YXIgcCA9IHByb2plY3Rpb24oW3gsIHldKVxuICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHBbMF0sIHBbMV0pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHBvc3RjbGlwID0gaWRlbnRpdHksXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGt4ID0gayAqIHN4O1xuICAgIGt5ID0gayAqIHN5O1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdGlvbiAocCkge1xuICAgIHZhciB4ID0gcFswXSAqIGt4LCB5ID0gcFsxXSAqIGt5O1xuICAgIGlmIChhbHBoYSkge1xuICAgICAgdmFyIHQgPSB5ICogY2EgLSB4ICogc2E7XG4gICAgICB4ID0geCAqIGNhICsgeSAqIHNhO1xuICAgICAgeSA9IHQ7XG4gICAgfSAgICBcbiAgICByZXR1cm4gW3ggKyB0eCwgeSArIHR5XTtcbiAgfVxuICBwcm9qZWN0aW9uLmludmVydCA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgeCA9IHBbMF0gLSB0eCwgeSA9IHBbMV0gLSB0eTtcbiAgICBpZiAoYWxwaGEpIHtcbiAgICAgIHZhciB0ID0geSAqIGNhICsgeCAqIHNhO1xuICAgICAgeCA9IHggKiBjYSAtIHkgKiBzYTtcbiAgICAgIHkgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gW3ggLyBreCwgeSAvIGt5XTtcbiAgfTtcbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm0ocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKTtcbiAgfTtcbiAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgfTtcbiAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcFJlY3RhbmdsZSh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICB9O1xuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVzZXQoKSkgOiBrO1xuICB9O1xuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eCA9ICtfWzBdLCB0eSA9ICtfWzFdLCByZXNldCgpKSA6IFt0eCwgdHldO1xuICB9XG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgc2EgPSBzaW4oYWxwaGEpLCBjYSA9IGNvcyhhbHBoYSksIHJlc2V0KCkpIDogYWxwaGEgKiBkZWdyZWVzO1xuICB9O1xuICBwcm9qZWN0aW9uLnJlZmxlY3RYID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN4ID0gXyA/IC0xIDogMSwgcmVzZXQoKSkgOiBzeCA8IDA7XG4gIH07XG4gIHByb2plY3Rpb24ucmVmbGVjdFkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3kgPSBfID8gLTEgOiAxLCByZXNldCgpKSA6IHN5IDwgMDtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0aW9uO1xufVxuIiwiZnVuY3Rpb24gc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIHN0cmVhbSkge1xuICBpZiAoZ2VvbWV0cnkgJiYgc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59XG5cbnZhciBzdHJlYW1PYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59O1xuXG52YXIgc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtLnNwaGVyZSgpO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xuICB9LFxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gIH0sXG4gIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgc3RyZWFtKTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBzdHJlYW0sIGNsb3NlZCkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgc3RyZWFtLmxpbmVFbmQoKTtcbn1cblxuZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMSk7XG4gIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gIGlmIChvYmplY3QgJiYgc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICBzdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBzdHJlYW0pO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtZXRob2RzKSB7XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtZXIobWV0aG9kcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSBzW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHt9XG5cblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpOyB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCk7IH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG59O1xuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiAoaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5IDogZ2VuZXJpY0FycmF5KShhLCBiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyaWNBcnJheShhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gdmFsdWUoYVtpXSwgYltpXSk7XG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtiYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBkID0gbmV3IERhdGU7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkLnNldFRpbWUoYSAqICgxIC0gdCkgKyBiICogdCksIGQ7XG4gIH07XG59XG4iLCJpbXBvcnQge2xhYiBhcyBjb2xvckxhYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBjb2xvcigoc3RhcnQgPSBjb2xvckxhYihzdGFydCkpLmwsIChlbmQgPSBjb2xvckxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBjb2xvcihzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFiKSBiID0gW107XG4gIHZhciBuID0gYSA/IE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgYyA9IGIuc2xpY2UoKSxcbiAgICAgIGk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY1tpXSA9IGFbaV0gKiAoMSAtIHQpICsgYltpXSAqIHQ7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlckFycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgaSA9IHt9LFxuICAgICAgYyA9IHt9LFxuICAgICAgaztcblxuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IHZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyB2YWx1ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB2YWx1ZXMgPSBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtyZ2IgYXMgY29sb3JSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGJhc2lzIGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5pbXBvcnQgYmFzaXNDbG9zZWQgZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmltcG9ydCBub2dhbW1hLCB7Z2FtbWF9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBjb2xvclJnYihzdGFydCkpLnIsIChlbmQgPSBjb2xvclJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGNvbG9yUmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMpO1xuZXhwb3J0IHZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiAoMSAtIHQpICsgYiAqIHQpO1xuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHJnYiBmcm9tIFwiLi9yZ2IuanNcIjtcbmltcG9ydCB7Z2VuZXJpY0FycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGRhdGUgZnJvbSBcIi4vZGF0ZS5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCBvYmplY3QgZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5pbXBvcnQgc3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG4iLCJ2YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHpvb21SaG8ocmhvLCByaG8yLCByaG80KSB7XG5cbiAgLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuICAvLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG4gIGZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGksXG4gICAgICAgIFM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhbCBjYXNlLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwICogcmhvIC8gTWF0aC5TUVJUMjtcblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgem9vbS5yaG8gPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIF8xID0gTWF0aC5tYXgoMWUtMywgK18pLCBfMiA9IF8xICogXzEsIF80ID0gXzIgKiBfMjtcbiAgICByZXR1cm4gem9vbVJobyhfMSwgXzIsIF80KTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn0pKE1hdGguU1FSVDIsIDIsIDQpO1xuIiwiY29uc3QgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gYXBwZW5kKHN0cmluZ3MpIHtcbiAgdGhpcy5fICs9IHN0cmluZ3NbMF07XG4gIGZvciAobGV0IGkgPSAxLCBuID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLl8gKz0gYXJndW1lbnRzW2ldICsgc3RyaW5nc1tpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBlbmRSb3VuZChkaWdpdHMpIHtcbiAgbGV0IGQgPSBNYXRoLmZsb29yKGRpZ2l0cyk7XG4gIGlmICghKGQgPj0gMCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7ZGlnaXRzfWApO1xuICBpZiAoZCA+IDE1KSByZXR1cm4gYXBwZW5kO1xuICBjb25zdCBrID0gMTAgKiogZDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgICB0aGlzLl8gKz0gc3RyaW5nc1swXTtcbiAgICBmb3IgKGxldCBpID0gMSwgbiA9IHN0cmluZ3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0aGlzLl8gKz0gTWF0aC5yb3VuZChhcmd1bWVudHNbaV0gKiBrKSAvIGsgKyBzdHJpbmdzW2ldO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihkaWdpdHMpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3kwID0gLy8gc3RhcnQgb2YgY3VycmVudCBzdWJwYXRoXG4gICAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl8gPSBcIlwiO1xuICAgIHRoaXMuX2FwcGVuZCA9IGRpZ2l0cyA9PSBudWxsID8gYXBwZW5kIDogYXBwZW5kUm91bmQoZGlnaXRzKTtcbiAgfVxuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MCA9IHRoaXMuX3gxID0gK3h9LCR7dGhpcy5feTAgPSB0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuX2FwcGVuZGBaYDtcbiAgICB9XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgTCR7dGhpcy5feDEgPSAreH0sJHt0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgcXVhZHJhdGljQ3VydmVUbyh4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgUSR7K3gxfSwkeyt5MX0sJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBiZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fYXBwZW5kYEMkeyt4MX0sJHsreTF9LCR7K3gyfSwkeyt5Mn0sJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBhcmNUbyh4MSwgeTEsIHgyLCB5Miwgcikge1xuICAgIHgxID0gK3gxLCB5MSA9ICt5MSwgeDIgPSAreDIsIHkyID0gK3kyLCByID0gK3I7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke3J9YCk7XG5cbiAgICBsZXQgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgxLHkxKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MSA9IHgxfSwke3RoaXMuX3kxID0geTF9YDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgTCR7dGhpcy5feDEgPSB4MX0sJHt0aGlzLl95MSA9IHkxfWA7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIGxldCB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSxcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxuICAgICAgICAgIHQyMSA9IGwgLyBsMjE7XG5cbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgIGlmIChNYXRoLmFicyh0MDEgLSAxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kYEwke3gxICsgdDAxICogeDAxfSwke3kxICsgdDAxICogeTAxfWA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsMCwkeysoeTAxICogeDIwID4geDAxICogeTIwKX0sJHt0aGlzLl94MSA9IHgxICsgdDIxICogeDIxfSwke3RoaXMuX3kxID0geTEgKyB0MjEgKiB5MjF9YDtcbiAgICB9XG4gIH1cbiAgYXJjKHgsIHksIHIsIGEwLCBhMSwgY2N3KSB7XG4gICAgeCA9ICt4LCB5ID0gK3ksIHIgPSArciwgY2N3ID0gISFjY3c7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke3J9YCk7XG5cbiAgICBsZXQgZHggPSByICogTWF0aC5jb3MoYTApLFxuICAgICAgICBkeSA9IHIgKiBNYXRoLnNpbihhMCksXG4gICAgICAgIHgwID0geCArIGR4LFxuICAgICAgICB5MCA9IHkgKyBkeSxcbiAgICAgICAgY3cgPSAxIF4gY2N3LFxuICAgICAgICBkYSA9IGNjdyA/IGEwIC0gYTEgOiBhMSAtIGEwO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MCx5MCkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgTSR7eDB9LCR7eTB9YDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHkwKSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBMJHt4MH0sJHt5MH1gO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgQSR7cn0sJHtyfSwwLDEsJHtjd30sJHt4IC0gZHh9LCR7eSAtIGR5fUEke3J9LCR7cn0sMCwxLCR7Y3d9LCR7dGhpcy5feDEgPSB4MH0sJHt0aGlzLl95MSA9IHkwfWA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgbm9uLWVtcHR5PyBEcmF3IGFuIGFyYyFcbiAgICBlbHNlIGlmIChkYSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsJHsrKGRhID49IHBpKX0sJHtjd30sJHt0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpfSwke3RoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSl9YDtcbiAgICB9XG4gIH1cbiAgcmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9aCR7dyA9ICt3fXYkeytofWgkey13fVpgO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGgoKSB7XG4gIHJldHVybiBuZXcgUGF0aDtcbn1cblxuLy8gQWxsb3cgaW5zdGFuY2VvZiBkMy5wYXRoXG5wYXRoLnByb3RvdHlwZSA9IFBhdGgucHJvdG90eXBlO1xuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFJvdW5kKGRpZ2l0cyA9IDMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKCtkaWdpdHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBjb25zdCB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcbiAgICAgIHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpO1xuICByZXR1cm4gYWRkKHRoaXMuY292ZXIoeCwgeSksIHgsIHksIGQpO1xufVxuXG5mdW5jdGlvbiBhZGQodHJlZSwgeCwgeSwgZCkge1xuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXG4gICAgICBsZWFmID0ge2RhdGE6IGR9LFxuICAgICAgeDAgPSB0cmVlLl94MCxcbiAgICAgIHkwID0gdHJlZS5feTAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeTEgPSB0cmVlLl95MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB4cCxcbiAgICAgIHlwLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cbiAgd2hpbGUgKG5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKHBhcmVudCA9IG5vZGUsICEobm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG4gIH1cblxuICAvLyBJcyB0aGUgbmV3IHBvaW50IGlzIGV4YWN0bHkgY29pbmNpZGVudCB3aXRoIHRoZSBleGlzdGluZyBwb2ludD9cbiAgeHAgPSArdHJlZS5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDQpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg0KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgfSB3aGlsZSAoKGkgPSBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgdmFyIGQsIGksIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeHogPSBuZXcgQXJyYXkobiksXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgY29udGludWU7XG4gICAgeHpbaV0gPSB4O1xuICAgIHl6W2ldID0geTtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICAgIGlmICh5IDwgeTApIHkwID0geTtcbiAgICBpZiAoeSA+IHkxKSB5MSA9IHk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlIG5vICh2YWxpZCkgcG9pbnRzLCBhYm9ydC5cbiAgaWYgKHgwID4geDEgfHwgeTAgPiB5MSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRXhwYW5kIHRoZSB0cmVlIHRvIGNvdmVyIHRoZSBuZXcgcG9pbnRzLlxuICB0aGlzLmNvdmVyKHgwLCB5MCkuY292ZXIoeDEsIHkxKTtcblxuICAvLyBBZGQgdGhlIG5ldyBwb2ludHMuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCBkYXRhW2ldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTE7XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2Uge1xuICAgIHZhciB6ID0geDEgLSB4MCB8fCAxLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKHgwID4geCB8fCB4ID49IHgxIHx8IHkwID4geSB8fCB5ID49IHkxKSB7XG4gICAgICBpID0gKHkgPCB5MCkgPDwgMSB8ICh4IDwgeDApO1xuICAgICAgcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50LCB6ICo9IDI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOiB4MSA9IHgwICsgeiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHgwID0geDEgLSB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogeDEgPSB4MCArIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiB4MCA9IHgxIC0geiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxuICAgICAgOiBpc05hTih0aGlzLl94MCkgPyB1bmRlZmluZWQgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXTtcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gIHZhciBkYXRhLFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgzID0gdGhpcy5feDEsXG4gICAgICB5MyA9IHRoaXMuX3kxLFxuICAgICAgcXVhZHMgPSBbXSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcSxcbiAgICAgIGk7XG5cbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgeDAsIHkwLCB4MywgeTMpKTtcbiAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgZWxzZSB7XG4gICAgeDAgPSB4IC0gcmFkaXVzLCB5MCA9IHkgLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzLCB5MyA9IHkgKyByYWRpdXM7XG4gICAgcmFkaXVzICo9IHJhZGl1cztcbiAgfVxuXG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcblxuICAgIC8vIFN0b3Agc2VhcmNoaW5nIGlmIHRoaXMgcXVhZHJhbnQgY2Fu4oCZdCBjb250YWluIGEgY2xvc2VyIG5vZGUuXG4gICAgaWYgKCEobm9kZSA9IHEubm9kZSlcbiAgICAgICAgfHwgKHgxID0gcS54MCkgPiB4M1xuICAgICAgICB8fCAoeTEgPSBxLnkwKSA+IHkzXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDBcbiAgICAgICAgfHwgKHkyID0gcS55MSkgPCB5MCkgY29udGludWU7XG5cbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgcXVhZHJhbnQuXG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgIHltID0gKHkxICsgeTIpIC8gMjtcblxuICAgICAgcXVhZHMucHVzaChcbiAgICAgICAgbmV3IFF1YWQobm9kZVszXSwgeG0sIHltLCB4MiwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzJdLCB4MSwgeW0sIHhtLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMV0sIHhtLCB5MSwgeDIsIHltKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVswXSwgeDEsIHkxLCB4bSwgeW0pXG4gICAgICApO1xuXG4gICAgICAvLyBWaXNpdCB0aGUgY2xvc2VzdCBxdWFkcmFudCBmaXJzdC5cbiAgICAgIGlmIChpID0gKHkgPj0geW0pIDw8IDEgfCAoeCA+PSB4bSkpIHtcbiAgICAgICAgcSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxXSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldID0gcTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaXNpdCB0aGlzIHBvaW50LiAoVmlzaXRpbmcgY29pbmNpZGVudCBwb2ludHMgaXNu4oCZdCBuZWNlc3NhcnkhKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGR4ID0geCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkeSA9IHkgLSArdGhpcy5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA8IHJhZGl1cykge1xuICAgICAgICB2YXIgZCA9IE1hdGguc3FydChyYWRpdXMgPSBkMik7XG4gICAgICAgIHgwID0geCAtIGQsIHkwID0geSAtIGQ7XG4gICAgICAgIHgzID0geCArIGQsIHkzID0geSArIGQ7XG4gICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLngwID0geDA7XG4gIHRoaXMueTAgPSB5MDtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG59XG4iLCJpbXBvcnQgdHJlZV9hZGQsIHthZGRBbGwgYXMgdHJlZV9hZGRBbGx9IGZyb20gXCIuL2FkZC5qc1wiO1xuaW1wb3J0IHRyZWVfY292ZXIgZnJvbSBcIi4vY292ZXIuanNcIjtcbmltcG9ydCB0cmVlX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHRyZWVfZXh0ZW50IGZyb20gXCIuL2V4dGVudC5qc1wiO1xuaW1wb3J0IHRyZWVfZmluZCBmcm9tIFwiLi9maW5kLmpzXCI7XG5pbXBvcnQgdHJlZV9yZW1vdmUsIHtyZW1vdmVBbGwgYXMgdHJlZV9yZW1vdmVBbGx9IGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyZWVfcm9vdCBmcm9tIFwiLi9yb290LmpzXCI7XG5pbXBvcnQgdHJlZV9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0IGZyb20gXCIuL3Zpc2l0LmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdEFmdGVyIGZyb20gXCIuL3Zpc2l0QWZ0ZXIuanNcIjtcbmltcG9ydCB0cmVlX3gsIHtkZWZhdWx0WH0gZnJvbSBcIi4veC5qc1wiO1xuaW1wb3J0IHRyZWVfeSwge2RlZmF1bHRZfSBmcm9tIFwiLi95LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XG4gIHZhciB0cmVlID0gbmV3IFF1YWR0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIFF1YWR0cmVlKHgsIHksIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgdGhpcy5fcm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbGVhZl9jb3B5KGxlYWYpIHtcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XG4gIHdoaWxlIChsZWFmID0gbGVhZi5uZXh0KSBuZXh0ID0gbmV4dC5uZXh0ID0ge2RhdGE6IGxlYWYuZGF0YX07XG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgdHJlZVByb3RvID0gcXVhZHRyZWUucHJvdG90eXBlID0gUXVhZHRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBRdWFkdHJlZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoNCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IHRyZWVfYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gdHJlZV9yZW1vdmVBbGw7XG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcbnRyZWVQcm90by5zaXplID0gdHJlZV9zaXplO1xudHJlZVByb3RvLnZpc2l0ID0gdHJlZV92aXNpdDtcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xudHJlZVByb3RvLnggPSB0cmVlX3g7XG50cmVlUHJvdG8ueSA9IHRyZWVfeTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICByZXRhaW5lcixcbiAgICAgIHByZXZpb3VzLFxuICAgICAgbmV4dCxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAvLyBGaW5kIHRoZSBsZWFmIG5vZGUgZm9yIHRoZSBwb2ludC5cbiAgLy8gV2hpbGUgZGVzY2VuZGluZywgYWxzbyByZXRhaW4gdGhlIGRlZXBlc3QgcGFyZW50IHdpdGggYSBub24tcmVtb3ZlZCBzaWJsaW5nLlxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudFsoaSArIDEpICYgM10gfHwgcGFyZW50WyhpICsgMikgJiAzXSB8fCBwYXJlbnRbKGkgKyAzKSAmIDNdKSByZXRhaW5lciA9IHBhcmVudCwgaiA9IGk7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBwb2ludCB0byByZW1vdmUuXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xuICBpZiAobmV4dCA9IG5vZGUubmV4dCkgZGVsZXRlIG5vZGUubmV4dDtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cbiAgaWYgKHByZXZpb3VzKSByZXR1cm4gKG5leHQgPyBwcmV2aW91cy5uZXh0ID0gbmV4dCA6IGRlbGV0ZSBwcmV2aW91cy5uZXh0KSwgdGhpcztcblxuICAvLyBJZiB0aGlzIGlzIHRoZSByb290IHBvaW50LCByZW1vdmUgaXQuXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVhZi5cbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgbm93IGNvbnRhaW5zIGV4YWN0bHkgb25lIGxlYWYsIGNvbGxhcHNlIHN1cGVyZmx1b3VzIHBhcmVudHMuXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcbiAgICAgICYmIG5vZGUgPT09IChwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIG5leHQgPSBbXSwgcTtcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIHZhciBub2RlID0gcS5ub2RlO1xuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICB9XG4gICAgbmV4dC5wdXNoKHEpO1xuICB9XG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKHEubm9kZSwgcS54MCwgcS55MCwgcS54MSwgcS55MSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFgoZCkge1xuICByZXR1cm4gZFswXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gXywgdGhpcykgOiB0aGlzLl94O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feSA9IF8sIHRoaXMpIDogdGhpcy5feTtcbn1cbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4uL2NvbG9ycy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjb2xvcnMoXCI4ZGQzYzdmZmZmYjNiZWJhZGFmYjgwNzI4MGIxZDNmZGI0NjJiM2RlNjlmY2NkZTVkOWQ5ZDliYzgwYmRjY2ViYzVmZmVkNmZcIik7XG4iLCJpbXBvcnQgY29sb3JzIGZyb20gXCIuLi9jb2xvcnMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY29sb3JzKFwiMWY3N2I0ZmY3ZjBlMmNhMDJjZDYyNzI4OTQ2N2JkOGM1NjRiZTM3N2MyN2Y3ZjdmYmNiZDIyMTdiZWNmXCIpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gIHZhciBuID0gc3BlY2lmaWVyLmxlbmd0aCAvIDYgfCAwLCBjb2xvcnMgPSBuZXcgQXJyYXkobiksIGkgPSAwO1xuICB3aGlsZSAoaSA8IG4pIGNvbG9yc1tpXSA9IFwiI1wiICsgc3BlY2lmaWVyLnNsaWNlKGkgKiA2LCArK2kgKiA2KTtcbiAgcmV0dXJuIGNvbG9ycztcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVSZ2JCYXNpc30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHNjaGVtZSA9PiBpbnRlcnBvbGF0ZVJnYkJhc2lzKHNjaGVtZVtzY2hlbWUubGVuZ3RoIC0gMV0pO1xuIiwiaW1wb3J0IGNvbG9ycyBmcm9tIFwiLi4vY29sb3JzLmpzXCI7XG5pbXBvcnQgcmFtcCBmcm9tIFwiLi4vcmFtcC5qc1wiO1xuXG5leHBvcnQgdmFyIHNjaGVtZSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmVlOGM4ZmRiYjg0ZTM0YTMzXCIsXG4gIFwiZmVmMGQ5ZmRjYzhhZmM4ZDU5ZDczMDFmXCIsXG4gIFwiZmVmMGQ5ZmRjYzhhZmM4ZDU5ZTM0YTMzYjMwMDAwXCIsXG4gIFwiZmVmMGQ5ZmRkNDllZmRiYjg0ZmM4ZDU5ZTM0YTMzYjMwMDAwXCIsXG4gIFwiZmVmMGQ5ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmOTkwMDAwXCIsXG4gIFwiZmZmN2VjZmVlOGM4ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmOTkwMDAwXCIsXG4gIFwiZmZmN2VjZmVlOGM4ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmYjMwMDAwN2YwMDAwXCJcbikubWFwKGNvbG9ycyk7XG5cbmV4cG9ydCBkZWZhdWx0IHJhbXAoc2NoZW1lKTtcbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4uL2NvbG9ycy5qc1wiO1xuaW1wb3J0IHJhbXAgZnJvbSBcIi4uL3JhbXAuanNcIjtcblxuZXhwb3J0IHZhciBzY2hlbWUgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVkZjhiMTdmY2RiYjJjN2ZiOFwiLFxuICBcImZmZmZjY2ExZGFiNDQxYjZjNDIyNWVhOFwiLFxuICBcImZmZmZjY2ExZGFiNDQxYjZjNDJjN2ZiODI1MzQ5NFwiLFxuICBcImZmZmZjY2M3ZTliNDdmY2RiYjQxYjZjNDJjN2ZiODI1MzQ5NFwiLFxuICBcImZmZmZjY2M3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODBjMmM4NFwiLFxuICBcImZmZmZkOWVkZjhiMWM3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODBjMmM4NFwiLFxuICBcImZmZmZkOWVkZjhiMWM3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODI1MzQ5NDA4MWQ1OFwiXG4pLm1hcChjb2xvcnMpO1xuXG5leHBvcnQgZGVmYXVsdCByYW1wKHNjaGVtZSk7XG4iLCJpbXBvcnQge3JhbmdlIGFzIHNlcXVlbmNlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5pbXBvcnQgb3JkaW5hbCBmcm9tIFwiLi9vcmRpbmFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHIwID0gMCxcbiAgICAgIHIxID0gMSxcbiAgICAgIHN0ZXAsXG4gICAgICBiYW5kd2lkdGgsXG4gICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgcGFkZGluZ0lubmVyID0gMCxcbiAgICAgIHBhZGRpbmdPdXRlciA9IDAsXG4gICAgICBhbGlnbiA9IDAuNTtcblxuICBkZWxldGUgc2NhbGUudW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBuID0gZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICByZXZlcnNlID0gcjEgPCByMCxcbiAgICAgICAgc3RhcnQgPSByZXZlcnNlID8gcjEgOiByMCxcbiAgICAgICAgc3RvcCA9IHJldmVyc2UgPyByMCA6IHIxO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcXVlbmNlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbcjAsIHIxXSA9IF8sIHIwID0gK3IwLCByMSA9ICtyMSwgcmVzY2FsZSgpKSA6IFtyMCwgcjFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIFtyMCwgcjFdID0gXywgcjAgPSArcjAsIHIxID0gK3IxLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgcGFkZGluZ091dGVyID0gK18pLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbigxLCBfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gK18sIHJlc2NhbGUoKSkgOiBwYWRkaW5nT3V0ZXI7XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBhbGlnbjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmQoZG9tYWluKCksIFtyMCwgcjFdKVxuICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcbiAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHJlc2NhbGUoKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhZGRpbmdJbm5lcigxKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25zdGFudHMoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2ludGVycG9sYXRlIGFzIGludGVycG9sYXRlVmFsdWUsIGludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHVuaXQgPSBbMCwgMV07XG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgYikge1xuICByZXR1cm4gKGIgLT0gKGEgPSArYSkpXG4gICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICh4IC0gYSkgLyBiOyB9XG4gICAgICA6IGNvbnN0YW50KGlzTmFOKGIpID8gTmFOIDogMC41KTtcbn1cblxuZnVuY3Rpb24gY2xhbXBlcihhLCBiKSB7XG4gIHZhciB0O1xuICBpZiAoYSA+IGIpIHQgPSBhLCBhID0gYiwgYiA9IHQ7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCB4KSk7IH07XG59XG5cbi8vIG5vcm1hbGl6ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuLy8gaW50ZXJwb2xhdGUoYSwgYikodCkgdGFrZXMgYSBwYXJhbWV0ZXIgdCBpbiBbMCwxXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByYW5nZSB2YWx1ZSB4IGluIFthLGJdLlxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGQwID0gZG9tYWluWzBdLCBkMSA9IGRvbWFpblsxXSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXTtcbiAgaWYgKGQxIDwgZDApIGQwID0gbm9ybWFsaXplKGQxLCBkMCksIHIwID0gaW50ZXJwb2xhdGUocjEsIHIwKTtcbiAgZWxzZSBkMCA9IG5vcm1hbGl6ZShkMCwgZDEpLCByMCA9IGludGVycG9sYXRlKHIwLCByMSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiByMChkMCh4KSk7IH07XG59XG5cbmZ1bmN0aW9uIHBvbHltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcbiAgICAgIGQgPSBuZXcgQXJyYXkoaiksXG4gICAgICByID0gbmV3IEFycmF5KGopLFxuICAgICAgaSA9IC0xO1xuXG4gIC8vIFJldmVyc2UgZGVzY2VuZGluZyBkb21haW5zLlxuICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIH1cblxuICB3aGlsZSAoKytpIDwgaikge1xuICAgIGRbaV0gPSBub3JtYWxpemUoZG9tYWluW2ldLCBkb21haW5baSArIDFdKTtcbiAgICByW2ldID0gaW50ZXJwb2xhdGUocmFuZ2VbaV0sIHJhbmdlW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpID0gYmlzZWN0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xuICAgIHJldHVybiByW2ldKGRbaV0oeCkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5yYW5nZShzb3VyY2UucmFuZ2UoKSlcbiAgICAgIC5pbnRlcnBvbGF0ZShzb3VyY2UuaW50ZXJwb2xhdGUoKSlcbiAgICAgIC5jbGFtcChzb3VyY2UuY2xhbXAoKSlcbiAgICAgIC51bmtub3duKHNvdXJjZS51bmtub3duKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgcmFuZ2UgPSB1bml0LFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVZhbHVlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdW50cmFuc2Zvcm0sXG4gICAgICB1bmtub3duLFxuICAgICAgY2xhbXAgPSBpZGVudGl0eSxcbiAgICAgIHBpZWNld2lzZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIGlucHV0O1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICAgIGlmIChjbGFtcCAhPT0gaWRlbnRpdHkpIGNsYW1wID0gY2xhbXBlcihkb21haW5bMF0sIGRvbWFpbltuIC0gMV0pO1xuICAgIHBpZWNld2lzZSA9IG4gPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgIG91dHB1dCA9IGlucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBBcnJheS5mcm9tKF8sIG51bWJlciksIHJlc2NhbGUoKSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHJhbmdlID0gQXJyYXkuZnJvbShfKSwgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVJvdW5kLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSBfID8gdHJ1ZSA6IGlkZW50aXR5LCByZXNjYWxlKCkpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cygpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKCkoaWRlbnRpdHksIGlkZW50aXR5KTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpbml0UmFuZ2UoZG9tYWluLCByYW5nZSkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5yYW5nZShkb21haW4pOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aGlzLnJhbmdlKHJhbmdlKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0SW50ZXJwb2xhdG9yKGRvbWFpbiwgaW50ZXJwb2xhdG9yKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB7XG4gICAgICBpZiAodHlwZW9mIGRvbWFpbiA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmludGVycG9sYXRvcihkb21haW4pO1xuICAgICAgZWxzZSB0aGlzLnJhbmdlKGRvbWFpbik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhpcy5kb21haW4oZG9tYWluKTtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJwb2xhdG9yID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcik7XG4gICAgICBlbHNlIHRoaXMucmFuZ2UoaW50ZXJwb2xhdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCB7dGlja3MsIHRpY2tJbmNyZW1lbnR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5fSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuaW1wb3J0IHRpY2tGb3JtYXQgZnJvbSBcIi4vdGlja0Zvcm1hdC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LCBzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICB2YXIgaTAgPSAwO1xuICAgIHZhciBpMSA9IGQubGVuZ3RoIC0gMTtcbiAgICB2YXIgc3RhcnQgPSBkW2kwXTtcbiAgICB2YXIgc3RvcCA9IGRbaTFdO1xuICAgIHZhciBwcmVzdGVwO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBtYXhJdGVyID0gMTA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG4gICAgXG4gICAgd2hpbGUgKG1heEl0ZXItLSA+IDApIHtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgICBpZiAoc3RlcCA9PT0gcHJlc3RlcCkge1xuICAgICAgICBkW2kwXSA9IHN0YXJ0XG4gICAgICAgIGRbaTFdID0gc3RvcFxuICAgICAgICByZXR1cm4gZG9tYWluKGQpO1xuICAgICAgfSBlbHNlIGlmIChzdGVwID4gMCkge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHByZXN0ZXAgPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cygpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImltcG9ydCB7dGlja3N9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXQsIGZvcm1hdFNwZWNpZmllcn0gZnJvbSBcImQzLWZvcm1hdFwiO1xuaW1wb3J0IG5pY2UgZnJvbSBcIi4vbmljZS5qc1wiO1xuaW1wb3J0IHtjb3B5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nKHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHAoeCkge1xuICByZXR1cm4gTWF0aC5leHAoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxvZ24oeCkge1xuICByZXR1cm4gLU1hdGgubG9nKC14KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXhwbih4KSB7XG4gIHJldHVybiAtTWF0aC5leHAoLXgpO1xufVxuXG5mdW5jdGlvbiBwb3cxMCh4KSB7XG4gIHJldHVybiBpc0Zpbml0ZSh4KSA/ICsoXCIxZVwiICsgeCkgOiB4IDwgMCA/IDAgOiB4O1xufVxuXG5mdW5jdGlvbiBwb3dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IDEwID8gcG93MTBcbiAgICAgIDogYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5leHBcbiAgICAgIDogeCA9PiBNYXRoLnBvdyhiYXNlLCB4KTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgeCA9PiBNYXRoLmxvZyh4KSAvIGJhc2UpO1xufVxuXG5mdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgcmV0dXJuICh4LCBrKSA9PiAtZigteCwgayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dnaXNoKHRyYW5zZm9ybSkge1xuICBjb25zdCBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCk7XG4gIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcbiAgbGV0IGJhc2UgPSAxMDtcbiAgbGV0IGxvZ3M7XG4gIGxldCBwb3dzO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xuICAgIGlmIChkb21haW4oKVswXSA8IDApIHtcbiAgICAgIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2duLCB0cmFuc2Zvcm1FeHBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGNvdW50ID0+IHtcbiAgICBjb25zdCBkID0gZG9tYWluKCk7XG4gICAgbGV0IHUgPSBkWzBdO1xuICAgIGxldCB2ID0gZFtkLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHIgPSB2IDwgdTtcblxuICAgIGlmIChyKSAoW3UsIHZdID0gW3YsIHVdKTtcblxuICAgIGxldCBpID0gbG9ncyh1KTtcbiAgICBsZXQgaiA9IGxvZ3Modik7XG4gICAgbGV0IGs7XG4gICAgbGV0IHQ7XG4gICAgY29uc3QgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudDtcbiAgICBsZXQgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGguZmxvb3IoaSksIGogPSBNYXRoLmNlaWwoaik7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDw9IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxOyBrIDwgYmFzZTsgKytrKSB7XG4gICAgICAgICAgdCA9IGkgPCAwID8gayAvIHBvd3MoLWkpIDogayAqIHBvd3MoaSk7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAoOyBpIDw9IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMTsgayA+PSAxOyAtLWspIHtcbiAgICAgICAgICB0ID0gaSA+IDAgPyBrIC8gcG93cygtaSkgOiBrICogcG93cyhpKTtcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoei5sZW5ndGggKiAyIDwgbikgeiA9IHRpY2tzKHUsIHYsIG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gdGlja3MoaSwgaiwgTWF0aC5taW4oaiAtIGksIG4pKS5tYXAocG93cyk7XG4gICAgfVxuICAgIHJldHVybiByID8gei5yZXZlcnNlKCkgOiB6O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSAoY291bnQsIHNwZWNpZmllcikgPT4ge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcInNcIiA6IFwiLFwiO1xuICAgIGlmICh0eXBlb2Ygc3BlY2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICghKGJhc2UgJSAxKSAmJiAoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikpLnByZWNpc2lvbiA9PSBudWxsKSBzcGVjaWZpZXIudHJpbSA9IHRydWU7XG4gICAgICBzcGVjaWZpZXIgPSBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICB9XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBjb25zdCBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIGNvdW50IC8gc2NhbGUudGlja3MoKS5sZW5ndGgpOyAvLyBUT0RPIGZhc3QgZXN0aW1hdGU/XG4gICAgcmV0dXJuIGQgPT4ge1xuICAgICAgbGV0IGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgIH07XG4gIH07XG5cbiAgc2NhbGUubmljZSA9ICgpID0+IHtcbiAgICByZXR1cm4gZG9tYWluKG5pY2UoZG9tYWluKCksIHtcbiAgICAgIGZsb29yOiB4ID0+IHBvd3MoTWF0aC5mbG9vcihsb2dzKHgpKSksXG4gICAgICBjZWlsOiB4ID0+IHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZygpIHtcbiAgY29uc3Qgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcbiAgc2NhbGUuY29weSA9ICgpID0+IGNvcHkoc2NhbGUsIGxvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbmljZShkb21haW4sIGludGVydmFsKSB7XG4gIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuXG4gIHZhciBpMCA9IDAsXG4gICAgICBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLFxuICAgICAgeDAgPSBkb21haW5baTBdLFxuICAgICAgeDEgPSBkb21haW5baTFdLFxuICAgICAgdDtcblxuICBpZiAoeDEgPCB4MCkge1xuICAgIHQgPSBpMCwgaTAgPSBpMSwgaTEgPSB0O1xuICAgIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICB9XG5cbiAgZG9tYWluW2kwXSA9IGludGVydmFsLmZsb29yKHgwKTtcbiAgZG9tYWluW2kxXSA9IGludGVydmFsLmNlaWwoeDEpO1xuICByZXR1cm4gZG9tYWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuIiwiaW1wb3J0IHtJbnRlcm5NYXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGNvbnN0IGltcGxpY2l0ID0gU3ltYm9sKFwiaW1wbGljaXRcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGluYWwoKSB7XG4gIHZhciBpbmRleCA9IG5ldyBJbnRlcm5NYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgbGV0IGkgPSBpbmRleC5nZXQoZCk7XG4gICAgaWYgKGkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChkLCBpID0gZG9tYWluLnB1c2goZCkgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlW2kgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG5ldyBJbnRlcm5NYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIF8pIHtcbiAgICAgIGlmIChpbmRleC5oYXModmFsdWUpKSBjb250aW51ZTtcbiAgICAgIGluZGV4LnNldCh2YWx1ZSwgZG9tYWluLnB1c2godmFsdWUpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9yZGluYWwoZG9tYWluLCByYW5nZSkudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtjb3B5LCBpZGVudGl0eSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93aXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGV4cG9uZW50ID0gMTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHJldHVybiBleHBvbmVudCA9PT0gMSA/IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpXG4gICAgICAgIDogZXhwb25lbnQgPT09IDAuNSA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TcXJ0LCB0cmFuc2Zvcm1TcXVhcmUpXG4gICAgICAgIDogdHJhbnNmb3JtKHRyYW5zZm9ybVBvdyhleHBvbmVudCksIHRyYW5zZm9ybVBvdygxIC8gZXhwb25lbnQpKTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIHJlc2NhbGUoKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGVTb3J0ZWQgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdGhyZXNob2xkcyA9IFtdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gdGhyZXNob2xkKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAobGV0IGQgb2YgXykgaWYgKGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgZG9tYWluLnNvcnQoYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkcy5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpbGUoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHggPD0geCA/IHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXSA6IHVua25vd247XG4gIH1cblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgZG9tYWluID0gbmV3IEFycmF5KG4pO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkb21haW5baV0gPSAoKGkgKyAxKSAqIHgxIC0gKGkgLSBuKSAqIHgwKSAvIChuICsgMSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFt4MCwgeDFdID0gXywgeDAgPSAreDAsIHgxID0gK3gxLCByZXNjYWxlKCkpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IChyYW5nZSA9IEFycmF5LmZyb20oXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnRocmVzaG9sZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGl6ZSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShsaW5lYXJpc2goc2NhbGUpLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICB2YXIgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd24sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IEFycmF5LmZyb20oXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0LCBmb3JtYXRQcmVmaXgsIGZvcm1hdFNwZWNpZmllciwgcHJlY2lzaW9uRml4ZWQsIHByZWNpc2lvblByZWZpeCwgcHJlY2lzaW9uUm91bmR9IGZyb20gXCJkMy1mb3JtYXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGlja0Zvcm1hdChzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICB2YXIgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCksXG4gICAgICBwcmVjaXNpb247XG4gIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XG4gIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICBjYXNlIFwic1wiOiB7XG4gICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgcmV0dXJuIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgY2FzZSBcIlwiOlxuICAgIGNhc2UgXCJlXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJyXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZlwiOlxuICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvbkZpeGVkKHN0ZXApKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCIlXCIpICogMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHNwZWNpZmllcik7XG59XG4iLCIvLyBHaXZlbiBzb21ldGhpbmcgYXJyYXkgbGlrZSAob3IgbnVsbCksIHJldHVybnMgc29tZXRoaW5nIHRoYXQgaXMgc3RyaWN0bHkgYW5cbi8vIGFycmF5LiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYXJyYXktbGlrZSBvYmplY3RzIHBhc3NlZCB0byBkMy5zZWxlY3RBbGxcbi8vIG9yIHNlbGVjdGlvbi5zZWxlY3RBbGwgYXJlIGNvbnZlcnRlZCBpbnRvIHByb3BlciBhcnJheXMgd2hlbiBjcmVhdGluZyBhXG4vLyBzZWxlY3Rpb247IHdlIGRvbuKAmXQgZXZlciB3YW50IHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBiYWNrZWQgYnkgYSBsaXZlXG4vLyBIVE1MQ29sbGVjdGlvbiBvciBOb2RlTGlzdC4gSG93ZXZlciwgbm90ZSB0aGF0IHNlbGVjdGlvbi5zZWxlY3RBbGwgd2lsbCB1c2UgYVxuLy8gc3RhdGljIE5vZGVMaXN0IGFzIGEgZ3JvdXAsIHNpbmNlIGl0IHNhZmVseSBkZXJpdmVkIGZyb20gcXVlcnlTZWxlY3RvckFsbC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFycmF5KHgpIHtcbiAgcmV0dXJuIHggPT0gbnVsbCA/IFtdIDogQXJyYXkuaXNBcnJheSh4KSA/IHggOiBBcnJheS5mcm9tKHgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi9jcmVhdG9yLmpzXCI7XG5pbXBvcnQgc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3QoY3JlYXRvcihuYW1lKS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2UuanNcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkTWF0Y2hlcihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG4iLCJpbXBvcnQgbmFtZXNwYWNlcyBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG59XG4iLCJleHBvcnQgdmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQsIG5vZGUpIHtcbiAgZXZlbnQgPSBzb3VyY2VFdmVudChldmVudCk7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAobm9kZSkge1xuICAgIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtldmVudC5wYWdlWCwgZXZlbnQucGFnZVldO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbYXJyYXkoc2VsZWN0b3IpXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi4vbmFtZXNwYWNlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cbiIsImZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUodHJ1ZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7RW50ZXJOb2RlfSBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IG5ldyBNYXAsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApICsgXCJcIjtcbiAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUpKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKSArIFwiXCI7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUpKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZS5kZWxldGUoa2V5VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdHVtKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX19kYXRhX187XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLCBkYXR1bSk7XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gYXJyYXlsaWtlKHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG4vLyBHaXZlbiBzb21lIGRhdGEsIHRoaXMgcmV0dXJucyBhbiBhcnJheS1saWtlIHZpZXcgb2YgaXQ6IGFuIG9iamVjdCB0aGF0XG4vLyBleHBvc2VzIGEgbGVuZ3RoIHByb3BlcnR5IGFuZCBhbGxvd3MgbnVtZXJpYyBpbmRleGluZy4gTm90ZSB0aGF0IHVubGlrZVxuLy8gc2VsZWN0QWxsLCB0aGlzIGlzbuKAmXQgd29ycmllZCBhYm91dCDigJxsaXZl4oCdIGNvbGxlY3Rpb25zIGJlY2F1c2UgdGhlIHJlc3VsdGluZ1xuLy8gYXJyYXkgd2lsbCBvbmx5IGJlIHVzZWQgYnJpZWZseSB3aGlsZSBkYXRhIGlzIGJlaW5nIGJvdW5kLiAoSXQgaXMgcG9zc2libGUgdG9cbi8vIGNhdXNlIHRoZSBkYXRhIHRvIGNoYW5nZSB3aGlsZSBpdGVyYXRpbmcgYnkgdXNpbmcgYSBrZXkgZnVuY3Rpb24sIGJ1dCBwbGVhc2Vcbi8vIGRvbuKAmXQ7IHdl4oCZZCByYXRoZXIgYXZvaWQgYSBncmF0dWl0b3VzIGNvcHkuKVxuZnVuY3Rpb24gYXJyYXlsaWtlKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4gZGF0YVxuICAgID8gZGF0YSAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oZGF0YSk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQgZnJvbSBcIi4vc2VsZWN0Q2hpbGQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4gZnJvbSBcIi4vc2VsZWN0Q2hpbGRyZW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pdGVyYXRvciBmcm9tIFwiLi9pdGVyYXRvci5qc1wiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBqb2luOiBzZWxlY3Rpb25fam9pbixcbiAgbWVyZ2U6IHNlbGVjdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiBzZWxlY3Rpb25fc2VsZWN0aW9uLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX2l0ZXJhdG9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qKCkge1xuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9uZW50ZXIsIG9udXBkYXRlLCBvbmV4aXQpIHtcbiAgdmFyIGVudGVyID0gdGhpcy5lbnRlcigpLCB1cGRhdGUgPSB0aGlzLCBleGl0ID0gdGhpcy5leGl0KCk7XG4gIGlmICh0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZW50ZXIgPSBvbmVudGVyKGVudGVyKTtcbiAgICBpZiAoZW50ZXIpIGVudGVyID0gZW50ZXIuc2VsZWN0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgZW50ZXIgPSBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICB9XG4gIGlmIChvbnVwZGF0ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgICBpZiAodXBkYXRlKSB1cGRhdGUgPSB1cGRhdGUuc2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dDtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gc2VsZWN0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbiIsImZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCB0aGlzLl9fZGF0YV9fKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcih2YWx1ZSk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5vcHRpb25zID0gb3B0aW9ucyk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIG9wdGlvbnM6IG9wdGlvbnN9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5leHQpIF4gNCkgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn1cbiIsImZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IGFycmF5IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yQWxsIGZyb20gXCIuLi9zZWxlY3RvckFsbC5qc1wiO1xuXG5mdW5jdGlvbiBhcnJheUFsbChzZWxlY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcnJheShzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBhcnJheUFsbChzZWxlY3QpO1xuICBlbHNlIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbmQgPSBBcnJheS5wcm90b3R5cGUuZmluZDtcblxuZnVuY3Rpb24gY2hpbGRGaW5kKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmluZC5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRGaXJzdCgpIHtcbiAgcmV0dXJuIHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChtYXRjaCA9PSBudWxsID8gY2hpbGRGaXJzdFxuICAgICAgOiBjaGlsZEZpbmQodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcblxuZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjaGlsZHJlbkZpbHRlcihtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKG1hdGNoID09IG51bGwgPyBjaGlsZHJlblxuICAgICAgOiBjaGlsZHJlbkZpbHRlcih0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpICsrc2l6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGxldCBzb3VyY2VFdmVudDtcbiAgd2hpbGUgKHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQpIGV2ZW50ID0gc291cmNlRXZlbnQ7XG4gIHJldHVybiBldmVudDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YWJzLCBhY29zLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIG1heCwgbWluLCBwaSwgc2luLCBzcXJ0LCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcbmltcG9ydCB7d2l0aFBhdGh9IGZyb20gXCIuL3BhdGguanNcIjtcblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9IHkzMiAqIHgxMCAtIHgzMiAqIHkxMDtcbiAgaWYgKHQgKiB0IDwgZXBzaWxvbikgcmV0dXJuO1xuICB0ID0gKHgzMiAqICh5MCAtIHkyKSAtIHkzMiAqICh4MCAtIHgyKSkgLyB0O1xuICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbn1cblxuLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY29ybmVyVGFuZ2VudHMoeDAsIHkwLCB4MSwgeTEsIHIxLCByYywgY3cpIHtcbiAgdmFyIHgwMSA9IHgwIC0geDEsXG4gICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBzcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksXG4gICAgICBveCA9IGxvICogeTAxLFxuICAgICAgb3kgPSAtbG8gKiB4MDEsXG4gICAgICB4MTEgPSB4MCArIG94LFxuICAgICAgeTExID0geTAgKyBveSxcbiAgICAgIHgxMCA9IHgxICsgb3gsXG4gICAgICB5MTAgPSB5MSArIG95LFxuICAgICAgeDAwID0gKHgxMSArIHgxMCkgLyAyLFxuICAgICAgeTAwID0gKHkxMSArIHkxMCkgLyAyLFxuICAgICAgZHggPSB4MTAgLSB4MTEsXG4gICAgICBkeSA9IHkxMCAtIHkxMSxcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICByID0gcjEgLSByYyxcbiAgICAgIEQgPSB4MTEgKiB5MTAgLSB4MTAgKiB5MTEsXG4gICAgICBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBzcXJ0KG1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSxcbiAgICAgIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMixcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMixcbiAgICAgIGR4MCA9IGN4MCAtIHgwMCxcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcbiAgICAgIGR4MSA9IGN4MSAtIHgwMCxcbiAgICAgIGR5MSA9IGN5MSAtIHkwMDtcblxuICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBhcmNPdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvbnN0YW50KDApLFxuICAgICAgcGFkUmFkaXVzID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBhcmNTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBhcmNFbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChhcmMpO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IGFicyhhMSAtIGEwKSxcbiAgICAgICAgY3cgPSBhMSA+IGEwO1xuXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIG91dGVyIHJhZGl1cyBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIHJhZGl1cy5cbiAgICBpZiAocjEgPCByMCkgciA9IHIxLCByMSA9IHIwLCByMCA9IHI7XG5cbiAgICAvLyBJcyBpdCBhIHBvaW50P1xuICAgIGlmICghKHIxID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKDAsIDApO1xuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjbGUgb3IgYW5udWx1cz9cbiAgICBlbHNlIGlmIChkYSA+IHRhdSAtIGVwc2lsb24pIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHIxICogY29zKGEwKSwgcjEgKiBzaW4oYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogY29zKGExKSwgcjAgKiBzaW4oYTEpKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExLCBhMCwgY3cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY3VsYXIgb3IgYW5udWxhciBzZWN0b3I/XG4gICAgZWxzZSB7XG4gICAgICB2YXIgYTAxID0gYTAsXG4gICAgICAgICAgYTExID0gYTEsXG4gICAgICAgICAgYTAwID0gYTAsXG4gICAgICAgICAgYTEwID0gYTEsXG4gICAgICAgICAgZGEwID0gZGEsXG4gICAgICAgICAgZGExID0gZGEsXG4gICAgICAgICAgYXAgPSBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC8gMixcbiAgICAgICAgICBycCA9IChhcCA+IGVwc2lsb24pICYmIChwYWRSYWRpdXMgPyArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBtaW4oYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgICByYzAgPSByYyxcbiAgICAgICAgICByYzEgPSByYyxcbiAgICAgICAgICB0MCxcbiAgICAgICAgICB0MTtcblxuICAgICAgLy8gQXBwbHkgcGFkZGluZz8gTm90ZSB0aGF0IHNpbmNlIHIxIOKJpSByMCwgZGExIOKJpSBkYTAuXG4gICAgICBpZiAocnAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciBwMCA9IGFzaW4ocnAgLyByMCAqIHNpbihhcCkpLFxuICAgICAgICAgICAgcDEgPSBhc2luKHJwIC8gcjEgKiBzaW4oYXApKTtcbiAgICAgICAgaWYgKChkYTAgLT0gcDAgKiAyKSA+IGVwc2lsb24pIHAwICo9IChjdyA/IDEgOiAtMSksIGEwMCArPSBwMCwgYTEwIC09IHAwO1xuICAgICAgICBlbHNlIGRhMCA9IDAsIGEwMCA9IGExMCA9IChhMCArIGExKSAvIDI7XG4gICAgICAgIGlmICgoZGExIC09IHAxICogMikgPiBlcHNpbG9uKSBwMSAqPSAoY3cgPyAxIDogLTEpLCBhMDEgKz0gcDEsIGExMSAtPSBwMTtcbiAgICAgICAgZWxzZSBkYTEgPSAwLCBhMDEgPSBhMTEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDAxID0gcjEgKiBjb3MoYTAxKSxcbiAgICAgICAgICB5MDEgPSByMSAqIHNpbihhMDEpLFxuICAgICAgICAgIHgxMCA9IHIwICogY29zKGExMCksXG4gICAgICAgICAgeTEwID0gcjAgKiBzaW4oYTEwKTtcblxuICAgICAgLy8gQXBwbHkgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgaWYgKHJjID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgeDExID0gcjEgKiBjb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogc2luKGExMSksXG4gICAgICAgICAgICB4MDAgPSByMCAqIGNvcyhhMDApLFxuICAgICAgICAgICAgeTAwID0gcjAgKiBzaW4oYTAwKSxcbiAgICAgICAgICAgIG9jO1xuXG4gICAgICAgIC8vIFJlc3RyaWN0IHRoZSBjb3JuZXIgcmFkaXVzIGFjY29yZGluZyB0byB0aGUgc2VjdG9yIGFuZ2xlLiBJZiB0aGlzXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBmYWlscywgaXTigJlzIHByb2JhYmx5IGJlY2F1c2UgdGhlIGFyYyBpcyB0b28gc21hbGwsIHNvXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGNvcm5lciByYWRpdXMgZW50aXJlbHkuXG4gICAgICAgIGlmIChkYSA8IHBpKSB7XG4gICAgICAgICAgaWYgKG9jID0gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSkge1xuICAgICAgICAgICAgdmFyIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgICAgYXkgPSB5MDEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgICBieCA9IHgxMSAtIG9jWzBdLFxuICAgICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgICAga2MgPSAxIC8gc2luKGFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChzcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIHNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgICBsYyA9IHNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgICAgcmMwID0gbWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgICByYzEgPSBtaW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmMwID0gcmMxID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSXMgdGhlIHNlY3RvciBjb2xsYXBzZWQgdG8gYSBsaW5lP1xuICAgICAgaWYgKCEoZGExID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzEgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgaW5uZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEwLCBhMDAsIGN3KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsXG4gICAgICAgIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBwaSAvIDI7XG4gICAgcmV0dXJuIFtjb3MoYSkgKiByLCBzaW4oYSkgKiByXTtcbiAgfTtcblxuICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW5uZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGlubmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvdXRlclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogb3V0ZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZFJhZGl1cyA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZFJhZGl1cztcbiAgfTtcblxuICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRBbmdsZTtcbiAgfTtcblxuICBhcmMuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgYXJjKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyYztcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyLmpzXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeDAsIHkwLCB5MSkge1xuICB2YXIgeDEgPSBudWxsLFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChhcmVhKTtcblxuICB4MCA9IHR5cGVvZiB4MCA9PT0gXCJmdW5jdGlvblwiID8geDAgOiAoeDAgPT09IHVuZGVmaW5lZCkgPyBwb2ludFggOiBjb25zdGFudCgreDApO1xuICB5MCA9IHR5cGVvZiB5MCA9PT0gXCJmdW5jdGlvblwiID8geTAgOiAoeTAgPT09IHVuZGVmaW5lZCkgPyBjb25zdGFudCgwKSA6IGNvbnN0YW50KCt5MCk7XG4gIHkxID0gdHlwZW9mIHkxID09PSBcImZ1bmN0aW9uXCIgPyB5MSA6ICh5MSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WSA6IGNvbnN0YW50KCt5MSk7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSAoZGF0YSA9IGFycmF5KGRhdGEpKS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgeDB6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7XG4gICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFTdGFydCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGsgPSBpIC0gMTsgayA+PSBqOyAtLWspIHtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MHpba10sIHkweltrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSB7XG4gICAgICAgIHgweltpXSA9ICt4MChkLCBpLCBkYXRhKSwgeTB6W2ldID0gK3kwKGQsIGksIGRhdGEpO1xuICAgICAgICBvdXRwdXQucG9pbnQoeDEgPyAreDEoZCwgaSwgZGF0YSkgOiB4MHpbaV0sIHkxID8gK3kxKGQsIGksIGRhdGEpIDogeTB6W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlYWxpbmUoKSB7XG4gICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHgxID0gbnVsbCwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MTtcbiAgfTtcblxuICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeTEgPSBudWxsLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkxO1xuICB9O1xuXG4gIGFyZWEubGluZVgwID1cbiAgYXJlYS5saW5lWTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmxpbmVZMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xuICB9O1xuXG4gIGFyZWEubGluZVgxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MSkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGFyZWEpIDogZGVmaW5lZDtcbiAgfTtcblxuICBhcmVhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XG4gIH07XG5cbiAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBhcmVhKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyZWE7XG59XG4iLCJleHBvcnQgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIHhcbiAgICA/IHggLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKHgpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgcG9pbnRSYWRpYWwgZnJvbSBcIi4uL3BvaW50UmFkaWFsLmpzXCI7XG5cbmNsYXNzIEJ1bXAge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCB4KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5feCA9IHg7XG4gIH1cbiAgYXJlYVN0YXJ0KCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9XG4gIGFyZWFFbmQoKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfVxuICBsaW5lU3RhcnQoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9XG4gIGxpbmVFbmQoKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfVxuICBwb2ludCh4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmUpIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICBlbHNlIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl94KSB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8odGhpcy5feDAgPSAodGhpcy5feDAgKyB4KSAvIDIsIHRoaXMuX3kwLCB0aGlzLl94MCwgeSwgeCwgeSk7XG4gICAgICAgIGVsc2UgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHRoaXMuX3gwLCB0aGlzLl95MCA9ICh0aGlzLl95MCArIHkpIC8gMiwgeCwgdGhpcy5feTAsIHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feDAgPSB4LCB0aGlzLl95MCA9IHk7XG4gIH1cbn1cblxuY2xhc3MgQnVtcFJhZGlhbCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICBsaW5lU3RhcnQoKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9XG4gIGxpbmVFbmQoKSB7fVxuICBwb2ludCh4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHRoaXMuX3BvaW50ID09PSAwKSB7XG4gICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHAwID0gcG9pbnRSYWRpYWwodGhpcy5feDAsIHRoaXMuX3kwKTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRSYWRpYWwodGhpcy5feDAsIHRoaXMuX3kwID0gKHRoaXMuX3kwICsgeSkgLyAyKTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRSYWRpYWwoeCwgdGhpcy5feTApO1xuICAgICAgY29uc3QgcDMgPSBwb2ludFJhZGlhbCh4LCB5KTtcbiAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKC4uLnAwKTtcbiAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyguLi5wMSwgLi4ucDIsIC4uLnAzKTtcbiAgICB9XG4gICAgdGhpcy5feDAgPSB4LCB0aGlzLl95MCA9IHk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1bXBYKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCdW1wKGNvbnRleHQsIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVtcFkoY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJ1bXAoY29udGV4dCwgZmFsc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVtcFJhZGlhbChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQnVtcFJhZGlhbChjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgcmV0dXJuIGQ7XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhci5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgobGluZSk7XG5cbiAgeCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogKHggPT09IHVuZGVmaW5lZCkgPyBwb2ludFggOiBjb25zdGFudCh4KTtcbiAgeSA9IHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5IDogKHkgPT09IHVuZGVmaW5lZCkgPyBwb2ludFkgOiBjb25zdGFudCh5KTtcblxuICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IChkYXRhID0gYXJyYXkoZGF0YSkpLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIG91dHB1dC5wb2ludCgreChkLCBpLCBkYXRhKSwgK3koZCwgaSwgZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHg7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5O1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuIiwiaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHtidW1wWCwgYnVtcFksIGJ1bXBSYWRpYWx9IGZyb20gXCIuL2N1cnZlL2J1bXAuanNcIjtcbmltcG9ydCB7d2l0aFBhdGh9IGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5rU291cmNlKGQpIHtcbiAgcmV0dXJuIGQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBsaW5rVGFyZ2V0KGQpIHtcbiAgcmV0dXJuIGQudGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluayhjdXJ2ZSkge1xuICBsZXQgc291cmNlID0gbGlua1NvdXJjZSxcbiAgICAgIHRhcmdldCA9IGxpbmtUYXJnZXQsXG4gICAgICB4ID0gcG9pbnRYLFxuICAgICAgeSA9IHBvaW50WSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgb3V0cHV0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChsaW5rKTtcblxuICBmdW5jdGlvbiBsaW5rKCkge1xuICAgIGxldCBidWZmZXI7XG4gICAgY29uc3QgYXJndiA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBzID0gc291cmNlLmFwcGx5KHRoaXMsIGFyZ3YpO1xuICAgIGNvbnN0IHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJndik7XG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcbiAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgYXJndlswXSA9IHMsIG91dHB1dC5wb2ludCgreC5hcHBseSh0aGlzLCBhcmd2KSwgK3kuYXBwbHkodGhpcywgYXJndikpO1xuICAgIGFyZ3ZbMF0gPSB0LCBvdXRwdXQucG9pbnQoK3guYXBwbHkodGhpcywgYXJndiksICt5LmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5rLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3VyY2UgPSBfLCBsaW5rKSA6IHNvdXJjZTtcbiAgfTtcblxuICBsaW5rLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXJnZXQgPSBfLCBsaW5rKSA6IHRhcmdldDtcbiAgfTtcblxuICBsaW5rLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHg7XG4gIH07XG5cbiAgbGluay55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluaykgOiB5O1xuICB9O1xuXG4gIGxpbmsuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluaykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5rO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlua0hvcml6b250YWwoKSB7XG4gIHJldHVybiBsaW5rKGJ1bXBYKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmtWZXJ0aWNhbCgpIHtcbiAgcmV0dXJuIGxpbmsoYnVtcFkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlua1JhZGlhbCgpIHtcbiAgY29uc3QgbCA9IGxpbmsoYnVtcFJhZGlhbCk7XG4gIGwuYW5nbGUgPSBsLngsIGRlbGV0ZSBsLng7XG4gIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xuICByZXR1cm4gbDtcbn1cbiIsImV4cG9ydCBjb25zdCBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCBjb25zdCBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgY29uc3QgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgY29uc3QgbWluID0gTWF0aC5taW47XG5leHBvcnQgY29uc3Qgc2luID0gTWF0aC5zaW47XG5leHBvcnQgY29uc3Qgc3FydCA9IE1hdGguc3FydDtcblxuZXhwb3J0IGNvbnN0IGVwc2lsb24gPSAxZS0xMjtcbmV4cG9ydCBjb25zdCBwaSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IGNvbnN0IHRhdSA9IDIgKiBwaTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPj0gMSA/IGhhbGZQaSA6IHggPD0gLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuIiwiaW1wb3J0IHtQYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gd2l0aFBhdGgoc2hhcGUpIHtcbiAgbGV0IGRpZ2l0cyA9IDM7XG5cbiAgc2hhcGUuZGlnaXRzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpZ2l0cztcbiAgICBpZiAoXyA9PSBudWxsKSB7XG4gICAgICBkaWdpdHMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkID0gTWF0aC5mbG9vcihfKTtcbiAgICAgIGlmICghKGQgPj0gMCkpIHRocm93IG5ldyBSYW5nZUVycm9yKGBpbnZhbGlkIGRpZ2l0czogJHtffWApO1xuICAgICAgZGlnaXRzID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHJldHVybiAoKSA9PiBuZXcgUGF0aChkaWdpdHMpO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmcuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHt0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsXG4gICAgICBzb3J0ID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSxcbiAgICAgIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSxcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQoMCk7XG5cbiAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IChkYXRhID0gYXJyYXkoZGF0YSkpLmxlbmd0aCxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGFyY3MgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUsIE1hdGgubWF4KC10YXUsIGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBhMCkpLFxuICAgICAgICBhMSxcbiAgICAgICAgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sIHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgdjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodiA9IGFyY3NbaW5kZXhbaV0gPSBpXSA9ICt2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKSkgPiAwKSB7XG4gICAgICAgIHN1bSArPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGlvbmFsbHkgc29ydCB0aGUgYXJjcyBieSBwcmV2aW91c2x5LWNvbXB1dGVkIHZhbHVlcyBvciBieSBkYXRhLlxuICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7XG4gICAgZWxzZSBpZiAoc29ydCAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7IH0pO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXG4gICAgZm9yIChpID0gMCwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwOyBpIDwgbjsgKytpLCBhMCA9IGExKSB7XG4gICAgICBqID0gaW5kZXhbaV0sIHYgPSBhcmNzW2pdLCBhMSA9IGEwICsgKHYgPiAwID8gdiAqIGsgOiAwKSArIHBhLCBhcmNzW2pdID0ge1xuICAgICAgICBkYXRhOiBkYXRhW2pdLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBhcmNzO1xuICB9XG5cbiAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiB2YWx1ZTtcbiAgfTtcblxuICBwaWUuc29ydFZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0VmFsdWVzID0gXywgc29ydCA9IG51bGwsIHBpZSkgOiBzb3J0VmFsdWVzO1xuICB9O1xuXG4gIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XG4gIH07XG5cbiAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgcmV0dXJuIHBpZTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiBbKHkgPSAreSkgKiBNYXRoLmNvcyh4IC09IE1hdGguUEkgLyAyKSwgeSAqIE1hdGguc2luKHgpXTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IGFzdGVyaXNrIGZyb20gXCIuL3N5bWJvbC9hc3Rlcmlzay5qc1wiO1xuaW1wb3J0IGNpcmNsZSBmcm9tIFwiLi9zeW1ib2wvY2lyY2xlLmpzXCI7XG5pbXBvcnQgY3Jvc3MgZnJvbSBcIi4vc3ltYm9sL2Nyb3NzLmpzXCI7XG5pbXBvcnQgZGlhbW9uZCBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZC5qc1wiO1xuaW1wb3J0IGRpYW1vbmQyIGZyb20gXCIuL3N5bWJvbC9kaWFtb25kMi5qc1wiO1xuaW1wb3J0IHBsdXMgZnJvbSBcIi4vc3ltYm9sL3BsdXMuanNcIjtcbmltcG9ydCBzcXVhcmUgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZS5qc1wiO1xuaW1wb3J0IHNxdWFyZTIgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZTIuanNcIjtcbmltcG9ydCBzdGFyIGZyb20gXCIuL3N5bWJvbC9zdGFyLmpzXCI7XG5pbXBvcnQgdHJpYW5nbGUgZnJvbSBcIi4vc3ltYm9sL3RyaWFuZ2xlLmpzXCI7XG5pbXBvcnQgdHJpYW5nbGUyIGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZTIuanNcIjtcbmltcG9ydCB3eWUgZnJvbSBcIi4vc3ltYm9sL3d5ZS5qc1wiO1xuaW1wb3J0IHRpbWVzIGZyb20gXCIuL3N5bWJvbC90aW1lcy5qc1wiO1xuXG4vLyBUaGVzZSBzeW1ib2xzIGFyZSBkZXNpZ25lZCB0byBiZSBmaWxsZWQuXG5leHBvcnQgY29uc3Qgc3ltYm9sc0ZpbGwgPSBbXG4gIGNpcmNsZSxcbiAgY3Jvc3MsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxuLy8gVGhlc2Ugc3ltYm9scyBhcmUgZGVzaWduZWQgdG8gYmUgc3Ryb2tlZCAod2l0aCBhIHdpZHRoIG9mIDEuNXB4IGFuZCByb3VuZCBjYXBzKS5cbmV4cG9ydCBjb25zdCBzeW1ib2xzU3Ryb2tlID0gW1xuICBjaXJjbGUsXG4gIHBsdXMsXG4gIHRpbWVzLFxuICB0cmlhbmdsZTIsXG4gIGFzdGVyaXNrLFxuICBzcXVhcmUyLFxuICBkaWFtb25kMlxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3ltYm9sKHR5cGUsIHNpemUpIHtcbiAgbGV0IGNvbnRleHQgPSBudWxsLFxuICAgICAgcGF0aCA9IHdpdGhQYXRoKHN5bWJvbCk7XG5cbiAgdHlwZSA9IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgPyB0eXBlIDogY29uc3RhbnQodHlwZSB8fCBjaXJjbGUpO1xuICBzaXplID0gdHlwZW9mIHNpemUgPT09IFwiZnVuY3Rpb25cIiA/IHNpemUgOiBjb25zdGFudChzaXplID09PSB1bmRlZmluZWQgPyA2NCA6ICtzaXplKTtcblxuICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgbGV0IGJ1ZmZlcjtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG4gICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gIH07XG5cbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgfTtcblxuICBzeW1ib2wuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHN5bWJvbCkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBzeW1ib2w7XG59XG4iLCJpbXBvcnQge21pbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuY29uc3Qgc3FydDMgPSBzcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgKyBtaW4oc2l6ZSAvIDI4LCAwLjc1KSkgKiAwLjU5NDM2O1xuICAgIGNvbnN0IHQgPSByIC8gMjtcbiAgICBjb25zdCB1ID0gdCAqIHNxcnQzO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0Lm1vdmVUbygtdSwgLXQpO1xuICAgIGNvbnRleHQubGluZVRvKHUsIHQpO1xuICAgIGNvbnRleHQubW92ZVRvKC11LCB0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh1LCAtdCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3BpLCBzcXJ0LCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAvIHBpKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgY29udGV4dC5tb3ZlVG8oLTMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgY29udGV4dC5saW5lVG8oLTMgKiByLCByKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCB0YW4zMCA9IHNxcnQoMSAvIDMpO1xuY29uc3QgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCB5ID0gc3FydChzaXplIC8gdGFuMzBfMik7XG4gICAgY29uc3QgeCA9IHkgKiB0YW4zMDtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXgsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSkgKiAwLjYyNjI1O1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7bWluLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLSBtaW4oc2l6ZSAvIDcsIDIpKSAqIDAuODc1NTk7XG4gICAgY29udGV4dC5tb3ZlVG8oLXIsIDApO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDApO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKDAsIC1yKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCB3ID0gc3FydChzaXplKTtcbiAgICBjb25zdCB4ID0gLXcgLyAyO1xuICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplKSAqIDAuNDQzMTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c2luLCBjb3MsIHNxcnQsIHBpLCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmNvbnN0IGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMDtcbmNvbnN0IGtyID0gc2luKHBpIC8gMTApIC8gc2luKDcgKiBwaSAvIDEwKTtcbmNvbnN0IGt4ID0gc2luKHRhdSAvIDEwKSAqIGtyO1xuY29uc3Qga3kgPSAtY29zKHRhdSAvIDEwKSAqIGtyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgKiBrYSk7XG4gICAgY29uc3QgeCA9IGt4ICogcjtcbiAgICBjb25zdCB5ID0ga3kgKiByO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDU7ICsraSkge1xuICAgICAgY29uc3QgYSA9IHRhdSAqIGkgLyA1O1xuICAgICAgY29uc3QgYyA9IGNvcyhhKTtcbiAgICAgIGNvbnN0IHMgPSBzaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHttaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAtIG1pbihzaXplIC8gNiwgMS43KSkgKiAwLjYxODk7XG4gICAgY29udGV4dC5tb3ZlVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICBjb250ZXh0Lm1vdmVUbygtciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBzcXJ0MyA9IHNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgeSA9IC1zcXJ0KHNpemUgLyAoc3FydDMgKiAzKSk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBzcXJ0MyA9IHNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgcyA9IHNxcnQoc2l6ZSkgKiAwLjY4MjQ7XG4gICAgY29uc3QgdCA9IHMgIC8gMjtcbiAgICBjb25zdCB1ID0gKHMgKiBzcXJ0MykgLyAyOyAvLyBjb3MoTWF0aC5QSSAvIDYpXG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXMpO1xuICAgIGNvbnRleHQubGluZVRvKHUsIHQpO1xuICAgIGNvbnRleHQubGluZVRvKC11LCB0KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBjID0gLTAuNTtcbmNvbnN0IHMgPSBzcXJ0KDMpIC8gMjtcbmNvbnN0IGsgPSAxIC8gc3FydCgxMik7XG5jb25zdCBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUgLyBhKTtcbiAgICBjb25zdCB4MCA9IHIgLyAyLCB5MCA9IHIgKiBrO1xuICAgIGNvbnN0IHgxID0geDAsIHkxID0gciAqIGsgKyByO1xuICAgIGNvbnN0IHgyID0gLXgxLCB5MiA9IHkxO1xuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMgKiB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgKyBzICogeTEsIGMgKiB5MSAtIHMgKiB4MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBldmVudCwgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IGFyYywgY3VydmVDYXRtdWxsUm9tLCBjdXJ2ZUxpbmVhciwgbGluZSB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IGRpc3BhdGNoIH0gZnJvbSAnZDMtZGlzcGF0Y2gnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG52YXIgQW5ub3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5ub3RhdGlvbihfcmVmKSB7XG4gICAgdmFyIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgICAgeCA9IF9yZWYkeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeCxcbiAgICAgICAgX3JlZiR5ID0gX3JlZi55LFxuICAgICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgICBueCA9IF9yZWYubngsXG4gICAgICAgIG55ID0gX3JlZi5ueSxcbiAgICAgICAgX3JlZiRkeSA9IF9yZWYuZHksXG4gICAgICAgIGR5ID0gX3JlZiRkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkZHksXG4gICAgICAgIF9yZWYkZHggPSBfcmVmLmR4LFxuICAgICAgICBkeCA9IF9yZWYkZHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGR4LFxuICAgICAgICBfcmVmJGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgICAgY29sb3IgPSBfcmVmJGNvbG9yID09PSB1bmRlZmluZWQgPyBcImdyZXlcIiA6IF9yZWYkY29sb3IsXG4gICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgIHN1YmplY3QgPSBfcmVmLnN1YmplY3QsXG4gICAgICAgIGNvbm5lY3RvciA9IF9yZWYuY29ubmVjdG9yLFxuICAgICAgICBub3RlID0gX3JlZi5ub3RlLFxuICAgICAgICBkaXNhYmxlID0gX3JlZi5kaXNhYmxlLFxuICAgICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEFubm90YXRpb24pO1xuXG4gICAgdGhpcy5fZHggPSBueCAhPT0gdW5kZWZpbmVkID8gbnggLSB4IDogZHg7XG4gICAgdGhpcy5fZHkgPSBueSAhPT0gdW5kZWZpbmVkID8gbnkgLSB5IDogZHk7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IFwiXCI7XG5cbiAgICB0aGlzLl90eXBlID0gdHlwZSB8fCBcIlwiO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICB0aGlzLm5vdGUgPSBub3RlIHx8IHt9O1xuICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yIHx8IHt9O1xuICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3QgfHwge307XG5cbiAgICB0aGlzLmRpc2FibGUgPSBkaXNhYmxlIHx8IFtdO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQW5ub3RhdGlvbiwgW3tcbiAgICBrZXk6IFwidXBkYXRlUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICBpZiAodGhpcy50eXBlLnNldFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudHlwZS5zZXRQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy50eXBlLnN1YmplY3QgJiYgdGhpcy50eXBlLnN1YmplY3Quc2VsZWN0QWxsKFwiOm5vdCguaGFuZGxlKVwiKS5ub2RlcygpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRoaXMudHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJDb21wb25lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMudHlwZS5jbGVhckNvbXBvbmVudHMgJiYgdGhpcy50eXBlLmNsZWFyQ29tcG9uZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMudHlwZS5zZXRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy50eXBlLnNldE9mZnNldCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUuY29ubmVjdG9yLnNlbGVjdEFsbChcIjpub3QoLmhhbmRsZSlcIikubm9kZXMoKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aGlzLnR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR5cGUucmVkcmF3Tm90ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGFzc05hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIGlmICh0aGlzLnR5cGUuc2V0Q2xhc3NOYW1lKSB0aGlzLnR5cGUuc2V0Q2xhc3NOYW1lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodHlwZSkge1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmNsZWFyQ29tcG9uZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHgpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHkpIHtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb2xvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoY29sb3IpIHtcbiAgICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkeCkge1xuICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkeSkge1xuICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm54XCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobngpIHtcbiAgICAgIHRoaXMuX2R4ID0gbnggLSB0aGlzLl94O1xuICAgICAgdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibnlcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShueSkge1xuICAgICAgdGhpcy5fZHkgPSBueSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMuX2R4LCB5OiB0aGlzLl9keSB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoX3JlZjIpIHtcbiAgICAgIHZhciB4ID0gX3JlZjIueCxcbiAgICAgICAgICB5ID0gX3JlZjIueTtcblxuICAgICAgdGhpcy5fZHggPSB4O1xuICAgICAgdGhpcy5fZHkgPSB5O1xuICAgICAgdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMuX3gsIHk6IHRoaXMuX3kgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKF9yZWYzKSB7XG4gICAgICB2YXIgeCA9IF9yZWYzLngsXG4gICAgICAgICAgeSA9IF9yZWYzLnk7XG5cbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLl94ICsgdGhpcy5fZHgsXG4gICAgICAgIHk6IHRoaXMuX3kgKyB0aGlzLl9keVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIHg6IHRoaXMuX3gsXG4gICAgICAgIHk6IHRoaXMuX3ksXG4gICAgICAgIGR4OiB0aGlzLl9keCxcbiAgICAgICAgZHk6IHRoaXMuX2R5XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5kYXRhICYmIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoID4gMCkganNvbi5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHRoaXMudHlwZSkganNvbi50eXBlID0gdGhpcy50eXBlO1xuICAgICAgaWYgKHRoaXMuX2NsYXNzTmFtZSkganNvbi5jbGFzc05hbWUgPSB0aGlzLl9jbGFzc05hbWU7XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3RvcikubGVuZ3RoID4gMCkganNvbi5jb25uZWN0b3IgPSB0aGlzLmNvbm5lY3RvcjtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnN1YmplY3QpLmxlbmd0aCA+IDApIGpzb24uc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm5vdGUpLmxlbmd0aCA+IDApIGpzb24ubm90ZSA9IHRoaXMubm90ZTtcblxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBbm5vdGF0aW9uO1xufSgpO1xuXG52YXIgQW5ub3RhdGlvbkNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25Db2xsZWN0aW9uKF9yZWYpIHtcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBfcmVmLmFubm90YXRpb25zLFxuICAgICAgICBhY2Nlc3NvcnMgPSBfcmVmLmFjY2Vzc29ycyxcbiAgICAgICAgYWNjZXNzb3JzSW52ZXJzZSA9IF9yZWYuYWNjZXNzb3JzSW52ZXJzZTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uQ29sbGVjdGlvbik7XG5cbiAgICB0aGlzLmFjY2Vzc29ycyA9IGFjY2Vzc29ycztcbiAgICB0aGlzLmFjY2Vzc29yc0ludmVyc2UgPSBhY2Nlc3NvcnNJbnZlcnNlO1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEFubm90YXRpb25Db2xsZWN0aW9uLCBbe1xuICAgIGtleTogXCJjbGVhclR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVHlwZXMobmV3U2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkLnR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGQuc3ViamVjdCA9IG5ld1NldHRpbmdzICYmIG5ld1NldHRpbmdzLnN1YmplY3QgfHwgZC5zdWJqZWN0O1xuICAgICAgICBkLmNvbm5lY3RvciA9IG5ld1NldHRpbmdzICYmIG5ld1NldHRpbmdzLmNvbm5lY3RvciB8fCBkLmNvbm5lY3RvcjtcbiAgICAgICAgZC5ub3RlID0gbmV3U2V0dGluZ3MgJiYgbmV3U2V0dGluZ3Mubm90ZSB8fCBkLm5vdGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25XaXRoQWNjZXNzb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uV2l0aEFjY2Vzc29ycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkLnR5cGUuc2V0UG9zaXRpb25XaXRoQWNjZXNzb3JzKF90aGlzLmFjY2Vzc29ycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE1vZGUoX2VkaXRNb2RlKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGEudHlwZS5lZGl0TW9kZSA9IF9lZGl0TW9kZTtcbiAgICAgICAgICBhLnR5cGUudXBkYXRlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZURpc2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzYWJsZShkaXNhYmxlKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGRpc2FibGUuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGEudHlwZVtkXSkge1xuICAgICAgICAgICAgICBhLnR5cGVbZF0ucmVtb3ZlICYmIGEudHlwZVtkXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgYS50eXBlW2RdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVGV4dFdyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGV4dFdyYXAodGV4dFdyYXApIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoYS50eXBlICYmIGEudHlwZS51cGRhdGVUZXh0V3JhcCkge1xuICAgICAgICAgIGEudHlwZS51cGRhdGVUZXh0V3JhcCh0ZXh0V3JhcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRleHQoKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSAmJiBhLnR5cGUuZHJhd1RleHQpIHtcbiAgICAgICAgICBhLnR5cGUuZHJhd1RleHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU5vdGVQYWRkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU5vdGVQYWRkaW5nKG5vdGVQYWRkaW5nKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGEudHlwZS5ub3RlUGFkZGluZyA9IG5vdGVQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIganNvbiA9IGEuanNvbjtcbiAgICAgICAgaWYgKF90aGlzMi5hY2Nlc3NvcnNJbnZlcnNlICYmIGEuZGF0YSkge1xuICAgICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzMi5hY2Nlc3NvcnNJbnZlcnNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBqc29uLmRhdGFba10gPSBfdGhpczIuYWNjZXNzb3JzSW52ZXJzZVtrXSh7IHg6IGEueCwgeTogYS55IH0pO1xuXG4gICAgICAgICAgICAvL1RPRE8gbWFrZSB0aGlzIGZlYXNpYmxlIHRvIG1hcCBiYWNrIHRvIGRhdGEgZm9yIG90aGVyIHR5cGVzIG9mIHN1YmplY3RzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm90ZU5vZGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhLnR5cGUuZ2V0Tm90ZUJCb3hPZmZzZXQoKSwgeyBwb3NpdGlvblg6IGEueCwgcG9zaXRpb25ZOiBhLnkgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvL1RPRE86IGNvbWUgYmFjayBhbmQgcmV0aGluayBpZiBhLnggYW5kIGEueSBhcmUgYXBwbGljYWJsZSBpbiBhbGwgc2l0dWF0aW9uc1xuICAgIC8vIGdldCBjb25uZWN0b3JOb2RlcygpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChhID0+ICh7IC4uLmEudHlwZS5nZXRDb25uZWN0b3JCQm94KCksIHN0YXJ0WDogYS54LCBzdGFydFk6IGEueX0pKVxuICAgIC8vIH1cblxuICAgIC8vIGdldCBzdWJqZWN0Tm9kZXMoKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoYSA9PiAoeyAuLi5hLnR5cGUuZ2V0U3ViamVjdEJCb3goKSwgc3RhcnRYOiBhLngsIHN0YXJ0WTogYS55fSkpXG4gICAgLy8gfVxuXG4gICAgLy8gZ2V0IGFubm90YXRpb25Ob2RlcygpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChhID0+ICh7IC4uLmEudHlwZS5nZXRBbm5vdGF0aW9uQkJveCgpLCBzdGFydFg6IGEueCwgc3RhcnRZOiBhLnl9KSlcbiAgICAvLyB9XG5cbiAgfV0pO1xuICByZXR1cm4gQW5ub3RhdGlvbkNvbGxlY3Rpb247XG59KCk7XG5cbnZhciBwb2ludEhhbmRsZSA9IGZ1bmN0aW9uIHBvaW50SGFuZGxlKF9yZWYpIHtcbiAgdmFyIF9yZWYkY3ggPSBfcmVmLmN4LFxuICAgICAgY3ggPSBfcmVmJGN4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRjeCxcbiAgICAgIF9yZWYkY3kgPSBfcmVmLmN5LFxuICAgICAgY3kgPSBfcmVmJGN5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRjeTtcblxuICByZXR1cm4geyBtb3ZlOiB7IHg6IGN4LCB5OiBjeSB9IH07XG59O1xuXG52YXIgY2lyY2xlSGFuZGxlcyA9IGZ1bmN0aW9uIGNpcmNsZUhhbmRsZXMoX3JlZjIpIHtcbiAgdmFyIF9yZWYyJGN4ID0gX3JlZjIuY3gsXG4gICAgICBjeCA9IF9yZWYyJGN4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkY3gsXG4gICAgICBfcmVmMiRjeSA9IF9yZWYyLmN5LFxuICAgICAgY3kgPSBfcmVmMiRjeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJGN5LFxuICAgICAgcjEgPSBfcmVmMi5yMSxcbiAgICAgIHIyID0gX3JlZjIucjIsXG4gICAgICBwYWRkaW5nID0gX3JlZjIucGFkZGluZztcblxuICB2YXIgaCA9IHsgbW92ZTogeyB4OiBjeCwgeTogY3kgfSB9O1xuXG4gIGlmIChyMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaC5yMSA9IHsgeDogY3ggKyByMSAvIE1hdGguc3FydCgyKSwgeTogY3kgKyByMSAvIE1hdGguc3FydCgyKSB9O1xuICB9XG5cbiAgaWYgKHIyICE9PSB1bmRlZmluZWQpIHtcbiAgICBoLnIyID0geyB4OiBjeCArIHIyIC8gTWF0aC5zcXJ0KDIpLCB5OiBjeSArIHIyIC8gTWF0aC5zcXJ0KDIpIH07XG4gIH1cblxuICBpZiAocGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaC5wYWRkaW5nID0geyB4OiBjeCArIHIxICsgcGFkZGluZywgeTogY3kgfTtcbiAgfVxuXG4gIHJldHVybiBoO1xufTtcblxuXG5cblxuXG4vL2FyYyBoYW5kbGVzXG52YXIgYWRkSGFuZGxlcyA9IGZ1bmN0aW9uIGFkZEhhbmRsZXMoX3JlZjUpIHtcbiAgdmFyIGdyb3VwID0gX3JlZjUuZ3JvdXAsXG4gICAgICBoYW5kbGVzID0gX3JlZjUuaGFuZGxlcyxcbiAgICAgIF9yZWY1JHIgPSBfcmVmNS5yLFxuICAgICAgciA9IF9yZWY1JHIgPT09IHVuZGVmaW5lZCA/IDEwIDogX3JlZjUkcjtcblxuICAvL2dpdmUgaXQgYSBncm91cCBhbmQgeCx5IHRvIGRyYXcgaGFuZGxlc1xuICAvL3RoZW4gZ2l2ZSBpdCBpbnN0cnVjdGlvbnMgb24gd2hhdCB0aGUgaGFuZGxlcyBjaGFuZ2VcbiAgdmFyIGggPSBncm91cC5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLmRhdGEoaGFuZGxlcyk7XG5cbiAgaC5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIikuYXR0cihcImZpbGxcIiwgXCJncmV5XCIpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMC4xKS5hdHRyKFwiY3Vyc29yXCIsIFwibW92ZVwiKS5hdHRyKFwic3Ryb2tlLWRhc2hhcnJheVwiLCA1KS5hdHRyKFwic3Ryb2tlXCIsIFwiZ3JleVwiKS5jYWxsKGRyYWcoKS5jb250YWluZXIoc2VsZWN0KFwiZy5hbm5vdGF0aW9uc1wiKS5ub2RlKCkpLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zdGFydCAmJiBkLnN0YXJ0KGQpO1xuICB9KS5vbihcImRyYWdcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5kcmFnICYmIGQuZHJhZyhkKTtcbiAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5lbmQgJiYgZC5lbmQoZCk7XG4gIH0pKTtcblxuICBncm91cC5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0pLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0pLmF0dHIoXCJyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuciB8fCByO1xuICB9KS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gXCJoYW5kbGUgXCIgKyAoZC5jbGFzc05hbWUgfHwgXCJcIik7XG4gIH0pO1xuXG4gIGguZXhpdCgpLnJlbW92ZSgpO1xufTtcblxudmFyIGxlZnRSaWdodER5bmFtaWMgPSBmdW5jdGlvbiBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCB5KSB7XG4gIGlmIChhbGlnbiA9PT0gXCJkeW5hbWljXCIgfHwgYWxpZ24gPT09IFwibGVmdFwiIHx8IGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICBpZiAoeSA8IDApIHtcbiAgICAgIGFsaWduID0gXCJ0b3BcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ24gPSBcImJvdHRvbVwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxpZ247XG59O1xuXG52YXIgdG9wQm90dG9tRHluYW1pYyA9IGZ1bmN0aW9uIHRvcEJvdHRvbUR5bmFtaWMoYWxpZ24sIHgpIHtcbiAgaWYgKGFsaWduID09PSBcImR5bmFtaWNcIiB8fCBhbGlnbiA9PT0gXCJ0b3BcIiB8fCBhbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgYWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWduID0gXCJsZWZ0XCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGlnbjtcbn07XG5cbnZhciBvcmllbnRhdGlvblRvcEJvdHRvbSA9IFtcInRvcEJvdHRvbVwiLCBcInRvcFwiLCBcImJvdHRvbVwiXTtcbnZhciBvcmllbnRhdGlvbkxlZnRSaWdodCA9IFtcImxlZnRSaWdodFwiLCBcImxlZnRcIiwgXCJyaWdodFwiXTtcblxudmFyIG5vdGVBbGlnbm1lbnQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIF9yZWYkcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHBhZGRpbmcsXG4gICAgICBfcmVmJGJib3ggPSBfcmVmLmJib3gsXG4gICAgICBiYm94ID0gX3JlZiRiYm94ID09PSB1bmRlZmluZWQgPyB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSA6IF9yZWYkYmJveCxcbiAgICAgIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIG9yaWVudGF0aW9uID0gX3JlZi5vcmllbnRhdGlvbixcbiAgICAgIF9yZWYkb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfcmVmJG9mZnNldCA9PT0gdW5kZWZpbmVkID8geyB4OiAwLCB5OiAwIH0gOiBfcmVmJG9mZnNldDtcblxuICB2YXIgeCA9IC1iYm94Lng7XG4gIHZhciB5ID0gMDsgLy8tYmJveC55XG4gIGlmIChvcmllbnRhdGlvblRvcEJvdHRvbS5pbmRleE9mKG9yaWVudGF0aW9uKSAhPT0gLTEpIHtcbiAgICBhbGlnbiA9IHRvcEJvdHRvbUR5bmFtaWMoYWxpZ24sIG9mZnNldC54KTtcbiAgICBpZiAob2Zmc2V0LnkgPCAwICYmIG9yaWVudGF0aW9uID09PSBcInRvcEJvdHRvbVwiIHx8IG9yaWVudGF0aW9uID09PSBcInRvcFwiKSB7XG4gICAgICB5IC09IGJib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSBwYWRkaW5nO1xuICAgIH1cblxuICAgIGlmIChhbGlnbiA9PT0gXCJtaWRkbGVcIikge1xuICAgICAgeCAtPSBiYm94LndpZHRoIC8gMjtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHggLT0gYmJveC53aWR0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JpZW50YXRpb25MZWZ0UmlnaHQuaW5kZXhPZihvcmllbnRhdGlvbikgIT09IC0xKSB7XG4gICAgYWxpZ24gPSBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCBvZmZzZXQueSk7XG4gICAgaWYgKG9mZnNldC54IDwgMCAmJiBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0UmlnaHRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHggLT0gYmJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gcGFkZGluZztcbiAgICB9XG5cbiAgICBpZiAoYWxpZ24gPT09IFwibWlkZGxlXCIpIHtcbiAgICAgIHkgLT0gYmJveC5oZWlnaHQgLyAyO1xuICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwidG9wXCIpIHtcbiAgICAgIHkgLT0gYmJveC5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xufSk7XG5cbnZhciBsaW5lQnVpbGRlciA9IGZ1bmN0aW9uIGxpbmVCdWlsZGVyKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBfcmVmJGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGN1cnZlID0gX3JlZiRjdXJ2ZSA9PT0gdW5kZWZpbmVkID8gY3VydmVMaW5lYXIgOiBfcmVmJGN1cnZlLFxuICAgICAgY2FudmFzQ29udGV4dCA9IF9yZWYuY2FudmFzQ29udGV4dCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NJRCA9IF9yZWYuY2xhc3NJRDtcblxuICB2YXIgbGluZUdlbiA9IGxpbmUoKS5jdXJ2ZShjdXJ2ZSk7XG5cbiAgdmFyIGJ1aWxkZXIgPSB7XG4gICAgdHlwZTogJ3BhdGgnLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNsYXNzSUQ6IGNsYXNzSUQsXG4gICAgZGF0YTogZGF0YVxuICB9O1xuXG4gIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgbGluZUdlbi5jb250ZXh0KGNhbnZhc0NvbnRleHQpO1xuICAgIGJ1aWxkZXIucGF0aE1ldGhvZHMgPSBsaW5lR2VuO1xuICB9IGVsc2Uge1xuICAgIGJ1aWxkZXIuYXR0cnMgPSB7XG4gICAgICBkOiBsaW5lR2VuKGRhdGEpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyO1xufTtcblxudmFyIGFyY0J1aWxkZXIgPSBmdW5jdGlvbiBhcmNCdWlsZGVyKF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRleHQgPSBfcmVmMi5jYW52YXNDb250ZXh0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NJRCA9IF9yZWYyLmNsYXNzSUQ7XG5cblxuICB2YXIgYnVpbGRlciA9IHtcbiAgICB0eXBlOiAncGF0aCcsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgY2xhc3NJRDogY2xhc3NJRCxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG5cbiAgdmFyIGFyY1NoYXBlID0gYXJjKCkuaW5uZXJSYWRpdXMoZGF0YS5pbm5lclJhZGl1cyB8fCAwKS5vdXRlclJhZGl1cyhkYXRhLm91dGVyUmFkaXVzIHx8IGRhdGEucmFkaXVzIHx8IDIpLnN0YXJ0QW5nbGUoZGF0YS5zdGFydEFuZ2xlIHx8IDApLmVuZEFuZ2xlKGRhdGEuZW5kQW5nbGUgfHwgMiAqIE1hdGguUEkpO1xuXG4gIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgYXJjU2hhcGUuY29udGV4dChjYW52YXNDb250ZXh0KTtcbiAgICBidWlsZGVyLnBhdGhNZXRob2RzID0gbGluZUdlbjtcbiAgfSBlbHNlIHtcblxuICAgIGJ1aWxkZXIuYXR0cnMgPSB7XG4gICAgICBkOiBhcmNTaGFwZSgpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyO1xufTtcblxudmFyIG5vdGVWZXJ0aWNhbCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgX3JlZiR4ID0gX3JlZi54LFxuICAgICAgeCA9IF9yZWYkeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeCxcbiAgICAgIF9yZWYkeSA9IF9yZWYueSxcbiAgICAgIHkgPSBfcmVmJHkgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHksXG4gICAgICBiYm94ID0gX3JlZi5iYm94LFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG5cbiAgYWxpZ24gPSBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCBvZmZzZXQueSk7XG5cbiAgaWYgKGFsaWduID09PSBcInRvcFwiKSB7XG4gICAgeSAtPSBiYm94LmhlaWdodDtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHkgLT0gYmJveC5oZWlnaHQgLyAyO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBbW3gsIHldLCBbeCwgeSArIGJib3guaGVpZ2h0XV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJub3RlLWxpbmVcIiB9KV0gfTtcbn0pO1xuXG52YXIgbm90ZUhvcml6b250YWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICBiYm94ID0gX3JlZi5iYm94O1xuXG4gIGFsaWduID0gdG9wQm90dG9tRHluYW1pYyhhbGlnbiwgb2Zmc2V0LngpO1xuXG4gIGlmIChhbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgeCAtPSBiYm94LndpZHRoO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSBcIm1pZGRsZVwiKSB7XG4gICAgeCAtPSBiYm94LndpZHRoIC8gMjtcbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4LCB5XSwgW3ggKyBiYm94LndpZHRoLCB5XV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJub3RlLWxpbmVcIiB9KV0gfTtcbn0pO1xuXG52YXIgbGluZVNldHVwID0gZnVuY3Rpb24gbGluZVNldHVwKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBzdWJqZWN0VHlwZSA9IF9yZWYuc3ViamVjdFR5cGU7XG5cbiAgdmFyIGFubm90YXRpb24gPSB0eXBlLmFubm90YXRpb247XG4gIHZhciBvZmZzZXQgPSBhbm5vdGF0aW9uLnBvc2l0aW9uO1xuXG4gIHZhciB4MSA9IGFubm90YXRpb24ueCAtIG9mZnNldC54LFxuICAgICAgeDIgPSB4MSArIGFubm90YXRpb24uZHgsXG4gICAgICB5MSA9IGFubm90YXRpb24ueSAtIG9mZnNldC55LFxuICAgICAgeTIgPSB5MSArIGFubm90YXRpb24uZHk7XG5cbiAgdmFyIHN1YmplY3REYXRhID0gYW5ub3RhdGlvbi5zdWJqZWN0O1xuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJjaXJjbGVcIiAmJiAoc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzKSkge1xuICAgIHZhciBoID0gTWF0aC5zcXJ0KCh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKSk7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKC15MiAvIGgpO1xuICAgIHZhciByID0gc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzICsgKHN1YmplY3REYXRhLnJhZGl1c1BhZGRpbmcgfHwgMCk7XG5cbiAgICB4MSA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSAqIHIpICogKHgyIDwgMCA/IC0xIDogMSk7XG4gICAgeTEgPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkgKiByKSAqICh5MiA8IDAgPyAtMSA6IDEpO1xuICB9XG5cbiAgaWYgKHN1YmplY3RUeXBlID09PSBcInJlY3RcIikge1xuICAgIHZhciB3aWR0aCA9IHN1YmplY3REYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICAgIGlmICh3aWR0aCA+IDAgJiYgYW5ub3RhdGlvbi5keCA+IDAgfHwgd2lkdGggPCAwICYmIGFubm90YXRpb24uZHggPCAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMod2lkdGgpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keCkpIHgxID0gd2lkdGggLyAyO2Vsc2UgeDEgPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IDAgJiYgYW5ub3RhdGlvbi5keSA+IDAgfHwgaGVpZ2h0IDwgMCAmJiBhbm5vdGF0aW9uLmR5IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPiBNYXRoLmFicyhhbm5vdGF0aW9uLmR5KSkgeTEgPSBoZWlnaHQgLyAyO2Vsc2UgeTEgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmICh4MSA9PT0gd2lkdGggLyAyICYmIHkxID09PSBoZWlnaHQgLyAyKSB7XG4gICAgICB4MSA9IHgyO3kxID0geTI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtbeDEsIHkxXSwgW3gyLCB5Ml1dO1xufTtcblxudmFyIGNvbm5lY3RvckxpbmUgPSAoZnVuY3Rpb24gKGNvbm5lY3RvckRhdGEpIHtcbiAgdmFyIGRhdGEgPSBsaW5lU2V0dXAoY29ubmVjdG9yRGF0YSk7XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV0gfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yRWxib3cgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBzdWJqZWN0VHlwZSA9IF9yZWYuc3ViamVjdFR5cGU7XG5cblxuICB2YXIgYW5ub3RhdGlvbiA9IHR5cGUuYW5ub3RhdGlvbjtcbiAgdmFyIG9mZnNldCA9IGFubm90YXRpb24ucG9zaXRpb247XG5cbiAgdmFyIHgxID0gYW5ub3RhdGlvbi54IC0gb2Zmc2V0LngsXG4gICAgICB4MiA9IHgxICsgYW5ub3RhdGlvbi5keCxcbiAgICAgIHkxID0gYW5ub3RhdGlvbi55IC0gb2Zmc2V0LnksXG4gICAgICB5MiA9IHkxICsgYW5ub3RhdGlvbi5keTtcblxuICB2YXIgc3ViamVjdERhdGEgPSBhbm5vdGF0aW9uLnN1YmplY3Q7XG5cbiAgaWYgKHN1YmplY3RUeXBlID09PSBcInJlY3RcIikge1xuICAgIHZhciB3aWR0aCA9IHN1YmplY3REYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICAgIGlmICh3aWR0aCA+IDAgJiYgYW5ub3RhdGlvbi5keCA+IDAgfHwgd2lkdGggPCAwICYmIGFubm90YXRpb24uZHggPCAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMod2lkdGgpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keCkpIHgxID0gd2lkdGggLyAyO2Vsc2UgeDEgPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IDAgJiYgYW5ub3RhdGlvbi5keSA+IDAgfHwgaGVpZ2h0IDwgMCAmJiBhbm5vdGF0aW9uLmR5IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPiBNYXRoLmFicyhhbm5vdGF0aW9uLmR5KSkgeTEgPSBoZWlnaHQgLyAyO2Vsc2UgeTEgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmICh4MSA9PT0gd2lkdGggLyAyICYmIHkxID09PSBoZWlnaHQgLyAyKSB7XG4gICAgICB4MSA9IHgyO3kxID0geTI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGEgPSBbW3gxLCB5MV0sIFt4MiwgeTJdXTtcblxuICB2YXIgZGlmZlkgPSB5MiAtIHkxO1xuICB2YXIgZGlmZlggPSB4MiAtIHgxO1xuICB2YXIgeGUgPSB4MjtcbiAgdmFyIHllID0geTI7XG4gIHZhciBvcHBvc2l0ZSA9IHkyIDwgeTEgJiYgeDIgPiB4MSB8fCB4MiA8IHgxICYmIHkyID4geTEgPyAtMSA6IDE7XG5cbiAgaWYgKE1hdGguYWJzKGRpZmZYKSA8IE1hdGguYWJzKGRpZmZZKSkge1xuICAgIHhlID0geDI7XG4gICAgeWUgPSB5MSArIGRpZmZYICogb3Bwb3NpdGU7XG4gIH0gZWxzZSB7XG4gICAgeWUgPSB5MjtcbiAgICB4ZSA9IHgxICsgZGlmZlkgKiBvcHBvc2l0ZTtcbiAgfVxuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJjaXJjbGVcIiAmJiAoc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzKSkge1xuICAgIHZhciByID0gKHN1YmplY3REYXRhLm91dGVyUmFkaXVzIHx8IHN1YmplY3REYXRhLnJhZGl1cykgKyAoc3ViamVjdERhdGEucmFkaXVzUGFkZGluZyB8fCAwKTtcbiAgICB2YXIgbGVuZ3RoID0gciAvIE1hdGguc3FydCgyKTtcblxuICAgIGlmIChNYXRoLmFicyhkaWZmWCkgPiBsZW5ndGggJiYgTWF0aC5hYnMoZGlmZlkpID4gbGVuZ3RoKSB7XG4gICAgICB4MSA9IGxlbmd0aCAqICh4MiA8IDAgPyAtMSA6IDEpO1xuICAgICAgeTEgPSBsZW5ndGggKiAoeTIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gxLCB5MV0sIFt4ZSwgeWVdLCBbeDIsIHkyXV07XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmWCkgPiBNYXRoLmFicyhkaWZmWSkpIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbigteTIgLyByKTtcbiAgICAgIHgxID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpICogcikgKiAoeDIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gxLCB5Ml0sIFt4MiwgeTJdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9hbmdsZSA9IE1hdGguYWNvcyh4MiAvIHIpO1xuICAgICAgeTEgPSBNYXRoLmFicyhNYXRoLnNpbihfYW5nbGUpICogcikgKiAoeTIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gyLCB5MV0sIFt4MiwgeTJdXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IFtbeDEsIHkxXSwgW3hlLCB5ZV0sIFt4MiwgeTJdXTtcbiAgfVxuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV0gfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yQ3VydmUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBjb25uZWN0b3JEYXRhID0gX3JlZi5jb25uZWN0b3JEYXRhLFxuICAgICAgc3ViamVjdFR5cGUgPSBfcmVmLnN1YmplY3RUeXBlO1xuXG5cbiAgaWYgKCFjb25uZWN0b3JEYXRhKSB7XG4gICAgY29ubmVjdG9yRGF0YSA9IHt9O1xuICB9XG4gIGlmICghY29ubmVjdG9yRGF0YS5wb2ludHMgfHwgdHlwZW9mIGNvbm5lY3RvckRhdGEucG9pbnRzID09PSBcIm51bWJlclwiKSB7XG4gICAgY29ubmVjdG9yRGF0YS5wb2ludHMgPSBjcmVhdGVQb2ludHModHlwZS5hbm5vdGF0aW9uLm9mZnNldCwgY29ubmVjdG9yRGF0YS5wb2ludHMpO1xuICB9XG4gIGlmICghY29ubmVjdG9yRGF0YS5jdXJ2ZSkge1xuICAgIGNvbm5lY3RvckRhdGEuY3VydmUgPSBjdXJ2ZUNhdG11bGxSb207XG4gIH1cblxuICB2YXIgaGFuZGxlcyA9IFtdO1xuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIGNIYW5kbGVzID0gY29ubmVjdG9yRGF0YS5wb2ludHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHBvaW50SGFuZGxlKHsgY3g6IGNbMF0sIGN5OiBjWzFdIH0pLCB7IGluZGV4OiBpIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIHVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gdXBkYXRlUG9pbnQoaW5kZXgpIHtcbiAgICAgIGNvbm5lY3RvckRhdGEucG9pbnRzW2luZGV4XVswXSArPSBldmVudC5keDtcbiAgICAgIGNvbm5lY3RvckRhdGEucG9pbnRzW2luZGV4XVsxXSArPSBldmVudC5keTtcbiAgICAgIHR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgfTtcblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMoY0hhbmRsZXMubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGgubW92ZSwgeyBkcmFnOiB1cGRhdGVQb2ludC5iaW5kKHR5cGUsIGguaW5kZXgpIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gbGluZVNldHVwKHsgdHlwZTogdHlwZSwgc3ViamVjdFR5cGU6IHN1YmplY3RUeXBlIH0pO1xuICBkYXRhID0gW2RhdGFbMF1dLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShjb25uZWN0b3JEYXRhLnBvaW50cyksIFtkYXRhWzFdXSk7XG4gIHZhciBjb21wb25lbnRzID0gW2xpbmVCdWlsZGVyKHsgZGF0YTogZGF0YSwgY3VydmU6IGNvbm5lY3RvckRhdGEuY3VydmUsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV07XG5cbiAgcmV0dXJuIHsgY29tcG9uZW50czogY29tcG9uZW50cywgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbnZhciBjcmVhdGVQb2ludHMgPSBmdW5jdGlvbiBjcmVhdGVQb2ludHMob2Zmc2V0KSB7XG4gIHZhciBhbmNob3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyO1xuXG4gIHZhciBkaWZmID0geyB4OiBvZmZzZXQueCAvIChhbmNob3JzICsgMSksIHk6IG9mZnNldC55IC8gKGFuY2hvcnMgKyAxKSB9O1xuICB2YXIgcCA9IFtdO1xuXG4gIHZhciBpID0gMTtcbiAgZm9yICg7IGkgPD0gYW5jaG9yczsgaSsrKSB7XG4gICAgcC5wdXNoKFtkaWZmLnggKiBpICsgaSAlIDIgKiAyMCwgZGlmZi55ICogaSAtIGkgJSAyICogMjBdKTtcbiAgfVxuICByZXR1cm4gcDtcbn07XG5cbnZhciBjb25uZWN0b3JBcnJvdyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYW5ub3RhdGlvbiA9IF9yZWYuYW5ub3RhdGlvbixcbiAgICAgIHN0YXJ0ID0gX3JlZi5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWYuZW5kLFxuICAgICAgX3JlZiRzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWYkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHNjYWxlO1xuXG4gIHZhciBvZmZzZXQgPSBhbm5vdGF0aW9uLnBvc2l0aW9uO1xuICBpZiAoIXN0YXJ0KSB7XG4gICAgc3RhcnQgPSBbYW5ub3RhdGlvbi5keCwgYW5ub3RhdGlvbi5keV07XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBbLWVuZFswXSArIHN0YXJ0WzBdLCAtZW5kWzFdICsgc3RhcnRbMV1dO1xuICB9XG4gIGlmICghZW5kKSB7XG4gICAgZW5kID0gW2Fubm90YXRpb24ueCAtIG9mZnNldC54LCBhbm5vdGF0aW9uLnkgLSBvZmZzZXQueV07XG4gIH1cblxuICB2YXIgeDEgPSBlbmRbMF0sXG4gICAgICB5MSA9IGVuZFsxXTtcblxuICB2YXIgZHggPSBzdGFydFswXTtcbiAgdmFyIGR5ID0gc3RhcnRbMV07XG5cbiAgdmFyIHNpemUgPSAxMCAqIHNjYWxlO1xuICB2YXIgYW5nbGVPZmZzZXQgPSAxNiAvIDE4MCAqIE1hdGguUEk7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcblxuICBpZiAoZHggPCAwKSB7XG4gICAgYW5nbGUgKz0gTWF0aC5QSTtcbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4MSwgeTFdLCBbTWF0aC5jb3MoYW5nbGUgKyBhbmdsZU9mZnNldCkgKiBzaXplICsgeDEsIE1hdGguc2luKGFuZ2xlICsgYW5nbGVPZmZzZXQpICogc2l6ZSArIHkxXSwgW01hdGguY29zKGFuZ2xlIC0gYW5nbGVPZmZzZXQpICogc2l6ZSArIHgxLCBNYXRoLnNpbihhbmdsZSAtIGFuZ2xlT2Zmc2V0KSAqIHNpemUgKyB5MV0sIFt4MSwgeTFdXTtcblxuICAvL1RPRE8gYWRkIGluIHJldmVyc2VcbiAgLy8gaWYgKGNhbnZhc0NvbnRleHQuYXJyb3dSZXZlcnNlKXtcbiAgLy8gICBkYXRhID0gW1t4MSwgeTFdLFxuICAvLyAgIFtNYXRoLmNvcyhhbmdsZSArIGFuZ2xlT2Zmc2V0KSpzaXplLCBNYXRoLnNpbihhbmdsZSArIGFuZ2xlT2Zmc2V0KSpzaXplXSxcbiAgLy8gICBbTWF0aC5jb3MoYW5nbGUgLSBhbmdsZU9mZnNldCkqc2l6ZSwgTWF0aC5zaW4oYW5nbGUgLSBhbmdsZU9mZnNldCkqc2l6ZV0sXG4gIC8vICAgW3gxLCB5MV1cbiAgLy8gICBdXG4gIC8vIH0gZWxzZSB7XG4gIC8vICAgZGF0YSA9IFtbeDEsIHkxXSxcbiAgLy8gICBbTWF0aC5jb3MoYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZSwgTWF0aC5zaW4oYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZV0sXG4gIC8vICAgW01hdGguY29zKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemUsIE1hdGguc2luKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemVdLFxuICAvLyAgIFt4MSwgeTFdXG4gIC8vICAgXVxuICAvLyB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0b3ItZW5kIGNvbm5lY3Rvci1hcnJvd1wiLFxuICAgICAgY2xhc3NJRDogXCJjb25uZWN0b3ItZW5kXCJcbiAgICB9KV1cbiAgfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yRG90ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBsaW5lJCQxID0gX3JlZi5saW5lLFxuICAgICAgX3JlZiRzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWYkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHNjYWxlO1xuXG4gIHZhciBkb3QgPSBhcmNCdWlsZGVyKHtcbiAgICBjbGFzc05hbWU6IFwiY29ubmVjdG9yLWVuZCBjb25uZWN0b3ItZG90XCIsXG4gICAgY2xhc3NJRDogXCJjb25uZWN0b3ItZW5kXCIsXG4gICAgZGF0YTogeyByYWRpdXM6IDMgKiBNYXRoLnNxcnQoc2NhbGUpIH1cbiAgfSk7XG4gIGRvdC5hdHRycy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGxpbmUkJDEuZGF0YVswXVswXSArIFwiLCBcIiArIGxpbmUkJDEuZGF0YVswXVsxXSArIFwiKVwiO1xuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtkb3RdIH07XG59KTtcblxudmFyIHN1YmplY3RDaXJjbGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN1YmplY3REYXRhID0gX3JlZi5zdWJqZWN0RGF0YSxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgaWYgKCFzdWJqZWN0RGF0YS5yYWRpdXMgJiYgIXN1YmplY3REYXRhLm91dGVyUmFkaXVzKSB7XG4gICAgc3ViamVjdERhdGEucmFkaXVzID0gMjA7XG4gIH1cblxuICB2YXIgaGFuZGxlcyA9IFtdO1xuICB2YXIgYyA9IGFyY0J1aWxkZXIoeyBkYXRhOiBzdWJqZWN0RGF0YSwgY2xhc3NOYW1lOiBcInN1YmplY3RcIiB9KTtcbiAgaWYgKHR5cGUuZWRpdE1vZGUpIHtcbiAgICB2YXIgaCA9IGNpcmNsZUhhbmRsZXMoe1xuICAgICAgcjE6IGMuZGF0YS5vdXRlclJhZGl1cyB8fCBjLmRhdGEucmFkaXVzLFxuICAgICAgcjI6IGMuZGF0YS5pbm5lclJhZGl1cyxcbiAgICAgIHBhZGRpbmc6IHN1YmplY3REYXRhLnJhZGl1c1BhZGRpbmdcbiAgICB9KTtcblxuICAgIHZhciB1cGRhdGVSYWRpdXMgPSBmdW5jdGlvbiB1cGRhdGVSYWRpdXMoYXR0cikge1xuICAgICAgdmFyIHIgPSBzdWJqZWN0RGF0YVthdHRyXSArIGV2ZW50LmR4ICogTWF0aC5zcXJ0KDIpO1xuICAgICAgc3ViamVjdERhdGFbYXR0cl0gPSByO1xuICAgICAgdHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICB2YXIgY0hhbmRsZXMgPSBbX2V4dGVuZHMoe30sIGgucjEsIHtcbiAgICAgIGRyYWc6IHVwZGF0ZVJhZGl1cy5iaW5kKHR5cGUsIHN1YmplY3REYXRhLm91dGVyUmFkaXVzICE9PSB1bmRlZmluZWQgPyBcIm91dGVyUmFkaXVzXCIgOiBcInJhZGl1c1wiKVxuICAgIH0pXTtcblxuICAgIGlmIChzdWJqZWN0RGF0YS5pbm5lclJhZGl1cykge1xuICAgICAgY0hhbmRsZXMucHVzaChfZXh0ZW5kcyh7fSwgaC5yMiwgeyBkcmFnOiB1cGRhdGVSYWRpdXMuYmluZCh0eXBlLCBcImlubmVyUmFkaXVzXCIpIH0pKTtcbiAgICB9XG4gICAgaGFuZGxlcyA9IHR5cGUubWFwSGFuZGxlcyhjSGFuZGxlcyk7XG4gIH1cblxuICBjLmF0dHJzW1wiZmlsbC1vcGFjaXR5XCJdID0gMDtcblxuICByZXR1cm4geyBjb21wb25lbnRzOiBbY10sIGhhbmRsZXM6IGhhbmRsZXMgfTtcbn0pO1xuXG52YXIgc3ViamVjdFJlY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN1YmplY3REYXRhID0gX3JlZi5zdWJqZWN0RGF0YSxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgaWYgKCFzdWJqZWN0RGF0YS53aWR0aCkge1xuICAgIHN1YmplY3REYXRhLndpZHRoID0gMTAwO1xuICB9XG4gIGlmICghc3ViamVjdERhdGEuaGVpZ2h0KSB7XG4gICAgc3ViamVjdERhdGEuaGVpZ2h0ID0gMTAwO1xuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcbiAgdmFyIHdpZHRoID0gc3ViamVjdERhdGEud2lkdGgsXG4gICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICB2YXIgZGF0YSA9IFtbMCwgMF0sIFt3aWR0aCwgMF0sIFt3aWR0aCwgaGVpZ2h0XSwgWzAsIGhlaWdodF0sIFswLCAwXV07XG4gIHZhciByZWN0ID0gbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6IFwic3ViamVjdFwiIH0pO1xuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIHVwZGF0ZVdpZHRoID0gZnVuY3Rpb24gdXBkYXRlV2lkdGgoKSB7XG4gICAgICBzdWJqZWN0RGF0YS53aWR0aCA9IGV2ZW50Lng7XG4gICAgICB0eXBlLnJlZHJhd1N1YmplY3QoKTtcbiAgICAgIHR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiB1cGRhdGVIZWlnaHQoKSB7XG4gICAgICBzdWJqZWN0RGF0YS5oZWlnaHQgPSBldmVudC55O1xuICAgICAgdHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICB2YXIgckhhbmRsZXMgPSBbeyB4OiB3aWR0aCwgeTogaGVpZ2h0IC8gMiwgZHJhZzogdXBkYXRlV2lkdGguYmluZCh0eXBlKSB9LCB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0LCBkcmFnOiB1cGRhdGVIZWlnaHQuYmluZCh0eXBlKSB9XTtcblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMockhhbmRsZXMpO1xuICB9XG4gIHJlY3QuYXR0cnNbXCJmaWxsLW9wYWNpdHlcIl0gPSAwLjE7XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtyZWN0XSwgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbnZhciBzdWJqZWN0VGhyZXNob2xkID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdWJqZWN0RGF0YSA9IF9yZWYuc3ViamVjdERhdGEsXG4gICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gIHZhciBvZmZzZXQgPSB0eXBlLmFubm90YXRpb24ucG9zaXRpb247XG5cbiAgdmFyIHgxID0gKHN1YmplY3REYXRhLngxICE9PSB1bmRlZmluZWQgPyBzdWJqZWN0RGF0YS54MSA6IG9mZnNldC54KSAtIG9mZnNldC54LFxuICAgICAgeDIgPSAoc3ViamVjdERhdGEueDIgIT09IHVuZGVmaW5lZCA/IHN1YmplY3REYXRhLngyIDogb2Zmc2V0LngpIC0gb2Zmc2V0LngsXG4gICAgICB5MSA9IChzdWJqZWN0RGF0YS55MSAhPT0gdW5kZWZpbmVkID8gc3ViamVjdERhdGEueTEgOiBvZmZzZXQueSkgLSBvZmZzZXQueSxcbiAgICAgIHkyID0gKHN1YmplY3REYXRhLnkyICE9PSB1bmRlZmluZWQgPyBzdWJqZWN0RGF0YS55MiA6IG9mZnNldC55KSAtIG9mZnNldC55O1xuXG4gIHZhciBkYXRhID0gW1t4MSwgeTFdLCBbeDIsIHkyXV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogJ3N1YmplY3QnIH0pXSB9O1xufSk7XG5cbnZhciBzdWJqZWN0QmFkZ2UgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIF9yZWYkc3ViamVjdERhdGEgPSBfcmVmLnN1YmplY3REYXRhLFxuICAgICAgc3ViamVjdERhdGEgPSBfcmVmJHN1YmplY3REYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkc3ViamVjdERhdGEsXG4gICAgICBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICB0eXBlID0gX3JlZiR0eXBlID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkdHlwZTtcbiAgdmFyIGFubm90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciB0eXBlU2V0dGluZ3MgPSB0eXBlLnR5cGVTZXR0aW5ncyAmJiB0eXBlLnR5cGVTZXR0aW5ncy5zdWJqZWN0O1xuXG4gIGlmICghc3ViamVjdERhdGEucmFkaXVzKSB7XG4gICAgaWYgKHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MucmFkaXVzKSB7XG4gICAgICBzdWJqZWN0RGF0YS5yYWRpdXMgPSB0eXBlU2V0dGluZ3MucmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJqZWN0RGF0YS5yYWRpdXMgPSAxNDtcbiAgICB9XG4gIH1cbiAgaWYgKCFzdWJqZWN0RGF0YS54KSB7XG4gICAgaWYgKHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MueCkge1xuICAgICAgc3ViamVjdERhdGEueCA9IHR5cGVTZXR0aW5ncy54O1xuICAgIH1cbiAgfVxuICBpZiAoIXN1YmplY3REYXRhLnkpIHtcbiAgICBpZiAodHlwZVNldHRpbmdzICYmIHR5cGVTZXR0aW5ncy55KSB7XG4gICAgICBzdWJqZWN0RGF0YS55ID0gdHlwZVNldHRpbmdzLnk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIHJhZGl1cyA9IHN1YmplY3REYXRhLnJhZGl1cztcbiAgdmFyIGlubmVyUmFkaXVzID0gcmFkaXVzICogMC43O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICB2YXIgbm90Q29ybmVyT2Zmc2V0ID0gTWF0aC5zcXJ0KDIpICogcmFkaXVzO1xuICB2YXIgcGxhY2VtZW50ID0ge1xuICAgIHhsZWZ0Y29ybmVyOiAtcmFkaXVzLFxuICAgIHhyaWdodGNvcm5lcjogcmFkaXVzLFxuICAgIHl0b3Bjb3JuZXI6IC1yYWRpdXMsXG4gICAgeWJvdHRvbWNvcm5lcjogcmFkaXVzLFxuICAgIHhsZWZ0OiAtbm90Q29ybmVyT2Zmc2V0LFxuICAgIHhyaWdodDogbm90Q29ybmVyT2Zmc2V0LFxuICAgIHl0b3A6IC1ub3RDb3JuZXJPZmZzZXQsXG4gICAgeWJvdHRvbTogbm90Q29ybmVyT2Zmc2V0XG4gIH07XG5cbiAgaWYgKHN1YmplY3REYXRhLnggJiYgIXN1YmplY3REYXRhLnkpIHtcbiAgICB4ID0gcGxhY2VtZW50W1wieFwiICsgc3ViamVjdERhdGEueF07XG4gIH0gZWxzZSBpZiAoc3ViamVjdERhdGEueSAmJiAhc3ViamVjdERhdGEueCkge1xuICAgIHkgPSBwbGFjZW1lbnRbXCJ5XCIgKyBzdWJqZWN0RGF0YS55XTtcbiAgfSBlbHNlIGlmIChzdWJqZWN0RGF0YS54ICYmIHN1YmplY3REYXRhLnkpIHtcbiAgICB4ID0gcGxhY2VtZW50W1wieFwiICsgc3ViamVjdERhdGEueCArIFwiY29ybmVyXCJdO1xuICAgIHkgPSBwbGFjZW1lbnRbXCJ5XCIgKyBzdWJqZWN0RGF0YS55ICsgXCJjb3JuZXJcIl07XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiKVwiO1xuICB2YXIgY2lyY2xlYmcgPSBhcmNCdWlsZGVyKHsgY2xhc3NOYW1lOiBcInN1YmplY3RcIiwgZGF0YTogeyByYWRpdXM6IHJhZGl1cyB9IH0pO1xuICBjaXJjbGViZy5hdHRycy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIGNpcmNsZWJnLmF0dHJzLmZpbGwgPSBhbm5vdGF0aW9uLmNvbG9yO1xuICBjaXJjbGViZy5hdHRyc1tcInN0cm9rZS1saW5lY2FwXCJdID0gXCJyb3VuZFwiO1xuICBjaXJjbGViZy5hdHRyc1tcInN0cm9rZS13aWR0aFwiXSA9IFwiM3B4XCI7XG5cbiAgdmFyIGNpcmNsZSA9IGFyY0J1aWxkZXIoe1xuICAgIGNsYXNzTmFtZTogXCJzdWJqZWN0LXJpbmdcIixcbiAgICBkYXRhOiB7IG91dGVyUmFkaXVzOiByYWRpdXMsIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyB9XG4gIH0pO1xuXG4gIGNpcmNsZS5hdHRycy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIC8vIGNpcmNsZS5hdHRycy5maWxsID0gYW5ub3RhdGlvbi5jb2xvclxuICBjaXJjbGUuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gPSBcIjNweFwiO1xuICBjaXJjbGUuYXR0cnMuZmlsbCA9IFwid2hpdGVcIjtcblxuICB2YXIgcG9pbnRlciA9IHZvaWQgMDtcbiAgaWYgKHggJiYgeSB8fCAheCAmJiAheSkge1xuICAgIHBvaW50ZXIgPSBsaW5lQnVpbGRlcih7XG4gICAgICBjbGFzc05hbWU6IFwic3ViamVjdC1wb2ludGVyXCIsXG4gICAgICBkYXRhOiBbWzAsIDBdLCBbeCB8fCAwLCAwXSwgWzAsIHkgfHwgMF0sIFswLCAwXV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh4IHx8IHkpIHtcbiAgICB2YXIgbm90Q29ybmVyUG9pbnRlclhZID0gZnVuY3Rpb24gbm90Q29ybmVyUG9pbnRlclhZKHYpIHtcbiAgICAgIHZhciBzaWduID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgcmV0dXJuIHYgJiYgdiAvIE1hdGguc3FydCgyKSAvIE1hdGguc3FydCgyKSB8fCBzaWduICogcmFkaXVzIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH07XG5cbiAgICBwb2ludGVyID0gbGluZUJ1aWxkZXIoe1xuICAgICAgY2xhc3NOYW1lOiBcInN1YmplY3QtcG9pbnRlclwiLFxuICAgICAgZGF0YTogW1swLCAwXSwgW25vdENvcm5lclBvaW50ZXJYWSh4KSwgbm90Q29ybmVyUG9pbnRlclhZKHkpXSwgW25vdENvcm5lclBvaW50ZXJYWSh4LCAtMSksIG5vdENvcm5lclBvaW50ZXJYWSh5LCAtMSldLCBbMCwgMF1dXG4gICAgfSk7XG4gIH1cblxuICBpZiAocG9pbnRlcikge1xuICAgIHBvaW50ZXIuYXR0cnMuZmlsbCA9IGFubm90YXRpb24uY29sb3I7XG4gICAgcG9pbnRlci5hdHRyc1tcInN0cm9rZS1saW5lY2FwXCJdID0gXCJyb3VuZFwiO1xuICAgIHBvaW50ZXIuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gPSBcIjNweFwiO1xuICAgIGNvbXBvbmVudHMucHVzaChwb2ludGVyKTtcbiAgfVxuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIGRyYWdCYWRnZSA9IGZ1bmN0aW9uIGRyYWdCYWRnZSgpIHtcbiAgICAgIHN1YmplY3REYXRhLnggPSBldmVudC54IDwgLXJhZGl1cyAqIDIgPyBcImxlZnRcIiA6IGV2ZW50LnggPiByYWRpdXMgKiAyID8gXCJyaWdodFwiIDogdW5kZWZpbmVkO1xuICAgICAgc3ViamVjdERhdGEueSA9IGV2ZW50LnkgPCAtcmFkaXVzICogMiA/IFwidG9wXCIgOiBldmVudC55ID4gcmFkaXVzICogMiA/IFwiYm90dG9tXCIgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHR5cGUucmVkcmF3U3ViamVjdCgpO1xuICAgIH07XG5cbiAgICB2YXIgYkhhbmRsZXMgPSB7IHg6IHggKiAyLCB5OiB5ICogMiwgZHJhZzogZHJhZ0JhZGdlLmJpbmQodHlwZSkgfTtcbiAgICBpZiAoIWJIYW5kbGVzLnggJiYgIWJIYW5kbGVzLnkpIHtcbiAgICAgIGJIYW5kbGVzLnkgPSAtcmFkaXVzO1xuICAgIH1cblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMoW2JIYW5kbGVzXSk7XG4gIH1cblxuICB2YXIgdGV4dCA9IHZvaWQgMDtcbiAgaWYgKHN1YmplY3REYXRhLnRleHQpIHtcbiAgICB0ZXh0ID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBjbGFzc05hbWU6IFwiYmFkZ2UtdGV4dFwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgZmlsbDogXCJ3aGl0ZVwiLFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIi43ZW1cIixcbiAgICAgICAgdGV4dDogc3ViamVjdERhdGEudGV4dCxcbiAgICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBcIm1pZGRsZVwiLFxuICAgICAgICBkeTogXCIuMjVlbVwiLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudHMucHVzaChjaXJjbGViZyk7XG4gIGNvbXBvbmVudHMucHVzaChjaXJjbGUpO1xuICBjb21wb25lbnRzLnB1c2godGV4dCk7XG5cbiAgcmV0dXJuIHsgY29tcG9uZW50czogY29tcG9uZW50cywgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbi8vTm90ZSBvcHRpb25zXG4vL0Nvbm5lY3RvciBvcHRpb25zXG4vL1N1YmplY3Qgb3B0aW9uc1xudmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFR5cGUoX3JlZikge1xuICAgIHZhciBhID0gX3JlZi5hLFxuICAgICAgICBhbm5vdGF0aW9uID0gX3JlZi5hbm5vdGF0aW9uLFxuICAgICAgICBlZGl0TW9kZSA9IF9yZWYuZWRpdE1vZGUsXG4gICAgICAgIGRpc3BhdGNoZXIgPSBfcmVmLmRpc3BhdGNoZXIsXG4gICAgICAgIG5vdGVQYWRkaW5nID0gX3JlZi5ub3RlUGFkZGluZyxcbiAgICAgICAgYWNjZXNzb3JzID0gX3JlZi5hY2Nlc3NvcnM7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZSk7XG5cbiAgICB0aGlzLmEgPSBhO1xuXG4gICAgdGhpcy5ub3RlID0gYW5ub3RhdGlvbi5kaXNhYmxlLmluZGV4T2YoXCJub3RlXCIpID09PSAtMSAmJiBhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1ub3RlXCIpO1xuICAgIHRoaXMubm90ZUNvbnRlbnQgPSB0aGlzLm5vdGUgJiYgYS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgIHRoaXMuY29ubmVjdG9yID0gYW5ub3RhdGlvbi5kaXNhYmxlLmluZGV4T2YoXCJjb25uZWN0b3JcIikgPT09IC0xICYmIGEuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLWNvbm5lY3RvclwiKTtcbiAgICB0aGlzLnN1YmplY3QgPSBhbm5vdGF0aW9uLmRpc2FibGUuaW5kZXhPZihcInN1YmplY3RcIikgPT09IC0xICYmIGEuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLXN1YmplY3RcIik7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIGlmIChkaXNwYXRjaGVyKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGFkZEhhbmRsZXJzLmJpbmQobnVsbCwgZGlzcGF0Y2hlciwgYW5ub3RhdGlvbik7XG4gICAgICBoYW5kbGVyKHsgY29tcG9uZW50OiB0aGlzLm5vdGUsIG5hbWU6IFwibm90ZVwiIH0pO1xuICAgICAgaGFuZGxlcih7IGNvbXBvbmVudDogdGhpcy5jb25uZWN0b3IsIG5hbWU6IFwiY29ubmVjdG9yXCIgfSk7XG4gICAgICBoYW5kbGVyKHsgY29tcG9uZW50OiB0aGlzLnN1YmplY3QsIG5hbWU6IFwic3ViamVjdFwiIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG4gICAgdGhpcy5lZGl0TW9kZSA9IGFubm90YXRpb24uZWRpdE1vZGUgfHwgZWRpdE1vZGU7XG4gICAgdGhpcy5ub3RlUGFkZGluZyA9IG5vdGVQYWRkaW5nICE9PSB1bmRlZmluZWQgPyBub3RlUGFkZGluZyA6IDM7XG4gICAgdGhpcy5vZmZzZXRDb3JuZXJYID0gMDtcbiAgICB0aGlzLm9mZnNldENvcm5lclkgPSAwO1xuXG4gICAgaWYgKGFjY2Vzc29ycyAmJiBhbm5vdGF0aW9uLmRhdGEpIHtcbiAgICAgIHRoaXMuaW5pdChhY2Nlc3NvcnMpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGUsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChhY2Nlc3NvcnMpIHtcbiAgICAgIGlmICghdGhpcy5hbm5vdGF0aW9uLngpIHtcbiAgICAgICAgdGhpcy5tYXBYKGFjY2Vzc29ycyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbi55KSB7XG4gICAgICAgIHRoaXMubWFwWShhY2Nlc3NvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFkoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoYWNjZXNzb3JzLnkpIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uLnkgPSBhY2Nlc3NvcnMueSh0aGlzLmFubm90YXRpb24uZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWChhY2Nlc3NvcnMpIHtcbiAgICAgIGlmIChhY2Nlc3NvcnMueCkge1xuICAgICAgICB0aGlzLmFubm90YXRpb24ueCA9IGFjY2Vzc29ycy54KHRoaXMuYW5ub3RhdGlvbi5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmEuc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5yZW1vdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd09uU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdPblNWRyhjb21wb25lbnQsIGJ1aWxkZXJzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYnVpbGRlcnMpKSB7XG4gICAgICAgIGJ1aWxkZXJzID0gW2J1aWxkZXJzXTtcbiAgICAgIH1cblxuICAgICAgYnVpbGRlcnMuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmMi50eXBlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgICAgICAgYXR0cnMgPSBfcmVmMi5hdHRycyxcbiAgICAgICAgICAgIGhhbmRsZXMgPSBfcmVmMi5oYW5kbGVzLFxuICAgICAgICAgICAgY2xhc3NJRCA9IF9yZWYyLmNsYXNzSUQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaGFuZGxlXCIpIHtcbiAgICAgICAgICBhZGRIYW5kbGVzKHsgZ3JvdXA6IGNvbXBvbmVudCwgcjogYXR0cnMgJiYgYXR0cnMuciwgaGFuZGxlczogaGFuZGxlcyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdXaXRoQ2xhc3MoY29tcG9uZW50LCBbX3RoaXMuYW5ub3RhdGlvbl0sIHR5cGUsIGNsYXNzTmFtZSwgY2xhc3NJRCk7XG4gICAgICAgICAgdmFyIGVsID0gY29tcG9uZW50LnNlbGVjdCh0eXBlICsgXCIuXCIgKyAoY2xhc3NJRCB8fCBjbGFzc05hbWUpKTtcbiAgICAgICAgICB2YXIgYWRkQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgICAgdmFyIHJlbW92ZUF0dHJzID0gW107XG5cbiAgICAgICAgICB2YXIgY3VycmVudEF0dHJzID0gZWwubm9kZSgpLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBjdXJyZW50QXR0cnNbaV0ubmFtZTtcbiAgICAgICAgICAgIGlmIChhZGRBdHRycy5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBuYW1lICE9PSBcImNsYXNzXCIpIHJlbW92ZUF0dHJzLnB1c2gobmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgIGVsLnRleHQoYXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwuYXR0cihhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZW1vdmVBdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihhdHRyLCBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy9UT0RPOiBob3cgdG8gZXh0ZW5kIHRoaXMgdG8gYSBkcmF3T25DYW52YXMgbW9kZT9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5vdGVCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vdGVCQm94KCkge1xuICAgICAgcmV0dXJuIGJib3hXaXRob3V0SGFuZGxlcyh0aGlzLm5vdGUsIFwiLmFubm90YXRpb24tbm90ZS1jb250ZW50IHRleHRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5vdGVCQm94T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vdGVCQm94T2Zmc2V0KCkge1xuICAgICAgdmFyIGJib3ggPSBiYm94V2l0aG91dEhhbmRsZXModGhpcy5ub3RlLCBcIi5hbm5vdGF0aW9uLW5vdGUtY29udGVudFwiKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLm5vdGVDb250ZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIikuc3BsaXQoL1xcKHxcXCx8XFwpL2cpO1xuICAgICAgYmJveC5vZmZzZXRDb3JuZXJYID0gcGFyc2VGbG9hdCh0cmFuc2Zvcm1bMV0pICsgdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgYmJveC5vZmZzZXRDb3JuZXJZID0gcGFyc2VGbG9hdCh0cmFuc2Zvcm1bMl0pICsgdGhpcy5hbm5vdGF0aW9uLmR5O1xuICAgICAgYmJveC5vZmZzZXRYID0gdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgYmJveC5vZmZzZXRZID0gdGhpcy5hbm5vdGF0aW9uLmR5O1xuICAgICAgcmV0dXJuIGJib3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTdWJqZWN0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdmFyIHN1YmplY3REYXRhID0gdGhpcy5hbm5vdGF0aW9uLnN1YmplY3Q7XG4gICAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICAgIHZhciBzdWJqZWN0UGFyYW1zID0geyB0eXBlOiB0aGlzLCBzdWJqZWN0RGF0YTogc3ViamVjdERhdGEgfTtcblxuICAgICAgdmFyIHN1YmplY3QgPSB7fTtcbiAgICAgIGlmICh0eXBlID09PSBcImNpcmNsZVwiKSBzdWJqZWN0ID0gc3ViamVjdENpcmNsZShzdWJqZWN0UGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcInJlY3RcIikgc3ViamVjdCA9IHN1YmplY3RSZWN0KHN1YmplY3RQYXJhbXMpO2Vsc2UgaWYgKHR5cGUgPT09IFwidGhyZXNob2xkXCIpIHN1YmplY3QgPSBzdWJqZWN0VGhyZXNob2xkKHN1YmplY3RQYXJhbXMpO2Vsc2UgaWYgKHR5cGUgPT09IFwiYmFkZ2VcIikgc3ViamVjdCA9IHN1YmplY3RCYWRnZShzdWJqZWN0UGFyYW1zLCB0aGlzLmFubm90YXRpb24pO1xuXG4gICAgICB2YXIgX3N1YmplY3QgPSBzdWJqZWN0LFxuICAgICAgICAgIF9zdWJqZWN0JGNvbXBvbmVudHMgPSBfc3ViamVjdC5jb21wb25lbnRzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfc3ViamVjdCRjb21wb25lbnRzID09PSB1bmRlZmluZWQgPyBbXSA6IF9zdWJqZWN0JGNvbXBvbmVudHMsXG4gICAgICAgICAgX3N1YmplY3QkaGFuZGxlcyA9IF9zdWJqZWN0LmhhbmRsZXMsXG4gICAgICAgICAgaGFuZGxlcyA9IF9zdWJqZWN0JGhhbmRsZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX3N1YmplY3QkaGFuZGxlcztcblxuICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICYmIGMuYXR0cnMgJiYgIWMuYXR0cnMuc3Ryb2tlKSB7XG4gICAgICAgICAgYy5hdHRycy5zdHJva2UgPSBfdGhpczIuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdCh0aGlzLm1hcEhhbmRsZXMoW3sgZHJhZzogdGhpcy5kcmFnU3ViamVjdC5iaW5kKHRoaXMpIH1dKSk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7IHR5cGU6IFwiaGFuZGxlXCIsIGhhbmRsZXM6IGhhbmRsZXMgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q29ubmVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDb25uZWN0b3IoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICB2YXIgY29ubmVjdG9yRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5jb25uZWN0b3I7XG4gICAgICB2YXIgdHlwZSA9IGNvbm5lY3RvckRhdGEudHlwZSB8fCBjb250ZXh0LnR5cGU7XG4gICAgICB2YXIgY29ubmVjdG9yUGFyYW1zID0geyB0eXBlOiB0aGlzLCBjb25uZWN0b3JEYXRhOiBjb25uZWN0b3JEYXRhIH07XG4gICAgICBjb25uZWN0b3JQYXJhbXMuc3ViamVjdFR5cGUgPSB0aGlzLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnR5cGVTZXR0aW5ncy5zdWJqZWN0ICYmIHRoaXMudHlwZVNldHRpbmdzLnN1YmplY3QudHlwZTtcblxuICAgICAgdmFyIGNvbm5lY3RvciA9IHt9O1xuICAgICAgaWYgKHR5cGUgPT09IFwiY3VydmVcIikgY29ubmVjdG9yID0gY29ubmVjdG9yQ3VydmUoY29ubmVjdG9yUGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcImVsYm93XCIpIGNvbm5lY3RvciA9IGNvbm5lY3RvckVsYm93KGNvbm5lY3RvclBhcmFtcyk7ZWxzZSBjb25uZWN0b3IgPSBjb25uZWN0b3JMaW5lKGNvbm5lY3RvclBhcmFtcyk7XG4gICAgICB2YXIgX2Nvbm5lY3RvciA9IGNvbm5lY3RvcixcbiAgICAgICAgICBfY29ubmVjdG9yJGNvbXBvbmVudHMgPSBfY29ubmVjdG9yLmNvbXBvbmVudHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF9jb25uZWN0b3IkY29tcG9uZW50cyA9PT0gdW5kZWZpbmVkID8gW10gOiBfY29ubmVjdG9yJGNvbXBvbmVudHMsXG4gICAgICAgICAgX2Nvbm5lY3RvciRoYW5kbGVzID0gX2Nvbm5lY3Rvci5oYW5kbGVzLFxuICAgICAgICAgIGhhbmRsZXMgPSBfY29ubmVjdG9yJGhhbmRsZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX2Nvbm5lY3RvciRoYW5kbGVzO1xuXG4gICAgICB2YXIgbGluZSQkMSA9IGNvbXBvbmVudHNbMF07XG4gICAgICAvL1RPRE86IGdlbmVyaWNpemUgdGhpcyBpbnRvIGZpbGwgdC9mIHN0cm9rZSB0L2ZcbiAgICAgIGlmIChsaW5lJCQxKSB7XG4gICAgICAgIGxpbmUkJDEuYXR0cnMuc3Ryb2tlID0gdGhpcy5hbm5vdGF0aW9uLmNvbG9yO1xuICAgICAgICBsaW5lJCQxLmF0dHJzLmZpbGwgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRUeXBlID0gY29ubmVjdG9yRGF0YS5lbmQgfHwgY29udGV4dC5lbmQ7XG4gICAgICB2YXIgZW5kID0ge307XG4gICAgICBpZiAoZW5kVHlwZSA9PT0gXCJhcnJvd1wiKSB7XG4gICAgICAgIHZhciBzID0gbGluZSQkMS5kYXRhWzFdO1xuICAgICAgICB2YXIgZSA9IGxpbmUkJDEuZGF0YVswXTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHNbMF0gLSBlWzBdLCAyKSArIE1hdGgucG93KHNbMV0gLSBlWzFdLCAyKSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IDUgJiYgbGluZSQkMS5kYXRhWzJdKSB7XG4gICAgICAgICAgcyA9IGxpbmUkJDEuZGF0YVsyXTtcbiAgICAgICAgfVxuICAgICAgICBlbmQgPSBjb25uZWN0b3JBcnJvdyh7XG4gICAgICAgICAgYW5ub3RhdGlvbjogdGhpcy5hbm5vdGF0aW9uLFxuICAgICAgICAgIHN0YXJ0OiBzLFxuICAgICAgICAgIGVuZDogZSxcbiAgICAgICAgICBzY2FsZTogY29ubmVjdG9yRGF0YS5lbmRTY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kVHlwZSA9PT0gXCJkb3RcIikge1xuICAgICAgICBlbmQgPSBjb25uZWN0b3JEb3QoeyBsaW5lOiBsaW5lJCQxLCBzY2FsZTogY29ubmVjdG9yRGF0YS5lbmRTY2FsZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVuZFR5cGUgfHwgZW5kVHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5jb25uZWN0b3Iuc2VsZWN0KFwiLmNvbm5lY3Rvci1lbmRcIikucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQuY29tcG9uZW50cykge1xuICAgICAgICBlbmQuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYy5hdHRycy5maWxsID0gX3RoaXMzLmFubm90YXRpb24uY29sb3I7XG4gICAgICAgICAgYy5hdHRycy5zdHJva2UgPSBfdGhpczMuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbXBvbmVudHMgPSBjb21wb25lbnRzLmNvbmNhdChlbmQuY29tcG9uZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGlmIChoYW5kbGVzLmxlbmd0aCAhPT0gMCkgY29tcG9uZW50cy5wdXNoKHsgdHlwZTogXCJoYW5kbGVcIiwgaGFuZGxlczogaGFuZGxlcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Tm90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Tm90ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHZhciBub3RlRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlO1xuICAgICAgdmFyIGFsaWduID0gbm90ZURhdGEuYWxpZ24gfHwgY29udGV4dC5hbGlnbiB8fCBcImR5bmFtaWNcIjtcbiAgICAgIHZhciBub3RlUGFyYW1zID0ge1xuICAgICAgICBiYm94OiBjb250ZXh0LmJib3gsXG4gICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmFubm90YXRpb24ub2Zmc2V0XG4gICAgICB9O1xuICAgICAgdmFyIGxpbmVUeXBlID0gbm90ZURhdGEubGluZVR5cGUgfHwgY29udGV4dC5saW5lVHlwZTtcbiAgICAgIHZhciBub3RlID0ge307XG4gICAgICBpZiAobGluZVR5cGUgPT09IFwidmVydGljYWxcIikgbm90ZSA9IG5vdGVWZXJ0aWNhbChub3RlUGFyYW1zKTtlbHNlIGlmIChsaW5lVHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIG5vdGUgPSBub3RlSG9yaXpvbnRhbChub3RlUGFyYW1zKTtcblxuICAgICAgdmFyIF9ub3RlID0gbm90ZSxcbiAgICAgICAgICBfbm90ZSRjb21wb25lbnRzID0gX25vdGUuY29tcG9uZW50cyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX25vdGUkY29tcG9uZW50cyA9PT0gdW5kZWZpbmVkID8gW10gOiBfbm90ZSRjb21wb25lbnRzLFxuICAgICAgICAgIF9ub3RlJGhhbmRsZXMgPSBfbm90ZS5oYW5kbGVzLFxuICAgICAgICAgIGhhbmRsZXMgPSBfbm90ZSRoYW5kbGVzID09PSB1bmRlZmluZWQgPyBbXSA6IF9ub3RlJGhhbmRsZXM7XG5cbiAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBjLmF0dHJzLnN0cm9rZSA9IF90aGlzNC5hbm5vdGF0aW9uLmNvbG9yO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGhhbmRsZXMgPSB0aGlzLm1hcEhhbmRsZXMoW3sgeDogMCwgeTogMCwgZHJhZzogdGhpcy5kcmFnTm90ZS5iaW5kKHRoaXMpIH1dKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHsgdHlwZTogXCJoYW5kbGVcIiwgaGFuZGxlczogaGFuZGxlcyB9KTtcblxuICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLmRyYWdOb3RlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuZHJhZ3N0YXJ0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuZHJhZ2VuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubm90ZS5jYWxsKGRyYWcoKS5jb250YWluZXIoc2VsZWN0KFwiZy5hbm5vdGF0aW9uc1wiKS5ub2RlKCkpLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnQoZCk7XG4gICAgICAgIH0pLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkcmFnZ2luZyhkKTtcbiAgICAgICAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZW5kKGQpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vdGUub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Tm90ZUNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGVDb250ZW50KGNvbnRleHQpIHtcbiAgICAgIHZhciBub3RlRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlO1xuICAgICAgdmFyIHBhZGRpbmcgPSBub3RlRGF0YS5wYWRkaW5nICE9PSB1bmRlZmluZWQgPyBub3RlRGF0YS5wYWRkaW5nIDogdGhpcy5ub3RlUGFkZGluZztcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IG5vdGVEYXRhLm9yaWVudGF0aW9uIHx8IGNvbnRleHQub3JpZW50YXRpb24gfHwgXCJ0b3BCb3R0b21cIjtcbiAgICAgIHZhciBsaW5lVHlwZSA9IG5vdGVEYXRhLmxpbmVUeXBlIHx8IGNvbnRleHQubGluZVR5cGU7XG4gICAgICB2YXIgYWxpZ24gPSBub3RlRGF0YS5hbGlnbiB8fCBjb250ZXh0LmFsaWduIHx8IFwiZHluYW1pY1wiO1xuXG4gICAgICBpZiAobGluZVR5cGUgPT09IFwidmVydGljYWxcIikgb3JpZW50YXRpb24gPSBcImxlZnRSaWdodFwiO2Vsc2UgaWYgKGxpbmVUeXBlID09PSBcImhvcml6b250YWxcIikgb3JpZW50YXRpb24gPSBcInRvcEJvdHRvbVwiO1xuXG4gICAgICB2YXIgbm90ZVBhcmFtcyA9IHtcbiAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgYmJveDogY29udGV4dC5iYm94LFxuICAgICAgICBvZmZzZXQ6IHRoaXMuYW5ub3RhdGlvbi5vZmZzZXQsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcbiAgICAgICAgYWxpZ246IGFsaWduXG4gICAgICB9O1xuXG4gICAgICB2YXIgX25vdGVBbGlnbm1lbnQgPSBub3RlQWxpZ25tZW50KG5vdGVQYXJhbXMpLFxuICAgICAgICAgIHggPSBfbm90ZUFsaWdubWVudC54LFxuICAgICAgICAgIHkgPSBfbm90ZUFsaWdubWVudC55O1xuXG4gICAgICB0aGlzLm9mZnNldENvcm5lclggPSB4ICsgdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgdGhpcy5vZmZzZXRDb3JuZXJZID0geSArIHRoaXMuYW5ub3RhdGlvbi5keTtcbiAgICAgIHRoaXMubm90ZSAmJiB0aGlzLm5vdGVDb250ZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiKVwiKTtcblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3T25TY3JlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd09uU2NyZWVuKGNvbXBvbmVudCwgZHJhd0Z1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3T25TVkcoY29tcG9uZW50LCBkcmF3RnVuY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhd1N1YmplY3QoKSB7XG4gICAgICB0aGlzLnN1YmplY3QgJiYgdGhpcy5kcmF3T25TY3JlZW4odGhpcy5zdWJqZWN0LCB0aGlzLmRyYXdTdWJqZWN0KCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdDb25uZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3Q29ubmVjdG9yKCkge1xuICAgICAgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5kcmF3T25TY3JlZW4odGhpcy5jb25uZWN0b3IsIHRoaXMuZHJhd0Nvbm5lY3RvcigpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3Tm90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXdOb3RlKCkge1xuICAgICAgdmFyIGJib3ggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuZ2V0Tm90ZUJCb3goKTtcblxuICAgICAgdGhpcy5ub3RlQ29udGVudCAmJiB0aGlzLmRyYXdPblNjcmVlbih0aGlzLm5vdGVDb250ZW50LCB0aGlzLmRyYXdOb3RlQ29udGVudCh7IGJib3g6IGJib3ggfSkpO1xuICAgICAgdGhpcy5ub3RlICYmIHRoaXMuZHJhd09uU2NyZWVuKHRoaXMubm90ZSwgdGhpcy5kcmF3Tm90ZSh7IGJib3g6IGJib3ggfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYW5ub3RhdGlvbi5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcG9zaXRpb24ueCArIFwiLCBcIiArIHBvc2l0aW9uLnkgKyBcIilcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQ29tcG9uZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLnN1YmplY3QgJiYgdGhpcy5zdWJqZWN0LnNlbGVjdChcIipcIikucmVtb3ZlKCk7XG4gICAgICB0aGlzLmNvbm5lY3RvciAmJiB0aGlzLmNvbm5lY3Rvci5zZWxlY3QoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgLy8gdGhpcy5ub3RlICYmIHRoaXMubm90ZS5zZWxlY3QoXCIqXCIpLnJlbW92ZSgpXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy5ub3RlKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmFubm90YXRpb24ub2Zmc2V0O1xuICAgICAgICB0aGlzLm5vdGUuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG9mZnNldC54ICsgXCIsIFwiICsgb2Zmc2V0LnkgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uV2l0aEFjY2Vzc29yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbldpdGhBY2Nlc3NvcnMoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoYWNjZXNzb3JzICYmIHRoaXMuYW5ub3RhdGlvbi5kYXRhKSB7XG4gICAgICAgIHRoaXMubWFwWChhY2Nlc3NvcnMpO1xuICAgICAgICB0aGlzLm1hcFkoYWNjZXNzb3JzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2xhc3NOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENsYXNzTmFtZSgpIHtcbiAgICAgIHRoaXMuYS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uIFwiICsgKHRoaXMuY2xhc3NOYW1lICYmIHRoaXMuY2xhc3NOYW1lKCkpICsgXCIgXCIgKyAodGhpcy5lZGl0TW9kZSA/IFwiZWRpdGFibGVcIiA6IFwiXCIpICsgXCIgXCIgKyAodGhpcy5hbm5vdGF0aW9uLmNsYXNzTmFtZSB8fCBcIlwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lKCk7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnNldE9mZnNldCgpO1xuICAgICAgdGhpcy5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0aGlzLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgICAgdGhpcy5yZWRyYXdOb3RlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdzdGFydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdzdGFydGVkKCkge1xuICAgICAgZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmRpc3BhdGNoZXIgJiYgdGhpcy5kaXNwYXRjaGVyLmNhbGwoXCJkcmFnc3RhcnRcIiwgdGhpcy5hLCB0aGlzLmFubm90YXRpb24pO1xuICAgICAgdGhpcy5hLmNsYXNzZWQoXCJkcmFnZ2luZ1wiLCB0cnVlKTtcbiAgICAgIHRoaXMuYS5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnZW5kZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ2VuZGVkKCkge1xuICAgICAgdGhpcy5kaXNwYXRjaGVyICYmIHRoaXMuZGlzcGF0Y2hlci5jYWxsKFwiZHJhZ2VuZFwiLCB0aGlzLmEsIHRoaXMuYW5ub3RhdGlvbik7XG4gICAgICB0aGlzLmEuY2xhc3NlZChcImRyYWdnaW5nXCIsIGZhbHNlKTtcbiAgICAgIHRoaXMuYS5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdTdWJqZWN0KCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5hbm5vdGF0aW9uLnBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24ueCArPSBldmVudC5keDtcbiAgICAgIHBvc2l0aW9uLnkgKz0gZXZlbnQuZHk7XG4gICAgICB0aGlzLmFubm90YXRpb24ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhZ05vdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ05vdGUoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5hbm5vdGF0aW9uLm9mZnNldDtcbiAgICAgIG9mZnNldC54ICs9IGV2ZW50LmR4O1xuICAgICAgb2Zmc2V0LnkgKz0gZXZlbnQuZHk7XG4gICAgICB0aGlzLmFubm90YXRpb24ub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBIYW5kbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcEhhbmRsZXMoaGFuZGxlcykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBoYW5kbGVzLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGgsIHtcbiAgICAgICAgICBzdGFydDogX3RoaXM1LmRyYWdzdGFydGVkLmJpbmQoX3RoaXM1KSxcbiAgICAgICAgICBlbmQ6IF90aGlzNS5kcmFnZW5kZWQuYmluZChfdGhpczUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlO1xufSgpO1xuXG52YXIgY3VzdG9tVHlwZSA9IGZ1bmN0aW9uIGN1c3RvbVR5cGUoaW5pdGlhbFR5cGUsIHR5cGVTZXR0aW5ncywgX2luaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfaW5pdGlhbFR5cGUpIHtcbiAgICBpbmhlcml0cyhjdXN0b21UeXBlLCBfaW5pdGlhbFR5cGUpO1xuXG4gICAgZnVuY3Rpb24gY3VzdG9tVHlwZShzZXR0aW5ncykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgY3VzdG9tVHlwZSk7XG5cbiAgICAgIHZhciBfdGhpczYgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChjdXN0b21UeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZSkpLmNhbGwodGhpcywgc2V0dGluZ3MpKTtcblxuICAgICAgX3RoaXM2LnR5cGVTZXR0aW5ncyA9IHR5cGVTZXR0aW5ncztcblxuICAgICAgaWYgKHR5cGVTZXR0aW5ncy5kaXNhYmxlKSB7XG4gICAgICAgIHR5cGVTZXR0aW5ncy5kaXNhYmxlLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBfdGhpczZbZF0gJiYgX3RoaXM2W2RdLnJlbW92ZSgpO1xuXG4gICAgICAgICAgX3RoaXM2W2RdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChkID09PSBcIm5vdGVcIikge1xuICAgICAgICAgICAgX3RoaXM2Lm5vdGVDb250ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXM2O1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKGN1c3RvbVR5cGUsIFt7XG4gICAgICBrZXk6IFwiY2xhc3NOYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJcIiArICh0eXBlU2V0dGluZ3MuY2xhc3NOYW1lIHx8IGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJjbGFzc05hbWVcIiwgdGhpcykgJiYgZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImNsYXNzTmFtZVwiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IFwiXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3U3ViamVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTdWJqZWN0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCA9IF9leHRlbmRzKHt9LCB0eXBlU2V0dGluZ3Muc3ViamVjdCwgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCk7XG4gICAgICAgIHJldHVybiBnZXQoY3VzdG9tVHlwZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXN0b21UeXBlLnByb3RvdHlwZSksIFwiZHJhd1N1YmplY3RcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Q29ubmVjdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Nvbm5lY3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHlwZVNldHRpbmdzLmNvbm5lY3RvciA9IF9leHRlbmRzKHt9LCB0eXBlU2V0dGluZ3MuY29ubmVjdG9yLCB0aGlzLnR5cGVTZXR0aW5ncy5jb25uZWN0b3IpO1xuICAgICAgICByZXR1cm4gZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImRyYXdDb25uZWN0b3JcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdHlwZVNldHRpbmdzLmNvbm5lY3RvciwgdGhpcy50eXBlU2V0dGluZ3MuY29ubmVjdG9yKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdOb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGUoY29udGV4dCkge1xuICAgICAgICB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlID0gX2V4dGVuZHMoe30sIHR5cGVTZXR0aW5ncy5ub3RlLCB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlKTtcbiAgICAgICAgcmV0dXJuIGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJkcmF3Tm90ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIF9leHRlbmRzKHt9LCBjb250ZXh0LCB0eXBlU2V0dGluZ3Mubm90ZSwgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Tm90ZUNvbnRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Tm90ZUNvbnRlbnQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImRyYXdOb3RlQ29udGVudFwiLCB0aGlzKS5jYWxsKHRoaXMsIF9leHRlbmRzKHt9LCBjb250ZXh0LCB0eXBlU2V0dGluZ3Mubm90ZSwgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSkpO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGFubm90YXRpb24sIGFjY2Vzc29ycykge1xuICAgICAgICBnZXQoY3VzdG9tVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBhbm5vdGF0aW9uLCBhY2Nlc3NvcnMpO1xuICAgICAgICBpZiAoX2luaXQpIHtcbiAgICAgICAgICBhbm5vdGF0aW9uID0gX2luaXQoYW5ub3RhdGlvbiwgYWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIGN1c3RvbVR5cGU7XG4gIH0oaW5pdGlhbFR5cGUpO1xufTtcblxudmFyIGQzTm90ZVRleHQgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoZDNOb3RlVGV4dCwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIGQzTm90ZVRleHQocGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgZDNOb3RlVGV4dCk7XG5cbiAgICB2YXIgX3RoaXM3ID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoZDNOb3RlVGV4dC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGQzTm90ZVRleHQpKS5jYWxsKHRoaXMsIHBhcmFtcykpO1xuXG4gICAgX3RoaXM3LnRleHRXcmFwID0gcGFyYW1zLnRleHRXcmFwIHx8IDEyMDtcbiAgICBfdGhpczcuZHJhd1RleHQoKTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoZDNOb3RlVGV4dCwgW3tcbiAgICBrZXk6IFwidXBkYXRlVGV4dFdyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGV4dFdyYXAodGV4dFdyYXApIHtcbiAgICAgIHRoaXMudGV4dFdyYXAgPSB0ZXh0V3JhcDtcbiAgICAgIHRoaXMuZHJhd1RleHQoKTtcbiAgICB9XG5cbiAgICAvL1RPRE86IGFkZCB1cGRhdGUgdGV4dCBmdW5jdGlvbmFsaXR5XG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLm5vdGUpIHtcbiAgICAgICAgbmV3V2l0aENsYXNzKHRoaXMubm90ZSwgW3RoaXMuYW5ub3RhdGlvbl0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuXG4gICAgICAgIHZhciBub3RlQ29udGVudCA9IHRoaXMubm90ZS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgICAgICBuZXdXaXRoQ2xhc3Mobm90ZUNvbnRlbnQsIFt0aGlzLmFubm90YXRpb25dLCBcInJlY3RcIiwgXCJhbm5vdGF0aW9uLW5vdGUtYmdcIik7XG4gICAgICAgIG5ld1dpdGhDbGFzcyhub3RlQ29udGVudCwgW3RoaXMuYW5ub3RhdGlvbl0sIFwidGV4dFwiLCBcImFubm90YXRpb24tbm90ZS1sYWJlbFwiKTtcbiAgICAgICAgbmV3V2l0aENsYXNzKG5vdGVDb250ZW50LCBbdGhpcy5hbm5vdGF0aW9uXSwgXCJ0ZXh0XCIsIFwiYW5ub3RhdGlvbi1ub3RlLXRpdGxlXCIpO1xuXG4gICAgICAgIHZhciB0aXRsZUJCb3ggPSB7IGhlaWdodDogMCB9O1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmEuc2VsZWN0KFwidGV4dC5hbm5vdGF0aW9uLW5vdGUtbGFiZWxcIik7XG4gICAgICAgIHZhciB3cmFwTGVuZ3RoID0gdGhpcy5hbm5vdGF0aW9uLm5vdGUgJiYgdGhpcy5hbm5vdGF0aW9uLm5vdGUud3JhcCB8fCB0aGlzLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUud3JhcCB8fCB0aGlzLnRleHRXcmFwO1xuXG4gICAgICAgIHZhciB3cmFwU3BsaXR0ZXIgPSB0aGlzLmFubm90YXRpb24ubm90ZSAmJiB0aGlzLmFubm90YXRpb24ubm90ZS53cmFwU3BsaXR0ZXIgfHwgdGhpcy50eXBlU2V0dGluZ3MgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlLndyYXBTcGxpdHRlcjtcblxuICAgICAgICB2YXIgYmdQYWRkaW5nID0gdGhpcy5hbm5vdGF0aW9uLm5vdGUgJiYgdGhpcy5hbm5vdGF0aW9uLm5vdGUuYmdQYWRkaW5nIHx8IHRoaXMudHlwZVNldHRpbmdzICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZS5iZ1BhZGRpbmc7XG5cbiAgICAgICAgdmFyIGJnUGFkZGluZ0ZpbmFsID0geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBiZ1BhZGRpbmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBiZ1BhZGRpbmdGaW5hbCA9IHtcbiAgICAgICAgICAgIHRvcDogYmdQYWRkaW5nLFxuICAgICAgICAgICAgYm90dG9tOiBiZ1BhZGRpbmcsXG4gICAgICAgICAgICBsZWZ0OiBiZ1BhZGRpbmcsXG4gICAgICAgICAgICByaWdodDogYmdQYWRkaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChiZ1BhZGRpbmcgJiYgKHR5cGVvZiBiZ1BhZGRpbmcgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihiZ1BhZGRpbmcpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGJnUGFkZGluZ0ZpbmFsID0gX2V4dGVuZHMoYmdQYWRkaW5nRmluYWwsIGJnUGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uLm5vdGUudGl0bGUpIHtcbiAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmEuc2VsZWN0KFwidGV4dC5hbm5vdGF0aW9uLW5vdGUtdGl0bGVcIik7XG4gICAgICAgICAgdGl0bGUudGV4dCh0aGlzLmFubm90YXRpb24ubm90ZS50aXRsZSk7XG4gICAgICAgICAgdGl0bGUuYXR0cihcImZpbGxcIiwgdGhpcy5hbm5vdGF0aW9uLmNvbG9yKTtcbiAgICAgICAgICB0aXRsZS5hdHRyKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpO1xuICAgICAgICAgIHRpdGxlLmNhbGwod3JhcCwgd3JhcExlbmd0aCwgd3JhcFNwbGl0dGVyKTtcbiAgICAgICAgICB0aXRsZUJCb3ggPSB0aXRsZS5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwudGV4dCh0aGlzLmFubm90YXRpb24ubm90ZS5sYWJlbCkuYXR0cihcImR4XCIsIFwiMFwiKTtcbiAgICAgICAgbGFiZWwuY2FsbCh3cmFwLCB3cmFwTGVuZ3RoLCB3cmFwU3BsaXR0ZXIpO1xuXG4gICAgICAgIGxhYmVsLmF0dHIoXCJ5XCIsIHRpdGxlQkJveC5oZWlnaHQgKiAxLjEgfHwgMCk7XG4gICAgICAgIGxhYmVsLmF0dHIoXCJmaWxsXCIsIHRoaXMuYW5ub3RhdGlvbi5jb2xvcik7XG5cbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldE5vdGVCQm94KCk7XG5cbiAgICAgICAgdGhpcy5hLnNlbGVjdChcInJlY3QuYW5ub3RhdGlvbi1ub3RlLWJnXCIpLmF0dHIoXCJ3aWR0aFwiLCBiYm94LndpZHRoICsgYmdQYWRkaW5nRmluYWwubGVmdCArIGJnUGFkZGluZ0ZpbmFsLnJpZ2h0KS5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0ICsgYmdQYWRkaW5nRmluYWwudG9wICsgYmdQYWRkaW5nRmluYWwuYm90dG9tKS5hdHRyKFwieFwiLCBiYm94LnggLSBiZ1BhZGRpbmdGaW5hbC5sZWZ0KS5hdHRyKFwieVwiLCAtYmdQYWRkaW5nRmluYWwudG9wKS5hdHRyKFwiZmlsbFwiLCBcIndoaXRlXCIpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBkM05vdGVUZXh0O1xufShUeXBlKTtcblxudmFyIGQzTGFiZWwgPSBjdXN0b21UeXBlKGQzTm90ZVRleHQsIHtcbiAgY2xhc3NOYW1lOiBcImxhYmVsXCIsXG4gIG5vdGU6IHsgYWxpZ246IFwibWlkZGxlXCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXQgPSBjdXN0b21UeXBlKGQzTm90ZVRleHQsIHtcbiAgY2xhc3NOYW1lOiBcImNhbGxvdXRcIixcbiAgbm90ZTogeyBsaW5lVHlwZTogXCJob3Jpem9udGFsXCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRFbGJvdyA9IGN1c3RvbVR5cGUoZDNDYWxsb3V0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IGVsYm93XCIsXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImVsYm93XCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRDdXJ2ZSA9IGN1c3RvbVR5cGUoZDNDYWxsb3V0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IGN1cnZlXCIsXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImN1cnZlXCIgfVxufSk7XG5cbnZhciBkM0JhZGdlID0gY3VzdG9tVHlwZShUeXBlLCB7XG4gIGNsYXNzTmFtZTogXCJiYWRnZVwiLFxuICBzdWJqZWN0OiB7IHR5cGU6IFwiYmFkZ2VcIiB9LFxuICBkaXNhYmxlOiBbXCJjb25uZWN0b3JcIiwgXCJub3RlXCJdXG59KTtcblxudmFyIGQzQ2FsbG91dENpcmNsZSA9IGN1c3RvbVR5cGUoZDNOb3RlVGV4dCwge1xuICBjbGFzc05hbWU6IFwiY2FsbG91dCBjaXJjbGVcIixcbiAgc3ViamVjdDogeyB0eXBlOiBcImNpcmNsZVwiIH0sXG4gIG5vdGU6IHsgbGluZVR5cGU6IFwiaG9yaXpvbnRhbFwiIH0sXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImVsYm93XCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRSZWN0ID0gY3VzdG9tVHlwZShkM05vdGVUZXh0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IHJlY3RcIixcbiAgc3ViamVjdDogeyB0eXBlOiBcInJlY3RcIiB9LFxuICBub3RlOiB7IGxpbmVUeXBlOiBcImhvcml6b250YWxcIiB9LFxuICBjb25uZWN0b3I6IHsgdHlwZTogXCJlbGJvd1wiIH1cbn0pO1xuXG52YXIgVGhyZXNob2xkTWFwID0gZnVuY3Rpb24gKF9kM0NhbGxvdXQpIHtcbiAgaW5oZXJpdHMoVGhyZXNob2xkTWFwLCBfZDNDYWxsb3V0KTtcblxuICBmdW5jdGlvbiBUaHJlc2hvbGRNYXAoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhyZXNob2xkTWFwKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGhyZXNob2xkTWFwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhyZXNob2xkTWFwKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUaHJlc2hvbGRNYXAsIFt7XG4gICAga2V5OiBcIm1hcFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWShhY2Nlc3NvcnMpIHtcbiAgICAgIGdldChUaHJlc2hvbGRNYXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhyZXNob2xkTWFwLnByb3RvdHlwZSksIFwibWFwWVwiLCB0aGlzKS5jYWxsKHRoaXMsIGFjY2Vzc29ycyk7XG4gICAgICB2YXIgYSA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgIGlmICgoYS5zdWJqZWN0LngxIHx8IGEuc3ViamVjdC54MikgJiYgYS5kYXRhICYmIGFjY2Vzc29ycy55KSB7XG4gICAgICAgIGEueSA9IGFjY2Vzc29ycy55KGEuZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKGEuc3ViamVjdC54MSB8fCBhLnN1YmplY3QueDIpICYmICFhLngpIHtcbiAgICAgICAgYS54ID0gYS5zdWJqZWN0LngxIHx8IGEuc3ViamVjdC54MjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBYKGFjY2Vzc29ycykge1xuICAgICAgZ2V0KFRocmVzaG9sZE1hcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaHJlc2hvbGRNYXAucHJvdG90eXBlKSwgXCJtYXBYXCIsIHRoaXMpLmNhbGwodGhpcywgYWNjZXNzb3JzKTtcbiAgICAgIHZhciBhID0gdGhpcy5hbm5vdGF0aW9uO1xuICAgICAgaWYgKChhLnN1YmplY3QueTEgfHwgYS5zdWJqZWN0LnkyKSAmJiBhLmRhdGEgJiYgYWNjZXNzb3JzLngpIHtcbiAgICAgICAgYS54ID0gYWNjZXNzb3JzLngoYS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICgoYS5zdWJqZWN0LnkxIHx8IGEuc3ViamVjdC55MikgJiYgIWEueSkge1xuICAgICAgICBhLnkgPSBhLnN1YmplY3QueTEgfHwgYS5zdWJqZWN0LnkyO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGhyZXNob2xkTWFwO1xufShkM0NhbGxvdXQpO1xuXG52YXIgZDNYWVRocmVzaG9sZCA9IGN1c3RvbVR5cGUoVGhyZXNob2xkTWFwLCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IHh5dGhyZXNob2xkXCIsXG4gIHN1YmplY3Q6IHsgdHlwZTogXCJ0aHJlc2hvbGRcIiB9XG59KTtcblxudmFyIG5ld1dpdGhDbGFzcyA9IGZ1bmN0aW9uIG5ld1dpdGhDbGFzcyhhLCBkLCB0eXBlLCBjbGFzc05hbWUsIGNsYXNzSUQpIHtcbiAgdmFyIGdyb3VwID0gYS5zZWxlY3RBbGwodHlwZSArIFwiLlwiICsgKGNsYXNzSUQgfHwgY2xhc3NOYW1lKSkuZGF0YShkKTtcbiAgZ3JvdXAuZW50ZXIoKS5hcHBlbmQodHlwZSkubWVyZ2UoZ3JvdXApLmF0dHIoXCJjbGFzc1wiLCBjbGFzc05hbWUpO1xuXG4gIGdyb3VwLmV4aXQoKS5yZW1vdmUoKTtcbiAgcmV0dXJuIGE7XG59O1xuXG52YXIgYWRkSGFuZGxlcnMgPSBmdW5jdGlvbiBhZGRIYW5kbGVycyhkaXNwYXRjaGVyLCBhbm5vdGF0aW9uLCBfcmVmMykge1xuICB2YXIgY29tcG9uZW50ID0gX3JlZjMuY29tcG9uZW50LFxuICAgICAgbmFtZSA9IF9yZWYzLm5hbWU7XG5cbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5vbihcIm1vdXNlb3Zlci5hbm5vdGF0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkaXNwYXRjaGVyLmNhbGwobmFtZSArIFwib3ZlclwiLCBjb21wb25lbnQsIGFubm90YXRpb24pO1xuICAgIH0pLm9uKFwibW91c2VvdXQuYW5ub3RhdGlvbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIuY2FsbChuYW1lICsgXCJvdXRcIiwgY29tcG9uZW50LCBhbm5vdGF0aW9uKTtcbiAgICB9KS5vbihcImNsaWNrLmFubm90YXRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLmNhbGwobmFtZSArIFwiY2xpY2tcIiwgY29tcG9uZW50LCBhbm5vdGF0aW9uKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy9UZXh0IHdyYXBwaW5nIGNvZGUgYWRhcHRlZCBmcm9tIE1pa2UgQm9zdG9ja1xudmFyIHdyYXAgPSBmdW5jdGlvbiB3cmFwKHRleHQsIHdpZHRoLCB3cmFwU3BsaXR0ZXIpIHtcbiAgdmFyIGxpbmVIZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDEuMjtcblxuICB0ZXh0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0ID0gc2VsZWN0KHRoaXMpLFxuICAgICAgICB3b3JkcyA9IHRleHQudGV4dCgpLnNwbGl0KHdyYXBTcGxpdHRlciB8fCAvWyBcXHRcXHJcXG5dKy8pLnJldmVyc2UoKS5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgIHJldHVybiB3ICE9PSBcIlwiO1xuICAgIH0pO1xuICAgIHZhciB3b3JkID0gdm9pZCAwLFxuICAgICAgICBsaW5lJCQxID0gW10sXG4gICAgICAgIHRzcGFuID0gdGV4dC50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCAwLjggKyBcImVtXCIpO1xuXG4gICAgd2hpbGUgKHdvcmQgPSB3b3Jkcy5wb3AoKSkge1xuICAgICAgbGluZSQkMS5wdXNoKHdvcmQpO1xuICAgICAgdHNwYW4udGV4dChsaW5lJCQxLmpvaW4oXCIgXCIpKTtcbiAgICAgIGlmICh0c3Bhbi5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPiB3aWR0aCAmJiBsaW5lJCQxLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGluZSQkMS5wb3AoKTtcbiAgICAgICAgdHNwYW4udGV4dChsaW5lJCQxLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbGluZSQkMSA9IFt3b3JkXTtcbiAgICAgICAgdHNwYW4gPSB0ZXh0LmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCBsaW5lSGVpZ2h0ICsgXCJlbVwiKS50ZXh0KHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgYmJveFdpdGhvdXRIYW5kbGVzID0gZnVuY3Rpb24gYmJveFdpdGhvdXRIYW5kbGVzKHNlbGVjdGlvbikge1xuICB2YXIgc2VsZWN0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiOm5vdCguaGFuZGxlKVwiO1xuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbi5zZWxlY3RBbGwoc2VsZWN0b3IpLm5vZGVzKCkucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgdmFyIGJib3ggPSBjLmdldEJCb3goKTtcbiAgICBwLnggPSBNYXRoLm1pbihwLngsIGJib3gueCk7XG4gICAgcC55ID0gTWF0aC5taW4ocC55LCBiYm94LnkpO1xuICAgIHAud2lkdGggPSBNYXRoLm1heChwLndpZHRoLCBiYm94LndpZHRoKTtcblxuICAgIHZhciB5T2Zmc2V0ID0gYyAmJiBjLmF0dHJpYnV0ZXMgJiYgYy5hdHRyaWJ1dGVzLnk7XG4gICAgcC5oZWlnaHQgPSBNYXRoLm1heChwLmhlaWdodCwgKHlPZmZzZXQgJiYgcGFyc2VGbG9hdCh5T2Zmc2V0LnZhbHVlKSB8fCAwKSArIGJib3guaGVpZ2h0KTtcbiAgICByZXR1cm4gcDtcbiAgfSwgeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbigpIHtcbiAgdmFyIGFubm90YXRpb25zID0gW10sXG4gICAgICBjb2xsZWN0aW9uID0gdm9pZCAwLFxuICAgICAgY29udGV4dCA9IHZvaWQgMCxcbiAgICAgIC8vVE9ETzogYWRkIGNhbnZhcyBmdW5jdGlvbmFsaXR5XG4gIGRpc2FibGUgPSBbXSxcbiAgICAgIGFjY2Vzc29ycyA9IHt9LFxuICAgICAgYWNjZXNzb3JzSW52ZXJzZSA9IHt9LFxuICAgICAgZWRpdE1vZGUgPSBmYWxzZSxcbiAgICAgIGlkcyA9IHZvaWQgMCxcbiAgICAgIHR5cGUgPSBkM0NhbGxvdXQsXG4gICAgICB0ZXh0V3JhcCA9IHZvaWQgMCxcbiAgICAgIG5vdGVQYWRkaW5nID0gdm9pZCAwLFxuICAgICAgYW5ub3RhdGlvbkRpc3BhdGNoZXIgPSBkaXNwYXRjaChcInN1YmplY3RvdmVyXCIsIFwic3ViamVjdG91dFwiLCBcInN1YmplY3RjbGlja1wiLCBcImNvbm5lY3Rvcm92ZXJcIiwgXCJjb25uZWN0b3JvdXRcIiwgXCJjb25uZWN0b3JjbGlja1wiLCBcIm5vdGVvdmVyXCIsIFwibm90ZW91dFwiLCBcIm5vdGVjbGlja1wiLCBcImRyYWdlbmRcIiwgXCJkcmFnc3RhcnRcIiksXG4gICAgICBzZWwgPSB2b2lkIDA7XG5cbiAgdmFyIGFubm90YXRpb24gPSBmdW5jdGlvbiBhbm5vdGF0aW9uKHNlbGVjdGlvbikge1xuICAgIHNlbCA9IHNlbGVjdGlvbjtcbiAgICAvL1RPRE86IGNoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIHN0aWxsIG5lZWRlZFxuICAgIGlmICghZWRpdE1vZGUpIHtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2xhdGVkQW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGlmICghYS50eXBlKSB7XG4gICAgICAgIGEudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoIWEuZGlzYWJsZSkge1xuICAgICAgICBhLmRpc2FibGUgPSBkaXNhYmxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKGEpO1xuICAgIH0pO1xuXG4gICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24gfHwgbmV3IEFubm90YXRpb25Db2xsZWN0aW9uKHtcbiAgICAgIGFubm90YXRpb25zOiB0cmFuc2xhdGVkQW5ub3RhdGlvbnMsXG4gICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29ycyxcbiAgICAgIGFjY2Vzc29yc0ludmVyc2U6IGFjY2Vzc29yc0ludmVyc2UsXG4gICAgICBpZHM6IGlkc1xuICAgIH0pO1xuXG4gICAgdmFyIGFubm90YXRpb25HID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcImdcIikuZGF0YShbY29sbGVjdGlvbl0pO1xuICAgIGFubm90YXRpb25HLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uc1wiKTtcblxuICAgIHZhciBncm91cCA9IHNlbGVjdGlvbi5zZWxlY3QoXCJnLmFubm90YXRpb25zXCIpO1xuICAgIG5ld1dpdGhDbGFzcyhncm91cCwgY29sbGVjdGlvbi5hbm5vdGF0aW9ucywgXCJnXCIsIFwiYW5ub3RhdGlvblwiKTtcblxuICAgIHZhciBhbm5vdGF0aW9uID0gZ3JvdXAuc2VsZWN0QWxsKFwiZy5hbm5vdGF0aW9uXCIpO1xuXG4gICAgYW5ub3RhdGlvbi5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYSA9IHNlbGVjdCh0aGlzKTtcblxuICAgICAgYS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uXCIpO1xuXG4gICAgICBuZXdXaXRoQ2xhc3MoYSwgW2RdLCBcImdcIiwgXCJhbm5vdGF0aW9uLWNvbm5lY3RvclwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tc3ViamVjdFwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZVwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1ub3RlXCIpLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgICAgZC50eXBlID0gZC50eXBlLnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBPYmplY3RdXCIgPyBkLnR5cGUgOiBuZXcgZC50eXBlKHtcbiAgICAgICAgYTogYSxcbiAgICAgICAgYW5ub3RhdGlvbjogZCxcbiAgICAgICAgdGV4dFdyYXA6IHRleHRXcmFwLFxuICAgICAgICBub3RlUGFkZGluZzogbm90ZVBhZGRpbmcsXG4gICAgICAgIGVkaXRNb2RlOiBlZGl0TW9kZSxcbiAgICAgICAgZGlzcGF0Y2hlcjogYW5ub3RhdGlvbkRpc3BhdGNoZXIsXG4gICAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzXG4gICAgICB9KTtcbiAgICAgIGQudHlwZS5kcmF3KCk7XG4gICAgICBkLnR5cGUuZHJhd1RleHQgJiYgZC50eXBlLmRyYXdUZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5qc29uID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBjb25zb2xlLmxvZyhcIkFubm90YXRpb25zIEpTT04gd2FzIGNvcGllZCB0byB5b3VyIGNsaXBib2FyZC4gUGxlYXNlIG5vdGUgdGhlIGFubm90YXRpb24gdHlwZSBpcyBub3QgSlNPTiBjb21wYXRpYmxlLiBJdCBhcHBlYXJzIGluIHRoZSBvYmplY3RzIGFycmF5IGluIHRoZSBjb25zb2xlLCBidXQgbm90IGluIHRoZSBjb3BpZWQgSlNPTi5cIiwgY29sbGVjdGlvbi5qc29uKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB3aW5kb3cuY29weShKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uLmpzb24ubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICBkZWxldGUgYS50eXBlO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSkpKTtcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYW5ub3RhdGlvbnMgJiYgY29sbGVjdGlvbikge1xuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICBhLnR5cGUuZHJhdygpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24udXBkYXRlVGV4dCh0ZXh0V3JhcCk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24udXBkYXRlZEFjY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb2xsZWN0aW9uLnNldFBvc2l0aW9uV2l0aEFjY2Vzc29ycygpO1xuICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmRpc2FibGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpc2FibGU7XG4gICAgZGlzYWJsZSA9IF87XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24udXBkYXRlRGlzYWJsZShkaXNhYmxlKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi50ZXh0V3JhcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGV4dFdyYXA7XG4gICAgdGV4dFdyYXAgPSBfO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZVRleHRXcmFwKHRleHRXcmFwKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5ub3RlUGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm90ZVBhZGRpbmc7XG4gICAgbm90ZVBhZGRpbmcgPSBfO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZU5vdGVQYWRkaW5nKG5vdGVQYWRkaW5nKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG4gIC8vdG9kbyB0aGluayBvZiBob3cgdG8gaGFuZGxlIHdoZW4gdW5kZWZpbmVkIGlzIHNlbnRcbiAgYW5ub3RhdGlvbi50eXBlID0gZnVuY3Rpb24gKF8sIHNldHRpbmdzKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHlwZTtcbiAgICB0eXBlID0gXztcbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS50eXBlLm5vdGUgJiYgYS50eXBlLm5vdGUuc2VsZWN0QWxsKFwiKjpub3QoLmFubm90YXRpb24tbm90ZS1jb250ZW50KVwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLm5vdGVDb250ZW50ICYmIGEudHlwZS5ub3RlQ29udGVudC5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBhLnR5cGUuc3ViamVjdCAmJiBhLnR5cGUuc3ViamVjdC5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBhLnR5cGUuY29ubmVjdG9yICYmIGEudHlwZS5jb25uZWN0b3Iuc2VsZWN0QWxsKFwiKlwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLnR5cGVTZXR0aW5ncyA9IHt9O1xuICAgICAgICBhLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIGEuc3ViamVjdCA9IHNldHRpbmdzICYmIHNldHRpbmdzLnN1YmplY3QgfHwgYS5zdWJqZWN0O1xuICAgICAgICBhLmNvbm5lY3RvciA9IHNldHRpbmdzICYmIHNldHRpbmdzLmNvbm5lY3RvciB8fCBhLmNvbm5lY3RvcjtcbiAgICAgICAgYS5ub3RlID0gc2V0dGluZ3MgJiYgc2V0dGluZ3Mubm90ZSB8fCBhLm5vdGU7XG4gICAgICB9KTtcblxuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmFubm90YXRpb25zID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMgfHwgYW5ub3RhdGlvbnM7XG4gICAgYW5ub3RhdGlvbnMgPSBfO1xuXG4gICAgaWYgKGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5hbm5vdGF0aW9ucykge1xuICAgICAgdmFyIHJlcnVuID0gYW5ub3RhdGlvbnMuc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWQudHlwZSB8fCBkLnR5cGUudG9TdHJpbmcoKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVydW4pIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGFubm90YXRpb24oc2VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgIGNvbnRleHQgPSBfO1xuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uYWNjZXNzb3JzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhY2Nlc3NvcnM7XG4gICAgYWNjZXNzb3JzID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmFjY2Vzc29yc0ludmVyc2UgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFjY2Vzc29yc0ludmVyc2U7XG4gICAgYWNjZXNzb3JzSW52ZXJzZSA9IF87XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5pZHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlkcztcbiAgICBpZHMgPSBfO1xuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uZWRpdE1vZGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVkaXRNb2RlO1xuICAgIGVkaXRNb2RlID0gXztcblxuICAgIGlmIChzZWwpIHtcbiAgICAgIHNlbC5zZWxlY3RBbGwoXCJnLmFubm90YXRpb25cIikuY2xhc3NlZChcImVkaXRhYmxlXCIsIGVkaXRNb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi5lZGl0TW9kZShlZGl0TW9kZSk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uY29sbGVjdGlvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgICBjb2xsZWN0aW9uID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLm9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IGFubm90YXRpb25EaXNwYXRjaGVyLm9uLmFwcGx5KGFubm90YXRpb25EaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gYW5ub3RhdGlvbkRpc3BhdGNoZXIgPyBhbm5vdGF0aW9uIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGFubm90YXRpb247XG59XG5cbnZhciBpbmRleCA9IHtcbiAgYW5ub3RhdGlvbjogYW5ub3RhdGlvbixcbiAgYW5ub3RhdGlvblR5cGVCYXNlOiBUeXBlLFxuICBhbm5vdGF0aW9uTGFiZWw6IGQzTGFiZWwsXG4gIGFubm90YXRpb25DYWxsb3V0OiBkM0NhbGxvdXQsXG4gIGFubm90YXRpb25DYWxsb3V0Q3VydmU6IGQzQ2FsbG91dEN1cnZlLFxuICBhbm5vdGF0aW9uQ2FsbG91dEVsYm93OiBkM0NhbGxvdXRFbGJvdyxcbiAgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGU6IGQzQ2FsbG91dENpcmNsZSxcbiAgYW5ub3RhdGlvbkNhbGxvdXRSZWN0OiBkM0NhbGxvdXRSZWN0LFxuICBhbm5vdGF0aW9uWFlUaHJlc2hvbGQ6IGQzWFlUaHJlc2hvbGQsXG4gIGFubm90YXRpb25CYWRnZTogZDNCYWRnZSxcbiAgYW5ub3RhdGlvbkN1c3RvbVR5cGU6IGN1c3RvbVR5cGVcbn07XG5cbmV4cG9ydCB7IGFubm90YXRpb24sIFR5cGUgYXMgYW5ub3RhdGlvblR5cGVCYXNlLCBkM0xhYmVsIGFzIGFubm90YXRpb25MYWJlbCwgZDNDYWxsb3V0IGFzIGFubm90YXRpb25DYWxsb3V0LCBkM0NhbGxvdXRDdXJ2ZSBhcyBhbm5vdGF0aW9uQ2FsbG91dEN1cnZlLCBkM0NhbGxvdXRFbGJvdyBhcyBhbm5vdGF0aW9uQ2FsbG91dEVsYm93LCBkM0NhbGxvdXRDaXJjbGUgYXMgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGUsIGQzQ2FsbG91dFJlY3QgYXMgYW5ub3RhdGlvbkNhbGxvdXRSZWN0LCBkM1hZVGhyZXNob2xkIGFzIGFubm90YXRpb25YWVRocmVzaG9sZCwgZDNCYWRnZSBhcyBhbm5vdGF0aW9uQmFkZ2UsIGN1c3RvbVR5cGUgYXMgYW5ub3RhdGlvbkN1c3RvbVR5cGUgfTtleHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Um9sbHVwTmV4dC5qcy5tYXBcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBkaXNwYXRjaH0gZnJvbSBcIi4vc3JjL2Rpc3BhdGNoXCI7XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge2V2ZW50LCBjdXN0b21FdmVudCwgc2VsZWN0LCBtb3VzZSwgdG91Y2h9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2RyYWcsIHt5ZXNkcmFnfSBmcm9tIFwiLi9ub2RyYWdcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgRHJhZ0V2ZW50IGZyb20gXCIuL2V2ZW50XCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcigpIHtcbiAgcmV0dXJuICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBldmVudC54LCB5OiBldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gZGVmYXVsdFN1YmplY3QsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgZ2VzdHVyZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxuICAgICAgYWN0aXZlID0gMCxcbiAgICAgIG1vdXNlZG93bngsXG4gICAgICBtb3VzZWRvd255LFxuICAgICAgbW91c2Vtb3ZpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiBkcmFnKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd25lZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuZHJhZ1wiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC5kcmFnIHRvdWNoY2FuY2VsLmRyYWdcIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnZXN0dXJlID0gYmVmb3Jlc3RhcnQoXCJtb3VzZVwiLCBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgbW91c2UsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCFnZXN0dXJlKSByZXR1cm47XG4gICAgc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLmRyYWdcIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLmRyYWdcIiwgbW91c2V1cHBlZCwgdHJ1ZSk7XG4gICAgbm9kcmFnKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBtb3VzZW1vdmluZyA9IGZhbHNlO1xuICAgIG1vdXNlZG93bnggPSBldmVudC5jbGllbnRYO1xuICAgIG1vdXNlZG93bnkgPSBldmVudC5jbGllbnRZO1xuICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoKSB7XG4gICAgbm9ldmVudCgpO1xuICAgIGlmICghbW91c2Vtb3ZpbmcpIHtcbiAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBtb3VzZWRvd254LCBkeSA9IGV2ZW50LmNsaWVudFkgLSBtb3VzZWRvd255O1xuICAgICAgbW91c2Vtb3ZpbmcgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgIH1cbiAgICBnZXN0dXJlcy5tb3VzZShcImRyYWdcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZXVwcGVkKCkge1xuICAgIHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKTtcbiAgICB5ZXNkcmFnKGV2ZW50LnZpZXcsIG1vdXNlbW92aW5nKTtcbiAgICBub2V2ZW50KCk7XG4gICAgZ2VzdHVyZXMubW91c2UoXCJlbmRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIGMgPSBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBiZWZvcmVzdGFydCh0b3VjaGVzW2ldLmlkZW50aWZpZXIsIGMsIHRvdWNoLCB0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vZXZlbnQoKTtcbiAgICAgICAgZ2VzdHVyZShcImRyYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbigpO1xuICAgICAgICBnZXN0dXJlKFwiZW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZXN0YXJ0KGlkLCBjb250YWluZXIsIHBvaW50LCB0aGF0LCBhcmdzKSB7XG4gICAgdmFyIHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgcywgZHgsIGR5LFxuICAgICAgICBzdWJsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29weSgpO1xuXG4gICAgaWYgKCFjdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIFwiYmVmb3Jlc3RhcnRcIiwgcywgaWQsIGFjdGl2ZSwgcFswXSwgcFsxXSwgMCwgMCwgc3VibGlzdGVuZXJzKSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKGV2ZW50LnN1YmplY3QgPSBzID0gc3ViamVjdC5hcHBseSh0aGF0LCBhcmdzKSkgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHggPSBzLnggLSBwWzBdIHx8IDA7XG4gICAgICBkeSA9IHMueSAtIHBbMV0gfHwgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pKSByZXR1cm47XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZ2VzdHVyZSh0eXBlKSB7XG4gICAgICB2YXIgcDAgPSBwLCBuO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOiBnZXN0dXJlc1tpZF0gPSBnZXN0dXJlLCBuID0gYWN0aXZlKys7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5kXCI6IGRlbGV0ZSBnZXN0dXJlc1tpZF0sIC0tYWN0aXZlOyAvLyBub2JyZWFrXG4gICAgICAgIGNhc2UgXCJkcmFnXCI6IHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgbiA9IGFjdGl2ZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIHR5cGUsIHMsIGlkLCBuLCBwWzBdICsgZHgsIHBbMV0gKyBkeSwgcFswXSAtIHAwWzBdLCBwWzFdIC0gcDBbMV0sIHN1Ymxpc3RlbmVycyksIHN1Ymxpc3RlbmVycy5hcHBseSwgc3VibGlzdGVuZXJzLCBbdHlwZSwgdGhhdCwgYXJnc10pO1xuICAgIH07XG4gIH1cblxuICBkcmFnLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogZmlsdGVyO1xuICB9O1xuXG4gIGRyYWcuY29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogY29udGFpbmVyO1xuICB9O1xuXG4gIGRyYWcuc3ViamVjdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdWJqZWN0ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBzdWJqZWN0O1xuICB9O1xuXG4gIGRyYWcudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgZHJhZy5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBkcmFnIDogdmFsdWU7XG4gIH07XG5cbiAgZHJhZy5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCBkcmFnKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIGRyYWc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnRXZlbnQodGFyZ2V0LCB0eXBlLCBzdWJqZWN0LCBpZCwgYWN0aXZlLCB4LCB5LCBkeCwgZHksIGRpc3BhdGNoKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICB0aGlzLmlkZW50aWZpZXIgPSBpZDtcbiAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZHggPSBkeDtcbiAgdGhpcy5keSA9IGR5O1xuICB0aGlzLl8gPSBkaXNwYXRjaDtcbn1cblxuRHJhZ0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcbn07XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgZHJhZ30gZnJvbSBcIi4vZHJhZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWdEaXNhYmxlLCB5ZXNkcmFnIGFzIGRyYWdFbmFibGV9IGZyb20gXCIuL25vZHJhZ1wiO1xuIiwiaW1wb3J0IHtzZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2V2ZW50IGZyb20gXCIuL25vZXZlbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHllc2RyYWcodmlldywgbm9jbGljaykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIGlmIChub2NsaWNrKSB7XG4gICAgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcbiAgfVxuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gcm9vdC5fX25vc2VsZWN0O1xuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XG4gIH1cbn1cbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJ2YXIgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3IsIGNjdyA9ICEhY2N3O1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi9jcmVhdG9yXCI7XG5pbXBvcnQgc2VsZWN0IGZyb20gXCIuL3NlbGVjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3QoY3JlYXRvcihuYW1lKS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2VcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdGV9IGZyb20gXCIuL2NyZWF0ZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0b3J9IGZyb20gXCIuL2NyZWF0b3JcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsb2NhbH0gZnJvbSBcIi4vbG9jYWxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtYXRjaGVyfSBmcm9tIFwiLi9tYXRjaGVyXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbW91c2V9IGZyb20gXCIuL21vdXNlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmFtZXNwYWNlfSBmcm9tIFwiLi9uYW1lc3BhY2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2VzfSBmcm9tIFwiLi9uYW1lc3BhY2VzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY2xpZW50UG9pbnR9IGZyb20gXCIuL3BvaW50XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0fSBmcm9tIFwiLi9zZWxlY3RcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RBbGx9IGZyb20gXCIuL3NlbGVjdEFsbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdGlvbn0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3J9IGZyb20gXCIuL3NlbGVjdG9yXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3JBbGx9IGZyb20gXCIuL3NlbGVjdG9yQWxsXCI7XG5leHBvcnQge3N0eWxlVmFsdWUgYXMgc3R5bGV9IGZyb20gXCIuL3NlbGVjdGlvbi9zdHlsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRvdWNofSBmcm9tIFwiLi90b3VjaFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRvdWNoZXN9IGZyb20gXCIuL3RvdWNoZXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB3aW5kb3d9IGZyb20gXCIuL3dpbmRvd1wiO1xuZXhwb3J0IHtldmVudCwgY3VzdG9tRXZlbnR9IGZyb20gXCIuL3NlbGVjdGlvbi9vblwiO1xuIiwidmFyIG5leHRJZCA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvY2FsKCkge1xuICByZXR1cm4gbmV3IExvY2FsO1xufVxuXG5mdW5jdGlvbiBMb2NhbCgpIHtcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcbn1cblxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTG9jYWwsXG4gIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICB3aGlsZSAoIShpZCBpbiBub2RlKSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gbm9kZVtpZF07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLl8gaW4gbm9kZSAmJiBkZWxldGUgbm9kZVt0aGlzLl9dO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudFwiO1xuaW1wb3J0IHBvaW50IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGV2ZW50ID0gc291cmNlRXZlbnQoKTtcbiAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSBldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICByZXR1cm4gcG9pbnQobm9kZSwgZXZlbnQpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSBcIi4vbmFtZXNwYWNlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lO1xufVxuIiwiZXhwb3J0IHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgZXZlbnQpIHtcbiAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG5cbiAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgfVxuXG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuLi9uYW1lc3BhY2VcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGUoZnVsbG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuIiwiZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUoZmFsc2UpLCB0aGlzLm5leHRTaWJsaW5nKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUodHJ1ZSksIHRoaXMubmV4dFNpYmxpbmcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnRcIjtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3dcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2VcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGxcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGFcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemVcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHlcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0clwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWRcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaFwiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvclwiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3RvclwiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgZW50ZXIgPSB0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiID8gb25lbnRlcihlbnRlcikgOiBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICBpZiAob251cGRhdGUgIT0gbnVsbCkgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaSA9IC0xO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwidmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG5leHBvcnQgdmFyIGV2ZW50ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50KSkge1xuICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApO1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzKSAmIDgpKSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQxKSB7XG4gICAgdmFyIGV2ZW50MCA9IGV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgIGV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXZlbnQ7XG4gIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICBldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXZlbnQgPSBldmVudDA7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuIiwiZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3JBbGwgZnJvbSBcIi4uL3NlbGVjdG9yQWxsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyArK3NpemU7IH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvd1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCIuL3NlbGVjdGlvbi9vblwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnQgPSBldmVudCwgc291cmNlO1xuICB3aGlsZSAoc291cmNlID0gY3VycmVudC5zb3VyY2VFdmVudCkgY3VycmVudCA9IHNvdXJjZTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnRcIjtcbmltcG9ydCBwb2ludCBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLmNoYW5nZWRUb3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIHRvdWNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudFwiO1xuaW1wb3J0IHBvaW50IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIHRvdWNoZXMpIHtcbiAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHBvaW50cyA9IG5ldyBBcnJheShuKTsgaSA8IG47ICsraSkge1xuICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYXJjfSBmcm9tIFwiLi9zcmMvYXJjXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXJlYX0gZnJvbSBcIi4vc3JjL2FyZWFcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsaW5lfSBmcm9tIFwiLi9zcmMvbGluZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZX0gZnJvbSBcIi4vc3JjL3BpZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhZGlhbEFyZWF9IGZyb20gXCIuL3NyYy9yYWRpYWxBcmVhXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFkaWFsTGluZX0gZnJvbSBcIi4vc3JjL3JhZGlhbExpbmVcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbCwgc3ltYm9sc30gZnJvbSBcIi4vc3JjL3N5bWJvbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbENpcmNsZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC9jaXJjbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xDcm9zc30gZnJvbSBcIi4vc3JjL3N5bWJvbC9jcm9zc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbERpYW1vbmR9IGZyb20gXCIuL3NyYy9zeW1ib2wvZGlhbW9uZFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFNxdWFyZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC9zcXVhcmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xTdGFyfSBmcm9tIFwiLi9zcmMvc3ltYm9sL3N0YXJcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xUcmlhbmdsZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC90cmlhbmdsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFd5ZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC93eWVcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXNDbG9zZWR9IGZyb20gXCIuL3NyYy9jdXJ2ZS9iYXNpc0Nsb3NlZFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXNPcGVufSBmcm9tIFwiLi9zcmMvY3VydmUvYmFzaXNPcGVuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCYXNpc30gZnJvbSBcIi4vc3JjL2N1cnZlL2Jhc2lzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCdW5kbGV9IGZyb20gXCIuL3NyYy9jdXJ2ZS9idW5kbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9zcmMvY3VydmUvY2FyZGluYWxDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsT3Blbn0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhcmRpbmFsT3BlblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2FyZGluYWx9IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXJkaW5hbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2F0bXVsbFJvbUNsb3NlZH0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb21PcGVufSBmcm9tIFwiLi9zcmMvY3VydmUvY2F0bXVsbFJvbU9wZW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb219IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVMaW5lYXJDbG9zZWR9IGZyb20gXCIuL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUxpbmVhcn0gZnJvbSBcIi4vc3JjL2N1cnZlL2xpbmVhclwiO1xuZXhwb3J0IHttb25vdG9uZVggYXMgY3VydmVNb25vdG9uZVgsIG1vbm90b25lWSBhcyBjdXJ2ZU1vbm90b25lWX0gZnJvbSBcIi4vc3JjL2N1cnZlL21vbm90b25lXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVOYXR1cmFsfSBmcm9tIFwiLi9zcmMvY3VydmUvbmF0dXJhbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlU3RlcCwgc3RlcEFmdGVyIGFzIGN1cnZlU3RlcEFmdGVyLCBzdGVwQmVmb3JlIGFzIGN1cnZlU3RlcEJlZm9yZX0gZnJvbSBcIi4vc3JjL2N1cnZlL3N0ZXBcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrfSBmcm9tIFwiLi9zcmMvc3RhY2tcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldEV4cGFuZH0gZnJvbSBcIi4vc3JjL29mZnNldC9leHBhbmRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldE5vbmV9IGZyb20gXCIuL3NyYy9vZmZzZXQvbm9uZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT2Zmc2V0U2lsaG91ZXR0ZX0gZnJvbSBcIi4vc3JjL29mZnNldC9zaWxob3VldHRlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXRXaWdnbGV9IGZyb20gXCIuL3NyYy9vZmZzZXQvd2lnZ2xlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlckFzY2VuZGluZ30gZnJvbSBcIi4vc3JjL29yZGVyL2FzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJEZXNjZW5kaW5nfSBmcm9tIFwiLi9zcmMvb3JkZXIvZGVzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJJbnNpZGVPdXR9IGZyb20gXCIuL3NyYy9vcmRlci9pbnNpZGVPdXRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyTm9uZX0gZnJvbSBcIi4vc3JjL29yZGVyL25vbmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyUmV2ZXJzZX0gZnJvbSBcIi4vc3JjL29yZGVyL3JldmVyc2VcIjtcbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IHtlcHNpbG9uLCBwaSwgaGFsZlBpLCB0YXV9IGZyb20gXCIuL21hdGhcIjtcblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gKHkzMiAqIHgxMCAtIHgzMiAqIHkxMCk7XG4gIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xufVxuXG4vLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtTGluZUludGVyc2VjdGlvbi5odG1sXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICB2YXIgeDAxID0geDAgLSB4MSxcbiAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIE1hdGguc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLFxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLFxuICAgICAgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxuICAgICAgZHgwID0gY3gwIC0geDAwLFxuICAgICAgZHkwID0gY3kwIC0geTAwLFxuICAgICAgZHgxID0gY3gxIC0geDAwLFxuICAgICAgZHkxID0gY3kxIC0geTAwO1xuXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcblxuICByZXR1cm4ge1xuICAgIGN4OiBjeDAsXG4gICAgY3k6IGN5MCxcbiAgICB4MDE6IC1veCxcbiAgICB5MDE6IC1veSxcbiAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcbiAgICB5MTE6IGN5MCAqIChyMSAvIHIgLSAxKVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gY29uc3RhbnQoMCksXG4gICAgICBwYWRSYWRpdXMgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGFyY0VuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IE1hdGguYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgIGVsc2UgaWYgKGRhID4gdGF1IC0gZXBzaWxvbikge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBNYXRoLmNvcyhhMCksIHIxICogTWF0aC5zaW4oYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogTWF0aC5jb3MoYTEpLCByMCAqIE1hdGguc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogTWF0aC5zcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBNYXRoLm1pbihNYXRoLmFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBNYXRoLnNpbihhcCkpLFxuICAgICAgICAgICAgcDEgPSBhc2luKHJwIC8gcjEgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbikgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICBlbHNlIGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MDEgPSByMSAqIE1hdGguY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBNYXRoLnNpbihhMDEpLFxuICAgICAgICAgIHgxMCA9IHIwICogTWF0aC5jb3MoYTEwKSxcbiAgICAgICAgICB5MTAgPSByMCAqIE1hdGguc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogTWF0aC5jb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogTWF0aC5zaW4oYTExKSxcbiAgICAgICAgICAgIHgwMCA9IHIwICogTWF0aC5jb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogTWF0aC5zaW4oYTAwKTtcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkpIHtcbiAgICAgICAgICB2YXIgb2MgPSBkYTAgPiBlcHNpbG9uID8gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSA6IFt4MTAsIHkxMF0sXG4gICAgICAgICAgICAgIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGJ4ID0geDExIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGtjID0gMSAvIE1hdGguc2luKE1hdGguYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgbGMgPSBNYXRoLnNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IE1hdGgubWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gTWF0aC5taW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBNYXRoLmF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIE1hdGguYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgTWF0aC5hdGFuMih0MS55MTEsIHQxLngxMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBNYXRoLmF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIE1hdGguYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBNYXRoLmF0YW4yKHQxLnkxMSwgdDEueDExKSwgTWF0aC5hdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgIHJldHVybiBbTWF0aC5jb3MoYSkgKiByLCBNYXRoLnNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB4MCA9IHBvaW50WCxcbiAgICAgIHgxID0gbnVsbCxcbiAgICAgIHkwID0gY29uc3RhbnQoMCksXG4gICAgICB5MSA9IHBvaW50WSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHtcbiAgICAgICAgICBqID0gaTtcbiAgICAgICAgICBvdXRwdXQuYXJlYVN0YXJ0KCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgweltrXSwgeTB6W2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQuYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIHtcbiAgICAgICAgeDB6W2ldID0gK3gwKGQsIGksIGRhdGEpLCB5MHpbaV0gPSAreTAoZCwgaSwgZGF0YSk7XG4gICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICByZXR1cm4gbGluZSgpLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpLmNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgxO1xuICB9O1xuXG4gIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTE7XG4gIH07XG5cbiAgYXJlYS5saW5lWDAgPVxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTApO1xuICB9O1xuXG4gIGFyZWEubGluZVkxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gIH07XG5cbiAgYXJlYS5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGFyZWEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBhcmVhLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJlYTtcbn1cbiIsImV4cG9ydCB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb25zdGFudCgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMyxcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyAyICogdGhhdC5feDEpIC8gMyxcbiAgICAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXG4gICAgKHRoYXQuX3kwICsgNCAqIHRoYXQuX3kxICsgeSkgLyA2XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpcy5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2Jhc2lzXCI7XG5cbmZ1bmN0aW9uIEJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MiA9IHgsIHRoaXMuX3kyID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5OyB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNDbG9zZWQoY29udGV4dCk7XG59XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59XG4iLCJpbXBvcnQge0Jhc2lzfSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGJldGEpIHtcblxuICBmdW5jdGlvbiBidW5kbGUoY29udGV4dCkge1xuICAgIHJldHVybiBiZXRhID09PSAxID8gbmV3IEJhc2lzKGNvbnRleHQpIDogbmV3IEJ1bmRsZShjb250ZXh0LCBiZXRhKTtcbiAgfVxuXG4gIGJ1bmRsZS5iZXRhID0gZnVuY3Rpb24oYmV0YSkge1xuICAgIHJldHVybiBjdXN0b20oK2JldGEpO1xuICB9O1xuXG4gIHJldHVybiBidW5kbGU7XG59KSgwLjg1KTtcbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhcmRpbmFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHtDYXJkaW5hbH0gZnJvbSBcIi4vY2FyZGluYWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdmFyIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgeDIgPSB0aGF0Ll94MixcbiAgICAgIHkyID0gdGhhdC5feTI7XG5cbiAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gIH1cblxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG59XG5cbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9jYXJkaW5hbENsb3NlZFwiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhdG11bGxSb21cIjtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsT3Blbn0gZnJvbSBcIi4vY2FyZGluYWxPcGVuXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcbiIsImZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcFwiO1xuXG5mdW5jdGlvbiBMaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZWxzZSB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyQ2xvc2VkKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBzbG9wZXMgb2YgdGhlIHRhbmdlbnRzIChIZXJtaXRlLXR5cGUgaW50ZXJwb2xhdGlvbikgYmFzZWQgb25cbi8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXG4vLyBJbnRlcnBvbGF0aW9uIGluIE9uZSBEaW1lbnNpb24uIEFzdHJvbm9teSBhbmQgQXN0cm9waHlzaWNzLCBWb2wuIDIzOSwgTk8uXG4vLyBOT1YoSUkpLCBQLiA0NDMsIDE5OTAuXG5mdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XG4gIHZhciBoMCA9IHRoYXQuX3gxIC0gdGhhdC5feDAsXG4gICAgICBoMSA9IHgyIC0gdGhhdC5feDEsXG4gICAgICBzMCA9ICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIChoMCB8fCBoMSA8IDAgJiYgLTApLFxuICAgICAgczEgPSAoeTIgLSB0aGF0Ll95MSkgLyAoaDEgfHwgaDAgPCAwICYmIC0wKSxcbiAgICAgIHAgPSAoczAgKiBoMSArIHMxICogaDApIC8gKGgwICsgaDEpO1xuICByZXR1cm4gKHNpZ24oczApICsgc2lnbihzMSkpICogTWF0aC5taW4oTWF0aC5hYnMoczApLCBNYXRoLmFicyhzMSksIDAuNSAqIE1hdGguYWJzKHApKSB8fCAwO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBvbmUtc2lkZWQgc2xvcGUuXG5mdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xuICB2YXIgaCA9IHRoYXQuX3gxIC0gdGhhdC5feDA7XG4gIHJldHVybiBoID8gKDMgKiAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyBoIC0gdCkgLyAyIDogdDtcbn1cblxuLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lI1JlcHJlc2VudGF0aW9uc1xuLy8gXCJ5b3UgY2FuIGV4cHJlc3MgY3ViaWMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGluIHRlcm1zIG9mIGN1YmljIELDqXppZXIgY3VydmVzXG4vLyB3aXRoIHJlc3BlY3QgdG8gdGhlIGZvdXIgdmFsdWVzIHAwLCBwMCArIG0wIC8gMywgcDEgLSBtMSAvIDMsIHAxXCIuXG5mdW5jdGlvbiBwb2ludCh0aGF0LCB0MCwgdDEpIHtcbiAgdmFyIHgwID0gdGhhdC5feDAsXG4gICAgICB5MCA9IHRoYXQuX3kwLFxuICAgICAgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICBkeCA9ICh4MSAtIHgwKSAvIDM7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk1vbm90b25lWC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9XG4gICAgdGhpcy5fdDAgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0MSA9IE5hTjtcblxuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBwb2ludCh0aGlzLCBzbG9wZTIodGhpcywgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpLCB0MSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICB0aGlzLl90MCA9IHQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWShjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBuZXcgUmVmbGVjdENvbnRleHQoY29udGV4dCk7XG59XG5cbihNb25vdG9uZVkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb25vdG9uZVgucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIE1vbm90b25lWC5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLCB5LCB4KTtcbn07XG5cbmZ1bmN0aW9uIFJlZmxlY3RDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubW92ZVRvKHksIHgpOyB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh5MSwgeDEsIHkyLCB4MiwgeSwgeCk7IH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbm90b25lWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVZKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gTmF0dXJhbChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5OYXR1cmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW107XG4gICAgdGhpcy5feSA9IFtdO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICBuID0geC5sZW5ndGg7XG5cbiAgICBpZiAobikge1xuICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHhbMF0sIHlbMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzFdLCB5WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBweCA9IGNvbnRyb2xQb2ludHMoeCksXG4gICAgICAgICAgICBweSA9IGNvbnRyb2xQb2ludHMoeSk7XG4gICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAxOyBpMSA8IG47ICsraTAsICsraTEpIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8ocHhbMF1baTBdLCBweVswXVtpMF0sIHB4WzFdW2kwXSwgcHlbMV1baTBdLCB4W2kxXSwgeVtpMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgbiA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgIHRoaXMuX3kucHVzaCgreSk7XG4gIH1cbn07XG5cbi8vIFNlZSBodHRwczovL3d3dy5wYXJ0aWNsZWluY2VsbC5jb20vMjAxMi9iZXppZXItc3BsaW5lcy8gZm9yIGRlcml2YXRpb24uXG5mdW5jdGlvbiBjb250cm9sUG9pbnRzKHgpIHtcbiAgdmFyIGksXG4gICAgICBuID0geC5sZW5ndGggLSAxLFxuICAgICAgbSxcbiAgICAgIGEgPSBuZXcgQXJyYXkobiksXG4gICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgciA9IG5ldyBBcnJheShuKTtcbiAgYVswXSA9IDAsIGJbMF0gPSAyLCByWzBdID0geFswXSArIDIgKiB4WzFdO1xuICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7ICsraSkgYVtpXSA9IDEsIGJbaV0gPSA0LCByW2ldID0gNCAqIHhbaV0gKyAyICogeFtpICsgMV07XG4gIGFbbiAtIDFdID0gMiwgYltuIC0gMV0gPSA3LCByW24gLSAxXSA9IDggKiB4W24gLSAxXSArIHhbbl07XG4gIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIG0gPSBhW2ldIC8gYltpIC0gMV0sIGJbaV0gLT0gbSwgcltpXSAtPSBtICogcltpIC0gMV07XG4gIGFbbiAtIDFdID0gcltuIC0gMV0gLyBiW24gLSAxXTtcbiAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSBhW2ldID0gKHJbaV0gLSBhW2kgKyAxXSkgLyBiW2ldO1xuICBiW24gLSAxXSA9ICh4W25dICsgYVtuIC0gMV0pIC8gMjtcbiAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyArK2kpIGJbaV0gPSAyICogeFtpICsgMV0gLSBhW2kgKyAxXTtcbiAgcmV0dXJuIFthLCBiXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IE5hdHVyYWwoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vbGluZWFyXCI7XG5cbmV4cG9ydCB2YXIgY3VydmVSYWRpYWxMaW5lYXIgPSBjdXJ2ZVJhZGlhbChjdXJ2ZUxpbmVhcik7XG5cbmZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xufVxuXG5SYWRpYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuXG4gIGZ1bmN0aW9uIHJhZGlhbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICB9XG5cbiAgcmFkaWFsLl9jdXJ2ZSA9IGN1cnZlO1xuXG4gIHJldHVybiByYWRpYWw7XG59XG4iLCJmdW5jdGlvbiBTdGVwKGNvbnRleHQsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX3QgPSB0O1xufVxuXG5TdGVwLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICgwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiB0aGlzLl9wb2ludCA9PT0gMikgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSk7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGlmICh0aGlzLl9saW5lID49IDApIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fdCA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHgxID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyB4ICogdGhpcy5fdDtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgdGhpcy5feSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94ID0geCwgdGhpcy5feSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDAuNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwQmVmb3JlKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEFmdGVyKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIHJldHVybiBkO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gcG9pbnRYLFxuICAgICAgeSA9IHBvaW50WSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIG91dHB1dC5wb2ludCgreChkLCBpLCBkYXRhKSwgK3koZCwgaSwgZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHg7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5O1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuIiwiZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciB0YXUgPSAyICogcGk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHt9XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIG4sIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aCwgeTsgaiA8IG07ICsraikge1xuICAgIGZvciAoeSA9IGkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIGlmICh5KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzZXJpZXNbaV1bal1bMV0gLz0geTtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMSkpIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDEsIHMwLCBzMSA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBzMCA9IHMxLCBzMSA9IHNlcmllc1tvcmRlcltpXV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIHMxW2pdWzFdICs9IHMxW2pdWzBdID0gaXNOYU4oczBbal1bMV0pID8gczBbal1bMF0gOiBzMFtqXVsxXTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaiA9IDAsIHMwID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMwLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCB5ID0gMDsgaSA8IG47ICsraSkgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcbiAgICBzMFtqXVsxXSArPSBzMFtqXVswXSA9IC15IC8gMjtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSB8fCAhKChtID0gKHMwID0gc2VyaWVzW29yZGVyWzBdXSkubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgczEgPSAwLCBzMiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBzaSA9IHNlcmllc1tvcmRlcltpXV0sXG4gICAgICAgICAgc2lqMCA9IHNpW2pdWzFdIHx8IDAsXG4gICAgICAgICAgc2lqMSA9IHNpW2ogLSAxXVsxXSB8fCAwLFxuICAgICAgICAgIHMzID0gKHNpajAgLSBzaWoxKSAvIDI7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7ICsraykge1xuICAgICAgICB2YXIgc2sgPSBzZXJpZXNbb3JkZXJba11dLFxuICAgICAgICAgICAgc2tqMCA9IHNrW2pdWzFdIHx8IDAsXG4gICAgICAgICAgICBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XG4gICAgICAgIHMzICs9IHNrajAgLSBza2oxO1xuICAgICAgfVxuICAgICAgczEgKz0gc2lqMCwgczIgKz0gczMgKiBzaWowO1xuICAgIH1cbiAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICBpZiAoczEpIHkgLT0gczIgLyBzMTtcbiAgfVxuICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBzdW1zID0gc2VyaWVzLm1hcChzdW0pO1xuICByZXR1cm4gbm9uZShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1thXSAtIHN1bXNbYl07IH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VtKHNlcmllcykge1xuICB2YXIgcyA9IDAsIGkgPSAtMSwgbiA9IHNlcmllcy5sZW5ndGgsIHY7XG4gIHdoaWxlICgrK2kgPCBuKSBpZiAodiA9ICtzZXJpZXNbaV1bMV0pIHMgKz0gdjtcbiAgcmV0dXJuIHM7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIGFzY2VuZGluZyhzZXJpZXMpLnJldmVyc2UoKTtcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcbmltcG9ydCB7c3VtfSBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgc3VtcyA9IHNlcmllcy5tYXAoc3VtKSxcbiAgICAgIG9yZGVyID0gbm9uZShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1tiXSAtIHN1bXNbYV07IH0pLFxuICAgICAgdG9wID0gMCxcbiAgICAgIGJvdHRvbSA9IDAsXG4gICAgICB0b3BzID0gW10sXG4gICAgICBib3R0b21zID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGogPSBvcmRlcltpXTtcbiAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgIHRvcHMucHVzaChqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICBib3R0b21zLnB1c2goaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvdHRvbXMucmV2ZXJzZSgpLmNvbmNhdCh0b3BzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkobik7XG4gIHdoaWxlICgtLW4gPj0gMCkgb1tuXSA9IG47XG4gIHJldHVybiBvO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIG5vbmUoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmdcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuaW1wb3J0IHt0YXV9IGZyb20gXCIuL21hdGhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsXG4gICAgICBzb3J0ID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSxcbiAgICAgIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSxcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQoMCk7XG5cbiAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBpbmRleCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYXJjcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYTAgPSArc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBkYSA9IE1hdGgubWluKHRhdSwgTWF0aC5tYXgoLXRhdSwgZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGEwKSksXG4gICAgICAgIGExLFxuICAgICAgICBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICB2O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh2ID0gYXJjc1tpbmRleFtpXSA9IGldID0gK3ZhbHVlKGRhdGFbaV0sIGksIGRhdGEpKSA+IDApIHtcbiAgICAgICAgc3VtICs9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWxseSBzb3J0IHRoZSBhcmNzIGJ5IHByZXZpb3VzbHktY29tcHV0ZWQgdmFsdWVzIG9yIGJ5IGRhdGEuXG4gICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0VmFsdWVzKGFyY3NbaV0sIGFyY3Nbal0pOyB9KTtcbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhcmNzISBUaGV5IGFyZSBzdG9yZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEncyBvcmRlci5cbiAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcbiAgICAgIGogPSBpbmRleFtpXSwgdiA9IGFyY3Nbal0sIGExID0gYTAgKyAodiA+IDAgPyB2ICogayA6IDApICsgcGEsIGFyY3Nbal0gPSB7XG4gICAgICAgIGRhdGE6IGRhdGFbal0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyY3M7XG4gIH1cblxuICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHZhbHVlO1xuICB9O1xuXG4gIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRWYWx1ZXMgPSBfLCBzb3J0ID0gbnVsbCwgcGllKSA6IHNvcnRWYWx1ZXM7XG4gIH07XG5cbiAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNvcnRWYWx1ZXMgPSBudWxsLCBwaWUpIDogc29ydDtcbiAgfTtcblxuICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBwYWRBbmdsZTtcbiAgfTtcblxuICByZXR1cm4gcGllO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWxcIjtcbmltcG9ydCBhcmVhIGZyb20gXCIuL2FyZWFcIjtcbmltcG9ydCB7cmFkaWFsTGluZX0gZnJvbSBcIi4vcmFkaWFsTGluZVwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgYSA9IGFyZWEoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhciksXG4gICAgICBjID0gYS5jdXJ2ZSxcbiAgICAgIHgwID0gYS5saW5lWDAsXG4gICAgICB4MSA9IGEubGluZVgxLFxuICAgICAgeTAgPSBhLmxpbmVZMCxcbiAgICAgIHkxID0gYS5saW5lWTE7XG5cbiAgYS5hbmdsZSA9IGEueCwgZGVsZXRlIGEueDtcbiAgYS5zdGFydEFuZ2xlID0gYS54MCwgZGVsZXRlIGEueDA7XG4gIGEuZW5kQW5nbGUgPSBhLngxLCBkZWxldGUgYS54MTtcbiAgYS5yYWRpdXMgPSBhLnksIGRlbGV0ZSBhLnk7XG4gIGEuaW5uZXJSYWRpdXMgPSBhLnkwLCBkZWxldGUgYS55MDtcbiAgYS5vdXRlclJhZGl1cyA9IGEueTEsIGRlbGV0ZSBhLnkxO1xuICBhLmxpbmVTdGFydEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHgwKCkpOyB9LCBkZWxldGUgYS5saW5lWDA7XG4gIGEubGluZUVuZEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHgxKCkpOyB9LCBkZWxldGUgYS5saW5lWDE7XG4gIGEubGluZUlubmVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHkwKCkpOyB9LCBkZWxldGUgYS5saW5lWTA7XG4gIGEubGluZU91dGVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHkxKCkpOyB9LCBkZWxldGUgYS5saW5lWTE7XG5cbiAgYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gYTtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWxcIjtcbmltcG9ydCBsaW5lIGZyb20gXCIuL2xpbmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbExpbmUobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiByYWRpYWxMaW5lKGxpbmUoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhcikpO1xufVxuIiwiaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IG9mZnNldE5vbmUgZnJvbSBcIi4vb2Zmc2V0L25vbmVcIjtcbmltcG9ydCBvcmRlck5vbmUgZnJvbSBcIi4vb3JkZXIvbm9uZVwiO1xuXG5mdW5jdGlvbiBzdGFja1ZhbHVlKGQsIGtleSkge1xuICByZXR1cm4gZFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBjb25zdGFudChbXSksXG4gICAgICBvcmRlciA9IG9yZGVyTm9uZSxcbiAgICAgIG9mZnNldCA9IG9mZnNldE5vbmUsXG4gICAgICB2YWx1ZSA9IHN0YWNrVmFsdWU7XG5cbiAgZnVuY3Rpb24gc3RhY2soZGF0YSkge1xuICAgIHZhciBreiA9IGtleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgaSxcbiAgICAgICAgbSA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBuID0ga3oubGVuZ3RoLFxuICAgICAgICBzeiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgb3o7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmb3IgKHZhciBraSA9IGt6W2ldLCBzaSA9IHN6W2ldID0gbmV3IEFycmF5KG0pLCBqID0gMCwgc2lqOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHNpW2pdID0gc2lqID0gWzAsICt2YWx1ZShkYXRhW2pdLCBraSwgaiwgZGF0YSldO1xuICAgICAgICBzaWouZGF0YSA9IGRhdGFbal07XG4gICAgICB9XG4gICAgICBzaS5rZXkgPSBraTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBveiA9IG9yZGVyKHN6KTsgaSA8IG47ICsraSkge1xuICAgICAgc3pbb3pbaV1dLmluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBvZmZzZXQoc3osIG96KTtcbiAgICByZXR1cm4gc3o7XG4gIH1cblxuICBzdGFjay5rZXlzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGtleXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBrZXlzO1xuICB9O1xuXG4gIHN0YWNrLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN0YWNrKSA6IHZhbHVlO1xuICB9O1xuXG4gIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gXyA9PSBudWxsID8gb3JkZXJOb25lIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDogb3JkZXI7XG4gIH07XG5cbiAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG9mZnNldE5vbmUgOiBfLCBzdGFjaykgOiBvZmZzZXQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNpcmNsZSBmcm9tIFwiLi9zeW1ib2wvY2lyY2xlXCI7XG5pbXBvcnQgY3Jvc3MgZnJvbSBcIi4vc3ltYm9sL2Nyb3NzXCI7XG5pbXBvcnQgZGlhbW9uZCBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZFwiO1xuaW1wb3J0IHN0YXIgZnJvbSBcIi4vc3ltYm9sL3N0YXJcIjtcbmltcG9ydCBzcXVhcmUgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZVwiO1xuaW1wb3J0IHRyaWFuZ2xlIGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZVwiO1xuaW1wb3J0IHd5ZSBmcm9tIFwiLi9zeW1ib2wvd3llXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcblxuZXhwb3J0IHZhciBzeW1ib2xzID0gW1xuICBjaXJjbGUsXG4gIGNyb3NzLFxuICBkaWFtb25kLFxuICBzcXVhcmUsXG4gIHN0YXIsXG4gIHRyaWFuZ2xlLFxuICB3eWVcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGNvbnN0YW50KGNpcmNsZSksXG4gICAgICBzaXplID0gY29uc3RhbnQoNjQpLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuICAgIHR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS5kcmF3KGNvbnRleHQsICtzaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHlwZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHN5bWJvbCkgOiB0eXBlO1xuICB9O1xuXG4gIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNpemUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3ltYm9sKSA6IHNpemU7XG4gIH07XG5cbiAgc3ltYm9sLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gc3ltYm9sO1xufVxuIiwiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyksXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLFxuICAgICAgICB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB3ID0gTWF0aC5zcXJ0KHNpemUpLFxuICAgICAgICB4ID0gLXcgLyAyO1xuICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgfVxufTtcbiIsImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGhcIjtcblxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcbiAgICBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLFxuICAgIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsXG4gICAga3kgPSAtTWF0aC5jb3ModGF1IC8gMTApICoga3I7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCB5ICogMik7XG4gICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgYyA9IC0wLjUsXG4gICAgcyA9IE1hdGguc3FydCgzKSAvIDIsXG4gICAgayA9IDEgLyBNYXRoLnNxcnQoMTIpLFxuICAgIGEgPSAoayAvIDIgKyAxKSAqIDM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBhKSxcbiAgICAgICAgeDAgPSByIC8gMixcbiAgICAgICAgeTAgPSByICogayxcbiAgICAgICAgeDEgPSB4MCxcbiAgICAgICAgeTEgPSByICogayArIHIsXG4gICAgICAgIHgyID0gLXgxLFxuICAgICAgICB5MiA9IHkxO1xuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMgKiB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgKyBzICogeTEsIGMgKiB5MSAtIHMgKiB4MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge1RpbWVyfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XG4gIHQucmVzdGFydChlbGFwc2VkID0+IHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwidmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbCh1bmRlZmluZWQsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtTQ0hFRFVMRUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBpO1xuXG4gIGlmIChzY2hlZHVsZXMpIHtcbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLnN0YXRlID4gU0NIRURVTEVEICYmIHNjaGVkdWxlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKFtbbm9kZV1dLCByb290LCBuYW1lLCAraSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhY3RpdmV9IGZyb20gXCIuL2FjdGl2ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycnVwdH0gZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG4iLCJpbXBvcnQge1NUQVJUSU5HLCBFTkRJTkcsIEVOREVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbXB0eSA9IHRydWUsXG4gICAgICBpO1xuXG4gIGlmICghc2NoZWR1bGVzKSByZXR1cm47XG5cbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcgJiYgc2NoZWR1bGUuc3RhdGUgPCBFTkRJTkc7XG4gICAgc2NoZWR1bGUuc3RhdGUgPSBFTkRFRDtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgc2NoZWR1bGUub24uY2FsbChhY3RpdmUgPyBcImludGVycnVwdFwiIDogXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2NoZWR1bGUuaW5kZXgsIHNjaGVkdWxlLmdyb3VwKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICB9XG5cbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnRlcnJ1cHQgZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuXG5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XG5zZWxlY3Rpb24ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBzZWxlY3Rpb25fdHJhbnNpdGlvbjtcbiIsImltcG9ydCBpbnRlcnJ1cHQgZnJvbSBcIi4uL2ludGVycnVwdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJydXB0KHRoaXMsIG5hbWUpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUgZnJvbSBcIi4uL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7ZWFzZUN1YmljSW5PdXR9IGZyb20gXCJkMy1lYXNlXCI7XG5pbXBvcnQge25vd30gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBkZWZhdWx0VGltaW5nID0ge1xuICB0aW1lOiBudWxsLCAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogZWFzZUN1YmljSW5PdXRcbn07XG5cbmZ1bmN0aW9uIGluaGVyaXQobm9kZSwgaWQpIHtcbiAgdmFyIHRpbWluZztcbiAgd2hpbGUgKCEodGltaW5nID0gbm9kZS5fX3RyYW5zaXRpb24pIHx8ICEodGltaW5nID0gdGltaW5nW2lkXSkpIHtcbiAgICBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2l0aW9uICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGltaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBpZCxcbiAgICAgIHRpbWluZztcblxuICBpZiAobmFtZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICBpZCA9IG5hbWUuX2lkLCBuYW1lID0gbmFtZS5fbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IG5ld0lkKCksICh0aW1pbmcgPSBkZWZhdWx0VGltaW5nKS50aW1lID0gbm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSksIGkgPSBmdWxsbmFtZSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KShmdWxsbmFtZSwgaSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge2dldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZGVsYXlGdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGF5Q29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZGVsYXk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkdXJhdGlvbkZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZHVyYXRpb25GdW5jdGlvblxuICAgICAgICAgIDogZHVyYXRpb25Db25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZHVyYXRpb247XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaChlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlVmFyeWluZyhpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy5lYWNoKGVhc2VWYXJ5aW5nKHRoaXMuX2lkLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgb24wLCBvbjEsIHRoYXQgPSB0aGlzLCBpZCA9IHRoYXQuX2lkLCBzaXplID0gdGhhdC5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgY2FuY2VsID0ge3ZhbHVlOiByZWplY3R9LFxuICAgICAgICBlbmQgPSB7dmFsdWU6IGZ1bmN0aW9uKCkgeyBpZiAoLS1zaXplID09PSAwKSByZXNvbHZlKCk7IH19O1xuXG4gICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgICAgaWYgKG9uICE9PSBvbjApIHtcbiAgICAgICAgb24xID0gKG9uMCA9IG9uKS5jb3B5KCk7XG4gICAgICAgIG9uMS5fLmNhbmNlbC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmludGVycnVwdC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmVuZC5wdXNoKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHNlbGVjdGlvbiB3YXMgZW1wdHksIHJlc29sdmUgZW5kIGltbWVkaWF0ZWx5XG4gICAgaWYgKHNpemUgPT09IDApIHJlc29sdmUoKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge21hdGNoZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHJUd2VlbiBmcm9tIFwiLi9hdHRyVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2RlbGF5IGZyb20gXCIuL2RlbGF5LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZSBmcm9tIFwiLi9lYXNlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlVmFyeWluZyBmcm9tIFwiLi9lYXNlVmFyeWluZy5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3Rpb24gZnJvbSBcIi4vc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGVUd2VlbiBmcm9tIFwiLi9zdHlsZVR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHRUd2VlbiBmcm9tIFwiLi90ZXh0VHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHdlZW4gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2VuZCBmcm9tIFwiLi9lbmQuanNcIjtcblxudmFyIGlkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zaXRpb24oZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCkge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3Rpb24oKS50cmFuc2l0aW9uKG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3SWQoKSB7XG4gIHJldHVybiArK2lkO1xufVxuXG52YXIgc2VsZWN0aW9uX3Byb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGU7XG5cblRyYW5zaXRpb24ucHJvdG90eXBlID0gdHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICBzZWxlY3Q6IHRyYW5zaXRpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHRyYW5zaXRpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogdHJhbnNpdGlvbl9maWx0ZXIsXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHRyYW5zaXRpb25fc2VsZWN0aW9uLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uX3RyYW5zaXRpb24sXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX3Byb3RvdHlwZS5lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX3Byb3RvdHlwZS5lYWNoLFxuICBvbjogdHJhbnNpdGlvbl9vbixcbiAgYXR0cjogdHJhbnNpdGlvbl9hdHRyLFxuICBhdHRyVHdlZW46IHRyYW5zaXRpb25fYXR0clR3ZWVuLFxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcbiAgc3R5bGVUd2VlbjogdHJhbnNpdGlvbl9zdHlsZVR3ZWVuLFxuICB0ZXh0OiB0cmFuc2l0aW9uX3RleHQsXG4gIHRleHRUd2VlbjogdHJhbnNpdGlvbl90ZXh0VHdlZW4sXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXG4gIHR3ZWVuOiB0cmFuc2l0aW9uX3R3ZWVuLFxuICBkZWxheTogdHJhbnNpdGlvbl9kZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXG4gIGVhc2U6IHRyYW5zaXRpb25fZWFzZSxcbiAgZWFzZVZhcnlpbmc6IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcsXG4gIGVuZDogdHJhbnNpdGlvbl9lbmQsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25fcHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl1cbn07XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUmdiLCBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGM7XG4gIHJldHVybiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIgPyBpbnRlcnBvbGF0ZU51bWJlclxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyBpbnRlcnBvbGF0ZVJnYlxuICAgICAgOiAoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gc3RhcnQobmFtZSkge1xuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsIG9uMSwgc2l0ID0gc3RhcnQobmFtZSkgPyBpbml0IDogc2V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2l0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCkgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihuYW1lLCBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyXG4gICAgICA/IGdldCh0aGlzLm5vZGUoKSwgaWQpLm9uLm9uKG5hbWUpXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyLCB0aW1lb3V0fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGVtcHR5T24gPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2FuY2VsXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxuZXhwb3J0IHZhciBDUkVBVEVEID0gMDtcbmV4cG9ydCB2YXIgU0NIRURVTEVEID0gMTtcbmV4cG9ydCB2YXIgU1RBUlRJTkcgPSAyO1xuZXhwb3J0IHZhciBTVEFSVEVEID0gMztcbmV4cG9ydCB2YXIgUlVOTklORyA9IDQ7XG5leHBvcnQgdmFyIEVORElORyA9IDU7XG5leHBvcnQgdmFyIEVOREVEID0gNjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSwgaWQsIGluZGV4LCBncm91cCwgdGltaW5nKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZXMpIG5vZGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKGlkIGluIHNjaGVkdWxlcykgcmV0dXJuO1xuICBjcmVhdGUobm9kZSwgaWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBlbXB0eU9uLFxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxuICAgIHRpbWU6IHRpbWluZy50aW1lLFxuICAgIGRlbGF5OiB0aW1pbmcuZGVsYXksXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcbiAgICBlYXNlOiB0aW1pbmcuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogQ1JFQVRFRFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gQ1JFQVRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgc2NoZWR1bGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gU1RBUlRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgcnVubmluZ1wiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgaWQsIHNlbGYpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgdHdlZW47XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuICBzY2hlZHVsZXNbaWRdID0gc2VsZjtcbiAgc2VsZi50aW1lciA9IHRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcblxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChzZWxmLmRlbGF5IDw9IGVsYXBzZWQpIHN0YXJ0KGVsYXBzZWQgLSBzZWxmLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICB2YXIgaSwgaiwgbiwgbztcblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgbyA9IHNjaGVkdWxlc1tpXTtcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XG5cbiAgICAgIC8vIFdoaWxlIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHN0YXJ0aW5nIHRyYW5zaXRpb24gZHVyaW5nIHRoaXMgZnJhbWUsXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcbiAgICAgIC8vIGNoYW5jZSB0byB0aWNrIChhbmQgcG9zc2libHkgZW5kKTsgc2VlIGQzL2QzLXRyYW5zaXRpb24jNTQhXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIHRpbWVvdXQoc3RhcnQpO1xuXG4gICAgICAvLyBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBhbnkgcHJlLWVtcHRlZCB0cmFuc2l0aW9ucy5cbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXG4gICAgLy8gTm90ZSB0aGUgdHJhbnNpdGlvbiBtYXkgYmUgY2FuY2VsZWQgYWZ0ZXIgc3RhcnQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdGljayFcbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBzY2hlZHVsZWQgYmVmb3JlIHRoZSBzdGFydCBldmVudDsgc2VlIGQzL2QzLXRyYW5zaXRpb24jMTYhXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxuICAgIHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gUlVOTklORztcbiAgICAgICAgc2VsZi50aW1lci5yZXN0YXJ0KHRpY2ssIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG4gICAgICAgIHRpY2soZWxhcHNlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgc3RhcnQgZXZlbnQuXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIHR3ZWVuIGFyZSBpbml0aWFsaXplZC5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0d2VlbiwgZGVsZXRpbmcgbnVsbCB0d2Vlbi5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGogPSAtMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG8gPSBzZWxmLnR3ZWVuW2ldLnZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCkpIHtcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgdmFyIHQgPSBlbGFwc2VkIDwgc2VsZi5kdXJhdGlvbiA/IHNlbGYuZWFzZS5jYWxsKG51bGwsIGVsYXBzZWQgLyBzZWxmLmR1cmF0aW9uKSA6IChzZWxmLnRpbWVyLnJlc3RhcnQoc3RvcCksIHNlbGYuc3RhdGUgPSBFTkRJTkcsIDEpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgdHdlZW5baV0uY2FsbChub2RlLCB0KTtcbiAgICB9XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuICAgIGlmIChzZWxmLnN0YXRlID09PSBFTkRJTkcpIHtcbiAgICAgIHNlbGYub24uY2FsbChcImVuZFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHNlbGYuc3RhdGUgPSBFTkRFRDtcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgICBzY2hlZHVsZShzdWJncm91cFtpXSwgbmFtZSwgaWQsIGksIHN1Ymdyb3VwLCBnZXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yQWxsfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCksIGNoaWxkLCBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkKSwgayA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGsgPCBsOyArK2spIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPSBjaGlsZHJlbltrXSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoY2hpbGQsIG5hbWUsIGlkLCBrLCBjaGlsZHJlbiwgaW5oZXJpdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbnZhciBTZWxlY3Rpb24gPSBzZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzdHlsZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVOdWxsKG5hbWUsIGludGVycG9sYXRlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgc3RyaW5nMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHN0cmluZzEwID0gc3RyaW5nMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgdmFsdWUxID0gdmFsdWUodGhpcyksXG4gICAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgc3RyaW5nMSA9IHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZU1heWJlUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciBvbjAsIG9uMSwgbGlzdGVuZXIwLCBrZXkgPSBcInN0eWxlLlwiICsgbmFtZSwgZXZlbnQgPSBcImVuZC5cIiArIGtleSwgcmVtb3ZlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbixcbiAgICAgICAgbGlzdGVuZXIgPSBzY2hlZHVsZS52YWx1ZVtrZXldID09IG51bGwgPyByZW1vdmUgfHwgKHJlbW92ZSA9IHN0eWxlUmVtb3ZlKG5hbWUpKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCB8fCBsaXN0ZW5lcjAgIT09IGxpc3RlbmVyKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKGV2ZW50LCBsaXN0ZW5lcjAgPSBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBpID0gKG5hbWUgKz0gXCJcIikgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlTnVsbChuYW1lLCBpKSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIHN0eWxlUmVtb3ZlKG5hbWUpKVxuICAgIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUZ1bmN0aW9uKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSkpXG4gICAgICAuZWFjaChzdHlsZU1heWJlUmVtb3ZlKHRoaXMuX2lkLCBuYW1lKSlcbiAgICA6IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUpLCBwcmlvcml0eSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIG51bGwpO1xufVxuIiwiZnVuY3Rpb24gc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaS5jYWxsKHRoaXMsIHQpLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciB0LCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdCA9IChpMCA9IGkpICYmIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIga2V5ID0gXCJzdHlsZS5cIiArIChuYW1lICs9IFwiXCIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpO1xufVxuIiwiaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlMSA9PSBudWxsID8gXCJcIiA6IHZhbHVlMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IHRleHRGdW5jdGlvbih0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufVxuIiwiZnVuY3Rpb24gdGV4dEludGVycG9sYXRlKGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gaS5jYWxsKHRoaXMsIHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0VHdlZW4odmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiB0ZXh0SW50ZXJwb2xhdGUoaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcInRleHRcIjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHRleHRUd2Vlbih2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxuICAgICAgaWQxID0gbmV3SWQoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldChub2RlLCBpZDApO1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZDEsIGksIGdyb3VwLCB7XG4gICAgICAgICAgdGltZTogaW5oZXJpdC50aW1lICsgaW5oZXJpdC5kZWxheSArIGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiB0d2VlblJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gdHdlZW4wID0gdHdlZW47XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xID0gdHdlZW4xLnNsaWNlKCk7XG4gICAgICAgICAgdHdlZW4xLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0d2VlbkZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9ICh0d2VlbjAgPSB0d2Vlbikuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIHQgPSB7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSwgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMVtpXSA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBuKSB0d2VlbjEucHVzaCh0KTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgbmFtZSArPSBcIlwiO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciB0d2VlbiA9IGdldCh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4ubGVuZ3RoLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHQgPSB0d2VlbltpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gdHdlZW5SZW1vdmUgOiB0d2VlbkZ1bmN0aW9uKShpZCwgbmFtZSwgdmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG5cbiAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlLnZhbHVlIHx8IChzY2hlZHVsZS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBnZXQobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9vbUV2ZW50KHR5cGUsIHtcbiAgc291cmNlRXZlbnQsXG4gIHRhcmdldCxcbiAgdHJhbnNmb3JtLFxuICBkaXNwYXRjaFxufSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHlwZToge3ZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHNvdXJjZUV2ZW50OiB7dmFsdWU6IHNvdXJjZUV2ZW50LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRhcmdldDoge3ZhbHVlOiB0YXJnZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdHJhbnNmb3JtOiB7dmFsdWU6IHRyYW5zZm9ybSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBfOiB7dmFsdWU6IGRpc3BhdGNofVxuICB9KTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgem9vbVRyYW5zZm9ybSwgaWRlbnRpdHkgYXMgem9vbUlkZW50aXR5LCBUcmFuc2Zvcm0gYXMgWm9vbVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKGssIHgsIHkpIHtcbiAgdGhpcy5rID0gaztcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuayAqIGssIHRoaXMueCwgdGhpcy55KTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IDAgJiB5ID09PSAwID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB4LCB0aGlzLnkgKyB0aGlzLmsgKiB5KTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludFswXSAqIHRoaXMuayArIHRoaXMueCwgcG9pbnRbMV0gKiB0aGlzLmsgKyB0aGlzLnldO1xuICB9LFxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCAqIHRoaXMuayArIHRoaXMueDtcbiAgfSxcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLmsgKyB0aGlzLnk7XG4gIH0sXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gWyhsb2NhdGlvblswXSAtIHRoaXMueCkgLyB0aGlzLmssIChsb2NhdGlvblsxXSAtIHRoaXMueSkgLyB0aGlzLmtdO1xuICB9LFxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4IC0gdGhpcy54KSAvIHRoaXMuaztcbiAgfSxcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoeSAtIHRoaXMueSkgLyB0aGlzLms7XG4gIH0sXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguY29weSgpLmRvbWFpbih4LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCwgdGhpcykubWFwKHguaW52ZXJ0LCB4KSk7XG4gIH0sXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkuY29weSgpLmRvbWFpbih5LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WSwgdGhpcykubWFwKHkuaW52ZXJ0LCB5KSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtkcmFnRGlzYWJsZSwgZHJhZ0VuYWJsZX0gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVab29tfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c2VsZWN0LCBwb2ludGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2ludGVycnVwdH0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IFpvb21FdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuaW1wb3J0IHtUcmFuc2Zvcm0sIGlkZW50aXR5fSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbi8vIGV4Y2VwdCBmb3IgcGluY2gtdG8tem9vbSwgd2hpY2ggaXMgc2VudCBhcyBhIHdoZWVsK2N0cmxLZXkgZXZlbnRcbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoZXZlbnQpIHtcbiAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBldmVudC50eXBlID09PSAnd2hlZWwnKSAmJiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXh0ZW50KCkge1xuICB2YXIgZSA9IHRoaXM7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIGlmIChlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICAgIGUgPSBlLnZpZXdCb3guYmFzZVZhbDtcbiAgICAgIHJldHVybiBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV07XG4gICAgfVxuICAgIHJldHVybiBbWzAsIDBdLCBbZS53aWR0aC5iYXNlVmFsLnZhbHVlLCBlLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtlLmNsaWVudFdpZHRoLCBlLmNsaWVudEhlaWdodF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKGV2ZW50KSB7XG4gIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogKGV2ZW50LmN0cmxLZXkgPyAxMCA6IDEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29uc3RyYWluKHRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpIHtcbiAgdmFyIGR4MCA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFswXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMF0sXG4gICAgICBkeDEgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMV1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzBdLFxuICAgICAgZHkwID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzBdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVsxXSxcbiAgICAgIGR5MSA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFsxXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMV07XG4gIHJldHVybiB0cmFuc2Zvcm0udHJhbnNsYXRlKFxuICAgIGR4MSA+IGR4MCA/IChkeDAgKyBkeDEpIC8gMiA6IE1hdGgubWluKDAsIGR4MCkgfHwgTWF0aC5tYXgoMCwgZHgxKSxcbiAgICBkeTEgPiBkeTAgPyAoZHkwICsgZHkxKSAvIDIgOiBNYXRoLm1pbigwLCBkeTApIHx8IE1hdGgubWF4KDAsIGR5MSlcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGNvbnN0cmFpbiA9IGRlZmF1bHRDb25zdHJhaW4sXG4gICAgICB3aGVlbERlbHRhID0gZGVmYXVsdFdoZWVsRGVsdGEsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgc2NhbGVFeHRlbnQgPSBbMCwgSW5maW5pdHldLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVpvb20sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSxcbiAgICAgIHRvdWNoc3RhcnRpbmcsXG4gICAgICB0b3VjaGZpcnN0LFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMCxcbiAgICAgIHRhcERpc3RhbmNlID0gMTA7XG5cbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZCwge3Bhc3NpdmU6IGZhbHNlfSlcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vkb3duZWQpXG4gICAgICAgIC5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuem9vbVwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcbiAgICBzZWxlY3Rpb24ucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSk7XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW50ZXJydXB0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgLmV2ZW50KGV2ZW50KVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLnpvb20obnVsbCwgdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0cmFuc2Zvcm0pXG4gICAgICAgICAgLmVuZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHpvb20uc2NhbGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHAsXG4gICAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBudWxsLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbihpZGVudGl0eS50cmFuc2xhdGUocDBbMF0sIHAwWzFdKS5zY2FsZSh0LmspLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IC15LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteVxuICAgICAgKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCBrKSB7XG4gICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgaykpO1xuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xuICAgIHZhciB4ID0gcDBbMF0gLSBwMVswXSAqIHRyYW5zZm9ybS5rLCB5ID0gcDBbMV0gLSBwMVsxXSAqIHRyYW5zZm9ybS5rO1xuICAgIHJldHVybiB4ID09PSB0cmFuc2Zvcm0ueCAmJiB5ID09PSB0cmFuc2Zvcm0ueSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtLmssIHgsIHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB0cmFuc2l0aW9uXG4gICAgICAgIC5vbihcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuZW5kKCk7IH0pXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgICAgICAgIGUgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyksXG4gICAgICAgICAgICAgIHAgPSBwb2ludCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcG9pbnQgPT09IFwiZnVuY3Rpb25cIiA/IHBvaW50LmFwcGx5KHRoYXQsIGFyZ3MpIDogcG9pbnQsXG4gICAgICAgICAgICAgIHcgPSBNYXRoLm1heChlWzFdWzBdIC0gZVswXVswXSwgZVsxXVsxXSAtIGVbMF1bMV0pLFxuICAgICAgICAgICAgICBhID0gdGhhdC5fX3pvb20sXG4gICAgICAgICAgICAgIGIgPSB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhhdCwgYXJncykgOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGkgPSBpbnRlcnBvbGF0ZShhLmludmVydChwKS5jb25jYXQodyAvIGEuayksIGIuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYi5rKSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0ID0gYjsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3Igb24gZW5kLlxuICAgICAgICAgICAgZWxzZSB7IHZhciBsID0gaSh0KSwgayA9IHcgLyBsWzJdOyB0ID0gbmV3IFRyYW5zZm9ybShrLCBwWzBdIC0gbFswXSAqIGssIHBbMV0gLSBsWzFdICogayk7IH1cbiAgICAgICAgICAgIGcuem9vbShudWxsLCB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlc3R1cmUodGhhdCwgYXJncywgY2xlYW4pIHtcbiAgICByZXR1cm4gKCFjbGVhbiAmJiB0aGF0Ll9fem9vbWluZykgfHwgbmV3IEdlc3R1cmUodGhhdCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBHZXN0dXJlKHRoYXQsIGFyZ3MpIHtcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIHRoaXMuc291cmNlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIHRoaXMudGFwcyA9IDA7XG4gIH1cblxuICBHZXN0dXJlLnByb3RvdHlwZSA9IHtcbiAgICBldmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkgdGhpcy5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkge1xuICAgICAgICB0aGlzLnRoYXQuX196b29taW5nID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhcnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uKGtleSwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodGhpcy5tb3VzZSAmJiBrZXkgIT09IFwibW91c2VcIikgdGhpcy5tb3VzZVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy5tb3VzZVswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDAgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gwWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMFswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDEgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gxWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMVswXSk7XG4gICAgICB0aGlzLnRoYXQuX196b29tID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5lbWl0KFwiem9vbVwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRoYXQuX196b29taW5nO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBkID0gc2VsZWN0KHRoaXMudGhhdCkuZGF0dW0oKTtcbiAgICAgIGxpc3RlbmVycy5jYWxsKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLnRoYXQsXG4gICAgICAgIG5ldyBab29tRXZlbnQodHlwZSwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiB0aGlzLnNvdXJjZUV2ZW50LFxuICAgICAgICAgIHRhcmdldDogem9vbSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy50aGF0Ll9fem9vbSxcbiAgICAgICAgICBkaXNwYXRjaDogbGlzdGVuZXJzXG4gICAgICAgIH0pLFxuICAgICAgICBkXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgdC5rICogTWF0aC5wb3coMiwgd2hlZWxEZWx0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCk7XG5cbiAgICAvLyBJZiB0aGUgbW91c2UgaXMgaW4gdGhlIHNhbWUgbG9jYXRpb24gYXMgYmVmb3JlLCByZXVzZSBpdC5cbiAgICAvLyBJZiB0aGVyZSB3ZXJlIHJlY2VudCB3aGVlbCBldmVudHMsIHJlc2V0IHRoZSB3aGVlbCBpZGxlIHRpbWVvdXQuXG4gICAgaWYgKGcud2hlZWwpIHtcbiAgICAgIGlmIChnLm1vdXNlWzBdWzBdICE9PSBwWzBdIHx8IGcubW91c2VbMF1bMV0gIT09IHBbMV0pIHtcbiAgICAgICAgZy5tb3VzZVsxXSA9IHQuaW52ZXJ0KGcubW91c2VbMF0gPSBwKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChnLndoZWVsKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHdoZWVsIGV2ZW50IHdvbuKAmXQgdHJpZ2dlciBhIHRyYW5zZm9ybSBjaGFuZ2UsIGlnbm9yZSBpdC5cbiAgICBlbHNlIGlmICh0LmsgPT09IGspIHJldHVybjtcblxuICAgIC8vIE90aGVyd2lzZSwgY2FwdHVyZSB0aGUgbW91c2UgcG9pbnQgYW5kIGxvY2F0aW9uIGF0IHRoZSBzdGFydC5cbiAgICBlbHNlIHtcbiAgICAgIGcubW91c2UgPSBbcCwgdC5pbnZlcnQocCldO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgdHJ1ZSkuZXZlbnQoZXZlbnQpLFxuICAgICAgICB2ID0gc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLnpvb21cIiwgbW91c2V1cHBlZCwgdHJ1ZSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgeDAgPSBldmVudC5jbGllbnRYLFxuICAgICAgICB5MCA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICBkcmFnRGlzYWJsZShldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBnLm1vdXNlID0gW3AsIHRoaXMuX196b29tLmludmVydChwKV07XG4gICAgaW50ZXJydXB0KHRoaXMpO1xuICAgIGcuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZWQoZXZlbnQpIHtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKCFnLm1vdmVkKSB7XG4gICAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSB4MCwgZHkgPSBldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy5ldmVudChldmVudClcbiAgICAgICAuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXBwZWQoZXZlbnQpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkcmFnRW5hYmxlKGV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBnLmV2ZW50KGV2ZW50KS5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICBwMCA9IHBvaW50ZXIoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50LCB0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmdzKSwgdHJhbnNsYXRlRXh0ZW50KTtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCwgZXZlbnQpO1xuICAgIGVsc2Ugc2VsZWN0KHRoaXMpLmNhbGwoem9vbS50cmFuc2Zvcm0sIHQxLCBwMCwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgc3RhcnRlZCwgaSwgdCwgcDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaGZpcnN0ID0gcFswXSwgdG91Y2hzdGFydGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoc3RhcnRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0LCBwLCBsO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gwWzBdID0gcDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gxWzBdID0gcDtcbiAgICB9XG4gICAgdCA9IGcudGhhdC5fX3pvb207XG4gICAgaWYgKGcudG91Y2gxKSB7XG4gICAgICB2YXIgcDAgPSBnLnRvdWNoMFswXSwgbDAgPSBnLnRvdWNoMFsxXSxcbiAgICAgICAgICBwMSA9IGcudG91Y2gxWzBdLCBsMSA9IGcudG91Y2gxWzFdLFxuICAgICAgICAgIGRwID0gKGRwID0gcDFbMF0gLSBwMFswXSkgKiBkcCArIChkcCA9IHAxWzFdIC0gcDBbMV0pICogZHAsXG4gICAgICAgICAgZGwgPSAoZGwgPSBsMVswXSAtIGwwWzBdKSAqIGRsICsgKGRsID0gbDFbMV0gLSBsMFsxXSkgKiBkbDtcbiAgICAgIHQgPSBzY2FsZSh0LCBNYXRoLnNxcnQoZHAgLyBkbCkpO1xuICAgICAgcCA9IFsocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyXTtcbiAgICAgIGwgPSBbKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGcudG91Y2gwKSBwID0gZy50b3VjaDBbMF0sIGwgPSBnLnRvdWNoMFsxXTtcbiAgICBlbHNlIHJldHVybjtcblxuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQ7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICB9XG4gICAgaWYgKGcudG91Y2gxICYmICFnLnRvdWNoMCkgZy50b3VjaDAgPSBnLnRvdWNoMSwgZGVsZXRlIGcudG91Y2gxO1xuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgZy5lbmQoKTtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgZGJsdGFwLCByZXJvdXRlIHRvIHRoZSAob3B0aW9uYWwpIGRibGNsaWNrLnpvb20gaGFuZGxlci5cbiAgICAgIGlmIChnLnRhcHMgPT09IDIpIHtcbiAgICAgICAgdCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICAgIGlmIChNYXRoLmh5cG90KHRvdWNoZmlyc3RbMF0gLSB0WzBdLCB0b3VjaGZpcnN0WzFdIC0gdFsxXSkgPCB0YXBEaXN0YW5jZSkge1xuICAgICAgICAgIHZhciBwID0gc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgICBpZiAocCkgcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdoZWVsRGVsdGEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgem9vbSkgOiB3aGVlbERlbHRhO1xuICB9O1xuXG4gIHpvb20uZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgem9vbS50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgem9vbSkgOiBleHRlbnQ7XG4gIH07XG5cbiAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZUV4dGVudFswXSA9ICtfWzBdLCBzY2FsZUV4dGVudFsxXSA9ICtfWzFdLCB6b29tKSA6IFtzY2FsZUV4dGVudFswXSwgc2NhbGVFeHRlbnRbMV1dO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25zdHJhaW4gPSBfLCB6b29tKSA6IGNvbnN0cmFpbjtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgem9vbS50YXBEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXBEaXN0YW5jZSA9ICtfLCB6b29tKSA6IHRhcERpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufVxuIiwiZXhwb3J0IGNsYXNzIEludGVybk1hcCBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMsIGtleSA9IGtleW9mKSB7XG4gICAgc3VwZXIoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7X2ludGVybjoge3ZhbHVlOiBuZXcgTWFwKCl9LCBfa2V5OiB7dmFsdWU6IGtleX19KTtcbiAgICBpZiAoZW50cmllcyAhPSBudWxsKSBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldChpbnRlcm5fZ2V0KHRoaXMsIGtleSkpO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIuaGFzKGludGVybl9nZXQodGhpcywga2V5KSk7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0KGludGVybl9zZXQodGhpcywga2V5KSwgdmFsdWUpO1xuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKGludGVybl9kZWxldGUodGhpcywga2V5KSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludGVyblNldCBleHRlbmRzIFNldCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlcywga2V5ID0ga2V5b2YpIHtcbiAgICBzdXBlcigpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtfaW50ZXJuOiB7dmFsdWU6IG5ldyBNYXAoKX0sIF9rZXk6IHt2YWx1ZToga2V5fX0pO1xuICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHRoaXMuYWRkKHZhbHVlKTtcbiAgfVxuICBoYXModmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuaGFzKGludGVybl9nZXQodGhpcywgdmFsdWUpKTtcbiAgfVxuICBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkKGludGVybl9zZXQodGhpcywgdmFsdWUpKTtcbiAgfVxuICBkZWxldGUodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKGludGVybl9kZWxldGUodGhpcywgdmFsdWUpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcm5fZ2V0KHtfaW50ZXJuLCBfa2V5fSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5ID0gX2tleSh2YWx1ZSk7XG4gIHJldHVybiBfaW50ZXJuLmhhcyhrZXkpID8gX2ludGVybi5nZXQoa2V5KSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5fc2V0KHtfaW50ZXJuLCBfa2V5fSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5ID0gX2tleSh2YWx1ZSk7XG4gIGlmIChfaW50ZXJuLmhhcyhrZXkpKSByZXR1cm4gX2ludGVybi5nZXQoa2V5KTtcbiAgX2ludGVybi5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuX2RlbGV0ZSh7X2ludGVybiwgX2tleX0sIHZhbHVlKSB7XG4gIGNvbnN0IGtleSA9IF9rZXkodmFsdWUpO1xuICBpZiAoX2ludGVybi5oYXMoa2V5KSkge1xuICAgIHZhbHVlID0gX2ludGVybi5nZXQoa2V5KTtcbiAgICBfaW50ZXJuLmRlbGV0ZShrZXkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24ga2V5b2YodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xufVxuIiwiLy8ganNvbnN0YXQtdG9vbGtpdCB2MS41LjMgQ29weXJpZ2h0IDIwMjQgWGF2aWVyIEJhZG9zYSBodHRwczovL2pzb25zdGF0LmNvbVxuZnVuY3Rpb24gdChpLHIpe3ZhciBsLHMsYSxvLHU9ZnVuY3Rpb24odCxpLHIpe2lmKDA9PT1PYmplY3QuZW50cmllcyh0KS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGwscz1bXTtpZihyJiYhbihyLm5hbWUpJiYocj1udWxsKSxcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9W3RdKSxBcnJheS5pc0FycmF5KHQpfHxlKHQpKXtpZih0Lmxlbmd0aD09PWkpcmV0dXJuIHImJi0xPT09dC5maW5kSW5kZXgoKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10fSkpP3IuZnJvbSh0KTp0O2lmKDE9PT10Lmxlbmd0aCl7Zm9yKGw9MDtsPGk7bCsrKXMucHVzaCh0WzBdKTtyZXR1cm4gc319Zm9yKGw9MDtsPGk7bCsrKXt2YXIgYT12b2lkIDA9PT10W2xdP251bGw6dFtsXTtzLnB1c2goYSl9cmV0dXJuIHN9O2lmKHRoaXMubGVuZ3RoPTAsdGhpcy5pZD1bXSxudWxsIT1pKXN3aXRjaCh0aGlzLmNsYXNzPWkuY2xhc3N8fFwiYnVuZGxlXCIsdGhpcy5jbGFzcyl7Y2FzZVwiYnVuZGxlXCI6dmFyIGg9W10sZj0wO2lmKHRoaXMuZXJyb3I9bnVsbCx0aGlzLmxlbmd0aD0wLG51bGw9PT1pfHxcIm9iamVjdFwiIT10eXBlb2YgaSlyZXR1cm4gdm9pZCh0aGlzLmNsYXNzPW51bGwpO2lmKGkuaGFzT3duUHJvcGVydHkoXCJlcnJvclwiKSlyZXR1cm4gdm9pZCh0aGlzLmVycm9yPWkuZXJyb3IpO2lmKFwiZGF0YXNldFwiPT09aS5jbGFzc3x8XCJjb2xsZWN0aW9uXCI9PT1pLmNsYXNzfHxcImRpbWVuc2lvblwiPT09aS5jbGFzcylyZXR1cm4gbmV3IHQoaSk7Zm9yKHMgaW4gaSlmKyssaC5wdXNoKHMpO3RoaXMuX190cmVlX189aSx0aGlzLmxlbmd0aD1mLHRoaXMuaWQ9aDticmVhaztjYXNlXCJkYXRhc2V0XCI6aS5oYXNPd25Qcm9wZXJ0eShcIl9fdHJlZV9fXCIpP3RoaXMuX190cmVlX189bD1pLl9fdHJlZV9fOnRoaXMuX190cmVlX189bD1pLHRoaXMubGFiZWw9bC5sYWJlbHx8bnVsbCx0aGlzLm5vdGU9bC5ub3RlfHxudWxsLHRoaXMubGluaz1sLmxpbmt8fG51bGwsdGhpcy5ocmVmPWwuaHJlZnx8bnVsbCx0aGlzLnVwZGF0ZWQ9bC51cGRhdGVkfHxudWxsLHRoaXMuc291cmNlPWwuc291cmNlfHxudWxsLHRoaXMuZXh0ZW5zaW9uPWwuZXh0ZW5zaW9ufHxudWxsO3ZhciBjLGQ9MCx2PWwuc2l6ZXx8bC5kaW1lbnNpb24mJmwuZGltZW5zaW9uLnNpemU7aWYodGhpcy5zaXplPXYsdGhpcy52YWx1ZT1sLmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJm51bGwhPT1sLnZhbHVlJiYwIT09bC52YWx1ZS5sZW5ndGg/bC52YWx1ZTp7fSxBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpfHxlKHRoaXMudmFsdWUpKWQ9dGhpcy52YWx1ZS5sZW5ndGg7ZWxzZXt2YXIgeT0xO2ZvcihjPXYubGVuZ3RoO2MtLTspeSo9dltjXTtkPXl9aWYodGhpcy52YWx1ZT11KHRoaXMudmFsdWUsZCxyKSx0aGlzLnN0YXR1cz1sLmhhc093blByb3BlcnR5KFwic3RhdHVzXCIpJiZudWxsIT09bC5zdGF0dXM/dShsLnN0YXR1cyxkKTpudWxsLGwuaGFzT3duUHJvcGVydHkoXCJkaW1lbnNpb25cIikpe3ZhciBwPWwuZGltZW5zaW9uLGc9bC5yb2xlfHwhbC52ZXJzaW9uJiZwLnJvbGV8fG51bGwsYj1sLmlkfHxwLmlkLG09di5sZW5ndGgsXz1mdW5jdGlvbih0KXtnLmhhc093blByb3BlcnR5KHQpfHwoZ1t0XT1udWxsKX07aWYoIUFycmF5LmlzQXJyYXkoYil8fCFBcnJheS5pc0FycmF5KHYpfHxiLmxlbmd0aCE9bSlyZXR1cm47aWYodGhpcy5sZW5ndGg9bSx0aGlzLmlkPWIsZyYmKF8oXCJ0aW1lXCIpLF8oXCJnZW9cIiksXyhcIm1ldHJpY1wiKSxfKFwiY2xhc3NpZmljYXRpb25cIikpLGcmJm51bGw9PT1nLmNsYXNzaWZpY2F0aW9uKXt2YXIgeD1bXSxPPVtcInRpbWVcIixcImdlb1wiLFwibWV0cmljXCJdLEE9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5sZW5ndGg7bi0tOylpZih0PT09ZVtuXSlyZXR1cm4hMDtyZXR1cm4hMX07Zm9yKGM9MDtjPDM7YysrKXt2YXIgdz1nW09bY11dO251bGwhPT13JiYoeD14LmNvbmNhdCh3KSl9Zm9yKGcuY2xhc3NpZmljYXRpb249W10sYz0wO2M8bTtjKyspQShiW2NdLHgpfHxnLmNsYXNzaWZpY2F0aW9uLnB1c2goYltjXSk7MD09PWcuY2xhc3NpZmljYXRpb24ubGVuZ3RoJiYoZy5jbGFzc2lmaWNhdGlvbj1udWxsKX10aGlzLnJvbGU9Zyx0aGlzLm49ZDtmb3IodmFyIGo9MCxrPXRoaXMubGVuZ3RoO2o8aztqKyspaWYocFtiW2pdXS5jYXRlZ29yeS5oYXNPd25Qcm9wZXJ0eShcImluZGV4XCIpKXtpZihBcnJheS5pc0FycmF5KHBbYltqXV0uY2F0ZWdvcnkuaW5kZXgpKXt2YXIgRD17fSxQPXBbYltqXV0uY2F0ZWdvcnkuaW5kZXg7Zm9yKGE9UC5sZW5ndGgsbz0wO288YTtvKyspRFtQW29dXT1vO3BbYltqXV0uY2F0ZWdvcnkuaW5kZXg9RH19ZWxzZXt2YXIgRT0wO2ZvcihzIGluIHBbYltqXV0uY2F0ZWdvcnkuaW5kZXg9e30scFtiW2pdXS5jYXRlZ29yeS5sYWJlbClwW2Jbal1dLmNhdGVnb3J5LmluZGV4W3NdPUUrK319ZWxzZSB0aGlzLmxlbmd0aD0wO2JyZWFrO2Nhc2VcImRpbWVuc2lvblwiOmlmKCFpLmhhc093blByb3BlcnR5KFwiX190cmVlX19cIikpcmV0dXJuIG5ldyB0KHt2ZXJzaW9uOlwiMi4wXCIsY2xhc3M6XCJkYXRhc2V0XCIsZGltZW5zaW9uOntkOml9LGlkOltcImRcIl0sc2l6ZTpbZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwPT09dC5pbmRleD90LmxhYmVsOnQuaW5kZXg7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5sZW5ndGg6T2JqZWN0LmtleXMoZSkubGVuZ3RofShpLmNhdGVnb3J5KV0sdmFsdWU6W251bGxdfSkuRGltZW5zaW9uKDApO3ZhciB6PVtdLFM9KGw9aS5fX3RyZWVfXykuY2F0ZWdvcnk7aWYoIWwuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeVwiKSlyZXR1cm47aWYoIVMuaGFzT3duUHJvcGVydHkoXCJsYWJlbFwiKSlmb3IocyBpbiBTLmxhYmVsPXt9LFMuaW5kZXgpUy5sYWJlbFtzXT1zO2ZvcihzIGluIFMuaW5kZXgpeltTLmluZGV4W3NdXT1zO3RoaXMuX190cmVlX189bCx0aGlzLmxhYmVsPWwubGFiZWx8fG51bGwsdGhpcy5ub3RlPWwubm90ZXx8bnVsbCx0aGlzLmxpbms9bC5saW5rfHxudWxsLHRoaXMuaHJlZj1sLmhyZWZ8fG51bGwsdGhpcy5pZD16LHRoaXMubGVuZ3RoPXoubGVuZ3RoLHRoaXMucm9sZT1pLnJvbGUsdGhpcy5oaWVyYXJjaHk9Uy5oYXNPd25Qcm9wZXJ0eShcImNoaWxkXCIpLHRoaXMuZXh0ZW5zaW9uPWwuZXh0ZW5zaW9ufHxudWxsO2JyZWFrO2Nhc2VcImNhdGVnb3J5XCI6dmFyIEk9aS5jaGlsZDt0aGlzLmlkPUksdGhpcy5sZW5ndGg9bnVsbD09PUk/MDpJLmxlbmd0aCx0aGlzLmluZGV4PWkuaW5kZXgsdGhpcy5sYWJlbD1pLmxhYmVsLHRoaXMubm90ZT1pLm5vdGV8fG51bGwsdGhpcy51bml0PWkudW5pdCx0aGlzLmNvb3JkaW5hdGVzPWkuY29vcmQ7YnJlYWs7Y2FzZVwiY29sbGVjdGlvblwiOmlmKHRoaXMubGVuZ3RoPTAsdGhpcy5sYWJlbD1pLmxhYmVsfHxudWxsLHRoaXMubm90ZT1pLm5vdGV8fG51bGwsdGhpcy5saW5rPWkubGlua3x8bnVsbCx0aGlzLmhyZWY9aS5ocmVmfHxudWxsLHRoaXMudXBkYXRlZD1pLnVwZGF0ZWR8fG51bGwsdGhpcy5zb3VyY2U9aS5zb3VyY2V8fG51bGwsdGhpcy5leHRlbnNpb249aS5leHRlbnNpb258fG51bGwsbnVsbCE9PXRoaXMubGluayYmaS5saW5rLml0ZW0pe3ZhciBDPWkubGluay5pdGVtO2lmKHRoaXMubGVuZ3RoPUFycmF5LmlzQXJyYXkoQyk/Qy5sZW5ndGg6MCx0aGlzLmxlbmd0aClmb3Iobz0wO288dGhpcy5sZW5ndGg7bysrKXRoaXMuaWRbb109Q1tvXS5ocmVmfX19ZnVuY3Rpb24gZSh0KXtyZXR1cm5cIltvYmplY3QgQXJyYXlCdWZmZXJdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5idWZmZXIpfWZ1bmN0aW9uIG4odCl7cmV0dXJuLTEhPT1bXCJJbnQ4QXJyYXlcIixcIlVpbnQ4QXJyYXlcIixcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXCJJbnQxNkFycmF5XCIsXCJVaW50MTZBcnJheVwiLFwiSW50MzJBcnJheVwiLFwiVWludDMyQXJyYXlcIixcIkZsb2F0MzJBcnJheVwiLFwiRmxvYXQ2NEFycmF5XCIsXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiXS5pbmRleE9mKHQpfWZ1bmN0aW9uIGkodCl7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKHQuc3RhdHVzK1wiIFwiK3Quc3RhdHVzVGV4dCk7cmV0dXJuIHQuanNvbigpfWZ1bmN0aW9uIHIoZSxuLHIpe3ZhciBsPVwib2JqZWN0XCI9PXR5cGVvZiBuP246bnVsbDtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiByJiYocj1udWxsKSxyfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBufHwocj1uKSxcIm9iamVjdFwiPT10eXBlb2YgZT9uZXcgdChlLHIpOlwidmVyc2lvblwiPT09ZT9cIjEuNS4zXCI6ZmV0Y2g/ZmV0Y2goZSxsKS50aGVuKGkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlLHIpfSkpOnZvaWQgMH10LnByb3RvdHlwZS5JdGVtPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzfHxcImNvbGxlY3Rpb25cIiE9PXRoaXMuY2xhc3N8fCF0aGlzLmxlbmd0aClyZXR1cm4gbnVsbDtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gdD50aGlzLmxlbmd0aHx8dDwwP251bGw6dGhpcy5saW5rLml0ZW1bdF07dmFyIGUsbj1bXTtpZihcIm9iamVjdFwiPT10eXBlb2YgdCl7aWYoIXQuY2xhc3MmJiF0LmZvbGxvdylyZXR1cm4gbnVsbDt0LmNsYXNzJiYoZT1cImRhdGFzZXRcIj09PXQuY2xhc3MmJlwiYm9vbGVhblwiPT10eXBlb2YgdC5lbWJlZGRlZD8hMD09PXQuZW1iZWRkZWQ/ZnVuY3Rpb24odCxlLGkpe3ZhciByPXQubGluay5pdGVtW2VdO2kuY2xhc3M9PT1yLmNsYXNzJiZyLmlkJiZyLnNpemUmJnIuZGltZW5zaW9uJiZuLnB1c2gocil9OmZ1bmN0aW9uKHQsZSxpKXt2YXIgcj10LmxpbmsuaXRlbVtlXTtpLmNsYXNzIT09ci5jbGFzc3x8ci5pZCYmci5zaXplJiZyLmRpbWVuc2lvbnx8bi5wdXNoKHIpfTpmdW5jdGlvbih0LGUsaSl7aS5jbGFzcz09PXQubGluay5pdGVtW2VdLmNsYXNzJiZuLnB1c2godC5saW5rLml0ZW1bZV0pfSl9ZWxzZSBlPWZ1bmN0aW9uKHQsZSl7bi5wdXNoKHQubGluay5pdGVtW2VdKX07Zm9yKHZhciBpPTA7aTx0aGlzLmxlbmd0aDtpKyspZSh0aGlzLGksdCk7cmV0dXJuIG59LHQucHJvdG90eXBlLkRhdGFzZXQ9ZnVuY3Rpb24oZSl7aWYobnVsbD09PXRoaXMpcmV0dXJuIG51bGw7aWYoXCJkYXRhc2V0XCI9PT10aGlzLmNsYXNzKXJldHVybiB2b2lkIDAhPT1lP3RoaXM6W3RoaXNdO3ZhciBuLGk9W10scj0wO2lmKFwiY29sbGVjdGlvblwiPT09dGhpcy5jbGFzcyl7dmFyIGw9dGhpcy5JdGVtKHtjbGFzczpcImRhdGFzZXRcIixlbWJlZGRlZDohMH0pO2lmKHZvaWQgMD09PWUpe2ZvcihuPWwubGVuZ3RoO3I8bjtyKyspaS5wdXNoKG5ldyB0KGxbcl0pKTtyZXR1cm4gaX1pZihcIm51bWJlclwiPT10eXBlb2YgZSYmZT49MCYmZTxsLmxlbmd0aClyZXR1cm4gbmV3IHQobFtlXSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpZm9yKG49bC5sZW5ndGg7cjxuO3IrKylpZihsW3JdLmhyZWY9PT1lKXJldHVybiBuZXcgdChsW3JdKTtyZXR1cm4gbnVsbH1pZihcImJ1bmRsZVwiIT09dGhpcy5jbGFzcylyZXR1cm4gbnVsbDtpZih2b2lkIDA9PT1lKXtmb3Iobj10aGlzLmlkLmxlbmd0aDtyPG47cisrKWkucHVzaCh0aGlzLkRhdGFzZXQodGhpcy5pZFtyXSkpO3JldHVybiBpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXt2YXIgcz10aGlzLmlkW2VdO3JldHVybiB2b2lkIDAhPT1zP3RoaXMuRGF0YXNldChzKTpudWxsfXZhciBhPXRoaXMuX190cmVlX19bZV07cmV0dXJuIHZvaWQgMD09PWE/bnVsbDpuZXcgdCh7Y2xhc3M6XCJkYXRhc2V0XCIsX190cmVlX186YX0pfSx0LnByb3RvdHlwZS5EaW1lbnNpb249ZnVuY3Rpb24oZSxuKXtuPVwiYm9vbGVhblwiIT10eXBlb2Ygbnx8bjt2YXIgaSxyPVtdLGw9dGhpcy5pZC5sZW5ndGgscz1mdW5jdGlvbih0LGUpe2lmKG51bGwhPT10KWZvcih2YXIgbiBpbiB0KWZvcih2YXIgaT1udWxsIT09dFtuXT90W25dLmxlbmd0aDowO2ktLTspaWYodFtuXVtpXT09PWUpcmV0dXJuIG47cmV0dXJuIG51bGx9O2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3MpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09ZSl7Zm9yKGk9MDtpPGw7aSsrKXIucHVzaCh0aGlzLkRpbWVuc2lvbih0aGlzLmlkW2ldKSk7cmV0dXJuIHJ9aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3ZhciBhPXRoaXMuaWRbZV07cmV0dXJuIHZvaWQgMCE9PWE/dGhpcy5EaW1lbnNpb24oYSxuKTpudWxsfXZhciBvPXRoaXMucm9sZTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSl7aWYoZS5oYXNPd25Qcm9wZXJ0eShcInJvbGVcIikpe2ZvcihpPTA7aTxsO2krKyl7dmFyIHU9dGhpcy5pZFtpXTtzKG8sdSk9PT1lLnJvbGUmJnIucHVzaCh0aGlzLkRpbWVuc2lvbih1LG4pKX1yZXR1cm4gdm9pZCAwPT09clswXT9udWxsOnJ9cmV0dXJuIG51bGx9dmFyIGg9dGhpcy5fX3RyZWVfXy5kaW1lbnNpb247aWYodm9pZCAwPT09aClyZXR1cm4gbnVsbDt2YXIgZj1oW2VdO3JldHVybiB2b2lkIDA9PT1mP251bGw6bj9uZXcgdCh7Y2xhc3M6XCJkaW1lbnNpb25cIixfX3RyZWVfXzpmLHJvbGU6cyhvLGUpfSk6ZnVuY3Rpb24odCxlKXt2YXIgbj1bXTtmb3IodmFyIGkgaW4gdCluW3RbaV1dPWVbaV07cmV0dXJuIG59KGYuY2F0ZWdvcnkuaW5kZXgsZi5jYXRlZ29yeS5sYWJlbCl9LHQucHJvdG90eXBlLkNhdGVnb3J5PWZ1bmN0aW9uKGUpe2lmKG51bGw9PT10aGlzfHxcImRpbWVuc2lvblwiIT09dGhpcy5jbGFzcylyZXR1cm4gbnVsbDtpZih2b2lkIDA9PT1lKXtmb3IodmFyIG49W10saT0wLHI9dGhpcy5pZC5sZW5ndGg7aTxyO2krKyluLnB1c2godGhpcy5DYXRlZ29yeSh0aGlzLmlkW2ldKSk7cmV0dXJuIG59aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3ZhciBsPXRoaXMuaWRbZV07cmV0dXJuIHZvaWQgMCE9PWw/dGhpcy5DYXRlZ29yeShsKTpudWxsfXZhciBzPXRoaXMuX190cmVlX18uY2F0ZWdvcnk7aWYodm9pZCAwPT09cylyZXR1cm4gbnVsbDt2YXIgYT1zLmluZGV4W2VdO2lmKHZvaWQgMD09PWEpcmV0dXJuIG51bGw7dmFyIG89cy51bml0JiZzLnVuaXRbZV18fG51bGwsdT1zLmNvb3JkaW5hdGVzJiZzLmNvb3JkaW5hdGVzW2VdfHxudWxsLGg9cy5jaGlsZCYmcy5jaGlsZFtlXXx8bnVsbCxmPXMubm90ZSYmcy5ub3RlW2VdfHxudWxsO3JldHVybiBuZXcgdCh7Y2xhc3M6XCJjYXRlZ29yeVwiLGluZGV4OmEsbGFiZWw6cy5sYWJlbFtlXSxub3RlOmYsY2hpbGQ6aCx1bml0Om8sY29vcmQ6dX0pfSx0LnByb3RvdHlwZS5EaWNlPWZ1bmN0aW9uKG4saSxyKXt2YXIgbCxzLGEsbyx1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaGFzT3duUHJvcGVydHkoZSkmJiEhdFtlXX07aWYobnVsbD09PXRoaXN8fFwiZGF0YXNldFwiIT09dGhpcy5jbGFzc3x8bnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIG51bGw7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG4pcmV0dXJuIHRoaXM7XCJvYmplY3RcIiE9dHlwZW9mIGk/KFwiYm9vbGVhblwiPT10eXBlb2YgaSYmITA9PT1pJiYobD0hMCksXCJib29sZWFuXCI9PXR5cGVvZiByJiYhMD09PXJ8fChyPSExKSk6KGw9dShpLFwiY2xvbmVcIikscj11KGksXCJkcm9wXCIpLHM9dShpLFwic3RyaW5naWZ5XCIpLGE9dShpLFwib3ZhbHVlXCIpLG89dShpLFwib3N0YXR1c1wiKSk7dmFyIGgsZj10aGlzLnZhbHVlLGM9bD9uZXcgdChKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMpKSk6dGhpcyxkPWMuc3RhdHVzLHY9W10seT1bXSxwPWZ1bmN0aW9uKHQsZSl7dmFyIG4saSxyLGw9KG49dCxpPWUscj17fSxBcnJheS5pc0FycmF5KG5baV0pPyhuW2ldLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7bnVsbCE9PXQmJihyW1N0cmluZyhlKV09dCl9KSkscik6bltpXSk7ZGVsZXRlIHRbZV0sdFtlXT1sfTtBcnJheS5pc0FycmF5KG4pJiYobj1mdW5jdGlvbih0KXt2YXIgZT17fTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RbMF1dPXRbMV19KSksZX0obikpLG51bGw9PT1uJiYobj17fSk7dmFyIGc9T2JqZWN0LmtleXMobik7cmV0dXJuIGcubGVuZ3RoPjAmJihnLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPW5bdF07QXJyYXkuaXNBcnJheShlKXx8KG5bdF09W2VdKSwwPT09blt0XS5sZW5ndGgmJmRlbGV0ZSBuW3RdfSkpLHImJihuPWZ1bmN0aW9uKHQpe3ZhciBlPXt9O3JldHVybiBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXtlW25dPWMuRGltZW5zaW9uKG4pLmlkLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuLTE9PT10W25dLmluZGV4T2YoZSl9KSl9KSksZX0obikpLGMudG9UYWJsZSh7dHlwZTpcImFycm9ialwiLGNvbnRlbnQ6XCJpZFwiLHN0YXR1czohMH0pLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7dmFyIGk9W107Zy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgcj1uW2VdLGw9W107ci5mb3JFYWNoKChmdW5jdGlvbihuKXtsLnB1c2godFtlXT09PW4pfSkpLGkucHVzaCgtMSE9PWwuaW5kZXhPZighMCkpfSkpLC0xPT09aS5pbmRleE9mKCExKSYmKHYucHVzaCh0LnZhbHVlKSx5LnB1c2godC5zdGF0dXMpKX0pKSxnLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWMuRGltZW5zaW9uKHQpLmlkLGk9MCxyPXt9O2Muc2l6ZVtjLmlkLmluZGV4T2YodCldPW5bdF0ubGVuZ3RoLGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7LTEhPT1uW3RdLmluZGV4T2YoZSkmJihyW2VdPWksaSsrKX0pKSxjLl9fdHJlZV9fLmRpbWVuc2lvblt0XS5jYXRlZ29yeS5pbmRleD1yfSkpLGMubj12Lmxlbmd0aCxjLnZhbHVlPWMuX190cmVlX18udmFsdWU9ZShmKT9mdW5jdGlvbih0LGUpe3JldHVybiBlLmZyb20odCl9KHYsZi5jb25zdHJ1Y3Rvcik6dixjLnN0YXR1cz1jLl9fdHJlZV9fLnN0YXR1cz1udWxsIT09ZD95Om51bGwpLHM/KChoPWMuX190cmVlX18pLmhhc093blByb3BlcnR5KFwiaWRcIil8fChoLnZlcnNpb249XCIyLjBcIixoLmhhc093blByb3BlcnR5KFwiY2xhc3NcIil8fChoLmNsYXNzPVwiZGF0YXNldFwiKSxoLmlkPWguZGltZW5zaW9uLmlkLGguc2l6ZT1oLmRpbWVuc2lvbi5zaXplLGRlbGV0ZSBoLmRpbWVuc2lvbi5pZCxkZWxldGUgaC5kaW1lbnNpb24uc2l6ZSxoLmRpbWVuc2lvbi5oYXNPd25Qcm9wZXJ0eShcInJvbGVcIikmJihoLnJvbGU9aC5kaW1lbnNpb24ucm9sZSxkZWxldGUgaC5kaW1lbnNpb24ucm9sZSkpLGguaGFzT3duUHJvcGVydHkoXCJzdGF0dXNcIikmJi0xIT09W1wibnVsbFwiLFwie31cIixcIltdXCJdLmluZGV4T2YoSlNPTi5zdHJpbmdpZnkoaC5zdGF0dXMpKSYmZGVsZXRlIGguc3RhdHVzLGguaGFzT3duUHJvcGVydHkoXCJyb2xlXCIpJiYoZGVsZXRlIGgucm9sZS5jbGFzc2lmaWNhdGlvbixbXCJnZW9cIixcInRpbWVcIixcIm1ldHJpY1wiXS5mb3JFYWNoKChmdW5jdGlvbih0KXtudWxsPT09aC5yb2xlW3RdJiZkZWxldGUgaC5yb2xlW3RdfSkpKSxhJiZwKGgsXCJ2YWx1ZVwiKSxvJiZoLmhhc093blByb3BlcnR5KFwic3RhdHVzXCIpJiZwKGgsXCJzdGF0dXNcIiksSlNPTi5zdHJpbmdpZnkoaCkpOmN9LHQucHJvdG90eXBlLlNsaWNlPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3N8fDA9PT1PYmplY3QuZW50cmllcyh0aGlzLnZhbHVlKS5sZW5ndGgpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcztpZighQXJyYXkuaXNBcnJheSh0KSl7dmFyIGUsbj1bXTtmb3IoZSBpbiB0KW4ucHVzaChbZSx0W2VdXSk7dD1ufXJldHVybiB0aGlzLkRpY2UodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblt0WzBdLFt0WzFdXV19KSkpfSx0LnByb3RvdHlwZS5EYXRhPWZ1bmN0aW9uKHQsZSl7dmFyIG4saSxyPVtdLGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gZX07aWYobnVsbD09PXRoaXN8fFwiZGF0YXNldFwiIT09dGhpcy5jbGFzc3x8bnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09dCl7Zm9yKGk9dGhpcy52YWx1ZS5sZW5ndGgsbj0wO248aTtuKyspci5wdXNoKHRoaXMuRGF0YShuKSk7cmV0dXJuIHJ9aWYoXCJib29sZWFuXCIhPXR5cGVvZiBlJiYoZT0hMCksXCJudW1iZXJcIj09dHlwZW9mIHQpe3ZhciBzPXRoaXMudmFsdWVbdF07cmV0dXJuIHZvaWQgMD09PXM/bnVsbDplP3t2YWx1ZTpzLHN0YXR1czp0aGlzLnN0YXR1cz90aGlzLnN0YXR1c1t0XTpudWxsfTpzfXZhciBhPVwib2JqZWN0XCIsbz10aGlzLl9fdHJlZV9fLHU9by5zaXplfHxvLmRpbWVuc2lvbiYmby5kaW1lbnNpb24uc2l6ZSxoPXUubGVuZ3RoO2lmKEFycmF5LmlzQXJyYXkodCkpe2lmKCFBcnJheS5pc0FycmF5KHRbMF0pKXtpZih0aGlzLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiBudWxsO3ZhciBmPTEsYz0wLGQ9W10sdj1bXTtmb3Iobj0wO248aDtuKyspaWYodm9pZCAwIT09dFtuXSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHRbbl18fHRbbl0+PXVbbl0pcmV0dXJuIG51bGw7Yys9KGYqPW4+MD91W2gtbl06MSkqdFtoLW4tMV19ZWxzZSBkLnB1c2gobiksdi5wdXNoKHVbbl0pO2lmKGQubGVuZ3RoPjEpcmV0dXJuIG51bGw7aWYoMT09PWQubGVuZ3RoKXtmb3IodmFyIHk9MCxwPXZbMF07eTxwO3krKyl7dmFyIGc9W107Zm9yKG49MDtuPGg7bisrKW4hPT1kWzBdP2cucHVzaCh0W25dKTpnLnB1c2goeSk7ci5wdXNoKHRoaXMuRGF0YShnLGUpKX1yZXR1cm4gcn1yZXR1cm4gZT97dmFsdWU6dGhpcy52YWx1ZVtjXSxzdGF0dXM6dGhpcy5zdGF0dXM/dGhpcy5zdGF0dXNbY106bnVsbH06dGhpcy52YWx1ZVtjXX1hPVwiYXJyYXlcIn12YXIgYj1mdW5jdGlvbih0LGUsbil7dmFyIGkscj1bXSxzPXt9LGE9dC5kaW1lbnNpb24sbz10LmlkfHxhLmlkLHU9dC5zaXplfHxhJiZhLnNpemU7aWYoXCJhcnJheVwiPT09bil7Zm9yKGk9ZS5sZW5ndGg7aS0tOylzW2VbaV1bMF1dPWVbaV1bMV07ZT1zfWZvcih2YXIgaD0wLGY9by5sZW5ndGg7aDxmO2grKyl7dmFyIGM9b1toXSxkPWVbY107ci5wdXNoKFwic3RyaW5nXCI9PXR5cGVvZiBkP2Q6MT09PXVbaF0/bChhW2NdLmNhdGVnb3J5LmluZGV4KTpudWxsKX1yZXR1cm4gcn0obyx0LGEpLG09W10sXz1vLmRpbWVuc2lvbix4PW8uaWR8fF8uaWQ7Zm9yKG49MCxpPWIubGVuZ3RoO248aTtuKyspbS5wdXNoKF9beFtuXV0uY2F0ZWdvcnkuaW5kZXhbYltuXV0pO3JldHVybiB0aGlzLkRhdGEobSxlKX0sdC5wcm90b3R5cGUudG9UYWJsZT1mdW5jdGlvbih0LGUpe2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3N8fG51bGw9PT10aGlzLnZhbHVlKXJldHVybiBudWxsOzE9PWFyZ3VtZW50cy5sZW5ndGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihlPXQsdD1udWxsKSxcImFycm9ialwiIT09KHQ9dHx8e2ZpZWxkOlwibGFiZWxcIixjb250ZW50OlwibGFiZWxcIix2bGFiZWw6XCJWYWx1ZVwiLHNsYWJlbDpcIlN0YXR1c1wiLHR5cGU6XCJhcnJheVwiLHN0YXR1czohMSx1bml0OiExLGJ5Om51bGwscHJlZml4OlwiXCIsZHJvcDpbXSxtZXRhOiExLGNvbW1hOiExLGJ5bGFiZWw6ITF9KS50eXBlJiZcIm9iamFyclwiIT09dC50eXBlfHx2b2lkIDAhPT10LmZpZWxkfHwodC5maWVsZD1cImlkXCIpO3ZhciBpLHIsbCxzLGEsbyx1LGgsZixjPVwiaWRcIj09PXQuZmllbGQsZD1mdW5jdGlvbih0KXtyZXR1cm4oYz9cInZhbHVlXCI6dCl8fFwiVmFsdWVcIn0sdj1mdW5jdGlvbih0KXtyZXR1cm4oYz9cInN0YXR1c1wiOnQpfHxcIlN0YXR1c1wifSx5PXRoaXMuX190cmVlX18scD0hMD09PXQuc3RhdHVzO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpe2k9dGhpcy50b1RhYmxlKHQpO3ZhciBnPVtdLGI9XCJhcnJheVwiIT09dC50eXBlPzA6MTtmb3IoYT0oVj1cIm9iamVjdFwiIT09dC50eXBlP2kuc2xpY2UoYik6aS5yb3dzLnNsaWNlKDApKS5sZW5ndGgscj0wO3I8YTtyKyspe3ZhciBtPWUuY2FsbCh0aGlzLFZbcl0scik7dm9pZCAwIT09bSYmZy5wdXNoKG0pfXJldHVyblwib2JqZWN0XCI9PT10LnR5cGU/e2NvbHM6aS5jb2xzLHJvd3M6Z306KFwiYXJyYXlcIj09PXQudHlwZSYmZy51bnNoaWZ0KGlbMF0pLGcpfWlmKFwiYXJyb2JqXCI9PT10LnR5cGV8fFwib2JqYXJyXCI9PT10LnR5cGUpe3ZhciBfPVtdLHg9eS5yb2xlJiZ5LnJvbGUubWV0cmljLE89ZnVuY3Rpb24oKXt9LEE9e30sdz10aGlzLGo9dy5pZCxrPXQuYnkmJi0xIT09ai5pbmRleE9mKHQuYnkpP3QuYnk6bnVsbCxEPSEwPT09dC5tZXRhLFA9dm9pZCAwIT09dC5kcm9wJiZBcnJheS5pc0FycmF5KHQuZHJvcCk/dC5kcm9wOltdLEU9ITA9PT10LmNvbW1hLHo9ITA9PT10LmJ5bGFiZWwsUz13LnZhbHVlLmNvbnN0cnVjdG9yLEk9ZnVuY3Rpb24oZSl7dmFyIGkscj17fSxsPWQodC52bGFiZWwpO2lmKFwib2JqYXJyXCI9PT10LnR5cGUmJihpPW51bGw9PT1rJiZuKFMubmFtZSk/ZnVuY3Rpb24odCl7clt0XT10PT09bD9TLmZyb20oZSwoZnVuY3Rpb24oZSl7cmV0dXJuIGVbdF19KSk6ZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlW3RdfSkpfTpmdW5jdGlvbih0KXtyW3RdPWUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZVt0XX0pKX0sT2JqZWN0LmtleXMoZVswXSkuZm9yRWFjaChpKSxlPXIpLEQpe3I9e307cmV0dXJuIGouZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dy5EaW1lbnNpb24odCk7clt0XT17bGFiZWw6ZS5sYWJlbCxyb2xlOmUucm9sZSxjYXRlZ29yaWVzOntpZDplLmlkLGxhYmVsOncuRGltZW5zaW9uKHQsITEpfX19KSkse21ldGE6e2xhYmVsOncubGFiZWwsc291cmNlOncuc291cmNlLHVwZGF0ZWQ6dy51cGRhdGVkLGlkOmosc3RhdHVzOnAsdW5pdDp0LnVuaXQsYnk6ayxieWxhYmVsOnosZHJvcDpudWxsIT09ayYmUC5sZW5ndGg+MD9QOm51bGwscHJlZml4Om51bGwhPT1rP0d8fFwiXCI6bnVsbCxjb21tYTpFLGRpbWVuc2lvbnM6cn0sZGF0YTplfX1yZXR1cm4gZX07ayYmKHQuZmllbGQ9XCJpZFwiKTt2YXIgQz0oaT10aGlzLnRvVGFibGUoe2ZpZWxkOnQuZmllbGQsdmxhYmVsOnQudmxhYmVsLHNsYWJlbDp0LnNsYWJlbCxjb250ZW50OnQuY29udGVudCxzdGF0dXM6cH0pKS5zaGlmdCgpO2lmKG51bGw9PT1rJiZ0LnVuaXQmJngpe2lmKFwiaWRcIiE9PXQuY29udGVudClmb3IodmFyIFQ9eC5sZW5ndGg7VC0tOyl7dmFyIFU9dGhpcy5EaW1lbnNpb24oeFtUXSk7QVt4W1RdXT17fTtmb3IodmFyIEo9VS5sZW5ndGg7Si0tOylBW3hbVF1dW1UuQ2F0ZWdvcnkoSikubGFiZWxdPVUuaWRbSl19Tz1mdW5jdGlvbihlLG4pe2lmKC0xIT09eC5pbmRleE9mKGUpKXt2YXIgaT15LmRpbWVuc2lvbltlXS5jYXRlZ29yeTtpLnVuaXQ/Ti51bml0PWkudW5pdFtcImlkXCIhPT10LmNvbnRlbnQ/QVtlXVtuXTpuXTpOLnVuaXQ9bnVsbH19LHQudW5pdD0hMH1lbHNlIHQudW5pdD0hMTtmb3IoYT1pLmxlbmd0aCxyPTA7cjxhO3IrKyl7dmFyIE49e307Zm9yKGw9aVtyXS5sZW5ndGg7bC0tOylOW0NbbF1dPWlbcl1bbF0sTyhDW2xdLGlbcl1bbF0pO18ucHVzaChOKX1pZihFJiZfLmZvckVhY2goKGZ1bmN0aW9uKHQpe251bGwhPT10LnZhbHVlJiYodC52YWx1ZT0oXCJcIit0LnZhbHVlKS5yZXBsYWNlKFwiLlwiLFwiLFwiKSl9KSksbnVsbCE9PWspe3ZhciBCLEY9e30sVj1bXSxxPXt9LEc9dm9pZCAwIT09dC5wcmVmaXg/dC5wcmVmaXg6XCJcIjtQLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7KCF3LkRpbWVuc2lvbih0KXx8dy5EaW1lbnNpb24odCkubGVuZ3RoPjEpJiYoUFtlXT1cIlwiKX0pKTt2YXIgSD1qLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQhPT1rJiYtMT09PVAuaW5kZXhPZih0KX0pKSxLPXcuRGltZW5zaW9uKGspO2Zvcih2YXIgTCBpblwiaWRcIiE9PXQuY29udGVudD96P0I9ZnVuY3Rpb24odCxlLG4pe3RbZV1bRytuW2tdXT1uLnZhbHVlfTooSy5DYXRlZ29yeSgpLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7cVt0LmxhYmVsXT1LLmlkW2VdfSkpLEI9ZnVuY3Rpb24odCxlLG4pe3RbZV1bRytxW25ba11dXT1uLnZhbHVlfSk6Qj1mdW5jdGlvbih0LGUsbil7dFtlXVtHK25ba11dPW4udmFsdWV9LF8uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1bXTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlKXtuLnB1c2godFtlXSl9KSksbi5qb2luKFwiXFx0XCIpfSh0LEgpO3ZvaWQgMD09PUZbZV0mJihGW2VdPWZ1bmN0aW9uKHQsZSl7dmFyIG49e307cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bltlXT10W2VdfSkpLG59KHQsSCkpLEIoRixlLHQsayl9KSksRilWLnB1c2goRltMXSk7cmV0dXJuIHA9ITEsSShWKX1yZXR1cm4gSShfKX1pZihcIm9iamVjdFwiPT09dC50eXBlKXt2YXIgTT1cIm51bWJlclwiPT10eXBlb2YgdGhpcy52YWx1ZVswXXx8bnVsbD09PXRoaXMudmFsdWVbMF0/XCJudW1iZXJcIjpcInN0cmluZ1wiO289ZnVuY3Rpb24odCxlKXt2YXIgbj1jJiZ0fHxlfHx0O2l0LnB1c2goe2lkOnQsbGFiZWw6bix0eXBlOlwic3RyaW5nXCJ9KX0sdT1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZCh0KSxyPXYoZSk7biYmaXQucHVzaCh7aWQ6XCJzdGF0dXNcIixsYWJlbDpyLHR5cGU6XCJzdHJpbmdcIn0pLGl0LnB1c2goe2lkOlwidmFsdWVcIixsYWJlbDppLHR5cGU6TX0pfSxoPWZ1bmN0aW9uKHQpe3l0LnB1c2goe3Y6dH0pfSxmPWZ1bmN0aW9uKHQpe3l0LnB1c2goe3Y6dH0pLHJ0LnB1c2goe2M6eXR9KX19ZWxzZSBvPWZ1bmN0aW9uKHQsZSl7dmFyIG49YyYmdHx8ZXx8dDtpdC5wdXNoKG4pfSx1PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1kKHQpLHI9dihlKTtuJiZpdC5wdXNoKHIpLGl0LnB1c2goaSksbnQucHVzaChpdCl9LGg9ZnVuY3Rpb24odCl7eXQucHVzaCh0KX0sZj1mdW5jdGlvbih0KXt5dC5wdXNoKHQpLG50LnB1c2goeXQpfTt2YXIgUT15LmRpbWVuc2lvbixSPXkuaWR8fFEuaWQsVz15LnNpemV8fFEuc2l6ZSxYPVIubGVuZ3RoO2lmKFghPVcubGVuZ3RoKXJldHVybiExO3ZhciBZPVtdLFo9MSwkPShUPTEsW10pLHR0PVtdLGV0PVtdLG50PVtdLGl0PVtdLHJ0PVtdO2ZvcihyPTA7cjxYO3IrKyl7dmFyIGx0PVJbcl07byhsdCxRW2x0XS5sYWJlbCksWio9V1tyXSxUKj1XW3JdO3ZhciBzdD1bXTtmb3IobD0wO2w8V1tyXTtsKyspZm9yKHZhciBhdCBpbiBRW1Jbcl1dLmNhdGVnb3J5LmluZGV4KWlmKFFbUltyXV0uY2F0ZWdvcnkuaW5kZXhbYXRdPT09bCl7dmFyIG90PVwiaWRcIiE9PXQuY29udGVudCYmUVtSW3JdXS5jYXRlZ29yeS5sYWJlbD9RW1Jbcl1dLmNhdGVnb3J5LmxhYmVsW2F0XTphdDtzdC5wdXNoKG90KX1ZLnB1c2goc3QpLCQucHVzaChUKX1mb3IodSh0LnZsYWJlbCx0LnNsYWJlbCxwKSxhPVkubGVuZ3RoLHI9MDtyPGE7cisrKXtmb3IodmFyIHV0PVtdLGh0PTAsZnQ9WVtyXS5sZW5ndGg7aHQ8ZnQ7aHQrKylmb3IodmFyIGN0PTA7Y3Q8Wi8kW3JdO2N0KyspdXQucHVzaChZW3JdW2h0XSk7dHQucHVzaCh1dCl9Zm9yKGE9dHQubGVuZ3RoLHI9MDtyPGE7cisrKXt2YXIgZHQ9W10sdnQ9MDtmb3Iocz0wO3M8WjtzKyspZHQucHVzaCh0dFtyXVt2dF0pLCsrdnQ9PT10dFtyXS5sZW5ndGgmJih2dD0wKTtldC5wdXNoKGR0KX1mb3Iocz0wO3M8WjtzKyspe3ZhciB5dD1bXTthPXR0Lmxlbmd0aDtmb3IodmFyIHB0PTA7cHQ8YTtwdCsrKWgoZXRbcHRdW3NdKTtwJiZoKHRoaXMuc3RhdHVzP3RoaXMuc3RhdHVzW3NdOm51bGwpLGYodGhpcy52YWx1ZVtzXSl9cmV0dXJuXCJvYmplY3RcIj09PXQudHlwZT97Y29sczppdCxyb3dzOnJ0fTpudH0sdC5wcm90b3R5cGUubm9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fdHJlZV9ffSx0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfTtleHBvcnR7ciBhcyBkZWZhdWx0fTtcbiIsIi8qKlxuICogW1NpbXBsZSBsaW5lYXIgcmVncmVzc2lvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfbGluZWFyX3JlZ3Jlc3Npb24pXG4gKiBpcyBhIHNpbXBsZSB3YXkgdG8gZmluZCBhIGZpdHRlZCBsaW5lXG4gKiBiZXR3ZWVuIGEgc2V0IG9mIGNvb3JkaW5hdGVzLiBUaGlzIGFsZ29yaXRobSBmaW5kcyB0aGUgc2xvcGUgYW5kIHktaW50ZXJjZXB0IG9mIGEgcmVncmVzc2lvbiBsaW5lXG4gKiB1c2luZyB0aGUgbGVhc3Qgc3VtIG9mIHNxdWFyZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGF0YSBhbiBhcnJheSBvZiB0d28tZWxlbWVudCBvZiBhcnJheXMsXG4gKiBsaWtlIGBbWzAsIDFdLCBbMiwgM11dYFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgc2xvcGUgYW5kIGludGVyc2VjdCBvZiByZWdyZXNzaW9uIGxpbmVcbiAqIEBleGFtcGxlXG4gKiBsaW5lYXJSZWdyZXNzaW9uKFtbMCwgMF0sIFsxLCAxXV0pOyAvLyA9PiB7IG06IDEsIGI6IDAgfVxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uKGRhdGEpIHtcbiAgICB2YXIgbTtcbiAgICB2YXIgYjtcblxuICAgIC8vIFN0b3JlIGRhdGEgbGVuZ3RoIGluIGEgbG9jYWwgdmFyaWFibGUgdG8gcmVkdWNlXG4gICAgLy8gcmVwZWF0ZWQgb2JqZWN0IHByb3BlcnR5IGxvb2t1cHNcbiAgICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgLy9pZiB0aGVyZSdzIG9ubHkgb25lIHBvaW50LCBhcmJpdHJhcmlseSBjaG9vc2UgYSBzbG9wZSBvZiAwXG4gICAgLy9hbmQgYSB5LWludGVyY2VwdCBvZiB3aGF0ZXZlciB0aGUgeSBvZiB0aGUgaW5pdGlhbCBwb2ludCBpc1xuICAgIGlmIChkYXRhTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBiID0gZGF0YVswXVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbml0aWFsaXplIG91ciBzdW1zIGFuZCBzY29wZSB0aGUgYG1gIGFuZCBgYmBcbiAgICAgICAgLy8gdmFyaWFibGVzIHRoYXQgZGVmaW5lIHRoZSBsaW5lLlxuICAgICAgICB2YXIgc3VtWCA9IDA7XG4gICAgICAgIHZhciBzdW1ZID0gMDtcbiAgICAgICAgdmFyIHN1bVhYID0gMDtcbiAgICAgICAgdmFyIHN1bVhZID0gMDtcblxuICAgICAgICAvLyBVc2UgbG9jYWwgdmFyaWFibGVzIHRvIGdyYWIgcG9pbnQgdmFsdWVzXG4gICAgICAgIC8vIHdpdGggbWluaW1hbCBvYmplY3QgcHJvcGVydHkgbG9va3Vwc1xuICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcblxuICAgICAgICAvLyBHYXRoZXIgdGhlIHN1bSBvZiBhbGwgeCB2YWx1ZXMsIHRoZSBzdW0gb2YgYWxsXG4gICAgICAgIC8vIHkgdmFsdWVzLCBhbmQgdGhlIHN1bSBvZiB4XjIgYW5kICh4KnkpIGZvciBlYWNoXG4gICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBtYXRoIG5vdGF0aW9uLCB0aGVzZSB3b3VsZCBiZSBTU194LCBTU195LCBTU194eCwgYW5kIFNTX3h5XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgICAgICAgICB4ID0gcG9pbnRbMF07XG4gICAgICAgICAgICB5ID0gcG9pbnRbMV07XG5cbiAgICAgICAgICAgIHN1bVggKz0geDtcbiAgICAgICAgICAgIHN1bVkgKz0geTtcblxuICAgICAgICAgICAgc3VtWFggKz0geCAqIHg7XG4gICAgICAgICAgICBzdW1YWSArPSB4ICogeTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBtYCBpcyB0aGUgc2xvcGUgb2YgdGhlIHJlZ3Jlc3Npb24gbGluZVxuICAgICAgICBtID1cbiAgICAgICAgICAgIChkYXRhTGVuZ3RoICogc3VtWFkgLSBzdW1YICogc3VtWSkgL1xuICAgICAgICAgICAgKGRhdGFMZW5ndGggKiBzdW1YWCAtIHN1bVggKiBzdW1YKTtcblxuICAgICAgICAvLyBgYmAgaXMgdGhlIHktaW50ZXJjZXB0IG9mIHRoZSBsaW5lLlxuICAgICAgICBiID0gc3VtWSAvIGRhdGFMZW5ndGggLSAobSAqIHN1bVgpIC8gZGF0YUxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYm90aCB2YWx1ZXMgYXMgYW4gb2JqZWN0LlxuICAgIHJldHVybiB7XG4gICAgICAgIG06IG0sXG4gICAgICAgIGI6IGJcbiAgICB9O1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBvdXRwdXQgb2YgYGxpbmVhclJlZ3Jlc3Npb25gOiBhbiBvYmplY3RcbiAqIHdpdGggYG1gIGFuZCBgYmAgdmFsdWVzIGluZGljYXRpbmcgc2xvcGUgYW5kIGludGVyY2VwdCxcbiAqIHJlc3BlY3RpdmVseSwgZ2VuZXJhdGUgYSBsaW5lIGZ1bmN0aW9uIHRoYXQgdHJhbnNsYXRlc1xuICogeCB2YWx1ZXMgaW50byB5IHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWIgb2JqZWN0IHdpdGggYG1gIGFuZCBgYmAgbWVtYmVycywgcmVwcmVzZW50aW5nXG4gKiBzbG9wZSBhbmQgaW50ZXJzZWN0IG9mIGRlc2lyZWQgbGluZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBtZXRob2QgdGhhdCBjb21wdXRlcyB5LXZhbHVlIGF0IGFueSBnaXZlblxuICogeC12YWx1ZSBvbiB0aGUgbGluZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbCA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24oW1swLCAwXSwgWzEsIDFdXSkpO1xuICogbCgwKSAvLyA9IDBcbiAqIGwoMikgLy8gPSAyXG4gKiBsaW5lYXJSZWdyZXNzaW9uTGluZSh7IGI6IDAsIG06IDEgfSkoMSk7IC8vID0+IDFcbiAqIGxpbmVhclJlZ3Jlc3Npb25MaW5lKHsgYjogMSwgbTogMSB9KSgxKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBsaW5lYXJSZWdyZXNzaW9uTGluZShtYiAvKjogeyBiOiBudW1iZXIsIG06IG51bWJlciB9Ki8pIHtcbiAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIGEgYHlgIHZhbHVlIGZvciBlYWNoXG4gICAgLy8geCB2YWx1ZSBpdCBpcyBnaXZlbiwgYmFzZWQgb24gdGhlIHZhbHVlcyBvZiBgYmAgYW5kIGBhYFxuICAgIC8vIHRoYXQgd2UganVzdCBjb21wdXRlZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG1iLmIgKyBtYi5tICogeDtcbiAgICB9O1xufVxuXG4vKipcbiAqIE91ciBkZWZhdWx0IHN1bSBpcyB0aGUgW0thaGFuLUJhYnVza2EgYWxnb3JpdGhtXShodHRwczovL3BkZnMuc2VtYW50aWNzY2hvbGFyLm9yZy8xNzYwLzdkNDY3Y2RhMWQwMjc3YWQyNzJkZWIyMTEzNTMzMTMxZGMwOS5wZGYpLlxuICogVGhpcyBtZXRob2QgaXMgYW4gaW1wcm92ZW1lbnQgb3ZlciB0aGUgY2xhc3NpY2FsXG4gKiBbS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FoYW5fc3VtbWF0aW9uX2FsZ29yaXRobSkuXG4gKiBJdCBhaW1zIGF0IGNvbXB1dGluZyB0aGUgc3VtIG9mIGEgbGlzdCBvZiBudW1iZXJzIHdoaWxlIGNvcnJlY3RpbmcgZm9yXG4gKiBmbG9hdGluZy1wb2ludCBlcnJvcnMuIFRyYWRpdGlvbmFsbHksIHN1bXMgYXJlIGNhbGN1bGF0ZWQgYXMgbWFueVxuICogc3VjY2Vzc2l2ZSBhZGRpdGlvbnMsIGVhY2ggb25lIHdpdGggaXRzIG93biBmbG9hdGluZy1wb2ludCByb3VuZG9mZi4gVGhlc2VcbiAqIGxvc3NlcyBpbiBwcmVjaXNpb24gYWRkIHVwIGFzIHRoZSBudW1iZXIgb2YgbnVtYmVycyBpbmNyZWFzZXMuIFRoaXMgYWx0ZXJuYXRpdmVcbiAqIGFsZ29yaXRobSBpcyBtb3JlIGFjY3VyYXRlIHRoYW4gdGhlIHNpbXBsZSB3YXkgb2YgY2FsY3VsYXRpbmcgc3VtcyBieSBzaW1wbGVcbiAqIGFkZGl0aW9uLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHN1bSBvZiBhbGwgaW5wdXQgbnVtYmVyc1xuICogQGV4YW1wbGVcbiAqIHN1bShbMSwgMiwgM10pOyAvLyA9PiA2XG4gKi9cbmZ1bmN0aW9uIHN1bSh4KSB7XG4gICAgLy8gSWYgdGhlIGFycmF5IGlzIGVtcHR5LCB3ZSBuZWVkbid0IGJvdGhlciBjb21wdXRpbmcgaXRzIHN1bVxuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIHN1bSBhcyB0aGUgZmlyc3QgbnVtYmVyIGluIHRoZSBhcnJheVxuICAgIHZhciBzdW0gPSB4WzBdO1xuXG4gICAgLy8gS2VlcGluZyB0cmFjayBvZiB0aGUgZmxvYXRpbmctcG9pbnQgZXJyb3IgY29ycmVjdGlvblxuICAgIHZhciBjb3JyZWN0aW9uID0gMDtcblxuICAgIHZhciB0cmFuc2l0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBzdW0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeFtpXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNpdGlvbiA9IHN1bSArIHhbaV07XG5cbiAgICAgICAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY29ycmVjdGlvbiBpbiBhIGRpZmZlcmVudCBmYXNoaW9uXG4gICAgICAgIC8vIGlmIHRoZSBuZXcgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBhYnNvbHV0ZSBzdW1cbiAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPj0gTWF0aC5hYnMoeFtpXSkpIHtcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gKz0gc3VtIC0gdHJhbnNpdGlvbiArIHhbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3JyZWN0aW9uICs9IHhbaV0gLSB0cmFuc2l0aW9uICsgc3VtO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VtID0gdHJhbnNpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5pbmcgdGhlIGNvcnJlY3RlZCBzdW1cbiAgICByZXR1cm4gc3VtICsgY29ycmVjdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgbWVhbiwgX2Fsc28ga25vd24gYXMgYXZlcmFnZV8sXG4gKiBpcyB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMgb3ZlciB0aGUgbnVtYmVyIG9mIHZhbHVlcy5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQHJldHVybnMge251bWJlcn0gbWVhblxuICogQGV4YW1wbGVcbiAqIG1lYW4oWzAsIDEwXSk7IC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gbWVhbih4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSh4KSAvIHgubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBzdW0gb2YgZGV2aWF0aW9ucyB0byB0aGUgTnRoIHBvd2VyLlxuICogV2hlbiBuPTIgaXQncyB0aGUgc3VtIG9mIHNxdWFyZWQgZGV2aWF0aW9ucy5cbiAqIFdoZW4gbj0zIGl0J3MgdGhlIHN1bSBvZiBjdWJlZCBkZXZpYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geFxuICogQHBhcmFtIHtudW1iZXJ9IG4gcG93ZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHN1bSBvZiBudGggcG93ZXIgZGV2aWF0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5wdXQgPSBbMSwgMiwgM107XG4gKiAvLyBzaW5jZSB0aGUgdmFyaWFuY2Ugb2YgYSBzZXQgaXMgdGhlIG1lYW4gc3F1YXJlZFxuICogLy8gZGV2aWF0aW9ucywgd2UgY2FuIGNhbGN1bGF0ZSB0aGF0IHdpdGggc3VtTnRoUG93ZXJEZXZpYXRpb25zOlxuICogc3VtTnRoUG93ZXJEZXZpYXRpb25zKGlucHV0LCAyKSAvIGlucHV0Lmxlbmd0aDtcbiAqL1xuZnVuY3Rpb24gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgsIG4pIHtcbiAgICB2YXIgbWVhblZhbHVlID0gbWVhbih4KTtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgdGVtcFZhbHVlO1xuICAgIHZhciBpO1xuXG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb246IHdoZW4gbiBpcyAyICh3ZSdyZSBjb21wdXRpbmcgYSBudW1iZXIgc3F1YXJlZCksXG4gICAgLy8gbXVsdGlwbHlpbmcgdGhlIG51bWJlciBieSBpdHNlbGYgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiB1c2luZ1xuICAgIC8vIHRoZSBNYXRoLnBvdyBtZXRob2QuXG4gICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgICAgICBzdW0gKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4W2ldIC0gbWVhblZhbHVlLCBuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdW07XG59XG5cbi8qKlxuICogVGhlIFt2YXJpYW5jZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYW5jZSlcbiAqIGlzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW4uXG4gKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB2YXJpYW5jZSwgbm90IHNhbXBsZSB2YXJpYW5jZTpcbiAqIHNlZSB0aGUgYHNhbXBsZVZhcmlhbmNlYCBtZXRob2QgaWYgeW91IHdhbnQgYSBzYW1wbGUgbWVhc3VyZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBwb3B1bGF0aW9uIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB2YXJpYW5jZTogYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cbiAqIHplcm8gaW5kaWNhdGVzIHRoYXQgYWxsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHgncyBsZW5ndGggaXMgMFxuICogQGV4YW1wbGVcbiAqIHZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1LCA2XSk7IC8vID0+IDIuOTE2NjY2NjY2NjY2NjY2NVxuICovXG5mdW5jdGlvbiB2YXJpYW5jZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIG1lYW4gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGJldHdlZW4gdGhlXG4gICAgLy8gbWVhbiB2YWx1ZSBhbmQgZWFjaCB2YWx1ZS5cbiAgICByZXR1cm4gc3VtTnRoUG93ZXJEZXZpYXRpb25zKHgsIDIpIC8geC5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIFtzdGFuZGFyZCBkZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfZGV2aWF0aW9uKVxuICogaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YXJpYW5jZS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIHRoZSBwb3B1bGF0aW9uXG4gKiBzdGFuZGFyZCBkZXZpYXRpb24uIEl0J3MgdXNlZnVsIGZvciBtZWFzdXJpbmcgdGhlIGFtb3VudFxuICogb2YgdmFyaWF0aW9uIG9yIGRpc3BlcnNpb24gaW4gYSBzZXQgb2YgdmFsdWVzLlxuICpcbiAqIFN0YW5kYXJkIGRldmlhdGlvbiBpcyBvbmx5IGFwcHJvcHJpYXRlIGZvciBmdWxsLXBvcHVsYXRpb24ga25vd2xlZGdlOiBmb3JcbiAqIHNhbXBsZXMgb2YgYSBwb3B1bGF0aW9uLCB7QGxpbmsgc2FtcGxlU3RhbmRhcmREZXZpYXRpb259IGlzXG4gKiBtb3JlIGFwcHJvcHJpYXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc3RhbmRhcmQgZGV2aWF0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyaWFuY2UoWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gNFxuICogc3RhbmRhcmREZXZpYXRpb24oWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBzdGFuZGFyZERldmlhdGlvbih4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgdiA9IHZhcmlhbmNlKHgpO1xuICAgIHJldHVybiBNYXRoLnNxcnQodik7XG59XG5cbi8qKlxuICogVGhlIFtSIFNxdWFyZWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29lZmZpY2llbnRfb2ZfZGV0ZXJtaW5hdGlvbilcbiAqIHZhbHVlIG9mIGRhdGEgY29tcGFyZWQgd2l0aCBhIGZ1bmN0aW9uIGBmYFxuICogaXMgdGhlIHN1bSBvZiB0aGUgc3F1YXJlZCBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBwcmVkaWN0aW9uXG4gKiBhbmQgdGhlIGFjdHVhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSB4IGlucHV0IGRhdGE6IHRoaXMgc2hvdWxkIGJlIGRvdWJseS1uZXN0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gY2FsbGVkIG9uIGBbaV1bMF1gIHZhbHVlcyB3aXRoaW4gdGhlIGRhdGFzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHItc3F1YXJlZCB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIHZhciBzYW1wbGVzID0gW1swLCAwXSwgWzEsIDFdXTtcbiAqIHZhciByZWdyZXNzaW9uTGluZSA9IGxpbmVhclJlZ3Jlc3Npb25MaW5lKGxpbmVhclJlZ3Jlc3Npb24oc2FtcGxlcykpO1xuICogclNxdWFyZWQoc2FtcGxlcywgcmVncmVzc2lvbkxpbmUpOyAvLyA9IDEgdGhpcyBsaW5lIGlzIGEgcGVyZmVjdCBmaXRcbiAqL1xuZnVuY3Rpb24gclNxdWFyZWQoeCwgZnVuYykge1xuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXZlcmFnZSB5IHZhbHVlIGZvciB0aGUgYWN0dWFsXG4gICAgLy8gZGF0YSBzZXQgaW4gb3JkZXIgdG8gY29tcHV0ZSB0aGVcbiAgICAvLyBfdG90YWwgc3VtIG9mIHNxdWFyZXNfXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSB4W2ldWzFdO1xuICAgIH1cbiAgICB2YXIgYXZlcmFnZSA9IHN1bSAvIHgubGVuZ3RoO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgdG90YWwgc3VtIG9mIHNxdWFyZXMgLSB0aGVcbiAgICAvLyBzcXVhcmVkIGRpZmZlcmVuY2UgYmV0d2VlbiBlYWNoIHBvaW50XG4gICAgLy8gYW5kIHRoZSBhdmVyYWdlIG9mIGFsbCBwb2ludHMuXG4gICAgdmFyIHN1bU9mU3F1YXJlcyA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB4Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bU9mU3F1YXJlcyArPSBNYXRoLnBvdyhhdmVyYWdlIC0geFtqXVsxXSwgMik7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSBlc3RpbWF0ZSB0aGUgZXJyb3I6IHRoZSBzcXVhcmVkXG4gICAgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBlc3RpbWF0ZSBhbmQgdGhlIGFjdHVhbCBkYXRhXG4gICAgLy8gdmFsdWUgYXQgZWFjaCBwb2ludC5cbiAgICB2YXIgZXJyID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHgubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgZXJyICs9IE1hdGgucG93KHhba11bMV0gLSBmdW5jKHhba11bMF0pLCAyKTtcbiAgICB9XG5cbiAgICAvLyBBcyB0aGUgZXJyb3IgZ3Jvd3MgbGFyZ2VyLCBpdHMgcmF0aW8gdG8gdGhlXG4gICAgLy8gc3VtIG9mIHNxdWFyZXMgaW5jcmVhc2VzIGFuZCB0aGUgciBzcXVhcmVkXG4gICAgLy8gdmFsdWUgZ3Jvd3MgbG93ZXIuXG4gICAgcmV0dXJuIDEgLSBlcnIgLyBzdW1PZlNxdWFyZXM7XG59XG5cbi8qKlxuICogVGhlIFttb2RlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2RlXyUyOHN0YXRpc3RpY3MlMjkpIGlzIHRoZSBudW1iZXJcbiAqIHRoYXQgYXBwZWFycyBpbiBhIGxpc3QgdGhlIGhpZ2hlc3QgbnVtYmVyIG9mIHRpbWVzLlxuICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIG1vZGVzIGluIGEgbGlzdDogaW4gdGhlIGV2ZW50IG9mIGEgdGllLCB0aGlzXG4gKiBhbGdvcml0aG0gd2lsbCByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgc2VlbiBtb2RlLlxuICpcbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgIGJlY2F1c2UgdGhlIGlucHV0IGlzIHNvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNvcnRlZCBhIHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gbW9kZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHNvcnRlZCBpcyBlbXB0eVxuICogQGV4YW1wbGVcbiAqIG1vZGVTb3J0ZWQoWzAsIDAsIDFdKTsgLy8gPT4gMFxuICovXG5mdW5jdGlvbiBtb2RlU29ydGVkKHNvcnRlZCkge1xuICAgIC8vIEhhbmRsZSBlZGdlIGNhc2VzOlxuICAgIC8vIFRoZSBtb2RlIG9mIGFuIGVtcHR5IGxpc3QgaXMgdW5kZWZpbmVkXG4gICAgaWYgKHNvcnRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG4gICAgaWYgKHNvcnRlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRlZFswXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGFzc3VtZXMgaXQgaXMgZGVhbGluZyB3aXRoIGFuIGFycmF5IG9mIHNpemUgPiAxLCBzaW5jZSBzaXplXG4gICAgLy8gMCBhbmQgMSBhcmUgaGFuZGxlZCBpbW1lZGlhdGVseS4gSGVuY2UgaXQgc3RhcnRzIGF0IGluZGV4IDEgaW4gdGhlXG4gICAgLy8gYXJyYXkuXG4gICAgdmFyIGxhc3QgPSBzb3J0ZWRbMF07XG4gICAgLy8gc3RvcmUgdGhlIG1vZGUgYXMgd2UgZmluZCBuZXcgbW9kZXNcbiAgICB2YXIgdmFsdWUgPSBOdW1iZXIuTmFOO1xuICAgIC8vIHN0b3JlIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHNlZW4gdGhlIG1vZGVcbiAgICB2YXIgbWF4U2VlbiA9IDA7XG4gICAgLy8gaG93IG1hbnkgdGltZXMgdGhlIGN1cnJlbnQgY2FuZGlkYXRlIGZvciB0aGUgbW9kZVxuICAgIC8vIGhhcyBiZWVuIHNlZW5cbiAgICB2YXIgc2VlblRoaXMgPSAxO1xuXG4gICAgLy8gZW5kIGF0IHNvcnRlZC5sZW5ndGggKyAxIHRvIGZpeCB0aGUgY2FzZSBpbiB3aGljaCB0aGUgbW9kZSBpc1xuICAgIC8vIHRoZSBoaWdoZXN0IG51bWJlciB0aGF0IG9jY3VycyBpbiB0aGUgc2VxdWVuY2UuIHRoZSBsYXN0IGl0ZXJhdGlvblxuICAgIC8vIGNvbXBhcmVzIHNvcnRlZFtpXSwgd2hpY2ggaXMgdW5kZWZpbmVkLCB0byB0aGUgaGlnaGVzdCBudW1iZXJcbiAgICAvLyBpbiB0aGUgc2VyaWVzXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzb3J0ZWQubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgIC8vIHdlJ3JlIHNlZWluZyBhIG5ldyBudW1iZXIgcGFzcyBieVxuICAgICAgICBpZiAoc29ydGVkW2ldICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAvLyB0aGUgbGFzdCBudW1iZXIgaXMgdGhlIG5ldyBtb2RlIHNpbmNlIHdlIHNhdyBpdCBtb3JlXG4gICAgICAgICAgICAvLyBvZnRlbiB0aGFuIHRoZSBvbGQgb25lXG4gICAgICAgICAgICBpZiAoc2VlblRoaXMgPiBtYXhTZWVuKSB7XG4gICAgICAgICAgICAgICAgbWF4U2VlbiA9IHNlZW5UaGlzO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5UaGlzID0gMTtcbiAgICAgICAgICAgIGxhc3QgPSBzb3J0ZWRbaV07XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzbid0IGEgbmV3IG51bWJlciwgaXQncyBvbmUgbW9yZSBvY2N1cnJlbmNlIG9mXG4gICAgICAgICAgICAvLyB0aGUgcG90ZW50aWFsIG1vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW5UaGlzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFNvcnQgYW4gYXJyYXkgb2YgbnVtYmVycyBieSB0aGVpciBudW1lcmljIHZhbHVlLCBlbnN1cmluZyB0aGF0IHRoZVxuICogYXJyYXkgaXMgbm90IGNoYW5nZWQgaW4gcGxhY2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiAuc29ydFxuICogaW4gSmF2YVNjcmlwdCBpcyB0byBzb3J0IGFycmF5cyBhcyBzdHJpbmcgdmFsdWVzXG4gKlxuICogICAgIFsxLCAxMCwgMTIsIDEwMiwgMjBdLnNvcnQoKVxuICogICAgIC8vIG91dHB1dFxuICogICAgIFsxLCAxMCwgMTAyLCAxMiwgMjBdXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBzb3J0ZWQgYXJyYXlcbiAqIEBwcml2YXRlXG4gKiBAZXhhbXBsZVxuICogbnVtZXJpY1NvcnQoWzMsIDIsIDFdKSAvLyA9PiBbMSwgMiwgM11cbiAqL1xuZnVuY3Rpb24gbnVtZXJpY1NvcnQoeCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHhcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgYXJyYXkgaXMgbm90IGNoYW5nZWQgaW4tcGxhY2VcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAvLyBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYXQgdHJlYXRzIGlucHV0IGFzIG51bWVyaWNcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSlcbiAgICApO1xufVxuXG4vKipcbiAqIFRoZSBbbW9kZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kZV8lMjhzdGF0aXN0aWNzJTI5KSBpcyB0aGUgbnVtYmVyXG4gKiB0aGF0IGFwcGVhcnMgaW4gYSBsaXN0IHRoZSBoaWdoZXN0IG51bWJlciBvZiB0aW1lcy5cbiAqIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSBtb2RlcyBpbiBhIGxpc3Q6IGluIHRoZSBldmVudCBvZiBhIHRpZSwgdGhpc1xuICogYWxnb3JpdGhtIHdpbGwgcmV0dXJuIHRoZSBtb3N0IHJlY2VudGx5IHNlZW4gbW9kZS5cbiAqXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4gbG9nKG4pKWAgYmVjYXVzZSBpdCBuZWVkcyB0byBzb3J0IHRoZSBhcnJheSBpbnRlcm5hbGx5XG4gKiBiZWZvcmUgcnVubmluZyBhbiBgTyhuKWAgc2VhcmNoIHRvIGZpbmQgdGhlIG1vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtb2RlXG4gKiBAZXhhbXBsZVxuICogbW9kZShbMCwgMCwgMV0pOyAvLyA9PiAwXG4gKi9cbmZ1bmN0aW9uIG1vZGUoeCkge1xuICAgIC8vIFNvcnRpbmcgdGhlIGFycmF5IGxldHMgdXMgaXRlcmF0ZSB0aHJvdWdoIGl0IGJlbG93IGFuZCBiZSBzdXJlXG4gICAgLy8gdGhhdCBldmVyeSB0aW1lIHdlIHNlZSBhIG5ldyBudW1iZXIgaXQncyBuZXcgYW5kIHdlJ2xsIG5ldmVyXG4gICAgLy8gc2VlIHRoZSBzYW1lIG51bWJlciB0d2ljZVxuICAgIHJldHVybiBtb2RlU29ydGVkKG51bWVyaWNTb3J0KHgpKTtcbn1cblxuLyogZ2xvYmFscyBNYXA6IGZhbHNlICovXG5cbi8qKlxuICogVGhlIFttb2RlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2RlXyUyOHN0YXRpc3RpY3MlMjkpIGlzIHRoZSBudW1iZXJcbiAqIHRoYXQgYXBwZWFycyBpbiBhIGxpc3QgdGhlIGhpZ2hlc3QgbnVtYmVyIG9mIHRpbWVzLlxuICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIG1vZGVzIGluIGEgbGlzdDogaW4gdGhlIGV2ZW50IG9mIGEgdGllLCB0aGlzXG4gKiBhbGdvcml0aG0gd2lsbCByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgc2VlbiBtb2RlLlxuICpcbiAqIG1vZGVGYXN0IHVzZXMgYSBNYXAgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIG1vZGUsIGluc3RlYWQgb2YgdGhlIGFwcHJvYWNoXG4gKiB1c2VkIHdpdGggYG1vZGVgLCBhIHNvcnRlZCBhcnJheS4gQXMgYSByZXN1bHQsIGl0IGlzIGZhc3RlclxuICogdGhhbiBgbW9kZWAgYW5kIHN1cHBvcnRzIGFueSBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBgPT1gLlxuICogSXQgYWxzbyByZXF1aXJlcyBhXG4gKiBbSmF2YVNjcmlwdCBlbnZpcm9ubWVudCB3aXRoIHN1cHBvcnQgZm9yIE1hcF0oaHR0cHM6Ly9rYW5nYXguZ2l0aHViLmlvL2NvbXBhdC10YWJsZS9lczYvI3Rlc3QtTWFwKSxcbiAqIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIE1hcCBpcyBub3QgYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB4IGEgc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7Pyp9IG1vZGVcbiAqIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBpZiB0aGUgSmF2YVNjcmlwdCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgTWFwXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBpcyBlbXB0eVxuICogQGV4YW1wbGVcbiAqIG1vZGVGYXN0KFsncmFiYml0cycsICdyYWJiaXRzJywgJ3NxdWlycmVscyddKTsgLy8gPT4gJ3JhYmJpdHMnXG4gKi9cbmZ1bmN0aW9uIG1vZGVGYXN0KHgpIHtcbiAgICAvLyBUaGlzIGluZGV4IHdpbGwgcmVmbGVjdCB0aGUgaW5jaWRlbmNlIG9mIGRpZmZlcmVudCB2YWx1ZXMsIGluZGV4aW5nXG4gICAgLy8gdGhlbSBsaWtlXG4gICAgLy8geyB2YWx1ZTogY291bnQgfVxuICAgIHZhciBpbmRleCA9IG5ldyBNYXAoKTtcblxuICAgIC8vIEEgcnVubmluZyBgbW9kZWAgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgaXQgaGFzIGJlZW4gZW5jb3VudGVyZWQuXG4gICAgdmFyIG1vZGU7XG4gICAgdmFyIG1vZGVDb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NvdW50ID0gaW5kZXguZ2V0KHhbaV0pO1xuICAgICAgICBpZiAobmV3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3Q291bnQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q291bnQgPiBtb2RlQ291bnQpIHtcbiAgICAgICAgICAgIG1vZGUgPSB4W2ldO1xuICAgICAgICAgICAgbW9kZUNvdW50ID0gbmV3Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXguc2V0KHhbaV0sIG5ld0NvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobW9kZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGUgcmVxdWlyZXMgYXQgbGFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZTtcbn1cblxuLyoqXG4gKiBUaGUgbWluIGlzIHRoZSBsb3dlc3QgbnVtYmVyIGluIHRoZSBhcnJheS5cbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gb25lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtaW5pbXVtIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogbWluKFsxLCA1LCAtMTAsIDEwMCwgMl0pOyAvLyA9PiAtMTBcbiAqL1xuZnVuY3Rpb24gbWluKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWluIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHhbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0geFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBjb21wdXRlcyB0aGUgbWF4aW11bSBudW1iZXIgaW4gYW4gYXJyYXkuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtYXhpbXVtIHZhbHVlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEBleGFtcGxlXG4gKiBtYXgoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IDRcbiAqL1xuZnVuY3Rpb24gbWF4KHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHhbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldID4gdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0geFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBjb21wdXRlcyB0aGUgbWluaW11bSAmIG1heGltdW0gbnVtYmVyIGluIGFuIGFycmF5LlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IG1pbmltdW0gJiBtYXhpbXVtIHZhbHVlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEBleGFtcGxlXG4gKiBleHRlbnQoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFsxLCA0XVxuICovXG5mdW5jdGlvbiBleHRlbnQoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnQgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IHhbMF07XG4gICAgdmFyIG1heCA9IHhbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB4W2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4W2ldIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSB4W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWluLCBtYXhdO1xufVxuXG4vKipcbiAqIFRoZSBtaW5pbXVtIGlzIHRoZSBsb3dlc3QgbnVtYmVyIGluIHRoZSBhcnJheS4gV2l0aCBhIHNvcnRlZCBhcnJheSxcbiAqIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBhbHdheXMgdGhlIHNtYWxsZXN0LCBzbyB0aGlzIGNhbGN1bGF0aW9uXG4gKiBjYW4gYmUgZG9uZSBpbiBvbmUgc3RlcCwgb3IgY29uc3RhbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1pbmltdW0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtaW5Tb3J0ZWQoWy0xMDAsIC0xMCwgMSwgMiwgNV0pOyAvLyA9PiAtMTAwXG4gKi9cbmZ1bmN0aW9uIG1pblNvcnRlZCh4KSB7XG4gICAgcmV0dXJuIHhbMF07XG59XG5cbi8qKlxuICogVGhlIG1heGltdW0gaXMgdGhlIGhpZ2hlc3QgbnVtYmVyIGluIHRoZSBhcnJheS4gV2l0aCBhIHNvcnRlZCBhcnJheSxcbiAqIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIGFsd2F5cyB0aGUgbGFyZ2VzdCwgc28gdGhpcyBjYWxjdWxhdGlvblxuICogY2FuIGJlIGRvbmUgaW4gb25lIHN0ZXAsIG9yIGNvbnN0YW50IHRpbWUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtYXhpbXVtIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogbWF4U29ydGVkKFstMTAwLCAtMTAsIDEsIDIsIDVdKTsgLy8gPT4gNVxuICovXG5mdW5jdGlvbiBtYXhTb3J0ZWQoeCkge1xuICAgIHJldHVybiB4W3gubGVuZ3RoIC0gMV07XG59XG5cbi8qKlxuICogVGhlIGV4dGVudCBpcyB0aGUgbG93ZXN0ICYgaGlnaGVzdCBudW1iZXIgaW4gdGhlIGFycmF5LiBXaXRoIGEgc29ydGVkIGFycmF5LFxuICogdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIGFsd2F5cyB0aGUgbG93ZXN0IHdoaWxlIHRoZSBsYXN0IGVsZW1lbnQgaXMgYWx3YXlzIHRoZSBsYXJnZXN0LCBzbyB0aGlzIGNhbGN1bGF0aW9uXG4gKiBjYW4gYmUgZG9uZSBpbiBvbmUgc3RlcCwgb3IgY29uc3RhbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBtaW5pbXVtICYgbWF4aW11bSB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIGV4dGVudFNvcnRlZChbLTEwMCwgLTEwLCAxLCAyLCA1XSk7IC8vID0+IFstMTAwLCA1XVxuICovXG5mdW5jdGlvbiBleHRlbnRTb3J0ZWQoeCkge1xuICAgIHJldHVybiBbeFswXSwgeFt4Lmxlbmd0aCAtIDFdXTtcbn1cblxuLyoqXG4gKiBUaGUgc2ltcGxlIFtzdW1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1bW1hdGlvbikgb2YgYW4gYXJyYXlcbiAqIGlzIHRoZSByZXN1bHQgb2YgYWRkaW5nIGFsbCBudW1iZXJzIHRvZ2V0aGVyLCBzdGFydGluZyBmcm9tIHplcm8uXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gc3VtIG9mIGFsbCBpbnB1dCBudW1iZXJzXG4gKiBAZXhhbXBsZVxuICogc3VtU2ltcGxlKFsxLCAyLCAzXSk7IC8vID0+IDZcbiAqL1xuZnVuY3Rpb24gc3VtU2ltcGxlKHgpIHtcbiAgICB2YXIgdmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIHhbaV0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IHhbaV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgW3Byb2R1Y3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2R1Y3RfKG1hdGhlbWF0aWNzKSkgb2YgYW4gYXJyYXlcbiAqIGlzIHRoZSByZXN1bHQgb2YgbXVsdGlwbHlpbmcgYWxsIG51bWJlcnMgdG9nZXRoZXIsIHN0YXJ0aW5nIHVzaW5nIG9uZSBhcyB0aGUgbXVsdGlwbGljYXRpdmUgaWRlbnRpdHkuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gcHJvZHVjdCBvZiBhbGwgaW5wdXQgbnVtYmVyc1xuICogQGV4YW1wbGVcbiAqIHByb2R1Y3QoWzEsIDIsIDMsIDRdKTsgLy8gPT4gMjRcbiAqL1xuZnVuY3Rpb24gcHJvZHVjdCh4KSB7XG4gICAgdmFyIHZhbHVlID0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgKj0geFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHF1YW50aWxlczogd2hlbiB5b3Uga25vd1xuICogdGhhdCB0aGUgb3JkZXIgaXMgc29ydGVkLCB5b3UgZG9uJ3QgbmVlZCB0byByZS1zb3J0IGl0LCBhbmQgdGhlIGNvbXB1dGF0aW9uc1xuICogYXJlIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gcCBkZXNpcmVkIHF1YW50aWxlOiBhIG51bWJlciBiZXR3ZWVuIDAgdG8gMSwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBxdWFudGlsZSB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHAgaXggb3V0c2lkZSBvZiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDFcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVTb3J0ZWQoWzMsIDYsIDcsIDgsIDgsIDksIDEwLCAxMywgMTUsIDE2LCAyMF0sIDAuNSk7IC8vID0+IDlcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQoeCwgcCkge1xuICAgIHZhciBpZHggPSB4Lmxlbmd0aCAqIHA7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInF1YW50aWxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50LlwiKTtcbiAgICB9IGVsc2UgaWYgKHAgPCAwIHx8IHAgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInF1YW50aWxlcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMVwiKTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFt4Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIDAsIGRpcmVjdGx5IHJldHVybiB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICByZXR1cm4geFswXTtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgcCBpcyBub3QgaW50ZWdlciwgcmV0dXJuIHRoZSBuZXh0IGVsZW1lbnQgaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHhbTWF0aC5jZWlsKGlkeCkgLSAxXTtcbiAgICB9IGVsc2UgaWYgKHgubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhpcyBudW1iZXJcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHZhbHVlLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgcmV0dXJuICh4W2lkeCAtIDFdICsgeFtpZHhdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgdmFsdWVcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgeCB2YWx1ZSBhdCB0aGUgaW5kZXguXG4gICAgICAgIHJldHVybiB4W2lkeF07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlYXJyYW5nZSBpdGVtcyBpbiBgYXJyYCBzbyB0aGF0IGFsbCBpdGVtcyBpbiBgW2xlZnQsIGtdYCByYW5nZSBhcmUgdGhlIHNtYWxsZXN0LlxuICogVGhlIGBrYC10aCBlbGVtZW50IHdpbGwgaGF2ZSB0aGUgYChrIC0gbGVmdCArIDEpYC10aCBzbWFsbGVzdCB2YWx1ZSBpbiBgW2xlZnQsIHJpZ2h0XWAuXG4gKlxuICogSW1wbGVtZW50cyBGbG95ZC1SaXZlc3Qgc2VsZWN0aW9uIGFsZ29yaXRobSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZC1SaXZlc3RfYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhcnIgaW5wdXQgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBrIHBpdm90IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW2xlZnRdIGxlZnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmlnaHRdIHJpZ2h0IGluZGV4XG4gKiBAcmV0dXJucyB7dm9pZH0gbXV0YXRlcyBpbnB1dCBhcnJheVxuICogQGV4YW1wbGVcbiAqIHZhciBhcnIgPSBbNjUsIDI4LCA1OSwgMzMsIDIxLCA1NiwgMjIsIDk1LCA1MCwgMTIsIDkwLCA1MywgMjgsIDc3LCAzOV07XG4gKiBxdWlja3NlbGVjdChhcnIsIDgpO1xuICogLy8gPSBbMzksIDI4LCAyOCwgMzMsIDIxLCAxMiwgMjIsIDUwLCA1MywgNTYsIDU5LCA2NSwgOTAsIDc3LCA5NV1cbiAqL1xuZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCkge1xuICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgcmlnaHQgPSByaWdodCB8fCBhcnIubGVuZ3RoIC0gMTtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgLy8gNjAwIGFuZCAwLjUgYXJlIGFyYml0cmFyeSBjb25zdGFudHMgY2hvc2VuIGluIHRoZSBvcmlnaW5hbCBwYXBlciB0byBtaW5pbWl6ZSBleGVjdXRpb24gdGltZVxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKCgyICogeikgLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCgoeiAqIHMgKiAobiAtIHMpKSAvIG4pO1xuICAgICAgICAgICAgaWYgKG0gLSBuIC8gMiA8IDApIHsgc2QgKj0gLTE7IH1cbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gKG0gKiBzKSAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcihrICsgKChuIC0gbSkgKiBzKSAvIG4gKyBzZClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gYXJyW2tdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoYXJyW3JpZ2h0XSA+IHQpIHsgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTsgfVxuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGFycltpXSA8IHQpIHsgaSsrOyB9XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2pdID4gdCkgeyBqLS07IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJbbGVmdF0gPT09IHQpIHsgc3dhcChhcnIsIGxlZnQsIGopOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIHsgbGVmdCA9IGogKyAxOyB9XG4gICAgICAgIGlmIChrIDw9IGopIHsgcmlnaHQgPSBqIC0gMTsgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbi8qKlxuICogVGhlIFtxdWFudGlsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUpOlxuICogdGhpcyBpcyBhIHBvcHVsYXRpb24gcXVhbnRpbGUsIHNpbmNlIHdlIGFzc3VtZSB0byBrbm93IHRoZSBlbnRpcmVcbiAqIGRhdGFzZXQgaW4gdGhpcyBsaWJyYXJ5LiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICogW1F1YW50aWxlcyBvZiBhIFBvcHVsYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhbnRpbGUjUXVhbnRpbGVzX29mX2FfcG9wdWxhdGlvbilcbiAqIGFsZ29yaXRobSBmcm9tIHdpa2lwZWRpYS5cbiAqXG4gKiBTYW1wbGUgaXMgYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2YgbnVtYmVycyxcbiAqIGFuZCBwIGlzIGVpdGhlciBhIGRlY2ltYWwgbnVtYmVyIGZyb20gMCB0byAxIG9yIGFuIGFycmF5IG9mIGRlY2ltYWxcbiAqIG51bWJlcnMgZnJvbSAwIHRvIDEuXG4gKiBJbiB0ZXJtcyBvZiBhIGsvcSBxdWFudGlsZSwgcCA9IGsvcSAtIGl0J3MganVzdCBkZWFsaW5nIHdpdGggZnJhY3Rpb25zIG9yIGRlYWxpbmdcbiAqIHdpdGggZGVjaW1hbCB2YWx1ZXMuXG4gKiBXaGVuIHAgaXMgYW4gYXJyYXksIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlzIGFsc28gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYXBwcm9wcmlhdGVcbiAqIHF1YW50aWxlcyBpbiBpbnB1dCBvcmRlclxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+IHwgbnVtYmVyfSBwIHRoZSBkZXNpcmVkIHF1YW50aWxlLCBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHF1YW50aWxlXG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGUoWzMsIDYsIDcsIDgsIDgsIDksIDEwLCAxMywgMTUsIDE2LCAyMF0sIDAuNSk7IC8vID0+IDlcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGUoeCwgcCkge1xuICAgIHZhciBjb3B5ID0geC5zbGljZSgpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocCkpIHtcbiAgICAgICAgLy8gcmVhcnJhbmdlIGVsZW1lbnRzIHNvIHRoYXQgZWFjaCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSByZXF1ZXN0ZWRcbiAgICAgICAgLy8gcXVhbnRpbGUgaXMgb24gYSBwbGFjZSBpdCB3b3VsZCBiZSBpZiB0aGUgYXJyYXkgd2FzIGZ1bGx5IHNvcnRlZFxuICAgICAgICBtdWx0aVF1YW50aWxlU2VsZWN0KGNvcHksIHApO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgLy8gRm9yIGVhY2ggcmVxdWVzdGVkIHF1YW50aWxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHF1YW50aWxlU29ydGVkKGNvcHksIHBbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBxdWFudGlsZUluZGV4KGNvcHkubGVuZ3RoLCBwKTtcbiAgICAgICAgcXVhbnRpbGVTZWxlY3QoY29weSwgaWR4LCAwLCBjb3B5Lmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gcXVhbnRpbGVTb3J0ZWQoY29weSwgcCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBxdWFudGlsZVNlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGsgJSAxID09PSAwKSB7XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSBNYXRoLmZsb29yKGspO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrICsgMSwgayArIDEsIHJpZ2h0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG11bHRpUXVhbnRpbGVTZWxlY3QoYXJyLCBwKSB7XG4gICAgdmFyIGluZGljZXMgPSBbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaChxdWFudGlsZUluZGV4KGFyci5sZW5ndGgsIHBbaV0pKTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKGFyci5sZW5ndGggLSAxKTtcbiAgICBpbmRpY2VzLnNvcnQoY29tcGFyZSk7XG5cbiAgICB2YXIgc3RhY2sgPSBbMCwgaW5kaWNlcy5sZW5ndGggLSAxXTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHIgPSBNYXRoLmNlaWwoc3RhY2sucG9wKCkpO1xuICAgICAgICB2YXIgbCA9IE1hdGguZmxvb3Ioc3RhY2sucG9wKCkpO1xuICAgICAgICBpZiAociAtIGwgPD0gMSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtID0gTWF0aC5mbG9vcigobCArIHIpIC8gMik7XG4gICAgICAgIHF1YW50aWxlU2VsZWN0KFxuICAgICAgICAgICAgYXJyLFxuICAgICAgICAgICAgaW5kaWNlc1ttXSxcbiAgICAgICAgICAgIE1hdGguZmxvb3IoaW5kaWNlc1tsXSksXG4gICAgICAgICAgICBNYXRoLmNlaWwoaW5kaWNlc1tyXSlcbiAgICAgICAgKTtcblxuICAgICAgICBzdGFjay5wdXNoKGwsIG0sIG0sIHIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBxdWFudGlsZUluZGV4KGxlbiwgcCkge1xuICAgIHZhciBpZHggPSBsZW4gKiBwO1xuICAgIGlmIChwID09PSAxKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMSwgZGlyZWN0bHkgcmV0dXJuIHRoZSBsYXN0IGluZGV4XG4gICAgICAgIHJldHVybiBsZW4gLSAxO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIDAsIGRpcmVjdGx5IHJldHVybiB0aGUgZmlyc3QgaW5kZXhcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChpZHggJSAxICE9PSAwKSB7XG4gICAgICAgIC8vIElmIGluZGV4IGlzIG5vdCBpbnRlZ2VyLCByZXR1cm4gdGhlIG5leHQgaW5kZXggaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChpZHgpIC0gMTtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDIgPT09IDApIHtcbiAgICAgICAgLy8gSWYgdGhlIGxpc3QgaGFzIGV2ZW4tbGVuZ3RoLCB3ZSdsbCByZXR1cm4gdGhlIG1pZGRsZSBvZiB0d28gaW5kaWNlc1xuICAgICAgICAvLyBhcm91bmQgcXVhbnRpbGUgdG8gaW5kaWNhdGUgdGhhdCB3ZSBuZWVkIGFuIGF2ZXJhZ2UgdmFsdWUgb2YgdGhlIHR3b1xuICAgICAgICByZXR1cm4gaWR4IC0gMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpbmFsbHksIGluIHRoZSBzaW1wbGUgY2FzZSBvZiBhbiBpbnRlZ2VyIGluZGV4XG4gICAgICAgIC8vIHdpdGggYW4gb2RkLWxlbmd0aCBsaXN0LCByZXR1cm4gdGhlIGluZGV4XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxufVxuXG4vKiBlc2xpbnQgbm8tYml0d2lzZTogMCAqL1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcXVhbnRpbGUgaW4gd2hpY2ggb25lIHdvdWxkIGZpbmQgdGhlIGdpdmVuIHZhbHVlIGluXG4gKiB0aGUgZ2l2ZW4gYXJyYXkuIFdpdGggYSBzb3J0ZWQgYXJyYXksIGxldmVyYWdpbmcgYmluYXJ5IHNlYXJjaCwgd2UgY2FuIGZpbmRcbiAqIHRoaXMgaW5mb3JtYXRpb24gaW4gbG9nYXJpdGhtaWMgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVSYW5rU29ydGVkKFsxLCAyLCAzLCA0XSwgMyk7IC8vID0+IDAuNzVcbiAqIHF1YW50aWxlUmFua1NvcnRlZChbMSwgMiwgMywgMywgNF0sIDMpOyAvLyA9PiAwLjdcbiAqIHF1YW50aWxlUmFua1NvcnRlZChbMSwgMiwgMywgNF0sIDYpOyAvLyA9PiAxXG4gKiBxdWFudGlsZVJhbmtTb3J0ZWQoWzEsIDIsIDMsIDMsIDVdLCA0KTsgLy8gPT4gMC44XG4gKi9cbmZ1bmN0aW9uIHF1YW50aWxlUmFua1NvcnRlZCh4LCB2YWx1ZSkge1xuICAgIC8vIFZhbHVlIGlzIGxlc3NlciB0aGFuIGFueSB2YWx1ZSBpbiB0aGUgYXJyYXlcbiAgICBpZiAodmFsdWUgPCB4WzBdKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIFZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBhbnkgdmFsdWUgaW4gdGhlIGFycmF5XG4gICAgaWYgKHZhbHVlID4geFt4Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBsID0gbG93ZXJCb3VuZCh4LCB2YWx1ZSk7XG5cbiAgICAvLyBWYWx1ZSBpcyBub3QgaW4gdGhlIGFycmF5XG4gICAgaWYgKHhbbF0gIT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsIC8geC5sZW5ndGg7XG4gICAgfVxuXG4gICAgbCsrO1xuXG4gICAgdmFyIHUgPSB1cHBlckJvdW5kKHgsIHZhbHVlKTtcblxuICAgIC8vIFRoZSB2YWx1ZSBleGlzdHMgb25seSBvbmNlIGluIHRoZSBhcnJheVxuICAgIGlmICh1ID09PSBsKSB7XG4gICAgICAgIHJldHVybiBsIC8geC5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gSGVyZSwgd2UgYXJlIGJhc2ljYWxseSBjb21wdXRpbmcgdGhlIG1lYW4gb2YgdGhlIHJhbmdlIG9mIGluZGljZXNcbiAgICAvLyBjb250YWluaW5nIG91ciBzZWFyY2hlZCB2YWx1ZS4gQnV0LCBpbnN0ZWFkLCBvZiBpbml0aWFsaXppbmcgYW5cbiAgICAvLyBhcnJheSBhbmQgbG9vcGluZyBvdmVyIGl0LCB0aGVyZSBpcyBhIGRlZGljYXRlZCBtYXRoIGZvcm11bGEgdGhhdFxuICAgIC8vIHdlIGFwcGx5IGJlbG93IHRvIGdldCB0aGUgcmVzdWx0LlxuICAgIHZhciByID0gdSAtIGwgKyAxO1xuICAgIHZhciBzdW0gPSAociAqICh1ICsgbCkpIC8gMjtcbiAgICB2YXIgbWVhbiA9IHN1bSAvIHI7XG5cbiAgICByZXR1cm4gbWVhbiAvIHgubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBsb3dlckJvdW5kKHgsIHZhbHVlKSB7XG4gICAgdmFyIG1pZCA9IDA7XG4gICAgdmFyIGxvID0gMDtcbiAgICB2YXIgaGkgPSB4Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcblxuICAgICAgICBpZiAodmFsdWUgPD0geFttaWRdKSB7XG4gICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvID0gLX5taWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIHVwcGVyQm91bmQoeCwgdmFsdWUpIHtcbiAgICB2YXIgbWlkID0gMDtcbiAgICB2YXIgbG8gPSAwO1xuICAgIHZhciBoaSA9IHgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuXG4gICAgICAgIGlmICh2YWx1ZSA+PSB4W21pZF0pIHtcbiAgICAgICAgICAgIGxvID0gLX5taWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsbztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHF1YW50aWxlIGluIHdoaWNoIG9uZSB3b3VsZCBmaW5kIHRoZSBnaXZlbiB2YWx1ZSBpblxuICogdGhlIGdpdmVuIGFycmF5LiBJdCB3aWxsIGNvcHkgYW5kIHNvcnQgeW91ciBhcnJheSBiZWZvcmUgZWFjaCBydW4sIHNvXG4gKiBpZiB5b3Uga25vdyB5b3VyIGFycmF5IGlzIGFscmVhZHkgc29ydGVkLCB5b3Ugc2hvdWxkIHVzZSBgcXVhbnRpbGVSYW5rU29ydGVkYFxuICogaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogcXVhbnRpbGVSYW5rKFs0LCAzLCAxLCAyXSwgMyk7IC8vID0+IDAuNzVcbiAqIHF1YW50aWxlUmFuayhbNCwgMywgMiwgMywgMV0sIDMpOyAvLyA9PiAwLjdcbiAqIHF1YW50aWxlUmFuayhbMiwgNCwgMSwgM10sIDYpOyAvLyA9PiAxXG4gKiBxdWFudGlsZVJhbmsoWzUsIDMsIDEsIDIsIDNdLCA0KTsgLy8gPT4gMC44XG4gKi9cbmZ1bmN0aW9uIHF1YW50aWxlUmFuayh4LCB2YWx1ZSkge1xuICAgIC8vIENsb25pbmcgYW5kIHNvcnRpbmcgdGhlIGFycmF5XG4gICAgdmFyIHNvcnRlZENvcHkgPSBudW1lcmljU29ydCh4KTtcblxuICAgIHJldHVybiBxdWFudGlsZVJhbmtTb3J0ZWQoc29ydGVkQ29weSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBbSW50ZXJxdWFydGlsZSByYW5nZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnF1YXJ0aWxlX3JhbmdlKSBpc1xuICogYSBtZWFzdXJlIG9mIHN0YXRpc3RpY2FsIGRpc3BlcnNpb24sIG9yIGhvdyBzY2F0dGVyZWQsIHNwcmVhZCwgb3JcbiAqIGNvbmNlbnRyYXRlZCBhIGRpc3RyaWJ1dGlvbiBpcy4gSXQncyBjb21wdXRlZCBhcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gKiB0aGUgdGhpcmQgcXVhcnRpbGUgYW5kIGZpcnN0IHF1YXJ0aWxlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHJldHVybnMge251bWJlcn0gaW50ZXJxdWFydGlsZSByYW5nZTogdGhlIHNwYW4gYmV0d2VlbiBsb3dlciBhbmQgdXBwZXIgcXVhcnRpbGUsXG4gKiAwLjI1IGFuZCAwLjc1XG4gKiBAZXhhbXBsZVxuICogaW50ZXJxdWFydGlsZVJhbmdlKFswLCAxLCAyLCAzXSk7IC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gaW50ZXJxdWFydGlsZVJhbmdlKHgpIHtcbiAgICAvLyBJbnRlcnF1YXJ0aWxlIHJhbmdlIGlzIHRoZSBzcGFuIGJldHdlZW4gdGhlIHVwcGVyIHF1YXJ0aWxlLFxuICAgIC8vIGF0IGAwLjc1YCwgYW5kIGxvd2VyIHF1YXJ0aWxlLCBgMC4yNWBcbiAgICB2YXIgcTEgPSBxdWFudGlsZSh4LCAwLjc1KTtcbiAgICB2YXIgcTIgPSBxdWFudGlsZSh4LCAwLjI1KTtcblxuICAgIGlmICh0eXBlb2YgcTEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHEyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBxMSAtIHEyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgW21lZGlhbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZWRpYW4pIGlzXG4gKiB0aGUgbWlkZGxlIG51bWJlciBvZiBhIGxpc3QuIFRoaXMgaXMgb2Z0ZW4gYSBnb29kIGluZGljYXRvciBvZiAndGhlIG1pZGRsZSdcbiAqIHdoZW4gdGhlcmUgYXJlIG91dGxpZXJzIHRoYXQgc2tldyB0aGUgYG1lYW4oKWAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhlIG1lZGlhbiBpc24ndCBuZWNlc3NhcmlseSBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBsaXN0OiB0aGUgdmFsdWVcbiAqIGNhbiBiZSB0aGUgYXZlcmFnZSBvZiB0d28gZWxlbWVudHMgaWYgdGhlIGxpc3QgaGFzIGFuIGV2ZW4gbGVuZ3RoXG4gKiBhbmQgdGhlIHR3byBjZW50cmFsIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gbWVkaWFuIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogbWVkaWFuKFsxMCwgMiwgNSwgMTAwLCAyLCAxXSk7IC8vID0+IDMuNVxuICovXG5mdW5jdGlvbiBtZWRpYW4oeCkge1xuICAgIHJldHVybiArcXVhbnRpbGUoeCwgMC41KTtcbn1cblxuLyoqXG4gKiBUaGUgW01lZGlhbiBBYnNvbHV0ZSBEZXZpYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVkaWFuX2Fic29sdXRlX2RldmlhdGlvbikgaXNcbiAqIGEgcm9idXN0IG1lYXN1cmUgb2Ygc3RhdGlzdGljYWxcbiAqIGRpc3BlcnNpb24uIEl0IGlzIG1vcmUgcmVzaWxpZW50IHRvIG91dGxpZXJzIHRoYW4gdGhlIHN0YW5kYXJkIGRldmlhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXQgYXJyYXlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1lZGlhbiBhYnNvbHV0ZSBkZXZpYXRpb25cbiAqIEBleGFtcGxlXG4gKiBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbihbMSwgMSwgMiwgMiwgNCwgNiwgOV0pOyAvLyA9PiAxXG4gKi9cbmZ1bmN0aW9uIG1lZGlhbkFic29sdXRlRGV2aWF0aW9uKHgpIHtcbiAgICB2YXIgbWVkaWFuVmFsdWUgPSBtZWRpYW4oeCk7XG4gICAgdmFyIG1lZGlhbkFic29sdXRlRGV2aWF0aW9ucyA9IFtdO1xuXG4gICAgLy8gTWFrZSBhIGxpc3Qgb2YgYWJzb2x1dGUgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWRpYW5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb25zLnB1c2goTWF0aC5hYnMoeFtpXSAtIG1lZGlhblZhbHVlKSk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgbWVkaWFuIHZhbHVlIG9mIHRoYXQgbGlzdFxuICAgIHJldHVybiBtZWRpYW4obWVkaWFuQWJzb2x1dGVEZXZpYXRpb25zKTtcbn1cblxuLyoqXG4gKiBTcGxpdCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBhIHNwZWNpZmllZCBzaXplLiBUaGlzIGZ1bmN0aW9uXG4gKiBoYXMgdGhlIHNhbWUgYmVoYXZpb3IgYXMgW1BIUCdzIGFycmF5X2NodW5rXShodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uYXJyYXktY2h1bmsucGhwKVxuICogZnVuY3Rpb24sIGFuZCB0aHVzIHdpbGwgaW5zZXJ0IHNtYWxsZXItc2l6ZWQgY2h1bmtzIGF0IHRoZSBlbmQgaWZcbiAqIHRoZSBpbnB1dCBzaXplIGlzIG5vdCBkaXZpc2libGUgYnkgdGhlIGNodW5rIHNpemUuXG4gKlxuICogYHhgIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5LCBhbmQgYGNodW5rU2l6ZWAgYSBudW1iZXIuXG4gKiBUaGUgYHhgIGFycmF5IGNhbiBjb250YWluIGFueSBraW5kIG9mIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBhIHNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGNodW5rU2l6ZSBzaXplIG9mIGVhY2ggb3V0cHV0IGFycmF5LiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYSBjaHVua2VkIGFycmF5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2h1bmsgc2l6ZSBpcyBsZXNzIHRoYW4gMSBvciBub3QgYW4gaW50ZWdlclxuICogQGV4YW1wbGVcbiAqIGNodW5rKFsxLCAyLCAzLCA0LCA1LCA2XSwgMik7XG4gKiAvLyA9PiBbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV1cbiAqL1xuZnVuY3Rpb24gY2h1bmsoeCwgY2h1bmtTaXplKSB7XG4gICAgLy8gYSBsaXN0IG9mIHJlc3VsdCBjaHVua3MsIGFzIGFycmF5cyBpbiBhbiBhcnJheVxuICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgIC8vIGBjaHVua1NpemVgIG11c3QgYmUgemVybyBvciBoaWdoZXIgLSBvdGhlcndpc2UgdGhlIGxvb3AgYmVsb3csXG4gICAgLy8gaW4gd2hpY2ggd2UgY2FsbCBgc3RhcnQgKz0gY2h1bmtTaXplYCwgd2lsbCBsb29wIGluZmluaXRlbHkuXG4gICAgLy8gU28sIHdlJ2xsIGRldGVjdCBhbmQgdGhyb3cgaW4gdGhhdCBjYXNlIHRvIGluZGljYXRlXG4gICAgLy8gaW52YWxpZCBpbnB1dC5cbiAgICBpZiAoY2h1bmtTaXplIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaHVuayBzaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguZmxvb3IoY2h1bmtTaXplKSAhPT0gY2h1bmtTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rIHNpemUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgIH1cblxuICAgIC8vIGBzdGFydGAgaXMgdGhlIGluZGV4IGF0IHdoaWNoIGAuc2xpY2VgIHdpbGwgc3RhcnQgc2VsZWN0aW5nXG4gICAgLy8gbmV3IGFycmF5IGVsZW1lbnRzXG4gICAgZm9yICh2YXIgc3RhcnQgPSAwOyBzdGFydCA8IHgubGVuZ3RoOyBzdGFydCArPSBjaHVua1NpemUpIHtcbiAgICAgICAgLy8gZm9yIGVhY2ggY2h1bmssIHNsaWNlIHRoYXQgcGFydCBvZiB0aGUgYXJyYXkgYW5kIGFkZCBpdFxuICAgICAgICAvLyB0byB0aGUgb3V0cHV0LiBUaGUgYC5zbGljZWAgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICAgICAgb3V0cHV0LnB1c2goeC5zbGljZShzdGFydCwgc3RhcnQgKyBjaHVua1NpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBTYW1wbGluZyB3aXRoIHJlcGxhY2VtZW50IGlzIGEgdHlwZSBvZiBzYW1wbGluZyB0aGF0IGFsbG93cyB0aGUgc2FtZVxuICogaXRlbSB0byBiZSBwaWNrZWQgb3V0IG9mIGEgcG9wdWxhdGlvbiBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB4IGFuIGFycmF5IG9mIGFueSBraW5kIG9mIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBjb3VudCBvZiBob3cgbWFueSBlbGVtZW50cyB0byB0YWtlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmFuZG9tU291cmNlPU1hdGgucmFuZG9tXSBhbiBvcHRpb25hbCBlbnRyb3B5IHNvdXJjZSB0aGF0XG4gKiByZXR1cm5zIG51bWJlcnMgYmV0d2VlbiAwIGluY2x1c2l2ZSBhbmQgMSBleGNsdXNpdmU6IHRoZSByYW5nZSBbMCwgMSlcbiAqIEByZXR1cm4ge0FycmF5fSBuIHNhbXBsZWQgaXRlbXMgZnJvbSB0aGUgcG9wdWxhdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciB2YWx1ZXMgPSBbMSwgMiwgMywgNF07XG4gKiBzYW1wbGVXaXRoUmVwbGFjZW1lbnQodmFsdWVzLCAyKTsgLy8gcmV0dXJucyAyIHJhbmRvbSB2YWx1ZXMsIGxpa2UgWzIsIDRdO1xuICovXG5mdW5jdGlvbiBzYW1wbGVXaXRoUmVwbGFjZW1lbnQoeCwgbiwgcmFuZG9tU291cmNlKSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBhIGN1c3RvbSByYW5kb20gbnVtYmVyIHNvdXJjZSBjYW4gYmUgcHJvdmlkZWQgaWYgeW91IHdhbnQgdG8gdXNlXG4gICAgLy8gYSBmaXhlZCBzZWVkIG9yIGFub3RoZXIgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IsIGxpa2VcbiAgICAvLyBbcmFuZG9tLWpzXShodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9yYW5kb20tanMpXG4gICAgcmFuZG9tU291cmNlID0gcmFuZG9tU291cmNlIHx8IE1hdGgucmFuZG9tO1xuXG4gICAgdmFyIGxlbmd0aCA9IHgubGVuZ3RoO1xuICAgIHZhciBzYW1wbGUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IocmFuZG9tU291cmNlKCkgKiBsZW5ndGgpO1xuXG4gICAgICAgIHNhbXBsZS5wdXNoKHhbaW5kZXhdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2FtcGxlO1xufVxuXG4vKipcbiAqIEEgW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlciVFMiU4MCU5M1lhdGVzX3NodWZmbGUpXG4gKiBpbi1wbGFjZSAtIHdoaWNoIG1lYW5zIHRoYXQgaXQgKip3aWxsIGNoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsXG4gKiBhcnJheSBieSByZWZlcmVuY2UqKi5cbiAqXG4gKiBUaGlzIGlzIGFuIGFsZ29yaXRobSB0aGF0IGdlbmVyYXRlcyBhIHJhbmRvbSBbcGVybXV0YXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Blcm11dGF0aW9uKVxuICogb2YgYSBzZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdFxuICogcmV0dXJucyBudW1iZXJzIGJldHdlZW4gMCBpbmNsdXNpdmUgYW5kIDEgZXhjbHVzaXZlOiB0aGUgcmFuZ2UgWzAsIDEpXG4gKiBAcmV0dXJucyB7QXJyYXl9IHhcbiAqIEBleGFtcGxlXG4gKiB2YXIgeCA9IFsxLCAyLCAzLCA0XTtcbiAqIHNodWZmbGVJblBsYWNlKHgpO1xuICogLy8geCBpcyBzaHVmZmxlZCB0byBhIHZhbHVlIGxpa2UgWzIsIDEsIDQsIDNdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVJblBsYWNlKHgsIHJhbmRvbVNvdXJjZSkge1xuICAgIC8vIGEgY3VzdG9tIHJhbmRvbSBudW1iZXIgc291cmNlIGNhbiBiZSBwcm92aWRlZCBpZiB5b3Ugd2FudCB0byB1c2VcbiAgICAvLyBhIGZpeGVkIHNlZWQgb3IgYW5vdGhlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvciwgbGlrZVxuICAgIC8vIFtyYW5kb20tanNdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL3JhbmRvbS1qcylcbiAgICByYW5kb21Tb3VyY2UgPSByYW5kb21Tb3VyY2UgfHwgTWF0aC5yYW5kb207XG5cbiAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHggdG8gZGV0ZXJtaW5lXG4gICAgLy8gd2hlbiBubyBlbGVtZW50cyByZW1haW4gdG8gc2h1ZmZsZS5cbiAgICB2YXIgbGVuZ3RoID0geC5sZW5ndGg7XG5cbiAgICAvLyB0ZW1wb3JhcnkgaXMgdXNlZCB0byBob2xkIGFuIGl0ZW0gd2hlbiBpdCBpcyBiZWluZ1xuICAgIC8vIHN3YXBwZWQgYmV0d2VlbiBpbmRpY2VzLlxuICAgIHZhciB0ZW1wb3Jhcnk7XG5cbiAgICAvLyBUaGUgaW5kZXggdG8gc3dhcCBhdCBlYWNoIHN0YWdlLlxuICAgIHZhciBpbmRleDtcblxuICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBzdGlsbCBpdGVtcyB0byBzaHVmZmxlXG4gICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gY2hvb3NlIGEgcmFuZG9tIGluZGV4IHdpdGhpbiB0aGUgc3Vic2V0IG9mIHRoZSBhcnJheVxuICAgICAgICAvLyB0aGF0IGlzIG5vdCB5ZXQgc2h1ZmZsZWRcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKHJhbmRvbVNvdXJjZSgpICogbGVuZ3RoLS0pO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSB2YWx1ZSB0aGF0IHdlJ2xsIG1vdmUgdGVtcG9yYXJpbHlcbiAgICAgICAgdGVtcG9yYXJ5ID0geFtsZW5ndGhdO1xuXG4gICAgICAgIC8vIHN3YXAgdGhlIHZhbHVlIGF0IGB4W2xlbmd0aF1gIHdpdGggYHhbaW5kZXhdYFxuICAgICAgICB4W2xlbmd0aF0gPSB4W2luZGV4XTtcbiAgICAgICAgeFtpbmRleF0gPSB0ZW1wb3Jhcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG59XG5cbi8qKlxuICogQSBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZSlcbiAqIGlzIGEgZmFzdCB3YXkgdG8gY3JlYXRlIGEgcmFuZG9tIHBlcm11dGF0aW9uIG9mIGEgZmluaXRlIHNldC4gVGhpcyBpc1xuICogYSBmdW5jdGlvbiBhcm91bmQgYHNodWZmbGVfaW5fcGxhY2VgIHRoYXQgYWRkcyB0aGUgZ3VhcmFudGVlIHRoYXRcbiAqIGl0IHdpbGwgbm90IG1vZGlmeSBpdHMgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBzYW1wbGUgb2YgMCBvciBtb3JlIG51bWJlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlIHRoYXRcbiAqIHJldHVybnMgbnVtYmVycyBiZXR3ZWVuIDAgaW5jbHVzaXZlIGFuZCAxIGV4Y2x1c2l2ZTogdGhlIHJhbmdlIFswLCAxKVxuICogQHJldHVybiB7QXJyYXl9IHNodWZmbGVkIHZlcnNpb24gb2YgaW5wdXRcbiAqIEBleGFtcGxlXG4gKiB2YXIgc2h1ZmZsZWQgPSBzaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gKiBzaHVmZmxlZDsgLy8gPSBbMiwgMywgMSwgNF0gb3IgYW55IG90aGVyIHJhbmRvbSBwZXJtdXRhdGlvblxuICovXG5mdW5jdGlvbiBzaHVmZmxlKHgsIHJhbmRvbVNvdXJjZSkge1xuICAgIC8vIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheSBzbyB0aGF0IGl0IGlzIG5vdCBtb2RpZmllZFxuICAgIHZhciBzYW1wbGUgPSB4LnNsaWNlKCk7XG5cbiAgICAvLyBhbmQgdGhlbiBzaHVmZmxlIHRoYXQgc2hhbGxvdy1jb3BpZWQgYXJyYXksIGluIHBsYWNlXG4gICAgcmV0dXJuIHNodWZmbGVJblBsYWNlKHNhbXBsZSwgcmFuZG9tU291cmNlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBbc2ltcGxlIHJhbmRvbSBzYW1wbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2ltcGxlX3JhbmRvbV9zYW1wbGUpXG4gKiBmcm9tIGEgZ2l2ZW4gYXJyYXkgb2YgYG5gIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBzYW1wbGVkIHZhbHVlcyB3aWxsIGJlIGluIGFueSBvcmRlciwgbm90IG5lY2Vzc2FyaWx5IHRoZSBvcmRlclxuICogdGhleSBhcHBlYXIgaW4gdGhlIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0geCBpbnB1dCBhcnJheS4gY2FuIGNvbnRhaW4gYW55IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIGNvdW50IG9mIGhvdyBtYW55IGVsZW1lbnRzIHRvIHRha2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlIHRoYXRcbiAqIHJldHVybnMgbnVtYmVycyBiZXR3ZWVuIDAgaW5jbHVzaXZlIGFuZCAxIGV4Y2x1c2l2ZTogdGhlIHJhbmdlIFswLCAxKVxuICogQHJldHVybiB7QXJyYXl9IHN1YnNldCBvZiBuIGVsZW1lbnRzIGluIG9yaWdpbmFsIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB2YWx1ZXMgPSBbMSwgMiwgNCwgNSwgNiwgNywgOCwgOV07XG4gKiBzYW1wbGUodmFsdWVzLCAzKTsgLy8gcmV0dXJucyAzIHJhbmRvbSB2YWx1ZXMsIGxpa2UgWzIsIDUsIDhdO1xuICovXG5mdW5jdGlvbiBzYW1wbGUoeCwgbiwgcmFuZG9tU291cmNlKSB7XG4gICAgLy8gc2h1ZmZsZSB0aGUgb3JpZ2luYWwgYXJyYXkgdXNpbmcgYSBmaXNoZXIteWF0ZXMgc2h1ZmZsZVxuICAgIHZhciBzaHVmZmxlZCA9IHNodWZmbGUoeCwgcmFuZG9tU291cmNlKTtcblxuICAgIC8vIGFuZCB0aGVuIHJldHVybiBhIHN1YnNldCBvZiBpdCAtIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMuXG4gICAgcmV0dXJuIHNodWZmbGVkLnNsaWNlKDAsIG4pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjb2x1bW4geCByb3cgbWF0cml4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBtYXRyaXhcbiAqIEBleGFtcGxlXG4gKiBtYWtlTWF0cml4KDEwLCAxMCk7XG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXRyaXgoY29sdW1ucywgcm93cykge1xuICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgICB2YXIgY29sdW1uID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93czsgaisrKSB7XG4gICAgICAgICAgICBjb2x1bW4ucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXgucHVzaChjb2x1bW4pO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufVxuXG4vKipcbiAqIEZvciBhIHNvcnRlZCBpbnB1dCwgY291bnRpbmcgdGhlIG51bWJlciBvZiB1bmlxdWUgdmFsdWVzXG4gKiBpcyBwb3NzaWJsZSBpbiBjb25zdGFudCB0aW1lIGFuZCBjb25zdGFudCBtZW1vcnkuIFRoaXMgaXNcbiAqIGEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBhbGdvcml0aG0uXG4gKlxuICogVmFsdWVzIGFyZSBjb21wYXJlZCB3aXRoIGA9PT1gLCBzbyBvYmplY3RzIGFuZCBub24tcHJpbWl0aXZlIG9iamVjdHNcbiAqIGFyZSBub3QgaGFuZGxlZCBpbiBhbnkgc3BlY2lhbCB3YXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTwqPn0geCBhbiBhcnJheSBvZiBhbnkga2luZCBvZiB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gY291bnQgb2YgdW5pcXVlIHZhbHVlc1xuICogQGV4YW1wbGVcbiAqIHVuaXF1ZUNvdW50U29ydGVkKFsxLCAyLCAzXSk7IC8vID0+IDNcbiAqIHVuaXF1ZUNvdW50U29ydGVkKFsxLCAxLCAxXSk7IC8vID0+IDFcbiAqL1xuZnVuY3Rpb24gdW5pcXVlQ291bnRTb3J0ZWQoeCkge1xuICAgIHZhciB1bmlxdWVWYWx1ZUNvdW50ID0gMDtcbiAgICB2YXIgbGFzdFNlZW5WYWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgeFtpXSAhPT0gbGFzdFNlZW5WYWx1ZSkge1xuICAgICAgICAgICAgbGFzdFNlZW5WYWx1ZSA9IHhbaV07XG4gICAgICAgICAgICB1bmlxdWVWYWx1ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZVZhbHVlQ291bnQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGluY3JlbWVudGFsbHkgY29tcHV0ZWQgdmFsdWVzIGJhc2VkIG9uIHRoZSBzdW1zIGFuZCBzdW1zIG9mXG4gKiBzcXVhcmVzIGZvciB0aGUgZGF0YSBhcnJheVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0galxuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc3Vtc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zT2ZTcXVhcmVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAZXhhbXBsZVxuICogc3NxKDAsIDEsIFstMSwgMCwgMl0sIFsxLCAxLCA1XSk7XG4gKi9cbmZ1bmN0aW9uIHNzcShqLCBpLCBzdW1zLCBzdW1zT2ZTcXVhcmVzKSB7XG4gICAgdmFyIHNqaTsgLy8gcyhqLCBpKVxuICAgIGlmIChqID4gMCkge1xuICAgICAgICB2YXIgbXVqaSA9IChzdW1zW2ldIC0gc3Vtc1tqIC0gMV0pIC8gKGkgLSBqICsgMSk7IC8vIG11KGosIGkpXG4gICAgICAgIHNqaSA9XG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzW2ldIC0gc3Vtc09mU3F1YXJlc1tqIC0gMV0gLSAoaSAtIGogKyAxKSAqIG11amkgKiBtdWppO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNqaSA9IHN1bXNPZlNxdWFyZXNbaV0gLSAoc3Vtc1tpXSAqIHN1bXNbaV0pIC8gKGkgKyAxKTtcbiAgICB9XG4gICAgaWYgKHNqaSA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBzamk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZWN1cnNpdmVseSBkaXZpZGVzIGFuZCBjb25xdWVycyBjb21wdXRhdGlvbnNcbiAqIGZvciBjbHVzdGVyIGpcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGlNaW4gTWluaW11bSBpbmRleCBpbiBjbHVzdGVyIHRvIGJlIGNvbXB1dGVkXG4gKiBAcGFyYW0ge251bWJlcn0gaU1heCBNYXhpbXVtIGluZGV4IGluIGNsdXN0ZXIgdG8gYmUgY29tcHV0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbHVzdGVyIEluZGV4IG9mIHRoZSBjbHVzdGVyIGN1cnJlbnRseSBiZWluZyBjb21wdXRlZFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0cml4XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBiYWNrdHJhY2tNYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc3Vtc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zT2ZTcXVhcmVzXG4gKi9cbmZ1bmN0aW9uIGZpbGxNYXRyaXhDb2x1bW4oXG4gICAgaU1pbixcbiAgICBpTWF4LFxuICAgIGNsdXN0ZXIsXG4gICAgbWF0cml4LFxuICAgIGJhY2t0cmFja01hdHJpeCxcbiAgICBzdW1zLFxuICAgIHN1bXNPZlNxdWFyZXNcbikge1xuICAgIGlmIChpTWluID4gaU1heCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYXQgbWlkcG9pbnQgYmV0d2VlbiBpTWluIGFuZCBpTWF4XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKChpTWluICsgaU1heCkgLyAyKTtcblxuICAgIG1hdHJpeFtjbHVzdGVyXVtpXSA9IG1hdHJpeFtjbHVzdGVyIC0gMV1baSAtIDFdO1xuICAgIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpXSA9IGk7XG5cbiAgICB2YXIgamxvdyA9IGNsdXN0ZXI7IC8vIHRoZSBsb3dlciBlbmQgZm9yIGpcblxuICAgIGlmIChpTWluID4gY2x1c3Rlcikge1xuICAgICAgICBqbG93ID0gTWF0aC5tYXgoamxvdywgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2lNaW4gLSAxXSB8fCAwKTtcbiAgICB9XG4gICAgamxvdyA9IE1hdGgubWF4KGpsb3csIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyIC0gMV1baV0gfHwgMCk7XG5cbiAgICB2YXIgamhpZ2ggPSBpIC0gMTsgLy8gdGhlIHVwcGVyIGVuZCBmb3IgalxuICAgIGlmIChpTWF4IDwgbWF0cml4WzBdLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGpoaWdoID0gTWF0aC5taW4oamhpZ2gsIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpTWF4ICsgMV0gfHwgMCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBlbmQgKi9cbiAgICB9XG5cbiAgICB2YXIgc2ppO1xuICAgIHZhciBzamxvd2k7XG4gICAgdmFyIHNzcWpsb3c7XG4gICAgdmFyIHNzcWo7XG4gICAgZm9yICh2YXIgaiA9IGpoaWdoOyBqID49IGpsb3c7IC0taikge1xuICAgICAgICBzamkgPSBzc3EoaiwgaSwgc3Vtcywgc3Vtc09mU3F1YXJlcyk7XG5cbiAgICAgICAgaWYgKHNqaSArIG1hdHJpeFtjbHVzdGVyIC0gMV1bamxvdyAtIDFdID49IG1hdHJpeFtjbHVzdGVyXVtpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGFtaW5lIHRoZSBsb3dlciBib3VuZCBvZiB0aGUgY2x1c3RlciBib3JkZXJcbiAgICAgICAgc2psb3dpID0gc3NxKGpsb3csIGksIHN1bXMsIHN1bXNPZlNxdWFyZXMpO1xuXG4gICAgICAgIHNzcWpsb3cgPSBzamxvd2kgKyBtYXRyaXhbY2x1c3RlciAtIDFdW2psb3cgLSAxXTtcblxuICAgICAgICBpZiAoc3NxamxvdyA8IG1hdHJpeFtjbHVzdGVyXVtpXSkge1xuICAgICAgICAgICAgLy8gU2hyaW5rIHRoZSBsb3dlciBib3VuZFxuICAgICAgICAgICAgbWF0cml4W2NsdXN0ZXJdW2ldID0gc3NxamxvdztcbiAgICAgICAgICAgIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpXSA9IGpsb3c7XG4gICAgICAgIH1cbiAgICAgICAgamxvdysrO1xuXG4gICAgICAgIHNzcWogPSBzamkgKyBtYXRyaXhbY2x1c3RlciAtIDFdW2ogLSAxXTtcbiAgICAgICAgaWYgKHNzcWogPCBtYXRyaXhbY2x1c3Rlcl1baV0pIHtcbiAgICAgICAgICAgIG1hdHJpeFtjbHVzdGVyXVtpXSA9IHNzcWo7XG4gICAgICAgICAgICBiYWNrdHJhY2tNYXRyaXhbY2x1c3Rlcl1baV0gPSBqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlsbE1hdHJpeENvbHVtbihcbiAgICAgICAgaU1pbixcbiAgICAgICAgaSAtIDEsXG4gICAgICAgIGNsdXN0ZXIsXG4gICAgICAgIG1hdHJpeCxcbiAgICAgICAgYmFja3RyYWNrTWF0cml4LFxuICAgICAgICBzdW1zLFxuICAgICAgICBzdW1zT2ZTcXVhcmVzXG4gICAgKTtcbiAgICBmaWxsTWF0cml4Q29sdW1uKFxuICAgICAgICBpICsgMSxcbiAgICAgICAgaU1heCxcbiAgICAgICAgY2x1c3RlcixcbiAgICAgICAgbWF0cml4LFxuICAgICAgICBiYWNrdHJhY2tNYXRyaXgsXG4gICAgICAgIHN1bXMsXG4gICAgICAgIHN1bXNPZlNxdWFyZXNcbiAgICApO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBtYWluIG1hdHJpY2VzIHVzZWQgaW4gQ2ttZWFucyBhbmQga2lja3NcbiAqIG9mZiB0aGUgZGl2aWRlIGFuZCBjb25xdWVyIGNsdXN0ZXIgY29tcHV0YXRpb24gc3RyYXRlZ3lcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhIHNvcnRlZCBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdHJpeFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gYmFja3RyYWNrTWF0cml4XG4gKi9cbmZ1bmN0aW9uIGZpbGxNYXRyaWNlcyhkYXRhLCBtYXRyaXgsIGJhY2t0cmFja01hdHJpeCkge1xuICAgIHZhciBuVmFsdWVzID0gbWF0cml4WzBdLmxlbmd0aDtcblxuICAgIC8vIFNoaWZ0IHZhbHVlcyBieSB0aGUgbWVkaWFuIHRvIGltcHJvdmUgbnVtZXJpYyBzdGFiaWxpdHlcbiAgICB2YXIgc2hpZnQgPSBkYXRhW01hdGguZmxvb3IoblZhbHVlcyAvIDIpXTtcblxuICAgIC8vIEN1bXVsYXRpdmUgc3VtIGFuZCBjdW11bGF0aXZlIHN1bSBvZiBzcXVhcmVzIGZvciBhbGwgdmFsdWVzIGluIGRhdGEgYXJyYXlcbiAgICB2YXIgc3VtcyA9IFtdO1xuICAgIHZhciBzdW1zT2ZTcXVhcmVzID0gW107XG5cbiAgICAvLyBJbml0aWFsaXplIGZpcnN0IGNvbHVtbiBpbiBtYXRyaXggJiBiYWNrdHJhY2tNYXRyaXhcbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnRlZFZhbHVlID0gKHZvaWQgMCk7IGkgPCBuVmFsdWVzOyArK2kpIHtcbiAgICAgICAgc2hpZnRlZFZhbHVlID0gZGF0YVtpXSAtIHNoaWZ0O1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgc3Vtcy5wdXNoKHNoaWZ0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzLnB1c2goc2hpZnRlZFZhbHVlICogc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1bXMucHVzaChzdW1zW2kgLSAxXSArIHNoaWZ0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzLnB1c2goXG4gICAgICAgICAgICAgICAgc3Vtc09mU3F1YXJlc1tpIC0gMV0gKyBzaGlmdGVkVmFsdWUgKiBzaGlmdGVkVmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIGZvciBjbHVzdGVyID0gMFxuICAgICAgICBtYXRyaXhbMF1baV0gPSBzc3EoMCwgaSwgc3Vtcywgc3Vtc09mU3F1YXJlcyk7XG4gICAgICAgIGJhY2t0cmFja01hdHJpeFswXVtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVzdCBvZiB0aGUgY29sdW1uc1xuICAgIHZhciBpTWluO1xuICAgIGZvciAodmFyIGNsdXN0ZXIgPSAxOyBjbHVzdGVyIDwgbWF0cml4Lmxlbmd0aDsgKytjbHVzdGVyKSB7XG4gICAgICAgIGlmIChjbHVzdGVyIDwgbWF0cml4Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlNaW4gPSBjbHVzdGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjb21wdXRlIG1hdHJpeFtLLTFdWzBdIC4uLiBtYXRyaXhbSy0xXVtOLTJdXG4gICAgICAgICAgICBpTWluID0gblZhbHVlcyAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBmaWxsTWF0cml4Q29sdW1uKFxuICAgICAgICAgICAgaU1pbixcbiAgICAgICAgICAgIG5WYWx1ZXMgLSAxLFxuICAgICAgICAgICAgY2x1c3RlcixcbiAgICAgICAgICAgIG1hdHJpeCxcbiAgICAgICAgICAgIGJhY2t0cmFja01hdHJpeCxcbiAgICAgICAgICAgIHN1bXMsXG4gICAgICAgICAgICBzdW1zT2ZTcXVhcmVzXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIENrbWVhbnMgY2x1c3RlcmluZyBpcyBhbiBpbXByb3ZlbWVudCBvbiBoZXVyaXN0aWMtYmFzZWQgY2x1c3RlcmluZ1xuICogYXBwcm9hY2hlcyBsaWtlIEplbmtzLiBUaGUgYWxnb3JpdGhtIHdhcyBkZXZlbG9wZWQgaW5cbiAqIFtIYWl6aG91IFdhbmcgYW5kIE1pbmd6aG91IFNvbmddKGh0dHA6Ly9qb3VybmFsLnItcHJvamVjdC5vcmcvYXJjaGl2ZS8yMDExLTIvUkpvdXJuYWxfMjAxMS0yX1dhbmcrU29uZy5wZGYpXG4gKiBhcyBhIFtkeW5hbWljIHByb2dyYW1taW5nXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EeW5hbWljX3Byb2dyYW1taW5nKSBhcHByb2FjaFxuICogdG8gdGhlIHByb2JsZW0gb2YgY2x1c3RlcmluZyBudW1lcmljIGRhdGEgaW50byBncm91cHMgd2l0aCB0aGUgbGVhc3RcbiAqIHdpdGhpbi1ncm91cCBzdW0tb2Ytc3F1YXJlZC1kZXZpYXRpb25zLlxuICpcbiAqIE1pbmltaXppbmcgdGhlIGRpZmZlcmVuY2Ugd2l0aGluIGdyb3VwcyAtIHdoYXQgV2FuZyAmIFNvbmcgcmVmZXIgdG8gYXNcbiAqIGB3aXRoaW5zc2AsIG9yIHdpdGhpbiBzdW0tb2Ytc3F1YXJlcywgbWVhbnMgdGhhdCBncm91cHMgYXJlIG9wdGltYWxseVxuICogaG9tb2dlbm91cyB3aXRoaW4gYW5kIHRoZSBkYXRhIGlzIHNwbGl0IGludG8gcmVwcmVzZW50YXRpdmUgZ3JvdXBzLlxuICogVGhpcyBpcyB2ZXJ5IHVzZWZ1bCBmb3IgdmlzdWFsaXphdGlvbiwgd2hlcmUgeW91IG1heSB3YW50IHRvIHJlcHJlc2VudFxuICogYSBjb250aW51b3VzIHZhcmlhYmxlIGluIGRpc2NyZXRlIGNvbG9yIG9yIHN0eWxlIGdyb3Vwcy4gVGhpcyBmdW5jdGlvblxuICogY2FuIHByb3ZpZGUgZ3JvdXBzIHRoYXQgZW1waGFzaXplIGRpZmZlcmVuY2VzIGJldHdlZW4gZGF0YS5cbiAqXG4gKiBCZWluZyBhIGR5bmFtaWMgYXBwcm9hY2gsIHRoaXMgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIHR3byBtYXRyaWNlcyB0aGF0XG4gKiBzdG9yZSBpbmNyZW1lbnRhbGx5LWNvbXB1dGVkIHZhbHVlcyBmb3Igc3F1YXJlZCBkZXZpYXRpb25zIGFuZCBiYWNrdHJhY2tpbmdcbiAqIGluZGV4ZXMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiBDa21lYW5zIDMuNC42LCB3aGljaCBpbnRyb2R1Y2VkIGEgbmV3IGRpdmlkZVxuICogYW5kIGNvbnF1ZXIgYXBwcm9hY2ggdGhhdCBpbXByb3ZlZCBydW50aW1lIGZyb20gTyhrbl4yKSB0byBPKGtuIGxvZyhuKSkuXG4gKlxuICogVW5saWtlIHRoZSBbb3JpZ2luYWwgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vY3Jhbi5yLXByb2plY3Qub3JnL3dlYi9wYWNrYWdlcy9Da21lYW5zLjFkLmRwL2luZGV4Lmh0bWwpLFxuICogdGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBpbmNsdWRlIGFueSBjb2RlIHRvIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lXG4gKiB0aGUgb3B0aW1hbCBudW1iZXIgb2YgY2x1c3RlcnM6IHRoaXMgaW5mb3JtYXRpb24gbmVlZHMgdG8gYmUgZXhwbGljaXRseVxuICogcHJvdmlkZWQuXG4gKlxuICogIyMjIFJlZmVyZW5jZXNcbiAqIF9Da21lYW5zLjFkLmRwOiBPcHRpbWFsIGstbWVhbnMgQ2x1c3RlcmluZyBpbiBPbmUgRGltZW5zaW9uIGJ5IER5bmFtaWNcbiAqIFByb2dyYW1taW5nXyBIYWl6aG91IFdhbmcgYW5kIE1pbmd6aG91IFNvbmcgSVNTTiAyMDczLTQ4NTlcbiAqXG4gKiBmcm9tIFRoZSBSIEpvdXJuYWwgVm9sLiAzLzIsIERlY2VtYmVyIDIwMTFcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dCBkYXRhLCBhcyBhbiBhcnJheSBvZiBudW1iZXIgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbkNsdXN0ZXJzIG51bWJlciBvZiBkZXNpcmVkIGNsYXNzZXMuIFRoaXMgY2Fubm90IGJlXG4gKiBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiB2YWx1ZXMgaW4gdGhlIGRhdGEgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNsdXN0ZXJlZCBpbnB1dFxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBudW1iZXIgb2YgcmVxdWVzdGVkIGNsdXN0ZXJzIGlzIGhpZ2hlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogY2ttZWFucyhbLTEsIDIsIC0xLCAyLCA0LCA1LCA2LCAtMSwgMiwgLTFdLCAzKTtcbiAqIC8vIFRoZSBpbnB1dCwgY2x1c3RlcmVkIGludG8gZ3JvdXBzIG9mIHNpbWlsYXIgbnVtYmVycy5cbiAqIC8vPSBbWy0xLCAtMSwgLTEsIC0xXSwgWzIsIDIsIDJdLCBbNCwgNSwgNl1dKTtcbiAqL1xuZnVuY3Rpb24gY2ttZWFucyh4LCBuQ2x1c3RlcnMpIHtcbiAgICBpZiAobkNsdXN0ZXJzID4geC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJjYW5ub3QgZ2VuZXJhdGUgbW9yZSBjbGFzc2VzIHRoYW4gdGhlcmUgYXJlIGRhdGEgdmFsdWVzXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgc29ydGVkID0gbnVtZXJpY1NvcnQoeCk7XG4gICAgLy8gd2UnbGwgdXNlIHRoaXMgYXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNsdXN0ZXJzXG4gICAgdmFyIHVuaXF1ZUNvdW50ID0gdW5pcXVlQ291bnRTb3J0ZWQoc29ydGVkKTtcblxuICAgIC8vIGlmIGFsbCBvZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBpZGVudGljYWwsIHRoZXJlJ3Mgb25lIGNsdXN0ZXJcbiAgICAvLyB3aXRoIGFsbCBvZiB0aGUgaW5wdXQgaW4gaXQuXG4gICAgaWYgKHVuaXF1ZUNvdW50ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbc29ydGVkXTtcbiAgICB9XG5cbiAgICAvLyBuYW1lZCAnUycgb3JpZ2luYWxseVxuICAgIHZhciBtYXRyaXggPSBtYWtlTWF0cml4KG5DbHVzdGVycywgc29ydGVkLmxlbmd0aCk7XG4gICAgLy8gbmFtZWQgJ0onIG9yaWdpbmFsbHlcbiAgICB2YXIgYmFja3RyYWNrTWF0cml4ID0gbWFrZU1hdHJpeChuQ2x1c3RlcnMsIHNvcnRlZC5sZW5ndGgpO1xuXG4gICAgLy8gVGhpcyBpcyBhIGR5bmFtaWMgcHJvZ3JhbW1pbmcgd2F5IHRvIHNvbHZlIHRoZSBwcm9ibGVtIG9mIG1pbmltaXppbmdcbiAgICAvLyB3aXRoaW4tY2x1c3RlciBzdW0gb2Ygc3F1YXJlcy4gSXQncyBzaW1pbGFyIHRvIGxpbmVhciByZWdyZXNzaW9uXG4gICAgLy8gaW4gdGhpcyB3YXksIGFuZCB0aGlzIGNhbGN1bGF0aW9uIGluY3JlbWVudGFsbHkgY29tcHV0ZXMgdGhlXG4gICAgLy8gc3VtIG9mIHNxdWFyZXMgdGhhdCBhcmUgbGF0ZXIgcmVhZC5cbiAgICBmaWxsTWF0cmljZXMoc29ydGVkLCBtYXRyaXgsIGJhY2t0cmFja01hdHJpeCk7XG5cbiAgICAvLyBUaGUgcmVhbCB3b3JrIG9mIENrbWVhbnMgY2x1c3RlcmluZyBoYXBwZW5zIGluIHRoZSBtYXRyaXggZ2VuZXJhdGlvbjpcbiAgICAvLyB0aGUgZ2VuZXJhdGVkIG1hdHJpY2VzIGVuY29kZSBhbGwgcG9zc2libGUgY2x1c3RlcmluZyBjb21iaW5hdGlvbnMsIGFuZFxuICAgIC8vIG9uY2UgdGhleSdyZSBnZW5lcmF0ZWQgd2UgY2FuIHNvbHZlIGZvciB0aGUgYmVzdCBjbHVzdGVyaW5nIGdyb3Vwc1xuICAgIC8vIHZlcnkgcXVpY2tseS5cbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICB2YXIgY2x1c3RlclJpZ2h0ID0gYmFja3RyYWNrTWF0cml4WzBdLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBCYWNrdHJhY2sgdGhlIGNsdXN0ZXJzIGZyb20gdGhlIGR5bmFtaWMgcHJvZ3JhbW1pbmcgbWF0cml4LiBUaGlzXG4gICAgLy8gc3RhcnRzIGF0IHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIHRoZSBtYXRyaXggKGlmIHRoZSB0b3AtbGVmdCBpcyAwLCAwKSxcbiAgICAvLyBhbmQgbW92ZXMgdGhlIGNsdXN0ZXIgdGFyZ2V0IHdpdGggdGhlIGxvb3AuXG4gICAgZm9yICh2YXIgY2x1c3RlciA9IGJhY2t0cmFja01hdHJpeC5sZW5ndGggLSAxOyBjbHVzdGVyID49IDA7IGNsdXN0ZXItLSkge1xuICAgICAgICB2YXIgY2x1c3RlckxlZnQgPSBiYWNrdHJhY2tNYXRyaXhbY2x1c3Rlcl1bY2x1c3RlclJpZ2h0XTtcblxuICAgICAgICAvLyBmaWxsIHRoZSBjbHVzdGVyIGZyb20gdGhlIHNvcnRlZCBpbnB1dCBieSB0YWtpbmcgYSBzbGljZSBvZiB0aGVcbiAgICAgICAgLy8gYXJyYXkuIHRoZSBiYWNrdHJhY2sgbWF0cml4IG1ha2VzIHRoaXMgZWFzeSAtIGl0IHN0b3JlcyB0aGVcbiAgICAgICAgLy8gaW5kZXhlcyB3aGVyZSB0aGUgY2x1c3RlciBzaG91bGQgc3RhcnQgYW5kIGVuZC5cbiAgICAgICAgY2x1c3RlcnNbY2x1c3Rlcl0gPSBzb3J0ZWQuc2xpY2UoY2x1c3RlckxlZnQsIGNsdXN0ZXJSaWdodCArIDEpO1xuXG4gICAgICAgIGlmIChjbHVzdGVyID4gMCkge1xuICAgICAgICAgICAgY2x1c3RlclJpZ2h0ID0gY2x1c3RlckxlZnQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG4vKlxuICogUHVsbCBCcmVha3MgVmFsdWVzIGZvciBKZW5rc1xuICpcbiAqIHRoZSBzZWNvbmQgcGFydCBvZiB0aGUgamVua3MgcmVjaXBlOiB0YWtlIHRoZSBjYWxjdWxhdGVkIG1hdHJpY2VzXG4gKiBhbmQgZGVyaXZlIGFuIGFycmF5IG9mIG4gYnJlYWtzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGplbmtzQnJlYWtzKGRhdGEsIGxvd2VyQ2xhc3NMaW1pdHMsIG5DbGFzc2VzKSB7XG4gICAgdmFyIGsgPSBkYXRhLmxlbmd0aDtcbiAgICB2YXIga2NsYXNzID0gW107XG4gICAgdmFyIGNvdW50TnVtID0gbkNsYXNzZXM7XG5cbiAgICAvLyB0aGUgY2FsY3VsYXRpb24gb2YgY2xhc3NlcyB3aWxsIG5ldmVyIGluY2x1ZGUgdGhlIHVwcGVyXG4gICAgLy8gYm91bmQsIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSBzZXQgaXRcbiAgICBrY2xhc3NbbkNsYXNzZXNdID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gdGhlIGxvd2VyQ2xhc3NMaW1pdHMgbWF0cml4IGlzIHVzZWQgYXMgaW5kaWNlcyBpbnRvIGl0c2VsZlxuICAgIC8vIGhlcmU6IHRoZSBga2AgdmFyaWFibGUgaXMgcmV1c2VkIGluIGVhY2ggaXRlcmF0aW9uLlxuICAgIHdoaWxlIChjb3VudE51bSA+IDApIHtcbiAgICAgICAga2NsYXNzW2NvdW50TnVtIC0gMV0gPSBkYXRhW2xvd2VyQ2xhc3NMaW1pdHNba11bY291bnROdW1dIC0gMV07XG4gICAgICAgIGsgPSBsb3dlckNsYXNzTGltaXRzW2tdW2NvdW50TnVtXSAtIDE7XG4gICAgICAgIGNvdW50TnVtLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGtjbGFzcztcbn1cblxuLypcbiAqIENvbXB1dGUgTWF0cmljZXMgZm9yIEplbmtzXG4gKlxuICogQ29tcHV0ZSB0aGUgbWF0cmljZXMgcmVxdWlyZWQgZm9yIEplbmtzIGJyZWFrcy4gVGhlc2UgbWF0cmljZXNcbiAqIGNhbiBiZSB1c2VkIGZvciBhbnkgY2xhc3Npbmcgb2YgZGF0YSB3aXRoIGBjbGFzc2VzIDw9IG5DbGFzc2VzYFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGplbmtzTWF0cmljZXMoZGF0YSwgbkNsYXNzZXMpIHtcbiAgICAvLyBpbiB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24sIHRoZXNlIG1hdHJpY2VzIGFyZSByZWZlcnJlZCB0b1xuICAgIC8vIGFzIGBMQ2AgYW5kIGBPUGBcbiAgICAvL1xuICAgIC8vICogbG93ZXJDbGFzc0xpbWl0cyAoTEMpOiBvcHRpbWFsIGxvd2VyIGNsYXNzIGxpbWl0c1xuICAgIC8vICogdmFyaWFuY2VDb21iaW5hdGlvbnMgKE9QKTogb3B0aW1hbCB2YXJpYW5jZSBjb21iaW5hdGlvbnMgZm9yIGFsbCBjbGFzc2VzXG4gICAgdmFyIGxvd2VyQ2xhc3NMaW1pdHMgPSBbXTtcbiAgICB2YXIgdmFyaWFuY2VDb21iaW5hdGlvbnMgPSBbXTtcbiAgICAvLyBsb29wIGNvdW50ZXJzXG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG4gICAgLy8gdGhlIHZhcmlhbmNlLCBhcyBjb21wdXRlZCBhdCBlYWNoIHN0ZXAgaW4gdGhlIGNhbGN1bGF0aW9uXG4gICAgdmFyIHZhcmlhbmNlID0gMDtcblxuICAgIC8vIEluaXRpYWxpemUgYW5kIGZpbGwgZWFjaCBtYXRyaXggd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgICAgdmFyIHRtcDEgPSBbXTtcbiAgICAgICAgdmFyIHRtcDIgPSBbXTtcbiAgICAgICAgLy8gZGVzcGl0ZSB0aGVzZSBhcnJheXMgaGF2aW5nIHRoZSBzYW1lIHZhbHVlcywgd2UgbmVlZFxuICAgICAgICAvLyB0byBrZWVwIHRoZW0gc2VwYXJhdGUgc28gdGhhdCBjaGFuZ2luZyBvbmUgZG9lcyBub3QgY2hhbmdlXG4gICAgICAgIC8vIHRoZSBvdGhlclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbkNsYXNzZXMgKyAxOyBqKyspIHtcbiAgICAgICAgICAgIHRtcDEucHVzaCgwKTtcbiAgICAgICAgICAgIHRtcDIucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBsb3dlckNsYXNzTGltaXRzLnB1c2godG1wMSk7XG4gICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zLnB1c2godG1wMik7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMTsgaSA8IG5DbGFzc2VzICsgMTsgaSsrKSB7XG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHNbMV1baV0gPSAxO1xuICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1sxXVtpXSA9IDA7XG4gICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiwgOTk5OTk5OSBpcyB1c2VkIGJ1dFxuICAgICAgICAvLyBzaW5jZSBKYXZhc2NyaXB0IGhhcyBgSW5maW5pdHlgLCB3ZSB1c2UgdGhhdC5cbiAgICAgICAgZm9yIChqID0gMjsgaiA8IGRhdGEubGVuZ3RoICsgMTsgaisrKSB7XG4gICAgICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1tqXVtpXSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGwgPSAyOyBsIDwgZGF0YS5sZW5ndGggKyAxOyBsKyspIHtcbiAgICAgICAgLy8gYFNaYCBvcmlnaW5hbGx5LiB0aGlzIGlzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBzZWVuIHRodXNcbiAgICAgICAgLy8gZmFyIHdoZW4gY2FsY3VsYXRpbmcgdmFyaWFuY2UuXG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAvLyBgWlNRYCBvcmlnaW5hbGx5LiB0aGUgc3VtIG9mIHNxdWFyZXMgb2YgdmFsdWVzIHNlZW5cbiAgICAgICAgLy8gdGh1cyBmYXJcbiAgICAgICAgdmFyIHN1bVNxdWFyZXMgPSAwO1xuICAgICAgICAvLyBgV1RgIG9yaWdpbmFsbHkuIFRoaXMgaXMgdGhlIG51bWJlciBvZlxuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIC8vIGBJVmAgb3JpZ2luYWxseVxuICAgICAgICB2YXIgaTQgPSAwO1xuXG4gICAgICAgIC8vIGluIHNldmVyYWwgaW5zdGFuY2VzLCB5b3UgY291bGQgc2F5IGBNYXRoLnBvdyh4LCAyKWBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBgeCAqIHhgLCBidXQgdGhpcyBpcyBzbG93ZXIgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICAvLyBpbnRyb2R1Y2VzIGFuIHVubmVjZXNzYXJ5IGNvbmNlcHQuXG4gICAgICAgIGZvciAodmFyIG0gPSAxOyBtIDwgbCArIDE7IG0rKykge1xuICAgICAgICAgICAgLy8gYElJSWAgb3JpZ2luYWxseVxuICAgICAgICAgICAgdmFyIGxvd2VyQ2xhc3NMaW1pdCA9IGwgLSBtICsgMTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhW2xvd2VyQ2xhc3NMaW1pdCAtIDFdO1xuXG4gICAgICAgICAgICAvLyBoZXJlIHdlJ3JlIGVzdGltYXRpbmcgdmFyaWFuY2UgZm9yIGVhY2ggcG90ZW50aWFsIGNsYXNzaW5nXG4gICAgICAgICAgICAvLyBvZiB0aGUgZGF0YSwgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZiBjbGFzc2VzLiBgd2BcbiAgICAgICAgICAgIC8vIGlzIHRoZSBudW1iZXIgb2YgZGF0YSBwb2ludHMgY29uc2lkZXJlZCBzbyBmYXIuXG4gICAgICAgICAgICB3Kys7XG5cbiAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBjdXJyZW50IHN1bSBhbmQgc3VtLW9mLXNxdWFyZXNcbiAgICAgICAgICAgIHN1bSArPSB2YWw7XG4gICAgICAgICAgICBzdW1TcXVhcmVzICs9IHZhbCAqIHZhbDtcblxuICAgICAgICAgICAgLy8gdGhlIHZhcmlhbmNlIGF0IHRoaXMgcG9pbnQgaW4gdGhlIHNlcXVlbmNlIGlzIHRoZSBkaWZmZXJlbmNlXG4gICAgICAgICAgICAvLyBiZXR3ZWVuIHRoZSBzdW0gb2Ygc3F1YXJlcyBhbmQgdGhlIHRvdGFsIHggMiwgb3ZlciB0aGUgbnVtYmVyXG4gICAgICAgICAgICAvLyBvZiBzYW1wbGVzLlxuICAgICAgICAgICAgdmFyaWFuY2UgPSBzdW1TcXVhcmVzIC0gKHN1bSAqIHN1bSkgLyB3O1xuXG4gICAgICAgICAgICBpNCA9IGxvd2VyQ2xhc3NMaW1pdCAtIDE7XG5cbiAgICAgICAgICAgIGlmIChpNCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDI7IGogPCBuQ2xhc3NlcyArIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhZGRpbmcgdGhpcyBlbGVtZW50IHRvIGFuIGV4aXN0aW5nIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgaW5jcmVhc2UgaXRzIHZhcmlhbmNlIGJleW9uZCB0aGUgbGltaXQsIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjbGFzcyBhdCB0aGlzIHBvaW50LCBzZXR0aW5nIHRoZSBgbG93ZXJDbGFzc0xpbWl0YFxuICAgICAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1tsXVtqXSA+PVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFuY2UgKyB2YXJpYW5jZUNvbWJpbmF0aW9uc1tpNF1baiAtIDFdXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJDbGFzc0xpbWl0c1tsXVtqXSA9IGxvd2VyQ2xhc3NMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zW2xdW2pdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW5jZSArIHZhcmlhbmNlQ29tYmluYXRpb25zW2k0XVtqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb3dlckNsYXNzTGltaXRzW2xdWzFdID0gMTtcbiAgICAgICAgdmFyaWFuY2VDb21iaW5hdGlvbnNbbF1bMV0gPSB2YXJpYW5jZTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdGhlIHR3byBtYXRyaWNlcy4gZm9yIGp1c3QgcHJvdmlkaW5nIGJyZWFrcywgb25seVxuICAgIC8vIGBsb3dlckNsYXNzTGltaXRzYCBpcyBuZWVkZWQsIGJ1dCB2YXJpYW5jZXMgY2FuIGJlIHVzZWZ1bCB0b1xuICAgIC8vIGV2YWx1YXRlIGdvb2RuZXNzIG9mIGZpdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBsb3dlckNsYXNzTGltaXRzOiBsb3dlckNsYXNzTGltaXRzLFxuICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uczogdmFyaWFuY2VDb21iaW5hdGlvbnNcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSAqKltqZW5rcyBuYXR1cmFsIGJyZWFrcyBvcHRpbWl6YXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVua3NfbmF0dXJhbF9icmVha3Nfb3B0aW1pemF0aW9uKSoqXG4gKiBpcyBhbiBhbGdvcml0aG0gY29tbW9ubHkgdXNlZCBpbiBjYXJ0b2dyYXBoeSBhbmQgdmlzdWFsaXphdGlvbiB0byBkZWNpZGVcbiAqIHVwb24gZ3JvdXBpbmdzIG9mIGRhdGEgdmFsdWVzIHRoYXQgbWluaW1pemUgdmFyaWFuY2Ugd2l0aGluIHRoZW1zZWx2ZXNcbiAqIGFuZCBtYXhpbWl6ZSB2YXJpYXRpb24gYmV0d2VlbiB0aGVtc2VsdmVzLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgY2FydG9ncmFwaGVycyBvZnRlbiB1c2UgamVua3MgaW4gb3JkZXIgdG8gY2hvb3NlIHdoaWNoXG4gKiB2YWx1ZXMgYXJlIGFzc2lnbmVkIHRvIHdoaWNoIGNvbG9ycyBpbiBhIFtjaG9yb3BsZXRoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaG9yb3BsZXRoX21hcClcbiAqIG1hcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhdGEgaW5wdXQgZGF0YSwgYXMgYW4gYXJyYXkgb2YgbnVtYmVyIHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5DbGFzc2VzIG51bWJlciBvZiBkZXNpcmVkIGNsYXNzZXNcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBhcnJheSBvZiBjbGFzcyBicmVhayBwb3NpdGlvbnNcbiAqIC8vIHNwbGl0IGRhdGEgaW50byAzIGJyZWFrIHBvaW50c1xuICogamVua3MoWzEsIDIsIDQsIDUsIDcsIDksIDEwLCAyMF0sIDMpIC8vID0gWzEsIDcsIDIwLCAyMF1cbiAqL1xuZnVuY3Rpb24gamVua3MoZGF0YSwgbkNsYXNzZXMpIHtcbiAgICBpZiAobkNsYXNzZXMgPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzb3J0IGRhdGEgaW4gbnVtZXJpY2FsIG9yZGVyLCBzaW5jZSB0aGlzIGlzIGV4cGVjdGVkXG4gICAgLy8gYnkgdGhlIG1hdHJpY2VzIGZ1bmN0aW9uXG4gICAgZGF0YSA9IGRhdGEuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcblxuICAgIC8vIGdldCBvdXIgYmFzaWMgbWF0cmljZXNcbiAgICB2YXIgbWF0cmljZXMgPSBqZW5rc01hdHJpY2VzKGRhdGEsIG5DbGFzc2VzKTtcbiAgICAvLyB3ZSBvbmx5IG5lZWQgbG93ZXIgY2xhc3MgbGltaXRzIGhlcmVcbiAgICB2YXIgbG93ZXJDbGFzc0xpbWl0cyA9IG1hdHJpY2VzLmxvd2VyQ2xhc3NMaW1pdHM7XG5cbiAgICAvLyBleHRyYWN0IG5DbGFzc2VzIG91dCBvZiB0aGUgY29tcHV0ZWQgbWF0cmljZXNcbiAgICByZXR1cm4gamVua3NCcmVha3MoZGF0YSwgbG93ZXJDbGFzc0xpbWl0cywgbkNsYXNzZXMpO1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHgsIHRoaXMgd2lsbCBmaW5kIHRoZSBleHRlbnQgb2YgdGhlXG4gKiB4IGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgYnJlYWtzIHRoYXQgY2FuIGJlIHVzZWRcbiAqIHRvIGNhdGVnb3JpemUgdGhlIHggaW50byBhIG51bWJlciBvZiBjbGFzc2VzLiBUaGVcbiAqIHJldHVybmVkIGFycmF5IHdpbGwgYWx3YXlzIGJlIDEgbG9uZ2VyIHRoYW4gdGhlIG51bWJlciBvZlxuICogY2xhc3NlcyBiZWNhdXNlIGl0IGluY2x1ZGVzIHRoZSBtaW5pbXVtIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhbiBhcnJheSBvZiBudW1iZXIgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbkNsYXNzZXMgbnVtYmVyIG9mIGRlc2lyZWQgY2xhc3Nlc1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGFycmF5IG9mIGNsYXNzIGJyZWFrIHBvc2l0aW9uc1xuICogQGV4YW1wbGVcbiAqIGVxdWFsSW50ZXJ2YWxCcmVha3MoWzEsIDIsIDMsIDQsIDUsIDZdLCA0KTsgLy8gPT4gWzEsIDIuMjUsIDMuNSwgNC43NSwgNl1cbiAqL1xuZnVuY3Rpb24gZXF1YWxJbnRlcnZhbEJyZWFrcyh4LCBuQ2xhc3Nlcykge1xuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgdmFyIHRoZU1pbiA9IG1pbih4KTtcbiAgICB2YXIgdGhlTWF4ID0gbWF4KHgpO1xuXG4gICAgLy8gdGhlIGZpcnN0IGJyZWFrIHdpbGwgYWx3YXlzIGJlIHRoZSBtaW5pbXVtIHZhbHVlXG4gICAgLy8gaW4gdGhlIHhzZXRcbiAgICB2YXIgYnJlYWtzID0gW3RoZU1pbl07XG5cbiAgICAvLyBUaGUgc2l6ZSBvZiBlYWNoIGJyZWFrIGlzIHRoZSBmdWxsIHJhbmdlIG9mIHRoZSB4XG4gICAgLy8gZGl2aWRlZCBieSB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgcmVxdWVzdGVkXG4gICAgdmFyIGJyZWFrU2l6ZSA9ICh0aGVNYXggLSB0aGVNaW4pIC8gbkNsYXNzZXM7XG5cbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBuQ2xhc3NlcyA9IDEsIHRoaXMgbG9vcCB3b24ndCBydW5cbiAgICAvLyBhbmQgdGhlIHJldHVybmVkIGJyZWFrcyB3aWxsIGJlIFttaW4sIG1heF1cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5DbGFzc2VzOyBpKyspIHtcbiAgICAgICAgYnJlYWtzLnB1c2goYnJlYWtzWzBdICsgYnJlYWtTaXplICogaSk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGxhc3QgYnJlYWsgd2lsbCBhbHdheXMgYmUgdGhlXG4gICAgLy8gbWF4aW11bS5cbiAgICBicmVha3MucHVzaCh0aGVNYXgpO1xuXG4gICAgcmV0dXJuIGJyZWFrcztcbn1cblxuLyoqXG4gKiBbU2FtcGxlIGNvdmFyaWFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NhbXBsZV9tZWFuX2FuZF9jb3ZhcmlhbmNlKSBvZiB0d28gZGF0YXNldHM6XG4gKiBob3cgbXVjaCBkbyB0aGUgdHdvIGRhdGFzZXRzIG1vdmUgdG9nZXRoZXI/XG4gKiB4IGFuZCB5IGFyZSB0d28gZGF0YXNldHMsIHJlcHJlc2VudGVkIGFzIGFycmF5cyBvZiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiB0d28gb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5IGEgc2FtcGxlIG9mIHR3byBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBhbmQgeSBkbyBub3QgaGF2ZSBlcXVhbCBsZW5ndGhzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBvciB5IGhhdmUgbGVuZ3RoIG9mIG9uZSBvciBsZXNzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzYW1wbGUgY292YXJpYW5jZVxuICogQGV4YW1wbGVcbiAqIHNhbXBsZUNvdmFyaWFuY2UoWzEsIDIsIDMsIDQsIDUsIDZdLCBbNiwgNSwgNCwgMywgMiwgMV0pOyAvLyA9PiAtMy41XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZUNvdmFyaWFuY2UoeCwgeSkge1xuICAgIC8vIFRoZSB0d28gZGF0YXNldHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCB3aGljaCBtdXN0IGJlIG1vcmUgdGhhbiAxXG4gICAgaWYgKHgubGVuZ3RoICE9PSB5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIHNhbXBsZXMgd2l0aCBlcXVhbCBsZW5ndGhzXCIpO1xuICAgIH1cblxuICAgIGlmICh4Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBkYXRhIHBvaW50cyBpbiBlYWNoIHNhbXBsZVwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBtZWFuIG9mIGVhY2ggZGF0YXNldCBzbyB0aGF0IHdlIGNhbiBqdWRnZSBlYWNoXG4gICAgLy8gdmFsdWUgb2YgdGhlIGRhdGFzZXQgZmFpcmx5IGFzIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIG1lYW4uIHRoaXNcbiAgICAvLyB3YXksIGlmIG9uZSBkYXRhc2V0IGlzIFsxLCAyLCAzXSBhbmQgWzIsIDMsIDRdLCB0aGVpciBjb3ZhcmlhbmNlXG4gICAgLy8gZG9lcyBub3Qgc3VmZmVyIGJlY2F1c2Ugb2YgdGhlIGRpZmZlcmVuY2UgaW4gYWJzb2x1dGUgdmFsdWVzXG4gICAgdmFyIHhtZWFuID0gbWVhbih4KTtcbiAgICB2YXIgeW1lYW4gPSBtZWFuKHkpO1xuICAgIHZhciBzdW0gPSAwO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBvZiB2YWx1ZXMsIHRoZSBjb3ZhcmlhbmNlIGluY3JlYXNlcyB3aGVuIHRoZWlyXG4gICAgLy8gZGlmZmVyZW5jZSBmcm9tIHRoZSBtZWFuIGlzIGFzc29jaWF0ZWQgLSBpZiBib3RoIGFyZSB3ZWxsIGFib3ZlXG4gICAgLy8gb3IgaWYgYm90aCBhcmUgd2VsbCBiZWxvd1xuICAgIC8vIHRoZSBtZWFuLCB0aGUgY292YXJpYW5jZSBpbmNyZWFzZXMgc2lnbmlmaWNhbnRseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9ICh4W2ldIC0geG1lYW4pICogKHlbaV0gLSB5bWVhbik7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIHRoZSBjb3ZhcmlhbmNlIGlzIHdlaWdodGVkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGRhdGFzZXRzLlxuICAgIHJldHVybiBzdW0gLyBiZXNzZWxzQ29ycmVjdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgW3NhbXBsZSB2YXJpYW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFyaWFuY2UjU2FtcGxlX3ZhcmlhbmNlKVxuICogaXMgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbi4gVGhlIHNhbXBsZSB2YXJpYW5jZVxuICogaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHRoZSB2YXJpYW5jZSBieSB0aGUgdXNhZ2Ugb2YgW0Jlc3NlbCdzIENvcnJlY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jlc3NlbCdzX2NvcnJlY3Rpb24pOlxuICogaW5zdGVhZCBvZiBkaXZpZGluZyB0aGUgc3VtIG9mIHNxdWFyZWQgZGV2aWF0aW9ucyBieSB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCxcbiAqIGl0IGlzIGRpdmlkZWQgYnkgdGhlIGxlbmd0aCBtaW51cyBvbmUuIFRoaXMgY29ycmVjdHMgdGhlIGJpYXMgaW4gZXN0aW1hdGluZ1xuICogYSB2YWx1ZSBmcm9tIGEgc2V0IHRoYXQgeW91IGRvbid0IGtub3cgaWYgZnVsbC5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICogKiBbV29sZnJhbSBNYXRoV29ybGQgb24gU2FtcGxlIFZhcmlhbmNlXShodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL1NhbXBsZVZhcmlhbmNlLmh0bWwpXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIHR3byBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHNhbXBsZSB2YXJpYW5jZVxuICogQGV4YW1wbGVcbiAqIHNhbXBsZVZhcmlhbmNlKFsxLCAyLCAzLCA0LCA1XSk7IC8vID0+IDIuNVxuICovXG5mdW5jdGlvbiBzYW1wbGVWYXJpYW5jZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVWYXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gZGF0YSBwb2ludHNcIik7XG4gICAgfVxuXG4gICAgdmFyIHN1bVNxdWFyZWREZXZpYXRpb25zVmFsdWUgPSBzdW1OdGhQb3dlckRldmlhdGlvbnMoeCwgMik7XG5cbiAgICAvLyB0aGlzIGlzIEJlc3NlbHMnIENvcnJlY3Rpb246IGFuIGFkanVzdG1lbnQgbWFkZSB0byBzYW1wbGUgc3RhdGlzdGljc1xuICAgIC8vIHRoYXQgYWxsb3dzIGZvciB0aGUgcmVkdWNlZCBkZWdyZWUgb2YgZnJlZWRvbSBlbnRhaWxlZCBpbiBjYWxjdWxhdGluZ1xuICAgIC8vIHZhbHVlcyBmcm9tIHNhbXBsZXMgcmF0aGVyIHRoYW4gY29tcGxldGUgcG9wdWxhdGlvbnMuXG4gICAgdmFyIGJlc3NlbHNDb3JyZWN0aW9uID0geC5sZW5ndGggLSAxO1xuXG4gICAgLy8gRmluZCB0aGUgbWVhbiB2YWx1ZSBvZiB0aGF0IGxpc3RcbiAgICByZXR1cm4gc3VtU3F1YXJlZERldmlhdGlvbnNWYWx1ZSAvIGJlc3NlbHNDb3JyZWN0aW9uO1xufVxuXG4vKipcbiAqIFRoZSBbc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9kZXZpYXRpb24jU2FtcGxlX3N0YW5kYXJkX2RldmlhdGlvbilcbiAqIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc2FtcGxlIHZhcmlhbmNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dCBhcnJheVxuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvblxuICogQGV4YW1wbGVcbiAqIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKFsyLCA0LCA0LCA0LCA1LCA1LCA3LCA5XSkudG9GaXhlZCgyKTtcbiAqIC8vID0+ICcyLjE0J1xuICovXG5mdW5jdGlvbiBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih4KSB7XG4gICAgdmFyIHNhbXBsZVZhcmlhbmNlWCA9IHNhbXBsZVZhcmlhbmNlKHgpO1xuICAgIHJldHVybiBNYXRoLnNxcnQoc2FtcGxlVmFyaWFuY2VYKTtcbn1cblxuLyoqXG4gKiBUaGUgW2NvcnJlbGF0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvcnJlbGF0aW9uX2FuZF9kZXBlbmRlbmNlKSBpc1xuICogYSBtZWFzdXJlIG9mIGhvdyBjb3JyZWxhdGVkIHR3byBkYXRhc2V0cyBhcmUsIGJldHdlZW4gLTEgYW5kIDFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggZmlyc3QgaW5wdXRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geSBzZWNvbmQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBjb3JyZWxhdGlvblxuICogQGV4YW1wbGVcbiAqIHNhbXBsZUNvcnJlbGF0aW9uKFsxLCAyLCAzLCA0LCA1LCA2XSwgWzIsIDIsIDMsIDQsIDUsIDYwXSkudG9GaXhlZCgyKTtcbiAqIC8vID0+ICcwLjY5J1xuICovXG5mdW5jdGlvbiBzYW1wbGVDb3JyZWxhdGlvbih4LCB5KSB7XG4gICAgdmFyIGNvdiA9IHNhbXBsZUNvdmFyaWFuY2UoeCwgeSk7XG4gICAgdmFyIHhzdGQgPSBzYW1wbGVTdGFuZGFyZERldmlhdGlvbih4KTtcbiAgICB2YXIgeXN0ZCA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHkpO1xuXG4gICAgcmV0dXJuIGNvdiAvIHhzdGQgLyB5c3RkO1xufVxuXG4vKipcbiAqIFRoZSBbcmFuayBjb3JyZWxhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFua19jb3JyZWxhdGlvbikgaXNcbiAqIGEgbWVhc3VyZSBvZiB0aGUgc3RyZW5ndGggb2YgbW9ub3RvbmljIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHR3byBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggZmlyc3QgaW5wdXRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geSBzZWNvbmQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSByYW5rIGNvcnJlbGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVJhbmtDb3JyZWxhdGlvbih4LCB5KSB7XG4gICAgdmFyIHhJbmRleGVzID0geFxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuIFt2YWx1ZSwgaW5kZXhdOyB9KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhaXIpIHsgcmV0dXJuIHBhaXJbMV07IH0pO1xuICAgIHZhciB5SW5kZXhlcyA9IHlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7IHJldHVybiBbdmFsdWUsIGluZGV4XTsgfSlcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChwYWlyKSB7IHJldHVybiBwYWlyWzFdOyB9KTtcblxuICAgIC8vIEF0IHRoaXMgc3RlcCwgd2UgaGF2ZSBhbiBhcnJheSBvZiBpbmRleGVzXG4gICAgLy8gdGhhdCBtYXAgZnJvbSBzb3J0ZWQgbnVtYmVycyB0byB0aGVpciBvcmlnaW5hbCBpbmRleGVzLiBXZSByZXZlcnNlXG4gICAgLy8gdGhhdCBzbyB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIHRoZSBzb3J0ZWQgZGVzdGluYXRpb24gaW5kZXguXG4gICAgdmFyIHhSYW5rcyA9IEFycmF5KHhJbmRleGVzLmxlbmd0aCk7XG4gICAgdmFyIHlSYW5rcyA9IEFycmF5KHhJbmRleGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB4UmFua3NbeEluZGV4ZXNbaV1dID0gaTtcbiAgICAgICAgeVJhbmtzW3lJbmRleGVzW2ldXSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhbXBsZUNvcnJlbGF0aW9uKHhSYW5rcywgeVJhbmtzKTtcbn1cblxuLyoqXG4gKiBbU2tld25lc3NdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2tld25lc3MpIGlzXG4gKiBhIG1lYXN1cmUgb2YgdGhlIGV4dGVudCB0byB3aGljaCBhIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiBvZiBhXG4gKiByZWFsLXZhbHVlZCByYW5kb20gdmFyaWFibGUgXCJsZWFuc1wiIHRvIG9uZSBzaWRlIG9mIHRoZSBtZWFuLlxuICogVGhlIHNrZXduZXNzIHZhbHVlIGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgb3IgZXZlbiB1bmRlZmluZWQuXG4gKlxuICogSW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIGFkanVzdGVkIEZpc2hlci1QZWFyc29uIHN0YW5kYXJkaXplZFxuICogbW9tZW50IGNvZWZmaWNpZW50LCB3aGljaCBpcyB0aGUgdmVyc2lvbiBmb3VuZCBpbiBFeGNlbCBhbmQgc2V2ZXJhbFxuICogc3RhdGlzdGljYWwgcGFja2FnZXMgaW5jbHVkaW5nIE1pbml0YWIsIFNBUyBhbmQgU1BTUy5cbiAqXG4gKiBAc2luY2UgNC4xLjBcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiAzIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBza2V3bmVzc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggaGFzIGxlbmd0aCBsZXNzIHRoYW4gM1xuICogQGV4YW1wbGVcbiAqIHNhbXBsZVNrZXduZXNzKFsyLCA0LCA2LCAzLCAxXSk7IC8vID0+IDAuNTkwMTI4NjU2Mzg0MzY1XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVNrZXduZXNzKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZVNrZXduZXNzIHJlcXVpcmVzIGF0IGxlYXN0IHRocmVlIGRhdGEgcG9pbnRzXCIpO1xuICAgIH1cblxuICAgIHZhciBtZWFuVmFsdWUgPSBtZWFuKHgpO1xuICAgIHZhciB0ZW1wVmFsdWU7XG4gICAgdmFyIHN1bVNxdWFyZWREZXZpYXRpb25zID0gMDtcbiAgICB2YXIgc3VtQ3ViZWREZXZpYXRpb25zID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZW1wVmFsdWUgPSB4W2ldIC0gbWVhblZhbHVlO1xuICAgICAgICBzdW1TcXVhcmVkRGV2aWF0aW9ucyArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgICAgIHN1bUN1YmVkRGV2aWF0aW9ucyArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBCZXNzZWxzJyBDb3JyZWN0aW9uOiBhbiBhZGp1c3RtZW50IG1hZGUgdG8gc2FtcGxlIHN0YXRpc3RpY3NcbiAgICAvLyB0aGF0IGFsbG93cyBmb3IgdGhlIHJlZHVjZWQgZGVncmVlIG9mIGZyZWVkb20gZW50YWlsZWQgaW4gY2FsY3VsYXRpbmdcbiAgICAvLyB2YWx1ZXMgZnJvbSBzYW1wbGVzIHJhdGhlciB0aGFuIGNvbXBsZXRlIHBvcHVsYXRpb25zLlxuICAgIHZhciBiZXNzZWxzQ29ycmVjdGlvbiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIC8vIEZpbmQgdGhlIG1lYW4gdmFsdWUgb2YgdGhhdCBsaXN0XG4gICAgdmFyIHRoZVNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KFxuICAgICAgICBzdW1TcXVhcmVkRGV2aWF0aW9ucyAvIGJlc3NlbHNDb3JyZWN0aW9uXG4gICAgKTtcblxuICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgdmFyIGN1YmVkUyA9IE1hdGgucG93KHRoZVNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uLCAzKTtcblxuICAgIHJldHVybiAobiAqIHN1bUN1YmVkRGV2aWF0aW9ucykgLyAoKG4gLSAxKSAqIChuIC0gMikgKiBjdWJlZFMpO1xufVxuXG4vKipcbiAqIFtLdXJ0b3Npc10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LdXJ0b3NpcykgaXNcbiAqIGEgbWVhc3VyZSBvZiB0aGUgaGVhdmluZXNzIG9mIGEgZGlzdHJpYnV0aW9uJ3MgdGFpbHMgcmVsYXRpdmUgdG8gaXRzXG4gKiB2YXJpYW5jZS4gVGhlIGt1cnRvc2lzIHZhbHVlIGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgb3IgZXZlbiB1bmRlZmluZWQuXG4gKlxuICogSW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gRmlzaGVyJ3MgZXhjZXNzIGt1cnRvc2lzIGRlZmluaXRpb24gYW5kIHVzZXNcbiAqIHVuYmlhc2VkIG1vbWVudCBlc3RpbWF0b3JzLiBUaGlzIGlzIHRoZSB2ZXJzaW9uIGZvdW5kIGluIEV4Y2VsIGFuZCBhdmFpbGFibGVcbiAqIGluIHNldmVyYWwgc3RhdGlzdGljYWwgcGFja2FnZXMsIGluY2x1ZGluZyBTQVMgYW5kIFNjaVB5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiA0IG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBrdXJ0b3Npc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHggaGFzIGxlbmd0aCBsZXNzIHRoYW4gNFxuICogQGV4YW1wbGVcbiAqIHNhbXBsZUt1cnRvc2lzKFsxLCAyLCAyLCAzLCA1XSk7IC8vID0+IDEuNDU1NTc2NTU5NTQ2MzEyMlxuICovXG5mdW5jdGlvbiBzYW1wbGVLdXJ0b3Npcyh4KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcblxuICAgIGlmIChuIDwgNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVLdXJ0b3NpcyByZXF1aXJlcyBhdCBsZWFzdCBmb3VyIGRhdGEgcG9pbnRzXCIpO1xuICAgIH1cblxuICAgIHZhciBtZWFuVmFsdWUgPSBtZWFuKHgpO1xuICAgIHZhciB0ZW1wVmFsdWU7XG4gICAgdmFyIHNlY29uZENlbnRyYWxNb21lbnQgPSAwO1xuICAgIHZhciBmb3VydGhDZW50cmFsTW9tZW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgIHNlY29uZENlbnRyYWxNb21lbnQgKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgICAgICBmb3VydGhDZW50cmFsTW9tZW50ICs9IHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICAoKG4gLSAxKSAvICgobiAtIDIpICogKG4gLSAzKSkpICpcbiAgICAgICAgKChuICogKG4gKyAxKSAqIGZvdXJ0aENlbnRyYWxNb21lbnQpIC9cbiAgICAgICAgICAgIChzZWNvbmRDZW50cmFsTW9tZW50ICogc2Vjb25kQ2VudHJhbE1vbWVudCkgLVxuICAgICAgICAgICAgMyAqIChuIC0gMSkpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBbSGVhcCdzIEFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVhcCUyN3NfYWxnb3JpdGhtKVxuICogZm9yIGdlbmVyYXRpbmcgcGVybXV0YXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIGFueSB0eXBlIG9mIGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IGFycmF5IG9mIHBlcm11dGF0aW9uc1xuICovXG5mdW5jdGlvbiBwZXJtdXRhdGlvbnNIZWFwKGVsZW1lbnRzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBuZXcgQXJyYXkoZWxlbWVudHMubGVuZ3RoKTtcbiAgICB2YXIgcGVybXV0YXRpb25zID0gW2VsZW1lbnRzLnNsaWNlKCldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbmRleGVzW2ldID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBlbGVtZW50cy5sZW5ndGg7ICkge1xuICAgICAgICBpZiAoaW5kZXhlc1tpJDFdIDwgaSQxKSB7XG4gICAgICAgICAgICAvLyBBdCBvZGQgaW5kZXhlcywgc3dhcCBmcm9tIGluZGV4ZXNbaV0gaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICAgICAgICAgICAgdmFyIHN3YXBGcm9tID0gMDtcbiAgICAgICAgICAgIGlmIChpJDEgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc3dhcEZyb20gPSBpbmRleGVzW2kkMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN3YXAgYmV0d2VlbiBzd2FwRnJvbSBhbmQgaSwgdXNpbmdcbiAgICAgICAgICAgIC8vIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIGFzIHN0b3JhZ2UuXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGVsZW1lbnRzW3N3YXBGcm9tXTtcbiAgICAgICAgICAgIGVsZW1lbnRzW3N3YXBGcm9tXSA9IGVsZW1lbnRzW2kkMV07XG4gICAgICAgICAgICBlbGVtZW50c1tpJDFdID0gdGVtcDtcblxuICAgICAgICAgICAgcGVybXV0YXRpb25zLnB1c2goZWxlbWVudHMuc2xpY2UoKSk7XG4gICAgICAgICAgICBpbmRleGVzW2kkMV0rKztcbiAgICAgICAgICAgIGkkMSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleGVzW2kkMV0gPSAwO1xuICAgICAgICAgICAgaSQxKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIENvbWJpbmF0aW9uc1xuICogQ29tYmluYXRpb25zIGFyZSB1bmlxdWUgc3Vic2V0cyBvZiBhIGNvbGxlY3Rpb24gLSBpbiB0aGlzIGNhc2UsIGsgeCBmcm9tIGEgY29sbGVjdGlvbiBhdCBhIHRpbWUuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5hdGlvblxuICogQHBhcmFtIHtBcnJheX0geCBhbnkgdHlwZSBvZiBkYXRhXG4gKiBAcGFyYW0ge2ludH0gayB0aGUgbnVtYmVyIG9mIG9iamVjdHMgaW4gZWFjaCBncm91cCAod2l0aG91dCByZXBsYWNlbWVudClcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IGFycmF5IG9mIHBlcm11dGF0aW9uc1xuICogQGV4YW1wbGVcbiAqIGNvbWJpbmF0aW9ucyhbMSwgMiwgM10sIDIpOyAvLyA9PiBbWzEsMl0sIFsxLDNdLCBbMiwzXV1cbiAqL1xuXG5mdW5jdGlvbiBjb21iaW5hdGlvbnMoeCwgaykge1xuICAgIHZhciBpO1xuICAgIHZhciBzdWJJO1xuICAgIHZhciBjb21iaW5hdGlvbkxpc3QgPSBbXTtcbiAgICB2YXIgc3Vic2V0Q29tYmluYXRpb25zO1xuICAgIHZhciBuZXh0O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbWJpbmF0aW9uTGlzdC5wdXNoKFt4W2ldXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzZXRDb21iaW5hdGlvbnMgPSBjb21iaW5hdGlvbnMoeC5zbGljZShpICsgMSwgeC5sZW5ndGgpLCBrIC0gMSk7XG4gICAgICAgICAgICBmb3IgKHN1YkkgPSAwOyBzdWJJIDwgc3Vic2V0Q29tYmluYXRpb25zLmxlbmd0aDsgc3ViSSsrKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHN1YnNldENvbWJpbmF0aW9uc1tzdWJJXTtcbiAgICAgICAgICAgICAgICBuZXh0LnVuc2hpZnQoeFtpXSk7XG4gICAgICAgICAgICAgICAgY29tYmluYXRpb25MaXN0LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmF0aW9uTGlzdDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBbQ29tYmluYXRpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5hdGlvbikgd2l0aCByZXBsYWNlbWVudFxuICogQ29tYmluYXRpb25zIGFyZSB1bmlxdWUgc3Vic2V0cyBvZiBhIGNvbGxlY3Rpb24gLSBpbiB0aGlzIGNhc2UsIGsgeCBmcm9tIGEgY29sbGVjdGlvbiBhdCBhIHRpbWUuXG4gKiAnV2l0aCByZXBsYWNlbWVudCcgbWVhbnMgdGhhdCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGNob3NlbiBtdWx0aXBsZSB0aW1lcy5cbiAqIFVubGlrZSBwZXJtdXRhdGlvbiwgb3JkZXIgZG9lc24ndCBtYXR0ZXIgZm9yIGNvbWJpbmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IGFueSB0eXBlIG9mIGRhdGFcbiAqIEBwYXJhbSB7aW50fSBrIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiBlYWNoIGdyb3VwICh3aXRob3V0IHJlcGxhY2VtZW50KVxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYXJyYXkgb2YgcGVybXV0YXRpb25zXG4gKiBAZXhhbXBsZVxuICogY29tYmluYXRpb25zUmVwbGFjZW1lbnQoWzEsIDJdLCAyKTsgLy8gPT4gW1sxLCAxXSwgWzEsIDJdLCBbMiwgMl1dXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmF0aW9uc1JlcGxhY2VtZW50KHgsIGspIHtcbiAgICB2YXIgY29tYmluYXRpb25MaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHJlcXVlc3RlZCB0byBmaW5kIG9ubHkgb25lIGVsZW1lbnQsIHdlIGRvbid0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHJlY3Vyc2U6IGp1c3QgcHVzaCBgeFtpXWAgb250byB0aGUgbGlzdCBvZiBjb21iaW5hdGlvbnMuXG4gICAgICAgICAgICBjb21iaW5hdGlvbkxpc3QucHVzaChbeFtpXV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWN1cnNpdmVseSBmaW5kIGNvbWJpbmF0aW9ucywgZ2l2ZW4gYGsgLSAxYC4gTm90ZSB0aGF0XG4gICAgICAgICAgICAvLyB3ZSByZXF1ZXN0IGBrIC0gMWAsIHNvIGlmIHlvdSB3ZXJlIGxvb2tpbmcgZm9yIGs9MyBjb21iaW5hdGlvbnMsIHdlJ3JlXG4gICAgICAgICAgICAvLyByZXF1ZXN0aW5nIGs9Mi4gVGhpcyAtMSBnZXRzIHJldmVyc2VkIGluIHRoZSBmb3IgbG9vcCByaWdodCBhZnRlciB0aGlzXG4gICAgICAgICAgICAvLyBjb2RlLCBzaW5jZSB3ZSBjb25jYXRlbmF0ZSBgeFtpXWAgb250byB0aGUgc2VsZWN0ZWQgY29tYmluYXRpb25zLFxuICAgICAgICAgICAgLy8gYnJpbmdpbmcgYGtgIGJhY2sgdXAgdG8geW91ciByZXF1ZXN0ZWQgbGV2ZWwuXG4gICAgICAgICAgICAvLyBUaGlzIHJlY3Vyc2lvbiBtYXkgZ28gbWFueSBsZXZlbHMgZGVlcCwgc2luY2UgaXQgb25seSBzdG9wcyBvbmNlXG4gICAgICAgICAgICAvLyBrPTEuXG4gICAgICAgICAgICB2YXIgc3Vic2V0Q29tYmluYXRpb25zID0gY29tYmluYXRpb25zUmVwbGFjZW1lbnQoXG4gICAgICAgICAgICAgICAgeC5zbGljZShpLCB4Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgayAtIDFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3Vic2V0Q29tYmluYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29tYmluYXRpb25MaXN0LnB1c2goW3hbaV1dLmNvbmNhdChzdWJzZXRDb21iaW5hdGlvbnNbal0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5hdGlvbkxpc3Q7XG59XG5cbi8qKlxuICogV2hlbiBhZGRpbmcgYSBuZXcgdmFsdWUgdG8gYSBsaXN0LCBvbmUgZG9lcyBub3QgaGF2ZSB0byBuZWNlc3NhcnlcbiAqIHJlY29tcHV0ZSB0aGUgbWVhbiBvZiB0aGUgbGlzdCBpbiBsaW5lYXIgdGltZS4gVGhleSBjYW4gaW5zdGVhZCB1c2VcbiAqIHRoaXMgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgbmV3IG1lYW4gYnkgcHJvdmlkaW5nIHRoZSBjdXJyZW50IG1lYW4sXG4gKiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBsaXN0IHRoYXQgcHJvZHVjZWQgaXQgYW5kIHRoZSBuZXdcbiAqIHZhbHVlIHRvIGFkZC5cbiAqXG4gKiBAc2luY2UgMi41LjBcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuIGN1cnJlbnQgbWVhblxuICogQHBhcmFtIHtudW1iZXJ9IG4gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgdGhlIGFkZGVkIHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbmV3IG1lYW5cbiAqXG4gKiBAZXhhbXBsZVxuICogYWRkVG9NZWFuKDE0LCA1LCA1Myk7IC8vID0+IDIwLjVcbiAqL1xuZnVuY3Rpb24gYWRkVG9NZWFuKG1lYW4sIG4sIG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIG1lYW4gKyAobmV3VmFsdWUgLSBtZWFuKSAvIChuICsgMSk7XG59XG5cbi8qKlxuICogV2hlbiBjb21iaW5pbmcgdHdvIGxpc3RzIG9mIHZhbHVlcyBmb3Igd2hpY2ggb25lIGFscmVhZHkga25vd3MgdGhlIG1lYW5zLFxuICogb25lIGRvZXMgbm90IGhhdmUgdG8gbmVjZXNzYXJ5IHJlY29tcHV0ZSB0aGUgbWVhbiBvZiB0aGUgY29tYmluZWQgbGlzdHMgaW5cbiAqIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGNvbWJpbmVkXG4gKiBtZWFuIGJ5IHByb3ZpZGluZyB0aGUgbWVhbiAmIG51bWJlciBvZiB2YWx1ZXMgb2YgdGhlIGZpcnN0IGxpc3QgYW5kIHRoZSBtZWFuXG4gKiAmIG51bWJlciBvZiB2YWx1ZXMgb2YgdGhlIHNlY29uZCBsaXN0LlxuICpcbiAqIEBzaW5jZSAzLjAuMFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4xIG1lYW4gb2YgdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuMiBtZWFuIG9mIHRoZSBzZWNvbmQgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4yIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc2Vjb25kIGxpc3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb21iaW5lZCBtZWFuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbWJpbmVNZWFucyg1LCAzLCA0LCAzKTsgLy8gPT4gNC41XG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVNZWFucyhtZWFuMSwgbjEsIG1lYW4yLCBuMikge1xuICAgIHJldHVybiAobWVhbjEgKiBuMSArIG1lYW4yICogbjIpIC8gKG4xICsgbjIpO1xufVxuXG4vKipcbiAqIFdoZW4gY29tYmluaW5nIHR3byBsaXN0cyBvZiB2YWx1ZXMgZm9yIHdoaWNoIG9uZSBhbHJlYWR5IGtub3dzIHRoZSB2YXJpYW5jZXMsXG4gKiBvbmUgZG9lcyBub3QgaGF2ZSB0byBuZWNlc3NhcnkgcmVjb21wdXRlIHRoZSB2YXJpYW5jZSBvZiB0aGUgY29tYmluZWQgbGlzdHNcbiAqIGluIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGNvbWJpbmVkXG4gKiB2YXJpYW5jZSBieSBwcm92aWRpbmcgdGhlIHZhcmlhbmNlLCBtZWFuICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgZmlyc3QgbGlzdFxuICogYW5kIHRoZSB2YXJpYW5jZSwgbWVhbiAmIG51bWJlciBvZiB2YWx1ZXMgb2YgdGhlIHNlY29uZCBsaXN0LlxuICpcbiAqIEBzaW5jZSAzLjAuMFxuICogQHBhcmFtIHtudW1iZXJ9IHZhcmlhbmNlMSB2YXJpYW5jZSBvZiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4xIG1lYW4gb2YgdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YXJpYW5jZTIgdmFyaWFuY2Ugb2YgdGhlIHNlY29uZCBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbWVhbjIgbWVhbiBvZiB0aGUgc2Vjb25kIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMiBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHNlY29uZCBsaXN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY29tYmluZWQgbWVhblxuICpcbiAqIEBleGFtcGxlXG4gKiBjb21iaW5lVmFyaWFuY2VzKDE0IC8gMywgNSwgMywgOCAvIDMsIDQsIDMpOyAvLyA9PiA0NyAvIDEyXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVWYXJpYW5jZXModmFyaWFuY2UxLCBtZWFuMSwgbjEsIHZhcmlhbmNlMiwgbWVhbjIsIG4yKSB7XG4gICAgdmFyIG5ld01lYW4gPSBjb21iaW5lTWVhbnMobWVhbjEsIG4xLCBtZWFuMiwgbjIpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgKG4xICogKHZhcmlhbmNlMSArIE1hdGgucG93KG1lYW4xIC0gbmV3TWVhbiwgMikpICtcbiAgICAgICAgICAgIG4yICogKHZhcmlhbmNlMiArIE1hdGgucG93KG1lYW4yIC0gbmV3TWVhbiwgMikpKSAvXG4gICAgICAgIChuMSArIG4yKVxuICAgICk7XG59XG5cbi8qKlxuICogVGhlIFtHZW9tZXRyaWMgTWVhbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvbWV0cmljX21lYW4pIGlzXG4gKiBhIG1lYW4gZnVuY3Rpb24gdGhhdCBpcyBtb3JlIHVzZWZ1bCBmb3IgbnVtYmVycyBpbiBkaWZmZXJlbnRcbiAqIHJhbmdlcy5cbiAqXG4gKiBUaGlzIGlzIHRoZSBudGggcm9vdCBvZiB0aGUgaW5wdXQgbnVtYmVycyBtdWx0aXBsaWVkIGJ5IGVhY2ggb3RoZXIuXG4gKlxuICogVGhlIGdlb21ldHJpYyBtZWFuIGlzIG9mdGVuIHVzZWZ1bCBmb3JcbiAqICoqW3Byb3BvcnRpb25hbCBncm93dGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb21ldHJpY19tZWFuI1Byb3BvcnRpb25hbF9ncm93dGgpKio6IGdpdmVuXG4gKiBncm93dGggcmF0ZXMgZm9yIG11bHRpcGxlIHllYXJzLCBsaWtlIF84MCUsIDE2LjY2JSBhbmQgNDIuODUlXywgYSBzaW1wbGVcbiAqIG1lYW4gd2lsbCBpbmNvcnJlY3RseSBlc3RpbWF0ZSBhbiBhdmVyYWdlIGdyb3d0aCByYXRlLCB3aGVyZWFzIGEgZ2VvbWV0cmljXG4gKiBtZWFuIHdpbGwgY29ycmVjdGx5IGVzdGltYXRlIGEgZ3Jvd3RoIHJhdGUgdGhhdCwgb3ZlciB0aG9zZSB5ZWFycyxcbiAqIHdpbGwgeWllbGQgdGhlIHNhbWUgZW5kIHZhbHVlLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gZ2VvbWV0cmljIG1lYW5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBjb250YWlucyBhIG5lZ2F0aXZlIG51bWJlclxuICogQGV4YW1wbGVcbiAqIHZhciBncm93dGhSYXRlcyA9IFsxLjgwLCAxLjE2NjY2NiwgMS40Mjg1NzFdO1xuICogdmFyIGF2ZXJhZ2VHcm93dGggPSBzcy5nZW9tZXRyaWNNZWFuKGdyb3d0aFJhdGVzKTtcbiAqIHZhciBhdmVyYWdlR3Jvd3RoUmF0ZXMgPSBbYXZlcmFnZUdyb3d0aCwgYXZlcmFnZUdyb3d0aCwgYXZlcmFnZUdyb3d0aF07XG4gKiB2YXIgc3RhcnRpbmdWYWx1ZSA9IDEwO1xuICogdmFyIHN0YXJ0aW5nVmFsdWVNZWFuID0gMTA7XG4gKiBncm93dGhSYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhdGUpIHtcbiAqICAgc3RhcnRpbmdWYWx1ZSAqPSByYXRlO1xuICogfSk7XG4gKiBhdmVyYWdlR3Jvd3RoUmF0ZXMuZm9yRWFjaChmdW5jdGlvbihyYXRlKSB7XG4gKiAgIHN0YXJ0aW5nVmFsdWVNZWFuICo9IHJhdGU7XG4gKiB9KTtcbiAqIHN0YXJ0aW5nVmFsdWVNZWFuID09PSBzdGFydGluZ1ZhbHVlO1xuICovXG5mdW5jdGlvbiBnZW9tZXRyaWNNZWFuKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvbWV0cmljTWVhbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgc3RhcnRpbmcgdmFsdWUuXG4gICAgdmFyIHZhbHVlID0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB0aGUgZ2VvbWV0cmljIG1lYW4gaXMgb25seSB2YWxpZCBmb3IgcG9zaXRpdmUgbnVtYmVyc1xuICAgICAgICBpZiAoeFtpXSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImdlb21ldHJpY01lYW4gcmVxdWlyZXMgb25seSBub24tbmVnYXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwZWF0ZWRseSBtdWx0aXBseSB0aGUgdmFsdWUgYnkgZWFjaCBudW1iZXJcbiAgICAgICAgdmFsdWUgKj0geFtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5wb3codmFsdWUsIDEgLyB4Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogVGhlIFtsb2cgYXZlcmFnZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvbWV0cmljX21lYW4jUmVsYXRpb25zaGlwX3dpdGhfbG9nYXJpdGhtcylcbiAqIGlzIGFuIGVxdWl2YWxlbnQgd2F5IG9mIGNvbXB1dGluZyB0aGUgZ2VvbWV0cmljIG1lYW4gb2YgYW4gYXJyYXkgc3VpdGFibGUgZm9yIGxhcmdlIG9yIHNtYWxsIHByb2R1Y3RzLlxuICpcbiAqIEl0J3MgZm91bmQgYnkgY2FsY3VsYXRpbmcgdGhlIGF2ZXJhZ2UgbG9nYXJpdGhtIG9mIHRoZSBlbGVtZW50cyBhbmQgZXhwb25lbnRpYXRpbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gZ2VvbWV0cmljIG1lYW5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBjb250YWlucyBhIG5lZ2F0aXZlIG51bWJlclxuICovXG5mdW5jdGlvbiBsb2dBdmVyYWdlKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9nQXZlcmFnZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeFtpXSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImxvZ0F2ZXJhZ2UgcmVxdWlyZXMgb25seSBub24tbmVnYXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IE1hdGgubG9nKHhbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmV4cCh2YWx1ZSAvIHgubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBUaGUgW0hhcm1vbmljIE1lYW5dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhcm1vbmljX21lYW4pIGlzXG4gKiBhIG1lYW4gZnVuY3Rpb24gdHlwaWNhbGx5IHVzZWQgdG8gZmluZCB0aGUgYXZlcmFnZSBvZiByYXRlcy5cbiAqIFRoaXMgbWVhbiBpcyBjYWxjdWxhdGVkIGJ5IHRha2luZyB0aGUgcmVjaXByb2NhbCBvZiB0aGUgYXJpdGhtZXRpYyBtZWFuXG4gKiBvZiB0aGUgcmVjaXByb2NhbHMgb2YgdGhlIGlucHV0IG51bWJlcnMuXG4gKlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gaGFybW9uaWMgbWVhblxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGNvbnRhaW5zIGEgbmVnYXRpdmUgbnVtYmVyXG4gKiBAZXhhbXBsZVxuICogaGFybW9uaWNNZWFuKFsyLCAzXSkudG9GaXhlZCgyKSAvLyA9PiAnMi40MCdcbiAqL1xuZnVuY3Rpb24gaGFybW9uaWNNZWFuKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFybW9uaWNNZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciByZWNpcHJvY2FsU3VtID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB0aGUgaGFybW9uaWMgbWVhbiBpcyBvbmx5IHZhbGlkIGZvciBwb3NpdGl2ZSBudW1iZXJzXG4gICAgICAgIGlmICh4W2ldIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImhhcm1vbmljTWVhbiByZXF1aXJlcyBvbmx5IHBvc2l0aXZlIG51bWJlcnMgYXMgaW5wdXRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2lwcm9jYWxTdW0gKz0gMSAvIHhbaV07XG4gICAgfVxuXG4gICAgLy8gZGl2aWRlIG4gYnkgdGhlIHJlY2lwcm9jYWwgc3VtXG4gICAgcmV0dXJuIHgubGVuZ3RoIC8gcmVjaXByb2NhbFN1bTtcbn1cblxuLyoqXG4gKiBUaGUgbWVhbiwgX2Fsc28ga25vd24gYXMgYXZlcmFnZV8sXG4gKiBpcyB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMgb3ZlciB0aGUgbnVtYmVyIG9mIHZhbHVlcy5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGUgc2ltcGxlIG1lYW4gdXNlcyB0aGUgc3VjY2Vzc2l2ZSBhZGRpdGlvbiBtZXRob2QgaW50ZXJuYWxseVxuICogdG8gY2FsY3VsYXRlIGl0J3MgcmVzdWx0LiBFcnJvcnMgaW4gZmxvYXRpbmctcG9pbnQgYWRkaXRpb24gYXJlXG4gKiBub3QgYWNjb3VudGVkIGZvciwgc28gaWYgcHJlY2lzaW9uIGlzIHJlcXVpcmVkLCB0aGUgc3RhbmRhcmQge0BsaW5rIG1lYW59XG4gKiBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1lYW5cbiAqIEBleGFtcGxlXG4gKiBtZWFuKFswLCAxMF0pOyAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIG1lYW5TaW1wbGUoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZWFuU2ltcGxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdW1TaW1wbGUoeCkgLyB4Lmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgW21lZGlhbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZWRpYW4pIGlzXG4gKiB0aGUgbWlkZGxlIG51bWJlciBvZiBhIGxpc3QuIFRoaXMgaXMgb2Z0ZW4gYSBnb29kIGluZGljYXRvciBvZiAndGhlIG1pZGRsZSdcbiAqIHdoZW4gdGhlcmUgYXJlIG91dGxpZXJzIHRoYXQgc2tldyB0aGUgYG1lYW4oKWAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhlIG1lZGlhbiBpc24ndCBuZWNlc3NhcmlseSBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBsaXN0OiB0aGUgdmFsdWVcbiAqIGNhbiBiZSB0aGUgYXZlcmFnZSBvZiB0d28gZWxlbWVudHMgaWYgdGhlIGxpc3QgaGFzIGFuIGV2ZW4gbGVuZ3RoXG4gKiBhbmQgdGhlIHR3byBjZW50cmFsIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc29ydGVkIGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWRpYW4gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtZWRpYW5Tb3J0ZWQoWzEwLCAyLCA1LCAxMDAsIDIsIDFdKTsgLy8gPT4gNTIuNVxuICovXG5mdW5jdGlvbiBtZWRpYW5Tb3J0ZWQoc29ydGVkKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlU29ydGVkKHNvcnRlZCwgMC41KTtcbn1cblxuLyoqXG4gKiBXaGVuIHJlbW92aW5nIGEgdmFsdWUgZnJvbSBhIGxpc3QsIG9uZSBkb2VzIG5vdCBoYXZlIHRvIG5lY2Vzc2FyeVxuICogcmVjb21wdXRlIHRoZSBtZWFuIG9mIHRoZSBsaXN0IGluIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZVxuICogdGhpcyBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBuZXcgbWVhbiBieSBwcm92aWRpbmcgdGhlIGN1cnJlbnQgbWVhbixcbiAqIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3QgdGhhdCBwcm9kdWNlZCBpdCBhbmQgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuIGN1cnJlbnQgbWVhblxuICogQHBhcmFtIHtudW1iZXJ9IG4gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlbW92ZVxuICogQHJldHVybnMge251bWJlcn0gdGhlIG5ldyBtZWFuXG4gKlxuICogQGV4YW1wbGVcbiAqIHN1YnRyYWN0RnJvbU1lYW4oMjAuNSwgNiwgNTMpOyAvLyA9PiAxNFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdEZyb21NZWFuKG1lYW4sIG4sIHZhbHVlKSB7XG4gICAgcmV0dXJuIChtZWFuICogbiAtIHZhbHVlKSAvIChuIC0gMSk7XG59XG5cbi8qKlxuICogVGhlIFJvb3QgTWVhbiBTcXVhcmUgKFJNUykgaXNcbiAqIGEgbWVhbiBmdW5jdGlvbiB1c2VkIGFzIGEgbWVhc3VyZSBvZiB0aGUgbWFnbml0dWRlIG9mIGEgc2V0XG4gKiBvZiBudW1iZXJzLCByZWdhcmRsZXNzIG9mIHRoZWlyIHNpZ24uXG4gKiBUaGlzIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgbWVhbiBvZiB0aGUgc3F1YXJlcyBvZiB0aGVcbiAqIGlucHV0IG51bWJlcnMuXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gcm9vdCBtZWFuIHNxdWFyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEBleGFtcGxlXG4gKiByb290TWVhblNxdWFyZShbLTEsIDEsIC0xLCAxXSk7IC8vID0+IDFcbiAqL1xuZnVuY3Rpb24gcm9vdE1lYW5TcXVhcmUoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyb290TWVhblNxdWFyZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtT2ZTcXVhcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtT2ZTcXVhcmVzICs9IE1hdGgucG93KHhbaV0sIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnNxcnQoc3VtT2ZTcXVhcmVzIC8geC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRoZWBjb2VmZmljaWVudCBvZiB2YXJpYXRpb25gXyBpcyB0aGUgcmF0aW8gb2YgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiB0byB0aGUgbWVhbi5cbiAqIC4uX2Bjb2VmZmljaWVudCBvZiB2YXJpYXRpb25gOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2VmZmljaWVudF9vZl92YXJpYXRpb25cbiAqXG4gKlxuICogQHBhcmFtIHtBcnJheX0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uXG4gKiBAZXhhbXBsZVxuICogY29lZmZpY2llbnRPZlZhcmlhdGlvbihbMSwgMiwgMywgNF0pLnRvRml4ZWQoMyk7IC8vID0+IDAuNTE2XG4gKiBjb2VmZmljaWVudE9mVmFyaWF0aW9uKFsxLCAyLCAzLCA0LCA1XSkudG9GaXhlZCgzKTsgLy8gPT4gMC41MjdcbiAqIGNvZWZmaWNpZW50T2ZWYXJpYXRpb24oWy0xLCAwLCAxLCAyLCAzLCA0XSkudG9GaXhlZCgzKTsgLy8gPT4gMS4yNDdcbiAqL1xuZnVuY3Rpb24gY29lZmZpY2llbnRPZlZhcmlhdGlvbih4KSB7XG4gICAgcmV0dXJuIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpIC8gbWVhbih4KTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRvIGNvbXB1dGUgW2Egb25lLXNhbXBsZSB0LXRlc3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0dWRlbnQlMjdzX3QtdGVzdCNPbmUtc2FtcGxlX3QtdGVzdCksIGNvbXBhcmluZyB0aGUgbWVhblxuICogb2YgYSBzYW1wbGUgdG8gYSBrbm93biB2YWx1ZSwgeC5cbiAqXG4gKiBpbiB0aGlzIGNhc2UsIHdlJ3JlIHRyeWluZyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIHBvcHVsYXRpb24gbWVhbiBpcyBlcXVhbCB0byB0aGUgdmFsdWUgdGhhdCB3ZSBrbm93LCB3aGljaCBpcyBgeGBcbiAqIGhlcmUuIFVzdWFsbHkgdGhlIHJlc3VsdHMgaGVyZSBhcmUgdXNlZCB0byBsb29rIHVwIGFcbiAqIFtwLXZhbHVlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1AtdmFsdWUpLCB3aGljaCwgZm9yXG4gKiBhIGNlcnRhaW4gbGV2ZWwgb2Ygc2lnbmlmaWNhbmNlLCB3aWxsIGxldCB5b3UgZGV0ZXJtaW5lIHRoYXQgdGhlXG4gKiBudWxsIGh5cG90aGVzaXMgY2FuIG9yIGNhbm5vdCBiZSByZWplY3RlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZFZhbHVlIGV4cGVjdGVkIHZhbHVlIG9mIHRoZSBwb3B1bGF0aW9uIG1lYW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gKiBAZXhhbXBsZVxuICogdFRlc3QoWzEsIDIsIDMsIDQsIDUsIDZdLCAzLjM4NSkudG9GaXhlZCgyKTsgLy8gPT4gJzAuMTYnXG4gKi9cbmZ1bmN0aW9uIHRUZXN0KHgsIGV4cGVjdGVkVmFsdWUpIHtcbiAgICAvLyBUaGUgbWVhbiBvZiB0aGUgc2FtcGxlXG4gICAgdmFyIHNhbXBsZU1lYW4gPSBtZWFuKHgpO1xuXG4gICAgLy8gVGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgc2FtcGxlXG4gICAgdmFyIHNkID0gc3RhbmRhcmREZXZpYXRpb24oeCk7XG5cbiAgICAvLyBTcXVhcmUgcm9vdCB0aGUgbGVuZ3RoIG9mIHRoZSBzYW1wbGVcbiAgICB2YXIgcm9vdE4gPSBNYXRoLnNxcnQoeC5sZW5ndGgpO1xuXG4gICAgLy8gcmV0dXJuaW5nIHRoZSB0IHZhbHVlXG4gICAgcmV0dXJuIChzYW1wbGVNZWFuIC0gZXhwZWN0ZWRWYWx1ZSkgLyAoc2QgLyByb290Tik7XG59XG5cbi8qKlxuICogVGhpcyBpcyB0byBjb21wdXRlIFt0d28gc2FtcGxlIHQtdGVzdF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdHVkZW50J3NfdC10ZXN0KS5cbiAqIFRlc3RzIHdoZXRoZXIgXCJtZWFuKFgpLW1lYW4oWSkgPSBkaWZmZXJlbmNlXCIsIChcbiAqIGluIHRoZSBtb3N0IGNvbW1vbiBjYXNlLCB3ZSBvZnRlbiBoYXZlIGBkaWZmZXJlbmNlID09IDBgIHRvIHRlc3QgaWYgdHdvIHNhbXBsZXNcbiAqIGFyZSBsaWtlbHkgdG8gYmUgdGFrZW4gZnJvbSBwb3B1bGF0aW9ucyB3aXRoIHRoZSBzYW1lIG1lYW4gdmFsdWUpIHdpdGhcbiAqIG5vIHByaW9yIGtub3dsZWRnZSBvbiBzdGFuZGFyZCBkZXZpYXRpb25zIG9mIGJvdGggc2FtcGxlc1xuICogb3RoZXIgdGhhbiB0aGUgZmFjdCB0aGF0IHRoZXkgaGF2ZSB0aGUgc2FtZSBzdGFuZGFyZCBkZXZpYXRpb24uXG4gKlxuICogVXN1YWxseSB0aGUgcmVzdWx0cyBoZXJlIGFyZSB1c2VkIHRvIGxvb2sgdXAgYVxuICogW3AtdmFsdWVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUC12YWx1ZSksIHdoaWNoLCBmb3JcbiAqIGEgY2VydGFpbiBsZXZlbCBvZiBzaWduaWZpY2FuY2UsIHdpbGwgbGV0IHlvdSBkZXRlcm1pbmUgdGhhdCB0aGVcbiAqIG51bGwgaHlwb3RoZXNpcyBjYW4gb3IgY2Fubm90IGJlIHJlamVjdGVkLlxuICpcbiAqIGBkaWZmYCBjYW4gYmUgb21pdHRlZCBpZiBpdCBlcXVhbHMgMC5cbiAqXG4gKiBbVGhpcyBpcyB1c2VkIHRvIHJlamVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhjbHVzaW9uX29mX3RoZV9udWxsX2h5cG90aGVzaXMpXG4gKiBhIG51bGwgaHlwb3RoZXNpcyB0aGF0IHRoZSB0d28gcG9wdWxhdGlvbnMgdGhhdCBoYXZlIGJlZW4gc2FtcGxlZCBpbnRvXG4gKiBgc2FtcGxlWGAgYW5kIGBzYW1wbGVZYCBhcmUgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVggYSBzYW1wbGUgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzYW1wbGVZIGEgc2FtcGxlIGFzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGlmZmVyZW5jZT0wXVxuICogQHJldHVybnMge251bWJlcnxudWxsfSB0ZXN0IHJlc3VsdFxuICpcbiAqIEBleGFtcGxlXG4gKiB0VGVzdFR3b1NhbXBsZShbMSwgMiwgMywgNF0sIFszLCA0LCA1LCA2XSwgMCk7IC8vID0+IC0yLjE5MDg5MDIzMDAyMDY2NDNcbiAqL1xuZnVuY3Rpb24gdFRlc3RUd29TYW1wbGUoc2FtcGxlWCwgc2FtcGxlWSwgZGlmZmVyZW5jZSkge1xuICAgIHZhciBuID0gc2FtcGxlWC5sZW5ndGg7XG4gICAgdmFyIG0gPSBzYW1wbGVZLmxlbmd0aDtcblxuICAgIC8vIElmIGVpdGhlciBzYW1wbGUgZG9lc24ndCBhY3R1YWxseSBoYXZlIGFueSB2YWx1ZXMsIHdlIGNhbid0XG4gICAgLy8gY29tcHV0ZSB0aGlzIGF0IGFsbCwgc28gd2UgcmV0dXJuIGBudWxsYC5cbiAgICBpZiAoIW4gfHwgIW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBkaWZmZXJlbmNlIChtdSkgaXMgemVyb1xuICAgIGlmICghZGlmZmVyZW5jZSkge1xuICAgICAgICBkaWZmZXJlbmNlID0gMDtcbiAgICB9XG5cbiAgICB2YXIgbWVhblggPSBtZWFuKHNhbXBsZVgpO1xuICAgIHZhciBtZWFuWSA9IG1lYW4oc2FtcGxlWSk7XG4gICAgdmFyIHNhbXBsZVZhcmlhbmNlWCA9IHNhbXBsZVZhcmlhbmNlKHNhbXBsZVgpO1xuICAgIHZhciBzYW1wbGVWYXJpYW5jZVkgPSBzYW1wbGVWYXJpYW5jZShzYW1wbGVZKTtcblxuICAgIGlmIChcbiAgICAgICAgdHlwZW9mIG1lYW5YID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBtZWFuWSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2Ygc2FtcGxlVmFyaWFuY2VYID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBzYW1wbGVWYXJpYW5jZVkgPT09IFwibnVtYmVyXCJcbiAgICApIHtcbiAgICAgICAgdmFyIHdlaWdodGVkVmFyaWFuY2UgPVxuICAgICAgICAgICAgKChuIC0gMSkgKiBzYW1wbGVWYXJpYW5jZVggKyAobSAtIDEpICogc2FtcGxlVmFyaWFuY2VZKSAvXG4gICAgICAgICAgICAobiArIG0gLSAyKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG1lYW5YIC0gbWVhblkgLSBkaWZmZXJlbmNlKSAvXG4gICAgICAgICAgICBNYXRoLnNxcnQod2VpZ2h0ZWRWYXJpYW5jZSAqICgxIC8gbiArIDEgLyBtKSlcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBXaWxjb3hvbiByYW5rIHN1bSBzdGF0aXN0aWMgZm9yIHRoZSBmaXJzdCBzYW1wbGVcbiAqIHdpdGggcmVzcGVjdCB0byB0aGUgc2Vjb25kLiBUaGUgV2lsY294b24gcmFuayBzdW0gdGVzdCBpcyBhIG5vbi1wYXJhbWV0cmljXG4gKiBhbHRlcm5hdGl2ZSB0byB0aGUgdC10ZXN0IHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlXG4gKiBbTWFubi1XaGl0bmV5IFUgdGVzdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFubiVFMiU4MCU5M1doaXRuZXlfVV90ZXN0KS5cbiAqIFRoZSBzdGF0aXN0aWMgaXMgY2FsY3VsYXRlZCBieSBwb29saW5nIGFsbCB0aGUgb2JzZXJ2YXRpb25zIHRvZ2V0aGVyLCByYW5raW5nIHRoZW0sXG4gKiBhbmQgdGhlbiBzdW1taW5nIHRoZSByYW5rcyBhc3NvY2lhdGVkIHdpdGggb25lIG9mIHRoZSBzYW1wbGVzLiBJZiB0aGlzIHJhbmsgc3VtIGlzXG4gKiBzdWZmaWNpZW50bHkgbGFyZ2Ugb3Igc21hbGwgd2UgcmVqZWN0IHRoZSBoeXBvdGhlc2lzIHRoYXQgdGhlIHR3byBzYW1wbGVzIGNvbWVcbiAqIGZyb20gdGhlIHNhbWUgZGlzdHJpYnV0aW9uIGluIGZhdm9yIG9mIHRoZSBhbHRlcm5hdGl2ZSB0aGF0IG9uZSBpcyBzaGlmdGVkIHdpdGhcbiAqIHJlc3BlY3QgdG8gdGhlIG90aGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWCBhIHNhbXBsZSBhcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVkgYSBzYW1wbGUgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybnMge251bWJlcn0gcmFuayBzdW0gZm9yIHNhbXBsZVhcbiAqXG4gKiBAZXhhbXBsZVxuICogd2lsY294b25SYW5rU3VtKFsxLCA0LCA4XSwgWzksIDEyLCAxNV0pOyAvLyA9PiA2XG4gKi9cbmZ1bmN0aW9uIHdpbGNveG9uUmFua1N1bShzYW1wbGVYLCBzYW1wbGVZKSB7XG4gICAgaWYgKCFzYW1wbGVYLmxlbmd0aCB8fCAhc2FtcGxlWS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVpdGhlciBzYW1wbGUgY2FuIGJlIGVtcHR5XCIpO1xuICAgIH1cblxuICAgIHZhciBwb29sZWRTYW1wbGVzID0gc2FtcGxlWFxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAoeyBsYWJlbDogXCJ4XCIsIHZhbHVlOiB4IH0pOyB9KVxuICAgICAgICAuY29uY2F0KHNhbXBsZVkubWFwKGZ1bmN0aW9uICh5KSB7IHJldHVybiAoeyBsYWJlbDogXCJ5XCIsIHZhbHVlOiB5IH0pOyB9KSlcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlOyB9KTtcblxuICAgIGZvciAodmFyIHJhbmsgPSAwOyByYW5rIDwgcG9vbGVkU2FtcGxlcy5sZW5ndGg7IHJhbmsrKykge1xuICAgICAgICBwb29sZWRTYW1wbGVzW3JhbmtdLnJhbmsgPSByYW5rO1xuICAgIH1cblxuICAgIHZhciB0aWVkUmFua3MgPSBbcG9vbGVkU2FtcGxlc1swXS5yYW5rXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvb2xlZFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBvb2xlZFNhbXBsZXNbaV0udmFsdWUgPT09IHBvb2xlZFNhbXBsZXNbaSAtIDFdLnZhbHVlKSB7XG4gICAgICAgICAgICB0aWVkUmFua3MucHVzaChwb29sZWRTYW1wbGVzW2ldLnJhbmspO1xuICAgICAgICAgICAgaWYgKGkgPT09IHBvb2xlZFNhbXBsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VSYW5rc0luUGxhY2UocG9vbGVkU2FtcGxlcywgdGllZFJhbmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aWVkUmFua3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmVwbGFjZVJhbmtzSW5QbGFjZShwb29sZWRTYW1wbGVzLCB0aWVkUmFua3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGllZFJhbmtzID0gW3Bvb2xlZFNhbXBsZXNbaV0ucmFua107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlUmFua3NJblBsYWNlKHBvb2xlZFNhbXBsZXMsIHRpZWRSYW5rcykge1xuICAgICAgICB2YXIgYXZlcmFnZSA9ICh0aWVkUmFua3NbMF0gKyB0aWVkUmFua3NbdGllZFJhbmtzLmxlbmd0aCAtIDFdKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGllZFJhbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb29sZWRTYW1wbGVzW3RpZWRSYW5rc1tpXV0ucmFuayA9IGF2ZXJhZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmFua1N1bSA9IDA7XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb29sZWRTYW1wbGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHNhbXBsZSA9IHBvb2xlZFNhbXBsZXNbaSQxXTtcbiAgICAgICAgaWYgKHNhbXBsZS5sYWJlbCA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJhbmtTdW0gKz0gc2FtcGxlLnJhbmsgKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmtTdW07XG59XG5cbi8qKlxuICogW0JheWVzaWFuIENsYXNzaWZpZXJdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmFpdmVfQmF5ZXNfY2xhc3NpZmllcilcbiAqXG4gKiBUaGlzIGlzIGEgbmHDr3ZlIGJheWVzaWFuIGNsYXNzaWZpZXIgdGhhdCB0YWtlc1xuICogc2luZ2x5LW5lc3RlZCBvYmplY3RzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIHZhciBiYXllcyA9IG5ldyBCYXllc2lhbkNsYXNzaWZpZXIoKTtcbiAqIGJheWVzLnRyYWluKHtcbiAqICAgc3BlY2llczogJ0NhdCdcbiAqIH0sICdhbmltYWwnKTtcbiAqIHZhciByZXN1bHQgPSBiYXllcy5zY29yZSh7XG4gKiAgIHNwZWNpZXM6ICdDYXQnXG4gKiB9KVxuICogLy8gcmVzdWx0XG4gKiAvLyB7XG4gKiAvLyAgIGFuaW1hbDogMVxuICogLy8gfVxuICovXG52YXIgQmF5ZXNpYW5DbGFzc2lmaWVyID0gZnVuY3Rpb24gQmF5ZXNpYW5DbGFzc2lmaWVyKCkge1xuICAgIC8vIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBhcmUgY3VycmVudGx5XG4gICAgLy8gY2xhc3NpZmllZCBpbiB0aGUgbW9kZWxcbiAgICB0aGlzLnRvdGFsQ291bnQgPSAwO1xuICAgIC8vIEV2ZXJ5IGl0ZW0gY2xhc3NpZmllZCBpbiB0aGUgbW9kZWxcbiAgICB0aGlzLmRhdGEgPSB7fTtcbn07XG5cbi8qKlxuICogVHJhaW4gdGhlIGNsYXNzaWZpZXIgd2l0aCBhIG5ldyBpdGVtLCB3aGljaCBoYXMgYSBzaW5nbGVcbiAqIGRpbWVuc2lvbiBvZiBKYXZhc2NyaXB0IGxpdGVyYWwga2V5cyBhbmQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIGFuIG9iamVjdCB3aXRoIHNpbmdseS1kZWVwIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSB0aGUgY2F0ZWdvcnkgdGhpcyBpdGVtIGJlbG9uZ3MgdG9cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gYWRkcyB0aGUgaXRlbSB0byB0aGUgY2xhc3NpZmllclxuICovXG5CYXllc2lhbkNsYXNzaWZpZXIucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gdHJhaW4gKGl0ZW0sIGNhdGVnb3J5KSB7XG4gICAgLy8gSWYgdGhlIGRhdGEgb2JqZWN0IGRvZXNuJ3QgaGF2ZSBhbnkgdmFsdWVzXG4gICAgLy8gZm9yIHRoaXMgY2F0ZWdvcnksIGNyZWF0ZSBhIG5ldyBvYmplY3QgZm9yIGl0LlxuICAgIGlmICghdGhpcy5kYXRhW2NhdGVnb3J5XSkge1xuICAgICAgICB0aGlzLmRhdGFbY2F0ZWdvcnldID0ge307XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2gga2V5IGluIHRoZSBpdGVtLlxuICAgIGZvciAodmFyIGsgaW4gaXRlbSkge1xuICAgICAgICB2YXIgdiA9IGl0ZW1ba107XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG5lc3RlZCBvYmplY3QgYGRhdGFbY2F0ZWdvcnldW2tdW2l0ZW1ba11dYFxuICAgICAgICAvLyB3aXRoIGFuIG9iamVjdCBvZiBrZXlzIHRoYXQgZXF1YWwgMC5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVtjYXRlZ29yeV1ba10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2NhdGVnb3J5XVtrXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGFbY2F0ZWdvcnldW2tdW3ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtjYXRlZ29yeV1ba11bdl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5kIGluY3JlbWVudCB0aGUga2V5IGZvciB0aGlzIGtleS92YWx1ZSBjb21iaW5hdGlvbi5cbiAgICAgICAgdGhpcy5kYXRhW2NhdGVnb3J5XVtrXVt2XSsrO1xuICAgIH1cblxuICAgIC8vIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGNsYXNzaWZpZWRcbiAgICB0aGlzLnRvdGFsQ291bnQrKztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzY29yZSBvZiBob3cgd2VsbCB0aGlzIGl0ZW0gbWF0Y2hlcyBhbGxcbiAqIHBvc3NpYmxlIGNhdGVnb3JpZXMgYmFzZWQgb24gaXRzIGF0dHJpYnV0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSBhbiBpdGVtIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB3aXRoIHRyYWluXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvZiBwcm9iYWJpbGl0aWVzIHRoYXQgdGhpcyBpdGVtIGJlbG9uZ3MgdG8gYVxuICogZ2l2ZW4gY2F0ZWdvcnkuXG4gKi9cbkJheWVzaWFuQ2xhc3NpZmllci5wcm90b3R5cGUuc2NvcmUgPSBmdW5jdGlvbiBzY29yZSAoaXRlbSkge1xuICAgIC8vIEluaXRpYWxpemUgYW4gZW1wdHkgYXJyYXkgb2Ygb2RkcyBwZXIgY2F0ZWdvcnkuXG4gICAgdmFyIG9kZHMgPSB7fTtcbiAgICB2YXIgY2F0ZWdvcnk7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2gga2V5IGluIHRoZSBpdGVtLFxuICAgIC8vIHRoZW4gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggY2F0ZWdvcnkgdGhhdCBoYXMgYmVlbiB1c2VkXG4gICAgLy8gaW4gcHJldmlvdXMgY2FsbHMgdG8gYC50cmFpbigpYFxuICAgIGZvciAodmFyIGsgaW4gaXRlbSkge1xuICAgICAgICB2YXIgdiA9IGl0ZW1ba107XG4gICAgICAgIGZvciAoY2F0ZWdvcnkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgb2JqZWN0IGZvciBzdG9yaW5nIGtleSAtIHZhbHVlIGNvbWJpbmF0aW9uc1xuICAgICAgICAgICAgLy8gZm9yIHRoaXMgY2F0ZWdvcnkuXG4gICAgICAgICAgICBvZGRzW2NhdGVnb3J5XSA9IHt9O1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGl0ZW0gZG9lc24ndCBldmVuIGhhdmUgYSBwcm9wZXJ0eSwgaXQgY291bnRzIGZvciBub3RoaW5nLFxuICAgICAgICAgICAgLy8gYnV0IGlmIGl0IGRvZXMgaGF2ZSB0aGUgcHJvcGVydHkgdGhhdCB3ZSdyZSBsb29raW5nIGZvciBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgaXRlbSB0byBjYXRlZ29yaXplLCBpdCBjb3VudHMgYmFzZWQgb24gaG93IHBvcHVsYXIgaXQgaXNcbiAgICAgICAgICAgIC8vIHZlcnN1cyB0aGUgd2hvbGUgcG9wdWxhdGlvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbY2F0ZWdvcnldW2tdKSB7XG4gICAgICAgICAgICAgICAgb2Rkc1tjYXRlZ29yeV1bayArIFwiX1wiICsgdl0gPVxuICAgICAgICAgICAgICAgICAgICAodGhpcy5kYXRhW2NhdGVnb3J5XVtrXVt2XSB8fCAwKSAvIHRoaXMudG90YWxDb3VudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Rkc1tjYXRlZ29yeV1bayArIFwiX1wiICsgdl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIGEgbmV3IG9iamVjdCB0aGF0IHdpbGwgY29udGFpbiBzdW1zIG9mIHRoZXNlIG9kZHMgYnkgY2F0ZWdvcnlcbiAgICB2YXIgb2Rkc1N1bXMgPSB7fTtcblxuICAgIGZvciAoY2F0ZWdvcnkgaW4gb2Rkcykge1xuICAgICAgICAvLyBUYWxseSBhbGwgb2YgdGhlIG9kZHMgZm9yIGVhY2ggY2F0ZWdvcnktY29tYmluYXRpb24gcGFpciAtXG4gICAgICAgIC8vIHRoZSBub24tZXhpc3RlbmNlIG9mIGEgY2F0ZWdvcnkgZG9lcyBub3QgYWRkIGFueXRoaW5nIHRvIHRoZVxuICAgICAgICAvLyBzY29yZS5cbiAgICAgICAgb2Rkc1N1bXNbY2F0ZWdvcnldID0gMDtcbiAgICAgICAgZm9yICh2YXIgY29tYmluYXRpb24gaW4gb2Rkc1tjYXRlZ29yeV0pIHtcbiAgICAgICAgICAgIG9kZHNTdW1zW2NhdGVnb3J5XSArPSBvZGRzW2NhdGVnb3J5XVtjb21iaW5hdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2Rkc1N1bXM7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBzaW5nbGUtbGF5ZXIgW1BlcmNlcHRyb24gQ2xhc3NpZmllcl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QZXJjZXB0cm9uKSB0aGF0IHRha2VzXG4gKiBhcnJheXMgb2YgbnVtYmVycyBhbmQgcHJlZGljdHMgd2hldGhlciB0aGV5IHNob3VsZCBiZSBjbGFzc2lmaWVkXG4gKiBhcyBlaXRoZXIgMCBvciAxIChuZWdhdGl2ZSBvciBwb3NpdGl2ZSBleGFtcGxlcykuXG4gKiBAY2xhc3NcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgdGhlIG1vZGVsXG4gKiB2YXIgcCA9IG5ldyBQZXJjZXB0cm9uTW9kZWwoKTtcbiAqIC8vIFRyYWluIHRoZSBtb2RlbCB3aXRoIGlucHV0IHdpdGggYSBkaWFnb25hbCBib3VuZGFyeS5cbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gKiAgICAgcC50cmFpbihbMSwgMV0sIDEpO1xuICogICAgIHAudHJhaW4oWzAsIDFdLCAwKTtcbiAqICAgICBwLnRyYWluKFsxLCAwXSwgMCk7XG4gKiAgICAgcC50cmFpbihbMCwgMF0sIDApO1xuICogfVxuICogcC5wcmVkaWN0KFswLCAwXSk7IC8vIDBcbiAqIHAucHJlZGljdChbMCwgMV0pOyAvLyAwXG4gKiBwLnByZWRpY3QoWzEsIDBdKTsgLy8gMFxuICogcC5wcmVkaWN0KFsxLCAxXSk7IC8vIDFcbiAqL1xudmFyIFBlcmNlcHRyb25Nb2RlbCA9IGZ1bmN0aW9uIFBlcmNlcHRyb25Nb2RlbCgpIHtcbiAgICAvLyBUaGUgd2VpZ2h0cywgb3IgY29lZmZpY2llbnRzIG9mIHRoZSBtb2RlbDtcbiAgICAvLyB3ZWlnaHRzIGFyZSBvbmx5IHBvcHVsYXRlZCB3aGVuIHRyYWluaW5nIHdpdGggZGF0YS5cbiAgICB0aGlzLndlaWdodHMgPSBbXTtcbiAgICAvLyBUaGUgYmlhcyB0ZXJtLCBvciBpbnRlcmNlcHQ7IGl0IGlzIGFsc28gYSB3ZWlnaHQgYnV0XG4gICAgLy8gaXQncyBzdG9yZWQgc2VwYXJhdGVseSBmb3IgY29udmVuaWVuY2UgYXMgaXQgaXMgYWx3YXlzXG4gICAgLy8gbXVsdGlwbGllZCBieSBvbmUuXG4gICAgdGhpcy5iaWFzID0gMDtcbn07XG4vKipcbiAqICoqUHJlZGljdCoqOiBVc2UgYW4gYXJyYXkgb2YgZmVhdHVyZXMgd2l0aCB0aGUgd2VpZ2h0IGFycmF5IGFuZCBiaWFzXG4gKiB0byBwcmVkaWN0IHdoZXRoZXIgYW4gZXhhbXBsZSBpcyBsYWJlbGVkIDAgb3IgMS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVzIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFzIG51bWJlcnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDEgaWYgdGhlIHNjb3JlIGlzIG92ZXIgMCwgb3RoZXJ3aXNlIDBcbiAqL1xuUGVyY2VwdHJvbk1vZGVsLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gcHJlZGljdCAoZmVhdHVyZXMpIHtcbiAgICAvLyBPbmx5IHByZWRpY3QgaWYgcHJldmlvdXNseSB0cmFpbmVkXG4gICAgLy8gb24gdGhlIHNhbWUgc2l6ZSBmZWF0dXJlIGFycmF5KHMpLlxuICAgIGlmIChmZWF0dXJlcy5sZW5ndGggIT09IHRoaXMud2VpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2YgZmVhdHVyZXMgdGltZXMgd2VpZ2h0cyxcbiAgICAvLyB3aXRoIHRoZSBiaWFzIGFkZGVkIChpbXBsaWNpdGx5IHRpbWVzIG9uZSkuXG4gICAgdmFyIHNjb3JlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzY29yZSArPSB0aGlzLndlaWdodHNbaV0gKiBmZWF0dXJlc1tpXTtcbiAgICB9XG4gICAgc2NvcmUgKz0gdGhpcy5iaWFzO1xuXG4gICAgLy8gQ2xhc3NpZnkgYXMgMSBpZiB0aGUgc2NvcmUgaXMgb3ZlciAwLCBvdGhlcndpc2UgMC5cbiAgICBpZiAoc2NvcmUgPiAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogKipUcmFpbioqIHRoZSBjbGFzc2lmaWVyIHdpdGggYSBuZXcgZXhhbXBsZSwgd2hpY2ggaXNcbiAqIGEgbnVtZXJpYyBhcnJheSBvZiBmZWF0dXJlcyBhbmQgYSAwIG9yIDEgbGFiZWwuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmZWF0dXJlcyBhbiBhcnJheSBvZiBmZWF0dXJlcyBhcyBudW1iZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gbGFiZWwgZWl0aGVyIDAgb3IgMVxuICogQHJldHVybnMge1BlcmNlcHRyb25Nb2RlbH0gdGhpc1xuICovXG5QZXJjZXB0cm9uTW9kZWwucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gdHJhaW4gKGZlYXR1cmVzLCBsYWJlbCkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCBvbmx5IGxhYmVscyBvZiAwIG9yIDEgYXJlIGNvbnNpZGVyZWQuXG4gICAgaWYgKGxhYmVsICE9PSAwICYmIGxhYmVsICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGUgbGVuZ3RoIG9mIHRoZSBmZWF0dXJlIGFycmF5IGRldGVybWluZXNcbiAgICAvLyB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWlnaHQgYXJyYXkuXG4gICAgLy8gVGhlIHBlcmNlcHRyb24gd2lsbCBjb250aW51ZSBsZWFybmluZyBhcyBsb25nIGFzXG4gICAgLy8gaXQga2VlcHMgc2VlaW5nIGZlYXR1cmUgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aC5cbiAgICAvLyBXaGVuIGl0IHNlZXMgYSBuZXcgZGF0YSBzaGFwZSwgaXQgaW5pdGlhbGl6ZXMuXG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCAhPT0gdGhpcy53ZWlnaHRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLndlaWdodHMgPSBmZWF0dXJlcztcbiAgICAgICAgdGhpcy5iaWFzID0gMTtcbiAgICB9XG4gICAgLy8gTWFrZSBhIHByZWRpY3Rpb24gYmFzZWQgb24gY3VycmVudCB3ZWlnaHRzLlxuICAgIHZhciBwcmVkaWN0aW9uID0gdGhpcy5wcmVkaWN0KGZlYXR1cmVzKTtcbiAgICAvLyBVcGRhdGUgdGhlIHdlaWdodHMgaWYgdGhlIHByZWRpY3Rpb24gaXMgd3JvbmcuXG4gICAgaWYgKHR5cGVvZiBwcmVkaWN0aW9uID09PSBcIm51bWJlclwiICYmIHByZWRpY3Rpb24gIT09IGxhYmVsKSB7XG4gICAgICAgIHZhciBncmFkaWVudCA9IGxhYmVsIC0gcHJlZGljdGlvbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud2VpZ2h0c1tpXSArPSBncmFkaWVudCAqIGZlYXR1cmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmlhcyArPSBncmFkaWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdlIHVzZSBgzrVgLCBlcHNpbG9uLCBhcyBhIHN0b3BwaW5nIGNyaXRlcmlvbiB3aGVuIHdlIHdhbnQgdG8gaXRlcmF0ZVxuICogdW50aWwgd2UncmUgXCJjbG9zZSBlbm91Z2hcIi4gRXBzaWxvbiBpcyBhIHZlcnkgc21hbGwgbnVtYmVyOiBmb3JcbiAqIHNpbXBsZSBzdGF0aXN0aWNzLCB0aGF0IG51bWJlciBpcyAqKjAuMDAwMSoqXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIGNhbGN1bGF0aW9ucyBsaWtlIHRoZSBiaW5vbWlhbERpc3RyaWJ1dGlvbiwgaW4gd2hpY2hcbiAqIHRoZSBwcm9jZXNzIG9mIGZpbmRpbmcgYSB2YWx1ZSBpcyBbaXRlcmF0aXZlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JdGVyYXRpdmVfbWV0aG9kKTpcbiAqIGl0IHByb2dyZXNzZXMgdW50aWwgaXQgaXMgY2xvc2UgZW5vdWdoLlxuICpcbiAqIEJlbG93IGlzIGFuIGV4YW1wbGUgb2YgdXNpbmcgZXBzaWxvbiBpbiBbZ3JhZGllbnQgZGVzY2VudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JhZGllbnRfZGVzY2VudCksXG4gKiB3aGVyZSB3ZSdyZSB0cnlpbmcgdG8gZmluZCBhIGxvY2FsIG1pbmltdW0gb2YgYSBmdW5jdGlvbidzIGRlcml2YXRpdmUsXG4gKiBnaXZlbiBieSB0aGUgYGZEZXJpdmF0aXZlYCBtZXRob2QuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZyb20gY2FsY3VsYXRpb24sIHdlIGV4cGVjdCB0aGF0IHRoZSBsb2NhbCBtaW5pbXVtIG9jY3VycyBhdCB4PTkvNFxuICogdmFyIHhfb2xkID0gMDtcbiAqIC8vIFRoZSBhbGdvcml0aG0gc3RhcnRzIGF0IHg9NlxuICogdmFyIHhfbmV3ID0gNjtcbiAqIHZhciBzdGVwU2l6ZSA9IDAuMDE7XG4gKlxuICogZnVuY3Rpb24gZkRlcml2YXRpdmUoeCkge1xuICogICByZXR1cm4gNCAqIE1hdGgucG93KHgsIDMpIC0gOSAqIE1hdGgucG93KHgsIDIpO1xuICogfVxuICpcbiAqIC8vIFRoZSBsb29wIHJ1bnMgdW50aWwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcHJldmlvdXNcbiAqIC8vIHZhbHVlIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gZXBzaWxvbiAtIGEgcm91Z2hcbiAqIC8vIG1lYXVyZSBvZiAnY2xvc2UgZW5vdWdoJ1xuICogd2hpbGUgKE1hdGguYWJzKHhfbmV3IC0geF9vbGQpID4gc3MuZXBzaWxvbikge1xuICogICB4X29sZCA9IHhfbmV3O1xuICogICB4X25ldyA9IHhfb2xkIC0gc3RlcFNpemUgKiBmRGVyaXZhdGl2ZSh4X29sZCk7XG4gKiB9XG4gKlxuICogY29uc29sZS5sb2coJ0xvY2FsIG1pbmltdW0gb2NjdXJzIGF0JywgeF9uZXcpO1xuICovXG52YXIgZXBzaWxvbiA9IDAuMDAwMTtcblxuLyoqXG4gKiBBIFtGYWN0b3JpYWxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZhY3RvcmlhbCksIHVzdWFsbHkgd3JpdHRlbiBuISwgaXMgdGhlIHByb2R1Y3Qgb2YgYWxsIHBvc2l0aXZlXG4gKiBpbnRlZ2VycyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbi4gT2Z0ZW4gZmFjdG9yaWFsIGlzIGltcGxlbWVudGVkXG4gKiByZWN1cnNpdmVseSwgYnV0IHRoaXMgaXRlcmF0aXZlIGFwcHJvYWNoIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyXG4gKiBhbmQgc2ltcGxlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBpbnB1dCwgbXVzdCBiZSBhbiBpbnRlZ2VyIG51bWJlciAxIG9yIGdyZWF0ZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGZhY3RvcmlhbDogbiFcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBuIGlzIGxlc3MgdGhhbiAwIG9yIG5vdCBhbiBpbnRlZ2VyXG4gKiBAZXhhbXBsZVxuICogZmFjdG9yaWFsKDUpOyAvLyA9PiAxMjBcbiAqL1xuZnVuY3Rpb24gZmFjdG9yaWFsKG4pIHtcbiAgICAvLyBmYWN0b3JpYWwgaXMgbWF0aGVtYXRpY2FsbHkgdW5kZWZpbmVkIGZvciBuZWdhdGl2ZSBudW1iZXJzXG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhY3RvcmlhbCByZXF1aXJlcyBhIG5vbi1uZWdhdGl2ZSB2YWx1ZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5mbG9vcihuKSAhPT0gbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3JpYWwgcmVxdWlyZXMgYW4gaW50ZWdlciBpbnB1dFwiKTtcbiAgICB9XG5cbiAgICAvLyB0eXBpY2FsbHkgeW91J2xsIGV4cGFuZCB0aGUgZmFjdG9yaWFsIGZ1bmN0aW9uIGdvaW5nIGRvd24sIGxpa2VcbiAgICAvLyA1ISA9IDUgKiA0ICogMyAqIDIgKiAxLiBUaGlzIGlzIGdvaW5nIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sXG4gICAgLy8gY291bnRpbmcgZnJvbSAyIHVwIHRvIHRoZSBudW1iZXIgaW4gcXVlc3Rpb24sIGFuZCBzaW5jZSBhbnl0aGluZ1xuICAgIC8vIG11bHRpcGxpZWQgYnkgMSBpcyBpdHNlbGYsIHRoZSBsb29wIG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgMi5cbiAgICB2YXIgYWNjdW11bGF0b3IgPSAxO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDw9IG47IGkrKykge1xuICAgICAgICAvLyBmb3IgZWFjaCBudW1iZXIgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgbnVtYmVyIGBuYCwgbXVsdGlwbHlcbiAgICAgICAgLy8gdGhlIGFjY3VtdWxhdG9yIG15IHRoYXQgbnVtYmVyLlxuICAgICAgICBhY2N1bXVsYXRvciAqPSBpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgW2dhbW1hIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbikgb2YgYSB2YWx1ZSB1c2luZyBOZW1lcycgYXBwcm94aW1hdGlvbi5cbiAqIFRoZSBnYW1tYSBvZiBuIGlzIGVxdWl2YWxlbnQgdG8gKG4tMSkhLCBidXQgdW5saWtlIHRoZSBmYWN0b3JpYWwgZnVuY3Rpb24sIGdhbW1hIGlzIGRlZmluZWQgZm9yIGFsbCByZWFsIG4gZXhjZXB0IHplcm9cbiAqIGFuZCBuZWdhdGl2ZSBpbnRlZ2VycyAod2hlcmUgTmFOIGlzIHJldHVybmVkKS4gTm90ZSwgdGhlIGdhbW1hIGZ1bmN0aW9uIGlzIGFsc28gd2VsbC1kZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnMsXG4gKiB0aG91Z2ggdGhpcyBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZG9lcyBub3QgaGFuZGxlIGNvbXBsZXggbnVtYmVycyBhcyBpbnB1dCB2YWx1ZXMuXG4gKiBOZW1lcycgYXBwcm94aW1hdGlvbiBpcyBkZWZpbmVkIFtoZXJlXShodHRwczovL2FyeGl2Lm9yZy9hYnMvMTAwMy42MDIwKSBhcyBUaGVvcmVtIDIuMi5cbiAqIE5lZ2F0aXZlIHZhbHVlcyB1c2UgW0V1bGVyJ3MgcmVmbGVjdGlvbiBmb3JtdWxhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbiNQcm9wZXJ0aWVzKSBmb3IgY29tcHV0YXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG4gQW55IHJlYWwgbnVtYmVyIGV4Y2VwdCBmb3IgemVybyBhbmQgbmVnYXRpdmUgaW50ZWdlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZ2FtbWEgb2YgdGhlIGlucHV0IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBnYW1tYSgxMS41KTsgLy8gMTE4OTk0MjMuMDg0MDM3MDM4XG4gKiBnYW1tYSgtMTEuNSk7IC8vIDIuMjk1NzU4MTA0ODE2MDllLThcbiAqIGdhbW1hKDUpOyAvLyAyNFxuICovXG5mdW5jdGlvbiBnYW1tYShuKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgICAgLy8gZ2FtbWEgbm90IGRlZmluZWQgZm9yIHplcm8gb3IgbmVnYXRpdmUgaW50ZWdlcnNcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlIGZhY3RvcmlhbCBmb3IgaW50ZWdlciBpbnB1dHNcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3JpYWwobiAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVjcmVtZW50IG4sIGJlY2F1c2UgYXBwcm94aW1hdGlvbiBpcyBkZWZpbmVkIGZvciBuIC0gMVxuICAgIG4tLTtcblxuICAgIGlmIChuIDwgMCkge1xuICAgICAgICAvLyBVc2UgRXVsZXIncyByZWZsZWN0aW9uIGZvcm11bGEgZm9yIG5lZ2F0aXZlIGlucHV0c1xuICAgICAgICAvLyBzZWU6ICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbiNQcm9wZXJ0aWVzXG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiAtbikgKiBnYW1tYSgtbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5lbWVzJyBleHBhbnNpb24gYXBwcm94aW1hdGlvblxuICAgICAgICB2YXIgc2VyaWVzQ29lZmZpY2llbnQgPVxuICAgICAgICAgICAgTWF0aC5wb3cobiAvIE1hdGguRSwgbikgKiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgKiAobiArIDEgLyA2KSk7XG5cbiAgICAgICAgdmFyIHNlcmllc0Rlbm9tID0gbiArIDEgLyA0O1xuXG4gICAgICAgIHZhciBzZXJpZXNFeHBhbnNpb24gPVxuICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAxIC8gMTQ0IC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDIpIC1cbiAgICAgICAgICAgIDEgLyAxMjk2MCAvIE1hdGgucG93KHNlcmllc0Rlbm9tLCAzKSAtXG4gICAgICAgICAgICAyNTcgLyAyMDczNjAgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNCkgLVxuICAgICAgICAgICAgNTIgLyAyNjEyNzM2IC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDUpICtcbiAgICAgICAgICAgIDU3NDExNzMgLyA5NDA1ODQ5NjAwIC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDYpICtcbiAgICAgICAgICAgIDM3NTI5IC8gMTg4MTE2OTkyMDAgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNyk7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc0NvZWZmaWNpZW50ICogc2VyaWVzRXhwYW5zaW9uO1xuICAgIH1cbn1cblxuLy8gRGVmaW5lIHNlcmllcyBjb2VmZmljaWVudHNcbnZhciBDT0VGRklDSUVOVFMgPSBbXG4gICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MiwgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LCAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAgIDE0LjEzNjA5Nzk3NDc0MTc0NzE3NCwgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCwgLTAuOTgzNzQ0NzUzMDQ4Nzk1NjQ2NzdlLTQsXG4gICAgMC4xNTgwODg3MDMyMjQ5MTI0ODg4NGUtMywgLTAuMjEwMjY0NDQxNzI0MTA0ODgzMTllLTMsXG4gICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyZS0zLCAtMC4xNjQzMTgxMDY1MzY3NjM4OTAyMmUtMyxcbiAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LCAtMC4yNjE5MDgzODQwMTU4MTQwODY3ZS00LFxuICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbl07XG5cbnZhciBnID0gNjA3IC8gMTI4O1xudmFyIExPR1NRUlQyUEkgPSBNYXRoLmxvZyhNYXRoLnNxcnQoMiAqIE1hdGguUEkpKTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsb2dhcml0aG0gb2YgdGhlIFtnYW1tYSBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2FtbWFfZnVuY3Rpb24pIG9mIGEgdmFsdWUgdXNpbmcgTGFuY3pvcycgYXBwcm94aW1hdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYXMgaW5wdXQgYW55IHJlYWwtdmFsdWUgbiBncmVhdGVyIHRoYW4gMC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciB2YWx1ZXMgb2YgbiB0b28gbGFyZ2UgZm9yIHRoZSBub3JtYWwgZ2FtbWEgZnVuY3Rpb24gKG4gPiAxNjUpLlxuICogVGhlIGNvZGUgaXMgYmFzZWQgb24gTGFuY3pvJ3MgR2FtbWEgYXBwcm94aW1hdGlvbiwgZGVmaW5lZCBbaGVyZV0oaHR0cDovL215LmZpdC5lZHUvfmdhYmRvL2dhbW1hLnR4dCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG4gQW55IHJlYWwgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGxvZ2FyaXRobSBvZiBnYW1tYSBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGdhbW1hbG4oNTAwKTsgLy8gMjYwNS4xMTU4NTAzNjE3MzM1XG4gKiBnYW1tYWxuKDIuNCk7IC8vIDAuMjE2ODU5MzIyNDQ4ODQwNDNcbiAqL1xuZnVuY3Rpb24gZ2FtbWFsbihuKSB7XG4gICAgLy8gUmV0dXJuIGluZmluaXR5IGlmIHZhbHVlIG5vdCBpbiBkb21haW5cbiAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuXG4gICAgLy8gRGVjcmVtZW50IG4sIGJlY2F1c2UgYXBwcm94aW1hdGlvbiBpcyBkZWZpbmVkIGZvciBuIC0gMVxuICAgIG4tLTtcblxuICAgIC8vIENyZWF0ZSBzZXJpZXMgYXBwcm94aW1hdGlvblxuICAgIHZhciBhID0gQ09FRkZJQ0lFTlRTWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICAgIGEgKz0gQ09FRkZJQ0lFTlRTW2ldIC8gKG4gKyBpKTtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gZyArIDAuNSArIG47XG5cbiAgICAvLyBSZXR1cm4gbmF0dXJhbCBsb2dhcml0aG0gb2YgZ2FtbWEobilcbiAgICByZXR1cm4gTE9HU1FSVDJQSSArIE1hdGgubG9nKGEpIC0gdG1wICsgKG4gKyAwLjUpICogTWF0aC5sb2codG1wKTtcbn1cblxuLyoqXG4gKiBUaGUgW0Jlcm5vdWxsaSBkaXN0cmlidXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybm91bGxpX2Rpc3RyaWJ1dGlvbilcbiAqIGlzIHRoZSBwcm9iYWJpbGl0eSBkaXNjcmV0ZVxuICogZGlzdHJpYnV0aW9uIG9mIGEgcmFuZG9tIHZhcmlhYmxlIHdoaWNoIHRha2VzIHZhbHVlIDEgd2l0aCBzdWNjZXNzXG4gKiBwcm9iYWJpbGl0eSBgcGAgYW5kIHZhbHVlIDAgd2l0aCBmYWlsdXJlXG4gKiBwcm9iYWJpbGl0eSBgcWAgPSAxIC0gYHBgLiBJdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIHJlcHJlc2VudCB0aGVcbiAqIHRvc3Mgb2YgYSBjb2luLCB3aGVyZSBcIjFcIiBpcyBkZWZpbmVkIHRvIG1lYW4gXCJoZWFkc1wiIGFuZCBcIjBcIiBpcyBkZWZpbmVkXG4gKiB0byBtZWFuIFwidGFpbHNcIiAob3IgdmljZSB2ZXJzYSkuIEl0IGlzXG4gKiBhIHNwZWNpYWwgY2FzZSBvZiBhIEJpbm9taWFsIERpc3RyaWJ1dGlvblxuICogd2hlcmUgYG5gID0gMS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcCBpbnB1dCB2YWx1ZSwgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZVxuICogQHJldHVybnMge251bWJlcltdfSB2YWx1ZXMgb2YgYmVybm91bGxpIGRpc3RyaWJ1dGlvbiBhdCB0aGlzIHBvaW50XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcCBpcyBvdXRzaWRlIDAgYW5kIDFcbiAqIEBleGFtcGxlXG4gKiBiZXJub3VsbGlEaXN0cmlidXRpb24oMC4zKTsgLy8gPT4gWzAuNywgMC4zXVxuICovXG5mdW5jdGlvbiBiZXJub3VsbGlEaXN0cmlidXRpb24ocCkgLyo6IG51bWJlcltdICovIHtcbiAgICAvLyBDaGVjayB0aGF0IGBwYCBpcyBhIHZhbGlkIHByb2JhYmlsaXR5ICgwIOKJpCBwIOKJpCAxKVxuICAgIGlmIChwIDwgMCB8fCBwID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcImJlcm5vdWxsaURpc3RyaWJ1dGlvbiByZXF1aXJlcyBwcm9iYWJpbGl0eSB0byBiZSBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWzEgLSBwLCBwXTtcbn1cblxuLyoqXG4gKiBUaGUgW0Jpbm9taWFsIERpc3RyaWJ1dGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaW5vbWlhbF9kaXN0cmlidXRpb24pIGlzIHRoZSBkaXNjcmV0ZSBwcm9iYWJpbGl0eVxuICogZGlzdHJpYnV0aW9uIG9mIHRoZSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGluIGEgc2VxdWVuY2Ugb2YgbiBpbmRlcGVuZGVudCB5ZXMvbm8gZXhwZXJpbWVudHMsIGVhY2ggb2Ygd2hpY2ggeWllbGRzXG4gKiBzdWNjZXNzIHdpdGggcHJvYmFiaWxpdHkgYHByb2JhYmlsaXR5YC4gU3VjaCBhIHN1Y2Nlc3MvZmFpbHVyZSBleHBlcmltZW50IGlzIGFsc28gY2FsbGVkIGEgQmVybm91bGxpIGV4cGVyaW1lbnQgb3JcbiAqIEJlcm5vdWxsaSB0cmlhbDsgd2hlbiB0cmlhbHMgPSAxLCB0aGUgQmlub21pYWwgRGlzdHJpYnV0aW9uIGlzIGEgQmVybm91bGxpIERpc3RyaWJ1dGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdHJpYWxzIG51bWJlciBvZiB0cmlhbHMgdG8gc2ltdWxhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9iYWJpbGl0eVxuICogQHJldHVybnMge251bWJlcltdfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gYmlub21pYWxEaXN0cmlidXRpb24odHJpYWxzLCBwcm9iYWJpbGl0eSkgLyo6ID9udW1iZXJbXSAqLyB7XG4gICAgLy8gQ2hlY2sgdGhhdCBgcGAgaXMgYSB2YWxpZCBwcm9iYWJpbGl0eSAoMCDiiaQgcCDiiaQgMSksXG4gICAgLy8gdGhhdCBgbmAgaXMgYW4gaW50ZWdlciwgc3RyaWN0bHkgcG9zaXRpdmUuXG4gICAgaWYgKHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEgfHwgdHJpYWxzIDw9IDAgfHwgdHJpYWxzICUgMSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFdlIGluaXRpYWxpemUgYHhgLCB0aGUgcmFuZG9tIHZhcmlhYmxlLCBhbmQgYGFjY3VtdWxhdG9yYCwgYW4gYWNjdW11bGF0b3JcbiAgICAvLyBmb3IgdGhlIGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uIGZ1bmN0aW9uIHRvIDAuIGBkaXN0cmlidXRpb25fZnVuY3Rpb25zYFxuICAgIC8vIGlzIHRoZSBvYmplY3Qgd2UnbGwgcmV0dXJuIHdpdGggdGhlIGBwcm9iYWJpbGl0eV9vZl94YCBhbmQgdGhlXG4gICAgLy8gYGN1bXVsYXRpdmVQcm9iYWJpbGl0eV9vZl94YCwgYXMgd2VsbCBhcyB0aGUgY2FsY3VsYXRlZCBtZWFuICZcbiAgICAvLyB2YXJpYW5jZS4gV2UgaXRlcmF0ZSB1bnRpbCB0aGUgYGN1bXVsYXRpdmVQcm9iYWJpbGl0eV9vZl94YCBpc1xuICAgIC8vIHdpdGhpbiBgZXBzaWxvbmAgb2YgMS4wLlxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgY3VtdWxhdGl2ZVByb2JhYmlsaXR5ID0gMDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICB2YXIgYmlub21pYWxDb2VmZmljaWVudCA9IDE7XG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBpdGVyYXRlcyB0aHJvdWdoIGVhY2ggcG90ZW50aWFsIG91dGNvbWUsXG4gICAgLy8gdW50aWwgdGhlIGBjdW11bGF0aXZlUHJvYmFiaWxpdHlgIGlzIHZlcnkgY2xvc2UgdG8gMSwgYXRcbiAgICAvLyB3aGljaCBwb2ludCB3ZSd2ZSBkZWZpbmVkIHRoZSB2YXN0IG1ham9yaXR5IG9mIG91dGNvbWVzXG4gICAgZG8ge1xuICAgICAgICAvLyBhIFtwcm9iYWJpbGl0eSBtYXNzIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9iYWJpbGl0eV9tYXNzX2Z1bmN0aW9uKVxuICAgICAgICBjZWxsc1t4XSA9XG4gICAgICAgICAgICBiaW5vbWlhbENvZWZmaWNpZW50ICpcbiAgICAgICAgICAgIE1hdGgucG93KHByb2JhYmlsaXR5LCB4KSAqXG4gICAgICAgICAgICBNYXRoLnBvdygxIC0gcHJvYmFiaWxpdHksIHRyaWFscyAtIHgpO1xuICAgICAgICBjdW11bGF0aXZlUHJvYmFiaWxpdHkgKz0gY2VsbHNbeF07XG4gICAgICAgIHgrKztcbiAgICAgICAgYmlub21pYWxDb2VmZmljaWVudCA9IChiaW5vbWlhbENvZWZmaWNpZW50ICogKHRyaWFscyAtIHggKyAxKSkgLyB4O1xuICAgICAgICAvLyB3aGVuIHRoZSBjdW11bGF0aXZlUHJvYmFiaWxpdHkgaXMgbmVhcmx5IDEsIHdlJ3ZlIGNhbGN1bGF0ZWRcbiAgICAgICAgLy8gdGhlIHVzZWZ1bCByYW5nZSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxuICAgIH0gd2hpbGUgKGN1bXVsYXRpdmVQcm9iYWJpbGl0eSA8IDEgLSBlcHNpbG9uKTtcblxuICAgIHJldHVybiBjZWxscztcbn1cblxuLyoqXG4gKiBUaGUgW1BvaXNzb24gRGlzdHJpYnV0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvaXNzb25fZGlzdHJpYnV0aW9uKVxuICogaXMgYSBkaXNjcmV0ZSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24gdGhhdCBleHByZXNzZXMgdGhlIHByb2JhYmlsaXR5XG4gKiBvZiBhIGdpdmVuIG51bWJlciBvZiBldmVudHMgb2NjdXJyaW5nIGluIGEgZml4ZWQgaW50ZXJ2YWwgb2YgdGltZVxuICogYW5kL29yIHNwYWNlIGlmIHRoZXNlIGV2ZW50cyBvY2N1ciB3aXRoIGEga25vd24gYXZlcmFnZSByYXRlIGFuZFxuICogaW5kZXBlbmRlbnRseSBvZiB0aGUgdGltZSBzaW5jZSB0aGUgbGFzdCBldmVudC5cbiAqXG4gKiBUaGUgUG9pc3NvbiBEaXN0cmlidXRpb24gaXMgY2hhcmFjdGVyaXplZCBieSB0aGUgc3RyaWN0bHkgcG9zaXRpdmVcbiAqIG1lYW4gYXJyaXZhbCBvciBvY2N1cnJlbmNlIHJhdGUsIGDOu2AuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxhbWJkYSBsb2NhdGlvbiBwb2lzc29uIGRpc3RyaWJ1dGlvblxuICogQHJldHVybnMge251bWJlcltdfSB2YWx1ZXMgb2YgcG9pc3NvbiBkaXN0cmlidXRpb24gYXQgdGhhdCBwb2ludFxuICovXG5mdW5jdGlvbiBwb2lzc29uRGlzdHJpYnV0aW9uKGxhbWJkYSkgLyo6ID9udW1iZXJbXSAqLyB7XG4gICAgLy8gQ2hlY2sgdGhhdCBsYW1iZGEgaXMgc3RyaWN0bHkgcG9zaXRpdmVcbiAgICBpZiAobGFtYmRhIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBvdXIgY3VycmVudCBwbGFjZSBpbiB0aGUgZGlzdHJpYnV0aW9uXG4gICAgdmFyIHggPSAwO1xuICAgIC8vIGFuZCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IGN1bXVsYXRpdmUgcHJvYmFiaWxpdHksIGluXG4gICAgLy8gb3JkZXIgdG8ga25vdyB3aGVuIHRvIHN0b3AgY2FsY3VsYXRpbmcgY2hhbmNlcy5cbiAgICB2YXIgY3VtdWxhdGl2ZVByb2JhYmlsaXR5ID0gMDtcbiAgICAvLyB0aGUgY2FsY3VsYXRlZCBjZWxscyB0byBiZSByZXR1cm5lZFxuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIHZhciBmYWN0b3JpYWxYID0gMTtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGl0ZXJhdGVzIHRocm91Z2ggZWFjaCBwb3RlbnRpYWwgb3V0Y29tZSxcbiAgICAvLyB1bnRpbCB0aGUgYGN1bXVsYXRpdmVQcm9iYWJpbGl0eWAgaXMgdmVyeSBjbG9zZSB0byAxLCBhdFxuICAgIC8vIHdoaWNoIHBvaW50IHdlJ3ZlIGRlZmluZWQgdGhlIHZhc3QgbWFqb3JpdHkgb2Ygb3V0Y29tZXNcbiAgICBkbyB7XG4gICAgICAgIC8vIGEgW3Byb2JhYmlsaXR5IG1hc3MgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JhYmlsaXR5X21hc3NfZnVuY3Rpb24pXG4gICAgICAgIGNlbGxzW3hdID0gKE1hdGguZXhwKC1sYW1iZGEpICogTWF0aC5wb3cobGFtYmRhLCB4KSkgLyBmYWN0b3JpYWxYO1xuICAgICAgICBjdW11bGF0aXZlUHJvYmFiaWxpdHkgKz0gY2VsbHNbeF07XG4gICAgICAgIHgrKztcbiAgICAgICAgZmFjdG9yaWFsWCAqPSB4O1xuICAgICAgICAvLyB3aGVuIHRoZSBjdW11bGF0aXZlUHJvYmFiaWxpdHkgaXMgbmVhcmx5IDEsIHdlJ3ZlIGNhbGN1bGF0ZWRcbiAgICAgICAgLy8gdGhlIHVzZWZ1bCByYW5nZSBvZiB0aGlzIGRpc3RyaWJ1dGlvblxuICAgIH0gd2hpbGUgKGN1bXVsYXRpdmVQcm9iYWJpbGl0eSA8IDEgLSBlcHNpbG9uKTtcblxuICAgIHJldHVybiBjZWxscztcbn1cblxuLyoqXG4gKiAqKlBlcmNlbnRhZ2UgUG9pbnRzIG9mIHRoZSDPhzIgKENoaS1TcXVhcmVkKSBEaXN0cmlidXRpb24qKlxuICpcbiAqIFRoZSBbz4cyIChDaGktU3F1YXJlZCkgRGlzdHJpYnV0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoaS1zcXVhcmVkX2Rpc3RyaWJ1dGlvbikgaXMgdXNlZCBpbiB0aGUgY29tbW9uXG4gKiBjaGktc3F1YXJlZCB0ZXN0cyBmb3IgZ29vZG5lc3Mgb2YgZml0IG9mIGFuIG9ic2VydmVkIGRpc3RyaWJ1dGlvbiB0byBhIHRoZW9yZXRpY2FsIG9uZSwgdGhlIGluZGVwZW5kZW5jZSBvZiB0d29cbiAqIGNyaXRlcmlhIG9mIGNsYXNzaWZpY2F0aW9uIG9mIHF1YWxpdGF0aXZlIGRhdGEsIGFuZCBpbiBjb25maWRlbmNlIGludGVydmFsIGVzdGltYXRpb24gZm9yIGEgcG9wdWxhdGlvbiBzdGFuZGFyZFxuICogZGV2aWF0aW9uIG9mIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbiBmcm9tIGEgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbi5cbiAqXG4gKiBWYWx1ZXMgZnJvbSBBcHBlbmRpeCAxLCBUYWJsZSBJSUkgb2YgV2lsbGlhbSBXLiBIaW5lcyAmIERvdWdsYXMgQy4gTW9udGdvbWVyeSwgXCJQcm9iYWJpbGl0eSBhbmQgU3RhdGlzdGljcyBpblxuICogRW5naW5lZXJpbmcgYW5kIE1hbmFnZW1lbnQgU2NpZW5jZVwiLCBXaWxleSAoMTk4MCkuXG4gKi9cbnZhciBjaGlTcXVhcmVkRGlzdHJpYnV0aW9uVGFibGUgPSB7XG4gICAgMToge1xuICAgICAgICAwLjk5NTogMCxcbiAgICAgICAgMC45OTogMCxcbiAgICAgICAgMC45NzU6IDAsXG4gICAgICAgIDAuOTU6IDAsXG4gICAgICAgIDAuOTogMC4wMixcbiAgICAgICAgMC41OiAwLjQ1LFxuICAgICAgICAwLjE6IDIuNzEsXG4gICAgICAgIDAuMDU6IDMuODQsXG4gICAgICAgIDAuMDI1OiA1LjAyLFxuICAgICAgICAwLjAxOiA2LjYzLFxuICAgICAgICAwLjAwNTogNy44OFxuICAgIH0sXG4gICAgMjoge1xuICAgICAgICAwLjk5NTogMC4wMSxcbiAgICAgICAgMC45OTogMC4wMixcbiAgICAgICAgMC45NzU6IDAuMDUsXG4gICAgICAgIDAuOTU6IDAuMSxcbiAgICAgICAgMC45OiAwLjIxLFxuICAgICAgICAwLjU6IDEuMzksXG4gICAgICAgIDAuMTogNC42MSxcbiAgICAgICAgMC4wNTogNS45OSxcbiAgICAgICAgMC4wMjU6IDcuMzgsXG4gICAgICAgIDAuMDE6IDkuMjEsXG4gICAgICAgIDAuMDA1OiAxMC42XG4gICAgfSxcbiAgICAzOiB7XG4gICAgICAgIDAuOTk1OiAwLjA3LFxuICAgICAgICAwLjk5OiAwLjExLFxuICAgICAgICAwLjk3NTogMC4yMixcbiAgICAgICAgMC45NTogMC4zNSxcbiAgICAgICAgMC45OiAwLjU4LFxuICAgICAgICAwLjU6IDIuMzcsXG4gICAgICAgIDAuMTogNi4yNSxcbiAgICAgICAgMC4wNTogNy44MSxcbiAgICAgICAgMC4wMjU6IDkuMzUsXG4gICAgICAgIDAuMDE6IDExLjM0LFxuICAgICAgICAwLjAwNTogMTIuODRcbiAgICB9LFxuICAgIDQ6IHtcbiAgICAgICAgMC45OTU6IDAuMjEsXG4gICAgICAgIDAuOTk6IDAuMyxcbiAgICAgICAgMC45NzU6IDAuNDgsXG4gICAgICAgIDAuOTU6IDAuNzEsXG4gICAgICAgIDAuOTogMS4wNixcbiAgICAgICAgMC41OiAzLjM2LFxuICAgICAgICAwLjE6IDcuNzgsXG4gICAgICAgIDAuMDU6IDkuNDksXG4gICAgICAgIDAuMDI1OiAxMS4xNCxcbiAgICAgICAgMC4wMTogMTMuMjgsXG4gICAgICAgIDAuMDA1OiAxNC44NlxuICAgIH0sXG4gICAgNToge1xuICAgICAgICAwLjk5NTogMC40MSxcbiAgICAgICAgMC45OTogMC41NSxcbiAgICAgICAgMC45NzU6IDAuODMsXG4gICAgICAgIDAuOTU6IDEuMTUsXG4gICAgICAgIDAuOTogMS42MSxcbiAgICAgICAgMC41OiA0LjM1LFxuICAgICAgICAwLjE6IDkuMjQsXG4gICAgICAgIDAuMDU6IDExLjA3LFxuICAgICAgICAwLjAyNTogMTIuODMsXG4gICAgICAgIDAuMDE6IDE1LjA5LFxuICAgICAgICAwLjAwNTogMTYuNzVcbiAgICB9LFxuICAgIDY6IHtcbiAgICAgICAgMC45OTU6IDAuNjgsXG4gICAgICAgIDAuOTk6IDAuODcsXG4gICAgICAgIDAuOTc1OiAxLjI0LFxuICAgICAgICAwLjk1OiAxLjY0LFxuICAgICAgICAwLjk6IDIuMixcbiAgICAgICAgMC41OiA1LjM1LFxuICAgICAgICAwLjE6IDEwLjY1LFxuICAgICAgICAwLjA1OiAxMi41OSxcbiAgICAgICAgMC4wMjU6IDE0LjQ1LFxuICAgICAgICAwLjAxOiAxNi44MSxcbiAgICAgICAgMC4wMDU6IDE4LjU1XG4gICAgfSxcbiAgICA3OiB7XG4gICAgICAgIDAuOTk1OiAwLjk5LFxuICAgICAgICAwLjk5OiAxLjI1LFxuICAgICAgICAwLjk3NTogMS42OSxcbiAgICAgICAgMC45NTogMi4xNyxcbiAgICAgICAgMC45OiAyLjgzLFxuICAgICAgICAwLjU6IDYuMzUsXG4gICAgICAgIDAuMTogMTIuMDIsXG4gICAgICAgIDAuMDU6IDE0LjA3LFxuICAgICAgICAwLjAyNTogMTYuMDEsXG4gICAgICAgIDAuMDE6IDE4LjQ4LFxuICAgICAgICAwLjAwNTogMjAuMjhcbiAgICB9LFxuICAgIDg6IHtcbiAgICAgICAgMC45OTU6IDEuMzQsXG4gICAgICAgIDAuOTk6IDEuNjUsXG4gICAgICAgIDAuOTc1OiAyLjE4LFxuICAgICAgICAwLjk1OiAyLjczLFxuICAgICAgICAwLjk6IDMuNDksXG4gICAgICAgIDAuNTogNy4zNCxcbiAgICAgICAgMC4xOiAxMy4zNixcbiAgICAgICAgMC4wNTogMTUuNTEsXG4gICAgICAgIDAuMDI1OiAxNy41MyxcbiAgICAgICAgMC4wMTogMjAuMDksXG4gICAgICAgIDAuMDA1OiAyMS45NlxuICAgIH0sXG4gICAgOToge1xuICAgICAgICAwLjk5NTogMS43MyxcbiAgICAgICAgMC45OTogMi4wOSxcbiAgICAgICAgMC45NzU6IDIuNyxcbiAgICAgICAgMC45NTogMy4zMyxcbiAgICAgICAgMC45OiA0LjE3LFxuICAgICAgICAwLjU6IDguMzQsXG4gICAgICAgIDAuMTogMTQuNjgsXG4gICAgICAgIDAuMDU6IDE2LjkyLFxuICAgICAgICAwLjAyNTogMTkuMDIsXG4gICAgICAgIDAuMDE6IDIxLjY3LFxuICAgICAgICAwLjAwNTogMjMuNTlcbiAgICB9LFxuICAgIDEwOiB7XG4gICAgICAgIDAuOTk1OiAyLjE2LFxuICAgICAgICAwLjk5OiAyLjU2LFxuICAgICAgICAwLjk3NTogMy4yNSxcbiAgICAgICAgMC45NTogMy45NCxcbiAgICAgICAgMC45OiA0Ljg3LFxuICAgICAgICAwLjU6IDkuMzQsXG4gICAgICAgIDAuMTogMTUuOTksXG4gICAgICAgIDAuMDU6IDE4LjMxLFxuICAgICAgICAwLjAyNTogMjAuNDgsXG4gICAgICAgIDAuMDE6IDIzLjIxLFxuICAgICAgICAwLjAwNTogMjUuMTlcbiAgICB9LFxuICAgIDExOiB7XG4gICAgICAgIDAuOTk1OiAyLjYsXG4gICAgICAgIDAuOTk6IDMuMDUsXG4gICAgICAgIDAuOTc1OiAzLjgyLFxuICAgICAgICAwLjk1OiA0LjU3LFxuICAgICAgICAwLjk6IDUuNTgsXG4gICAgICAgIDAuNTogMTAuMzQsXG4gICAgICAgIDAuMTogMTcuMjgsXG4gICAgICAgIDAuMDU6IDE5LjY4LFxuICAgICAgICAwLjAyNTogMjEuOTIsXG4gICAgICAgIDAuMDE6IDI0LjcyLFxuICAgICAgICAwLjAwNTogMjYuNzZcbiAgICB9LFxuICAgIDEyOiB7XG4gICAgICAgIDAuOTk1OiAzLjA3LFxuICAgICAgICAwLjk5OiAzLjU3LFxuICAgICAgICAwLjk3NTogNC40LFxuICAgICAgICAwLjk1OiA1LjIzLFxuICAgICAgICAwLjk6IDYuMyxcbiAgICAgICAgMC41OiAxMS4zNCxcbiAgICAgICAgMC4xOiAxOC41NSxcbiAgICAgICAgMC4wNTogMjEuMDMsXG4gICAgICAgIDAuMDI1OiAyMy4zNCxcbiAgICAgICAgMC4wMTogMjYuMjIsXG4gICAgICAgIDAuMDA1OiAyOC4zXG4gICAgfSxcbiAgICAxMzoge1xuICAgICAgICAwLjk5NTogMy41NyxcbiAgICAgICAgMC45OTogNC4xMSxcbiAgICAgICAgMC45NzU6IDUuMDEsXG4gICAgICAgIDAuOTU6IDUuODksXG4gICAgICAgIDAuOTogNy4wNCxcbiAgICAgICAgMC41OiAxMi4zNCxcbiAgICAgICAgMC4xOiAxOS44MSxcbiAgICAgICAgMC4wNTogMjIuMzYsXG4gICAgICAgIDAuMDI1OiAyNC43NCxcbiAgICAgICAgMC4wMTogMjcuNjksXG4gICAgICAgIDAuMDA1OiAyOS44MlxuICAgIH0sXG4gICAgMTQ6IHtcbiAgICAgICAgMC45OTU6IDQuMDcsXG4gICAgICAgIDAuOTk6IDQuNjYsXG4gICAgICAgIDAuOTc1OiA1LjYzLFxuICAgICAgICAwLjk1OiA2LjU3LFxuICAgICAgICAwLjk6IDcuNzksXG4gICAgICAgIDAuNTogMTMuMzQsXG4gICAgICAgIDAuMTogMjEuMDYsXG4gICAgICAgIDAuMDU6IDIzLjY4LFxuICAgICAgICAwLjAyNTogMjYuMTIsXG4gICAgICAgIDAuMDE6IDI5LjE0LFxuICAgICAgICAwLjAwNTogMzEuMzJcbiAgICB9LFxuICAgIDE1OiB7XG4gICAgICAgIDAuOTk1OiA0LjYsXG4gICAgICAgIDAuOTk6IDUuMjMsXG4gICAgICAgIDAuOTc1OiA2LjI3LFxuICAgICAgICAwLjk1OiA3LjI2LFxuICAgICAgICAwLjk6IDguNTUsXG4gICAgICAgIDAuNTogMTQuMzQsXG4gICAgICAgIDAuMTogMjIuMzEsXG4gICAgICAgIDAuMDU6IDI1LFxuICAgICAgICAwLjAyNTogMjcuNDksXG4gICAgICAgIDAuMDE6IDMwLjU4LFxuICAgICAgICAwLjAwNTogMzIuOFxuICAgIH0sXG4gICAgMTY6IHtcbiAgICAgICAgMC45OTU6IDUuMTQsXG4gICAgICAgIDAuOTk6IDUuODEsXG4gICAgICAgIDAuOTc1OiA2LjkxLFxuICAgICAgICAwLjk1OiA3Ljk2LFxuICAgICAgICAwLjk6IDkuMzEsXG4gICAgICAgIDAuNTogMTUuMzQsXG4gICAgICAgIDAuMTogMjMuNTQsXG4gICAgICAgIDAuMDU6IDI2LjMsXG4gICAgICAgIDAuMDI1OiAyOC44NSxcbiAgICAgICAgMC4wMTogMzIsXG4gICAgICAgIDAuMDA1OiAzNC4yN1xuICAgIH0sXG4gICAgMTc6IHtcbiAgICAgICAgMC45OTU6IDUuNyxcbiAgICAgICAgMC45OTogNi40MSxcbiAgICAgICAgMC45NzU6IDcuNTYsXG4gICAgICAgIDAuOTU6IDguNjcsXG4gICAgICAgIDAuOTogMTAuMDksXG4gICAgICAgIDAuNTogMTYuMzQsXG4gICAgICAgIDAuMTogMjQuNzcsXG4gICAgICAgIDAuMDU6IDI3LjU5LFxuICAgICAgICAwLjAyNTogMzAuMTksXG4gICAgICAgIDAuMDE6IDMzLjQxLFxuICAgICAgICAwLjAwNTogMzUuNzJcbiAgICB9LFxuICAgIDE4OiB7XG4gICAgICAgIDAuOTk1OiA2LjI2LFxuICAgICAgICAwLjk5OiA3LjAxLFxuICAgICAgICAwLjk3NTogOC4yMyxcbiAgICAgICAgMC45NTogOS4zOSxcbiAgICAgICAgMC45OiAxMC44NyxcbiAgICAgICAgMC41OiAxNy4zNCxcbiAgICAgICAgMC4xOiAyNS45OSxcbiAgICAgICAgMC4wNTogMjguODcsXG4gICAgICAgIDAuMDI1OiAzMS41MyxcbiAgICAgICAgMC4wMTogMzQuODEsXG4gICAgICAgIDAuMDA1OiAzNy4xNlxuICAgIH0sXG4gICAgMTk6IHtcbiAgICAgICAgMC45OTU6IDYuODQsXG4gICAgICAgIDAuOTk6IDcuNjMsXG4gICAgICAgIDAuOTc1OiA4LjkxLFxuICAgICAgICAwLjk1OiAxMC4xMixcbiAgICAgICAgMC45OiAxMS42NSxcbiAgICAgICAgMC41OiAxOC4zNCxcbiAgICAgICAgMC4xOiAyNy4yLFxuICAgICAgICAwLjA1OiAzMC4xNCxcbiAgICAgICAgMC4wMjU6IDMyLjg1LFxuICAgICAgICAwLjAxOiAzNi4xOSxcbiAgICAgICAgMC4wMDU6IDM4LjU4XG4gICAgfSxcbiAgICAyMDoge1xuICAgICAgICAwLjk5NTogNy40MyxcbiAgICAgICAgMC45OTogOC4yNixcbiAgICAgICAgMC45NzU6IDkuNTksXG4gICAgICAgIDAuOTU6IDEwLjg1LFxuICAgICAgICAwLjk6IDEyLjQ0LFxuICAgICAgICAwLjU6IDE5LjM0LFxuICAgICAgICAwLjE6IDI4LjQxLFxuICAgICAgICAwLjA1OiAzMS40MSxcbiAgICAgICAgMC4wMjU6IDM0LjE3LFxuICAgICAgICAwLjAxOiAzNy41NyxcbiAgICAgICAgMC4wMDU6IDQwXG4gICAgfSxcbiAgICAyMToge1xuICAgICAgICAwLjk5NTogOC4wMyxcbiAgICAgICAgMC45OTogOC45LFxuICAgICAgICAwLjk3NTogMTAuMjgsXG4gICAgICAgIDAuOTU6IDExLjU5LFxuICAgICAgICAwLjk6IDEzLjI0LFxuICAgICAgICAwLjU6IDIwLjM0LFxuICAgICAgICAwLjE6IDI5LjYyLFxuICAgICAgICAwLjA1OiAzMi42NyxcbiAgICAgICAgMC4wMjU6IDM1LjQ4LFxuICAgICAgICAwLjAxOiAzOC45MyxcbiAgICAgICAgMC4wMDU6IDQxLjRcbiAgICB9LFxuICAgIDIyOiB7XG4gICAgICAgIDAuOTk1OiA4LjY0LFxuICAgICAgICAwLjk5OiA5LjU0LFxuICAgICAgICAwLjk3NTogMTAuOTgsXG4gICAgICAgIDAuOTU6IDEyLjM0LFxuICAgICAgICAwLjk6IDE0LjA0LFxuICAgICAgICAwLjU6IDIxLjM0LFxuICAgICAgICAwLjE6IDMwLjgxLFxuICAgICAgICAwLjA1OiAzMy45MixcbiAgICAgICAgMC4wMjU6IDM2Ljc4LFxuICAgICAgICAwLjAxOiA0MC4yOSxcbiAgICAgICAgMC4wMDU6IDQyLjhcbiAgICB9LFxuICAgIDIzOiB7XG4gICAgICAgIDAuOTk1OiA5LjI2LFxuICAgICAgICAwLjk5OiAxMC4yLFxuICAgICAgICAwLjk3NTogMTEuNjksXG4gICAgICAgIDAuOTU6IDEzLjA5LFxuICAgICAgICAwLjk6IDE0Ljg1LFxuICAgICAgICAwLjU6IDIyLjM0LFxuICAgICAgICAwLjE6IDMyLjAxLFxuICAgICAgICAwLjA1OiAzNS4xNyxcbiAgICAgICAgMC4wMjU6IDM4LjA4LFxuICAgICAgICAwLjAxOiA0MS42NCxcbiAgICAgICAgMC4wMDU6IDQ0LjE4XG4gICAgfSxcbiAgICAyNDoge1xuICAgICAgICAwLjk5NTogOS44OSxcbiAgICAgICAgMC45OTogMTAuODYsXG4gICAgICAgIDAuOTc1OiAxMi40LFxuICAgICAgICAwLjk1OiAxMy44NSxcbiAgICAgICAgMC45OiAxNS42NixcbiAgICAgICAgMC41OiAyMy4zNCxcbiAgICAgICAgMC4xOiAzMy4yLFxuICAgICAgICAwLjA1OiAzNi40MixcbiAgICAgICAgMC4wMjU6IDM5LjM2LFxuICAgICAgICAwLjAxOiA0Mi45OCxcbiAgICAgICAgMC4wMDU6IDQ1LjU2XG4gICAgfSxcbiAgICAyNToge1xuICAgICAgICAwLjk5NTogMTAuNTIsXG4gICAgICAgIDAuOTk6IDExLjUyLFxuICAgICAgICAwLjk3NTogMTMuMTIsXG4gICAgICAgIDAuOTU6IDE0LjYxLFxuICAgICAgICAwLjk6IDE2LjQ3LFxuICAgICAgICAwLjU6IDI0LjM0LFxuICAgICAgICAwLjE6IDM0LjI4LFxuICAgICAgICAwLjA1OiAzNy42NSxcbiAgICAgICAgMC4wMjU6IDQwLjY1LFxuICAgICAgICAwLjAxOiA0NC4zMSxcbiAgICAgICAgMC4wMDU6IDQ2LjkzXG4gICAgfSxcbiAgICAyNjoge1xuICAgICAgICAwLjk5NTogMTEuMTYsXG4gICAgICAgIDAuOTk6IDEyLjIsXG4gICAgICAgIDAuOTc1OiAxMy44NCxcbiAgICAgICAgMC45NTogMTUuMzgsXG4gICAgICAgIDAuOTogMTcuMjksXG4gICAgICAgIDAuNTogMjUuMzQsXG4gICAgICAgIDAuMTogMzUuNTYsXG4gICAgICAgIDAuMDU6IDM4Ljg5LFxuICAgICAgICAwLjAyNTogNDEuOTIsXG4gICAgICAgIDAuMDE6IDQ1LjY0LFxuICAgICAgICAwLjAwNTogNDguMjlcbiAgICB9LFxuICAgIDI3OiB7XG4gICAgICAgIDAuOTk1OiAxMS44MSxcbiAgICAgICAgMC45OTogMTIuODgsXG4gICAgICAgIDAuOTc1OiAxNC41NyxcbiAgICAgICAgMC45NTogMTYuMTUsXG4gICAgICAgIDAuOTogMTguMTEsXG4gICAgICAgIDAuNTogMjYuMzQsXG4gICAgICAgIDAuMTogMzYuNzQsXG4gICAgICAgIDAuMDU6IDQwLjExLFxuICAgICAgICAwLjAyNTogNDMuMTksXG4gICAgICAgIDAuMDE6IDQ2Ljk2LFxuICAgICAgICAwLjAwNTogNDkuNjVcbiAgICB9LFxuICAgIDI4OiB7XG4gICAgICAgIDAuOTk1OiAxMi40NixcbiAgICAgICAgMC45OTogMTMuNTcsXG4gICAgICAgIDAuOTc1OiAxNS4zMSxcbiAgICAgICAgMC45NTogMTYuOTMsXG4gICAgICAgIDAuOTogMTguOTQsXG4gICAgICAgIDAuNTogMjcuMzQsXG4gICAgICAgIDAuMTogMzcuOTIsXG4gICAgICAgIDAuMDU6IDQxLjM0LFxuICAgICAgICAwLjAyNTogNDQuNDYsXG4gICAgICAgIDAuMDE6IDQ4LjI4LFxuICAgICAgICAwLjAwNTogNTAuOTlcbiAgICB9LFxuICAgIDI5OiB7XG4gICAgICAgIDAuOTk1OiAxMy4xMixcbiAgICAgICAgMC45OTogMTQuMjYsXG4gICAgICAgIDAuOTc1OiAxNi4wNSxcbiAgICAgICAgMC45NTogMTcuNzEsXG4gICAgICAgIDAuOTogMTkuNzcsXG4gICAgICAgIDAuNTogMjguMzQsXG4gICAgICAgIDAuMTogMzkuMDksXG4gICAgICAgIDAuMDU6IDQyLjU2LFxuICAgICAgICAwLjAyNTogNDUuNzIsXG4gICAgICAgIDAuMDE6IDQ5LjU5LFxuICAgICAgICAwLjAwNTogNTIuMzRcbiAgICB9LFxuICAgIDMwOiB7XG4gICAgICAgIDAuOTk1OiAxMy43OSxcbiAgICAgICAgMC45OTogMTQuOTUsXG4gICAgICAgIDAuOTc1OiAxNi43OSxcbiAgICAgICAgMC45NTogMTguNDksXG4gICAgICAgIDAuOTogMjAuNixcbiAgICAgICAgMC41OiAyOS4zNCxcbiAgICAgICAgMC4xOiA0MC4yNixcbiAgICAgICAgMC4wNTogNDMuNzcsXG4gICAgICAgIDAuMDI1OiA0Ni45OCxcbiAgICAgICAgMC4wMTogNTAuODksXG4gICAgICAgIDAuMDA1OiA1My42N1xuICAgIH0sXG4gICAgNDA6IHtcbiAgICAgICAgMC45OTU6IDIwLjcxLFxuICAgICAgICAwLjk5OiAyMi4xNixcbiAgICAgICAgMC45NzU6IDI0LjQzLFxuICAgICAgICAwLjk1OiAyNi41MSxcbiAgICAgICAgMC45OiAyOS4wNSxcbiAgICAgICAgMC41OiAzOS4zNCxcbiAgICAgICAgMC4xOiA1MS44MSxcbiAgICAgICAgMC4wNTogNTUuNzYsXG4gICAgICAgIDAuMDI1OiA1OS4zNCxcbiAgICAgICAgMC4wMTogNjMuNjksXG4gICAgICAgIDAuMDA1OiA2Ni43N1xuICAgIH0sXG4gICAgNTA6IHtcbiAgICAgICAgMC45OTU6IDI3Ljk5LFxuICAgICAgICAwLjk5OiAyOS43MSxcbiAgICAgICAgMC45NzU6IDMyLjM2LFxuICAgICAgICAwLjk1OiAzNC43NixcbiAgICAgICAgMC45OiAzNy42OSxcbiAgICAgICAgMC41OiA0OS4zMyxcbiAgICAgICAgMC4xOiA2My4xNyxcbiAgICAgICAgMC4wNTogNjcuNSxcbiAgICAgICAgMC4wMjU6IDcxLjQyLFxuICAgICAgICAwLjAxOiA3Ni4xNSxcbiAgICAgICAgMC4wMDU6IDc5LjQ5XG4gICAgfSxcbiAgICA2MDoge1xuICAgICAgICAwLjk5NTogMzUuNTMsXG4gICAgICAgIDAuOTk6IDM3LjQ4LFxuICAgICAgICAwLjk3NTogNDAuNDgsXG4gICAgICAgIDAuOTU6IDQzLjE5LFxuICAgICAgICAwLjk6IDQ2LjQ2LFxuICAgICAgICAwLjU6IDU5LjMzLFxuICAgICAgICAwLjE6IDc0LjQsXG4gICAgICAgIDAuMDU6IDc5LjA4LFxuICAgICAgICAwLjAyNTogODMuMyxcbiAgICAgICAgMC4wMTogODguMzgsXG4gICAgICAgIDAuMDA1OiA5MS45NVxuICAgIH0sXG4gICAgNzA6IHtcbiAgICAgICAgMC45OTU6IDQzLjI4LFxuICAgICAgICAwLjk5OiA0NS40NCxcbiAgICAgICAgMC45NzU6IDQ4Ljc2LFxuICAgICAgICAwLjk1OiA1MS43NCxcbiAgICAgICAgMC45OiA1NS4zMyxcbiAgICAgICAgMC41OiA2OS4zMyxcbiAgICAgICAgMC4xOiA4NS41MyxcbiAgICAgICAgMC4wNTogOTAuNTMsXG4gICAgICAgIDAuMDI1OiA5NS4wMixcbiAgICAgICAgMC4wMTogMTAwLjQyLFxuICAgICAgICAwLjAwNTogMTA0LjIyXG4gICAgfSxcbiAgICA4MDoge1xuICAgICAgICAwLjk5NTogNTEuMTcsXG4gICAgICAgIDAuOTk6IDUzLjU0LFxuICAgICAgICAwLjk3NTogNTcuMTUsXG4gICAgICAgIDAuOTU6IDYwLjM5LFxuICAgICAgICAwLjk6IDY0LjI4LFxuICAgICAgICAwLjU6IDc5LjMzLFxuICAgICAgICAwLjE6IDk2LjU4LFxuICAgICAgICAwLjA1OiAxMDEuODgsXG4gICAgICAgIDAuMDI1OiAxMDYuNjMsXG4gICAgICAgIDAuMDE6IDExMi4zMyxcbiAgICAgICAgMC4wMDU6IDExNi4zMlxuICAgIH0sXG4gICAgOTA6IHtcbiAgICAgICAgMC45OTU6IDU5LjIsXG4gICAgICAgIDAuOTk6IDYxLjc1LFxuICAgICAgICAwLjk3NTogNjUuNjUsXG4gICAgICAgIDAuOTU6IDY5LjEzLFxuICAgICAgICAwLjk6IDczLjI5LFxuICAgICAgICAwLjU6IDg5LjMzLFxuICAgICAgICAwLjE6IDEwNy41NyxcbiAgICAgICAgMC4wNTogMTEzLjE0LFxuICAgICAgICAwLjAyNTogMTE4LjE0LFxuICAgICAgICAwLjAxOiAxMjQuMTIsXG4gICAgICAgIDAuMDA1OiAxMjguM1xuICAgIH0sXG4gICAgMTAwOiB7XG4gICAgICAgIDAuOTk1OiA2Ny4zMyxcbiAgICAgICAgMC45OTogNzAuMDYsXG4gICAgICAgIDAuOTc1OiA3NC4yMixcbiAgICAgICAgMC45NTogNzcuOTMsXG4gICAgICAgIDAuOTogODIuMzYsXG4gICAgICAgIDAuNTogOTkuMzMsXG4gICAgICAgIDAuMTogMTE4LjUsXG4gICAgICAgIDAuMDU6IDEyNC4zNCxcbiAgICAgICAgMC4wMjU6IDEyOS41NixcbiAgICAgICAgMC4wMTogMTM1LjgxLFxuICAgICAgICAwLjAwNTogMTQwLjE3XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgW8+HMiAoQ2hpLVNxdWFyZWQpIEdvb2RuZXNzLW9mLUZpdCBUZXN0XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dvb2RuZXNzX29mX2ZpdCNQZWFyc29uLjI3c19jaGktc3F1YXJlZF90ZXN0KVxuICogdXNlcyBhIG1lYXN1cmUgb2YgZ29vZG5lc3Mgb2YgZml0IHdoaWNoIGlzIHRoZSBzdW0gb2YgZGlmZmVyZW5jZXMgYmV0d2VlbiBvYnNlcnZlZCBhbmQgZXhwZWN0ZWQgb3V0Y29tZSBmcmVxdWVuY2llc1xuICogKHRoYXQgaXMsIGNvdW50cyBvZiBvYnNlcnZhdGlvbnMpLCBlYWNoIHNxdWFyZWQgYW5kIGRpdmlkZWQgYnkgdGhlIG51bWJlciBvZiBvYnNlcnZhdGlvbnMgZXhwZWN0ZWQgZ2l2ZW4gdGhlXG4gKiBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLiBUaGUgcmVzdWx0aW5nIM+HMiBzdGF0aXN0aWMsIGBjaGlTcXVhcmVkYCwgY2FuIGJlIGNvbXBhcmVkIHRvIHRoZSBjaGktc3F1YXJlZCBkaXN0cmlidXRpb25cbiAqIHRvIGRldGVybWluZSB0aGUgZ29vZG5lc3Mgb2YgZml0LiBJbiBvcmRlciB0byBkZXRlcm1pbmUgdGhlIGRlZ3JlZXMgb2YgZnJlZWRvbSBvZiB0aGUgY2hpLXNxdWFyZWQgZGlzdHJpYnV0aW9uLCBvbmVcbiAqIHRha2VzIHRoZSB0b3RhbCBudW1iZXIgb2Ygb2JzZXJ2ZWQgZnJlcXVlbmNpZXMgYW5kIHN1YnRyYWN0cyB0aGUgbnVtYmVyIG9mIGVzdGltYXRlZCBwYXJhbWV0ZXJzLiBUaGUgdGVzdCBzdGF0aXN0aWNcbiAqIGZvbGxvd3MsIGFwcHJveGltYXRlbHksIGEgY2hpLXNxdWFyZSBkaXN0cmlidXRpb24gd2l0aCAoayDiiJIgYykgZGVncmVlcyBvZiBmcmVlZG9tIHdoZXJlIGBrYCBpcyB0aGUgbnVtYmVyIG9mIG5vbi1lbXB0eVxuICogY2VsbHMgYW5kIGBjYCBpcyB0aGUgbnVtYmVyIG9mIGVzdGltYXRlZCBwYXJhbWV0ZXJzIGZvciB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzdHJpYnV0aW9uVHlwZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBvaW50IGluIGEgZGlzdHJpYnV0aW9uOlxuICogZm9yIGluc3RhbmNlLCBiaW5vbWlhbCwgYmVybm91bGxpLCBvciBwb2lzc29uXG4gKiBAcGFyYW0ge251bWJlcn0gc2lnbmlmaWNhbmNlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjaGkgc3F1YXJlZCBnb29kbmVzcyBvZiBmaXRcbiAqIEBleGFtcGxlXG4gKiAvLyBEYXRhIGZyb20gUG9pc3NvbiBnb29kbmVzcy1vZi1maXQgZXhhbXBsZSAxMC0xOSBpbiBXaWxsaWFtIFcuIEhpbmVzICYgRG91Z2xhcyBDLiBNb250Z29tZXJ5LFxuICogLy8gXCJQcm9iYWJpbGl0eSBhbmQgU3RhdGlzdGljcyBpbiBFbmdpbmVlcmluZyBhbmQgTWFuYWdlbWVudCBTY2llbmNlXCIsIFdpbGV5ICgxOTgwKS5cbiAqIHZhciBkYXRhMTAxOSA9IFtcbiAqICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICogICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gKiAgICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAqICAgICAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLFxuICogICAgIDMsIDMsIDMsIDNcbiAqIF07XG4gKiBzcy5jaGlTcXVhcmVkR29vZG5lc3NPZkZpdChkYXRhMTAxOSwgc3MucG9pc3NvbkRpc3RyaWJ1dGlvbiwgMC4wNSk7IC8vPSBmYWxzZVxuICovXG5mdW5jdGlvbiBjaGlTcXVhcmVkR29vZG5lc3NPZkZpdChkYXRhLCBkaXN0cmlidXRpb25UeXBlLCBzaWduaWZpY2FuY2UpIHtcbiAgICAvLyBFc3RpbWF0ZSBmcm9tIHRoZSBzYW1wbGUgZGF0YSwgYSB3ZWlnaHRlZCBtZWFuLlxuICAgIHZhciBpbnB1dE1lYW4gPSBtZWFuKGRhdGEpO1xuICAgIC8vIENhbGN1bGF0ZWQgdmFsdWUgb2YgdGhlIM+HMiBzdGF0aXN0aWMuXG4gICAgdmFyIGNoaVNxdWFyZWQgPSAwO1xuICAgIC8vIE51bWJlciBvZiBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uIHBhcmFtZXRlcnMgZXN0aW1hdGVkLCBleHBlY3RlZCB0byBiZSBzdXBwbGllZCBpbiB0aGUgZGlzdHJpYnV0aW9uIHRlc3QuXG4gICAgLy8gTG9zZSBvbmUgZGVncmVlIG9mIGZyZWVkb20gZm9yIGVzdGltYXRpbmcgYGxhbWJkYWAgZnJvbSB0aGUgc2FtcGxlIGRhdGEuXG4gICAgdmFyIGMgPSAxO1xuICAgIC8vIFRoZSBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLlxuICAgIC8vIEdlbmVyYXRlIHRoZSBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLlxuICAgIHZhciBoeXBvdGhlc2l6ZWREaXN0cmlidXRpb24gPSBkaXN0cmlidXRpb25UeXBlKGlucHV0TWVhbik7XG4gICAgdmFyIG9ic2VydmVkRnJlcXVlbmNpZXMgPSBbXTtcbiAgICB2YXIgZXhwZWN0ZWRGcmVxdWVuY2llcyA9IFtdO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IGhvbGRpbmcgYSBoaXN0b2dyYW0gZnJvbSB0aGUgc2FtcGxlIGRhdGEsIG9mXG4gICAgLy8gdGhlIGZvcm0gYHsgdmFsdWU6IG51bWJlck9mT2N1cnJlbmNlcyB9YFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAob2JzZXJ2ZWRGcmVxdWVuY2llc1tkYXRhW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlZEZyZXF1ZW5jaWVzW2RhdGFbaV1dID0gMDtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlZEZyZXF1ZW5jaWVzW2RhdGFbaV1dKys7XG4gICAgfVxuXG4gICAgLy8gVGhlIGhpc3RvZ3JhbSB3ZSBjcmVhdGVkIG1pZ2h0IGJlIHNwYXJzZSAtIHRoZXJlIG1pZ2h0IGJlIGdhcHNcbiAgICAvLyBiZXR3ZWVuIHZhbHVlcy4gU28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBoaXN0b2dyYW0sIG1ha2luZ1xuICAgIC8vIHN1cmUgdGhhdCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCwgZ2FwcyBoYXZlIDAgdmFsdWVzLlxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9ic2VydmVkRnJlcXVlbmNpZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICBpZiAob2JzZXJ2ZWRGcmVxdWVuY2llc1tpJDFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbaSQxXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gYXJyYXkgaG9sZGluZyBhIGhpc3RvZ3JhbSBvZiBleHBlY3RlZCBkYXRhIGdpdmVuIHRoZVxuICAgIC8vIHNhbXBsZSBzaXplIGFuZCBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uLlxuICAgIGZvciAodmFyIGsgaW4gaHlwb3RoZXNpemVkRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChrIGluIG9ic2VydmVkRnJlcXVlbmNpZXMpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXNbK2tdID0gaHlwb3RoZXNpemVkRGlzdHJpYnV0aW9uW2tdICogZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JraW5nIGJhY2t3YXJkIHRocm91Z2ggdGhlIGV4cGVjdGVkIGZyZXF1ZW5jaWVzLCBjb2xsYXBzZSBjbGFzc2VzXG4gICAgLy8gaWYgbGVzcyB0aGFuIHRocmVlIG9ic2VydmF0aW9ucyBhcmUgZXhwZWN0ZWQgZm9yIGEgY2xhc3MuXG4gICAgLy8gVGhpcyB0cmFuc2Zvcm1hdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBvYnNlcnZlZCBmcmVxdWVuY2llcyBhcyB3ZWxsLlxuICAgIGZvciAodmFyIGskMSA9IGV4cGVjdGVkRnJlcXVlbmNpZXMubGVuZ3RoIC0gMTsgayQxID49IDA7IGskMS0tKSB7XG4gICAgICAgIGlmIChleHBlY3RlZEZyZXF1ZW5jaWVzW2skMV0gPCAzKSB7XG4gICAgICAgICAgICBleHBlY3RlZEZyZXF1ZW5jaWVzW2skMSAtIDFdICs9IGV4cGVjdGVkRnJlcXVlbmNpZXNbayQxXTtcbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXMucG9wKCk7XG5cbiAgICAgICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbayQxIC0gMV0gKz0gb2JzZXJ2ZWRGcmVxdWVuY2llc1trJDFdO1xuICAgICAgICAgICAgb2JzZXJ2ZWRGcmVxdWVuY2llcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3F1YXJlZCBkaWZmZXJlbmNlcyBiZXR3ZWVuIG9ic2VydmVkICYgZXhwZWN0ZWRcbiAgICAvLyBmcmVxdWVuY2llcywgYWNjdW11bGF0aW5nIHRoZSBgY2hpU3F1YXJlZGAgc3RhdGlzdGljLlxuICAgIGZvciAodmFyIGskMiA9IDA7IGskMiA8IG9ic2VydmVkRnJlcXVlbmNpZXMubGVuZ3RoOyBrJDIrKykge1xuICAgICAgICBjaGlTcXVhcmVkICs9XG4gICAgICAgICAgICBNYXRoLnBvdyhvYnNlcnZlZEZyZXF1ZW5jaWVzW2skMl0gLSBleHBlY3RlZEZyZXF1ZW5jaWVzW2skMl0sIDIpIC9cbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXNbayQyXTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVncmVlcyBvZiBmcmVlZG9tIGZvciB0aGlzIHRlc3QgYW5kIGxvb2sgaXQgdXAgaW4gdGhlXG4gICAgLy8gYGNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZWAgaW4gb3JkZXIgdG9cbiAgICAvLyBhY2NlcHQgb3IgcmVqZWN0IHRoZSBnb29kbmVzcy1vZi1maXQgb2YgdGhlIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgLy8gRGVncmVlcyBvZiBmcmVlZG9tLCBjYWxjdWxhdGVkIGFzIChudW1iZXIgb2YgY2xhc3MgaW50ZXJ2YWxzIC1cbiAgICAvLyBudW1iZXIgb2YgaHlwb3RoZXNpemVkIGRpc3RyaWJ1dGlvbiBwYXJhbWV0ZXJzIGVzdGltYXRlZCAtIDEpXG4gICAgdmFyIGRlZ3JlZXNPZkZyZWVkb20gPSBvYnNlcnZlZEZyZXF1ZW5jaWVzLmxlbmd0aCAtIGMgLSAxO1xuICAgIHJldHVybiAoXG4gICAgICAgIGNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZVtkZWdyZWVzT2ZGcmVlZG9tXVtzaWduaWZpY2FuY2VdIDwgY2hpU3F1YXJlZFxuICAgICk7XG59XG5cbnZhciBTUVJUXzJQSSQxID0gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKTtcblxuLyoqXG4gKiBbV2VsbC1rbm93biBrZXJuZWxzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LZXJuZWxfKHN0YXRpc3RpY3MpI0tlcm5lbF9mdW5jdGlvbnNfaW5fY29tbW9uX3VzZSlcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBrZXJuZWxzID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBnYXVzc2lhbiBrZXJuZWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnYXVzc2lhbjogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiB1ICogdSkgLyBTUVJUXzJQSSQxO1xuICAgIH1cbn07XG5cbi8qKlxuICogV2VsbCBrbm93biBiYW5kd2lkdGggc2VsZWN0aW9uIG1ldGhvZHNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBiYW5kd2lkdGhNZXRob2RzID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBbXCJub3JtYWwgcmVmZXJlbmNlIGRpc3RyaWJ1dGlvblwiXG4gICAgICogcnVsZS1vZi10aHVtYl0oaHR0cHM6Ly9zdGF0LmV0aHouY2gvUi1tYW51YWwvUi1kZXZlbC9saWJyYXJ5L01BU1MvaHRtbC9iYW5kd2lkdGgubnJkLmh0bWwpLFxuICAgICAqIGEgY29tbW9ubHkgdXNlZCB2ZXJzaW9uIG9mIFtTaWx2ZXJtYW4nc1xuICAgICAqIHJ1bGUtb2YtdGh1bWJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlcm5lbF9kZW5zaXR5X2VzdGltYXRpb24jQV9ydWxlLW9mLXRodW1iX2JhbmR3aWR0aF9lc3RpbWF0b3IpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbnJkOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcyA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpO1xuICAgICAgICB2YXIgaXFyID0gaW50ZXJxdWFydGlsZVJhbmdlKHgpO1xuICAgICAgICBpZiAodHlwZW9mIGlxciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcyA9IE1hdGgubWluKHMsIGlxciAvIDEuMzQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxLjA2ICogcyAqIE1hdGgucG93KHgubGVuZ3RoLCAtMC4yKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFtLZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LZXJuZWxfZGVuc2l0eV9lc3RpbWF0aW9uKVxuICogaXMgYSB1c2VmdWwgdG9vbCBmb3IsIGFtb25nIG90aGVyIHRoaW5ncywgZXN0aW1hdGluZyB0aGUgc2hhcGUgb2YgdGhlXG4gKiB1bmRlcmx5aW5nIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiBmcm9tIGEgc2FtcGxlLlxuICpcbiAqIEBuYW1lIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uXG4gKiBAcGFyYW0gWCBzYW1wbGUgdmFsdWVzXG4gKiBAcGFyYW0ga2VybmVsIFRoZSBrZXJuZWwgZnVuY3Rpb24gdG8gdXNlLiBJZiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpdCBzaG91bGQgcmV0dXJuIG5vbi1uZWdhdGl2ZSB2YWx1ZXMgYW5kIGludGVncmF0ZSB0byAxLiBEZWZhdWx0cyB0byAnZ2F1c3NpYW4nLlxuICogQHBhcmFtIGJhbmR3aWR0aE1ldGhvZCBUaGUgXCJiYW5kd2lkdGggc2VsZWN0aW9uXCIgbWV0aG9kIHRvIHVzZSwgb3IgYSBmaXhlZCBiYW5kd2lkdGggdmFsdWUuIERlZmF1bHRzIHRvIFwibnJkXCIsIHRoZSBjb21tb25seS11c2VkIFtcIm5vcm1hbCByZWZlcmVuY2UgZGlzdHJpYnV0aW9uXCIgcnVsZS1vZi10aHVtYl0oaHR0cHM6Ly9zdGF0LmV0aHouY2gvUi1tYW51YWwvUi1kZXZlbC9saWJyYXJ5L01BU1MvaHRtbC9iYW5kd2lkdGgubnJkLmh0bWwpLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBbiBlc3RpbWF0ZWQgW3Byb2JhYmlsaXR5IGRlbnNpdHkgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JhYmlsaXR5X2RlbnNpdHlfZnVuY3Rpb24pIGZvciB0aGUgZ2l2ZW4gc2FtcGxlLiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gcnVucyBpbiBgTyhYLmxlbmd0aClgLlxuICovXG5mdW5jdGlvbiBrZXJuZWxEZW5zaXR5RXN0aW1hdGlvbihYLCBrZXJuZWwsIGJhbmR3aWR0aE1ldGhvZCkge1xuICAgIHZhciBrZXJuZWxGbjtcbiAgICBpZiAoa2VybmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVsRm4gPSBrZXJuZWxzLmdhdXNzaWFuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtlcm5lbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIWtlcm5lbHNba2VybmVsXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGtlcm5lbCBcIicgKyBrZXJuZWwgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBrZXJuZWxGbiA9IGtlcm5lbHNba2VybmVsXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXJuZWxGbiA9IGtlcm5lbDtcbiAgICB9XG5cbiAgICB2YXIgYmFuZHdpZHRoO1xuICAgIGlmICh0eXBlb2YgYmFuZHdpZHRoTWV0aG9kID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGJhbmR3aWR0aCA9IGJhbmR3aWR0aE1ldGhvZHMubnJkKFgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJhbmR3aWR0aE1ldGhvZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIWJhbmR3aWR0aE1ldGhvZHNbYmFuZHdpZHRoTWV0aG9kXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmtub3duIGJhbmR3aWR0aCBtZXRob2QgXCInICsgYmFuZHdpZHRoTWV0aG9kICsgJ1wiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBiYW5kd2lkdGggPSBiYW5kd2lkdGhNZXRob2RzW2JhbmR3aWR0aE1ldGhvZF0oWCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmFuZHdpZHRoID0gYmFuZHdpZHRoTWV0aG9kO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgWC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGtlcm5lbEZuKCh4IC0gWFtpXSkgLyBiYW5kd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyBiYW5kd2lkdGggLyBYLmxlbmd0aDtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBbWi1TY29yZSwgb3IgU3RhbmRhcmQgU2NvcmVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfc2NvcmUpLlxuICpcbiAqIFRoZSBzdGFuZGFyZCBzY29yZSBpcyB0aGUgbnVtYmVyIG9mIHN0YW5kYXJkIGRldmlhdGlvbnMgYW4gb2JzZXJ2YXRpb25cbiAqIG9yIGRhdHVtIGlzIGFib3ZlIG9yIGJlbG93IHRoZSBtZWFuLiBUaHVzLCBhIHBvc2l0aXZlIHN0YW5kYXJkIHNjb3JlXG4gKiByZXByZXNlbnRzIGEgZGF0dW0gYWJvdmUgdGhlIG1lYW4sIHdoaWxlIGEgbmVnYXRpdmUgc3RhbmRhcmQgc2NvcmVcbiAqIHJlcHJlc2VudHMgYSBkYXR1bSBiZWxvdyB0aGUgbWVhbi4gSXQgaXMgYSBkaW1lbnNpb25sZXNzIHF1YW50aXR5XG4gKiBvYnRhaW5lZCBieSBzdWJ0cmFjdGluZyB0aGUgcG9wdWxhdGlvbiBtZWFuIGZyb20gYW4gaW5kaXZpZHVhbCByYXdcbiAqIHNjb3JlIGFuZCB0aGVuIGRpdmlkaW5nIHRoZSBkaWZmZXJlbmNlIGJ5IHRoZSBwb3B1bGF0aW9uIHN0YW5kYXJkXG4gKiBkZXZpYXRpb24uXG4gKlxuICogVGhlIHotc2NvcmUgaXMgb25seSBkZWZpbmVkIGlmIG9uZSBrbm93cyB0aGUgcG9wdWxhdGlvbiBwYXJhbWV0ZXJzO1xuICogaWYgb25lIG9ubHkgaGFzIGEgc2FtcGxlIHNldCwgdGhlbiB0aGUgYW5hbG9nb3VzIGNvbXB1dGF0aW9uIHdpdGhcbiAqIHNhbXBsZSBtZWFuIGFuZCBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIHlpZWxkcyB0aGVcbiAqIFN0dWRlbnQncyB0LXN0YXRpc3RpYy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFuZGFyZERldmlhdGlvblxuICogQHJldHVybiB7bnVtYmVyfSB6IHNjb3JlXG4gKiBAZXhhbXBsZVxuICogelNjb3JlKDc4LCA4MCwgNSk7IC8vID0+IC0wLjRcbiAqL1xuZnVuY3Rpb24gelNjb3JlKHgsIG1lYW4sIHN0YW5kYXJkRGV2aWF0aW9uKSB7XG4gICAgcmV0dXJuICh4IC0gbWVhbikgLyBzdGFuZGFyZERldmlhdGlvbjtcbn1cblxudmFyIFNRUlRfMlBJID0gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKTtcblxuZnVuY3Rpb24gY3VtdWxhdGl2ZURpc3RyaWJ1dGlvbih6KSB7XG4gICAgdmFyIHN1bSA9IHo7XG4gICAgdmFyIHRtcCA9IHo7XG5cbiAgICAvLyAxNSBpdGVyYXRpb25zIGFyZSBlbm91Z2ggZm9yIDQtZGlnaXQgcHJlY2lzaW9uXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAxNTsgaSsrKSB7XG4gICAgICAgIHRtcCAqPSAoeiAqIHopIC8gKDIgKiBpICsgMSk7XG4gICAgICAgIHN1bSArPSB0bXA7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIE1hdGgucm91bmQoKDAuNSArIChzdW0gLyBTUVJUXzJQSSkgKiBNYXRoLmV4cCgoLXogKiB6KSAvIDIpKSAqIDFlNCkgL1xuICAgICAgICAxZTRcbiAgICApO1xufVxuXG4vKipcbiAqIEEgc3RhbmRhcmQgbm9ybWFsIHRhYmxlLCBhbHNvIGNhbGxlZCB0aGUgdW5pdCBub3JtYWwgdGFibGUgb3IgWiB0YWJsZSxcbiAqIGlzIGEgbWF0aGVtYXRpY2FsIHRhYmxlIGZvciB0aGUgdmFsdWVzIG9mIM6mIChwaGkpLCB3aGljaCBhcmUgdGhlIHZhbHVlcyBvZlxuICogdGhlIFtjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFsX2Rpc3RyaWJ1dGlvbiNDdW11bGF0aXZlX2Rpc3RyaWJ1dGlvbl9mdW5jdGlvbilcbiAqIG9mIHRoZSBub3JtYWwgZGlzdHJpYnV0aW9uLiBJdCBpcyB1c2VkIHRvIGZpbmQgdGhlIHByb2JhYmlsaXR5IHRoYXQgYVxuICogc3RhdGlzdGljIGlzIG9ic2VydmVkIGJlbG93LCBhYm92ZSwgb3IgYmV0d2VlbiB2YWx1ZXMgb24gdGhlIHN0YW5kYXJkXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uLCBhbmQgYnkgZXh0ZW5zaW9uLCBhbnkgbm9ybWFsIGRpc3RyaWJ1dGlvbi5cbiAqL1xudmFyIHN0YW5kYXJkTm9ybWFsVGFibGUgPSBbXTtcblxuZm9yICh2YXIgeiA9IDA7IHogPD0gMy4wOTsgeiArPSAwLjAxKSB7XG4gICAgc3RhbmRhcmROb3JtYWxUYWJsZS5wdXNoKGN1bXVsYXRpdmVEaXN0cmlidXRpb24oeikpO1xufVxuXG4vKipcbiAqICoqW0N1bXVsYXRpdmUgU3RhbmRhcmQgTm9ybWFsIFByb2JhYmlsaXR5XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0YW5kYXJkX25vcm1hbF90YWJsZSkqKlxuICpcbiAqIFNpbmNlIHByb2JhYmlsaXR5IHRhYmxlcyBjYW5ub3QgYmVcbiAqIHByaW50ZWQgZm9yIGV2ZXJ5IG5vcm1hbCBkaXN0cmlidXRpb24sIGFzIHRoZXJlIGFyZSBhbiBpbmZpbml0ZSB2YXJpZXR5XG4gKiBvZiBub3JtYWwgZGlzdHJpYnV0aW9ucywgaXQgaXMgY29tbW9uIHByYWN0aWNlIHRvIGNvbnZlcnQgYSBub3JtYWwgdG8gYVxuICogc3RhbmRhcmQgbm9ybWFsIGFuZCB0aGVuIHVzZSB0aGUgc3RhbmRhcmQgbm9ybWFsIHRhYmxlIHRvIGZpbmQgcHJvYmFiaWxpdGllcy5cbiAqXG4gKiBZb3UgY2FuIHVzZSBgLjUgKyAuNSAqIGVycm9yRnVuY3Rpb24oeCAvIE1hdGguc3FydCgyKSlgIHRvIGNhbGN1bGF0ZSB0aGUgcHJvYmFiaWxpdHlcbiAqIGluc3RlYWQgb2YgbG9va2luZyBpdCB1cCBpbiBhIHRhYmxlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjdW11bGF0aXZlIHN0YW5kYXJkIG5vcm1hbCBwcm9iYWJpbGl0eVxuICovXG5mdW5jdGlvbiBjdW11bGF0aXZlU3RkTm9ybWFsUHJvYmFiaWxpdHkoeikge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhpcyB2YWx1ZS5cbiAgICB2YXIgYWJzWiA9IE1hdGguYWJzKHopO1xuICAgIC8vIEVhY2ggcm93IGJlZ2lucyB3aXRoIGEgZGlmZmVyZW50XG4gICAgLy8gc2lnbmlmaWNhbnQgZGlnaXQ6IDAuNSwgMC42LCAwLjcsIGFuZCBzbyBvbi4gRWFjaCB2YWx1ZSBpbiB0aGUgdGFibGVcbiAgICAvLyBjb3JyZXNwb25kcyB0byBhIHJhbmdlIG9mIDAuMDEgaW4gdGhlIGlucHV0IHZhbHVlcywgc28gdGhlIHZhbHVlIGlzXG4gICAgLy8gbXVsdGlwbGllZCBieSAxMDAuXG4gICAgdmFyIGluZGV4ID0gTWF0aC5taW4oXG4gICAgICAgIE1hdGgucm91bmQoYWJzWiAqIDEwMCksXG4gICAgICAgIHN0YW5kYXJkTm9ybWFsVGFibGUubGVuZ3RoIC0gMVxuICAgICk7XG5cbiAgICAvLyBUaGUgaW5kZXggd2UgY2FsY3VsYXRlIG11c3QgYmUgaW4gdGhlIHRhYmxlIGFzIGEgcG9zaXRpdmUgdmFsdWUsXG4gICAgLy8gYnV0IHdlIHN0aWxsIHBheSBhdHRlbnRpb24gdG8gd2hldGhlciB0aGUgaW5wdXQgaXMgcG9zaXRpdmVcbiAgICAvLyBvciBuZWdhdGl2ZSwgYW5kIGZsaXAgdGhlIG91dHB1dCB2YWx1ZSBhcyBhIGxhc3Qgc3RlcC5cbiAgICBpZiAoeiA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFuZGFyZE5vcm1hbFRhYmxlW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkdWUgdG8gZmxvYXRpbmctcG9pbnQgYXJpdGhtZXRpYywgdmFsdWVzIGluIHRoZSB0YWJsZSB3aXRoXG4gICAgICAgIC8vIDQgc2lnbmlmaWNhbnQgZmlndXJlcyBjYW4gbmV2ZXJ0aGVsZXNzIGVuZCB1cCBhcyByZXBlYXRpbmdcbiAgICAgICAgLy8gZnJhY3Rpb25zIHdoZW4gdGhleSdyZSBjb21wdXRlZCBoZXJlLlxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgoMSAtIHN0YW5kYXJkTm9ybWFsVGFibGVbaW5kZXhdKSAqIDFlNCkgLyAxZTQ7XG4gICAgfVxufVxuXG4vKipcbiAqICoqW0xvZ2lzdGljIEN1bXVsYXRpdmUgRGlzdHJpYnV0aW9uIEZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dpc3RpY19kaXN0cmlidXRpb24pKipcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybnMge251bWJlcn0gY3VtdWxhdGl2ZSBzdGFuZGFyZCBsb2dpc3RpYyBwcm9iYWJpbGl0eVxuICovXG5mdW5jdGlvbiBjdW11bGF0aXZlU3RkTG9naXN0aWNQcm9iYWJpbGl0eSh4KSB7XG4gICAgcmV0dXJuIDEgLyAoTWF0aC5leHAoLXgpICsgMSk7XG59XG5cbi8qKlxuICogKipbR2F1c3NpYW4gZXJyb3IgZnVuY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24pKipcbiAqXG4gKiBUaGUgYGVycm9yRnVuY3Rpb24oeC8oc2QgKiBNYXRoLnNxcnQoMikpKWAgaXMgdGhlIHByb2JhYmlsaXR5IHRoYXQgYSB2YWx1ZSBpbiBhXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uIHdpdGggc3RhbmRhcmQgZGV2aWF0aW9uIHNkIGlzIHdpdGhpbiB4IG9mIHRoZSBtZWFuLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG51bWVyaWNhbCBhcHByb3hpbWF0aW9uIHRvIHRoZSBleGFjdCB2YWx1ZS5cbiAqIEl0IHVzZXMgSG9ybmVyJ3MgbWV0aG9kIHRvIGV2YWx1YXRlIHRoZSBwb2x5bm9taWFsIG9mIM+EICh0YXUpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IGlucHV0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGVycm9yIGVzdGltYXRpb25cbiAqIEBleGFtcGxlXG4gKiBlcnJvckZ1bmN0aW9uKDEpLnRvRml4ZWQoMik7IC8vID0+ICcwLjg0J1xuICovXG5mdW5jdGlvbiBlcnJvckZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgdCA9IDEgLyAoMSArIDAuNSAqIE1hdGguYWJzKHgpKTtcbiAgICB2YXIgdGF1ID1cbiAgICAgICAgdCAqXG4gICAgICAgIE1hdGguZXhwKFxuICAgICAgICAgICAgLXggKiB4ICtcbiAgICAgICAgICAgICAgICAoKCgoKCgoKDAuMTcwODcyNzcgKiB0IC0gMC44MjIxNTIyMykgKiB0ICsgMS40ODg1MTU4NykgKiB0IC1cbiAgICAgICAgICAgICAgICAgICAgMS4xMzUyMDM5OCkgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMC4yNzg4NjgwNykgKlxuICAgICAgICAgICAgICAgICAgICB0IC1cbiAgICAgICAgICAgICAgICAgICAgMC4xODYyODgwNikgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMC4wOTY3ODQxOCkgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMC4zNzQwOTE5NikgKlxuICAgICAgICAgICAgICAgICAgICB0ICtcbiAgICAgICAgICAgICAgICAgICAgMS4wMDAwMjM2OCkgKlxuICAgICAgICAgICAgICAgICAgICB0IC1cbiAgICAgICAgICAgICAgICAxLjI2NTUxMjIzXG4gICAgICAgICk7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgICByZXR1cm4gMSAtIHRhdTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGF1IC0gMTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIEludmVyc2UgW0dhdXNzaWFuIGVycm9yIGZ1bmN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Vycm9yX2Z1bmN0aW9uKVxuICogcmV0dXJucyBhIG51bWVyaWNhbCBhcHByb3hpbWF0aW9uIHRvIHRoZSB2YWx1ZSB0aGF0IHdvdWxkIGhhdmUgY2F1c2VkXG4gKiBgZXJyb3JGdW5jdGlvbigpYCB0byByZXR1cm4geC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCB2YWx1ZSBvZiBlcnJvciBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gZXN0aW1hdGVkIGludmVydGVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGludmVyc2VFcnJvckZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgYSA9ICg4ICogKE1hdGguUEkgLSAzKSkgLyAoMyAqIE1hdGguUEkgKiAoNCAtIE1hdGguUEkpKTtcblxuICAgIHZhciBpbnYgPSBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KDIgLyAoTWF0aC5QSSAqIGEpICsgTWF0aC5sb2coMSAtIHggKiB4KSAvIDIsIDIpIC1cbiAgICAgICAgICAgICAgICBNYXRoLmxvZygxIC0geCAqIHgpIC8gYVxuICAgICAgICApIC1cbiAgICAgICAgICAgICgyIC8gKE1hdGguUEkgKiBhKSArIE1hdGgubG9nKDEgLSB4ICogeCkgLyAyKVxuICAgICk7XG5cbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpbnY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC1pbnY7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBbUHJvYml0XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JpdClcbiAqIGlzIHRoZSBpbnZlcnNlIG9mIGN1bXVsYXRpdmVTdGROb3JtYWxQcm9iYWJpbGl0eSgpLFxuICogYW5kIGlzIGFsc28ga25vd24gYXMgdGhlIG5vcm1hbCBxdWFudGlsZSBmdW5jdGlvbi5cbiAqXG4gKiBJdCByZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWFuXG4gKiB3aGVyZSB0aGUgcCd0aCBxdWFudGlsZSBvZiB2YWx1ZXMgY2FuIGJlIGZvdW5kIGluIGEgbm9ybWFsIGRpc3RyaWJ1dGlvbi5cbiAqIFNvLCBmb3IgZXhhbXBsZSwgcHJvYml0KDAuNSArIDAuNjgyNy8yKSDiiYggMSBiZWNhdXNlIDY4LjI3JSBvZiB2YWx1ZXMgYXJlXG4gKiBub3JtYWxseSBmb3VuZCB3aXRoaW4gMSBzdGFuZGFyZCBkZXZpYXRpb24gYWJvdmUgb3IgYmVsb3cgdGhlIG1lYW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHByb2JpdFxuICovXG5mdW5jdGlvbiBwcm9iaXQocCkge1xuICAgIGlmIChwID09PSAwKSB7XG4gICAgICAgIHAgPSBlcHNpbG9uO1xuICAgIH0gZWxzZSBpZiAocCA+PSAxKSB7XG4gICAgICAgIHAgPSAxIC0gZXBzaWxvbjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydCgyKSAqIGludmVyc2VFcnJvckZ1bmN0aW9uKDIgKiBwIC0gMSk7XG59XG5cbi8qKlxuICogVGhlIFtMb2dpdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9naXQpXG4gKiBpcyB0aGUgaW52ZXJzZSBvZiBjdW11bGF0aXZlU3RkTG9naXN0aWNQcm9iYWJpbGl0eSxcbiAqIGFuZCBpcyBhbHNvIGtub3duIGFzIHRoZSBsb2dpc3RpYyBxdWFudGlsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcFxuICogQHJldHVybnMge251bWJlcn0gbG9naXRcbiAqL1xuZnVuY3Rpb24gbG9naXQocCkge1xuICAgIGlmIChwIDw9IDAgfHwgcCA+PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInAgbXVzdCBiZSBzdHJpY3RseSBiZXR3ZWVuIHplcm8gYW5kIG9uZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nKHAgLyAoMSAtIHApKTtcbn1cblxuLyoqXG4gKiBDb25kdWN0cyBhIFtwZXJtdXRhdGlvbiB0ZXN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZXNhbXBsaW5nXyhzdGF0aXN0aWNzKSNQZXJtdXRhdGlvbl90ZXN0cylcbiAqIHRvIGRldGVybWluZSBpZiB0d28gZGF0YSBzZXRzIGFyZSAqc2lnbmlmaWNhbnRseSogZGlmZmVyZW50IGZyb20gZWFjaCBvdGhlciwgdXNpbmdcbiAqIHRoZSBkaWZmZXJlbmNlIG9mIG1lYW5zIGJldHdlZW4gdGhlIGdyb3VwcyBhcyB0aGUgdGVzdCBzdGF0aXN0aWMuXG4gKiBUaGUgZnVuY3Rpb24gYWxsb3dzIGZvciB0aGUgZm9sbG93aW5nIGh5cG90aGVzZXM6XG4gKiAtIHR3b190YWlsID0gTnVsbCBoeXBvdGhlc2lzOiB0aGUgdHdvIGRpc3RyaWJ1dGlvbnMgYXJlIGVxdWFsLlxuICogLSBncmVhdGVyID0gTnVsbCBoeXBvdGhlc2lzOiBvYnNlcnZhdGlvbnMgZnJvbSBzYW1wbGVYIHRlbmQgdG8gYmUgc21hbGxlciB0aGFuIHRob3NlIGZyb20gc2FtcGxlWS5cbiAqIC0gbGVzcyA9IE51bGwgaHlwb3RoZXNpczogb2JzZXJ2YXRpb25zIGZyb20gc2FtcGxlWCB0ZW5kIHRvIGJlIGdyZWF0ZXIgdGhhbiB0aG9zZSBmcm9tIHNhbXBsZVkuXG4gKiBbTGVhcm4gbW9yZSBhYm91dCBvbmUtdGFpbCB2cyB0d28tdGFpbCB0ZXN0cy5dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09uZS1fYW5kX3R3by10YWlsZWRfdGVzdHMpXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzYW1wbGVYIGZpcnN0IGRhdGFzZXQgKGUuZy4gdHJlYXRtZW50IGRhdGEpXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVkgc2Vjb25kIGRhdGFzZXQgKGUuZy4gY29udHJvbCBkYXRhKVxuICogQHBhcmFtIHtzdHJpbmd9IGFsdGVybmF0aXZlIGFsdGVybmF0aXZlIGh5cG90aGVzaXMsIGVpdGhlciAndHdvX3NpZGVkJyAoZGVmYXVsdCksICdncmVhdGVyJywgb3IgJ2xlc3MnXG4gKiBAcGFyYW0ge251bWJlcn0gayBudW1iZXIgb2YgdmFsdWVzIGluIHBlcm11dGF0aW9uIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBwLXZhbHVlIFRoZSBwcm9iYWJpbGl0eSBvZiBvYnNlcnZpbmcgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBncm91cHMgKGFzIG9yIG1vcmUgZXh0cmVtZSB0aGFuIHdoYXQgd2UgZGlkKSwgYXNzdW1pbmcgdGhlIG51bGwgaHlwb3RoZXNpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRyb2wgPSBbMiwgNSwgMywgNiwgNywgMiwgNV07XG4gKiB2YXIgdHJlYXRtZW50ID0gWzIwLCA1LCAxMywgMTIsIDcsIDIsIDJdO1xuICogcGVybXV0YXRpb25UZXN0KGNvbnRyb2wsIHRyZWF0bWVudCk7IC8vIH4wLjEzMjRcbiAqL1xuZnVuY3Rpb24gcGVybXV0YXRpb25UZXN0KHNhbXBsZVgsIHNhbXBsZVksIGFsdGVybmF0aXZlLCBrLCByYW5kb21Tb3VyY2UpIHtcbiAgICAvLyBTZXQgZGVmYXVsdCBhcmd1bWVudHNcbiAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGsgPSAxMDAwMDtcbiAgICB9XG4gICAgaWYgKGFsdGVybmF0aXZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWx0ZXJuYXRpdmUgPSBcInR3b19zaWRlXCI7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICAgYWx0ZXJuYXRpdmUgIT09IFwidHdvX3NpZGVcIiAmJlxuICAgICAgICBhbHRlcm5hdGl2ZSAhPT0gXCJncmVhdGVyXCIgJiZcbiAgICAgICAgYWx0ZXJuYXRpdmUgIT09IFwibGVzc1wiXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiYGFsdGVybmF0aXZlYCBtdXN0IGJlIGVpdGhlciAndHdvX3NpZGUnLCAnZ3JlYXRlcicsIG9yICdsZXNzJy5cIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIGdldCBtZWFucyBmb3IgZWFjaCBzYW1wbGVcbiAgICB2YXIgbWVhblggPSBtZWFuKHNhbXBsZVgpO1xuICAgIHZhciBtZWFuWSA9IG1lYW4oc2FtcGxlWSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaW5pdGlhbCB0ZXN0IHN0YXRpc3RpYy4gVGhpcyB3aWxsIGJlIG91ciBwb2ludCBvZiBjb21wYXJpc29uIHdpdGhcbiAgICAvLyB0aGUgZ2VuZXJhdGVkIHRlc3Qgc3RhdGlzdGljcy5cbiAgICB2YXIgdGVzdFN0YXRpc3RpYyA9IG1lYW5YIC0gbWVhblk7XG5cbiAgICAvLyBjcmVhdGUgdGVzdC1zdGF0aXN0aWMgZGlzdHJpYnV0aW9uXG4gICAgdmFyIHRlc3RTdGF0RHNuID0gbmV3IEFycmF5KGspO1xuXG4gICAgLy8gY29tYmluZSBkYXRzZXRzIHNvIHdlIGNhbiBlYXNpbHkgc2h1ZmZsZSBsYXRlclxuICAgIHZhciBhbGxEYXRhID0gc2FtcGxlWC5jb25jYXQoc2FtcGxlWSk7XG4gICAgdmFyIG1pZEluZGV4ID0gTWF0aC5mbG9vcihhbGxEYXRhLmxlbmd0aCAvIDIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgLy8gMS4gc2h1ZmZsZSBkYXRhIGFzc2lnbm1lbnRzXG4gICAgICAgIHNodWZmbGVJblBsYWNlKGFsbERhdGEsIHJhbmRvbVNvdXJjZSk7XG4gICAgICAgIHZhciBwZXJtTGVmdCA9IGFsbERhdGEuc2xpY2UoMCwgbWlkSW5kZXgpO1xuICAgICAgICB2YXIgcGVybVJpZ2h0ID0gYWxsRGF0YS5zbGljZShtaWRJbmRleCwgYWxsRGF0YS5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDIucmUtY2FsY3VsYXRlIHRlc3Qgc3RhdGlzdGljXG4gICAgICAgIHZhciBwZXJtVGVzdFN0YXRpc3RpYyA9IG1lYW4ocGVybUxlZnQpIC0gbWVhbihwZXJtUmlnaHQpO1xuXG4gICAgICAgIC8vIDMuIHN0b3JlIHRlc3Qgc3RhdGlzdGljIHRvIGJ1aWxkIHRlc3Qgc3RhdGlzdGljIGRpc3RyaWJ1dGlvblxuICAgICAgICB0ZXN0U3RhdERzbltpXSA9IHBlcm1UZXN0U3RhdGlzdGljO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBwLXZhbHVlIGRlcGVuZGluZyBvbiBhbHRlcm5hdGl2ZVxuICAgIC8vIEZvciB0aGlzIHRlc3QsIHdlIGNhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiAnZXh0cmVtZScgdGVzdCBzdGF0aXN0aWNzIChzdWJqZWN0IHRvIG91ciBoeXBvdGhlc2lzKVxuICAgIC8vIG1vcmUgaW5mbyBvbiBwZXJtdXRhdGlvbiB0ZXN0IHAtdmFsdWUgY2FsY3VsYXRpb25zOiBodHRwczovL29ubGluZWNvdXJzZXMuc2NpZW5jZS5wc3UuZWR1L3N0YXQ0NjQvbm9kZS8zNVxuICAgIHZhciBudW1FeHRyZW1lVFN0YXRzID0gMDtcbiAgICBpZiAoYWx0ZXJuYXRpdmUgPT09IFwidHdvX3NpZGVcIikge1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPD0gazsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0ZXN0U3RhdERzbltpJDFdKSA+PSBNYXRoLmFicyh0ZXN0U3RhdGlzdGljKSkge1xuICAgICAgICAgICAgICAgIG51bUV4dHJlbWVUU3RhdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRpdmUgPT09IFwiZ3JlYXRlclwiKSB7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8PSBrOyBpJDIrKykge1xuICAgICAgICAgICAgaWYgKHRlc3RTdGF0RHNuW2kkMl0gPj0gdGVzdFN0YXRpc3RpYykge1xuICAgICAgICAgICAgICAgIG51bUV4dHJlbWVUU3RhdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFsdGVybmF0aXZlID09PSAnbGVzcydcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDw9IGs7IGkkMysrKSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0ZXN0U3RhdERzbltpJDNdIDw9IHRlc3RTdGF0aXN0aWMpIHtcbiAgICAgICAgICAgICAgICBudW1FeHRyZW1lVFN0YXRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgZW5kICovXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtRXh0cmVtZVRTdGF0cyAvIGs7XG59XG5cbi8qKlxuICogW1NpZ25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpZ25fZnVuY3Rpb24pIGlzIGEgZnVuY3Rpb25cbiAqIHRoYXQgZXh0cmFjdHMgdGhlIHNpZ24gb2YgYSByZWFsIG51bWJlclxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzaWduIHZhbHVlIGVpdGhlciAxLCAwIG9yIC0xXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHRoZSBpbnB1dCBhcmd1bWVudCB4IGlzIG5vdCBhIG51bWJlclxuICogQHByaXZhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogc2lnbigyKTsgLy8gPT4gMVxuICovXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSBudW1iZXJcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIFtCaXNlY3Rpb24gbWV0aG9kXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaXNlY3Rpb25fbWV0aG9kKSBpcyBhIHJvb3QtZmluZGluZ1xuICogbWV0aG9kIHRoYXQgcmVwZWF0ZWRseSBiaXNlY3RzIGFuIGludGVydmFsIHRvIGZpbmQgdGhlIHJvb3QuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbnVtZXJpY2FsIGFwcHJveGltYXRpb24gdG8gdGhlIGV4YWN0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgaW5wdXQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IG9mIGludGVydmFsXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gZW5kIG9mIGludGVydmFsXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4SXRlcmF0aW9ucyAtIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gZXJyb3JUb2xlcmFuY2UgLSB0aGUgZXJyb3IgdG9sZXJhbmNlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBlc3RpbWF0ZWQgcm9vdCB2YWx1ZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBBcmd1bWVudCBmdW5jIG11c3QgYmUgYSBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBiaXNlY3QoTWF0aC5jb3MsMCw0LDEwMCwwLjAwMyk7IC8vID0+IDEuNTcyMjY1NjI1XG4gKi9cbmZ1bmN0aW9uIGJpc2VjdChmdW5jLCBzdGFydCwgZW5kLCBtYXhJdGVyYXRpb25zLCBlcnJvclRvbGVyYW5jZSkge1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJmdW5jIG11c3QgYmUgYSBmdW5jdGlvblwiKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IChzdGFydCArIGVuZCkgLyAyO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZ1bmMob3V0cHV0KSA9PT0gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnMoKGVuZCAtIHN0YXJ0KSAvIDIpIDwgZXJyb3JUb2xlcmFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZ24oZnVuYyhvdXRwdXQpKSA9PT0gc2lnbihmdW5jKHN0YXJ0KSkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gb3V0cHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBleGNlZWRlZFwiKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGVmdCBGaXJzdCBOLWRpbWVuc2lvbmFsIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSByaWdodCBTZWNvbmQgTi1kaW1lbnNpb25hbCBwb2ludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3RhbmNlLlxuICovXG5mdW5jdGlvbiBldWNsaWRlYW5EaXN0YW5jZShsZWZ0LCByaWdodCkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlmZiA9IGxlZnRbaV0gLSByaWdodFtpXTtcbiAgICAgICAgc3VtICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0ga01lYW5zUmV0dXJuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxhYmVscyBUaGUgbGFiZWxzLlxuICogQHByb3BlcnR5IHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY2VudHJvaWRzIFRoZSBjbHVzdGVyIGNlbnRyb2lkcy5cbiAqL1xuXG4vKipcbiAqIFBlcmZvcm0gay1tZWFucyBjbHVzdGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBOLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGVzIG9mIHBvaW50cyB0byBiZSBjbHVzdGVyZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQ2x1c3RlciBIb3cgbWFueSBjbHVzdGVycyB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByYW5kb21Tb3VyY2UgQW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdCBnZW5lcmF0ZXMgdW5pZm9ybSB2YWx1ZXMgaW4gWzAsIDEpLlxuICogQHJldHVybiB7a01lYW5zUmV0dXJufSBMYWJlbHMgKHNhbWUgbGVuZ3RoIGFzIGRhdGEpIGFuZCBjZW50cm9pZHMgKHNhbWUgbGVuZ3RoIGFzIG51bUNsdXN0ZXIpLlxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSBjZW50cm9pZHMgd2luZCB1cCBmcmllbmRsZXNzIChpLmUuLCB3aXRob3V0IGFzc29jaWF0ZWQgcG9pbnRzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICoga01lYW5zQ2x1c3RlcihbWzAuMCwgMC41XSwgWzEuMCwgMC41XV0sIDIpOyAvLyA9PiB7bGFiZWxzOiBbMCwgMV0sIGNlbnRyb2lkczogW1swLjAsIDAuNV0sIFsxLjAgMC41XV19XG4gKi9cbmZ1bmN0aW9uIGtNZWFuc0NsdXN0ZXIocG9pbnRzLCBudW1DbHVzdGVyLCByYW5kb21Tb3VyY2UpIHtcbiAgICBpZiAoIHJhbmRvbVNvdXJjZSA9PT0gdm9pZCAwICkgcmFuZG9tU291cmNlID0gTWF0aC5yYW5kb207XG5cbiAgICB2YXIgb2xkQ2VudHJvaWRzID0gbnVsbDtcbiAgICB2YXIgbmV3Q2VudHJvaWRzID0gc2FtcGxlKHBvaW50cywgbnVtQ2x1c3RlciwgcmFuZG9tU291cmNlKTtcbiAgICB2YXIgbGFiZWxzID0gbnVsbDtcbiAgICB2YXIgY2hhbmdlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB3aGlsZSAoY2hhbmdlICE9PSAwKSB7XG4gICAgICAgIGxhYmVscyA9IGxhYmVsUG9pbnRzKHBvaW50cywgbmV3Q2VudHJvaWRzKTtcbiAgICAgICAgb2xkQ2VudHJvaWRzID0gbmV3Q2VudHJvaWRzO1xuICAgICAgICBuZXdDZW50cm9pZHMgPSBjYWxjdWxhdGVDZW50cm9pZHMocG9pbnRzLCBsYWJlbHMsIG51bUNsdXN0ZXIpO1xuICAgICAgICBjaGFuZ2UgPSBjYWxjdWxhdGVDaGFuZ2UobmV3Q2VudHJvaWRzLCBvbGRDZW50cm9pZHMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgY2VudHJvaWRzOiBuZXdDZW50cm9pZHNcbiAgICB9O1xufVxuXG4vKipcbiAqIExhYmVsIGVhY2ggcG9pbnQgYWNjb3JkaW5nIHRvIHdoaWNoIGNlbnRyb2lkIGl0IGlzIGNsb3Nlc3QgdG8uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBBcnJheSBvZiBYWSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNlbnRyb2lkcyBDdXJyZW50IGNlbnRyb2lkcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEdyb3VwIGxhYmVscy5cbiAqL1xuZnVuY3Rpb24gbGFiZWxQb2ludHMocG9pbnRzLCBjZW50cm9pZHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHZhciBsYWJlbCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbnRyb2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBldWNsaWRlYW5EaXN0YW5jZShwLCBjZW50cm9pZHNbaV0pO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY2VudHJvaWRzIGZvciBwb2ludHMgZ2l2ZW4gbGFiZWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwb2ludHMgQXJyYXkgb2YgWFkgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGxhYmVscyBXaGljaCBncm91cHMgcG9pbnRzIGJlbG9uZyB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1DbHVzdGVyIE51bWJlciBvZiBjbHVzdGVycyBiZWluZyBjcmVhdGVkLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IENlbnRyb2lkIGZvciBlYWNoIGdyb3VwLlxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSBjZW50cm9pZHMgd2luZCB1cCBmcmllbmRsZXNzIChpLmUuLCB3aXRob3V0IGFzc29jaWF0ZWQgcG9pbnRzKS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQ2VudHJvaWRzKHBvaW50cywgbGFiZWxzLCBudW1DbHVzdGVyKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhY2N1bXVsYXRvcnMuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHBvaW50c1swXS5sZW5ndGg7XG4gICAgdmFyIGNlbnRyb2lkcyA9IG1ha2VNYXRyaXgobnVtQ2x1c3RlciwgZGltZW5zaW9uKTtcbiAgICB2YXIgY291bnRzID0gQXJyYXkobnVtQ2x1c3RlcikuZmlsbCgwKTtcblxuICAgIC8vIEFkZCBwb2ludHMgdG8gY2VudHJvaWRzJyBhY2N1bXVsYXRvcnMgYW5kIGNvdW50IHBvaW50cyBwZXIgY2VudHJvaWQuXG4gICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjZW50cm9pZHNbbGFiZWxdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICBjdXJyZW50W2pdICs9IHBvaW50W2pdO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50c1tsYWJlbF0gKz0gMTtcbiAgICB9XG5cbiAgICAvLyBSZXNjYWxlIGNlbnRyb2lkcywgY2hlY2tpbmcgZm9yIGFueSB0aGF0IGhhdmUgbm8gcG9pbnRzLlxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG51bUNsdXN0ZXI7IGkkMSsrKSB7XG4gICAgICAgIGlmIChjb3VudHNbaSQxXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkNlbnRyb2lkIFwiICsgaSQxICsgXCIgaGFzIG5vIGZyaWVuZHNcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkc1tpJDFdO1xuICAgICAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBkaW1lbnNpb247IGokMSsrKSB7XG4gICAgICAgICAgICBjZW50cm9pZFtqJDFdIC89IGNvdW50c1tpJDFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRyb2lkcztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbGQgY2VudHJvaWRzIGFuZCBuZXcgY2VudHJvaWRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBsZWZ0IE9uZSBsaXN0IG9mIGNlbnRyb2lkcy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHJpZ2h0IEFub3RoZXIgbGlzdCBvZiBjZW50cm9pZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gY2VudHJvaWRzLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDaGFuZ2UobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBldWNsaWRlYW5EaXN0YW5jZShsZWZ0W2ldLCByaWdodFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIFtzaWxob3VldHRlIHZhbHVlc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lsaG91ZXR0ZV8oY2x1c3RlcmluZykpXG4gKiBmb3IgY2x1c3RlcmVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy4gVGhpcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBhcyBgcG9pbnRzYCxcbiAqIGFuZCB2YWx1ZXMgbXVzdCBsaWUgaW4gWzAuLkctMV0sIHdoZXJlIEcgaXMgdGhlIG51bWJlciBvZiBncm91cHMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc2lsaG91ZXR0ZSB2YWx1ZSBmb3IgZWFjaCBwb2ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogc2lsaG91ZXR0ZShbWzAuMjVdLCBbMC43NV1dLCBbMCwgMF0pOyAvLyA9PiBbMS4wLCAxLjBdXG4gKi9cbmZ1bmN0aW9uIHNpbGhvdWV0dGUocG9pbnRzLCBsYWJlbHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCAhPT0gbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IGhhdmUgZXhhY3RseSBhcyBtYW55IGxhYmVscyBhcyBwb2ludHNcIik7XG4gICAgfVxuICAgIHZhciBncm91cGluZ3MgPSBjcmVhdGVHcm91cHMobGFiZWxzKTtcbiAgICB2YXIgZGlzdGFuY2VzID0gY2FsY3VsYXRlQWxsRGlzdGFuY2VzKHBvaW50cyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgaWYgKGdyb3VwaW5nc1tsYWJlbHNbaV1dLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBhID0gbWVhbkRpc3RhbmNlRnJvbVBvaW50VG9Hcm91cChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGdyb3VwaW5nc1tsYWJlbHNbaV1dLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBiID0gbWVhbkRpc3RhbmNlVG9OZWFyZXN0R3JvdXAoXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBsYWJlbHMsXG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdzLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHMgPSAoYiAtIGEpIC8gTWF0aC5tYXgoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbG9va3VwIHRhYmxlIG1hcHBpbmcgZ3JvdXAgSURzIHRvIHBvaW50IElEcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy4gVGhpcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBhcyBgcG9pbnRzYCxcbiAqIGFuZCB2YWx1ZXMgbXVzdCBsaWUgaW4gWzAuLkctMV0sIHdoZXJlIEcgaXMgdGhlIG51bWJlciBvZiBncm91cHMuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQW4gYXJyYXkgb2YgbGVuZ3RoIEcsIGVhY2ggb2Ygd2hvc2UgZW50cmllcyBpcyBhbiBhcnJheVxuICogY29udGFpbmluZyB0aGUgaW5kaWNlcyBvZiB0aGUgcG9pbnRzIGluIHRoYXQgZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwcyhsYWJlbHMpIHtcbiAgICB2YXIgbnVtR3JvdXBzID0gMSArIG1heChsYWJlbHMpO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShudW1Hcm91cHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgaWYgKHJlc3VsdFtsYWJlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0W2xhYmVsXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtsYWJlbF0ucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsb29rdXAgdGFibGUgb2YgYWxsIGludGVyLXBvaW50IGRpc3RhbmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IEEgc3ltbWV0cmljIHNxdWFyZSBhcnJheSBvZiBpbnRlci1wb2ludCBkaXN0YW5jZXNcbiAqICh6ZXJvIG9uIHRoZSBkaWFnb25hbCkuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFsbERpc3RhbmNlcyhwb2ludHMpIHtcbiAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbWFrZU1hdHJpeChudW1Qb2ludHMsIG51bVBvaW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldW2pdID0gZXVjbGlkZWFuRGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbal0pO1xuICAgICAgICAgICAgcmVzdWx0W2pdW2ldID0gcmVzdWx0W2ldW2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBtZWFuIGRpc3RhbmNlIGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYWxsIHRoZSBwb2ludHMgaW4gdGhlXG4gKiBuZWFyZXN0IGdyb3VwIChhcyBkZXRlcm1pbmVkIGJ5IHdoaWNoIHBvaW50IGluIGFub3RoZXIgZ3JvdXAgaXMgY2xvc2VzdCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aGljaCBUaGUgaW5kZXggb2YgdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIExhYmVscyBvZiBwb2ludHMuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBncm91cGluZ3MgQW4gYXJyYXkgd2hvc2UgZW50cmllcyBhcmUgYXJyYXlzXG4gKiBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSBwb2ludHMgaW4gdGhhdCBncm91cC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRpc3RhbmNlcyBBIHN5bW1ldHJpYyBzcXVhcmUgYXJyYXkgb2YgaW50ZXItcG9pbnRcbiAqIGRpc3RhbmNlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1lYW4gZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIG90aGVycyBpbiB0aGUgbmVhcmVzdFxuICogZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIG1lYW5EaXN0YW5jZVRvTmVhcmVzdEdyb3VwKHdoaWNoLCBsYWJlbHMsIGdyb3VwaW5ncywgZGlzdGFuY2VzKSB7XG4gICAgdmFyIGxhYmVsID0gbGFiZWxzW3doaWNoXTtcbiAgICB2YXIgcmVzdWx0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gbGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBkID0gbWVhbkRpc3RhbmNlRnJvbVBvaW50VG9Hcm91cChcbiAgICAgICAgICAgICAgICB3aGljaCxcbiAgICAgICAgICAgICAgICBncm91cGluZ3NbaV0sXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGQgPCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBtZWFuIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCBhbmQgYWxsIHRoZSBwb2ludHMgaW4gYSBncm91cFxuICogKHBvc3NpYmx5IGl0cyBvd24pLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gd2hpY2ggVGhlIGluZGV4IG9mIHRoaXMgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGdyb3VwIFRoZSBpbmRpY2VzIG9mIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBncm91cCBpblxuICogcXVlc3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBkaXN0YW5jZXMgQSBzeW1tZXRyaWMgc3F1YXJlIGFycmF5IG9mIGludGVyLXBvaW50XG4gKiBkaXN0YW5jZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtZWFuIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBvdGhlcnMgaW4gdGhlXG4gKiBzcGVjaWZpZWQgZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIG1lYW5EaXN0YW5jZUZyb21Qb2ludFRvR3JvdXAod2hpY2gsIGdyb3VwLCBkaXN0YW5jZXMpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gZGlzdGFuY2VzW3doaWNoXVtncm91cFtpXV07XG4gICAgfVxuICAgIHJldHVybiB0b3RhbCAvIGdyb3VwLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIFtzaWxob3VldHRlIG1ldHJpY10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lsaG91ZXR0ZV8oY2x1c3RlcmluZykpXG4gKiBmb3IgYSBzZXQgb2YgTi1kaW1lbnNpb25hbCBwb2ludHMgYXJyYW5nZWQgaW4gZ3JvdXBzLiBUaGUgbWV0cmljIGlzIHRoZSBsYXJnZXN0XG4gKiBpbmRpdmlkdWFsIHNpbGhvdWV0dGUgdmFsdWUgZm9yIHRoZSBkYXRhLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBOLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGVzIG9mIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIExhYmVscyBvZiBwb2ludHMuIFRoaXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGggYXMgYHBvaW50c2AsXG4gKiBhbmQgdmFsdWVzIG11c3QgbGllIGluIFswLi5HLTFdLCB3aGVyZSBHIGlzIHRoZSBudW1iZXIgb2YgZ3JvdXBzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc2lsaG91ZXR0ZSBtZXRyaWMgZm9yIHRoZSBncm91cGluZ3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIHNpbGhvdWV0dGVNZXRyaWMoW1swLjI1XSwgWzAuNzVdXSwgWzAsIDBdKTsgLy8gPT4gMS4wXG4gKi9cbmZ1bmN0aW9uIHNpbGhvdWV0dGVNZXRyaWMocG9pbnRzLCBsYWJlbHMpIHtcbiAgICB2YXIgdmFsdWVzID0gc2lsaG91ZXR0ZShwb2ludHMsIGxhYmVscyk7XG4gICAgcmV0dXJuIG1heCh2YWx1ZXMpO1xufVxuXG4vKipcbiAqIFJlbGF0aXZlIGVycm9yLlxuICpcbiAqIFRoaXMgaXMgbW9yZSBkaWZmaWN1bHQgdG8gY2FsY3VsYXRlIHRoYW4gaXQgZmlyc3QgYXBwZWFycyBbMSwyXS4gIFRoZSB1c3VhbFxuICogZm9ybXVsYSBmb3IgdGhlIHJlbGF0aXZlIGVycm9yIGJldHdlZW4gYW4gYWN0dWFsIHZhbHVlIEEgYW5kIGFuIGV4cGVjdGVkXG4gKiB2YWx1ZSBFIGlzIGB8KEEtRSkvRXxgLCBidXQ6XG4gKlxuICogMS4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIDAsIGFueSBvdGhlciB2YWx1ZSBoYXMgaW5maW5pdGUgcmVsYXRpdmUgZXJyb3IsXG4gKiAgICB3aGljaCBpcyBjb3VudGVyLWludHVpdGl2ZTogaWYgdGhlIGV4cGVjdGVkIHZvbHRhZ2UgaXMgMCwgZ2V0dGluZyAxLzEwdGhcbiAqICAgIG9mIGEgdm9sdCBkb2Vzbid0IGZlZWwgbGlrZSBhbiBpbmZpbml0ZWx5IGxhcmdlIGVycm9yLlxuICpcbiAqIDIuIFRoaXMgZm9ybXVsYSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBtYXRoZW1hdGljYWwgZGVmaW5pdGlvbiBvZiBhIG1ldHJpYyBbM10uXG4gKiAgICBbNF0gc29sdmVkIHRoaXMgcHJvYmxlbSBieSBkZWZpbmluZyB0aGUgcmVsYXRpdmUgZXJyb3IgYXMgYHxsbih8QS9FfCl8YCxcbiAqICAgIGJ1dCB0aGF0IGZvcm11bGEgb25seSB3b3JrcyBpZiBhbGwgdmFsdWVzIGFyZSBwb3NpdGl2ZTogZm9yIGV4YW1wbGUsIGl0XG4gKiAgICByZXBvcnRzIHRoZSByZWxhdGl2ZSBlcnJvciBvZiAtMTAgYW5kIDEwIGFzIDAuXG4gKlxuICogT3VyIGltcGxlbWVudGF0aW9uIHN0aWNrcyB3aXRoIGNvbnZlbnRpb24gYW5kIHJldHVybnM6XG4gKlxuICogLSAwIGlmIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyBhcmUgYm90aCB6ZXJvXG4gKiAtIEluZmluaXR5IGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgbm9uLXplcm8gYW5kIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyB6ZXJvXG4gKiAtIGB8KEEtRSkvRXxgIGluIGFsbCBvdGhlciBjYXNlc1xuICpcbiAqIFsxXSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzY3Nzg1Mi9ob3ctdG8tY2FsY3VsYXRlLXJlbGF0aXZlLWVycm9yLXdoZW4tdHJ1ZS12YWx1ZS1pcy16ZXJvXG4gKiBbMl0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVsYXRpdmVfY2hhbmdlX2FuZF9kaWZmZXJlbmNlXG4gKiBbM10gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWV0cmljXyhtYXRoZW1hdGljcykjRGVmaW5pdGlvblxuICogWzRdIEYuVy5KLiBPbHZlcjogXCJBIE5ldyBBcHByb2FjaCB0byBFcnJvciBBcml0aG1ldGljLlwiIFNJQU0gSm91cm5hbCBvblxuICogICAgIE51bWVyaWNhbCBBbmFseXNpcywgMTUoMiksIDE5NzgsIDEwLjExMzcvMDcxNTAyNC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYWN0dWFsIFRoZSBhY3R1YWwgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWQgVGhlIGV4cGVjdGVkIHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVsYXRpdmUgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlRXJyb3IoYWN0dWFsLCBleHBlY3RlZCkge1xuICAgIC8vIFRoZXNlIGxpbmVzIGFyZSBhY3R1YWxseSBjb3ZlcmVkIGJ5IHRlc3RzLCBidXQgaXQgc2VlbXNcbiAgICAvLyBsaWtlIGM4IGhhcyBhIGJ1ZyB0aGF0IG1hcmtzIHRoZW0gYXMgbm90IGNvdmVyZWQuXG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGFjdHVhbCA9PT0gMCAmJiBleHBlY3RlZCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIGVuZCAqL1xuICAgIHJldHVybiBNYXRoLmFicygoYWN0dWFsIC0gZXhwZWN0ZWQpIC8gZXhwZWN0ZWQpO1xufVxuXG4vKipcbiAqIEFwcHJveGltYXRlIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWwgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCBUaGUgcmVmZXJlbmNlIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUaGUgYWNjZXB0YWJsZSByZWxhdGl2ZSBkaWZmZXJlbmNlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBudW1iZXJzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLlxuICovXG5mdW5jdGlvbiBhcHByb3hFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAoIHRvbGVyYW5jZSA9PT0gdm9pZCAwICkgdG9sZXJhbmNlID0gZXBzaWxvbjtcblxuICAgIHJldHVybiByZWxhdGl2ZUVycm9yKGFjdHVhbCwgZXhwZWN0ZWQpIDw9IHRvbGVyYW5jZTtcbn1cblxuZXhwb3J0IHsgQmF5ZXNpYW5DbGFzc2lmaWVyLCBQZXJjZXB0cm9uTW9kZWwsIGFkZFRvTWVhbiwgYXBwcm94RXF1YWwsIG1lYW4gYXMgYXZlcmFnZSwgbWVhblNpbXBsZSBhcyBhdmVyYWdlU2ltcGxlLCBCYXllc2lhbkNsYXNzaWZpZXIgYXMgYmF5ZXNpYW4sIGJlcm5vdWxsaURpc3RyaWJ1dGlvbiwgYmlub21pYWxEaXN0cmlidXRpb24sIGJpc2VjdCwgY2hpU3F1YXJlZERpc3RyaWJ1dGlvblRhYmxlLCBjaGlTcXVhcmVkR29vZG5lc3NPZkZpdCwgY2h1bmssIGNrbWVhbnMsIGNvZWZmaWNpZW50T2ZWYXJpYXRpb24sIGNvbWJpbmF0aW9ucywgY29tYmluYXRpb25zUmVwbGFjZW1lbnQsIGNvbWJpbmVNZWFucywgY29tYmluZVZhcmlhbmNlcywgY3VtdWxhdGl2ZVN0ZExvZ2lzdGljUHJvYmFiaWxpdHksIGN1bXVsYXRpdmVTdGROb3JtYWxQcm9iYWJpbGl0eSwgZXBzaWxvbiwgZXF1YWxJbnRlcnZhbEJyZWFrcywgZXJyb3JGdW5jdGlvbiBhcyBlcmYsIGVycm9yRnVuY3Rpb24sIGV4dGVudCwgZXh0ZW50U29ydGVkLCBmYWN0b3JpYWwsIGdhbW1hLCBnYW1tYWxuLCBnZW9tZXRyaWNNZWFuLCBoYXJtb25pY01lYW4sIGludGVycXVhcnRpbGVSYW5nZSwgaW52ZXJzZUVycm9yRnVuY3Rpb24sIGludGVycXVhcnRpbGVSYW5nZSBhcyBpcXIsIGplbmtzLCBrTWVhbnNDbHVzdGVyLCBrZXJuZWxEZW5zaXR5RXN0aW1hdGlvbiBhcyBrZGUsIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uLCBsaW5lYXJSZWdyZXNzaW9uLCBsaW5lYXJSZWdyZXNzaW9uTGluZSwgbG9nQXZlcmFnZSwgbG9naXQsIG1lZGlhbkFic29sdXRlRGV2aWF0aW9uIGFzIG1hZCwgbWF4LCBtYXhTb3J0ZWQsIG1lYW4sIG1lYW5TaW1wbGUsIG1lZGlhbiwgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb24sIG1lZGlhblNvcnRlZCwgbWluLCBtaW5Tb3J0ZWQsIG1vZGUsIG1vZGVGYXN0LCBtb2RlU29ydGVkLCBudW1lcmljU29ydCwgUGVyY2VwdHJvbk1vZGVsIGFzIHBlcmNlcHRyb24sIHBlcm11dGF0aW9uVGVzdCwgcGVybXV0YXRpb25zSGVhcCwgcG9pc3NvbkRpc3RyaWJ1dGlvbiwgcHJvYml0LCBwcm9kdWN0LCBxdWFudGlsZSwgcXVhbnRpbGVSYW5rLCBxdWFudGlsZVJhbmtTb3J0ZWQsIHF1YW50aWxlU29ydGVkLCBxdWlja3NlbGVjdCwgclNxdWFyZWQsIHJlbGF0aXZlRXJyb3IsIHJvb3RNZWFuU3F1YXJlIGFzIHJtcywgcm9vdE1lYW5TcXVhcmUsIHNhbXBsZSwgc2FtcGxlQ29ycmVsYXRpb24sIHNhbXBsZUNvdmFyaWFuY2UsIHNhbXBsZUt1cnRvc2lzLCBzYW1wbGVSYW5rQ29ycmVsYXRpb24sIHNhbXBsZVNrZXduZXNzLCBzYW1wbGVTdGFuZGFyZERldmlhdGlvbiwgc2FtcGxlVmFyaWFuY2UsIHNhbXBsZVdpdGhSZXBsYWNlbWVudCwgc2h1ZmZsZSwgc2h1ZmZsZUluUGxhY2UsIHNpZ24sIHNpbGhvdWV0dGUsIHNpbGhvdWV0dGVNZXRyaWMsIHN0YW5kYXJkRGV2aWF0aW9uLCBzdGFuZGFyZE5vcm1hbFRhYmxlLCBzdWJ0cmFjdEZyb21NZWFuLCBzdW0sIHN1bU50aFBvd2VyRGV2aWF0aW9ucywgc3VtU2ltcGxlLCB0VGVzdCwgdFRlc3RUd29TYW1wbGUsIHVuaXF1ZUNvdW50U29ydGVkLCB2YXJpYW5jZSwgd2lsY294b25SYW5rU3VtLCB6U2NvcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1zdGF0aXN0aWNzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG4gIGNzcyArPSBvYmouY3NzO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9XG5cbiAgLy8gRm9yIG9sZCBJRVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfVxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiaW1wb3J0IHRyYW5zZm9ybSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgdmFyIHQgPSB0cmFuc2Zvcm0odG9wb2xvZ3kudHJhbnNmb3JtKSwga2V5LFxuICAgICAgeDAgPSBJbmZpbml0eSwgeTAgPSB4MCwgeDEgPSAteDAsIHkxID0gLXgwO1xuXG4gIGZ1bmN0aW9uIGJib3hQb2ludChwKSB7XG4gICAgcCA9IHQocCk7XG4gICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICBpZiAocFsxXSA8IHkwKSB5MCA9IHBbMV07XG4gICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gYmJveEdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChiYm94R2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBiYm94UG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogby5jb29yZGluYXRlcy5mb3JFYWNoKGJib3hQb2ludCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJjLmxlbmd0aCwgcDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcCA9IHQoYXJjW2ldLCBpKTtcbiAgICAgIGlmIChwWzBdIDwgeDApIHgwID0gcFswXTtcbiAgICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICAgIGlmIChwWzFdID4geTEpIHkxID0gcFsxXTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvciAoa2V5IGluIHRvcG9sb2d5Lm9iamVjdHMpIHtcbiAgICBiYm94R2VvbWV0cnkodG9wb2xvZ3kub2JqZWN0c1trZXldKTtcbiAgfVxuXG4gIHJldHVybiBbeDAsIHkwLCB4MSwgeTFdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgeCkge1xuICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgZWxzZSBoaSA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG87XG59XG4iLCJpbXBvcnQgcmV2ZXJzZSBmcm9tIFwiLi9yZXZlcnNlLmpzXCI7XG5pbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgbykge1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIG8gPSB0b3BvbG9neS5vYmplY3RzW29dO1xuICByZXR1cm4gby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiXG4gICAgICA/IHt0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUodG9wb2xvZ3ksIG8pOyB9KX1cbiAgICAgIDogZmVhdHVyZSh0b3BvbG9neSwgbyk7XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIGlkID0gby5pZCxcbiAgICAgIGJib3ggPSBvLmJib3gsXG4gICAgICBwcm9wZXJ0aWVzID0gby5wcm9wZXJ0aWVzID09IG51bGwgPyB7fSA6IG8ucHJvcGVydGllcyxcbiAgICAgIGdlb21ldHJ5ID0gb2JqZWN0KHRvcG9sb2d5LCBvKTtcbiAgcmV0dXJuIGlkID09IG51bGwgJiYgYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IGJib3ggPT0gbnVsbCA/IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBiYm94OiBiYm94LCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KHRvcG9sb2d5LCBvKSB7XG4gIHZhciB0cmFuc2Zvcm1Qb2ludCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgYXJjcyA9IHRvcG9sb2d5LmFyY3M7XG5cbiAgZnVuY3Rpb24gYXJjKGksIHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgZm9yICh2YXIgYSA9IGFyY3NbaSA8IDAgPyB+aSA6IGldLCBrID0gMCwgbiA9IGEubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICBwb2ludHMucHVzaCh0cmFuc2Zvcm1Qb2ludChhW2tdLCBrKSk7XG4gICAgfVxuICAgIGlmIChpIDwgMCkgcmV2ZXJzZShwb2ludHMsIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludChwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXSk7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBwZXIgdGhlIHNwZWNpZmljYXRpb24uXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpbmcoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgIHdoaWxlIChwb2ludHMubGVuZ3RoIDwgNCkgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIGFuIGFyYyBoYXMgb25seSB0d28gcG9pbnRzLlxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MpIHtcbiAgICByZXR1cm4gYXJjcy5tYXAocmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgdmFyIHR5cGUgPSBvLnR5cGUsIGNvb3JkaW5hdGVzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiByZXR1cm4ge3R5cGU6IHR5cGUsIGdlb21ldHJpZXM6IG8uZ2VvbWV0cmllcy5tYXAoZ2VvbWV0cnkpfTtcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBjb29yZGluYXRlcyA9IHBvaW50KG8uY29vcmRpbmF0ZXMpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IGNvb3JkaW5hdGVzID0gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGNvb3JkaW5hdGVzID0gbGluZShvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKGxpbmUpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGNvb3JkaW5hdGVzID0gcG9seWdvbihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKHBvbHlnb24pOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6IHR5cGUsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307XG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnkobyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGJib3h9IGZyb20gXCIuL2Jib3guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmZWF0dXJlfSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVzaCwgbWVzaEFyY3N9IGZyb20gXCIuL21lc2guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXJnZSwgbWVyZ2VBcmNzfSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5laWdoYm9yc30gZnJvbSBcIi4vbmVpZ2hib3JzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNmb3JtfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB1bnRyYW5zZm9ybX0gZnJvbSBcIi4vdW50cmFuc2Zvcm0uanNcIjtcbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5mdW5jdGlvbiBwbGFuYXJSaW5nQXJlYShyaW5nKSB7XG4gIHZhciBpID0gLTEsIG4gPSByaW5nLmxlbmd0aCwgYSwgYiA9IHJpbmdbbiAtIDFdLCBhcmVhID0gMDtcbiAgd2hpbGUgKCsraSA8IG4pIGEgPSBiLCBiID0gcmluZ1tpXSwgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICByZXR1cm4gTWF0aC5hYnMoYXJlYSk7IC8vIE5vdGU6IGRvdWJsZWQgYXJlYSFcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVyZ2VBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gIHZhciBwb2x5Z29uc0J5QXJjID0ge30sXG4gICAgICBwb2x5Z29ucyA9IFtdLFxuICAgICAgZ3JvdXBzID0gW107XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3Qoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6IG8uYXJjcy5mb3JFYWNoKGV4dHJhY3QpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0KHBvbHlnb24pIHtcbiAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAocG9seWdvbnNCeUFyY1thcmMgPSBhcmMgPCAwID8gfmFyYyA6IGFyY10gfHwgKHBvbHlnb25zQnlBcmNbYXJjXSA9IFtdKSkucHVzaChwb2x5Z29uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhKHJpbmcpIHtcbiAgICByZXR1cm4gcGxhbmFyUmluZ0FyZWEob2JqZWN0KHRvcG9sb2d5LCB7dHlwZTogXCJQb2x5Z29uXCIsIGFyY3M6IFtyaW5nXX0pLmNvb3JkaW5hdGVzWzBdKTtcbiAgfVxuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgd2hpbGUgKHBvbHlnb24gPSBuZWlnaGJvcnMucG9wKCkpIHtcbiAgICAgICAgZ3JvdXAucHVzaChwb2x5Z29uKTtcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICBwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICBkZWxldGUgcG9seWdvbi5fO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgYXJjczogZ3JvdXBzLm1hcChmdW5jdGlvbihwb2x5Z29ucykge1xuICAgICAgdmFyIGFyY3MgPSBbXSwgbjtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIGFyY3MucHVzaChhcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGl0Y2ggdGhlIGFyY3MgaW50byBvbmUgb3IgbW9yZSByaW5ncy5cbiAgICAgIGFyY3MgPSBzdGl0Y2godG9wb2xvZ3ksIGFyY3MpO1xuXG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIHJpbmcgaXMgcmV0dXJuZWQsXG4gICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgLy8gY2hvb3NlIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3QgYWJzb2x1dGUgYXJlYS5cbiAgICAgIGlmICgobiA9IGFyY3MubGVuZ3RoKSA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGsgPSBhcmVhKGFyY3NbMF0pLCBraSwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICgoa2kgPSBhcmVhKGFyY3NbaV0pKSA+IGspIHtcbiAgICAgICAgICAgIHQgPSBhcmNzWzBdLCBhcmNzWzBdID0gYXJjc1tpXSwgYXJjc1tpXSA9IHQsIGsgPSBraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGFyY3MpIHtcbiAgICAgIHJldHVybiBhcmNzLmxlbmd0aCA+IDA7XG4gICAgfSlcbiAgfTtcbn1cbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcywgaSwgbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBhcmNzID0gZXh0cmFjdEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKTtcbiAgZWxzZSBmb3IgKGkgPSAwLCBhcmNzID0gbmV3IEFycmF5KG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aCk7IGkgPCBuOyArK2kpIGFyY3NbaV0gPSBpO1xuICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGFyY3M6IHN0aXRjaCh0b3BvbG9neSwgYXJjcyl9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpIHtcbiAgdmFyIGFyY3MgPSBbXSxcbiAgICAgIGdlb21zQnlBcmMgPSBbXSxcbiAgICAgIGdlb207XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDAoaSkge1xuICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgKGdlb21zQnlBcmNbal0gfHwgKGdlb21zQnlBcmNbal0gPSBbXSkpLnB1c2goe2k6IGksIGc6IGdlb219KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QxKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDIoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MyhhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKGdlb20gPSBvLCBvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGV4dHJhY3QxKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjYXNlIFwiUG9seWdvblwiOiBleHRyYWN0MihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogZXh0cmFjdDMoby5hcmNzKTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZ2VvbWV0cnkob2JqZWN0KTtcblxuICBnZW9tc0J5QXJjLmZvckVhY2goZmlsdGVyID09IG51bGxcbiAgICAgID8gZnVuY3Rpb24oZ2VvbXMpIHsgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9XG4gICAgICA6IGZ1bmN0aW9uKGdlb21zKSB7IGlmIChmaWx0ZXIoZ2VvbXNbMF0uZywgZ2VvbXNbZ2VvbXMubGVuZ3RoIC0gMV0uZykpIGFyY3MucHVzaChnZW9tc1swXS5pKTsgfSk7XG5cbiAgcmV0dXJuIGFyY3M7XG59XG4iLCJpbXBvcnQgYmlzZWN0IGZyb20gXCIuL2Jpc2VjdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3RzKSB7XG4gIHZhciBpbmRleGVzQnlBcmMgPSB7fSwgLy8gYXJjIGluZGV4IC0+IGFycmF5IG9mIG9iamVjdCBpbmRleGVzXG4gICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICBmdW5jdGlvbiBsaW5lKGFyY3MsIGkpIHtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICB2YXIgbyA9IGluZGV4ZXNCeUFyY1thXTtcbiAgICAgIGlmIChvKSBvLnB1c2goaSk7XG4gICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgbGluZShhcmMsIGkpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChmdW5jdGlvbihvKSB7IGdlb21ldHJ5KG8sIGkpOyB9KTtcbiAgICBlbHNlIGlmIChvLnR5cGUgaW4gZ2VvbWV0cnlUeXBlKSBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MsIGkpO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcywgaSkgeyBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IHBvbHlnb24oYXJjLCBpKTsgfSk7IH1cbiAgfTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZvciAodmFyIGkgaW4gaW5kZXhlc0J5QXJjKSB7XG4gICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbTsgKytrKSB7XG4gICAgICAgIHZhciBpaiA9IGluZGV4ZXNbal0sIGlrID0gaW5kZXhlc1trXSwgbjtcbiAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWtdKVtpID0gYmlzZWN0KG4sIGlqKV0gIT09IGlqKSBuLnNwbGljZShpLCAwLCBpaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn1cbiIsImltcG9ydCBiYm94IGZyb20gXCIuL2Jib3guanNcIjtcbmltcG9ydCB1bnRyYW5zZm9ybSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgdHJhbnNmb3JtKSB7XG4gIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgcXVhbnRpemVkXCIpO1xuXG4gIGlmICghdHJhbnNmb3JtIHx8ICF0cmFuc2Zvcm0uc2NhbGUpIHtcbiAgICBpZiAoISgobiA9IE1hdGguZmxvb3IodHJhbnNmb3JtKSkgPj0gMikpIHRocm93IG5ldyBFcnJvcihcIm4gbXVzdCBiZSDiiaUyXCIpO1xuICAgIGJveCA9IHRvcG9sb2d5LmJib3ggfHwgYmJveCh0b3BvbG9neSk7XG4gICAgdmFyIHgwID0gYm94WzBdLCB5MCA9IGJveFsxXSwgeDEgPSBib3hbMl0sIHkxID0gYm94WzNdLCBuO1xuICAgIHRyYW5zZm9ybSA9IHtzY2FsZTogW3gxIC0geDAgPyAoeDEgLSB4MCkgLyAobiAtIDEpIDogMSwgeTEgLSB5MCA/ICh5MSAtIHkwKSAvIChuIC0gMSkgOiAxXSwgdHJhbnNsYXRlOiBbeDAsIHkwXX07XG4gIH0gZWxzZSB7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveDtcbiAgfVxuXG4gIHZhciB0ID0gdW50cmFuc2Zvcm0odHJhbnNmb3JtKSwgYm94LCBrZXksIGlucHV0cyA9IHRvcG9sb2d5Lm9iamVjdHMsIG91dHB1dHMgPSB7fTtcblxuICBmdW5jdGlvbiBxdWFudGl6ZVBvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHQocG9pbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVHZW9tZXRyeShpbnB1dCkge1xuICAgIHZhciBvdXRwdXQ7XG4gICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG91dHB1dCA9IHt0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLCBnZW9tZXRyaWVzOiBpbnB1dC5nZW9tZXRyaWVzLm1hcChxdWFudGl6ZUdlb21ldHJ5KX07IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IG91dHB1dCA9IHt0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBxdWFudGl6ZVBvaW50KGlucHV0LmNvb3JkaW5hdGVzKX07IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogaW5wdXQuY29vcmRpbmF0ZXMubWFwKHF1YW50aXplUG9pbnQpfTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dC5pZCAhPSBudWxsKSBvdXRwdXQuaWQgPSBpbnB1dC5pZDtcbiAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKSBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgaWYgKGlucHV0LnByb3BlcnRpZXMgIT0gbnVsbCkgb3V0cHV0LnByb3BlcnRpZXMgPSBpbnB1dC5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUFyYyhpbnB1dCkge1xuICAgIHZhciBpID0gMCwgaiA9IDEsIG4gPSBpbnB1dC5sZW5ndGgsIHAsIG91dHB1dCA9IG5ldyBBcnJheShuKTsgLy8gcGVzc2ltaXN0aWNcbiAgICBvdXRwdXRbMF0gPSB0KGlucHV0WzBdLCAwKTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKChwID0gdChpbnB1dFtpXSwgaSkpWzBdIHx8IHBbMV0pIG91dHB1dFtqKytdID0gcDsgLy8gbm9uLWNvaW5jaWRlbnQgcG9pbnRzXG4gICAgaWYgKGogPT09IDEpIG91dHB1dFtqKytdID0gWzAsIDBdOyAvLyBhbiBhcmMgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICBvdXRwdXQubGVuZ3RoID0gajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgZm9yIChrZXkgaW4gaW5wdXRzKSBvdXRwdXRzW2tleV0gPSBxdWFudGl6ZUdlb21ldHJ5KGlucHV0c1trZXldKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVG9wb2xvZ3lcIixcbiAgICBiYm94OiBib3gsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgb2JqZWN0czogb3V0cHV0cyxcbiAgICBhcmNzOiB0b3BvbG9neS5hcmNzLm1hcChxdWFudGl6ZUFyYylcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBuKSB7XG4gIHZhciB0LCBqID0gYXJyYXkubGVuZ3RoLCBpID0gaiAtIG47XG4gIHdoaWxlIChpIDwgLS1qKSB0ID0gYXJyYXlbaV0sIGFycmF5W2krK10gPSBhcnJheVtqXSwgYXJyYXlbal0gPSB0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3ksIGFyY3MpIHtcbiAgdmFyIHN0aXRjaGVkQXJjcyA9IHt9LFxuICAgICAgZnJhZ21lbnRCeVN0YXJ0ID0ge30sXG4gICAgICBmcmFnbWVudEJ5RW5kID0ge30sXG4gICAgICBmcmFnbWVudHMgPSBbXSxcbiAgICAgIGVtcHR5SW5kZXggPSAtMTtcblxuICAvLyBTdGl0Y2ggZW1wdHkgYXJjcyBmaXJzdCwgc2luY2UgdGhleSBtYXkgYmUgc3Vic3VtZWQgYnkgb3RoZXIgYXJjcy5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGksIGopIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHQ7XG4gICAgaWYgKGFyYy5sZW5ndGggPCAzICYmICFhcmNbMV1bMF0gJiYgIWFyY1sxXVsxXSkge1xuICAgICAgdCA9IGFyY3NbKytlbXB0eUluZGV4XSwgYXJjc1tlbXB0eUluZGV4XSA9IGksIGFyY3Nbal0gPSB0O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgZSA9IGVuZHMoaSksXG4gICAgICAgIHN0YXJ0ID0gZVswXSxcbiAgICAgICAgZW5kID0gZVsxXSxcbiAgICAgICAgZiwgZztcblxuICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgIGYucHVzaChpKTtcbiAgICAgIGYuZW5kID0gZW5kO1xuICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdO1xuICAgICAgICB2YXIgZmcgPSBnID09PSBmID8gZiA6IGYuY29uY2F0KGcpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZmcuc3RhcnQgPSBmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZmcuZW5kID0gZy5lbmRdID0gZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBmLnVuc2hpZnQoaSk7XG4gICAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2cuZW5kXTtcbiAgICAgICAgdmFyIGdmID0gZyA9PT0gZiA/IGYgOiBnLmNvbmNhdChmKTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2dmLnN0YXJ0ID0gZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2dmLmVuZCA9IGYuZW5kXSA9IGdmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmID0gW2ldO1xuICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kXSA9IGY7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBlbmRzKGkpIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHAwID0gYXJjWzBdLCBwMTtcbiAgICBpZiAodG9wb2xvZ3kudHJhbnNmb3JtKSBwMSA9IFswLCAwXSwgYXJjLmZvckVhY2goZnVuY3Rpb24oZHApIHsgcDFbMF0gKz0gZHBbMF0sIHAxWzFdICs9IGRwWzFdOyB9KTtcbiAgICBlbHNlIHAxID0gYXJjW2FyYy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gaSA8IDAgPyBbcDEsIHAwXSA6IFtwMCwgcDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KSB7XG4gICAgZm9yICh2YXIgayBpbiBmcmFnbWVudEJ5RW5kKSB7XG4gICAgICB2YXIgZiA9IGZyYWdtZW50QnlFbmRba107XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgZGVsZXRlIGYuc3RhcnQ7XG4gICAgICBkZWxldGUgZi5lbmQ7XG4gICAgICBmLmZvckVhY2goZnVuY3Rpb24oaSkgeyBzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldID0gMTsgfSk7XG4gICAgICBmcmFnbWVudHMucHVzaChmKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpO1xuICBmbHVzaChmcmFnbWVudEJ5U3RhcnQsIGZyYWdtZW50QnlFbmQpO1xuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkgeyBpZiAoIXN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0pIGZyYWdtZW50cy5wdXNoKFtpXSk7IH0pO1xuXG4gIHJldHVybiBmcmFnbWVudHM7XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLCBuID0gaW5wdXQubGVuZ3RoLCBvdXRwdXQgPSBuZXcgQXJyYXkobik7XG4gICAgb3V0cHV0WzBdID0gKHgwICs9IGlucHV0WzBdKSAqIGt4ICsgZHg7XG4gICAgb3V0cHV0WzFdID0gKHkwICs9IGlucHV0WzFdKSAqIGt5ICsgZHk7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLFxuICAgICAgICBuID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHgxID0gTWF0aC5yb3VuZCgoaW5wdXRbMF0gLSBkeCkgLyBreCksXG4gICAgICAgIHkxID0gTWF0aC5yb3VuZCgoaW5wdXRbMV0gLSBkeSkgLyBreSk7XG4gICAgb3V0cHV0WzBdID0geDEgLSB4MCwgeDAgPSB4MTtcbiAgICBvdXRwdXRbMV0gPSB5MSAtIHkwLCB5MCA9IHkxO1xuICAgIHdoaWxlIChqIDwgbikgb3V0cHV0W2pdID0gaW5wdXRbal0sICsrajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuIiwiaW1wb3J0IHtcclxuICAgIGFubm90YXRpb24sXHJcbiAgICBhbm5vdGF0aW9uTGFiZWwsXHJcbiAgICBhbm5vdGF0aW9uQ2FsbG91dCxcclxuICAgIGFubm90YXRpb25DYWxsb3V0UmVjdCxcclxuICAgIGFubm90YXRpb25DYWxsb3V0Q2lyY2xlLFxyXG4gICAgYW5ub3RhdGlvblhZVGhyZXNob2xkLFxyXG59IGZyb20gJ2QzLXN2Zy1hbm5vdGF0aW9uJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEFubm90YXRpb25zKG1hcCkge1xyXG4gICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAvL2NsZWFyIHByZXZpb3VzXHJcbiAgICAgICAgem9vbUdyb3VwLnNlbGVjdEFsbCgnLmVtLWFubm90YXRpb24tZ3JvdXAnKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICBjb25zdCBhbm5vdGF0aW9uc0NvbmZpZyA9IG1hcC5hbm5vdGF0aW9uc19cclxuXHJcbiAgICAgICAgaWYgKGFubm90YXRpb25zQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIC8vIERlZmluZSBhIG1hcCB0aGF0IG1hcHMgdGhlIHR5cGUgc3RyaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIGFubm90YXRpb24gZnVuY3Rpb25cclxuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblR5cGVNYXAgPSB7XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uTGFiZWw6IGFubm90YXRpb25MYWJlbCxcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25DYWxsb3V0OiBhbm5vdGF0aW9uQ2FsbG91dCxcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25DYWxsb3V0UmVjdDogYW5ub3RhdGlvbkNhbGxvdXRSZWN0LFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGU6IGFubm90YXRpb25DYWxsb3V0Q2lyY2xlLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvblhZVGhyZXNob2xkOiBhbm5vdGF0aW9uWFlUaHJlc2hvbGQsIC8vIEFkZCBhbnkgb3RoZXIgdHlwZXMgeW91IG5lZWRcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFwIGFubm90YXRpb25zIGRhdGEgdG8gZW5zdXJlIGVhY2ggYW5ub3RhdGlvbiBoYXMgdGhlIHByb3BlciBmdW5jdGlvblxyXG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uc1dpdGhUeXBlcyA9IGFubm90YXRpb25zQ29uZmlnLmFubm90YXRpb25zLm1hcCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgJ3R5cGUnIHN0cmluZyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGFubm90YXRpb24gZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvblR5cGVNYXBbZC50eXBlXSB8fCBhbm5vdGF0aW9uTGFiZWwgLy8gRGVmYXVsdCB0byBhbm5vdGF0aW9uTGFiZWxcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmQsIHR5cGU6IGFubm90YXRpb25UeXBlIH0gLy8gVXBkYXRlICd0eXBlJyB3aXRoIHRoZSBmdW5jdGlvbiByZWZlcmVuY2VcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgY29uc3QgbWFrZUFubm90YXRpb25zID0gYW5ub3RhdGlvbigpLnR5cGUoYW5ub3RhdGlvbkxhYmVsKS5hbm5vdGF0aW9ucyhhbm5vdGF0aW9uc1dpdGhUeXBlcykuZWRpdE1vZGUoYW5ub3RhdGlvbnNDb25maWcuZWRpdE1vZGUpXHJcblxyXG4gICAgICAgICAgICAvLyBhcHBlbmQgbmV3XHJcbiAgICAgICAgICAgIHpvb21Hcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1hbm5vdGF0aW9uLWdyb3VwJykuY2FsbChtYWtlQW5ub3RhdGlvbnMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBjc3ZQYXJzZVJvd3MgfSBmcm9tICdkMy1kc3YnXHJcblxyXG4vLyBkcmF3IGdyaWQgY2FydG9ncmFtIGdlb21ldHJpZXNcclxuZXhwb3J0IGNvbnN0IGJ1aWxkR3JpZENhcnRvZ3JhbUJhc2UgPSBmdW5jdGlvbiAob3V0KSB7XHJcbiAgICBjb25zdCB6b29tR3JvdXAgPSBzZWxlY3QoYCNlbS16b29tLWdyb3VwLSR7b3V0LnN2Z0lkX31gKVxyXG4gICAgY29uc3QgZ3JpZEdyb3VwID0gem9vbUdyb3VwLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLWdyaWQtY29udGFpbmVyJylcclxuXHJcbiAgICAvLyBFbnN1cmUgbWFyZ2lucyBleGlzdCB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfID0gb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zXyB8fCB7IHRvcDogODAsIHJpZ2h0OiA4MCwgYm90dG9tOiA4MCwgbGVmdDogODAgfVxyXG5cclxuICAgIC8vIEdldCBncmlkIGxheW91dFxyXG4gICAgY29uc3QgZ3JpZExheW91dCA9IGdldEdyaWRMYXlvdXQob3V0KVxyXG4gICAgY29uc3QgcG9zaXRpb24gPSBwYXJzZUdyaWRMYXlvdXQoZ3JpZExheW91dClcclxuICAgIGNvbnN0IGdyaWREYXRhID0gZ2V0R3JpZERhdGEocG9zaXRpb24sIG91dClcclxuXHJcbiAgICAvLyBEcmF3IHRoZSBhcHByb3ByaWF0ZSBncmlkXHJcbiAgICBpZiAob3V0LmdyaWRDYXJ0b2dyYW1TaGFwZV8gPT09ICdoZXhhZ29uJykge1xyXG4gICAgICAgIGRyYXdIZXhhZ29uR3JpZChncmlkR3JvdXAsIGdyaWREYXRhLCBvdXQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdTcXVhcmVHcmlkKGdyaWRHcm91cCwgZ3JpZERhdGEsIG91dClcclxuICAgIH1cclxuXHJcbiAgICAvLyBDZW50ZXIgdGhlIGdyaWRcclxuICAgIGNlbnRlckdyaWQoZ3JpZEdyb3VwLCBvdXQud2lkdGhfLCBvdXQuaGVpZ2h0Xywgb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zXylcclxufVxyXG5cclxuLyoqIERldGVybWluZXMgdGhlIGdyaWQgbGF5b3V0IGJhc2VkIG9uIHNldHRpbmdzICovXHJcbmNvbnN0IGdldEdyaWRMYXlvdXQgPSAob3V0KSA9PiB7XHJcbiAgICBjb25zdCBzcXVhcmVHcmlkID0gYFxyXG4gICAgICAgICxJUywgICwgICxOTyxTRSxGSSwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsRUUsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLExWLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICxJRSxVSywgICwgICxESywgICxMVCwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsTkwsREUsUEwsICAsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLEJFLExVLENaLFNLLFVBLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICxGUixDSCxMSSxBVCxIVSxSTyxNRCwgICwgICwgICxcclxuICAgICAgICAsUFQsRVMsICAsSVQsU0ksSFIsUlMsQkcsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLEJBLE1FLE1LLCAgLCAgLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLEFMLEVMLFRSLEdFLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLE1ULCAgLCAgLCAgLCAgLENZLCAgLCAgLCAgYFxyXG5cclxuICAgIGNvbnN0IGhleGFnb25HcmlkID0gYFxyXG4gICAgICAgICxJUywgICwgICwgICwgICwgICwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsTk8sU0UsRkksRUUsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLExWLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICxJRSxVSywgICwgICxESywgICxMVCwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsTkwsREUsUEwsICAsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLEJFLExVLENaLFNLLFVBLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICxGUixDSCxMSSxBVCxIVSxSTyxNRCwgICwgICwgICxcclxuICAgICAgICAsUFQsRVMsICAsSVQsU0ksSFIsUlMsQkcsICAsICAsICAsXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLEJBLE1FLE1LLCAgLCAgLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLCAgLCAgLCAgLEFMLEVMLFRSLEdFLCAgLCAgXHJcbiAgICAgICAgLCAgLCAgLCAgLE1ULCAgLCAgLCAgLCAgLENZLCAgLCAgLCAgYFxyXG5cclxuICAgIHJldHVybiBvdXQuZ3JpZENhcnRvZ3JhbVBvc2l0aW9uc18gfHwgKG91dC5ncmlkQ2FydG9ncmFtU2hhcGVfID09PSAnaGV4YWdvbicgPyBoZXhhZ29uR3JpZCA6IHNxdWFyZUdyaWQpXHJcbn1cclxuXHJcbi8qKiBQYXJzZXMgdGhlIGdyaWQgbGF5b3V0IGFuZCBtYXBzIGVhY2ggSUQgdG8gaXRzIHBvc2l0aW9uICovXHJcbmNvbnN0IHBhcnNlR3JpZExheW91dCA9IChncmlkTGF5b3V0KSA9PiB7XHJcbiAgICBjb25zdCBwb3NpdGlvbkJ5SWQgPSBuZXcgTWFwKClcclxuICAgIGNzdlBhcnNlUm93cyhncmlkTGF5b3V0LnRyaW0oKSwgKHJvdywgaikgPT4ge1xyXG4gICAgICAgIHJvdy5mb3JFYWNoKChpZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoKGlkID0gaWQudHJpbSgpKSkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25CeUlkLnNldChpZCwgW2ksIGpdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbiAgICByZXR1cm4gcG9zaXRpb25CeUlkXHJcbn1cclxuXHJcbi8qKiBDb252ZXJ0cyBwYXJzZWQgcG9zaXRpb25zIGludG8gc3RydWN0dXJlZCBncmlkIGRhdGEgKi9cclxuY29uc3QgZ2V0R3JpZERhdGEgPSAocG9zaXRpb24sIG91dCkgPT4ge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocG9zaXRpb24sIChbaWQsIFtjb2wsIHJvd11dKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IG91dC5HZW9tZXRyaWVzLmdlb0pTT05zLm51dHNyZy5maW5kKChyZykgPT4gcmcucHJvcGVydGllcy5pZCA9PSBpZClcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICByb3csXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGZlYXR1cmUgPyBmZWF0dXJlLnByb3BlcnRpZXMubmEgOiAnJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG4vKiogRHJhd3MgYSBzcXVhcmUgZ3JpZCAqL1xyXG5jb25zdCBkcmF3U3F1YXJlR3JpZCA9IChncmlkR3JvdXAsIGdyaWREYXRhLCBvdXQpID0+IHtcclxuICAgIGNvbnN0IG51bUNvbHMgPSBNYXRoLm1heCguLi5ncmlkRGF0YS5tYXAoKGQpID0+IGQuY29sKSkgKyAxXHJcbiAgICBjb25zdCBudW1Sb3dzID0gTWF0aC5tYXgoLi4uZ3JpZERhdGEubWFwKChkKSA9PiBkLnJvdykpICsgMVxyXG5cclxuICAgIGNvbnN0IG1hcmdpbnMgPSBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfXHJcbiAgICBjb25zdCBjZWxsUGFkZGluZyA9IG91dC5ncmlkQ2FydG9ncmFtQ2VsbFBhZGRpbmdfIHx8IDAgLy8gS2VlcCBjZWxsIHBhZGRpbmdcclxuXHJcbiAgICBjb25zdCBjZWxsV2lkdGggPSAob3V0LndpZHRoXyAtIG1hcmdpbnMubGVmdCAtIG1hcmdpbnMucmlnaHQpIC8gbnVtQ29scyAtIGNlbGxQYWRkaW5nXHJcbiAgICBjb25zdCBjZWxsSGVpZ2h0ID0gKG91dC5oZWlnaHRfIC0gbWFyZ2lucy50b3AgLSBtYXJnaW5zLmJvdHRvbSkgLyBudW1Sb3dzIC0gY2VsbFBhZGRpbmdcclxuICAgIGNvbnN0IGNlbGxTaXplID0gTWF0aC5taW4oY2VsbFdpZHRoLCBjZWxsSGVpZ2h0KVxyXG5cclxuICAgIGdyaWRHcm91cFxyXG4gICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLWNlbGwnKVxyXG4gICAgICAgIC5kYXRhKGdyaWREYXRhKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtY2VsbCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiBgdHJhbnNsYXRlKCR7ZC5jb2wgKiAoY2VsbFNpemUgKyBjZWxsUGFkZGluZykgKyBtYXJnaW5zLmxlZnR9LCAke2Qucm93ICogKGNlbGxTaXplICsgY2VsbFBhZGRpbmcpICsgbWFyZ2lucy50b3B9KWApXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmFwcGVuZCgncmVjdCcpLmF0dHIoJ3dpZHRoJywgY2VsbFNpemUpLmF0dHIoJ2hlaWdodCcsIGNlbGxTaXplKS5hdHRyKCdjbGFzcycsICdlbS1ncmlkLXJlY3QnKVxyXG5cclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoZC5pZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgY2VsbFNpemUgLyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBjZWxsU2l6ZSAvIDIgKyA1KVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbi8qKiBEcmF3cyBhIGhleGFnb24gZ3JpZCAqL1xyXG5jb25zdCBkcmF3SGV4YWdvbkdyaWQgPSAoZ3JpZEdyb3VwLCBncmlkRGF0YSwgb3V0KSA9PiB7XHJcbiAgICBjb25zdCBudW1Db2xzID0gTWF0aC5tYXgoLi4uZ3JpZERhdGEubWFwKChkKSA9PiBkLmNvbCkpICsgMVxyXG4gICAgY29uc3QgbnVtUm93cyA9IE1hdGgubWF4KC4uLmdyaWREYXRhLm1hcCgoZCkgPT4gZC5yb3cpKSArIDFcclxuXHJcbiAgICBjb25zdCBtYXJnaW5zID0gb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zX1xyXG4gICAgY29uc3QgY2VsbFBhZGRpbmcgPSBvdXQuZ3JpZENhcnRvZ3JhbUNlbGxQYWRkaW5nXyB8fCAwIC8vIEtlZXAgY2VsbCBwYWRkaW5nXHJcblxyXG4gICAgY29uc3QgYmFzZUhleFJhZGl1cyA9IE1hdGgubWluKFxyXG4gICAgICAgIChvdXQud2lkdGhfIC0gbWFyZ2lucy5sZWZ0IC0gbWFyZ2lucy5yaWdodCkgLyAobnVtQ29scyAqIDEuNSksXHJcbiAgICAgICAgKG91dC5oZWlnaHRfIC0gbWFyZ2lucy50b3AgLSBtYXJnaW5zLmJvdHRvbSkgLyAobnVtUm93cyAqIE1hdGguc3FydCgzKSlcclxuICAgIClcclxuXHJcbiAgICBjb25zdCBoZXhSYWRpdXMgPSBiYXNlSGV4UmFkaXVzXHJcbiAgICBjb25zdCBoZXhIZWlnaHQgPSBNYXRoLnNxcnQoMykgKiBoZXhSYWRpdXNcclxuXHJcbiAgICBncmlkR3JvdXBcclxuICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC1jZWxsJylcclxuICAgICAgICAuZGF0YShncmlkRGF0YSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1ncmlkLWNlbGwnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gZC5jb2wgKiAoMS41ICogaGV4UmFkaXVzICsgY2VsbFBhZGRpbmcpICsgbWFyZ2lucy5sZWZ0XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBkLnJvdyAqIChoZXhIZWlnaHQgKyBjZWxsUGFkZGluZykgKyAoZC5jb2wgJSAyID09PSAxID8gKGhleEhlaWdodCArIGNlbGxQYWRkaW5nKSAvIDIgOiAwKSArIG1hcmdpbnMudG9wXHJcbiAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBkcmF3SGV4YWdvbihoZXhSYWRpdXMpKS5hdHRyKCdjbGFzcycsICdlbS1ncmlkLWhleGFnb24nKVxyXG5cclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoZC5pZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgNSlcclxuICAgICAgICB9KVxyXG59XHJcblxyXG4vKiogR2VuZXJhdGVzIHRoZSBoZXhhZ29uIHBhdGggKi9cclxuY29uc3QgZHJhd0hleGFnb24gPSAocikgPT4ge1xyXG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLlBJIC8gM1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2IH0sIChfLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSByICogTWF0aC5jb3MoYW5nbGUgKiBpKVxyXG4gICAgICAgICAgICBjb25zdCB5ID0gciAqIE1hdGguc2luKGFuZ2xlICogaSlcclxuICAgICAgICAgICAgcmV0dXJuIGAke2kgPT09IDAgPyAnTScgOiAnTCd9JHt4fSwke3l9YFxyXG4gICAgICAgIH0pLmpvaW4oJyAnKSArICcgWidcclxuICAgIClcclxufVxyXG5cclxuLyoqIENlbnRlcnMgdGhlIGdyaWQgd2l0aGluIHRoZSBTVkcgKi9cclxuY29uc3QgY2VudGVyR3JpZCA9IChncmlkR3JvdXAsIHN2Z1dpZHRoLCBzdmdIZWlnaHQsIG1hcmdpbnMpID0+IHtcclxuICAgIGdyaWRHcm91cC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KClcclxuICAgICAgICBjb25zdCBkeCA9IChzdmdXaWR0aCAtIG1hcmdpbnMubGVmdCAtIG1hcmdpbnMucmlnaHQgLSBiYm94LndpZHRoKSAvIDIgLSBiYm94LnggKyBtYXJnaW5zLmxlZnRcclxuICAgICAgICBjb25zdCBkeSA9IChzdmdIZWlnaHQgLSBtYXJnaW5zLnRvcCAtIG1hcmdpbnMuYm90dG9tIC0gYmJveC5oZWlnaHQpIC8gMiAtIGJib3gueSArIG1hcmdpbnMudG9wXHJcbiAgICAgICAgZ3JpZEdyb3VwLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtkeH0sICR7ZHl9KWApXHJcbiAgICB9KVxyXG59XHJcbiIsImltcG9ydCB7IHVwZGF0ZUNTU1J1bGUgfSBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuLyogcHJldHRpZXItaWdub3JlICovXHJcbi8vIHRvIGtlZXAgdHJhY2sgb2YgZGVwcmVjYXRlZCBmdW5jdGlvbnMgd2hpbHN0IGtlZXBpbmcgdGhlIGN1cnJlbnQgdmVyc2lvbiBjbGVhbi5cclxuLy8gYWxzbyBwYXNzZXMgYW55IGltcG9ydGFudCBwYXJhbWV0ZXJzIHRvIHRoZSBuZXcgZnVuY3Rpb25zIChpZiB0aGV5IGV4aXN0KSBhbmQgb3ZlcndyaXRlcyBhbnkgQ1NTIHN0eWxlIHJ1bGVzLlxyXG4vLyBUbyBiZSByZW1vdmVkIHdoZW4gY29tcGxldGVseSBwaGFzZWQgb3V0LlxyXG5cclxuZXhwb3J0IGNvbnN0IGRlZmluZURlcHJlY2F0ZWRGdW5jdGlvbnMgPSAob3V0KSA9PiB7XHJcbiAgICAvLyBzdHlsZXNcclxuICAgIG91dC5zZWFGaWxsU3R5bGUgPSAodikgPT4gKGNvbnNvbGUud2Fybignc2VhRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1zZWEgQ1NTIGNsYXNzJyksIHVwZGF0ZUNTU1J1bGUoJy5lbS1zZWEnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5jbnRyZ0ZpbGxTdHlsZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdjbnRyZ0ZpbGxTdHlsZSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tY250cmcgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLWNudHJnJywnZmlsbCcsdiksIG91dCk7XHJcbiAgICBvdXQubnV0c3JnRmlsbFN0eWxlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ251dHNyZ0ZpbGxTdHlsZSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tbnV0c3JnIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1udXRzcmcnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5udXRzYm5TdHJva2UgPSAodikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignbnV0c2JuU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5ibl8wLCAuYm5fMSwgLmJuXzIsIC5ibl8zIENTUyBjbGFzc2VzJylcclxuICAgICAgICBpZiAodlsnMCddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8wJywnc3Ryb2tlJyx2WycwJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WycxJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzEnLCdzdHJva2UnLHZbJzEnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzInXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMicsJ3N0cm9rZScsdlsnMiddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8zJywnc3Ryb2tlJyx2WyczJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH07XHJcbiAgICBvdXQubnV0c2JuU3Ryb2tlV2lkdGggPSAodikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignbnV0c2JuU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmJuXzAsIC5ibl8xLCAuYm5fMiwgLmJuXzMgQ1NTIGNsYXNzZXMnKVxyXG4gICAgICAgIGlmICh2WycwJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzAnLCdzdHJva2Utd2lkdGgnLHZbJzAnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzEnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMScsJ3N0cm9rZS13aWR0aCcsdlsnMSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMiddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8yJywnc3Ryb2tlLXdpZHRoJyx2WycyJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WyczJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzMnLCdzdHJva2Utd2lkdGgnLHZbJzMnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC5ncmF0aWN1bGVTdHJva2UgPSAodikgPT4gKGNvbnNvbGUud2FybignZ3JhdGljdWxlU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1ncmF0aWN1bGUgQ1NTIGNsYXNzJyksIHVwZGF0ZUNTU1J1bGUoJy5lbS1ncmF0aWN1bGUnLCdzdHJva2UnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmdyYXRpY3VsZVN0cm9rZVdpZHRoID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2dyYXRpY3VsZVN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1ncmF0aWN1bGUgQ1NTIGNsYXNzJyksIHVwZGF0ZUNTU1J1bGUoJy5lbS1ncmF0aWN1bGUnLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG4gICAgb3V0Lm51dHNyZ1NlbEZpbGxTdHkgPSAodikgPT4gKGNvbnNvbGUud2FybignbnV0c3JnU2VsRmlsbFN0eSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIGhvdmVyQ29sb3IoKSBpbnN0ZWFkJyksIG91dC5ob3ZlckNvbG9yXyA9IHYsIG91dCk7XHJcbiAgICBvdXQudGl0bGVGb250U2l6ZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAudGl0bGVGb250U2l6ZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tdGl0bGUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXRpdGxlJywnZm9udC1zaXplJyx2KSwgb3V0KTtcclxuICAgIG91dC5zdWJ0aXRsZUZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5zdWJ0aXRsZUZvbnRTaXplKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdWJ0aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tc3VidGl0bGUnLCdmb250LXNpemUnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnN1YnRpdGxlRm9udFdlaWdodCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuc3VidGl0bGVGb250V2VpZ2h0KCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdWJ0aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tc3VidGl0bGUnLCdmb250LXdlaWdodCcsdiksIG91dCk7XHJcbiAgICBvdXQudGl0bGVGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50aXRsZUZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS10aXRsZScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnN1YnRpdGxlRmlsbCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuc3VidGl0bGVGaWxsKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1zdWJ0aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tc3VidGl0bGUnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5jbnRiblN0cm9rZSA9ICh2KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdjbnRiblN0cm9rZSgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tY250Ym4gLmVtLWJuLWV1IC5lbS1ibi1lZnRhIC5lbS1ibi1jYyAuZW0tYm4tb3RoIENTUyBjbGFzc2VzJylcclxuICAgICAgICBpZiAodlsnZXUnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tZXUnLCdzdHJva2UnLHZbJ2V1J10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydlZnRhJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWVmdGEnLCdzdHJva2UnLHZbJ2VmdGEnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2NjJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWNjJywnc3Ryb2tlJyx2WydjYyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnb3RoJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLW90aCcsJ3N0cm9rZScsdlsnb3RoJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydjbyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZScsdlsnY28nXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC5jbnRiblN0cm9rZVdpZHRoID0gKHYpID0+IHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2NudGJuU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLWNudGJuIC5lbS13b3JsZGJuIC5lbS1ibi1ldSAuZW0tYm4tZWZ0YSAuZW0tYm4tY2MgLmVtLWJuLW90aCBDU1MgY2xhc3NlcycpXHJcbiAgICAgICAgaWYgKHZbJ2V1J10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWV1Jywnc3Ryb2tlLXdpZHRoJyx2WydldSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnZWZ0YSddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1lZnRhJywnc3Ryb2tlLXdpZHRoJyx2WydlZnRhJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydjYyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jYycsJ3N0cm9rZS13aWR0aCcsdlsnY2MnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ290aCddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1vdGgnLCdzdHJva2Utd2lkdGgnLHZbJ290aCddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnY28nXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY28nLCdzdHJva2Utd2lkdGgnLHZbJ2NvJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH07XHJcbiAgICBvdXQud29ybGRTdHJva2UgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS13b3JsZGJuIC5lbS1ibi1jbyAuZW0tYm4tZCBDU1MgY2xhc3NlcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS13b3JsZGJuJywnc3Ryb2tlJyx2KSwgb3V0KTtcclxuICAgIG91dC53b3JsZFN0cm9rZVdpZHRoID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZFN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS13b3JsZGJuIC5lbS1ibi1jbyAuZW0tYm4tZCBDU1MgY2xhc3NlcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS13b3JsZGJuJywnc3Ryb2tlLXdpZHRoJyx2KSwgb3V0KTtcclxuICAgIG91dC53b3JsZENvYXN0U3Ryb2tlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZENvYXN0U3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1ibi1jbyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY28nLCdzdHJva2UnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkQ29hc3RTdHJva2VXaWR0aCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAud29ybGRDb2FzdFN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1ibi1jbyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY28nLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkRmlsbFN0eWxlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZEZpbGxTdHlsZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0td29ybGRyZyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0td29ybGRyZycsJ2ZpbGwnLHYpLCBvdXQpOyBcclxuICAgIG91dC5jb2FzdGFsTWFyZ2luV2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmNvYXN0YWxNYXJnaW5XaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAjZW0tY29hc3QtbWFyZ2luIENTUyBydWxlJyksdXBkYXRlQ1NTUnVsZSgnI2VtLWNvYXN0LW1hcmdpbicsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7ICBcclxuICAgIG91dC5jb2FzdGFsTWFyZ2luQ29sb3IgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmNvYXN0YWxNYXJnaW5Db2xvcigpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAjZW0tY29hc3QtbWFyZ2luIENTUyBydWxlJyksdXBkYXRlQ1NTUnVsZSgnI2VtLWNvYXN0LW1hcmdpbicsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQuZm9udEZhbWlseSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuZm9udEZhbWlseSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tbWFwIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1tYXAnLCdmb250LWZhbWlseScsdiksIG91dCk7XHJcbiAgICBvdXQuYm90VHh0Rm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmJvdFR4dEZvbnRTaXplKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1mb290bm90ZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tZm9vdG5vdGUnLCdmb250LXNpemUnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZpbGwgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmJvdFR4dEZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZvb3Rub3RlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mb290bm90ZScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnNjYWxlYmFyRm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnNjYWxlYmFyRm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXNjYWxlYmFyLWxhYmVsIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zY2FsZWJhci1sYWJlbCcsJ2ZvbnQtc2l6ZScsdiksIG91dCk7XHJcbiAgICBvdXQuZnJhbWVTdHJva2UgPSAodik9PiAoY29uc29sZS53YXJuKCdtYXAuZnJhbWVTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZyYW1lIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mcmFtZScsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQuZnJhbWVTdHJva2VXaWR0aCA9ICh2KT0+IChjb25zb2xlLndhcm4oJ21hcC5mcmFtZVN0cm9rZVdpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1mcmFtZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tZnJhbWUnLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG5cclxuICAgLy9vdGhlclxyXG4gICAgb3V0LnBzQ2xhc3NpZk1ldGhvZCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdwc0NsYXNzaWZNZXRob2QoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBwc0NsYXNzaWZpY2F0aW9uTWV0aG9kIGluc3RlYWQnKSxvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSB2LCBvdXQpO1xyXG4gICAgb3V0Lmdlb0NlbnRlciA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuZ2VvQ2VudGVyKCkgaXMgbm93IGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbWFwLnBvc2l0aW9uKHt4LHksen0pIGluc3RlYWQuJyksIG91dC5wb3NpdGlvbl8ueCA9IHZbMF0sIG91dC5wb3NpdGlvbl8ueSA9IHZbMV0sIG91dCk7XHJcbiAgICBvdXQucGl4ZWxTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5waXhlbFNpemUoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgeiBwcm9wZXJ0eSBpbiBtYXAucG9zaXRpb24oe3gseSx6fSkgaW5zdGVhZC4nKSwgb3V0LnBvc2l0aW9uXy56ID0gdiwgb3V0KTtcclxuICAgIG91dC5waXhTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5waXhlbFNpemUoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgeiBwcm9wZXJ0eSBpbiBtYXAucG9zaXRpb24oe3gseSx6fSkgaW5zdGVhZC4nKSwgb3V0LnBvc2l0aW9uXy56ID0gdiwgb3V0KTtcclxuICAgIG91dC50b29sdGlwVGV4dCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAudG9vbHRpcFRleHQoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtYXAudG9vbHRpcChjb25maWcudGV4dEZ1bmN0aW9uKSBpbnN0ZWFkLiBTZWUgQVBJIHJlZmVyZW5jZSBmb3IgZGV0YWlscy4nKSwgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHYsIG91dCk7XHJcbiAgICBvdXQuY2xhc3NpZk1ldGhvZCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY2xhc3NpZk1ldGhvZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC5jbGFzc2lmaWNhdGlvbk1ldGhvZCgpIGluc3RlYWQuJyksIG91dC5jbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSB2LG91dCk7XHJcbiAgICBvdXQudGhyZXNob2xkID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50aHJlc2hvbGQoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBtYXAudGhyZXNob2xkcygpIGluc3RlYWQuJyksIG91dC50aHJlc2hvbGRzXyA9IHYsb3V0KTtcclxuICAgIG91dC5jbG5iID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jbG5iKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLm51bWJlck9mQ2xhc3NlcygpIGluc3RlYWQuJyksIG91dC5udW1iZXJPZkNsYXNzZXNfID0gdixvdXQpO1xyXG4gICAgb3V0Lm51dHNMdmwgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLm51dHNMdmwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBtYXAubnV0c0xldmVsKCkgaW5zdGVhZC4nKSwgb3V0Lm51dHNMZXZlbF8gPSB2LG91dCk7XHJcbiAgICBvdXQubGcgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxnKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLmxhbmd1YWdlKCkgaW5zdGVhZC4nKSwgb3V0Lmxhbmd1YWdlXyA9IHYsb3V0KTtcclxuICAgIG91dC5ib3R0b21UZXh0ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdHRvbVRleHQgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2UgdGhlIGZvb3Rub3RlKCkgbWV0aG9kIGFuZCBlbS1mb290bm90ZSBDU1MgY2xhc3MgaW5zdGVhZC4nKSxvdXQuZm9vdG5vdGVfID0gdixvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdFR4dEZvbnRTaXplIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIHRoZSBlbS1mb290bm90ZSBDU1MgY2xhc3MgaW5zdGVhZC4nKSxvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZpbGwgPSAodikgPT4gKGNvbnNvbGUud2FybignYm90VHh0RmlsbCBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSB0aGUgZW0tZm9vdG5vdGUgQ1NTIGNsYXNzIGluc3RlYWQuJyksb3V0KTtcclxuICAgIG91dC5ib3RUeHRQYWRkaW5nID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdFR4dFBhZGRpbmcgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2UgdGhlIGVtLWZvb3Rub3RlIENTUyBjbGFzcyBpbnN0ZWFkLicpLG91dCk7XHJcbiAgICBvdXQuYm90VHh0VG9vbHRpcFR4dCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdib3RUeHRUb29sdGlwVHh0IGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIGZvb3Rub3RlVG9vbHRpcFRleHQoKSBpbnN0ZWFkLicpLG91dCk7XHJcbiAgICBvdXQudG9vbHRpcFNob3dGbGFncyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ3Rvb2x0aXBTaG93RmxhZ3MgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LnRvb2x0aXAoe3Nob3dGbGFnc30pIGluc3RlYWQuJyksb3V0LnRvb2x0aXBfLnNob3dGbGFncyA9IHYsb3V0KTtcclxuICAgIG91dC5jb2xvckZ1biA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2NvbG9yRnVuIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5jb2xvckZ1bmN0aW9uKCkgaW5zdGVhZC4nKSxvdXQuY29sb3JGdW5jdGlvbl8gPSB2LG91dCk7XHJcbiAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW4gPSAodik9Pihjb25zb2xlLndhcm4oJ2ZpbHRlcnNEZWZpbml0aW9uRnVuIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uKCkgaW5zdGVhZC4nKSxvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8gPSB2LG91dCk7XHJcbiAgICBcclxuICAgIC8vbGFiZWxsaW5nXHJcbiAgICBvdXQubGFiZWxsaW5nID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxsaW5nIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe30pIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxzQ29uZmlnID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxzQ29uZmlnIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe2NvbmZpZzp5b3VyQ29uZmlnfSkgY29uZmlndXJhdGlvbiBvYmplY3QgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0LmxhYmVsc18gPU9iamVjdC5hc3NpZ24ob3V0LmxhYmVsc18gfHwge30sIHsgY29uZmlnOiB2IH0pLG91dCk7XHJcbiAgICBvdXQuc3RhdExhYmVsc1Bvc2l0aW9ucyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ3N0YXRMYWJlbHNQb3NpdGlvbnMgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7c3RhdExhYmVsc1Bvc2l0aW9uczp5b3VyUG9zaXRpb25zfSkgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0LmxhYmVsc18gPSBPYmplY3QuYXNzaWduKG91dC5sYWJlbHNfIHx8IHt9LCB7IHN0YXRMYWJlbHNQb3NpdGlvbnM6IHYgfSksb3V0KTtcclxuICAgIG91dC5sYWJlbHNUb1Nob3cgPSAodikgPT4oY29uc29sZS53YXJuKCdsYWJlbHNUb1Nob3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxGaWx0ZXJGdW5jdGlvbjp5b3VyRnVuY3Rpb24ocmVnaW9uLG1hcCl9KSBmdW5jdGlvbiBpbnN0ZWFkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKSxvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93c1RvU2hvdyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2xhYmVsU2hhZG93c1RvU2hvdyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbEZpbHRlckZ1bmN0aW9uOnlvdXJGdW5jdGlvbihyZWdpb24sbWFwKX0pIGZ1bmN0aW9uIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxTaGFkb3cgPSAodikgPT4oY29uc29sZS53YXJuKCdsYWJlbFNoYWRvdyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbFNoYWRvdzpib29sZWFufSkgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0KTtcclxuICAgIG91dC5sYWJlbFNoYWRvd1dpZHRoID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxTaGFkb3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxTaGFkb3c6Ym9vbGVhbn0pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxGaWx0ZXJGdW5jdGlvbiA9KHYpID0+KGNvbnNvbGUud2FybignbGFiZWxGaWx0ZXJGdW5jdGlvbiBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbEZpbHRlckZ1bmN0aW9uOnlvdXJGdW5jdGlvbihyZWdpb24sbWFwKX0pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbEZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU3Ryb2tlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbFN0cm9rZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxTdHJva2VXaWR0aCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxTdHJva2VXaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxPcGFjaXR5ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbE9wYWNpdHkoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsVmFsdWVzRm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsVmFsdWVzRm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93V2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsU2hhZG93V2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzLXNoYWRvd3MgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxTaGFkb3dDb2xvciA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxTaGFkb3dDb2xvcigpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMtc2hhZG93cyBDU1MgY2xhc3MnKSwgb3V0KTtcclxuXHJcbiAgICBvdXQuY291bnRyaWVzVG9TaG93ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jb3VudHJpZXNUb1Nob3coKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgbWFwLmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbigpIGZ1bmN0aW9uIGlmIHlvdSB3aXNoIHRvIGZpbHRlciB0aGUgZGVmYXVsdCBnZW9tZXRyaWVzLicpLCBvdXQpO1xyXG4gICAgb3V0LmJvcmRlcnNUb1Nob3cgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmJvcmRlcnNUb1Nob3coKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgbWFwLmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbigpIGZ1bmN0aW9uIGlmIHlvdSB3aXNoIHRvIGZpbHRlciB0aGUgZGVmYXVsdCBnZW9tZXRyaWVzLicpLCBvdXQpO1xyXG59XHJcbiIsIi8vIHRha2VzIGNhcmUgb2YgdGhlIG1hcCdzIGdlb21ldHJpZXNcclxuaW1wb3J0IHsganNvbiB9IGZyb20gJ2QzLWZldGNoJ1xyXG5pbXBvcnQgeyBmZWF0dXJlIH0gZnJvbSAndG9wb2pzb24tY2xpZW50J1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IHsga29zb3ZvQm5GZWF0dXJlcyB9IGZyb20gJy4va29zb3ZvJ1xyXG5pbXBvcnQgeyBnZW9HcmF0aWN1bGUgfSBmcm9tICdkMy1nZW8nXHJcblxyXG4vLyBHZW9tZXRyaWVzIGNsYXNzIHdyYXBwZWQgYXMgYSBmdW5jdGlvblxyXG5leHBvcnQgY29uc3QgR2VvbWV0cmllcyA9IGZ1bmN0aW9uIChtYXAsIHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgIGxldCBvdXQgPSB7fVxyXG5cclxuICAgIC8vIGRlZmF1bHRzXHJcbiAgICBvdXQuZGVmYXVsdEdlb0RhdGEgPSB1bmRlZmluZWRcclxuICAgIG91dC5hbGxOVVRTR2VvRGF0YSA9IHVuZGVmaW5lZFxyXG4gICAgb3V0Lmdlb0pTT05zID0ge1xyXG4gICAgICAgIG1peGVkOiB7IHJnMDogdW5kZWZpbmVkLCByZzE6IHVuZGVmaW5lZCwgcmcyOiB1bmRlZmluZWQsIHJnMzogdW5kZWZpbmVkIH0sXHJcbiAgICAgICAgY250Ym46IHVuZGVmaW5lZCxcclxuICAgICAgICBjbnRyZzogdW5kZWZpbmVkLFxyXG4gICAgICAgIG51dHNibjogdW5kZWZpbmVkLFxyXG4gICAgICAgIG51dHNyZzogdW5kZWZpbmVkLFxyXG4gICAgICAgIGdyYTogdW5kZWZpbmVkLFxyXG4gICAgICAgIHdvcmxkcmc6IHVuZGVmaW5lZCxcclxuICAgICAgICB3b3JsZGJuOiB1bmRlZmluZWQsXHJcbiAgICAgICAga29zb3ZvOiB1bmRlZmluZWQsXHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXNlciBkZWZpbmVkIGdlb21ldHJpZXMgKGxheWVycylcclxuICAgIG91dC51c2VyR2VvbWV0cmllcyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vIHVzZXIgZGVmaW5lZCBzdGF0aXN0aWNhbCByZWdpb25zXHJcbiAgICBvdXQuc3RhdGlzdGljYWxSZWdpb25zID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9jZW50cm9pZHMgZm9yIHByb3Agc3ltYm9scyBldGNcclxuICAgIG91dC5jZW50cm9pZHNEYXRhID0gdW5kZWZpbmVkIC8vcmF3XHJcbiAgICBvdXQuY2VudHJvaWRzRmVhdHVyZXMgPSB1bmRlZmluZWQgLy9nZW9qc29uIGZlYXR1cmVzXHJcblxyXG4gICAgLy8gZ2V0IGdlb2pzb24gZmVhdHVyZXMgb2YgYWxsIHN0YXRpc3RpY2FsIHJlZ2lvbnNcclxuICAgIG91dC5nZXRSZWdpb25GZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobWFwLmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0Lmdlb0pTT05zLndvcmxkcmdcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbb3V0Lmdlb0pTT05zLm1peGVkLnJnMCwgb3V0Lmdlb0pTT05zLm1peGVkLnJnMSwgb3V0Lmdlb0pTT05zLm1peGVkLnJnMiwgb3V0Lmdlb0pTT05zLm1peGVkLnJnM11cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuZ2VvSlNPTnMubnV0c3JnLmNvbmNhdChvdXQuZ2VvSlNPTnMuY250cmcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYW5kIHBhcnNlcyAnZGVmYXVsdCcgZ2VvIGRhdGEgKGZvciBOVVRTIG9yIFdvcmxkIG1hcHMpXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXREZWZhdWx0R2VvRGF0YSA9IGZ1bmN0aW9uIChnZW8sIGZpbHRlckdlb21ldHJpZXNGdW5jdGlvbiwgbnV0c0xldmVsKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBvdXQuZ2V0RGVmYXVsdEdlb0RhdGFQcm9taXNlKClcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGZpbHRlckdlb21ldHJpZXNGdW5jdGlvbihyZXN1bHRzKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3V0LmFsbE5VVFNHZW9EYXRhID0gcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgb3V0LmRlZmF1bHRHZW9EYXRhID0gcmVzdWx0c1swXVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNlbnRyb2lkc0RhdGEgPSBudXRzTGV2ZWwgPT09ICdtaXhlZCcgPyBbcmVzdWx0c1s0XSwgcmVzdWx0c1s1XSwgcmVzdWx0c1s2XSwgcmVzdWx0c1s3XV0gOiByZXN1bHRzWzFdXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNXb3JsZCA9IGdlbyA9PT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIFRvcG9KU09OIHRvIEdlb0pTT05cclxuICAgICAgICAgICAgICAgIGlmIChpc1dvcmxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLndvcmxkcmcgPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMuQ05UUl9SR18yME1fMjAyMF80MzI2KS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy53b3JsZGJuID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLkNOVFJfQk5fMjBNXzIwMjBfNDMyNikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMua29zb3ZvID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLk5VVFNfQk5fMjBNXzIwMjFfUlNfWEtfYm9yZGVyKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5ncmF0aWN1bGUgPSBbZ2VvR3JhdGljdWxlKCkuc3RlcChbMzAsIDMwXSkoKV1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLmdyYXRpY3VsZSA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5ncmEpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLm51dHNyZyA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5udXRzcmcpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLm51dHNibiA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5udXRzYm4pLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLmNudHJnID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLmNudHJnKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5jbnRibiA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5jbnRibikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgZm9yIE51dHMySlNPTiB0b3BvanNvbiBkYXRhLlxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0RGVmYXVsdEdlb0RhdGFQcm9taXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG51dHNMZXZlbHMgPSBbMCwgMSwgMiwgM11cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdXHJcblxyXG4gICAgICAgIGNvbnN0IGJ1aWxkVXJsID0gKGJhc2UsIHllYXIsIGdlbywgcHJvaiwgc2NhbGUsIGxldmVsLCB3aXRoQ2VudGVyID0gZmFsc2UpID0+IHtcclxuICAgICAgICAgICAgbGV0IHBhdGggPSBgJHtiYXNlfS8ke3llYXJ9YFxyXG5cclxuICAgICAgICAgICAgLy8gSW5jbHVkZSBnZW8gcGFydCBpZiBpdCdzIHNwZWNpZmllZCBhbmQgbm90ICdFVVInIG9yICdXT1JMRCdcclxuICAgICAgICAgICAgaWYgKGdlbyAmJiBnZW8gIT09ICdFVVInICYmIGdlbyAhPT0gJ1dPUkxEJykgcGF0aCArPSBgLyR7Z2VvfWBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBwcm9qZWN0aW9uXHJcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2dlbyA9PSAnV09STEQnID8gJzQzMjYnIDogcHJvan1gIC8vIHdvcmxkIGdlb2RhdGEgaXMgYWx3YXlzIDQzMjYsIHRoZW4gcmVwcm9qZWN0ZWRcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBzY2FsZSBvbmx5IGlmIG5vdCB1c2luZyBjZW50ZXIgcG9pbnRzXHJcbiAgICAgICAgICAgIGlmICghd2l0aENlbnRlciAmJiBzY2FsZSkgcGF0aCArPSBgLyR7c2NhbGV9YFxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBhcHByb3ByaWF0ZSBmaWxlIG5hbWVcclxuICAgICAgICAgICAgcGF0aCArPSBgLyR7d2l0aENlbnRlciA/ICdudXRzcHRfJyA6ICcnfSR7bGV2ZWx9Lmpzb25gXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnICYmIG1hcC5nZW9fICE9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIG51dHNMZXZlbHMuZm9yRWFjaCgobHZsKSA9PiBwcm9taXNlcy5wdXNoKGpzb24oYnVpbGRVcmwobWFwLm51dHMyanNvbkJhc2VVUkxfLCBtYXAubnV0c1llYXJfLCBtYXAuZ2VvXywgbWFwLnByb2pfLCBtYXAuc2NhbGVfLCBsdmwpKSkpXHJcbiAgICAgICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBudXRzTGV2ZWxzLmZvckVhY2goKGx2bCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGpzb24oYnVpbGRVcmwobWFwLm51dHMyanNvbkJhc2VVUkxfLCBtYXAubnV0c1llYXJfLCBtYXAuZ2VvXywgbWFwLnByb2pfLCBtYXAuc2NhbGVfLCBsdmwsIHRydWUpKSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobWFwLmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgY29uc3Qgd29ybGRNYXBUb3BvanNvblVSTCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS5pbmNsdWRlcygnZWMuZXVyb3BhLmV1JylcclxuICAgICAgICAgICAgICAgID8gJ2h0dHBzOi8vZWMuZXVyb3BhLmV1L2Fzc2V0cy9lc3RhdC9FL0U0L2dpc2NvL0lNQUdFL1dPUkxEXzQzMjYuanNvbidcclxuICAgICAgICAgICAgICAgIDogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldXJvc3RhdC9ldXJvc3RhdC1tYXAvbWFzdGVyL3NyYy9hc3NldHMvdG9wb2pzb24vV09STERfNDMyNi5qc29uJ1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGpzb24od29ybGRNYXBUb3BvanNvblVSTCkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChqc29uKGJ1aWxkVXJsKG1hcC5udXRzMmpzb25CYXNlVVJMXywgbWFwLm51dHNZZWFyXywgbWFwLmdlb18sIG1hcC5wcm9qXywgbWFwLnNjYWxlXywgbWFwLm51dHNMZXZlbF8pKSlcclxuICAgICAgICAgICAgaWYgKHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goanNvbihidWlsZFVybChtYXAubnV0czJqc29uQmFzZVVSTF8sIG1hcC5udXRzWWVhcl8sIG1hcC5nZW9fLCBtYXAucHJval8sIG1hcC5zY2FsZV8sIG1hcC5udXRzTGV2ZWxfLCB0cnVlKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9taXNlc1xyXG4gICAgfVxyXG4gICAgLyoqIENoZWNrcyBpZiBhbGwgZ2VvIGRhdGEgaXMgcmVhZHkgKi9cclxuICAgIG91dC5pc0dlb1JlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghb3V0LmRlZmF1bHRHZW9EYXRhICYmICFvdXQudXNlckdlb21ldHJpZXMpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICBsZXQgYWxsUmVhZHkgPSB0cnVlXHJcblxyXG4gICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMobWFwLmluc2V0VGVtcGxhdGVzXywgbnVsbCwgKGluc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaW5zZXQuR2VvbWV0cmllcy5pc0dlb1JlYWR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGFsbFJlYWR5ID0gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBhbGxSZWFkeVxyXG4gICAgfVxyXG5cclxuICAgIG91dC5zZXRVc2VyR2VvbWV0cmllcyA9IGZ1bmN0aW9uIChnZW9tZXRyaWVzKSB7XHJcbiAgICAgICAgdGhpcy51c2VyR2VvbWV0cmllcyA9IGdlb21ldHJpZXNcclxuXHJcbiAgICAgICAgLy8gZ2V0IHJlZ2lvbnMgdGhhdCBhcmUgbGlua2VkIHRvIHRoZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tZXRyeSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuc3RhdGlzdGljYWxSZWdpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY2FsUmVnaW9ucyA9IGdlb21ldHJ5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIG91dC5hZGREZWZhdWx0R2VvbWV0cmllc1RvTWFwID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgZHJhd0dyYXRpY3VsZSwgcGF0aEZ1bmN0aW9uLCBudXRzTGV2ZWwsIG51dHNZZWFyLCBnZW8sIHByb2osIHNjYWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMuZ3JhdGljdWxlICYmIGRyYXdHcmF0aWN1bGUpIHtcclxuICAgICAgICAgICAgLy9kcmF3IGdyYXRpY3VsZVxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZ3JhdGljdWxlJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy5ncmF0aWN1bGUpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBjb3VudHJ5IHJlZ2lvbnNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5jbnRyZykge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNudHJnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jbnRyZycpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMuY250cmcpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyB3b3JsZCBtYXBcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy53b3JsZHJnKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0td29ybGRyZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0td29ybGRyZycpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMud29ybGRyZylcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IE5VVFMgcmVnaW9uc1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLm51dHNyZykge1xyXG4gICAgICAgICAgICBpZiAobnV0c0xldmVsID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmcwID0gdGhpcy5nZW9KU09Ocy5udXRzcmdcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmcxID0gZmVhdHVyZShvdXQuYWxsTlVUU0dlb0RhdGFbMV0sIG91dC5hbGxOVVRTR2VvRGF0YVsxXS5vYmplY3RzLm51dHNyZykuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmcyID0gZmVhdHVyZShvdXQuYWxsTlVUU0dlb0RhdGFbMl0sIG91dC5hbGxOVVRTR2VvRGF0YVsyXS5vYmplY3RzLm51dHNyZykuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmczID0gZmVhdHVyZShvdXQuYWxsTlVUU0dlb0RhdGFbM10sIG91dC5hbGxOVVRTR2VvRGF0YVszXS5vYmplY3RzLm51dHNyZykuZmVhdHVyZXNcclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZvciBtaXhlZCBOVVRTLCB3ZSBhZGQgZXZlcnkgTlVUUyByZWdpb24gYWNyb3NzIGFsbCBsZXZlbHMgYW5kIGhpZGUgbGV2ZWwgMSwyLDMgYnkgZGVmYXVsdCwgb25seSBzaG93aW5nIHRoZW0gd2hlbiB0aGV5IGhhdmUgc3RhdCBkYXRhXHJcbiAgICAgICAgICAgICAgICAvLyBzZWUgdXBkYXRlQ2xhc3NpZmljYXRpb24gYW5kIHVwZGF0ZVN0eWxlIGluIG1hcC1jaG9yb3BsZXRoLmpzIGZvciBoaWRpbmcvc2hvd2luZ1xyXG4gICAgICAgICAgICAgICAgO1t0aGlzLmdlb0pTT05zLm1peGVkLnJnMCwgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzEsIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmcyLCB0aGlzLmdlb0pTT05zLm1peGVkLnJnM10uZm9yRWFjaCgociwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYXBwZW5kIGVhY2ggbnV0cyBsZXZlbCB0byBtYXBcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgZW0tbnV0c3JnIGVtLW51dHNyZy0ke2l9YClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2x2bCcsIGkpIC8vdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBudXRzIGxldmVsc1xyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAvL2FkZCBrb3Nvdm9cclxuICAgICAgICAgICAgICAgIGlmIChnZW8gPT0gJ0VVUicgJiYgKHByb2ogPT0gJzMwMzUnIHx8IHByb2ogPT0gJzQzMjYnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBrb3Nvdm8gbWFudWFsbHlcclxuICAgICAgICAgICAgICAgICAgICBhZGRLb3Nvdm9Cb3JkZXIoY29udGFpbmVyLCBwYXRoRnVuY3Rpb24sIHByb2osIHNjYWxlLCBudXRzWWVhcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gbnV0c0xldmVsIGlzIG5vdCAnbWl4ZWQnXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLm51dHNyZylcclxuICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgY291bnRyeSBib3VuZGFyaWVzXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMuY250Ym4pIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jbnRibicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY250Ym4nKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLmNudGJuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5ldSA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmVmdGEgPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5jYyA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLm90aCA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNvID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoYm4pID0+ICdlbS1ibi0nICsgYm4ucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc0xpc3QgPSBbXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5ldSA9PT0gJ1QnKSBjbGFzc0xpc3QucHVzaCgnZW0tYm4tZXUnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmVmdGEgPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLWVmdGEnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNjID09PSAnVCcpIGNsYXNzTGlzdC5wdXNoKCdlbS1ibi1jYycpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMub3RoID09PSAnVCcpIGNsYXNzTGlzdC5wdXNoKCdlbS1ibi1vdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNvID09PSAnVCcpIGNsYXNzTGlzdC5wdXNoKCdlbS1ibi1jbycpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc0xpc3Quam9pbignICcpIC8vIFVzZSBqb2luIHdpdGggYSBzcGFjZSB0byBjcmVhdGUgYSB2YWxpZCBjbGFzcyBzdHJpbmdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgTlVUUyBib3VuZGFyaWVzXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMubnV0c2JuICYmIG51dHNMZXZlbCAhPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICB0aGlzLmdlb0pTT05zLm51dHNibi5zb3J0KGZ1bmN0aW9uIChibjEsIGJuMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJuMi5wcm9wZXJ0aWVzLmx2bCAtIGJuMS5wcm9wZXJ0aWVzLmx2bFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLW51dHNibicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbnV0c2JuJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy5udXRzYm4pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5ldSA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmVmdGEgPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5jYyA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLm90aCA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLmNvID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9wcyA9IGJuLnByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICAvL0tPU09WT1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5pZCA+IDEwMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2VtLWtvc292by1ibidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmNvID09PSAnVCcpIHJldHVybiAnZW0tYm4tY28nXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2wgPSBbJ2VtLWJuLScgKyBwcm9wcy5sdmxdXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoYm4ub3RoID09PSBcIlRcIikgY2wucHVzaChcImJuLW90aFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2wuam9pbignICcpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IHdvcmxkIGJvdW5kYXJpZXNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy53b3JsZGJuKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0td29ybGRibicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0td29ybGRibicpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMud29ybGRibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuUE9MX1NUQVQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGlzcHV0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbS1ibi1kJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm4ucHJvcGVydGllcy5DT0FTX0ZMQUcgPT09ICdUJyA/ICdlbS1ibi1jbycgOiAnZW0td29ybGRibidcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vLmF0dHIoXCJpZFwiLCAoYm4pID0+IGJuLnByb3BlcnRpZXMuQ05UUl9CTl9JRClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLmtvc292bykge1xyXG4gICAgICAgICAgICAvL2FkZCBrb3Nvdm8gdG8gd29ybGQgbWFwc1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWtvc292by1ibicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0ta29zb3ZvLWJuJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy5rb3Nvdm8pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkS29zb3ZvQm9yZGVyKGNvbnRhaW5lciwgcGF0aEZ1bmN0aW9uLCBwcm9qLCBzY2FsZSwgbnV0c1llYXIpIHtcclxuICAgICAgICBsZXQga29zb3ZvRmVhdHVyZSA9IGtvc292b0JuRmVhdHVyZXNbbnV0c1llYXJdID8ga29zb3ZvQm5GZWF0dXJlc1tudXRzWWVhcl1bcHJval1bc2NhbGVdIDoga29zb3ZvQm5GZWF0dXJlc1syMDI0XVtwcm9qXVtzY2FsZV1cclxuICAgICAgICBsZXQga29zb3ZvQm4gPSBmZWF0dXJlKGtvc292b0ZlYXR1cmUsICdudXRzYm5fMScpLmZlYXR1cmVzXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnZW0ta29zb3ZvLWJuJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWtvc292by1ibiBlbS1ibi1jYycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0YShrb3Nvdm9CbilcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZHMgdXNlci1kZWZpbmVkIGdlb21ldHJpZXMgdG8gdGhlIG1hcFxyXG4gICAgICogRS5nLlxyXG4gICAgICogbWFwLmdlb21ldHJpZXMoW1xyXG4gICAgICogIHsgaWQ6ICdyZWdpb25zJywgZmVhdHVyZXM6IGdlb0pTT04uZmVhdHVyZXMsIGNsYXNzOiAoZmVhdHVyZSkgPT4gJ3JlZ2lvbicgfSxcclxuICAgICAqICB7IGlkOiAnYm9yZGVycycsIGZlYXR1cmVzOiBib3JkZXJzRGF0YSwgY2xhc3M6IChmZWF0dXJlKSA9PiAnYm9yZGVyJyB9XHJcbiAgICAgKiBdKVxyXG4gICAgICogQHBhcmFtIGdlb21ldHJpZXMgYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBjb250YWluaW5nIGFuIGFycmF5IG9mIGdlb0pTT04gZmVhdHVyZXNcclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgZDMgc2VsZWN0aW9uIG9mIHRoZSBwYXJlbnQgdGhhdCB3ZSBhcHBlbmQgdGhlIGdlb21ldHJpZXMgdG9cclxuICAgICAqIEBwYXJhbSBwYXRoRnVuY3Rpb24gZDMgcGF0aCBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICBvdXQuYWRkVXNlckdlb21ldHJpZXNUb01hcCA9IGZ1bmN0aW9uIChnZW9tZXRyaWVzLCBjb250YWluZXIsIHBhdGhGdW5jdGlvbikge1xyXG4gICAgICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbWV0cnkpID0+IHtcclxuICAgICAgICAgICAgbGV0IGdyb3VwID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIGdlb21ldHJ5LnN0YXRpc3RpY2FsUmVnaW9ucyA/ICdlbS11c2VyLXJlZ2lvbnMnIDogJycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBnZW9tZXRyeS5jbGFzcyA/IGdlb21ldHJ5LmNsYXNzIDogJycpXHJcblxyXG4gICAgICAgICAgICBsZXQgZWxlbWVudHMgPSBncm91cC5zZWxlY3RBbGwoJ3BhdGgnKS5kYXRhKGdlb21ldHJ5LmZlYXR1cmVzKS5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBjdXN0b20gY2FsbCBjaGFpbiBtb2RpZmljYXRpb25zIHRocm91Z2ggb25FYWNoXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2VvbWV0cnkub25FYWNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5vbkVhY2goZWxlbWVudHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IG1hcFRlbXBsYXRlIH0gZnJvbSAnLi9tYXAtdGVtcGxhdGUnXHJcblxyXG4vKipcclxuICogQnVpbGQgaW5zZXQgbWFwcyBmb3IgYSBtYXAgdGVtcGxhdGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBidWlsZEluc2V0cyA9IGZ1bmN0aW9uIChvdXQsIHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgIGlmICghb3V0Lmluc2V0Qm94UG9zaXRpb25fKSB7XHJcbiAgICAgICAgb3V0Lmluc2V0Qm94UG9zaXRpb25fID0gW291dC53aWR0aF8gLSBvdXQuaW5zZXRCb3hXaWR0aF8gLSAyICogb3V0Lmluc2V0Qm94UGFkZGluZ18sIDIgKiBvdXQuaW5zZXRCb3hQYWRkaW5nX11cclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGQgY29udGFpbmVyIHRvIGRyYXdpbmcgZ3JvdXBcclxuICAgIC8vIENhbm5vdCByZWFkIHByb3BlcnRpZXMgb2YgdW5kZWZpbmVkIChyZWFkaW5nICdzdmdJZCcpXHJcbiAgICBsZXQgc3ZnID0gc2VsZWN0KCcjJyArIG91dC5zdmdJZF8pXHJcbiAgICBsZXQgZHJhd2luZ0dyb3VwID0gc3ZnLnNlbGVjdCgnI2VtLWRyYXdpbmctJyArIG91dC5zdmdJZF8pXHJcbiAgICBjb25zdCBpbmcgPSBkcmF3aW5nR3JvdXBcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignaWQnLCAnZW0taW5zZXRzLWdyb3VwJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0taW5zZXRzJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgb3V0Lmluc2V0Qm94UG9zaXRpb25fWzBdICsgJywnICsgb3V0Lmluc2V0Qm94UG9zaXRpb25fWzFdICsgJyknKVxyXG5cclxuICAgIGlmIChvdXQuaW5zZXRzXyA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgLy9pZiBuZWVkZWQsIHVzZSBkZWZhdWx0IGluc2V0IGNvbmZpZ1xyXG4gICAgICAgIG91dC5pbnNldHNfID0gZGVmYXVsdEluc2V0Q29uZmlnKG91dC5pbnNldEJveFdpZHRoXywgb3V0Lmluc2V0Qm94UGFkZGluZ18pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXBwZW5kIGVhY2ggaW5zZXQgdG8gbWFwXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5pbnNldHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY29uZmlnID0gb3V0Lmluc2V0c19baV1cclxuICAgICAgICBjb25maWcuc3ZnSWQgPSBjb25maWcuc3ZnSWQgfHwgJ2luc2V0JyArIGNvbmZpZy5nZW8gKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNylcclxuXHJcbiAgICAgICAgLy9nZXQgc3ZnIGVsZW1lbnQuXHJcbiAgICAgICAgbGV0IHN2ZyA9IHNlbGVjdCgnIycgKyBjb25maWcuc3ZnSWQpXHJcbiAgICAgICAgaWYgKHN2Zy5zaXplKCkgPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgaXQgYXMgYW4gZW1iZWRlZCBTVkcgaWYgaXQgZG9lcyBub3QgZXhpc3RcclxuICAgICAgICAgICAgY29uc3QgeCA9IGNvbmZpZy54ID09IHVuZGVmaW5lZCA/IG91dC5pbnNldEJveFBhZGRpbmdfIDogY29uZmlnLnhcclxuICAgICAgICAgICAgY29uc3QgeSA9IGNvbmZpZy55ID09IHVuZGVmaW5lZCA/IG91dC5pbnNldEJveFBhZGRpbmdfICsgaSAqIChvdXQuaW5zZXRCb3hQYWRkaW5nXyArIG91dC5pbnNldEJveFdpZHRoXykgOiBjb25maWcueVxyXG4gICAgICAgICAgICBjb25zdCBnZ2VvID0gaW5nXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1pbnNldC0nICsgY29uZmlnLnN2Z0lkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWluc2V0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpJylcclxuICAgICAgICAgICAgZ2dlby5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2lkJywgY29uZmlnLnN2Z0lkKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYnVpbGQgaW5zZXRcclxuICAgICAgICAvLyBHSVNDTy0yNjc2IC0gUFQgYXpvcmVzIGluc2V0IGhhcyAyIGluc2V0cyB3aXRoIHRoZSBzYW1lIEdlbywgc28gc2Vjb25kIHdhcyBvdmVycmlkaW5nIGZpcnN0OlxyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfW2NvbmZpZy5nZW9dKSB7XHJcbiAgICAgICAgICAgIC8vaWYgaW5zZXQgYWxyZWFkeSBleGlzdHMgaW4gbWFwIHdpdGggc2FtZSBnZW8sIHRoZW4gcHVzaCBib3RoIHRvIGFuIGFycmF5XHJcbiAgICAgICAgICAgIGxldCBpbnNldCA9IGJ1aWxkSW5zZXQoY29uZmlnLCBvdXQsIHdpdGhDZW50ZXJQb2ludHMpXHJcbiAgICAgICAgICAgIGluc2V0LmJ1aWxkTWFwVGVtcGxhdGVCYXNlKClcclxuICAgICAgICAgICAgb3V0Lmluc2V0VGVtcGxhdGVzX1tjb25maWcuZ2VvXSA9IFtvdXQuaW5zZXRUZW1wbGF0ZXNfW2NvbmZpZy5nZW9dLCBpbnNldF1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgaW5zZXQgPSBidWlsZEluc2V0KGNvbmZpZywgb3V0LCB3aXRoQ2VudGVyUG9pbnRzKVxyXG4gICAgICAgICAgICBsZXQgZHJhd25JbnNldCA9IGluc2V0LmJ1aWxkTWFwVGVtcGxhdGVCYXNlKClcclxuICAgICAgICAgICAgb3V0Lmluc2V0VGVtcGxhdGVzX1tjb25maWcuZ2VvXSA9IGRyYXduSW5zZXRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKiogQnVpbGQgdGVtcGxhdGUgZm9yIGluc2V0LCBiYXNlZCBvbiBtYWluIG9uZSAqL1xyXG5jb25zdCBidWlsZEluc2V0ID0gZnVuY3Rpb24gKGNvbmZpZywgb3V0LCB3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAvL1RPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gZG8gdGhhdFxyXG5cclxuICAgIC8vY29weSBtYXBcclxuICAgIC8vZm9yKGxldCBrZXlfXyBpbiBtYXApIHtcclxuICAgIC8vbXRba2V5X19dID0gbWFwW2tleV9fXTtcclxuICAgIC8vfVxyXG5cclxuICAgIGNvbnN0IG10ID0gbWFwVGVtcGxhdGUoY29uZmlnLCB3aXRoQ2VudGVyUG9pbnRzKVxyXG5cclxuICAgIC8vZGVmaW5lIGRlZmF1bHQgdmFsdWVzIGZvciBpbnNldCBjb25maWdzXHJcbiAgICBjb25maWcgPSBjb25maWcgfHwge31cclxuICAgIGNvbmZpZy5wcm9qID0gY29uZmlnLnByb2ogfHwgX2RlZmF1bHRDUlNbY29uZmlnLmdlb11cclxuICAgIGNvbmZpZy5zY2FsZSA9IGNvbmZpZy5zY2FsZSB8fCBvdXQuaW5zZXRTY2FsZV9cclxuICAgIGNvbmZpZy5mb290bm90ZSA9IGNvbmZpZy5mb290bm90ZSB8fCAnJ1xyXG4gICAgY29uZmlnLnNob3dTb3VyY2VMaW5rID0gY29uZmlnLnNob3dTb3VyY2VMaW5rIHx8IGZhbHNlXHJcbiAgICBjb25maWcuem9vbUV4dGVudCA9IGNvbmZpZy56b29tRXh0ZW50IHx8IG91dC5pbnNldFpvb21FeHRlbnRfXHJcbiAgICBjb25maWcud2lkdGggPSBjb25maWcud2lkdGggfHwgb3V0Lmluc2V0Qm94V2lkdGhfXHJcbiAgICBjb25maWcuaGVpZ2h0ID0gY29uZmlnLmhlaWdodCB8fCBvdXQuaW5zZXRCb3hXaWR0aF9cclxuICAgIGNvbmZpZy5pbnNldHMgPSBjb25maWcuaW5zZXRzIHx8IFtdXHJcbiAgICBjb25maWcuaW5zZXRUZW1wbGF0ZXMgPSBjb25maWcuaW5zZXRUZW1wbGF0ZXMgfHwge31cclxuICAgIGNvbmZpZy5jYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFjayB8fCB1bmRlZmluZWRcclxuXHJcbiAgICAvL2NvcHkgdGVtcGxhdGUgYXR0cmlidXRlc1xyXG4gICAgO1tcclxuICAgICAgICAnbnV0c0xldmVsXycsXHJcbiAgICAgICAgJ251dHNZZWFyXycsXHJcbiAgICAgICAgJ2hvdmVyQ29sb3JfJyxcclxuICAgICAgICAvLydudXRzYm5TdHJva2VfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgIC8vICdudXRzYm5TdHJva2VXaWR0aF8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2NudHJnRmlsbFN0eWxlXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnY250Ym5TdHJva2VfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjbnRiblN0cm9rZVdpZHRoXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnc2VhRmlsbFN0eWxlXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnZHJhd0NvYXN0YWxNYXJnaW5fJyxcclxuICAgICAgICAnY29hc3RhbE1hcmdpbkNvbG9yXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnY29hc3RhbE1hcmdpbldpZHRoXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnY29hc3RhbE1hcmdpblN0ZERldl8nLFxyXG4gICAgICAgICdncmF0aWN1bGVTdHJva2VfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdncmF0aWN1bGVTdHJva2VXaWR0aF8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2xhYmVsbGluZ18nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2xhYmVsRmlsbF8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2xhYmVsVmFsdWVzRm9udFNpemVfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdsYWJlbE9wYWNpdHlfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdsYWJlbFN0cm9rZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2xhYmVsU3Ryb2tlV2lkdGhfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdsYWJlbFNoYWRvd1dpZHRoXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnbGFiZWxTaGFkb3dfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdsYWJlbFNoYWRvd0NvbG9yXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnbGFiZWxTaGFkb3dzVG9TaG93XycsXHJcbiAgICAgICAgJ2xhYmVsc1RvU2hvd18nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2ZvbnRGYW1pbHlfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdsZ18nLFxyXG4gICAgICAgICdwcm9qZWN0aW9uRnVuY3Rpb25fJyxcclxuICAgICAgICAnZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG10W2F0dF0gPSBvdXRbYXR0XVxyXG4gICAgfSlcclxuXHJcbiAgICAvL2NvcHkgc3RhdCBtYXAgYXR0cmlidXRlcy9tZXRob2RzXHJcbiAgICA7WydzdGF0JywgJ3N0YXREYXRhJywgJ2xlZ2VuZCcsICdsZWdlbmRPYmonLCAnbm9EYXRhVGV4dCcsICdsYW5ndWFnZScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndG9vbHRpcF8nLCAnY2xhc3NUb1RleHRfJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgbXRbYXR0XSA9IG91dFthdHRdXHJcbiAgICB9KVxyXG5cclxuICAgIC8vYXBwbHkgY29uZmlnIHZhbHVlcyBmb3IgaW5zZXRcclxuICAgIGZvciAobGV0IGtleSBpbiBjb25maWcpIG10W2tleSArICdfJ10gPSBjb25maWdba2V5XVxyXG5cclxuICAgIG10LmlzSW5zZXQgPSB0cnVlIC8vIGZsYWcgZm9yIGluc2V0LXNwZWNpZmljIHNldHRpbmdzIGUuZy4gQ1NTIGNsYXNzIGZvciB0aXRsZXNcclxuICAgIHJldHVybiBtdFxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGluc2V0cyBtYXBzIGZyb20gdGhlIERPTVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbW92ZUluc2V0cyA9IGZ1bmN0aW9uIChvdXQpIHtcclxuICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgZm9yIChsZXQgdGVtcGxhdGUgaW4gb3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBsZXQgaWQgPSBvdXQuaW5zZXRUZW1wbGF0ZXNfW3RlbXBsYXRlXS5zdmdJZF9cclxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nID0gc2VsZWN0KCcjJyArIGlkKVxyXG4gICAgICAgICAgICAvLyBpZiAoZXhpc3RpbmcpIGV4aXN0aW5nLnJlbW92ZSgpXHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZykgZXhpc3RpbmcuaHRtbCgnJykgLy8gZW1wdHkgdGhlbSwgYnV0IGRvbnQgcmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5pbnNldFRlbXBsYXRlc18gPSB7fSAvLyAgR0lTQ08tMjY3NlxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBpbnNldCBzZXR0aW5nLlxyXG4gKiBAcGFyYW0geyp9IHMgVGhlIHdpZHRoIG9mIHRoZSBpbnNldCBib3hcclxuICogQHBhcmFtIHsqfSBwIFRoZSBwYWRkaW5nXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0SW5zZXRDb25maWcgPSBmdW5jdGlvbiAocywgcCkge1xyXG4gICAgY29uc3Qgb3V0ID0gW1xyXG4gICAgICAgIHsgZ2VvOiAnSUMnLCB4OiAwLCB5OiAwLCB3aWR0aDogcywgaGVpZ2h0OiAwLjMgKiBzIH0sXHJcbiAgICAgICAgeyBnZW86ICdDQVJJQicsIHg6IDAsIHk6IDAuMyAqIHMgKyBwLCB3aWR0aDogMC41ICogcywgaGVpZ2h0OiBzIH0sXHJcbiAgICAgICAgeyBnZW86ICdHRicsIHg6IDAuNSAqIHMsIHk6IDAuMyAqIHMgKyBwLCB3aWR0aDogMC41ICogcywgaGVpZ2h0OiAwLjc1ICogcyB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnWVQnLFxyXG4gICAgICAgICAgICB4OiAwLjUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjA1ICogcyArIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnUkUnLFxyXG4gICAgICAgICAgICB4OiAwLjc1ICogcyxcclxuICAgICAgICAgICAgeTogMS4wNSAqIHMgKyBwLFxyXG4gICAgICAgICAgICB3aWR0aDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIGhlaWdodDogMC4yNSAqIHMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ1BUMjAnLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAxLjMgKiBzICsgMiAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjc1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnUFQzMCcsXHJcbiAgICAgICAgICAgIHg6IDAuNzUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjMgKiBzICsgMiAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgZ2VvOiAnTVQnLCB4OiAwLCB5OiAxLjU1ICogcyArIDMgKiBwLCB3aWR0aDogMC4yNSAqIHMsIGhlaWdodDogMC4yNSAqIHMgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ0xJJyxcclxuICAgICAgICAgICAgeDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuNTUgKiBzICsgMyAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnU0pfU1YnLFxyXG4gICAgICAgICAgICB4OiAwLjUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjU1ICogcyArIDMgKiBwLFxyXG4gICAgICAgICAgICB3aWR0aDogMC4yNSAqIHMsXHJcbiAgICAgICAgICAgIGhlaWdodDogMC4yNSAqIHMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdlbzogJ1NKX0pNJyxcclxuICAgICAgICAgICAgeDogMC43NSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuNTUgKiBzICsgMyAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qe2dlbzpcIklDXCIsIHg6MCwgeTowfSwge2dlbzpcIlJFXCIsIHg6ZGQsIHk6MH0sIHtnZW86XCJZVFwiLCB4OjIqZGQsIHk6MH0sXHJcblx0XHR7Z2VvOlwiR1BcIiwgeDowLCB5OmRkfSwge2dlbzpcIk1RXCIsIHg6ZGQsIHk6ZGR9LCB7Z2VvOlwiR0ZcIixzY2FsZTpcIjEwTVwiLCB4OjIqZGQsIHk6ZGR9LFxyXG5cdFx0e2dlbzpcIlBUMjBcIiwgeDowLCB5OjIqZGR9LCB7Z2VvOlwiUFQzMFwiLCB4OmRkLCB5OjIqZGR9LCB7Z2VvOlwiTVRcIiwgeDoyKmRkLCB5OjIqZGR9LFxyXG5cdFx0e2dlbzpcIkxJXCIsc2NhbGU6XCIwMU1cIiwgeDowLCB5OjMqZGR9LCB7Z2VvOlwiU0pfU1ZcIiwgeDpkZCwgeTozKmRkfSwge2dlbzpcIlNKX0pNXCIsc2NhbGU6XCIwMU1cIiwgeDoyKmRkLCB5OjMqZGR9LCovXHJcbiAgICAgICAgLy97Z2VvOlwiQ0FSSUJcIiwgeDowLCB5OjMzMH0sIHtnZW86XCJJU1wiLCB4OmRkLCB5OjMzMH1cclxuICAgIF1cclxuICAgIC8vaGlkZSBncmF0aWN1bGUgZm9yIGluc2V0c1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIG91dFtpXS5kcmF3R3JhdGljdWxlID0gZmFsc2VcclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqIERlZmF1bHQgQ1JTIGZvciBlYWNoIGdlbyBhcmVhICovXHJcbmNvbnN0IF9kZWZhdWx0Q1JTID0ge1xyXG4gICAgRVVSOiAnMzAzNScsXHJcbiAgICBJQzogJzMyNjI4JyxcclxuICAgIEdQOiAnMzI2MjAnLFxyXG4gICAgTVE6ICczMjYyMCcsXHJcbiAgICBHRjogJzMyNjIyJyxcclxuICAgIFJFOiAnMzI3NDAnLFxyXG4gICAgWVQ6ICczMjczOCcsXHJcbiAgICBNVDogJzMwMzUnLFxyXG4gICAgUFQyMDogJzMyNjI2JyxcclxuICAgIFBUMzA6ICczMjYyOCcsXHJcbiAgICBMSTogJzMwMzUnLFxyXG4gICAgSVM6ICczMDM1JyxcclxuICAgIFNKX1NWOiAnMzAzNScsXHJcbiAgICBTSl9KTTogJzMwMzUnLFxyXG4gICAgQ0FSSUI6ICczMjYyMCcsXHJcbiAgICBXT1JMRDogJzU0MDMwJyxcclxufVxyXG4iLCIvLyBtaXhlZCBudXRzIGRvbnQgZHJhdyBudXRzYm4gc28gd2UgYWRkIHRoZW0gbWFudWFsbHlcclxuZXhwb3J0IGNvbnN0IGtvc292b0JuRmVhdHVyZXMgPSB7XHJcbiAgMjAyMTp7XHJcbiAgICAzMDM1OiB7XHJcbiAgICAgICcwM00nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMzA2MSwxMzAzXSxbLTE1MiwtNTldLFstMzIsLTY2XSxbLTY1LDcyXSxbLTk2LDddLFstMTYsNTldLFstNjQsMTldLFstNTYsLTM5XSxbLTEyMCwzOV0sWy0xODQsLTE5XSxbLTE2LDI2XSxbMzIsNTJdLFstMTYsNzJdLFsyNCw0MF0sWzgsMTgzXV0sW1syODg1LDBdLFstOCw0Nl0sWy02NSw4NV0sWy00MCwtN10sWy00MCw0MF0sWzAsMTExXSxbODAsMTNdLFsyNSw0Nl0sWzcyLDEzXSxbNDAsOThdLFstNTYsMTE4XSxbMTQ0LDE5Nl0sWy0yNCw3OV0sWzg4LDU5XSxbLTI0LDk4XSxbLTgsMjBdLFsyNCwzOV0sWzgsNTJdLFs0OCw3Ml0sWy04OCwxMjVdXSxbWzgyNSwyNjM4XSxbLTExMiwtOThdLFstNzIsLTddLFstODgsLTExOF0sWy0xNzYsLTM5XSxbNTYsLTkxXSxbODgsLTMzXSxbMjQsLTUzXSxbNTYsLTM5XSxbMjQsLTkxXSxbLTU2LC00Nl0sWzI0LC0xMDVdLFstNTYsLTkyXSxbLTEwNCwwXSxbLTQ4LC0xMDRdLFstMTYsLTQwXSxbLTU3LDddLFstNDAsLTUzXSxbLTE2LC03OF0sWzExMywtMTE4XSxbLTk3LC02NV0sWy04OCwtOTldLFstODAsMjBdLFstODAsLTM5XSxbLTI0LC0xM11dLFtbMTA5OCwyMzA0XSxbLTE5Myw2Nl0sWzI0LDM5XSxbLTE2LDM5XSxbNjUsMTNdLFswLDMzXSxbLTY1LDc5XSxbLTg4LDY1XV0sW1syMzA4LDE2ODldLFstMTUzLC0yMF0sWy02NCw1OV0sWy00MCw3XSxbLTk2LC0yN10sWy0xMDQsMTM4XSxbLTgsOTJdLFstMzIsNzhdLFstNjQsMjZdLFstMzIsLTU5XSxbLTI0LDBdLFstNTYsODZdLFstNDAsMTM3XSxbLTI1LDY1XSxbLTU2LDBdLFstNTYsNDZdLFstNjQsLTcyXSxbLTEyMCw1M10sWy04OCwtNDBdLFstODgsNDZdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlszNy43NjEwNDQ3NTI3Nzc1NjUsMzguNTQ3MzQyMDU2MjYxMTNdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDUsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcxME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbOTYyLDBdLFstMjksNzVdLFs0OCwxMzFdLFsyMSwzNV0sWzExLDM4XSxbMzIsMTE3XSxbLTI0LDQ0XV0sW1sxMDIxLDQ0MF0sWy02NCwtMjldLFstNzAsMzZdLFstMTIwLDJdLFszLDEyMV1dLFtbNzcwLDU3MF0sWy0xMjYsMTZdLFstNDAsOTFdLFstNDUsNF0sWy01MSw5M10sWy0xNDIsNF1dLFtbMjc1LDg5MV0sWy0xMzEsLTk5XSxbMzAsLTM2XSxbMjQsLTMxXSxbLTYsLTg2XSxbLTk4LC04Nl0sWzEzLC02NF0sWy0yNywtMzhdLFstODAsLTMxXV0sW1szNjYsNzc4XSxbLTM3LDIyXSxbLTU0LDkxXV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMTEzLjIwOTk0NDg1MTMwOTcsMTE0LjEyNzgyMDgxMzAzODAxXSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnMjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzUzNiwwXSxbLTI0LDQ1XSxbMTUsMzBdLFs0NSw5Ml0sWy0xLDQ0XSxbLTIsMzddXSxbWzU2OSwyNDhdLFstMTMwLDldLFstMTAsNjRdXSxbWzQyOSwzMjFdLFstNjQsMTBdLFstNzgsOTRdLFstODMsMTNdXSxbWzE1Myw1MDJdLFstNzMsLTUxXSxbMjYsLTg0XSxbLTQ4LC01M10sWy0zLC01Ml0sWy01NSwtMjVdXSxbWzIwNCw0MzhdLFstNTEsNjRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsyMDMuMTIzMDk2MDE0OTQxMjQsMjAyLjU2NTUxNDYzMDMxMjQ2XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnNjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzMxMCwxMzhdLFstMzYsLTJdLFstNDAsNDJdXSxbWzIzNCwxNzhdLFstMTIzLDY1XV0sW1s4NCwyNzhdLFstODQsLTE0N11dLFtbMTExLDI0M10sWy0yNywzNV1dLFtbMjkyLDBdLFsxOCwxMzhdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlszNzIuODQyODE3MzAyMTU2MzMsMzY0Ljg3NjExODk4NTgwNTM2XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNCxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAzLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDEsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMixcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA1LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX1dfX19XHJcbiAgICB9LFxyXG4gICAgNDMyNjoge1xyXG4gICAgICAnMDNNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzE5MDAsMTI3NV0sWy0zMCwyN10sWy0yNywtMTNdLFstMzQsMjNdLFstODcsNl0sWzI1LDU5XSxbMSw3MF0sWzIwLDM0XSxbMjQsMTY3XV0sW1sxNzkyLDE2NDhdLFstMTE2LDFdLFstNjIsNzddLFstODksLThdLFstNjAsMTQ4XSxbNyw4Nl0sWy00LDE1XSxbLTEzLDYwXSxbLTQ1LDI4XSxbLTMzLC00OF0sWy0yNiw0XSxbLTMxLDE0Ml0sWy0xMSw1M10sWzUsNDNdLFstMTksNDRdLFstMzksOF0sWy00MCw0OV0sWy01MiwtNTldLFstOTMsNzFdLFstMzgsLTZdLFstMTYsLTI2XV0sW1s5NDUsMjM4OF0sWy01NCwyN10sWy0yMCwyOF0sWy0yMiwtM10sWy0xNywyMl0sWy0yNSwxXSxbLTEwLDEwXSxbNCwxN10sWzI3LDE0XSxbLTE1LDI5XSxbMSwxNl0sWzY4LDFdLFstOCwxNl0sWy01LDMwXSxbLTE0LDI5XSxbLTI3LDQyXSxbLTI1LDIyXSxbLTMwLDQxXV0sW1s3NzMsMjczMF0sWy04OSwtNjldLFstNjQsLTRdLFstODIsLTkyXSxbLTEzMywtMTVdLFsyNywtOTNdLFs2NCwtNDNdLFsxNiwtNTBdLFszOCwtNDRdLFs5LC03NV0sWy00OCwtNTFdLFs1LC00MV0sWzYsLTUwXSxbLTUyLC04NF0sWy03OCwxNF0sWy0zNSwtNjZdLFstMzMsLTYxXSxbLTQ1LDExXSxbLTM1LC00Ml0sWy0xOCwtNzJdLFszMywtNzFdLFs0OCwtNTVdXSxbWzEwMTcsMjMzMF0sWy03Miw1OF1dLFtbMzA3LDE2NzddLFstMzYsLTEyXSxbLTI1LC0yMV0sWy0yNiwtMTBdLFstNzYsLTkwXSxbLTE3LDRdLFstMzAsMzFdLFstNTIsLTE0XSxbLTI2LC0yM10sWy0xOSwxXV0sW1syMzE5LDExODVdLFstMTE2LC0zMl0sWy0zOSwtNTJdLFstNDIsNzBdLFstNjgsMjNdLFstMTIsNThdLFstNDMsMjNdLFstNDIsLTIzXSxbLTU3LDIzXV0sW1syMDQ0LDBdLFstNCw0M10sWy0zOCw4Ml0sWy0zNCw5XSxbLTI0LDQzXSxbMTMsOTddLFs2MSw0XSxbMzIsNDFdLFs0OSwwXSxbMzcsODJdLFstMjYsMTE4XSxbMTMwLDE2N10sWy04LDczXSxbNzQsNDZdLFstMiwxOF0sWy05LDkyXSxbMjQsMzVdLFs3LDQ5XSxbNDgsNTJdLFstNTUsMTM0XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDA2MDM4MzM5MjgzOTA4OTc0LDAuMDAwMzY5ODM0NzU1Njc3NjU5NzVdLFwidHJhbnNsYXRlXCI6WzIwLjM1MjkyODM5MzAwMDA3LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19LFxyXG4gICAgICAnMTBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzY1OSw0MzldLFstNTQsMTddLFsxNywxMTFdXSxbWzYyMiw1NjddLFstOTMsMzFdLFstMjUsOTJdLFstMzYsMTFdLFstMjksOTddLFstMjMsMV0sWy02MywzXV0sW1szMjgsODIyXSxbLTMzLDc0XSxbLTI3LDQ0XV0sW1syNjgsOTQwXSxbLTcyLC00NF0sWy0zOCwtMzFdLFsyNywtODZdLFstMTQsLTY1XSxbLTgxLC03OF0sWzE2LC01OF1dLFtbMzUzLDgwMl0sWy0yNSwyMF1dLFtbMTA2LDU3OF0sWy00MSwtMTldLFstNjUsLTI4XV0sW1s4MDUsNDA4XSxbLTU0LC0yMV0sWy05Miw1Ml1dLFtbNzA5LDBdLFstMjIsNzJdLFswLDE3XSxbNDAsMzZdLFsxOCw2N10sWzUzLDEwMV0sWzE2LDY0XSxbLTksNTFdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwMTc0MDUyMTU0NzkxMTUyNCwwLjAwMTA3NDA5NDU1NjM4Mjk5MDddLFwidHJhbnNsYXRlXCI6WzIwLjM1MjkyODM5MzAwMDA3LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19LFxyXG4gICAgICAnMjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzM4MCwyNTJdLFstMjEsMjZdLFswLDQ4XV0sW1szNTksMzI2XSxbLTQ5LDE3XSxbLTU2LDEwN10sWy01MSwxMV1dLFtbMTg5LDQ3Ml0sWy0zNCw2OF1dLFtbMTU1LDU0MF0sWy02NiwtMzldLFsxOCwtNjZdLFstNTQsLTY4XSxbOCwtMzVdXSxbWzYxLDMzMl0sWy0yMSwtMTNdLFstMTAsLTEyXSxbLTEzLDVdLFstMTcsLTddXSxbWzQ2NCwyMzRdLFstODQsMThdXSxbWzQwOSwwXSxbLTE0LDQ2XSxbNjEsMTEwXSxbOCw3OF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAzMDE4Mjc2ODMxODk2NDk4LDAuMDAxODY5NzIwMTUzNzAzNzI0NV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDcsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX0sXHJcbiAgICAgICc2ME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMjM1LDE1Nl0sWy0xMyw0Nl1dLFtbMjIyLDIwMl0sWy05Niw4NF1dLFtbMTE3LDI5M10sWy0yMSw0Ml1dLFtbOTYsMzM1XSxbLTU4LC0xMjldXSxbWzEyNiwyODZdLFstOSw3XV0sW1szOCwyMDZdLFstMzgsLTE3XV0sW1syODcsMTQ1XSxbLTUyLDExXV0sW1syNTMsMF0sWzM0LDE0NV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDA0ODc5NzIyODIyMjk5NTY0LDAuMDAzMDEzODc3MjYyNjg2NjAwNl0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDc0LDQyLjI2MjgxNzY0MzAwMDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDIsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDMsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDQsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDUsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDYsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDEsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDcsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcImx2bFwiOjAsXCJpZFwiOjEwMDAwMDgsXCJjb1wiOlwiRlwiLFwib3RoXCI6XCJGXCIsfX1dfX19XHJcbiAgICB9XHJcbiAgfSxcclxuICAyMDI0OntcclxuICAgIDMwMzU6IHtcclxuICAgICAgJzAzTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1szMDYxLDEzMDNdLFstMTUyLC01OV0sWy0zMiwtNjZdLFstNjUsNzJdLFstOTYsN10sWy0xNiw1OV0sWy02NCwxOV0sWy01NiwtMzldLFstMTIwLDM5XSxbLTE4NCwtMTldLFstMTYsMjZdLFszMiw1Ml0sWy0xNiw3Ml0sWzI0LDQwXSxbOCwxODNdXSxbWzI4ODUsMF0sWy04LDQ2XSxbLTY1LDg1XSxbLTQwLC03XSxbLTQwLDQwXSxbMCwxMTFdLFs4MCwxM10sWzI1LDQ2XSxbNzIsMTNdLFs0MCw5OF0sWy01NiwxMThdLFsxNDQsMTk2XSxbLTI0LDc5XSxbODgsNTldLFstMjQsOThdLFstOCwyMF0sWzI0LDM5XSxbOCw1Ml0sWzQ4LDcyXSxbLTg4LDEyNV1dLFtbODI1LDI2MzhdLFstMTEyLC05OF0sWy03MiwtN10sWy04OCwtMTE4XSxbLTE3NiwtMzldLFs1NiwtOTFdLFs4OCwtMzNdLFsyNCwtNTNdLFs1NiwtMzldLFsyNCwtOTFdLFstNTYsLTQ2XSxbMjQsLTEwNV0sWy01NiwtOTJdLFstMTA0LDBdLFstNDgsLTEwNF0sWy0xNiwtNDBdLFstNTcsN10sWy00MCwtNTNdLFstMTYsLTc4XSxbMTEzLC0xMThdLFstOTcsLTY1XSxbLTg4LC05OV0sWy04MCwyMF0sWy04MCwtMzldLFstMjQsLTEzXV0sW1sxMDk4LDIzMDRdLFstMTkzLDY2XSxbMjQsMzldLFstMTYsMzldLFs2NSwxM10sWzAsMzNdLFstNjUsNzldLFstODgsNjVdXSxbWzIzMDgsMTY4OV0sWy0xNTMsLTIwXSxbLTY0LDU5XSxbLTQwLDddLFstOTYsLTI3XSxbLTEwNCwxMzhdLFstOCw5Ml0sWy0zMiw3OF0sWy02NCwyNl0sWy0zMiwtNTldLFstMjQsMF0sWy01Niw4Nl0sWy00MCwxMzddLFstMjUsNjVdLFstNTYsMF0sWy01Niw0Nl0sWy02NCwtNzJdLFstMTIwLDUzXSxbLTg4LC00MF0sWy04OCw0Nl1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzM3Ljc2MTA0NDc1Mjc3NzU2NSwzOC41NDczNDIwNTYyNjExM10sXCJ0cmFuc2xhdGVcIjpbNTE2NzAyMC4wMzc0NTE4NzMsMjIwMjI3OC41MTAzMjU1MTY2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDQsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAxLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDIsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMyxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzEwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1s5NjIsMF0sWy0yOSw3NV0sWzQ4LDEzMV0sWzIxLDM1XSxbMTEsMzhdLFszMiwxMTddLFstMjQsNDRdXSxbWzEwMjEsNDQwXSxbLTY0LC0yOV0sWy03MCwzNl0sWy0xMjAsMl0sWzMsMTIxXV0sW1s3NzAsNTcwXSxbLTEyNiwxNl0sWy00MCw5MV0sWy00NSw0XSxbLTUxLDkzXSxbLTE0Miw0XV0sW1syNzUsODkxXSxbLTEzMSwtOTldLFszMCwtMzZdLFsyNCwtMzFdLFstNiwtODZdLFstOTgsLTg2XSxbMTMsLTY0XSxbLTI3LC0zOF0sWy04MCwtMzFdXSxbWzM2Niw3NzhdLFstMzcsMjJdLFstNTQsOTFdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsxMTMuMjA5OTQ0ODUxMzA5NywxMTQuMTI3ODIwODEzMDM4MDFdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA1LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDQsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMyxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAxLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDIsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcyME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbNTM2LDBdLFstMjQsNDVdLFsxNSwzMF0sWzQ1LDkyXSxbLTEsNDRdLFstMiwzN11dLFtbNTY5LDI0OF0sWy0xMzAsOV0sWy0xMCw2NF1dLFtbNDI5LDMyMV0sWy02NCwxMF0sWy03OCw5NF0sWy04MywxM11dLFtbMTUzLDUwMl0sWy03MywtNTFdLFsyNiwtODRdLFstNDgsLTUzXSxbLTMsLTUyXSxbLTU1LC0yNV1dLFtbMjA0LDQzOF0sWy01MSw2NF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzIwMy4xMjMwOTYwMTQ5NDEyNCwyMDIuNTY1NTE0NjMwMzEyNDZdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA1LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDQsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMyxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAxLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDIsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICc2ME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMzEwLDEzOF0sWy0zNiwtMl0sWy00MCw0Ml1dLFtbMjM0LDE3OF0sWy0xMjMsNjVdXSxbWzg0LDI3OF0sWy04NCwtMTQ3XV0sW1sxMTEsMjQzXSxbLTI3LDM1XV0sW1syOTIsMF0sWzE4LDEzOF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzM3Mi44NDI4MTczMDIxNTYzMywzNjQuODc2MTE4OTg1ODA1MzZdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDUsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fV19fX1cclxuICAgIH0sXHJcbiAgICA0MzI2OiB7XHJcbiAgICAgICcwM00nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMTkwMCwxMjc1XSxbLTMwLDI3XSxbLTI3LC0xM10sWy0zNCwyM10sWy04Nyw2XSxbMjUsNTldLFsxLDcwXSxbMjAsMzRdLFsyNCwxNjddXSxbWzE3OTIsMTY0OF0sWy0xMTYsMV0sWy02Miw3N10sWy04OSwtOF0sWy02MCwxNDhdLFs3LDg2XSxbLTQsMTVdLFstMTMsNjBdLFstNDUsMjhdLFstMzMsLTQ4XSxbLTI2LDRdLFstMzEsMTQyXSxbLTExLDUzXSxbNSw0M10sWy0xOSw0NF0sWy0zOSw4XSxbLTQwLDQ5XSxbLTUyLC01OV0sWy05Myw3MV0sWy0zOCwtNl0sWy0xNiwtMjZdXSxbWzk0NSwyMzg4XSxbLTU0LDI3XSxbLTIwLDI4XSxbLTIyLC0zXSxbLTE3LDIyXSxbLTI1LDFdLFstMTAsMTBdLFs0LDE3XSxbMjcsMTRdLFstMTUsMjldLFsxLDE2XSxbNjgsMV0sWy04LDE2XSxbLTUsMzBdLFstMTQsMjldLFstMjcsNDJdLFstMjUsMjJdLFstMzAsNDFdXSxbWzc3MywyNzMwXSxbLTg5LC02OV0sWy02NCwtNF0sWy04MiwtOTJdLFstMTMzLC0xNV0sWzI3LC05M10sWzY0LC00M10sWzE2LC01MF0sWzM4LC00NF0sWzksLTc1XSxbLTQ4LC01MV0sWzUsLTQxXSxbNiwtNTBdLFstNTIsLTg0XSxbLTc4LDE0XSxbLTM1LC02Nl0sWy0zMywtNjFdLFstNDUsMTFdLFstMzUsLTQyXSxbLTE4LC03Ml0sWzMzLC03MV0sWzQ4LC01NV1dLFtbMTAxNywyMzMwXSxbLTcyLDU4XV0sW1szMDcsMTY3N10sWy0zNiwtMTJdLFstMjUsLTIxXSxbLTI2LC0xMF0sWy03NiwtOTBdLFstMTcsNF0sWy0zMCwzMV0sWy01MiwtMTRdLFstMjYsLTIzXSxbLTE5LDFdXSxbWzIzMTksMTE4NV0sWy0xMTYsLTMyXSxbLTM5LC01Ml0sWy00Miw3MF0sWy02OCwyM10sWy0xMiw1OF0sWy00MywyM10sWy00MiwtMjNdLFstNTcsMjNdXSxbWzIwNDQsMF0sWy00LDQzXSxbLTM4LDgyXSxbLTM0LDldLFstMjQsNDNdLFsxMyw5N10sWzYxLDRdLFszMiw0MV0sWzQ5LDBdLFszNyw4Ml0sWy0yNiwxMThdLFsxMzAsMTY3XSxbLTgsNzNdLFs3NCw0Nl0sWy0yLDE4XSxbLTksOTJdLFsyNCwzNV0sWzcsNDldLFs0OCw1Ml0sWy01NSwxMzRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwMDYwMzgzMzkyODM5MDg5NzQsMC4wMDAzNjk4MzQ3NTU2Nzc2NTk3NV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDcsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX0sXHJcbiAgICAgICcxME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbNjU5LDQzOV0sWy01NCwxN10sWzE3LDExMV1dLFtbNjIyLDU2N10sWy05MywzMV0sWy0yNSw5Ml0sWy0zNiwxMV0sWy0yOSw5N10sWy0yMywxXSxbLTYzLDNdXSxbWzMyOCw4MjJdLFstMzMsNzRdLFstMjcsNDRdXSxbWzI2OCw5NDBdLFstNzIsLTQ0XSxbLTM4LC0zMV0sWzI3LC04Nl0sWy0xNCwtNjVdLFstODEsLTc4XSxbMTYsLTU4XV0sW1szNTMsODAyXSxbLTI1LDIwXV0sW1sxMDYsNTc4XSxbLTQxLC0xOV0sWy02NSwtMjhdXSxbWzgwNSw0MDhdLFstNTQsLTIxXSxbLTkyLDUyXV0sW1s3MDksMF0sWy0yMiw3Ml0sWzAsMTddLFs0MCwzNl0sWzE4LDY3XSxbNTMsMTAxXSxbMTYsNjRdLFstOSw1MV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAxNzQwNTIxNTQ3OTExNTI0LDAuMDAxMDc0MDk0NTU2MzgyOTkwN10sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDcsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX0sXHJcbiAgICAgICcyME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMzgwLDI1Ml0sWy0yMSwyNl0sWzAsNDhdXSxbWzM1OSwzMjZdLFstNDksMTddLFstNTYsMTA3XSxbLTUxLDExXV0sW1sxODksNDcyXSxbLTM0LDY4XV0sW1sxNTUsNTQwXSxbLTY2LC0zOV0sWzE4LC02Nl0sWy01NCwtNjhdLFs4LC0zNV1dLFtbNjEsMzMyXSxbLTIxLC0xM10sWy0xMCwtMTJdLFstMTMsNV0sWy0xNywtN11dLFtbNDY0LDIzNF0sWy04NCwxOF1dLFtbNDA5LDBdLFstMTQsNDZdLFs2MSwxMTBdLFs4LDc4XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDMwMTgyNzY4MzE4OTY0OTgsMC4wMDE4Njk3MjAxNTM3MDM3MjQ1XSxcInRyYW5zbGF0ZVwiOlsyMC4zNTI5MjgzOTMwMDAwNyw0Mi4yNjI4MTc2NDMwMDAwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDAyLFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDAzLFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA0LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA1LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA3LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDAxLFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA4LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19XX19fSxcclxuICAgICAgJzYwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1syMzUsMTU2XSxbLTEzLDQ2XV0sW1syMjIsMjAyXSxbLTk2LDg0XV0sW1sxMTcsMjkzXSxbLTIxLDQyXV0sW1s5NiwzMzVdLFstNTgsLTEyOV1dLFtbMTI2LDI4Nl0sWy05LDddXSxbWzM4LDIwNl0sWy0zOCwtMTddXSxbWzI4NywxNDVdLFstNTIsMTFdXSxbWzI1MywwXSxbMzQsMTQ1XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDQ4Nzk3MjI4MjIyOTk1NjQsMC4wMDMwMTM4NzcyNjI2ODY2MDA2XSxcInRyYW5zbGF0ZVwiOlsyMC4zNTI5MjgzOTMwMDAwNzQsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX1cclxuICAgIH1cclxuICB9XHJcbn0iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciwgZXhlY3V0ZUZvckFsbEluc2V0cyB9IGZyb20gJy4vdXRpbHMnXHJcblxyXG4vLyBoYW5kbGVzIGFsbCBtYXAgbGFiZWxzIGUuZy4gc3RhdCB2YWx1ZXMsIG9yIGxhYmVscyBzcGVjaWZpZWQgaW4gbWFwLmxhYmVscyh7bGFiZWxzOlt0ZXh0OidteUxhYmVsJywgeDoxMjMsIHk6IDEyM119KVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBhZGRMYWJlbHNUb01hcFxyXG4gKiBAcGFyYW0gbWFwIGV1cm9zdGF0bWFwIG1hcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gemcgem9vbWdyb3VwIChkMyBzZWxlY3Rpb24gb2Ygem9vbWFibGUgZWxlbWVudHMpXHJcbiAqIEBkZXNjcmlwdGlvbiBhcHBlbmRzIHRleHQgbGFiZWxzIHRvIHRoZSBtYXAuIExhYmVscyBjYW4gYmUgY291bnRyaWVzLCBjb3VudHJ5IGNvZGVzLCBvY2VhbiBuYW1lcyBvciBzdGF0aXN0aWNhbCB2YWx1ZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBhZGRMYWJlbHNUb01hcCA9IGZ1bmN0aW9uIChtYXAsIHpnKSB7XHJcbiAgICAvLyBzZXQgZGVmYXVsdHNcclxuICAgIGlmICghbWFwLmxhYmVsc18uY29uZmlnKSBtYXAubGFiZWxzXy5jb25maWcgPSBERUZBVUxUTEFCRUxTXHJcbiAgICBpZiAoIW1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnMpIG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnMgPSBERUZBVUxUU1RBVExBQkVMUE9TSVRJT05TXHJcblxyXG4gICAgLy8gY2xlYXIgZXhpc3Rpbmcgb3IgYXBwZW5kIG5ldyBjb250YWluZXJcclxuICAgIGxldCBleGlzdGluZyA9IHpnLnNlbGVjdCgnI2VtLWxhYmVscycpXHJcbiAgICBsZXQgbGFiZWxzQ29udGFpbmVyID0gZXhpc3RpbmcuZW1wdHkoKSA/IHpnLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLWxhYmVscycpIDogZXhpc3RpbmdcclxuXHJcbiAgICAvL2ZvciBzdGF0aXN0aWNhbCB2YWx1ZXMgb24gbWFwcyB3aXRob3V0IGNlbnRyb2lkcywgd2UgbmVlZCB0byBhZGQgY2VudHJvaWRzIGluaXRpYWxseSwgdGhlbiBhZGQgdGV4dCB0byB0aGVtIGxhdGVyIG9uY2UgdGhlIHN0YXQgZGF0YSBpcyBsb2FkZWRcclxuICAgIGlmIChtYXAubGFiZWxzXz8udmFsdWVzICYmIG1hcC5fbWFwVHlwZSAhPT0gJ3BzJykgYXBwZW5kU3RhdExhYmVsQ2VudHJvaWRzVG9NYXAobWFwLCBsYWJlbHNDb250YWluZXIpXHJcblxyXG4gICAgLy8gZ2V0IGxhYmVscyBhcnJheVxyXG4gICAgbGV0IGxhYmVsc0FycmF5ID0gbWFwLmxhYmVsc18/LmxhYmVscyB8fCBERUZBVUxUTEFCRUxTW2Ake21hcC5nZW99XyR7bWFwLnByb2pffS5jY2BdXHJcblxyXG4gICAgLy8gYXBwZW5kIG90aGVyIGxhYmVscyB0byBtYXBcclxuICAgIGlmIChsYWJlbHNBcnJheSkge1xyXG4gICAgICAgIC8vY29tbW9uIHN0eWxlcyBiZXR3ZWVuIGFsbCBsYWJlbCBzaGFkb3dzXHJcbiAgICAgICAgY29uc3Qgc2hhZG93ZyA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1zaGFkb3dzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAgICAgLy9jb21tb24gc3R5bGVzIGJldHdlZW4gYWxsIGxhYmVsc1xyXG4gICAgICAgIGNvbnN0IGxhYmVsZyA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sYWJlbHMnKS5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG5cclxuICAgICAgICAvL1NIQURPV1NcclxuICAgICAgICBpZiAobWFwLmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICAgICAgbGV0IHNoYWRvd3MgPSBzaGFkb3dnXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGxhYmVsc0FycmF5KVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+ICdlbS1sYWJlbC1zaGFkb3ctJyArIGQudGV4dC5yZXBsYWNlKC9cXHMrL2csICctJykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAoZCkgPT4gJ2VtLWxhYmVsLXNoYWRvdyBlbS1sYWJlbC1zaGFkb3ctJyArIGQuY2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQucm90YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8vZm9yIHJvdGF0ZWQgdGV4dCwgeCBhbmQgeSBwb3NpdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pWzBdXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvL2ZvciByb3RhdGVkIHRleHQsIHggYW5kIHkgcG9zaXRpb25zIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVsxXVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIC03KSAvLyBzZXQgeSBwb3NpdGlvbiBvZiBib3R0b20gb2YgdGV4dFxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQucm90YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBwb3NbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBwb3NbMV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwke3l9KSByb3RhdGUoJHtkLnJvdGF0ZX0pYFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncm90YXRlKDApJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnRleHRcclxuICAgICAgICAgICAgICAgIH0pIC8vIGRlZmluZSB0aGUgdGV4dCB0byBkaXNwbGF5XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0xBQkVMIHRleHRzXHJcbiAgICAgICAgbGFiZWxnXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAuZGF0YShsYWJlbHNBcnJheSlcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAnZW0tbGFiZWwtJyArIGQudGV4dC5yZXBsYWNlKC9cXHMrL2csICctJykpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnZW0tbGFiZWwgZW0tbGFiZWwtJyArIGQuY2xhc3MpXHJcbiAgICAgICAgICAgIC8vcG9zaXRpb24gbGFiZWxcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQucm90YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLy9mb3Igcm90YXRlZCB0ZXh0LCB4IGFuZCB5IHBvc2l0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgdHJhbnNmb3JtIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pWzBdXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8vZm9yIHJvdGF0ZWQgdGV4dCwgeCBhbmQgeSBwb3NpdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVsxXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAtNykgLy8gc2V0IHkgcG9zaXRpb24gb2YgYm90dG9tIG9mIHRleHRcclxuICAgICAgICAgICAgLy90cmFuc2Zvcm0gbGFiZWxzIHdoaWNoIGhhdmUgYSBcInJvdGF0ZVwiIHByb3BlcnR5IGluIHRoZSBsYWJlbHMgY29uZmlnLiBGb3Igcm90YXRlZCBsYWJlbHMsIHRoZWlyIFgsWSBtdXN0IGFsc28gYmUgc2V0IGluIHRoZSB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIC8vIG5vdGU6IGRvbnQgYXBwbHkgdG8gY291bnRyeSBjb2RlIGxhYmVsc1xyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHBvc1swXVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB5ID0gcG9zWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwke3l9KSByb3RhdGUoJHtkLnJvdGF0ZX0pYFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSgwKSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRleHRcclxuICAgICAgICAgICAgfSkgLy8gZGVmaW5lIHRoZSB0ZXh0IHRvIGRpc3BsYXlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiB1cGRhdGVMYWJlbHNcclxuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSBleGlzdGluZyBtYXAgbGFiZWxzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXBkYXRlTGFiZWxzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgbGFiZWxzXHJcbiAgICAgICAgbGV0IHByZXZMYWJlbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJyNlbS1sYWJlbHMgPiAqJylcclxuICAgICAgICBpZiAocHJldkxhYmVscykgcHJldkxhYmVscy5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvLyBNYWluIG1hcFxyXG4gICAgICAgIGlmIChtYXAubGFiZWxzXykge1xyXG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJDb25maWcgPSBtYXAubGFiZWxzX1xyXG4gICAgICAgICAgICBsZXQgemcgPSBtYXAuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBtYXAuc3ZnSWRfKVxyXG4gICAgICAgICAgICBhZGRMYWJlbHNUb01hcChtYXAsIHpnKVxyXG4gICAgICAgICAgICBpZiAobWFzdGVyQ29uZmlnLnZhbHVlcyAmJiBtYXAudXBkYXRlVmFsdWVzTGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBtYXAudXBkYXRlVmFsdWVzTGFiZWxzKG1hcClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVmaW5lIHRoZSBjYWxsYmFjayB0byBhcHBseSB0byBlYWNoIGluc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5TGFiZWxzQ2FsbGJhY2sgPSAobWFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFzdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHpnID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmxhYmVsc18pIGFkZExhYmVsc1RvTWFwKG1hcCwgemcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc3RlckNvbmZpZy52YWx1ZXMgJiYgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAudXBkYXRlVmFsdWVzTGFiZWxzKG1hcClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGxhYmVscyB0byBhbGwgaW5zZXRzIHVzaW5nIHRoZSBleGVjdXRlRm9yQWxsSW5zZXRzIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGlmIChtYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG1hcC5zdmdJZF8sIGFwcGx5TGFiZWxzQ2FsbGJhY2spXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgbGFiZWxzIG9uIHRoZSBtYXBcclxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBldXJvc3RhdC1tYXAgbWFwIGluc3RhbmNlXHJcbiAqIEByZXR1cm4ge21hcH0gb3V0XHJcbiAqIE5PVEU6IFRISVMgRlVOQ1RJT04gSVMgTk9UIENBTExFRCBGT1IgUFJPUE9SVElPTkFMIFNZTUJPTCBNQVBTXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXBkYXRlVmFsdWVzTGFiZWxzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgaWYgKCFtYXApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIG1hcCBzcGVjaWZpZWQnKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vY2xlYXIgcHJldmlvdXMgbGFiZWxzXHJcbiAgICBsZXQgcHJldkxhYmVscyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnZy5lbS1zdGF0LWxhYmVsID4gKicpXHJcbiAgICBwcmV2TGFiZWxzLnJlbW92ZSgpXHJcbiAgICBsZXQgcHJldlNoYWRvd3MgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ2cuZW0tc3RhdC1sYWJlbC1zaGFkb3cgPiAqJylcclxuICAgIHByZXZTaGFkb3dzLnJlbW92ZSgpXHJcbiAgICBsZXQgc3RhdExhYmVscyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnZy5lbS1zdGF0LWxhYmVsJylcclxuXHJcbiAgICAvLyBmaWx0ZXIgc3RhdC1sYWJlbCBlbGVtZW50cyB0byBvbmx5IHNob3cgdGhvc2Ugd2l0aCBkYXRhXHJcbiAgICBjb25zdCBmaWx0ZXJGdW5jdGlvbiA9IG1hcC5sYWJlbHNfPy5zdGF0TGFiZWxzRmlsdGVyRnVuY3Rpb24gPyBtYXAubGFiZWxzXz8uc3RhdExhYmVsc0ZpbHRlckZ1bmN0aW9uIDogZGVmYXVsdFN0YXRMYWJlbEZpbHRlclxyXG4gICAgY29uc3Qgc3RhdERhdGEgPSBtYXAuc3RhdERhdGEoKVxyXG4gICAgc3RhdExhYmVsc1xyXG4gICAgICAgIC5maWx0ZXIoKHJnKSA9PiBmaWx0ZXJGdW5jdGlvbihyZywgbWFwKSlcclxuICAgICAgICAvLyAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gc3RhdExhYmVsc1RleHRGdW5jdGlvbihkLCBzdGF0RGF0YSkgLy8gVXNlICdkJyBkaXJlY3RseSBmb3IgdGhlIGxhYmVsIHRleHRcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgYmVoaW5kIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5iYWNrZ3JvdW5kcykgYXBwZW5kUmVjdChsYWJlbFRleHQsIHNlbClcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0ZXh0IGFmdGVyIHRoZSByZWN0YW5nbGVcclxuICAgICAgICAgICAgc2VsLmFwcGVuZCgndGV4dCcpLnRleHQobGFiZWxUZXh0KS5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVsLXRleHQnKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy8gRnVuY3Rpb24gdG8gYXBwZW5kIGEgcmVjdGFuZ2xlIGJlaGluZCB0aGUgbGFiZWxcclxuICAgIGZ1bmN0aW9uIGFwcGVuZFJlY3QobGFiZWxUZXh0LCBjb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IDUgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDIgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHRleHQgZWxlbWVudCB0byBnZXQgdGhlIHNpemVcclxuICAgICAgICBjb25zdCBiYm94ID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlzaWJpbGl0eScsICdoaWRkZW4nKSAvLyBNYWtlIHRoZSB0ZW1wb3JhcnkgdGV4dCBpbnZpc2libGVcclxuICAgICAgICAgICAgLnRleHQobGFiZWxUZXh0KSAvLyBTZXQgdGhlIGxhYmVsIHRleHQgdG8gZ2V0IGl0cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgLm5vZGUoKVxyXG4gICAgICAgICAgICAuZ2V0QkJveCgpIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBiYm94LndpZHRoXHJcbiAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSBiYm94LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgYWZ0ZXIgZ2V0dGluZyB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdCgndGV4dFt2aXNpYmlsaXR5PVwiaGlkZGVuXCJdJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIHRvIGJlIGNlbnRlcmVkIG9uIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgeCA9IC1sYWJlbFdpZHRoIC8gMiAtIHBhZGRpbmdYIC8vIENlbnRlciB0aGUgcmVjdCBob3Jpem9udGFsbHlcclxuICAgICAgICBjb25zdCB5ID0gLWxhYmVsSGVpZ2h0IC8gMiAtIHBhZGRpbmdZIC8vIENlbnRlciB0aGUgcmVjdCB2ZXJ0aWNhbGx5XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHgpIC8vIFBvc2l0aW9uIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSkgLy8gUG9zaXRpb24gcmVjdCB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGxhYmVsV2lkdGggKyAyICogcGFkZGluZ1gpIC8vIFdpZHRoIG9mIHRoZSByZWN0IHdpdGggcGFkZGluZ1xyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgbGFiZWxIZWlnaHQgKyAyICogcGFkZGluZ1kpIC8vIEhlaWdodCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxhYmVsLWJhY2tncm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vYWRkIHNoYWRvd3MgdG8gbGFiZWxzXHJcbiAgICBpZiAobWFwLmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICBtYXAuc3ZnX1xyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLXN0YXQtbGFiZWwtc2hhZG93JylcclxuICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IGZpbHRlckZ1bmN0aW9uKHJnLCBtYXApKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IHN0YXRMYWJlbHNUZXh0RnVuY3Rpb24oZCwgc3RhdERhdGEpKSAvLyBVc2UgJ2QnIGRpcmVjdGx5IGZvciB0aGUgbGFiZWwgdGV4dClcclxuICAgIH1cclxuICAgIHJldHVybiBtYXBcclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiB0ZXh0IGZ1bmN0aW9uIGZvciBzdGF0aXN0aWNhbCBsYWJlbGxpbmdcclxuICogQHBhcmFtIHtPYmplY3R9IGQgZDMgc2VsZWN0aW9uIGpzb24gZGF0YSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBzdGF0TGFiZWxzVGV4dEZ1bmN0aW9uID0gKGQsIHN0YXREYXRhKSA9PiB7XHJcbiAgICBpZiAoc3RhdERhdGEgJiYgc3RhdERhdGE/LmdldCkge1xyXG4gICAgICAgIGNvbnN0IHN2ID0gc3RhdERhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICBpZiAoIXN2IHx8ICghc3YudmFsdWUgJiYgc3YgIT09IDAgJiYgc3YudmFsdWUgIT09IDApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzdi52YWx1ZSAhPT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2LnZhbHVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgc3RhdGlzdGljYWwgbGFiZWxzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIGQzIHNlbGVjdGlvbiBqc29uIGRhdGEgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdFN0YXRMYWJlbEZpbHRlciA9IChyZWdpb24sIG1hcCkgPT4ge1xyXG4gICAgY29uc3QgcyA9IG1hcC5zdGF0RGF0YSgpXHJcbiAgICBjb25zdCBzdiA9IHMuZ2V0KHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBhcHBlbmRTdGF0TGFiZWxDZW50cm9pZHNUb01hcCA9IGZ1bmN0aW9uIChtYXAsIGxhYmVsc0NvbnRhaW5lcikge1xyXG4gICAgLy92YWx1ZXMgbGFiZWwgc2hhZG93cyBwYXJlbnQgPGc+XHJcbiAgICBjb25zdCBnc2xzID0gbGFiZWxzQ29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXN0YXQtbGFiZWxzLXNoYWRvd3MnKS5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG5cclxuICAgIC8vIHZhbHVlcyBsYWJlbHMgcGFyZW50IDxnPlxyXG4gICAgY29uc3Qgc3RhdExhYmVsc0dyb3VwID0gbGFiZWxzQ29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXN0YXQtbGFiZWxzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAvLyBvdXIgZmVhdHVyZXMgYXJyYXlcclxuICAgIGxldCBzdGF0TGFiZWxSZWdpb25zID0gW11cclxuXHJcbiAgICAvLyBkZWFmdWx0IGdlb21ldHJpZXNcclxuICAgIGlmIChtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy5udXRzcmcpIHtcclxuICAgICAgICAvL2FsbG93IGZvciBzdGF0IGxhYmVsIHBvc2l0aW9uaW5nIGJ5IGFkZGluZyBhIGcgZWxlbWVudCBoZXJlLCB0aGVuIGFkZGluZyB0aGUgdmFsdWVzIGluIHRoZSBtYXBUeXBlIHVwZGF0ZVZhbHVlc0xhYmVscyBmdW5jdGlvblxyXG4gICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgIHN0YXRMYWJlbFJlZ2lvbnMgPSBtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy5taXhlZC5yZzAuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmcxLFxyXG4gICAgICAgICAgICAgICAgbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmcyLFxyXG4gICAgICAgICAgICAgICAgbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmczXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0TGFiZWxSZWdpb25zID0gbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c3JnXHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykge1xyXG4gICAgICAgIC8vIHVzZXIgZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgc3RhdExhYmVsUmVnaW9ucyA9IG1hcC5HZW9tZXRyaWVzLnN0YXRpc3RpY2FsUmVnaW9ucy5mZWF0dXJlc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHByZXByb2Nlc3MgY2VudHJvaWRzXHJcbiAgICBpZiAobWFwLnByb2Nlc3NDZW50cm9pZHNfKSBjZW50cm9pZEZlYXR1cmVzID0gbWFwLnByb2Nlc3NDZW50cm9pZHNfKGNlbnRyb2lkRmVhdHVyZXMpXHJcblxyXG4gICAgLy9UT0RPOiBkb250IGFkZCBsYWJlbHMgZm9yIHJlZ2lvbnMgdGhhdCBhcmUgbm90IHZpc2libGU/IHdoYXQgYWJvdXQgcGFubmluZyBhbmQgem9vbWluZyB0aG91Z2guIE9ubHkgcmVhbGx5IGFuIGlzc3VlIGZvciBtaXhlZCBOVVRTLlxyXG5cclxuICAgIC8vIHN0YXRzIGxhYmVsc1xyXG4gICAgc3RhdExhYmVsc0dyb3VwXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgLmRhdGEoc3RhdExhYmVsUmVnaW9ucylcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAvLyB1c2UgcHJlZGVmaW5lZCBsYWJlbCBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICBpZiAobWFwLmxhYmVsc18uc3RhdExhYmVsc1Bvc2l0aW9uc1tkLnByb3BlcnRpZXMuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnNbZC5wcm9wZXJ0aWVzLmlkXVxyXG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IG1hcC5fcHJvamVjdGlvbihbcG9zaXRpb24ueCwgcG9zaXRpb24ueV0pXHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IHBvc1swXS50b0ZpeGVkKDMpXHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHBvc1sxXS50b0ZpeGVkKDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCR7eX0pYFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbnRyb2lkID0gbWFwLl9wYXRoRnVuY3Rpb24uY2VudHJvaWQoZClcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLmxhYmVsc18ucHJvY2Vzc1ZhbHVlTGFiZWxDZW50cm9pZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZW50cm9pZCA9IG1hcC5sYWJlbHNfLnByb2Nlc3NWYWx1ZUxhYmVsQ2VudHJvaWRzKGQsIGNlbnRyb2lkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNhbGN1bGF0ZSBjZW50cm9pZHNcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBjZW50cm9pZCArICcpJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc3RhdC1sYWJlbCcpXHJcblxyXG4gICAgLy8gc3RhdCBsYWJlbHMgc2hhZG93c1xyXG4gICAgaWYgKG1hcC5sYWJlbHNfPy5zaGFkb3dzKSB7XHJcbiAgICAgICAgZ3Nscy5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShzdGF0TGFiZWxSZWdpb25zKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgcHJlZGVmaW5lZCBsYWJlbCBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnNbZC5wcm9wZXJ0aWVzLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtYXAuX3Byb2plY3Rpb24oW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zW2QucHJvcGVydGllcy5pZF0ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmxhYmVsc18uc3RhdExhYmVsc1Bvc2l0aW9uc1tkLnByb3BlcnRpZXMuaWRdLnksXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHBvc1swXS50b0ZpeGVkKDMpXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBwb3NbMV0udG9GaXhlZCgzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IG1hcC5fcGF0aEZ1bmN0aW9uLmNlbnRyb2lkKGQpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5wcm9jZXNzVmFsdWVMYWJlbENlbnRyb2lkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50cm9pZCA9IG1hcC5sYWJlbHNfLnByb2Nlc3NWYWx1ZUxhYmVsQ2VudHJvaWRzKGQsIGNlbnRyb2lkKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgY2FsY3VsYXRlIGNlbnRyb2lkc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBjZW50cm9pZCArICcpJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXN0YXQtbGFiZWwtc2hhZG93JylcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgbGFiZWxzIGZvciBjb3VudHJ5IC8gZ2VvZ3JhcGhpY2FsIG5hbWVzLlxyXG4gKiBVc2luZyBjZW50cm9pZHMgd291bGQgY2xhc2ggd2l0aCBwcm9wb3J0aW9uYWwgc3ltYm9scywgYW5kIGFyZSBnZW5lcmFsbHkgbm90IGlkZWFsIHBsYWNlbWVudHMsIHNvIGxhYmVscyBhcmUgcG9zaXRpb25lZCBpbmRlcGVuZGVudGx5XHJcbiAqIExhYmVscyBhcmUgcHJvdmlkZWQgZm9yIGFsbCBzdXBwb3J0ZWQgbGFuZ3VhZ2VzOiBcImVuXCIsXCJmclwiIGFuZCBcImRlXCIgKGRlZmluZWQgdXNpbmcgbWFwLmxhbmd1YWdlKCkpXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgREVGQVVMVExBQkVMUyA9IHtcclxuICAgIEVVUl8zMDM1OiB7XHJcbiAgICAgICAgY2M6IFtcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQUwnLCB4OiA1MTAwMDAwLCB5OiAyMDYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVCcsIHg6IDQ2NzAwMDAsIHk6IDI2MjkwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxOCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCRScsIHg6IDM5MzAwMDAsIHk6IDMwMTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCRycsIHg6IDU1NjcwMDAsIHk6IDIyMDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdIUicsIHg6IDQ4NzYwMDAsIHk6IDI0NTUwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDWScsIHg6IDY0MjYwMDAsIHk6IDE0ODAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDWicsIHg6IDQ3MDcwMDAsIHk6IDI4ODUwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxOCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdESycsIHg6IDQzMTYwMDAsIHk6IDM2MjEwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFRScsIHg6IDUyMjAwMDAsIHk6IDM5OTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGSScsIHg6IDUxNTAwMDAsIHk6IDQ0MjQwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUicsIHg6IDM3Njc3NDAsIHk6IDI2NjI4MTcsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdERScsIHg6IDQzNDcyODQsIHk6IDMwOTMyNzYsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFTCcsIHg6IDUzNzAwMDAsIHk6IDE3NTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdIVScsIHg6IDUwMjAwMDAsIHk6IDI2MzAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJUycsIHg6IDMwNDAwMDAsIHk6IDQ4MzMwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJRScsIHg6IDMxMzYwMDAsIHk6IDMzOTQwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJVCcsIHg6IDQ0Njk5NjcsIHk6IDIxODE5NjMsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMVicsIHg6IDUyOTAwMDAsIHk6IDM4MDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMVCcsIHg6IDUxOTAwMDAsIHk6IDM2MzAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMVScsIHg6IDQxMjAwMDAsIHk6IDI5NDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNVCcsIHg6IDQ3MzEwMDAsIHk6IDEzMDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRScsIHg6IDUwNzMwMDAsIHk6IDIxODUwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01LJywgeDogNTMwMDAwMCwgeTogMjA4MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05MJywgeDogNDAyMDAwMCwgeTogMzIwODAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PJywgeDogNDMwMDAwMCwgeTogNDE0NzAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BMJywgeDogNDk2NDAwMCwgeTogMzIwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BUJywgeDogMjgwMDAwMCwgeTogMTk5MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE4IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JPJywgeDogNTQ1MTAwMCwgeTogMjYwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JTJywgeDogNTIwMDAwMCwgeTogMjMwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NLJywgeDogNTA0MDAwMCwgeTogMjgzNTAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NJJywgeDogNDY1NTAwMCwgeTogMjQ4MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTJywgeDogMzE2MDA5NiwgeTogMTkwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NFJywgeDogNDYzMDAwMCwgeTogNDAwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NIJywgeDogNDIwMDAwMCwgeTogMjU2NDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE2IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1RSJywgeDogNjUxMDAwMCwgeTogMjEwMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDIyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1VLJywgeDogMzU1ODAwMCwgeTogMzI1MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDE3IH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBlbjogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRURJVEVSUkFORUFOIFNFQScsIHg6IDM5ODAwMDAsIHk6IDE2MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyLCBsZXR0ZXJTcGFjaW5nOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FUTEFOVElDIE9DRUFOJywgeDogMjgyMDAwMCwgeTogMjU0MDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SVEggU0VBJywgeDogMzkxNTAwMCwgeTogMzcwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkFMVElDIFNFQScsIHg6IDQ5MDAwMDAsIHk6IDM3MzAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCByb3RhdGU6IC01MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JXRUdJQU4gU0VBJywgeDogMzg1MDAwMCwgeTogNDgwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkxBQ0sgU0VBJywgeDogNjMwMDAwMCwgeTogMjUwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDQgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQUxCQU5JQScsIGNjOiAnQUwnLCB4OiA1MTAwMDAwLCB5OiAyMDYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogODAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQVVTVFJJQScsIGNjOiAnQVQnLCB4OiA0NjcwMDAwLCB5OiAyNjI5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JFTEdJVU0nLCBjYzogJ0JFJywgeDogMzkwMDAwMCwgeTogMzAzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IDMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JVTEdBUklBJywgY2M6ICdCRycsIHg6IDU1NjcwMDAsIHk6IDIyNTYwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ1JPQVRJQScsIGNjOiAnSFInLCB4OiA0ODc2MDAwLCB5OiAyNDU1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ1lQUlVTJywgY2M6ICdDWScsIHg6IDY0MjYwMDAsIHk6IDE0ODAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ1pFQ0hJQScsIGNjOiAnQ1onLCB4OiA0NzA3MDAwLCB5OiAyODg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0RFTk1BUksnLCBjYzogJ0RLJywgeDogNDMxNjAwMCwgeTogMzYyMTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFU1RPTklBJywgY2M6ICdFRScsIHg6IDUyMjAwMDAsIHk6IDM5OTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGSU5MQU5EJywgY2M6ICdGSScsIHg6IDUxNTAwMDAsIHk6IDQ0MjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlJBTkNFJywgY2M6ICdGUicsIHg6IDM3Njc3NDAsIHk6IDI2NjI4MTcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR0VSTUFOWScsIGNjOiAnREUnLCB4OiA0MzQ3Mjg0LCB5OiAzMDkzMjc2LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0dSRUVDRScsIGNjOiAnRUwnLCB4OiA1NDcwMDAwLCB5OiAxODYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0hVTkdBUlknLCBjYzogJ0hVJywgeDogNTAyMDAwMCwgeTogMjYzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJQ0VMQU5EJywgY2M6ICdJUycsIHg6IDMwNDAwMDAsIHk6IDQ4MzMwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVJFTEFORCcsIGNjOiAnSUUnLCB4OiAzMTM2MDAwLCB5OiAzMzk0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lUQUxZJywgY2M6ICdJVCcsIHg6IDQ0Njk5NjcsIHk6IDIxODE5NjMsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTEFUVklBJywgY2M6ICdMVicsIHg6IDUyOTAwMDAsIHk6IDM4MDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMSVRIVUFOSUEnLCBjYzogJ0xUJywgeDogNTE5MDAwMCwgeTogMzYzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xVWC4nLCBjYzogJ0xVJywgeDogNDEyMDAwMCwgeTogMjk0MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01BTFRBJywgY2M6ICdNVCcsIHg6IDQ3MzEwMDAsIHk6IDEzMzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNT05ULicsIGNjOiAnTUUnLCB4OiA1MDczMDAwLCB5OiAyMTg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTi4gTUFDRURPTklBJywgY2M6ICdNSycsIHg6IDUzMDAwMDAsIHk6IDIwODIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdORVRIRVJMQU5EUycsIGNjOiAnTkwnLCB4OiAzOTc3MDAwLCB5OiAzMjA4MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SV0FZJywgY2M6ICdOTycsIHg6IDQzMzAwMDAsIHk6IDQxNDcwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BPTEFORCcsIGNjOiAnUEwnLCB4OiA0OTY0MDAwLCB5OiAzMjY5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BPUlRVR0FMJywgY2M6ICdQVCcsIHg6IDI4MzAwMDAsIHk6IDE5OTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JPTUFOSUEnLCBjYzogJ1JPJywgeDogNTQ1MTAwMCwgeTogMjYwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTRVJCSUEnLCBjYzogJ1JTJywgeDogNTIwMDAwMCwgeTogMjMwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NMT1ZBS0lBJywgY2M6ICdTSycsIHg6IDUwNDAwMDAsIHk6IDI4MzUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAtMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPVkVOSUEnLCBjYzogJ1NJJywgeDogNDczNTAwMCwgeTogMjUyMjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTUEFJTicsIGNjOiAnRVMnLCB4OiAzMTYwMDk2LCB5OiAxODUwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NXRURFTicsIGNjOiAnU0UnLCB4OiA0NjMwMDAwLCB5OiA0MTAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTV0lUWkVSTEFORCcsIGNjOiAnQ0gnLCB4OiA0MjAwMDAwLCB5OiAyNTY0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFVSS0VZJywgY2M6ICdUUicsIHg6IDY1MTAwMDAsIHk6IDIxMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVS5LLicsIGNjOiAnVUsnLCB4OiAzNTU4MDAwLCB5OiAzMjUwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBmcjogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRVIgTcOJRElURVJSQU7DiUUnLCB4OiA1NDcyMDAwLCB5OiAxMjQyMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdPQ8OIQU4gQVRMQU5USVFVRScsIHg6IDI4MjAwMDAsIHk6IDI1NDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FUiBEVSBOT1JEJywgeDogMzkxNTAwMCwgeTogMzcwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIEJBTFRJUVVFJywgeDogNDkwMDAwMCwgeTogMzY3MjAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIHJvdGF0ZTogLTUwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FUiBERSBOT1JWw4hHRScsIHg6IDM4NTAwMDAsIHk6IDQ4MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FUiBOT0lSRScsIHg6IDYyNjUwMDAsIHk6IDI0NzIwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FMQkFOSUUnLCB4OiA1MTAwMDAwLCB5OiAyMDYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogODAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQVVUUklDSEUnLCB4OiA0NjcwMDAwLCB5OiAyNjI5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JFTEdJUVVFJywgeDogMzkwMDAwMCwgeTogMzAzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IDMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JVTEdBUklFJywgeDogNTU2NzAwMCwgeTogMjI1NjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDUk9BVElFJywgeDogNDg3NjAwMCwgeTogMjQ1NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NIWVBSRScsIHg6IDY0MjYwMDAsIHk6IDE0ODAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVENIw4lRVUlFJywgeDogNDcwNzAwMCwgeTogMjg4NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdEQU5FTUFSSycsIHg6IDQzMTYwMDAsIHk6IDM2MjEwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRVNUT05JRScsIHg6IDUyMjAwMDAsIHk6IDM5OTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRklOTEFOREUnLCB4OiA1MTI1MDAwLCB5OiA0NDI0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSQU5DRScsIHg6IDM3Njc3NDAsIHk6IDI2NjI4MTcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQUxMRU1BR05FJywgeDogNDM0NzI4NCwgeTogMzA5MzI3NiwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdHUsOIQ0UnLCB4OiA1NDIwMDAwLCB5OiAxODYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0hPTkdSSUUnLCB4OiA1MDIwMDAwLCB5OiAyNjU0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lTTEFOREUnLCB4OiAzMDQwMDAwLCB5OiA0ODMzMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lSTEFOREUnLCB4OiAzMTM2MDAwLCB5OiAzMzk0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lUQUxJRScsIHg6IDQ1MDAwMDAsIHk6IDIxODE5NjMsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTEVUVE9OSUUnLCB4OiA1MjkwMDAwLCB5OiAzNzc2MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xJVFVBTklFJywgeDogNTE5MDAwMCwgeTogMzYzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMVVguJywgeDogNDEyMDAwMCwgeTogMjk0MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01BTFRFJywgeDogNDczMTAwMCwgeTogMTMzNTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01PTlQuJywgeDogNTA3MzAwMCwgeTogMjE4NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01BQy4gRFUgTk9SRCcsIHg6IDUzMDAwMDAsIHk6IDIwODIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQQVlTLUJBUycsIHg6IDM5NzcwMDAsIHk6IDMyMDgwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JWRUdFJywgeDogNDMzMDAwMCwgeTogNDE0NzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9MT0dORScsIHg6IDQ5NjQwMDAsIHk6IDMyNjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9SVFVHQUwnLCB4OiAyODM2MTM2LCB5OiAxOTU2MTc5LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdST1VNQU5JRScsIHg6IDU0NTEwMDAsIHk6IDI2MDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0VSQklFJywgeDogNTIwMDAwMCwgeTogMjMwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NMT1ZBUVVJRScsIHg6IDUwNDAwMDAsIHk6IDI4MzUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAtMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPVsOJTklFJywgeDogNDczNTAwMCwgeTogMjUyMjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zNSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFU1BBR05FJywgeDogMzE2MDA5NiwgeTogMTg1MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTVcOIREUnLCB4OiA0NzAwMDAwLCB5OiA0NDAxMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTVUlTU0UnLCB4OiA0MjAwMDAwLCB5OiAyNTY0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVFVSUVVJRScsIHg6IDY1MTAwMDAsIHk6IDIxMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUk9ZQVVNRS1VTkknLCB4OiAzNTU4MDAwLCB5OiAzMjUwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkZTogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdNSVRURUxNRUVSJywgeDogNTQ3MjAwMCwgeTogMTIwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIsIGxldHRlclNwYWNpbmc6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQVRMQU5USVNDSEVSIE9aRUFOJywgeDogMjgyMDAwMCwgeTogMjU0MDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SRFNFRScsIHg6IDM5MTUwMDAsIHk6IDM3MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ09TVFNFRScsIHg6IDQ5MDAwMDAsIHk6IDM2NzIwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCByb3RhdGU6IC01MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JXRUdJU0NIRSBNRUVSJywgeDogMzg1MDAwMCwgeTogNDgwMDAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0NIV0FSWkUgTUVFUicsIHg6IDYzMDAwMDAsIHk6IDI1MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FMQkFOSUVOJywgeDogNTEwMDAwMCwgeTogMjA2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IDgwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ8OWU1RFUlJFSUNIJywgeDogNDY1MDAwMCwgeTogMjYyOTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JFTEdJRU4nLCB4OiAzOTAwMDAwLCB5OiAzMDMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQlVMR0FSSUVOJywgeDogNTU2NzAwMCwgeTogMjI1NjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdLUk9BVElFTicsIHg6IDQ4NzYwMDAsIHk6IDI0NTUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdaWVBFUk4nLCB4OiA2NDI2MDAwLCB5OiAxNDgwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1RTQ0hFQ0hJRU4nLCB4OiA0NzA3MDAwLCB5OiAyODg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRMOETkVNQVJLJywgeDogNDMxNjAwMCwgeTogMzYyMTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFU1RMQU5EJywgeDogNTIyMDAwMCwgeTogMzk5MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZJTk5MQU5EJywgeDogNTE1MDAwMCwgeTogNDQyNDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUkFOS1JFSUNIJywgeDogMzc2Nzc0MCwgeTogMjY2MjgxNywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdERVVUU0NITEFORCcsIHg6IDQzNDcyODQsIHk6IDMwOTMyNzYsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR1JJRUNIRU5MQU5EJywgeDogNTU1MDAwMCwgeTogMTUwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdVTkdBUk4nLCB4OiA1MDIwMDAwLCB5OiAyNjMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lTTEFORCcsIHg6IDMwNDAwMDAsIHk6IDQ4MzMwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVJMQU5EJywgeDogMzEzNjAwMCwgeTogMzM5NDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJVEFMSUVOJywgeDogNDQ2OTk2NywgeTogMjE4MTk2MywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAzNSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMRVRUTEFORCcsIHg6IDUyOTAwMDAsIHk6IDM4MDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMSVRBVUVOJywgeDogNTE5MDAwMCwgeTogMzYzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xVWC4nLCB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUFMVEEnLCB4OiA0NzMxMDAwLCB5OiAxMzMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTU9OVC4nLCB4OiA1MDczMDAwLCB5OiAyMTg1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SRE1BWkVET05JRU4nLCB4OiA1MzUwMDAwLCB5OiAyMDgyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTklFREVSTEFOREUnLCB4OiAzOTc3MDAwLCB5OiAzMjA4MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SV0VHRU4nLCB4OiA0MzMwMDAwLCB5OiA0MTQ3MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT0xFTicsIHg6IDQ5NjQwMDAsIHk6IDMyNjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9SVFVHQUwnLCB4OiAyODM2MTM2LCB5OiAxOTU2MTc5LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdSVU3DhE5JRU4nLCB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NFUkJJRU4nLCB4OiA1MjAwMDAwLCB5OiAyMzAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0xPV0FLRUknLCB4OiA1MDQwMDAwLCB5OiAyODM1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NMT1dFTklFTicsIHg6IDQ3MzUwMDAsIHk6IDI1MjIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAtMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU1BBTklFTicsIHg6IDMxNjAwOTYsIHk6IDE4NTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0NIV0VERU4nLCB4OiA0NjcwMDAwLCB5OiA0MTgwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTQ0hXRUlaJywgeDogNDIwMDAwMCwgeTogMjU2NDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1RSVVRIQUhOJywgeDogNjUxMDAwMCwgeTogMjEwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdWRVJFSU5JR1RFUycsIHg6IDM1NTAwMDAsIHk6IDM1MjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnS8OWTklHUkVJQ0gnLCB4OiAzNTUwMDAwLCB5OiAzNDIwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICBJQ18zMjYyODoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRVMnLCB4OiA0MjA0NjgsIHk6IDMxODA2NDcsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0NhbmFyeSBJc2xhbmRzJywgeDogNDIwNDY4LCB5OiAzMTgwNjQ3LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGZyOiBbeyB0ZXh0OiAnTGVzIMOubGVzIENhbmFyaWVzJywgeDogNDIwNDY4LCB5OiAzMTgwNjQ3LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGRlOiBbeyB0ZXh0OiAnS2FuYXJpc2NoZSBJbnNlbG4nLCB4OiA0MTAwMDAsIHk6IDMxODA2NDcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICB9LFxyXG4gICAgR1BfMzI2MjA6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0ZSJywgeDogNjY3MDAwLCB5OiAxNzQwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdHdWFkZWxvdXBlJywgeDogNzAwMDAwLCB5OiAxODEwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgfSxcclxuICAgIE1RXzMyNjIwOiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdGUicsIHg6IDcxNjUyMSwgeTogMTYyMTMyMiwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnTWFydGluaXF1ZScsIHg6IDcxNjUyMSwgeTogMTYyMTMyMiwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgIH0sXHJcbiAgICBHRl8zMjYyMjoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRlInLCB4OiAyNjY4NTIsIHk6IDQ0NDA3NCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnR3V5YW5lJywgeDogMjY2ODUyLCB5OiA0NDQwNzQsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZGU6IFt7IHRleHQ6ICdHdWF5YW5hJywgeDogMjY2ODUyLCB5OiA0NDQwNzQsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICB9LFxyXG4gICAgUkVfMzI3NDA6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0ZSJywgeDogMzQ4MDExLCB5OiA3NjgwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdSw6l1bmlvbicsIHg6IDM0ODAxMSwgeTogNzY4MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgIH0sXHJcbiAgICBZVF8zMjczODoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRlInLCB4OiA1MTY1NDksIHk6IDg1OTM5MjAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ01heW90dGUnLCB4OiA1MTY1NDksIHk6IDg1OTM5MjAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICB9LFxyXG4gICAgTVRfMzAzNToge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnTVQnLCB4OiA0NzE5NzU1LCB5OiAxNDEwNzAxLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdNYWx0YScsIHg6IDQ3MTk3NTUsIHk6IDE0MTA3MDEsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICB9LFxyXG4gICAgUFQyMF8zMjYyNjoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnUFQnLCB4OiAzOTc0MTgsIHk6IDQzMjAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0F6b3JlcycsIHg6IDM5NzQxOCwgeTogNDMyMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBmcjogW3sgdGV4dDogJ0HDp29yZXMnLCB4OiAzOTc0MTgsIHk6IDQyNzE0NzEsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZGU6IFt7IHRleHQ6ICdBem9yZW4nLCB4OiAzOTc0MTgsIHk6IDQyNzE0NzEsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICB9LFxyXG4gICAgUFQzMF8zMjYyODoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnUFQnLCB4OiAzMzM1ODYsIHk6IDM2MjQwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCwgcm90YXRlOiAzMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ01hZGVpcmEnLCB4OiAzMzM1ODYsIHk6IDM2MjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAsIHJvdGF0ZTogMzAgfV0sXHJcbiAgICAgICAgZnI6IFt7IHRleHQ6ICdNYWTDqHJlJywgeDogMzMzNTg2LCB5OiAzNjI0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwLCByb3RhdGU6IDMwIH1dLFxyXG4gICAgfSxcclxuICAgIExJXzMwMzU6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0xJJywgeDogNDI4NzA2MCwgeTogMjY2MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnTGllY2h0ZW5zdGVpbicsIHg6IDQyODcwNjAsIHk6IDI2NzkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9XSxcclxuICAgIH0sXHJcbiAgICBJU18zMDM1OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdJUycsIHg6IDMwMTE4MDQsIHk6IDQ5NjAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0ljZWxhbmQnLCB4OiAzMDExODA0LCB5OiA0OTYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGZyOiBbeyB0ZXh0OiAnSXNsYW5kZScsIHg6IDMwMTE4MDQsIHk6IDQ5NjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZGU6IFt7IHRleHQ6ICdJc2xhbmQnLCB4OiAzMDExODA0LCB5OiA0OTYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgfSxcclxuICAgIFNKX1NWXzMwMzU6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ05PJywgeDogNDU3MDAwMCwgeTogNjI2MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnU3ZhbGJhcmQnLCB4OiA0NTcwMDAwLCB5OiA2MjYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGRlOiBbeyB0ZXh0OiAnU3BpdHpiZXJnZW4nLCB4OiA0NTcwMDAwLCB5OiA2MjYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfV0sXHJcbiAgICB9LFxyXG4gICAgU0pfSk1fMzAzNToge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnTk8nLCB4OiAzNjQ3NzYyLCB5OiA1NDIwMzAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdKYW4gTWF5ZW4nLCB4OiAzNjQ3NzYyLCB5OiA1NDIwMzAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfV0sXHJcbiAgICB9LFxyXG4gICAgQ0FSSUJfMzI2MjA6IHtcclxuICAgICAgICBjYzogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUicsIHg6IDcwMDAwMCwgeTogMTgxMDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSJywgeDogNjQwMDAwLCB5OiAxNTkwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlInLCB4OiA1NDAwMDAsIHk6IDE5NjIwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBlbjogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdHdWFkZWxvdXBlJywgeDogNzAwMDAwLCB5OiAxODEwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01hcnRpbmlxdWUnLCB4OiA1NzAwMDAsIHk6IDE1OTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU2FpbnQgTWFydGluJywgeDogNTk3MDAwLCB5OiAxOTYyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIC8vIG5vdGU6IFdPUkxEIHgveSBhcmUgaW4gRVBTRzo0MzI2IHRoZW4gcmVwcm9qZWN0ZWQgYnkgZDMgdG8gRVBTRzo1NDAzMFxyXG4gICAgV09STERfNTQwMzA6IHtcclxuICAgICAgICBlbjogW1xyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JUSCBBVExBTlRJQycsIHg6IC00NSwgeTogMjUsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NPVVRIIEFUTEFOVElDJywgeDogLTE1LCB5OiAtMjUsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NPVVRIIFBBQ0lGSUMnLCB4OiAtMTI2LCB5OiAtMjUsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUlRIJywgeDogLTEzNiwgeTogMjUsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BBQ0lGSUMnLCB4OiAtMTM0LCB5OiAyMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSU5ESUFOIE9DRUFOJywgeDogODAsIHk6IC0yNSwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDEgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU09VVEhFUk4gT0NFQU4nLCB4OiAtNSwgeTogLTY3LCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogNiB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG59XHJcblxyXG5jb25zdCBERUZBVUxUU1RBVExBQkVMUE9TSVRJT05TID0ge1xyXG4gICAgQUw6IHsgeDogNTE1MDAwMCwgeTogMjAwMDAwMCB9LFxyXG4gICAgQVQ6IHsgeDogNDY3MDAwMCwgeTogMjcwMDAwMCB9LFxyXG4gICAgQkU6IHsgeDogMzkzMDAwMCwgeTogMzA2MDAwMCB9LFxyXG4gICAgQkc6IHsgeDogNTU2NzAwMCwgeTogMjMwMDAwMCB9LFxyXG4gICAgSFI6IHsgeDogNDY1NzcxOCwgeTogMjQwMDI0MyB9LFxyXG4gICAgQ1k6IHsgeDogNjQyNjAwMCwgeTogMTU3MDAwMCB9LFxyXG4gICAgQ0g6IHsgeDogNDE3MDAwMCwgeTogMjYwMDAwMCB9LFxyXG4gICAgQ1o6IHsgeDogNDcwNzAwMCwgeTogMjk1MDAwMCB9LFxyXG4gICAgREs6IHsgeDogNDMxNjAwMCwgeTogMzYyMTAwMCB9LFxyXG4gICAgRUU6IHsgeDogNTIyMDAwMCwgeTogNDA1MDAwMCB9LFxyXG4gICAgRkk6IHsgeDogNTE1MDAwMCwgeTogNDQyNDAwMCB9LFxyXG4gICAgRlI6IHsgeDogMzc2Nzc0MCwgeTogMjY2MjgxNyB9LFxyXG4gICAgREU6IHsgeDogNDM0NzI4NCwgeTogMzA5MzI3NiB9LFxyXG4gICAgRUw6IHsgeDogNTM3MDAwMCwgeTogMTc1MDAwMCB9LFxyXG4gICAgSFU6IHsgeDogNTAyMDAwMCwgeTogMjY3MDAwMCB9LFxyXG4gICAgSVM6IHsgeDogMzA0MDAwMCwgeTogNDgzMzAwMCB9LFxyXG4gICAgSUU6IHsgeDogMzEzNjAwMCwgeTogMzM5NDAwMCB9LFxyXG4gICAgSVQ6IHsgeDogNDUwMDAwMCwgeTogMjE4MTk2MyB9LFxyXG4gICAgTFY6IHsgeDogNTI5MDAwMCwgeTogMzg0MDAwMCB9LFxyXG4gICAgTFQ6IHsgeDogNTE5MDAwMCwgeTogMzYzMDAwMCB9LFxyXG4gICAgTFU6IHsgeDogNDEyMDAwMCwgeTogMjk0MDAwMCB9LFxyXG4gICAgTVQ6IHsgeDogNDg4MDAwMCwgeTogMTQ4MDAwMCB9LFxyXG4gICAgTUU6IHsgeDogNTA3MzAwMCwgeTogMjIzMDAwMCB9LFxyXG4gICAgTUs6IHsgeDogNTMwMDAwMCwgeTogMjEzMDAwMCB9LFxyXG4gICAgTkw6IHsgeDogNDAyMDAwMCwgeTogMzIwODAwMCB9LFxyXG4gICAgTk86IHsgeDogNDMwMDAwMCwgeTogNDE0NzAwMCB9LFxyXG4gICAgUEw6IHsgeDogNDk2NDAwMCwgeTogMzIwMDAwMCB9LFxyXG4gICAgUFQ6IHsgeDogMjgwMDAwMCwgeTogMTk5MDAwMCB9LFxyXG4gICAgUk86IHsgeDogNTQ1MTAwMCwgeTogMjYwMDAwMCB9LFxyXG4gICAgUlM6IHsgeDogNTIwMDAwMCwgeTogMjM3MDAwMCB9LFxyXG4gICAgU0s6IHsgeDogNTA0MDAwMCwgeTogMjg2MDAwMCB9LFxyXG4gICAgU0k6IHsgeDogNDY2MDAwMCwgeTogMjU1MDAwMCB9LFxyXG4gICAgRVM6IHsgeDogMzE2MDA5NiwgeTogMTkwMDAwMCB9LFxyXG4gICAgU0U6IHsgeDogNDYzMDAwMCwgeTogNDAwMDAwMCB9LFxyXG4gICAgVFI6IHsgeDogNjUxMDAwMCwgeTogMjEwMDAwMCB9LFxyXG4gICAgVUs6IHsgeDogMzU1ODAwMCwgeTogMzI1MDAwMCB9LFxyXG4gICAgUlU6IHsgeDogNjg0MjA4NiwgeTogMzIzMDUxNyB9LFxyXG59XHJcbiIsImltcG9ydCB7IHpvb20sIHpvb21JZGVudGl0eSB9IGZyb20gJ2QzLXpvb20nXHJcbmltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBmb3JtYXREZWZhdWx0TG9jYWxlIH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBnZW9JZGVudGl0eSwgZ2VvUGF0aCwgZ2VvQ2VudHJvaWQgfSBmcm9tICdkMy1nZW8nXHJcbmltcG9ydCB7IGdlb1JvYmluc29uIH0gZnJvbSAnZDMtZ2VvLXByb2plY3Rpb24nXHJcbmltcG9ydCB7IGdldEJCT1hBc0dlb0pTT04sIGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldEZvbnRTaXplRnJvbUNsYXNzLCBnZXRQYXJhbWV0ZXJCeU5hbWUsIGNvbnZlcnRSZWN0YW5nbGVzVG9QYXRocyB9IGZyb20gJy4vdXRpbHMnXHJcbmltcG9ydCB7IGFwcGVuZEFubm90YXRpb25zIH0gZnJvbSAnLi9hbm5vdGF0aW9ucydcclxuaW1wb3J0IHsgYWRkTGFiZWxzVG9NYXAsIHVwZGF0ZUxhYmVscywgdXBkYXRlVmFsdWVzTGFiZWxzIH0gZnJvbSAnLi9sYWJlbHMnXHJcbmltcG9ydCB7IGRlZmluZURlcHJlY2F0ZWRGdW5jdGlvbnMgfSBmcm9tICcuL2RlcHJlY2F0ZWQnXHJcbmltcG9ydCB7IEdlb21ldHJpZXMgfSBmcm9tICcuL2dlb21ldHJpZXMnXHJcbmltcG9ydCB7IGJ1aWxkSW5zZXRzLCByZW1vdmVJbnNldHMgfSBmcm9tICcuL2luc2V0cydcclxuaW1wb3J0IHsgYXBwZW5kU3RhbXAgfSBmcm9tICcuL3N0YW1wcydcclxuaW1wb3J0IHsgYnVpbGRHcmlkQ2FydG9ncmFtQmFzZSB9IGZyb20gJy4vY2FydG9ncmFtcydcclxuXHJcbi8vIHNldCBkZWZhdWx0IGQzIGxvY2FsZVxyXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcclxuICAgIGRlY2ltYWw6ICcuJyxcclxuICAgIHRob3VzYW5kczogJyAnLFxyXG4gICAgZ3JvdXBpbmc6IFszXSxcclxuICAgIGN1cnJlbmN5OiBbJycsICfigqwnXSxcclxufSlcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFwIHRlbXBsYXRlOiBvbmx5IHRoZSBnZW9tZXRyaWNhbCBwYXJ0LlxyXG4gKiBUbyBiZSB1c2VkIGFzIGEgYmFzZSBtYXAgZm9yIGEgc3RhdGlzdGljYWwgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHdpdGhDZW50ZXJQb2ludHMgU2V0IHRvIHRydWUgKG9yIDEpIHRvIGFkZCByZWdpb25zIGNlbnRlciBwb2ludHMgdG8gdGhlIG1hcCB0ZW1wbGF0ZSwgdG8gYmUgdXNlZCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbHMgbWFwcyBmb3IgZXhhbXBsZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXBUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb25maWcsIHdpdGhDZW50ZXJQb2ludHMsIG1hcFR5cGUpIHtcclxuICAgIC8vYnVpbGQgbWFwIHRlbXBsYXRlIG9iamVjdFxyXG4gICAgY29uc3Qgb3V0ID0ge31cclxuICAgIG91dC5fbWFwVHlwZSA9IG1hcFR5cGVcclxuXHJcbiAgICAvLyBleHBvc2UgaW1wb3J0ZWQgZnVuY3Rpb24gdG8gb3RoZXIgbW9kdWxlc1xyXG4gICAgb3V0LnVwZGF0ZVZhbHVlc0xhYmVscyA9IHVwZGF0ZVZhbHVlc0xhYmVsc1xyXG5cclxuICAgIC8vbWFwXHJcbiAgICBvdXQuc3ZnSWRfID0gJ21hcCdcclxuICAgIG91dC5zdmdfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQud2lkdGhfID0gTWF0aC5taW4oNzk1LCB3aW5kb3cuaW5uZXJXaWR0aClcclxuICAgIG91dC5oZWlnaHRfID0gMFxyXG4gICAgb3V0LmNvbnRhaW5lcklkXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vZ2VvZ3JhcGhpY2FsIGZvY3VzXHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbV8gPSBmYWxzZSAvLyBkcmF3IGdlb21ldHJpZXMgYXMgZ3JpZCBjZWxsc1xyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1TaGFwZV8gPSAnc3F1YXJlJyAvLyBzcXVhcmUgb3IgaGV4YWdvblxyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1NYXJnaW5zXyA9IHsgdG9wOiA4MCwgcmlnaHQ6IDUwLCBib3R0b206IDgwLCBsZWZ0OiAxNTAgfVxyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1DZWxsUGFkZGluZ18gPSA0XHJcbiAgICBvdXQuZ3JpZENhcnRvZ3JhbVBvc2l0aW9uc18gPSB1bmRlZmluZWQgLy91c2VyIGRlZmluZWQgY2FydG9ncmFtc1xyXG4gICAgb3V0Lm51dHNMZXZlbF8gPSAzIC8vIDAsMSwyLDMsIG9yICdtaXhlZCdcclxuICAgIG91dC5udXRzWWVhcl8gPSAyMDI0XHJcbiAgICBvdXQuZ2VvXyA9ICdFVVInXHJcbiAgICBvdXQucHJval8gPSAnMzAzNSdcclxuICAgIG91dC5wcm9qZWN0aW9uRnVuY3Rpb25fID0gdW5kZWZpbmVkIC8vIGUuZy4gZDMuZ2VvUm9iaW5zb24oKVxyXG4gICAgb3V0LmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbl8gPSB1bmRlZmluZWQgLy8gdXNlciBkZWZpbmVkIGZpbHRlciBmdW5jdGlvblxyXG4gICAgb3V0LnNjYWxlXyA9ICcyME0nIC8vVE9ETyBjaG9vc2UgYXV0b21hdGljYWxseSwgZGVwZW5kaW5nIG9uIHBpeGVsU2l6ZSA/XHJcbiAgICBvdXQuem9vbUV4dGVudF8gPSB1bmRlZmluZWRcclxuICAgIG91dC5tYXhCb3VuZHNfID0geyB4TWluOiAtSW5maW5pdHksIHlNaW46IC1JbmZpbml0eSwgeE1heDogSW5maW5pdHksIHlNYXg6IEluZmluaXR5IH1cclxuICAgIG91dC5nZW9tZXRyaWVzXyA9IHVuZGVmaW5lZCAvLyBbe2lkOlN0cmluZywgZGF0YTpnZW9qc29uLCBjbGFzczpmdW5jdGlvbn1dIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICBvdXQucHJvY2Vzc0NlbnRyb2lkc18gPSB1bmRlZmluZWQgLy8gcnVucyBvdmVyIHN5bWJvbCBjZW50cm9pZHNcclxuICAgIG91dC5wb3NpdGlvbl8gPSB7IHg6IHVuZGVmaW5lZCwgeTogdW5kZWZpbmVkLCB6OiB1bmRlZmluZWQgfSAvLyBtYXAgdmlld1xyXG5cclxuICAgIC8vbWFwIHRpdGxlXHJcbiAgICBvdXQudGl0bGVfID0gJydcclxuICAgIG91dC50aXRsZVBvc2l0aW9uXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vbWFwIHN1YnRpdGxlXHJcbiAgICBvdXQuc3VidGl0bGVfID0gJydcclxuICAgIG91dC5zdWJ0aXRsZVBvc2l0aW9uXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vc2NhbGViYXJcclxuICAgIG91dC5zaG93U2NhbGViYXJfID0gZmFsc2VcclxuICAgIG91dC5zY2FsZWJhclBvc2l0aW9uXyA9IFtdXHJcbiAgICBvdXQuc2NhbGViYXJVbml0c18gPSAnIGttJyAvL2xhYmVsXHJcbiAgICBvdXQuc2NhbGViYXJUZXh0T2Zmc2V0XyA9IFswLCAxMl1cclxuICAgIG91dC5zY2FsZWJhck1heFdpZHRoXyA9IDE1MCAvL3B4XHJcbiAgICBvdXQuc2NhbGViYXJIZWlnaHRfID0gOTAgLy9weFxyXG4gICAgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfID0gMSAvL3B4XHJcbiAgICBvdXQuc2NhbGViYXJTZWdtZW50SGVpZ2h0XyA9IDZcclxuICAgIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfID0gOFxyXG5cclxuICAgIC8vIHN0YW1wIGFubm90YXRpb25cclxuICAgIG91dC5zdGFtcF8gPSB1bmRlZmluZWQgLy9lLmcge3gseSx0ZXh0LHNpemV9XHJcblxyXG4gICAgLy90b29sdGlwXHJcbiAgICBvdXQudG9vbHRpcF8gPSB7XHJcbiAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcclxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDIwMCxcclxuICAgICAgICB4T2Zmc2V0OiAwLFxyXG4gICAgICAgIHlPZmZzZXQ6IDAsXHJcbiAgICAgICAgdGV4dEZ1bmN0aW9uOiBudWxsLFxyXG4gICAgICAgIHNob3dGbGFnczogZmFsc2UsXHJcbiAgICB9IC8vICBTZWUgdG9vbHRpcC5qcyBmb3IgbW9yZSBkZXRhaWxzXHJcblxyXG4gICAgLy8gcmVnaW9uIG1vdXNlb3ZlciBjb2xvclxyXG4gICAgb3V0LmhvdmVyQ29sb3JfID0gJ3JlZCdcclxuXHJcbiAgICAvL2NvYXN0YWwgbWFyZ2luXHJcbiAgICBvdXQuZHJhd0NvYXN0YWxNYXJnaW5fID0gZmFsc2VcclxuICAgIG91dC5jb2FzdGFsTWFyZ2luU3RkRGV2XyA9IDNcclxuXHJcbiAgICAvL2dyYXRpY3VsZVxyXG4gICAgb3V0LmRyYXdHcmF0aWN1bGVfID0gZmFsc2VcclxuXHJcbiAgICAvL2JhY2tncm91bmQgbWFwIHRvZ2dsZSAoZS5nLiBmb3IgZG9ybGluZylcclxuICAgIG91dC5iYWNrZ3JvdW5kTWFwXyA9IHRydWVcclxuXHJcbiAgICAvL2xhYmVsbGluZ1xyXG4gICAgLy8gc2VlIGRvY3NcXHJlZmVyZW5jZS5tZCNsYWJlbGxpbmdcclxuICAgIG91dC5sYWJlbHNfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9hbm5vdGF0aW9uc1xyXG4gICAgb3V0LmFubm90YXRpb25zXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmFubm90YXRpb25zQWRkZWQgPSBmYWxzZSAvL3NpbXBsZSBmbGFnIHRvIGtub3cgd2hlbiBhbm5vdGF0aW9ucyBoYXZlIGFscmVhZHkgYmVlbiBhZGRlZFxyXG5cclxuICAgIC8vZGF0YXNldCBzb3VyY2UgbGlua1xyXG4gICAgb3V0LnNob3dTb3VyY2VMaW5rXyA9IHRydWVcclxuXHJcbiAgICAvL2RlZmF1bHQgY29weXJpZ2h0IGFuZCBkaXNjbGFpbWVyIHRleHRcclxuICAgIG91dC5mb290bm90ZV8gPSAnQWRtaW5pc3RyYXRpdmUgYm91bmRhcmllczogXFx1MDBBOUV1cm9HZW9ncmFwaGljcyBcXHUwMEE5VU4tRkFPIFxcdTAwQTlJTlNUQVQgXFx1MDBBOVR1cmtzdGF0JyAvL1wiKEMpRXVyb0dlb2dyYXBoaWNzIChDKVVOLUZBTyAoQylUdXJrc3RhdFwiO1xyXG4gICAgb3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfID1cclxuICAgICAgICAnVGhlIGRlc2lnbmF0aW9ucyBlbXBsb3llZCBhbmQgdGhlIHByZXNlbnRhdGlvbiBvZiBtYXRlcmlhbCBvbiB0aGlzIG1hcCBkbyBub3QgaW1wbHkgdGhlIGV4cHJlc3Npb24gb2YgYW55IG9waW5pb24gd2hhdHNvZXZlciBvbiB0aGUgcGFydCBvZiB0aGUgRXVyb3BlYW4gVW5pb24gY29uY2VybmluZyB0aGUgbGVnYWwgc3RhdHVzIG9mIGFueSBjb3VudHJ5LCB0ZXJyaXRvcnksIGNpdHkgb3IgYXJlYSBvciBvZiBpdHMgYXV0aG9yaXRpZXMsIG9yIGNvbmNlcm5pbmcgdGhlIGRlbGltaXRhdGlvbiBvZiBpdHMgZnJvbnRpZXJzIG9yIGJvdW5kYXJpZXMuIEtvc292byo6IFRoaXMgZGVzaWduYXRpb24gaXMgd2l0aG91dCBwcmVqdWRpY2UgdG8gcG9zaXRpb25zIG9uIHN0YXR1cywgYW5kIGlzIGluIGxpbmUgd2l0aCBVTlNDUiAxMjQ0LzE5OTkgYW5kIHRoZSBJQ0ogT3BpbmlvbiBvbiB0aGUgS29zb3ZvIGRlY2xhcmF0aW9uIG9mIGluZGVwZW5kZW5jZS4nXHJcblxyXG4gICAgb3V0Lm51dHMyanNvbkJhc2VVUkxfID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmluY2x1ZGVzKCdlYy5ldXJvcGEuZXUnKVxyXG4gICAgICAgID8gJ2h0dHBzOi8vZWMuZXVyb3BhLmV1L2Fzc2V0cy9lc3RhdC9FL0U0L2dpc2NvL3B1Yi9udXRzMmpzb24vdjInXHJcbiAgICAgICAgOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V1cm9zdGF0L051dHMyanNvbi9tYXN0ZXIvcHViL3YyJ1xyXG5cclxuICAgIC8vc3R5bGUgZm9yIG5vIGRhdGEgcmVnaW9uc1xyXG4gICAgb3V0Lm5vRGF0YUZpbGxTdHlsZV8gPSAnI2JjYmNiYydcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2V0cy5cclxuICAgICAqIFRoZSBtYXAgdGVtcGxhdGUgaGFzIGEgcmVjdXJzaXZlIHN0cnVjdHVyZS5cclxuICAgICAqL1xyXG5cclxuICAgIC8vaW5zZXRzIHRvIHNob3csIGFzIGEgbGlzdCBvZiBtYXAgdGVtcGxhdGUgY29uZmlncy4gRXguOiBbe2dlbzpcIk1UXCJ9LHtnZW86XCJMSVwifSx7Z2VvOlwiUFQyMFwifV1cclxuICAgIG91dC5pbnNldHNfID0gW11cclxuICAgIC8vaW5zZXQgdGVtcGxhdGVzIC0gZWFjaCBpbnNldCBpcyBhIG1hcC10ZW1wbGF0ZSBpbnN0YW5jZS5cclxuICAgIG91dC5pbnNldFRlbXBsYXRlc18gPSB7fVxyXG5cclxuICAgIG91dC5pbnNldEJveFBvc2l0aW9uXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0Lmluc2V0Qm94UGFkZGluZ18gPSA1XHJcbiAgICBvdXQuaW5zZXRCb3hXaWR0aF8gPSAyMTBcclxuICAgIC8vb3V0Lmluc2V0Wm9vbUV4dGVudF8gPSBbMSwgM107XHJcbiAgICBvdXQuaW5zZXRab29tRXh0ZW50XyA9IG51bGwgLy96b29tIGRpc2FibGVkIGFzIGRlZmF1bHRcclxuICAgIG91dC5pbnNldFNjYWxlXyA9ICcwM00nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgZm9yIChjb25zdCBhdHQgaW4gb3V0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdhcm4gZXhpc3RpbmcgdXNlcnMgb2YgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGJhbmlzaGVkIHRvIHRoZSBzaGFkb3cgcmVhbG0uXHJcbiAgICBkZWZpbmVEZXByZWNhdGVkRnVuY3Rpb25zKG91dClcclxuXHJcbiAgICAvLyBjb252ZXJ0IGdlbyB0byB1cHBlcmNhc2VcclxuICAgIG91dC5nZW8gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5nZW9fXHJcbiAgICAgICAgb3V0Lmdlb18gPSB2LnRvVXBwZXJDYXNlKClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWFsIG9uZXMgd2hpY2ggYWZmZWN0IGFsc28gdGhlIGluc2V0c1xyXG4gICAgO1sndG9vbHRpcF8nLCAnbnV0czJqc29uQmFzZVVSTF8nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xyXG4gICAgICAgICAgICAgICAgLy9vdmVycmlkZSBkZWZhdWx0IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0W2F0dF1bcF0gPSB2W3BdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9yZWN1cnNpdmUgY2FsbCB0byBpbnNldCBjb21wb25lbnRzXHJcbiAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKFxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5pbnNldFRlbXBsYXRlc18sXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnN2Z0lkXyxcclxuICAgICAgICAgICAgICAgICAgICAoaW5zZXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuTmFtZSA9IGF0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2V0W2ZuTmFtZV0odmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB2XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy90aXRsZSBnZXR0ZXIgYW5kIHNldHRlclxyXG4gICAgb3V0LnRpdGxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQudGl0bGVfXHJcbiAgICAgICAgb3V0LnRpdGxlXyA9IHZcclxuICAgICAgICBpZiAob3V0LnN2ZygpKVxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyN0aXRsZScgKyBvdXQuZ2VvKCkpXHJcbiAgICAgICAgICAgICAgICAudGV4dCh2KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL3N1YnRpdGxlIGdldHRlciBhbmQgc2V0dGVyXHJcbiAgICBvdXQuc3VidGl0bGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5zdWJ0aXRsZV9cclxuICAgICAgICBvdXQuc3VidGl0bGVfID0gdlxyXG4gICAgICAgIGlmIChvdXQuc3ZnKCkpXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnI3N1YnRpdGxlJyArIG91dC5nZW8oKSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KHYpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vaW5zZXRzIGdldHRlci9zZXR0ZXJcclxuICAgIG91dC5pbnNldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0Lmluc2V0c19cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIGFyZ3VtZW50c1swXSA9PT0gJ2RlZmF1bHQnKSBvdXQuaW5zZXRzXyA9ICdkZWZhdWx0J1xyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBhcmd1bWVudHNbMF0gPT09IGZhbHNlKSBvdXQuaW5zZXRzXyA9IGZhbHNlXHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkgb3V0Lmluc2V0c18gPSBhcmd1bWVudHNbMF1cclxuICAgICAgICBlbHNlIG91dC5pbnNldHNfID0gYXJndW1lbnRzXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGR5bmFtaWMgZHJhdyBncmF0aWN1bGVcclxuICAgIG91dC5kcmF3R3JhdGljdWxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuZHJhd0dyYXRpY3VsZV9cclxuICAgICAgICBvdXQuZHJhd0dyYXRpY3VsZV8gPSB2XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGdyYXRpY3VsZVxyXG4gICAgICAgIGxldCBncmF0aWN1bGUgPSBvdXQuc3ZnXyA/IG91dC5zdmcoKS5zZWxlY3QoJyNlbS1ncmF0aWN1bGUnKSA6IG51bGxcclxuICAgICAgICBsZXQgemcgPSBvdXQuc3ZnXyA/IG91dC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pIDogbnVsbFxyXG5cclxuICAgICAgICAvLyBpZiBleGlzdGluZyBhbmQgYXJndW1lbnQgaXMgZmFsc2VcclxuICAgICAgICBpZiAoZ3JhdGljdWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChncmF0aWN1bGUuX2dyb3Vwc1swXVswXSAmJiB2ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIGdyYXRpY3VsZS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIG1hcCBhbHJlYWR5IGNyZWF0ZWQgYW5kIGFyZ3VtZW50IGlzIHRydWVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5ncmF0aWN1bGUgJiYgb3V0Ll9wYXRoRnVuY3Rpb24gJiYgemcgJiYgdiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBleGlzdGluZyBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIGdyYXRpY3VsZS5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIG5ldyBncmF0aWN1bGVcclxuICAgICAgICAgICAgICAgIHpnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMuZ3JhdGljdWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZ3JhdGljdWxlJylcclxuXHJcbiAgICAgICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tZ3JhdGljdWxlJylcclxuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZ3JhdGljdWxlIGJlaGluZCBsYW5kIG1hc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb18gPT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzNdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzFdKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vY29hc3RhbCBtYXJnaW4gb3ZlcnJpZGVcclxuICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmRyYXdDb2FzdGFsTWFyZ2luX1xyXG4gICAgICAgIG91dC5kcmF3Q29hc3RhbE1hcmdpbl8gPSB2XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGV4aXN0aW5nXHJcbiAgICAgICAgaWYgKG91dC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXJnaW4gPSBzZWxlY3RBbGwoJyNlbS1jb2FzdC1tYXJnaW4nKVxyXG4gICAgICAgICAgICBsZXQgZmlsdGVyID0gc2VsZWN0KCcjZW0tY29hc3RhbC1ibHVyJylcclxuICAgICAgICAgICAgbGV0IHpnID0gc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXykgfHwgbnVsbFxyXG4gICAgICAgICAgICBpZiAobWFyZ2luLl9ncm91cHNbMF1bMF0gJiYgdiA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ucmVtb3ZlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2ID09IHRydWUgJiYgb3V0Ll9wYXRoRnVuY3Rpb24gJiYgemcpIHtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGV4aXN0aW5nIGdyYXRpY3VsZVxyXG4gICAgICAgICAgICAgICAgbWFyZ2luLnJlbW92ZSgpXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIucmVtb3ZlKClcclxuICAgICAgICAgICAgICAgIC8vYWRkIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgb3V0LnN2Z19cclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdmaWx0ZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdGFsLWJsdXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICctMjAwJScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzQwMCUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnNDAwJScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZmVHYXVzc2lhbkJsdXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpbicsICdTb3VyY2VHcmFwaGljJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgb3V0LmNvYXN0YWxNYXJnaW5TdGREZXZfKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyBmb3IgbWFpbiBtYXAgLSBnZW9tZXRyaWVzIGFyZSBzdGlsbCBpbiBtZW1vcnkgc28gbm8gcmVidWlsZCBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdOZXdDb2FzdGFsTWFyZ2luID0gKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHpvb20gZ3JvdXAgbWlnaHQgbm90IGJlIGluc2lkZSBtYWluIG1hcCAob3V0LnN2Z18pXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgbmV3IGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2cgPSB6b29tR3JvdXAuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb3VudHJpZXMgYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLl9nZW9tLmNudGJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1jbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShtYXAuX2dlb20uY250Ym4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm4ucHJvcGVydGllcy5jbyA9PT0gJ1QnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIG1hcC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vbnV0cyBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuX2dlb20ubnV0c2JuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1udXRzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEobWFwLl9nZW9tLm51dHNibilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLmNvID09PSAnVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgbWFwLl9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLy93b3JsZCBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuX2dlb20ud29ybGRibilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4tbnV0cycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKG1hcC5fZ2VvbS53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuQ09BU19GTEFHID09PSAnVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgbWFwLl9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGZvciBpbnNldHMgLSByZXF1aXJlcyBnZW9tZXRyaWVzIHNvIHdlIGhhdmUgdG8gcmVidWlsZCBiYXNlIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXyAmJiBvdXQuZHJhd0NvYXN0YWxNYXJnaW5fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBkcmF3TmV3Q29hc3RhbE1hcmdpbilcclxuICAgICAgICAgICAgICAgICAgICBkcmF3TmV3Q29hc3RhbE1hcmdpbihvdXQpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBtYXJnaW4gdG8gYmFjayAoaW4gZnJvbnQgb2Ygc2VhKVxyXG4gICAgICAgICAgICAgICAgc2VsZWN0QWxsKCcjZW0tY29hc3QtbWFyZ2luJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb18gPT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXNbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlc1sxXSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vYW5ub3RhdGlvbnMgb3ZlcnJpZGUgKHVwZGF0ZSBhZnRlciBmaXJzdCBjYWxsKVxyXG4gICAgb3V0LmFubm90YXRpb25zID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvL2dldFxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5hbm5vdGF0aW9uc19cclxuICAgICAgICAvL3NldFxyXG4gICAgICAgIG91dC5hbm5vdGF0aW9uc18gPSB2XHJcbiAgICAgICAgLy91cGRhdGVcclxuICAgICAgICBhcHBlbmRBbm5vdGF0aW9ucyhvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhbXBzIG92ZXJyaWRlICh1cGRhdGUgYWZ0ZXIgZmlyc3QgY2FsbClcclxuICAgIG91dC5zdGFtcCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgLy9nZXRcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuc3RhbXBfXHJcbiAgICAgICAgLy9zZXRcclxuICAgICAgICBvdXQuc3RhbXBfID0gdlxyXG4gICAgICAgIC8vdXBkYXRlXHJcbiAgICAgICAgYXBwZW5kU3RhbXAob3V0LnN0YW1wXywgb3V0KVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL2xhYmVscyBvdmVycmlkZSAodXBkYXRlIGFmdGVyIGZpcnN0IGNhbGwpXHJcbiAgICBvdXQubGFiZWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvL2dldFxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5sYWJlbHNfXHJcbiAgICAgICAgLy9zZXRcclxuICAgICAgICBvdXQubGFiZWxzXyA9IHZcclxuICAgICAgICAvL3VwZGF0ZVxyXG4gICAgICAgIHVwZGF0ZUxhYmVscyhvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGluaXRpYXRlIEdlb21ldHJpZXMgY2xhc3NcclxuICAgIG91dC5HZW9tZXRyaWVzID0gR2VvbWV0cmllcyhvdXQsIHdpdGhDZW50ZXJQb2ludHMpXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0cyBnZW9ncmFwaGljIGRhdGEgYW5kIHRoZW4gYnVpbGRzIHRoZSBtYXAgdGVtcGxhdGVcclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZUdlb01hcFRlbXBsYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gRXJhc2UgcHJldmlvdXMgZGF0YVxyXG4gICAgICAgIG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhID0gbnVsbFxyXG4gICAgICAgIG91dC5HZW9tZXRyaWVzLmFsbE5VVFNHZW9EYXRhID0gbnVsbFxyXG4gICAgICAgIG91dC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGEgPSBudWxsXHJcblxyXG4gICAgICAgIGlmIChvdXQuZ2VvbWV0cmllc18pIHtcclxuICAgICAgICAgICAgb3V0Lkdlb21ldHJpZXMuc2V0VXNlckdlb21ldHJpZXMob3V0Lmdlb21ldHJpZXNfKVxyXG4gICAgICAgICAgICAvLyB1c2UgY3VzdG9tIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgICAgIG91dC5idWlsZE1hcFRlbXBsYXRlKClcclxuXHJcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2sgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1c2UgZGVmYXVsdFxyXG4gICAgICAgICAgICBvdXQuR2VvbWV0cmllcy5nZXREZWZhdWx0R2VvRGF0YShvdXQuZ2VvXywgb3V0LmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbl8sIG91dC5udXRzTGV2ZWxfKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIG91dC5idWlsZE1hcFRlbXBsYXRlKClcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIGV4ZWN1dGVGb3JBbGxJbnNldHMgZm9yIHJlY3Vyc2l2ZSBpbnNldCB1cGRhdGVzXHJcbiAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCAoaW5zZXQpID0+IHtcclxuICAgICAgICAgICAgaW5zZXQudXBkYXRlR2VvTWFwVGVtcGxhdGUoY2FsbGJhY2spXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYSBtYXAgb2JqZWN0LCBpbmNsdWRpbmcgY29udGFpbmVyLCBmcmFtZSwgbWFwIHN2ZywgaW5zZXRzIGFuZCBkMyB6b29tXHJcbiAgICAgKi9cclxuICAgIG91dC5idWlsZE1hcFRlbXBsYXRlQmFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2dldCBzdmcgZWxlbWVudC4gQ3JlYXRlIGl0IGlmIGl0IGRvZXMgbm90IGV4aXN0c1xyXG4gICAgICAgIGxldCBzdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkKCkpXHJcbiAgICAgICAgaWYgKHN2Zy5zaXplKCkgPT0gMCkge1xyXG4gICAgICAgICAgICBzdmcgPSBzZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2lkJywgb3V0LnN2Z0lkKCkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN2Zy5hdHRyKCdjbGFzcycsICdlbS1tYXAnKVxyXG4gICAgICAgIG91dC5zdmdfID0gc3ZnXHJcblxyXG4gICAgICAgIC8vc2V0IGNvbnRhaW5lciBmb3IgY2FzZXMgd2hlcmUgY29udGFpbmVyIGNvbnRhaW5zIHZhcmlvdXMgbWFwc1xyXG4gICAgICAgIGlmICghb3V0LmNvbnRhaW5lcklkXykgb3V0LmNvbnRhaW5lcklkXyA9IG91dC5zdmdJZF9cclxuICAgICAgICAvL3Rvb2x0aXAgbmVlZHMgdG8ga25vdyBjb250YWluZXIgdG8gcHJldmVudCBvdmVyZmxvd1xyXG4gICAgICAgIGlmICghb3V0LnRvb2x0aXBfLmNvbnRhaW5lcklkKSB7XHJcbiAgICAgICAgICAgIG91dC50b29sdGlwXy5jb250YWluZXJJZCA9IG91dC5jb250YWluZXJJZF9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2xlYXIgU1ZHICh0byBhdm9pZCBidWlsZGluZyBtdWx0aXBsZSBzdmdzIG9uIHRvcCBvZiBlYWNoIG90aGVyIGR1cmluZyBtdWx0aXBsZSBidWlsZCgpIGNhbGxzKVxyXG4gICAgICAgIHNlbGVjdEFsbCgnIycgKyBvdXQuc3ZnSWQoKSArICcgPiAqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9zZXQgU1ZHIGRpbWVuc2lvbnNcclxuICAgICAgICBpZiAob3V0Lmdlb18udG9VcHBlckNhc2UoKSA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIC8vaWYgbm8gaGVpZ2h0IHdhcyBzcGVjaWZpZWQsIHVzZSA0NSUgb2YgdGhlIHdpZHRoLlxyXG4gICAgICAgICAgICBpZiAoIW91dC5oZWlnaHQoKSkgb3V0LmhlaWdodCgwLjU1ICogb3V0LndpZHRoKCkpXHJcbiAgICAgICAgICAgIHN2Zy5hdHRyKCd3aWR0aCcsIG91dC53aWR0aCgpKS5hdHRyKCdoZWlnaHQnLCBvdXQuaGVpZ2h0KCkpXHJcblxyXG4gICAgICAgICAgICAvL1dPUkxEIGdlbyBvbmx5IGFjY2VwdHMgcHJvaiA1NDAzMCAocm9iaW5zb24pIGF0IHRoZSBtb21lbnRcclxuICAgICAgICAgICAgb3V0LnByb2pfID0gNTQwMzBcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pZiBubyBoZWlnaHQgd2FzIHNwZWNpZmllZCwgdXNlIDg1JSBvZiB0aGUgd2lkdGguXHJcbiAgICAgICAgaWYgKCFvdXQuaGVpZ2h0KCkpIG91dC5oZWlnaHQoMC44NSAqIG91dC53aWR0aCgpKVxyXG4gICAgICAgIHN2Zy5hdHRyKCd3aWR0aCcsIG91dC53aWR0aCgpKS5hdHRyKCdoZWlnaHQnLCBvdXQuaGVpZ2h0KCkpXHJcblxyXG4gICAgICAgIC8vIGVhY2ggbWFwIHRlbXBsYXRlIG5lZWRzIGEgY2xpcFBhdGggdG8gYXZvaWQgb3ZlcmZsb3cuIFNlZSBHSVNDTy0yNzA3XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZGVmcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1kZWZzJylcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2xpcFBhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCBvdXQuc3ZnSWRfICsgJy1jbGlwLXBhdGgnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBjb252ZXJ0UmVjdGFuZ2xlc1RvUGF0aHMoMCwgMCwgb3V0LndpZHRoXywgb3V0LmhlaWdodF8pKVxyXG5cclxuICAgICAgICBpZiAob3V0LmRyYXdDb2FzdGFsTWFyZ2luXykge1xyXG4gICAgICAgICAgICAvL2RlZmluZSBmaWx0ZXIgZm9yIGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2ZpbHRlcicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3RhbC1ibHVyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICc0MDAlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnNDAwJScpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdmZUdhdXNzaWFuQmx1cicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaW4nLCAnU291cmNlR3JhcGhpYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgb3V0LmNvYXN0YWxNYXJnaW5TdGREZXZfKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgZHJhd2luZyBncm91cCwgYXMgZmlyc3QgY2hpbGRcclxuICAgICAgICBjb25zdCBkZyA9IHN2Z1xyXG4gICAgICAgICAgICAuaW5zZXJ0KCdnJywgJzpmaXJzdC1jaGlsZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1kcmF3aW5nLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZHJhd2luZy1ncm91cCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCMnICsgb3V0LnN2Z0lkXyArICctY2xpcC1wYXRoJyArICcpJylcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgbWFpbiB6b29tIGdyb3VwXHJcbiAgICAgICAgY29uc3QgemcgPSBkZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS16b29tLWdyb3VwJykgLy9vdXQuZ2VvIGNoYW5nZWQgdG8gb3V0LnN2Z0lkIGluIG9yZGVyIHRvIGJlIHVuaXF1ZVxyXG5cclxuICAgICAgICAvLyBidWlsZCBpbnNldHNcclxuICAgICAgICByZW1vdmVJbnNldHMob3V0KSAvL3JlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgIGJ1aWxkSW5zZXRzKG91dCwgd2l0aENlbnRlclBvaW50cykgLy9idWlsZCBuZXdcclxuXHJcbiAgICAgICAgLy9kcmF3IGZyYW1lXHJcbiAgICAgICAgZGcuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWZyYW1lLScgKyBvdXQuZ2VvXylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZyYW1lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC53aWR0aF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuaGVpZ2h0XylcclxuXHJcbiAgICAgICAgaWYgKG91dC5zdGFtcF8pIHtcclxuICAgICAgICAgICAgYXBwZW5kU3RhbXAob3V0LnN0YW1wXywgb3V0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpZCBhbiBlbXB0eSBtYXAgdGVtcGxhdGUsIGJhc2VkIG9uIHRoZSBnZW9tZXRyaWVzIG9ubHkuXHJcbiAgICAgKi9cclxuICAgIG91dC5idWlsZE1hcFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vcHJlcGFyZSBkcmF3aW5nIGdyb3VwXHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2ZygpLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgLy9yZW1vdmUgYWxsIGNoaWxkcmVuXHJcbiAgICAgICAgem9vbUdyb3VwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIHNlcGFyYXRlIGxvZ2ljIGZvciBjYXJ0b2dyYW1zXHJcbiAgICAgICAgaWYgKG91dC5ncmlkQ2FydG9ncmFtXyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkR3JpZENhcnRvZ3JhbUJhc2Uob3V0KVxyXG4gICAgICAgICAgICBvdXQuZm9vdG5vdGVfID0gZmFsc2UgLy9kb250IG5lZWQgY29weXJpZ2h0XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBnZW9ncmFwaGljIGxvZ2ljXHJcblxyXG4gICAgICAgICAgICAvLyBwb3NpdGlvblxyXG4gICAgICAgICAgICBpZiAoIW91dC5wb3NpdGlvbl8ueCB8fCAhb3V0LnBvc2l0aW9uXy55KSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVEZWZhdWx0UG9zaXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dC5wb3NpdGlvbl8ueiA9IG91dC5wb3NpdGlvbl8ueiB8fCBnZXREZWZhdWx0WigpXHJcblxyXG4gICAgICAgICAgICAvLyBkMyBwcm9qZWN0aW9uL3BhdGggZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIGRlZmluZVByb2plY3Rpb24oKVxyXG4gICAgICAgICAgICBkZWZpbmVQYXRoRnVuY3Rpb24oKVxyXG5cclxuICAgICAgICAgICAgLy8gZDMgem9vbVxyXG4gICAgICAgICAgICBpZiAob3V0Lnpvb21FeHRlbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lTWFwWm9vbSgpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQuYmFja2dyb3VuZE1hcF8pIHtcclxuICAgICAgICAgICAgICAgIGRyYXdCYWNrZ3JvdW5kTWFwKG91dClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9wcmVwYXJlIGdyb3VwIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9scywgd2l0aCBjZW50cm9pZHNcclxuICAgICAgICBpZiAod2l0aENlbnRlclBvaW50cykge1xyXG4gICAgICAgICAgICBhZGRDZW50cm9pZHNUb01hcChvdXQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgZ2VvZ3JhcGhpY2FsIGxhYmVscyB0byBtYXBcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18pIHtcclxuICAgICAgICAgICAgYWRkTGFiZWxzVG9NYXAob3V0LCB6b29tR3JvdXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2Fubm90YXRpb25zXHJcbiAgICAgICAgaWYgKG91dC5hbm5vdGF0aW9uc18pIHtcclxuICAgICAgICAgICAgYXBwZW5kQW5ub3RhdGlvbnMob3V0KVxyXG4gICAgICAgICAgICBvdXQuYW5ub3RhdGlvbnNBZGRlZCA9IHRydWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICBpZiAob3V0LnRpdGxlKCkpIHtcclxuICAgICAgICAgICAgLy9kZWZpbmUgZGVmYXVsdCBwb3NpdGlvblxyXG4gICAgICAgICAgICBsZXQgY3NzQ2xhc3MgPSBvdXQuaXNJbnNldCA/ICdlbS1pbnNldC10aXRsZScgOiAnZW0tdGl0bGUnXHJcbiAgICAgICAgICAgIGlmICghb3V0LnRpdGxlUG9zaXRpb24oKSkgb3V0LnRpdGxlUG9zaXRpb24oWzEwLCBnZXRGb250U2l6ZUZyb21DbGFzcyhjc3NDbGFzcykgKyAob3V0LmlzSW5zZXQgPyAwIDogMTApXSlcclxuICAgICAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAndGl0bGUnICsgb3V0Lmdlb18pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBjc3NDbGFzcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LnRpdGxlUG9zaXRpb24oKVswXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnRpdGxlUG9zaXRpb24oKVsxXSlcclxuICAgICAgICAgICAgICAgIC5odG1sKG91dC50aXRsZSgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zdWJ0aXRsZVxyXG4gICAgICAgIGlmIChvdXQuc3VidGl0bGUoKSkge1xyXG4gICAgICAgICAgICBsZXQgY3NzU3VidGl0bGVDbGFzcyA9IG91dC5pc0luc2V0ID8gJ2VtLWluc2V0LXN1YnRpdGxlJyA6ICdlbS1zdWJ0aXRsZSdcclxuICAgICAgICAgICAgbGV0IGNzc1RpdGxlQ2xhc3MgPSBvdXQuaXNJbnNldCA/ICdlbS1pbnNldC10aXRsZScgOiAnZW0tdGl0bGUnXHJcbiAgICAgICAgICAgIC8vZGVmaW5lIGRlZmF1bHQgcG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKCFvdXQuc3VidGl0bGVQb3NpdGlvbigpKSBvdXQuc3VidGl0bGVQb3NpdGlvbihbMTAsIGdldEZvbnRTaXplRnJvbUNsYXNzKGNzc1RpdGxlQ2xhc3MpICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoY3NzU3VidGl0bGVDbGFzcykgKyAxNV0pXHJcbiAgICAgICAgICAgIC8vZHJhdyBzdWJ0aXRsZVxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3N1YnRpdGxlJyArIG91dC5nZW9fKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgY3NzU3VidGl0bGVDbGFzcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LnN1YnRpdGxlUG9zaXRpb24oKVswXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnN1YnRpdGxlUG9zaXRpb24oKVsxXSlcclxuICAgICAgICAgICAgICAgIC5odG1sKG91dC5zdWJ0aXRsZSgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9ib3R0b20gdGV4dFxyXG4gICAgICAgIGlmIChvdXQuZm9vdG5vdGVfKSB7XHJcbiAgICAgICAgICAgIGFkZEZvb3Rub3RlKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc291cmNlIGRhdGFzZXQgVVJMXHJcbiAgICAgICAgaWYgKG91dC5zaG93U291cmNlTGlua18pIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRcclxuICAgICAgICAgICAgaWYgKHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXQgPSBvdXQuc3RhdCgnc2l6ZScpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ID0gb3V0LnN0YXQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdC5ldXJvc3RhdERhdGFzZXRDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kYXRhc2V0IGxpbmtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHN0YXQuZXVyb3N0YXREYXRhc2V0Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBgaHR0cHM6Ly9lYy5ldXJvcGEuZXUvZXVyb3N0YXQvZGF0YWJyb3dzZXIvdmlldy8ke2NvZGV9L2RlZmF1bHQvdGFibGU/bGFuZz1lbmBcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluayA9IG91dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnYScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zb3VyY2UtZGF0YXNldC1saW5rJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCB1cmwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0YXJnZXQnLCAnX2JsYW5rJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zb3VyY2UtZGF0YXNldC1saW5rLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC53aWR0aF8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmhlaWdodF8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KCdFVVJPU1RBVCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3ByZXRleHQgXCJTb3VyY2U6XCJcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlua1cgPSBsaW5rLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKVxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNvdXJjZS1wcmV0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQud2lkdGhfIC0gbGlua1cgLSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5oZWlnaHRfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dCgnU291cmNlOicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzY2FsZWJhclxyXG4gICAgICAgIGlmIChvdXQuc2hvd1NjYWxlYmFyXykge1xyXG4gICAgICAgICAgICBpZiAob3V0LnNjYWxlYmFyUG9zaXRpb25fLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgb3V0LnNjYWxlYmFyUG9zaXRpb25fWzBdID0gMTVcclxuICAgICAgICAgICAgICAgIG91dC5zY2FsZWJhclBvc2l0aW9uX1sxXSA9IG91dC5oZWlnaHRfIC0gNTBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRTY2FsZWJhclRvTWFwKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkcmF3QmFja2dyb3VuZE1hcCA9IGZ1bmN0aW9uIChvdXQpIHtcclxuICAgICAgICAvL2RyYXcgYmFja2dyb3VuZCBtYXBcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBvdXQuc3ZnKCkuc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAvL2RyYXcgc2VhXHJcbiAgICAgICAgem9vbUdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnc2VhJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNlYScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgLTUgKiBvdXQud2lkdGhfKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIC01ICogb3V0LmhlaWdodF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDExICogb3V0LndpZHRoXylcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDExICogb3V0LmhlaWdodF8pXHJcblxyXG4gICAgICAgIC8vc3BoZXJlIGZvciB3b3JsZCBtYXBcclxuICAgICAgICBpZiAob3V0Lmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICB6b29tR3JvdXAuYXBwZW5kKCdwYXRoJykuZGF0dW0oeyB0eXBlOiAnU3BoZXJlJyB9KS5hdHRyKCdpZCcsICdzcGhlcmUnKS5hdHRyKCdkJywgb3V0Ll9wYXRoRnVuY3Rpb24pLmF0dHIoJ2NsYXNzJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb2FzdGFsIG1hcmdpblxyXG4gICAgICAgIGlmIChvdXQuZHJhd0NvYXN0YWxNYXJnaW5fKSB7XHJcbiAgICAgICAgICAgIGFkZENvYXN0YWxNYXJnaW5Ub01hcCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkcmF3IHBvbHlnb25zIGFuZCBib3JkZXJzXHJcbiAgICAgICAgaWYgKG91dC5nZW9tZXRyaWVzXykge1xyXG4gICAgICAgICAgICBvdXQuR2VvbWV0cmllcy5hZGRVc2VyR2VvbWV0cmllc1RvTWFwKG91dC5nZW9tZXRyaWVzXywgem9vbUdyb3VwLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXQuR2VvbWV0cmllcy5hZGREZWZhdWx0R2VvbWV0cmllc1RvTWFwKFxyXG4gICAgICAgICAgICAgICAgem9vbUdyb3VwLFxyXG4gICAgICAgICAgICAgICAgb3V0LmRyYXdHcmF0aWN1bGVfLFxyXG4gICAgICAgICAgICAgICAgb3V0Ll9wYXRoRnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBvdXQubnV0c0xldmVsXyxcclxuICAgICAgICAgICAgICAgIG91dC5udXRzWWVhcl8sXHJcbiAgICAgICAgICAgICAgICBvdXQuZ2VvXyxcclxuICAgICAgICAgICAgICAgIG91dC5wcm9qXyxcclxuICAgICAgICAgICAgICAgIG91dC5zY2FsZV9cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWZpbmVEZWZhdWx0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFBvc2l0aW9uID0gX2RlZmF1bHRQb3NpdGlvbltvdXQuZ2VvXyArICdfJyArIG91dC5wcm9qX11cclxuICAgICAgICBpZiAoZGVmYXVsdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIG91dC5wb3NpdGlvbl8ueCA9IG91dC5wb3NpdGlvbl8ueCB8fCBkZWZhdWx0UG9zaXRpb24uZ2VvQ2VudGVyWzBdXHJcbiAgICAgICAgICAgIG91dC5wb3NpdGlvbl8ueSA9IG91dC5wb3NpdGlvbl8ueSB8fCBkZWZhdWx0UG9zaXRpb24uZ2VvQ2VudGVyWzFdXHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YT8uYmJveCkge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGNlbnRlciBvZiBnZW9EYXRhIGJib3hcclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy54ID0gb3V0LnBvc2l0aW9uXy54IHx8IDAuNSAqIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzBdICsgb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFsyXSlcclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gb3V0LnBvc2l0aW9uXy55IHx8IDAuNSAqIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzFdICsgb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFszXSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL1RPRE86IGF1dG8tZGVmaW5lIHVzZXI9ZGVmaW5lZCBnZW9tZXRyaWVzIGdlb0NlbnRlclxyXG4gICAgICAgICAgICAvLyBvdXQucG9zaXRpb25fLnggPSBHZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzXHJcbiAgICAgICAgICAgIC8vIG91dC5wb3NpdGlvbl8ueSA9IEdlb21ldHJpZXMudXNlckdlb21ldHJpZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9wdGlvbmFsOiBzZXQgZnJvbSBVUkxcclxuICAgICAgICBzZXRWaWV3RnJvbVVSTCgpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2V0RGVmYXVsdFogPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFBvc2l0aW9uID0gX2RlZmF1bHRQb3NpdGlvbltvdXQuZ2VvXyArICdfJyArIG91dC5wcm9qX11cclxuICAgICAgICBpZiAoZGVmYXVsdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZGVmYXVsdFBvc2l0aW9uLnBpeGVsU2l6ZSAqIDgwMCkgLyBvdXQud2lkdGhfXHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YT8uYmJveCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICAob3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFsyXSAtIG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbMF0pIC8gb3V0LndpZHRoXyxcclxuICAgICAgICAgICAgICAgIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzNdIC0gb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFsxXSkgLyBvdXQuaGVpZ2h0X1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEwMFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWZpbmVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERlZmluZSBwcm9qZWN0aW9uIGJhc2VkIG9uIHRoZSBnZW9ncmFwaGljYWwgY29udGV4dFxyXG5cclxuICAgICAgICBpZiAob3V0Lmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgLy8gVXNlIFJvYmluc29uIHByb2plY3Rpb24gZm9yIHRoZSB3b3JsZCB3aXRoIG9wdGlvbmFsIGN1c3RvbSBwcm9qZWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIG91dC5fcHJvamVjdGlvbiA9XHJcbiAgICAgICAgICAgICAgICBvdXQucHJvamVjdGlvbkZ1bmN0aW9uXyB8fFxyXG4gICAgICAgICAgICAgICAgZ2VvUm9iaW5zb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW291dC53aWR0aF8gLyAyLCBvdXQuaGVpZ2h0XyAvIDJdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSgob3V0LndpZHRoXyAtIDIwKSAvICgyICogTWF0aC5QSSkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRm9yIG5vbi1XT1JMRCBnZW8sIHVzZSBjdXN0b20gb3IgZGVmYXVsdCBpZGVudGl0eSBwcm9qZWN0aW9uIHdpdGggY2FsY3VsYXRlZCBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgb3V0Ll9wcm9qZWN0aW9uID1cclxuICAgICAgICAgICAgICAgIG91dC5wcm9qZWN0aW9uRnVuY3Rpb25fIHx8IGdlb0lkZW50aXR5KCkucmVmbGVjdFkodHJ1ZSkuZml0U2l6ZShbb3V0LndpZHRoXywgb3V0LmhlaWdodF9dLCBnZXRCQk9YQXNHZW9KU09OKGdldEN1cnJlbnRCYm94KCkpKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGN1cnJlbnQgdmlldyBhcyBiYm94XHJcbiAgICBjb25zdCBnZXRDdXJyZW50QmJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBoYWxmV2lkdGggPSAwLjUgKiBvdXQucG9zaXRpb25fLnogKiBvdXQud2lkdGhfXHJcbiAgICAgICAgY29uc3QgaGFsZkhlaWdodCA9IDAuNSAqIG91dC5wb3NpdGlvbl8ueiAqIG91dC5oZWlnaHRfXHJcbiAgICAgICAgY29uc3QgYmJveCA9IFtvdXQucG9zaXRpb25fLnggLSBoYWxmV2lkdGgsIG91dC5wb3NpdGlvbl8ueSAtIGhhbGZIZWlnaHQsIG91dC5wb3NpdGlvbl8ueCArIGhhbGZXaWR0aCwgb3V0LnBvc2l0aW9uXy55ICsgaGFsZkhlaWdodF1cclxuICAgICAgICByZXR1cm4gYmJveFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZVBhdGhGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQuX3BhdGhGdW5jdGlvbiA9IGdlb1BhdGgoKS5wcm9qZWN0aW9uKG91dC5fcHJvamVjdGlvbilcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWZpbmVNYXBab29tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBzdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkKCkpXHJcbiAgICAgICAgbGV0IHByZXZpb3VzVCA9IHpvb21JZGVudGl0eVxyXG4gICAgICAgIGNvbnN0IHhvbyA9IHpvb20oKVxyXG4gICAgICAgICAgICAuc2NhbGVFeHRlbnQob3V0Lnpvb21FeHRlbnQoKSlcclxuICAgICAgICAgICAgLm9uKCd6b29tJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRyYW5zZm9ybVxyXG4gICAgICAgICAgICAgICAgaWYgKHQuayAhPT0gcHJldmlvdXNULmspIHtcclxuICAgICAgICAgICAgICAgICAgICB6b29tSGFuZGxlcihlLCBwcmV2aW91c1QpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhbkhhbmRsZXIoZSlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBkZWZhdWx0IHRyYW5zZm9ybSB0byBtYXBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21Hcm91cCA9IG91dC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgICAgICAgICB6b29tR3JvdXAuYXR0cigndHJhbnNmb3JtJywgdClcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVCA9IHRcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgc3ZnLmNhbGwoeG9vKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFpvb20gaGFuZGxlciBmdW5jdGlvblxyXG4gICAgY29uc3Qgem9vbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQsIHByZXZpb3VzVCkge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybVxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByb2plY3RlZCBjZW50ZXJcclxuICAgICAgICBjb25zdCBjZW50ZXJYID0gKG91dC53aWR0aF8gLyAyIC0gdHJhbnNmb3JtLngpIC8gdHJhbnNmb3JtLmtcclxuICAgICAgICBjb25zdCBjZW50ZXJZID0gKG91dC5oZWlnaHRfIC8gMiAtIHRyYW5zZm9ybS55KSAvIHRyYW5zZm9ybS5rXHJcblxyXG4gICAgICAgIC8vIFVzZSB0aGUgcHJvamVjdGlvbiB0byBnZXQgdGhlIHByb2plY3RlZCBjZW50ZXIgaW4gRVBTRzozMDM1XHJcbiAgICAgICAgY29uc3QgW3Byb2plY3RlZFgsIHByb2plY3RlZFldID0gb3V0Ll9wcm9qZWN0aW9uLmludmVydChbY2VudGVyWCwgY2VudGVyWV0pXHJcblxyXG4gICAgICAgIC8vIHNldCBuZXcgcG9zaXRpb25cclxuICAgICAgICBvdXQucG9zaXRpb25fLnggPSBwcm9qZWN0ZWRYXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gcHJvamVjdGVkWVxyXG4gICAgICAgIG91dC5wb3NpdGlvbl8ueiA9IGdldE1ldHJlc1BlclBpeGVsKHRyYW5zZm9ybS5rIC8gcHJldmlvdXNULmspXHJcblxyXG4gICAgICAgIC8vIGFkanVzdCBzdHJva2UgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAgICBzY2FsZVN0cm9rZVdpZHRocyh0cmFuc2Zvcm0pXHJcblxyXG4gICAgICAgIC8vIGFkanVzdCBzdHJva2UgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAgICBpZiAob3V0LmxhYmVsc18/LnZhbHVlcykgc2NhbGVMYWJlbFRleHRzKHRyYW5zZm9ybSlcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHN0cm9rZSBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXz8uYmFja2dyb3VuZHMpIHNjYWxlTGFiZWxCYWNrZ3JvdW5kcyh0cmFuc2Zvcm0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYWRqdXN0cyB0ZXh0IGVsZW1lbnRzIGR5bmFtaWNhbGx5IGFjY29yZGluZyB0byB6b29tXHJcbiAgICAgKiBAcGFyYW0geyp9IHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBjb25zdCBzY2FsZUxhYmVsQmFja2dyb3VuZHMgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHpvb21Hcm91cC5zZWxlY3RBbGwoJy5lbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgICAgICBjb25zdCB6b29tRmFjdG9yID0gdHJhbnNmb3JtLmtcclxuICAgICAgICBjb25zdCB1cGRhdGVzID0gW11cclxuXHJcbiAgICAgICAgZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0LCB4LCBhbmQgeSBmcm9tIGRhdGEgYXR0cmlidXRlcyBvciBjdXJyZW50IGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLXdpZHRoJykpIHx8IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCd3aWR0aCcpKVxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLWhlaWdodCcpKSB8fCBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cignaGVpZ2h0JykpXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsWCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLXgnKSkgfHwgcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ3gnKSlcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxZID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEteScpKSB8fCBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cigneScpKVxyXG5cclxuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGVsZW1lbnRzIHRoYXQgaGF2ZSB2YWxpZCB3aWR0aCwgaGVpZ2h0LCB4LCBhbmQgeVxyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxXaWR0aCA+IDAgJiYgb3JpZ2luYWxIZWlnaHQgPiAwICYmICFpc05hTihvcmlnaW5hbFgpICYmICFpc05hTihvcmlnaW5hbFkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgd2lkdGgsIGhlaWdodCwgeCwgYW5kIHkgZm9yIHRoZSBmaXJzdCB0aW1lIGlmIG5vdCBhbHJlYWR5IHN0b3JlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmF0dHIoJ2RhdGEtd2lkdGgnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS13aWR0aCcsIG9yaWdpbmFsV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLWhlaWdodCcsIG9yaWdpbmFsSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS14Jywgb3JpZ2luYWxYKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS15Jywgb3JpZ2luYWxZKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFyZ2V0IHdpZHRoLCBoZWlnaHQsIHgsIGFuZCB5IGJhc2VkIG9uIHpvb20gZmFjdG9yIChpbnZlcnNlIHNjYWxpbmcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IG9yaWdpbmFsV2lkdGggKiAoMSAvIHpvb21GYWN0b3IpIC8vIEludmVyc2Ugc2NhbGluZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQgKiAoMSAvIHpvb21GYWN0b3IpIC8vIEludmVyc2Ugc2NhbGluZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0WCA9IG9yaWdpbmFsWCAqICgxIC8gem9vbUZhY3RvcikgLy8gQWRqdXN0IHggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFkgPSBvcmlnaW5hbFkgKiAoMSAvIHpvb21GYWN0b3IpIC8vIEFkanVzdCB5IHBvc2l0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzdHlsZSBjaGFuZ2UgdG8gYSBiYXRjaCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKHsgZWxlbWVudCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdGFyZ2V0WCwgdGFyZ2V0WSB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgYWxsIHN0eWxlIGNoYW5nZXMgYXQgb25jZVxyXG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaCgoeyBlbGVtZW50LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRYLCB0YXJnZXRZIH0pID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5hdHRyKCd3aWR0aCcsIHRhcmdldFdpZHRoKS5hdHRyKCdoZWlnaHQnLCB0YXJnZXRIZWlnaHQpLmF0dHIoJ3gnLCB0YXJnZXRYKS5hdHRyKCd5JywgdGFyZ2V0WSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYWRqdXN0cyB0ZXh0IGVsZW1lbnRzIGR5bmFtaWNhbGx5IGFjY29yZGluZyB0byB6b29tXHJcbiAgICAgKiBAcGFyYW0geyp9IHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBjb25zdCBzY2FsZUxhYmVsVGV4dHMgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSB6b29tR3JvdXAuc2VsZWN0KCcjZW0tbGFiZWxzJylcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGxhYmVscy5zZWxlY3RBbGwoJyonKSAvLyBTZWxlY3QgYWxsIGxhYmVsc1xyXG4gICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXVxyXG5cclxuICAgICAgICBlbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcylcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBmb250LXNpemUgZnJvbSBpbmxpbmUgb3IgY29tcHV0ZWQgc3R5bGVcclxuICAgICAgICAgICAgY29uc3QgaW5saW5lRm9udFNpemUgPSBlbGVtZW50LmF0dHIoJ2ZvbnQtc2l6ZScpXHJcbiAgICAgICAgICAgIGNvbnN0IGNzc0ZvbnRTaXplID0gY29tcHV0ZWRTdHlsZS5mb250U2l6ZVxyXG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IGlubGluZUZvbnRTaXplIHx8IGNzc0ZvbnRTaXplXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZWxlbWVudHMgdGhhdCBoYXZlIGEgZm9udCBzaXplIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKGZvbnRTaXplICYmIHBhcnNlRmxvYXQoZm9udFNpemUpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxGb250U2l6ZSA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLWZzJykpIHx8IHBhcnNlRmxvYXQoaW5saW5lRm9udFNpemUpIHx8IHBhcnNlRmxvYXQoY3NzRm9udFNpemUpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGZvbnQgc2l6ZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5hdHRyKCdkYXRhLWZzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2RhdGEtZnMnLCBvcmlnaW5hbEZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFyZ2V0IGZvbnQgc2l6ZSBiYXNlZCBvbiB6b29tIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Rm9udFNpemUgPSBvcmlnaW5hbEZvbnRTaXplIC8gem9vbUZhY3RvclxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc3R5bGUgY2hhbmdlIHRvIGEgYmF0Y2ggYXJyYXlcclxuICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaCh7IGVsZW1lbnQ6IHRoaXMsIHRhcmdldEZvbnRTaXplIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBBcHBseSBhbGwgc3R5bGUgY2hhbmdlcyBhdCBvbmNlXHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKCh7IGVsZW1lbnQsIHRhcmdldEZvbnRTaXplIH0pID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnZm9udC1zaXplJywgYCR7dGFyZ2V0Rm9udFNpemV9cHhgLCAnaW1wb3J0YW50JylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGFkanVzdHMgYWxsIHN0cm9rZS13aWR0aHMgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAqIEBwYXJhbSB7Kn0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNjYWxlU3Ryb2tlV2lkdGhzID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIGNvbnN0IHpvb21Hcm91cCA9IG91dC5zdmdfLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB6b29tR3JvdXAuc2VsZWN0QWxsKCcqJykgLy8gU2VsZWN0IGFsbCBlbGVtZW50cyBpbiB0aGUgem9vbSBncm91cFxyXG4gICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXVxyXG5cclxuICAgICAgICBlbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcylcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBzdHJva2Utd2lkdGggZnJvbSBpbmxpbmUgb3IgY29tcHV0ZWQgc3R5bGVcclxuICAgICAgICAgICAgY29uc3QgaW5saW5lU3Ryb2tlV2lkdGggPSBlbGVtZW50LmF0dHIoJ3N0cm9rZS13aWR0aCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGNzc1N0cm9rZVdpZHRoID0gY29tcHV0ZWRTdHlsZS5zdHJva2VXaWR0aFxyXG4gICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IGlubGluZVN0cm9rZVdpZHRoIHx8IGNzc1N0cm9rZVdpZHRoXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZWxlbWVudHMgdGhhdCBoYXZlIGEgc3Ryb2tlIHdpZHRoIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKHN0cm9rZVdpZHRoICYmIHBhcnNlRmxvYXQoc3Ryb2tlV2lkdGgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdHJva2VXaWR0aCA9IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdkYXRhLXN3JykpIHx8IHBhcnNlRmxvYXQoaW5saW5lU3Ryb2tlV2lkdGgpIHx8IHBhcnNlRmxvYXQoY3NzU3Ryb2tlV2lkdGgpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHN0cm9rZSB3aWR0aCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5hdHRyKCdkYXRhLXN3JykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2RhdGEtc3cnLCBvcmlnaW5hbFN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFyZ2V0IHN0cm9rZSB3aWR0aFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0U3Ryb2tlV2lkdGggPSBvcmlnaW5hbFN0cm9rZVdpZHRoIC8gem9vbUZhY3RvclxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc3R5bGUgY2hhbmdlIHRvIGEgYmF0Y2ggYXJyYXlcclxuICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaCh7IGVsZW1lbnQ6IHRoaXMsIHRhcmdldFN0cm9rZVdpZHRoIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBBcHBseSBhbGwgc3R5bGUgY2hhbmdlcyBhdCBvbmNlXHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKCh7IGVsZW1lbnQsIHRhcmdldFN0cm9rZVdpZHRoIH0pID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnc3Ryb2tlLXdpZHRoJywgYCR7dGFyZ2V0U3Ryb2tlV2lkdGh9cHhgLCAnaW1wb3J0YW50JylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGdldCB0aGUgY3VycmVudCB2aWV3J3MgbWV0cmVzIHBlciBwaXhlbCwgYmFzZWQgb24gYSB6b29tRmFjdG9yXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbUZhY3RvciB0aGlzIHpvb20gLyBwcmV2aW91cyB6b29tXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldE1ldHJlc1BlclBpeGVsID0gZnVuY3Rpb24gKHpvb21GYWN0b3IpIHtcclxuICAgICAgICAvLyBHZXQgY3VycmVudCBib3VuZGluZyBib3ggd2lkdGggaW4gbWV0ZXJzXHJcbiAgICAgICAgY29uc3QgYmJveCA9IGdldEN1cnJlbnRCYm94KClcclxuICAgICAgICBjb25zdCBiYm94V2lkdGggPSBiYm94WzJdIC0gYmJveFswXSAvLyBCQk9YIHdpZHRoIGluIG1ldGVyc1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbWV0ZXJzIHBlciBwaXhlbFxyXG4gICAgICAgIGNvbnN0IG1ldGVyc1BlclBpeGVsID0gYmJveFdpZHRoIC8gKG91dC53aWR0aF8gKiB6b29tRmFjdG9yKVxyXG5cclxuICAgICAgICByZXR1cm4gbWV0ZXJzUGVyUGl4ZWxcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYW4gaGFuZGxlciBmdW5jdGlvblxyXG4gICAgY29uc3QgcGFuSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCwgcHJldmlvdXNUKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZXZlbnQudHJhbnNmb3JtXHJcblxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByb2plY3RlZCBjZW50ZXJcclxuICAgICAgICBjb25zdCBjZW50ZXJYID0gKG91dC53aWR0aF8gLyAyIC0gdHJhbnNmb3JtLngpIC8gdHJhbnNmb3JtLmtcclxuICAgICAgICBjb25zdCBjZW50ZXJZID0gKG91dC5oZWlnaHRfIC8gMiAtIHRyYW5zZm9ybS55KSAvIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgbGV0IFtnZW9YLCBnZW9ZXSA9IG91dC5fcHJvamVjdGlvbi5pbnZlcnQoW2NlbnRlclgsIGNlbnRlclldKVxyXG5cclxuICAgICAgICAvLyBDbGFtcCBnZW9YIGFuZCBnZW9ZIHRvIG1heCBib3VuZHMgYW5kIGFkanVzdCB0aGUgZXZlbnQgdHJhbnNmb3JtXHJcbiAgICAgICAgaWYgKG91dC5tYXhCb3VuZHNfLnhNaW4gIT09IHVuZGVmaW5lZCAmJiBnZW9YIDwgb3V0Lm1heEJvdW5kc18ueE1pbikge1xyXG4gICAgICAgICAgICBnZW9YID0gb3V0Lm1heEJvdW5kc18ueE1pblxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0ueCA9IG91dC53aWR0aF8gLyAyIC0gb3V0Ll9wcm9qZWN0aW9uKFtnZW9YLCBnZW9ZXSlbMF0gKiB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3V0Lm1heEJvdW5kc18ueU1pbiAhPT0gdW5kZWZpbmVkICYmIGdlb1kgPCBvdXQubWF4Qm91bmRzXy55TWluKSB7XHJcbiAgICAgICAgICAgIGdlb1kgPSBvdXQubWF4Qm91bmRzXy55TWluXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS55ID0gb3V0LmhlaWdodF8gLyAyIC0gb3V0Ll9wcm9qZWN0aW9uKFtnZW9YLCBnZW9ZXSlbMV0gKiB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3V0Lm1heEJvdW5kc18ueE1heCAhPT0gdW5kZWZpbmVkICYmIGdlb1ggPiBvdXQubWF4Qm91bmRzXy54TWF4KSB7XHJcbiAgICAgICAgICAgIGdlb1ggPSBvdXQubWF4Qm91bmRzXy54TWF4XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS54ID0gb3V0LndpZHRoXyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVswXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXQubWF4Qm91bmRzXy55TWF4ICE9PSB1bmRlZmluZWQgJiYgZ2VvWSA+IG91dC5tYXhCb3VuZHNfLnlNYXgpIHtcclxuICAgICAgICAgICAgZ2VvWSA9IG91dC5tYXhCb3VuZHNfLnlNYXhcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnkgPSBvdXQuaGVpZ2h0XyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVsxXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzZXQgbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy54ID0gZ2VvWFxyXG4gICAgICAgIG91dC5wb3NpdGlvbl8ueSA9IGdlb1lcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHgseSx6IGVsZW1lbnRzIGZyb20gVVJMIGFuZCBhc3NpZ24gdGhlbSB0byB0aGUgdmlldy4gKi9cclxuICAgIGNvbnN0IHNldFZpZXdGcm9tVVJMID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHggPSBnZXRQYXJhbWV0ZXJCeU5hbWUoJ3gnKSxcclxuICAgICAgICAgICAgeSA9IGdldFBhcmFtZXRlckJ5TmFtZSgneScpLFxyXG4gICAgICAgICAgICB6ID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCd6JylcclxuICAgICAgICBpZiAoeCAhPSBudWxsICYmIHggIT0gdW5kZWZpbmVkICYmICFpc05hTigreCkpIG91dC5wb3NpdGlvbl8ueCA9ICt4XHJcbiAgICAgICAgaWYgKHkgIT0gbnVsbCAmJiB5ICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4oK3kpKSBvdXQucG9zaXRpb25fLnkgPSAreVxyXG4gICAgICAgIGlmICh6ICE9IG51bGwgJiYgeiAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt6KSkgb3V0LnBvc2l0aW9uXy56ID0gK3pcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRGb290bm90ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1mb290bm90ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1mb290bm90ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuaGVpZ2h0XylcclxuICAgICAgICAgICAgLmh0bWwob3V0LmZvb3Rub3RlXylcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuX3Rvb2x0aXAubXdfX18gPSBvdXQuX3Rvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcpXHJcbiAgICAgICAgICAgICAgICBvdXQuX3Rvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcsICc0MDBweCcpXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfKSBvdXQuX3Rvb2x0aXAubW91c2VvdmVyKG91dC5mb290bm90ZVRvb2x0aXBUZXh0XylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5mb290bm90ZVRvb2x0aXBUZXh0Xykgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuZm9vdG5vdGVUb29sdGlwVGV4dF8pIG91dC5fdG9vbHRpcC5tb3VzZW91dChlKVxyXG4gICAgICAgICAgICAgICAgb3V0Ll90b29sdGlwLnN0eWxlKCdtYXgtd2lkdGgnLCBvdXQuX3Rvb2x0aXAubXdfX18pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkQ29hc3RhbE1hcmdpblRvTWFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHpnID0gb3V0LnN2ZygpLnNlbGVjdCgnI2VtLXpvb20tZ3JvdXAtJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgLy9kcmF3IGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgY29uc3QgY2cgPSB6Zy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4nKS5hdHRyKCdjbGFzcycsICdlbS1jb2FzdC1tYXJnaW4nKVxyXG5cclxuICAgICAgICAvL2NvdW50cmllcyBiblxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5jbnRibikge1xyXG4gICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1jbnQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNvYXN0LW1hcmdpbi1jbnQnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5jbnRibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLmNvID09PSAnVCdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgb3V0Ll9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL251dHMgYm5cclxuICAgICAgICBpZiAob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c2JuKSB7XHJcbiAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLW51dHMnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNvYXN0LW1hcmdpbi1udXRzJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c2JuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuY28gPT09ICdUJ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vd29ybGQgYm5cclxuICAgICAgICBpZiAob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMud29ybGRibikge1xyXG4gICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi13b3JsZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY29hc3QtbWFyZ2luLXdvcmxkJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEob3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMud29ybGRibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLkNPQVNfRkxBRyA9PT0gJ1QnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIG91dC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRDZW50cm9pZHNUb01hcCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBsZXQgY2VudHJvaWRGZWF0dXJlc1xyXG5cclxuICAgICAgICBpZiAoIW1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGEpIHtcclxuICAgICAgICAgICAgLy8gaWYgY2VudHJvaWRzIGRhdGEgaXMgYWJzZW50IChlLmcuIGZvciB3b3JsZCBtYXBzKSB0aGVuIGNhbGN1bGF0ZSBtYW51YWxseVxyXG4gICAgICAgICAgICBpZiAobWFwLmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgY2VudHJvaWRGZWF0dXJlcyA9IFtdXHJcbiAgICAgICAgICAgICAgICBtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy53b3JsZHJnLmZvckVhY2goKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RmVhdHVyZSA9IHsgLi4uZmVhdHVyZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGZvciBGcmFuY2UgKGJlY2F1c2UgZ3V5YW5lKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT0gJ0ZSJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGZWF0dXJlLmdlb21ldHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFsyLjIsIDQ2LjJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BvaW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZlYXR1cmUuZ2VvbWV0cnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogZ2VvQ2VudHJvaWQoZmVhdHVyZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkRmVhdHVyZXMucHVzaChuZXdGZWF0dXJlKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50cm9pZEZlYXR1cmVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGFbMF0uZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YVsxXS5mZWF0dXJlcyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5tYXAuR2VvbWV0cmllcy5jZW50cm9pZHNEYXRhWzJdLmZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGFbM10uZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjZW50cm9pZEZlYXR1cmVzID0gbWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YS5mZWF0dXJlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWFwLnByb2Nlc3NDZW50cm9pZHNfKSBjZW50cm9pZEZlYXR1cmVzID0gbWFwLnByb2Nlc3NDZW50cm9pZHNfKGNlbnRyb2lkRmVhdHVyZXMpXHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzY3JlZW4gY29vcmRpbmF0ZXMgYW5kIHNhdmUgY2VudHJvaWRzIHRvIG1hcFxyXG4gICAgICAgIG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMgPSBjZW50cm9pZEZlYXR1cmVzLm1hcCgoZCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29vcmRzID0gbWFwLl9wcm9qZWN0aW9uKGQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICAgIGQucHJvcGVydGllcy5jZW50cm9pZCA9IGNvb3Jkc1xyXG4gICAgICAgICAgICByZXR1cm4gZFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIGVtLXByb3Atc3ltYm9scyBpcyB0aGUgZyBlbGVtZW50IGNvbnRhaW5pbmcgYWxsIHByb3BvcnRpb25hbCBzeW1ib2xzIGZvciB0aGUgbWFwXHJcbiAgICAgICAgY29uc3QgemcgPSBtYXAuc3ZnKCkuc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICBjb25zdCBnY3AgPSB6Zy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1wcm9wLXN5bWJvbHMnKVxyXG5cclxuICAgICAgICAvLyBhZGQgY2VudHJvaWQgZW0tY2VudHJvaWQgZWxlbWVudHNcclxuICAgICAgICAvLyB0aGVuIHN5bWJvbHMgYXJlIGRyYXduL2FwcGVuZGVkIHRvIHRoZXNlIGNvbnRhaW5lcnMgaW4gdGhlIG1hcC10eXBlIGpzIGZpbGVcclxuICAgICAgICBjb25zdCBzeW1ib2xDb250YWluZXJzID0gZ2NwXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShtYXAuR2VvbWV0cmllcy5jZW50cm9pZEZlYXR1cmVzKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzBdLnRvRml4ZWQoMykgKyAnLCcgKyBkLnByb3BlcnRpZXMuY2VudHJvaWRbMV0udG9GaXhlZCgzKSArICcpJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY2VudHJvaWQnKSAvLyBPVVIgU1lNQk9MIENPTlRBSU5FUlxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gJ3BzJyArIGQucHJvcGVydGllcy5pZClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBhZGRTY2FsZWJhclRvTWFwXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYXBwZW5kcyBhbiBTVkcgc2NhbGViYXIgdG8gdGhlIG1hcC4gVXNlcyBwaXhlbFNpemUgdG8gY2FsY3VsYXRlIHVuaXRzIGluIGttXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFkZFNjYWxlYmFyVG9NYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSnVsaWVuJ3MgbmljZSBzY2FsZWJhcnNcclxuICAgICAgICBjb25zdCBtYXJnaW5MZWZ0ID0gNVxyXG4gICAgICAgIGNvbnN0IG1heExlbmd0aFBpeCA9IG91dC5zY2FsZWJhck1heFdpZHRoX1xyXG4gICAgICAgIGNvbnN0IHRleHRPZmZzZXRYID0gb3V0LnNjYWxlYmFyVGV4dE9mZnNldF9bMF1cclxuICAgICAgICBjb25zdCB0ZXh0T2Zmc2V0WSA9IG91dC5zY2FsZWJhclRleHRPZmZzZXRfWzFdXHJcbiAgICAgICAgY29uc3QgcGl4ZWxTaXplTSA9IG91dC5wb3NpdGlvbl8uelxyXG4gICAgICAgIGNvbnN0IG1heExlbmd0aE0gPSBtYXhMZW5ndGhQaXggKiBwaXhlbFNpemVNXHJcbiAgICAgICAgY29uc3QgbmljZUxlbmd0aE0gPSBuaWNlU2NhbGVCYXJMZW5ndGgobWF4TGVuZ3RoTSlcclxuICAgICAgICBjb25zdCBuaWNlTGVuZ3RoUGl4ZWwgPSBuaWNlTGVuZ3RoTVswXSAvIHBpeGVsU2l6ZU1cclxuICAgICAgICBjb25zdCBzY2FsZUJhclN0YXJ0RGlnaXQgPSBuaWNlTGVuZ3RoTVsxXVxyXG4gICAgICAgIGNvbnN0IHN1YmRpdmlzaW9uTmJzID0ge1xyXG4gICAgICAgICAgICAxOiA0LFxyXG4gICAgICAgICAgICAyOiAyLFxyXG4gICAgICAgICAgICA1OiA1LFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGViYXJHcm91cCA9IG91dFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhcicpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7b3V0LnNjYWxlYmFyUG9zaXRpb25fWzBdfSwke291dC5zY2FsZWJhclBvc2l0aW9uX1sxXX0pYClcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgbWF4TGVuZ3RoUGl4ICsgMjApXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2NhbGViYXJIZWlnaHRfKVxyXG5cclxuICAgICAgICAvLyB0b3AgbGluZSBmdWxsIHdpZHRoXHJcbiAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCBuaWNlTGVuZ3RoUGl4ZWwgKyBtYXJnaW5MZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCAxKVxyXG5cclxuICAgICAgICAvL2JvdHRvbSBsaW5lIGZ1bGwgd2lkdGhcclxuICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIG91dC5zY2FsZWJhclNlZ21lbnRIZWlnaHRfKVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCBuaWNlTGVuZ3RoUGl4ZWwgKyBtYXJnaW5MZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCBvdXQuc2NhbGViYXJTZWdtZW50SGVpZ2h0XylcclxuXHJcbiAgICAgICAgLy9maXJzdCB0aWNrXHJcbiAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCBvdXQuc2NhbGViYXJUaWNrSGVpZ2h0XylcclxuXHJcbiAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW5MZWZ0ICsgdGV4dE9mZnNldFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8gKyB0ZXh0T2Zmc2V0WSlcclxuICAgICAgICAgICAgLnRleHQoJzAnKVxyXG5cclxuICAgICAgICAvL21pZGRsZSB0aWNrc1xyXG4gICAgICAgIGNvbnN0IHN1YmRpdmlzaW9uTmIgPSBzdWJkaXZpc2lvbk5ic1tzY2FsZUJhclN0YXJ0RGlnaXRdXHJcbiAgICAgICAgY29uc3QgZGl2aXNpb25XaWR0aCA9IG5pY2VMZW5ndGhQaXhlbCAvIHN1YmRpdmlzaW9uTmJcclxuICAgICAgICBjb25zdCBkaXZpc2lvbk1pbldpZHRoID0gMTVcclxuICAgICAgICBpZiAoZGl2aXNpb25XaWR0aCA+PSBkaXZpc2lvbk1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3ViZGl2aXNpb25OYjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfKVxyXG4gICAgICAgICAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW5MZWZ0ICsgdGV4dE9mZnNldFggKyBpICogZGl2aXNpb25XaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfICsgdGV4dE9mZnNldFkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZ2V0U2NhbGViYXJMYWJlbCgobmljZUxlbmd0aE1bMF0gLyBzdWJkaXZpc2lvbk5iKSAqIGkpKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2V2ZXJ5IG90aGVyIHNlZ21lbnQgbWlkLWxpbmVcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IC0xOyBpIDwgc3ViZGl2aXNpb25OYjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8gLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBvdXQuc2NhbGViYXJTZWdtZW50SGVpZ2h0XyAvIDIpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4MSA9IG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgKGkgLSAxKSAqIGRpdmlzaW9uV2lkdGhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBvdXQuc2NhbGViYXJTZWdtZW50SGVpZ2h0XyAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8gLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSBmdWxsLWxlbmd0aCBob3Jpem9udGFsIG1pZC1saW5lXHJcbiAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgbWFyZ2luTGVmdCArIG91dC5zY2FsZWJhclN0cm9rZVdpZHRoXyAtIDEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBvdXQuc2NhbGViYXJTZWdtZW50SGVpZ2h0XyAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGRpdmlzaW9uV2lkdGggKiBzdWJkaXZpc2lvbk5iKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8gLyAyKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sYXN0IHRpY2tcclxuICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfKVxyXG4gICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbmljZUxlbmd0aFBpeGVsICsgbWFyZ2luTGVmdCArIHRleHRPZmZzZXRYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfICsgdGV4dE9mZnNldFkpXHJcbiAgICAgICAgICAgIC50ZXh0KGdldFNjYWxlYmFyTGFiZWwobmljZUxlbmd0aE1bMF0pICsgb3V0LnNjYWxlYmFyVW5pdHNfKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5pY2VTY2FsZUJhckxlbmd0aCA9IGZ1bmN0aW9uIChzY2FsZUJhckxlbmd0aCkge1xyXG4gICAgICAgIC8vY29tcHV0ZSB0aGUgJ25pY2UnIHBvd2VyIG9mIHRlblxyXG4gICAgICAgIGNvbnN0IHBvdzEwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc2NhbGVCYXJMZW5ndGgpIC8gTWF0aC5sb2coMTApKSlcclxuXHJcbiAgICAgICAgLy9jaGVjayBpZiA1IHRpbWVzIHRoaXMgdmFsdWUgZml0c1xyXG4gICAgICAgIGlmICg1ICogcG93MTAgPD0gc2NhbGVCYXJMZW5ndGgpIHJldHVybiBbNSAqIHBvdzEwLCA1XVxyXG5cclxuICAgICAgICAvL2NoZWNrIGlmIDIgdGltZXMgdGhpcyB2YWx1ZSBmaXRzXHJcbiAgICAgICAgaWYgKDIgKiBwb3cxMCA8PSBzY2FsZUJhckxlbmd0aCkgcmV0dXJuIFsyICogcG93MTAsIDJdXHJcblxyXG4gICAgICAgIC8vcmV0dXJucyB0aGUgcG93ZXIgb2YgdGVuXHJcbiAgICAgICAgcmV0dXJuIFtwb3cxMCwgMV1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZXRTY2FsZWJhckxhYmVsID0gZnVuY3Rpb24gKHZhbHVlTSkge1xyXG4gICAgICAgIGlmICh2YWx1ZU0gPCAwLjAxKSByZXR1cm4gdmFsdWVNICogMTAwMCArICdtbSdcclxuICAgICAgICBpZiAodmFsdWVNIDwgMSkgcmV0dXJuIHZhbHVlTSAqIDEwMCArICdjbSdcclxuICAgICAgICBpZiAodmFsdWVNIDwgMTAwMCkgcmV0dXJuIHZhbHVlTSAqIDEgKyAnbSdcclxuICAgICAgICByZXR1cm4gdmFsdWVNIC8gMTAwMFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqIERlZmF1bHQgZ2VvY2VudGVyIHBvc2l0aW9ucyBhbmQgcGl4ZWxTaXplIChmb3IgZGVmYXVsdCB3aWR0aCA9IDgwMHB4KSBmb3IgdGVycml0b3JpZXMgYW5kIHByb2plY3Rpb25zLiAqL1xyXG5jb25zdCBfZGVmYXVsdFBvc2l0aW9uID0ge1xyXG4gICAgRVVSXzMwMzU6IHsgZ2VvQ2VudGVyOiBbNDk3MDAwMCwgMzM1MDAwMF0sIHBpeGVsU2l6ZTogNjgwMCB9LFxyXG4gICAgSUNfMzI2Mjg6IHsgZ2VvQ2VudGVyOiBbNDQzNDY4LCAzMTQ1NjQ3XSwgcGl4ZWxTaXplOiAxMDAwIH0sXHJcbiAgICBHUF8zMjYyMDogeyBnZW9DZW50ZXI6IFs2Njk0OTgsIDE3ODQ1NTJdLCBwaXhlbFNpemU6IDEzMCB9LFxyXG4gICAgTVFfMzI2MjA6IHsgZ2VvQ2VudGVyOiBbNzE2NTIxLCAxNjIxMzIyXSwgcGl4ZWxTaXplOiAxMzAgfSxcclxuICAgIEdGXzMyNjIyOiB7IGdlb0NlbnRlcjogWzI2Njg1MiwgNDQ0MDc0XSwgcGl4ZWxTaXplOiA1MDAgfSxcclxuICAgIFJFXzMyNzQwOiB7IGdlb0NlbnRlcjogWzM0ODAxMSwgNzY2MTYyN10sIHBpeGVsU2l6ZTogMTMwIH0sXHJcbiAgICBZVF8zMjczODogeyBnZW9DZW50ZXI6IFs1MTY1NDksIDg1ODM5MjBdLCBwaXhlbFNpemU6IDcwIH0sXHJcbiAgICBNVF8zMDM1OiB7IGdlb0NlbnRlcjogWzQ3MTk3NTUsIDE0NDE3MDFdLCBwaXhlbFNpemU6IDcwIH0sXHJcbiAgICBQVDIwXzMyNjI2OiB7IGdlb0NlbnRlcjogWzM5NzQxOCwgNDI3MTQ3MV0sIHBpeGVsU2l6ZTogMTUwMCB9LFxyXG4gICAgUFQzMF8zMjYyODogeyBnZW9DZW50ZXI6IFszMzM1ODYsIDM2MjI3MDZdLCBwaXhlbFNpemU6IDE1MCB9LFxyXG4gICAgTElfMzAzNTogeyBnZW9DZW50ZXI6IFs0Mjg3MDYwLCAyNjcyMDAwXSwgcGl4ZWxTaXplOiA0MCB9LFxyXG4gICAgSVNfMzAzNTogeyBnZW9DZW50ZXI6IFszMDExODA0LCA0OTYwMDAwXSwgcGl4ZWxTaXplOiA3MDAgfSxcclxuICAgIFNKX1NWXzMwMzU6IHsgZ2VvQ2VudGVyOiBbNDU3MDAwMCwgNjE2MDE1Nl0sIHBpeGVsU2l6ZTogODAwIH0sXHJcbiAgICBTSl9KTV8zMDM1OiB7IGdlb0NlbnRlcjogWzM2NDc3NjIsIDU0MDgzMDBdLCBwaXhlbFNpemU6IDEwMCB9LFxyXG4gICAgQ0FSSUJfMzI2MjA6IHsgZ2VvQ2VudGVyOiBbNjM2MzQ1LCAxNjY5NDM5XSwgcGl4ZWxTaXplOiA1MDAgfSxcclxuICAgIFdPUkxEXzU0MDMwOiB7IGdlb0NlbnRlcjogWzE0LCAxN10sIHBpeGVsU2l6ZTogOTAwMCB9LFxyXG59XHJcbiIsImV4cG9ydCBjb25zdCBhcHBlbmRTdGFtcCA9IChzdGFtcENvbmZpZywgbWFwKSA9PiB7XHJcbiAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICBjb25zdCBleGlzdGluZyA9IG1hcC5zdmdfLnNlbGVjdCgnI2VtLXN0YW1wJylcclxuICAgICAgICBleGlzdGluZy5yZW1vdmUoKVxyXG5cclxuICAgICAgICBpZiAoc3RhbXBDb25maWcpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gbWFwLnN2Z18uYXBwZW5kKCdnJykuYXR0cignaWQnLCAnZW0tc3RhbXAnKVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcuc2l6ZSkgc3RhbXBDb25maWcuc2l6ZSA9IDYwXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcueCkgc3RhbXBDb25maWcueCA9IDIzMFxyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLnkpIHN0YW1wQ29uZmlnLnkgPSAxMDBcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy50ZXh0Q29sb3IpIHN0YW1wQ29uZmlnLnRleHRDb2xvciA9ICcjMDAwJ1xyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLnN0YW1wQ29sb3IpIHN0YW1wQ29uZmlnLnN0YW1wQ29sb3IgPSAnIzAwMCdcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy5zdHJva2VXaWR0aCkgc3RhbXBDb25maWcuc3Ryb2tlV2lkdGggPSAxXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcubGluZUhlaWdodCkgc3RhbXBDb25maWcubGluZUhlaWdodCA9IDE1XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBjaXJjbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBzdGFtcENvbmZpZy5zaXplKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4Jywgc3RhbXBDb25maWcueClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHN0YW1wQ29uZmlnLnkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tc3RhbXAtY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHN0YW1wQ29uZmlnLnN0YW1wQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgc3RhbXBDb25maWcuc3Ryb2tlV2lkdGgpXHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgdGV4dFxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gc3RhbXBDb25maWcudGV4dFxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IE1hdGguc3FydChtZWFzdXJlV2lkdGgodGV4dC50cmltKCkpICogc3RhbXBDb25maWcubGluZUhlaWdodClcclxuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBnZXRMaW5lcyhnZXRXb3Jkcyh0ZXh0LnRyaW0oKSksIHRhcmdldFdpZHRoKVxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0UmFkaXVzID0gZ2V0VGV4dFJhZGl1cyhsaW5lcywgc3RhbXBDb25maWcubGluZUhlaWdodClcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBpbnNpZGUgY2lyY2xlXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgc3RhbXBDb25maWcudGV4dENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXN0YW1wLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtzdGFtcENvbmZpZy54fSwke3N0YW1wQ29uZmlnLnl9KSBzY2FsZSgke3N0YW1wQ29uZmlnLnNpemUgLyB0ZXh0UmFkaXVzfSlgKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndHNwYW4nKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEobGluZXMpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndHNwYW4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4gKGkgLSBsaW5lcy5sZW5ndGggLyAyICsgMC44KSAqIHN0YW1wQ29uZmlnLmxpbmVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoZCkgPT4gZC50ZXh0LnJlcGxhY2VBbGwoJ34nLCAnICcpLnJlcGxhY2VBbGwoJ8K2JywgJycpKSAvLyBSZW1vdmVzIMK2IChsaW5lIGJyZWFrZXIpIGFuZCB+IChub24gYnJlYWtpbmcgc3BhY2UpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vLyBTcGxpdHRpbmcgYnkgYm90aCBzcGFjZXMgYW5kIHBpbGNyb3dzXHJcbmNvbnN0IGdldFdvcmRzID0gKHRleHQpID0+IHtcclxuICAgIHJldHVybiB0ZXh0XHJcbiAgICAgICAgLnNwbGl0KC8oPzw9wrYpfFxccysvZylcclxuICAgICAgICAubWFwKCh3b3JkKSA9PiB3b3JkLnRyaW0oKSlcclxuICAgICAgICAuZmlsdGVyKCh3b3JkKSA9PiB3b3JkLmxlbmd0aCA+IDApXHJcbn1cclxuXHJcbi8vIENvbXB1dGVzIHRleHQgd2lkdGhcclxuY29uc3QgbWVhc3VyZVdpZHRoID0gKHRleHQpID0+IHtcclxuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJylcclxuICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICd0ZXh0JylcclxuXHJcbiAgICB0ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IHRleHRcclxuICAgIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0RWxlbWVudClcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKVxyXG5cclxuICAgIGNvbnN0IHdpZHRoID0gdGV4dEVsZW1lbnQuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKClcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnKVxyXG5cclxuICAgIHJldHVybiB3aWR0aCArIDEwXHJcbn1cclxuXHJcbi8vIENvbXB1dGUgdGV4dCByYWRpdXNcclxuY29uc3QgZ2V0VGV4dFJhZGl1cyA9IChsaW5lcywgbGluZUhlaWdodCkgPT4ge1xyXG4gICAgbGV0IHJhZGl1cyA9IDBcclxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgZHkgPSAoTWF0aC5hYnMoaSAtIG4gLyAyICsgMC41KSArIDAuNSkgKiBsaW5lSGVpZ2h0XHJcbiAgICAgICAgY29uc3QgZHggPSBsaW5lc1tpXS53aWR0aCAvIDJcclxuICAgICAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIE1hdGguc3FydChkeCAqKiAyICsgZHkgKiogMikpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmFkaXVzXHJcbn1cclxuXHJcbi8vIEhhbmRsZXMgZm9yY2VkIGxpbmUgYnJlYWtzXHJcbmNvbnN0IGdldExpbmVzID0gKHdvcmRzLCB0YXJnZXRXaWR0aCkgPT4ge1xyXG4gICAgbGV0IGxpbmVzID0gW11cclxuICAgIGxldCBsaW5lID0geyB3aWR0aDogMCwgdGV4dDogJycgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gd29yZHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKHdvcmRzW2ldID09PSAnwrYnKSB7XHJcbiAgICAgICAgICAgIC8vIFB1c2ggY3VycmVudCBsaW5lIChpZiBpdCBoYXMgdGV4dClcclxuICAgICAgICAgICAgaWYgKGxpbmUudGV4dCkgbGluZXMucHVzaChsaW5lKVxyXG4gICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBlbXB0eSBsaW5lXHJcbiAgICAgICAgICAgIGxpbmUgPSB7IHdpZHRoOiAwLCB0ZXh0OiAnJyB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGluZVRleHQxID0gKGxpbmUudGV4dCA/IGxpbmUudGV4dCArICcgJyA6ICcnKSArIHdvcmRzW2ldXHJcbiAgICAgICAgbGV0IGxpbmVXaWR0aDEgPSBtZWFzdXJlV2lkdGgobGluZVRleHQxKVxyXG5cclxuICAgICAgICBpZiAoKGxpbmUud2lkdGggKyBsaW5lV2lkdGgxKSAvIDIgPCB0YXJnZXRXaWR0aCkge1xyXG4gICAgICAgICAgICBsaW5lLndpZHRoID0gbGluZVdpZHRoMVxyXG4gICAgICAgICAgICBsaW5lLnRleHQgPSBsaW5lVGV4dDFcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpXHJcbiAgICAgICAgICAgIGxpbmUgPSB7IHdpZHRoOiBtZWFzdXJlV2lkdGgod29yZHNbaV0pLCB0ZXh0OiB3b3Jkc1tpXSB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChsaW5lLnRleHQpIGxpbmVzLnB1c2gobGluZSkgLy8gUHVzaCBsYXN0IGxpbmUgaWYgaXQgZXhpc3RzXHJcblxyXG4gICAgcmV0dXJuIGxpbmVzXHJcbn1cclxuIiwiaW1wb3J0IHsganNvbiwgY3N2IH0gZnJvbSAnZDMtZmV0Y2gnXHJcbmltcG9ydCB7IGdldEVzdGF0RGF0YVVSTCB9IGZyb20gJy4vdXRpbHMnXHJcbmltcG9ydCBKU09Oc3RhdCBmcm9tICdqc29uc3RhdC10b29sa2l0J1xyXG5pbXBvcnQgeyBjc3ZUb0luZGV4LCBqc29uc3RhdFRvSW5kZXggfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIEEgc3RhdGlzdGljYWwgZGF0YXNldCwgdG8gYmUgdXNlZCBmb3IgYSBzdGF0aXN0aWNhbCBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdERhdGEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIHN0YXQgZGF0YSBvYmplY3RcclxuICAgIGNvbnN0IG91dCA9IHt9XHJcblxyXG4gICAgb3V0Ll9fZGF0YSA9IHVuZGVmaW5lZCAvL2ZvciBkZWJ1Z2dpbmdcclxuXHJcbiAgICAvL291dC5tYXhOdW1iZXJPZkRlY2ltYWxzSW5EYXRhc2V0ID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RhdGlzdGljYWwgdmFsdWVzLCBpbmRleGVkIGJ5IE5VVFMgaWQuXHJcbiAgICAgKiBFYWNoIHN0YXQgdmFsdWUgaXMgYW4gb2JqZWN0IHt2YWx1ZSxzdGF0dXN9LlxyXG4gICAgICovXHJcbiAgICBvdXQuX2RhdGFfID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHN0YXQgdmFsdWUge3ZhbHVlLHN0YXR1c30gZnJvbSBhIG51dHMgaWQuXHJcbiAgICAgKiBJZiBubyBhcmd1bWVudCBpcyBzcGVjaWZpZWQsIHJldHVybnMgdGhlIGVudGlyZSBpbmRleC5cclxuICAgICAqIEBwYXJhbSB7Kn0gbnV0c0lkXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXQgPSAobnV0c0lkKSA9PiB7XHJcbiAgICAgICAgaWYgKCFudXRzSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5fZGF0YV9cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3V0Ll9kYXRhXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5fZGF0YV9bbnV0c0lkXVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzdGF0IHZhbHVlIGZyb20gYSBudXRzIGlkLlxyXG4gICAgICogQHBhcmFtIHsqfSBudXRzSWRcclxuICAgICAqL1xyXG4gICAgb3V0LmdldFZhbHVlID0gKG51dHNJZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHMgPSBvdXQuZ2V0KG51dHNJZClcclxuICAgICAgICByZXR1cm4gcyA/IHMudmFsdWUgOiB1bmRlZmluZWRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHN0YXQgdmFsdWUgZnJvbSBhIG51dHMgaWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG51dHNJZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3QgfHwgU3RyaW5nIHx8IE51bWJlcn0gc3RhdCBUaGUgbmV3IHN0YXRpc3RpY2FsIGRhdGEuIFRoZSBmb3JtYXQgY2FuIGJlIGVpdGhlciB7dmFsdWU6MzQuMzI0LHN0YXR1czpcImVcIn0gb3IgYSB0aGUgdmFsdWUgb25seS5cclxuICAgICAqL1xyXG4gICAgb3V0LnNldCA9IChudXRzSWQsIHN0YXQpID0+IHtcclxuICAgICAgICBvdXQuX2RhdGFfID0gb3V0Ll9kYXRhXyB8fCB7fVxyXG4gICAgICAgIGNvbnN0IHMgPSBvdXQuX2RhdGFfW251dHNJZF1cclxuXHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHMudmFsdWUgPSBzdGF0LnZhbHVlXHJcbiAgICAgICAgICAgICAgICBzLnN0YXR1cyA9IHN0YXQuc3RhdHVzXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBiZSBjYXJlZnVsIGhlcmUgc2V0dGluZyB2YWx1ZXMgaGVyZSwgd2UgbmVlZCB0byBtYWludGFpbiBzdHJpbmdzIHdpdGggdHJhaWxpbmcgemVyb3MgYmVjYXVzZSBpbiBKU09OIDEuMCA9PT0gMSBhbmQgdGhleSBhcmUgcmVtb3ZlZC4gVXNlciBtaWdodCB3YW50IHN0YXRzIGxhYmVscyB3aXRoIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgcy52YWx1ZSA9IHN0YXRcclxuICAgICAgICAgICAgICAgIC8vcy52YWx1ZSA9IGlzTmFOKCtzdGF0KSA/IHN0YXQgOiArc3RhdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYmUgY2FyZWZ1bCBoZXJlIHNldHRpbmcgdmFsdWVzIGhlcmUsIHdlIG5lZWQgdG8gbWFpbnRhaW4gc3RyaW5ncyB3aXRoIHRyYWlsaW5nIHplcm9zIGJlY2F1c2UgaW4gSlNPTiAxLjAgPT09IDEgYW5kIHRoZXkgYXJlIHJlbW92ZWQuIFVzZXIgbWlnaHQgd2FudCBzdGF0cyBsYWJlbHMgd2l0aCB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgb3V0Ll9kYXRhX1tudXRzSWRdID0gc3RhdC52YWx1ZSA/IHN0YXQgOiB7IHZhbHVlOiBzdGF0IH1cclxuICAgICAgICAgICAgLy9vdXQuX2RhdGFfW251dHNJZF0gPSBzdGF0LnZhbHVlID8gc3RhdCA6IHsgdmFsdWU6IGlzTmFOKCtzdGF0KSA/IHN0YXQgOiArc3RhdH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHN0YXRpc3RpY2FsIGRhdGEsIGFscmVhZHkgaW5kZXhlZCBieSBudXRzSWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgU29tZXRoaW5nIGxpa2U6IHsgXCJQVFwiOjAuMiwgXCJMVVwiOjAuNiwgLi4ufSwgb3Igd2l0aCBzdGF0dXM6IHsgXCJQVFwiOiB7dmFsdWU6MC4yLCBzdGF0dXM6XCJlXCJ9LCBcIkxVXCI6MC42LCAuLi59XHJcbiAgICAgKi9cclxuICAgIG91dC5zZXREYXRhID0gKGRhdGEpID0+IHtcclxuICAgICAgICBvdXQuX19kYXRhID0gZGF0YSAvLyBmb3IgZGVidWdnaW5nXHJcbiAgICAgICAgb3V0Ll9kYXRhXyA9IHt9IC8vIG92ZXJ3cml0ZSBleGlzdGluZyBkYXRhXHJcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgobnV0c0lkKSA9PiBvdXQuc2V0KG51dHNJZCwgZGF0YVtudXRzSWRdKSlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybiBhbGwgc3RhdCB2YWx1ZXMgYXMgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2xhc3NpZnkgdGhlIHZhbHVlcy4gKi9cclxuICAgIG91dC5nZXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3V0Ll9kYXRhXykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhvdXQuX2RhdGFfKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IHMgPT0gMCB8fCBzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogUmV0dXJuIHN0YXQgdW5pcXVlIHZhbHVlcy4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgY2F0ZWdvcmljYWwgbWFwcy4gKi9cclxuICAgIG91dC5nZXRVbmlxdWVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0Ll9kYXRhXylcclxuICAgICAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZSlcclxuICAgICAgICAgICAgLmZpbHRlcigoaXRlbSwgaSwgYXIpID0+IGFyLmluZGV4T2YoaXRlbSkgPT09IGkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCBtaW4gdmFsdWUuICovXHJcbiAgICBvdXQuZ2V0TWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdXQuX2RhdGFfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dC5fZGF0YV8pXHJcbiAgICAgICAgICAgICAgICAubWFwKChzKSA9PiBzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocykgPT4gcyA9PSAwIHx8IChzICYmIHMgIT09ICc6JykpXHJcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHYpID0+IE1hdGgubWluKGFjYywgdikpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEdldCBtYXggdmFsdWUuICovXHJcbiAgICBvdXQuZ2V0TWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdXQuX2RhdGFfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dC5fZGF0YV8pXHJcbiAgICAgICAgICAgICAgICAubWFwKChzKSA9PiBzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocykgPT4gcyA9PSAwIHx8IChzICYmIHMgIT09ICc6JykpXHJcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHYpID0+IE1hdGgubWF4KGFjYywgdikpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVjayBpZiB0aGUgc3RhdCBkYXRhIGlzIHJlYWR5LiAqL1xyXG4gICAgb3V0LmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dC5fZGF0YV8gIT0gdW5kZWZpbmVkXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNvbWUgbWV0YWRhdGEgKi9cclxuICAgIG91dC5tZXRhZGF0YSA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vYSB0ZXh0IGZvciB0aGUgc3RhdGl0aWNzIHVuaXQgb2YgbWVhc3VyZSwgdG8gYmUgc2hvd24gaW4gdGhlIHRvb2x0aXBcclxuICAgIG91dC51bml0VGV4dF8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHN0YXQgZGF0YSBmcm9tIHJlbW90ZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBudXRzTGV2ZWxcclxuICAgICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgb3V0LnJldHJpZXZlRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIChudXRzTGV2ZWwsIGxhbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKG91dC5ldXJvc3RhdERhdGFzZXRDb2RlXykgdXBkYXRlRXVyb2Jhc2UobnV0c0xldmVsLCBsYW5nLCBjYWxsYmFjaylcclxuICAgICAgICBlbHNlIGlmIChvdXQuY3N2VVJMXykgdXBkYXRlQ1NWKGNhbGxiYWNrKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE8gZGVjb21wb3NlIGludG8gRXVyb2Jhc2UvanNvbnN0YXQgYW5kIENTViB0eXBlcyA/XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdXJvYmFzZS9qc29uc3RhdCBkYXRhIHNvdXJjZVxyXG4gICAgICogU2VlIGh0dHBzOi8vZWMuZXVyb3BhLmV1L2V1cm9zdGF0L3dlYi9qc29uLWFuZC11bmljb2RlLXdlYi1zZXJ2aWNlcy9nZXR0aW5nLXN0YXJ0ZWQvcmVzdC1yZXF1ZXN0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKiogVGhlIEV1cm9iYXNlIGRhdGFzZXQgY29kZSAqL1xyXG4gICAgb3V0LmV1cm9zdGF0RGF0YXNldENvZGVfID0gdW5kZWZpbmVkXHJcbiAgICAvKiogVGhlIEV1cm9iYXNlIGNvZGUgKi9cclxuICAgIG91dC5maWx0ZXJzXyA9IHsgbGFzdFRpbWVQZXJpb2Q6IDEgfVxyXG4gICAgLyoqIFRoZSBwcmVjaXNpb24gKG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcykgKi9cclxuICAgIG91dC5wcmVjaXNpb25fID0gMlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHByb21pc2UgZm9yIEV1cm9iYXNlL2pzb25zdGF0IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldEV1cm9iYXNlUHJvbWlzZSA9IGZ1bmN0aW9uIChudXRzTGV2ZWwsIGxhbmcpIHtcclxuICAgICAgICAvL3NldCBwcmVjaXNpb24gLy9ERVBSRUNBVEVEIDE2LzExLzIwMjEgaHR0cHM6Ly9lYy5ldXJvcGEuZXUvZXVyb3N0YXQvb25saW5lLWhlbHAvcHVibGljL2VuL05BVklHQVRJT05fV0REU1RyYW5zbGF0b3JfbWlncmF0aW9uX2VuLyNERUNPTU1JU1NJT05cclxuICAgICAgICAvL291dC5maWx0ZXJzX1tcInByZWNpc2lvblwiXSA9IG91dC5wcmVjaXNpb25fO1xyXG4gICAgICAgIC8vc2VsZWN0IG9ubHkgcmVxdWlyZWQgZ2VvIGdyb3VwcywgZGVwZW5kaW5nIG9uIHRoZSBzcGVjaWZpZWQgbnV0cyBsZXZlbFxyXG4gICAgICAgIGlmICghb3V0LmZpbHRlcnNfLmdlbykge1xyXG4gICAgICAgICAgICBvdXQuZmlsdGVyc19bJ2dlb0xldmVsJ10gPSBudXRzTGV2ZWwgKyAnJyA9PT0gJzAnID8gJ2NvdW50cnknIDogJ251dHMnICsgbnV0c0xldmVsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2ZvcmNlIGZpbHRlcmluZyBvZiBldXJvLWdlby1hZ2dyZWdhdGVzXHJcbiAgICAgICAgLy9vdXQuZmlsdGVyc19bXCJmaWx0ZXJOb25HZW9cIl0gPSAxOyAvL0RFUFJFQ0FURUQgMTYvMTEvMjAyMVxyXG5cclxuICAgICAgICAvL3JldHJpZXZlIHN0YXQgZGF0YSBmcm9tIEV1cm9zdGF0IEFQSVxyXG4gICAgICAgIHJldHVybiBqc29uKGdldEVzdGF0RGF0YVVSTChvdXQuZXVyb3N0YXREYXRhc2V0Q29kZV8sIG91dC5maWx0ZXJzXywgbGFuZykpXHJcbiAgICB9XHJcblxyXG4gICAgLy9mb3IgZXVyb2Jhc2Ugc3RhdGlzdGljYWwgZGF0YSB0byByZXRyaWV2ZSBmcm9tIEV1cm9zdGF0IEFQSVxyXG4gICAgY29uc3QgdXBkYXRlRXVyb2Jhc2UgPSBmdW5jdGlvbiAobnV0c0xldmVsLCBsYW5nLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vZXJhc2UgcHJldmlvdXMgZGF0YVxyXG4gICAgICAgIG91dC5fZGF0YV8gPSBudWxsXHJcblxyXG4gICAgICAgIGdldEV1cm9iYXNlUHJvbWlzZShudXRzTGV2ZWwsIGxhbmcpLnRoZW4oZnVuY3Rpb24gKGRhdGFfX18pIHtcclxuICAgICAgICAgICAgLy9kZWNvZGUgc3RhdCBkYXRhXHJcbiAgICAgICAgICAgIGNvbnN0IGpzZCA9IEpTT05zdGF0KGRhdGFfX18pXHJcblxyXG4gICAgICAgICAgICAvL3N0b3JlIGpzb25zdGF0IG1ldGFkYXRhXHJcbiAgICAgICAgICAgIG91dC5tZXRhZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBqc2QubGFiZWwsXHJcbiAgICAgICAgICAgICAgICBocmVmOiBqc2QuaHJlZixcclxuICAgICAgICAgICAgICAgIHNvdXJjZToganNkLnNvdXJjZSxcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IGpzZC51cGRhdGVkLFxyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBqc2QuZXh0ZW5zaW9uLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dC5tZXRhZGF0YS50aW1lID0ganNkLkRpbWVuc2lvbigndGltZScpLmlkWzBdXHJcblxyXG4gICAgICAgICAgICAvL2luZGV4XHJcbiAgICAgICAgICAgIG91dC5fZGF0YV8gPSBqc29uc3RhdFRvSW5kZXgoanNkKVxyXG4gICAgICAgICAgICAvL1RPRE86IHVzZSBtYXliZSBodHRwczovL2dpdGh1Yi5jb20vYmFkb3NhL0pTT04tc3RhdC9ibG9iL21hc3Rlci91dGlscy9mcm9tdGFibGUubWQgdG8gYnVpbGQgZGlyZWN0bHkgYW4gaW5kZXggP1xyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgdGltZSBzdGFtcCBvZiB0aGUganNvbnN0YXQgZGF0YXNldC5cclxuICAgICAqL1xyXG4gICAgb3V0LmdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IG91dC5maWx0ZXJzXy50aW1lXHJcbiAgICAgICAgaWYgKHQpIHJldHVybiB0XHJcbiAgICAgICAgaWYgKCFvdXQuX2RhdGFfKSByZXR1cm5cclxuICAgICAgICByZXR1cm4gb3V0Lm1ldGFkYXRhLnRpbWVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENTViBkYXRhIHNvdXJjZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqIFRoZSBDU1YgZmlsZSBVUkwgKi9cclxuICAgIG91dC5jc3ZVUkxfID0gdW5kZWZpbmVkXHJcbiAgICAvKiogVGhlIENTViBjb2x1bW4gd2l0aCB0aGUgTlVUUyBpZHMgKi9cclxuICAgIG91dC5nZW9Db2xfID0gJ2dlbydcclxuICAgIC8qKiBUaGUgQ1NWIGNvbHVtbiB3aXRoIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgKi9cclxuICAgIG91dC52YWx1ZUNvbF8gPSAndmFsdWUnXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gcHJvbWlzZSBmb3IgQ1NWIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldENTVlByb21pc2UgPSBmdW5jdGlvbiAobnV0c0xldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNzdihvdXQuY3N2VVJMXylcclxuICAgIH1cclxuXHJcbiAgICAvL2ZvciBzdGF0aXN0aWNhbCBkYXRhIHRvIHJldHJpZXZlIGZyb20gQ1NWIGZpbGVcclxuICAgIGNvbnN0IHVwZGF0ZUNTViA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIC8vZXJhc2UgcHJldmlvdXMgZGF0YVxyXG4gICAgICAgIG91dC5fZGF0YV8gPSBudWxsXHJcblxyXG4gICAgICAgIC8vcmV0cmlldmUgY3N2IGRhdGFcclxuICAgICAgICBnZXRDU1ZQcm9taXNlKCkudGhlbihmdW5jdGlvbiAoZGF0YV9fXykge1xyXG4gICAgICAgICAgICAvL2RlY29kZSBzdGF0IGRhdGFcclxuICAgICAgICAgICAgb3V0Ll9kYXRhXyA9IGNzdlRvSW5kZXgoZGF0YV9fXywgb3V0Lmdlb0NvbF8sIG91dC52YWx1ZUNvbF8pXHJcblxyXG4gICAgICAgICAgICAvL3N0b3JlIHNvbWUgbWV0YWRhdGFcclxuICAgICAgICAgICAgb3V0Lm1ldGFkYXRhID0geyBocmVmOiBvdXQuY3N2VVJMXyB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbJ3VuaXRUZXh0XyddLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleSArICdfJ10gPSBjb25maWdba2V5XVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBhcHBseUlubGluZVN0eWxlc0Zyb21DU1MsIGZsYWdzLCBzZXJpYWxpemUsIHJhc3Rlcml6ZSwgZ2V0RG93bmxvYWRVUkwgfSBmcm9tICcuL3V0aWxzJ1xyXG5pbXBvcnQgKiBhcyBNYXBUZW1wbGF0ZSBmcm9tICcuL21hcC10ZW1wbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdGlzdGljYWxEYXRhIGZyb20gJy4vc3RhdC1kYXRhJ1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZCdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgKiBhcyB0cCBmcm9tICcuLi90b29sdGlwL3Rvb2x0aXAnXHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3Qgc3RhdGlzdGljYWwgbWFwOiBBIG1hcCB0ZW1wbGF0ZSB3aXRoIHN0YXRpc3RpY2FsIGRhdGEsIHdpdGhvdXQgYW55IHBhcnRpY3VsYXIgc3R5bGluZyBydWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHdpdGhDZW50ZXJQb2ludHMgU2V0IHRvIHRydWUgKG9yIDEpIHRvIGFkZCByZWdpb25zIGNlbnRlciBwb2ludHMgdG8gdGhlIG1hcCB0ZW1wbGF0ZSwgdG8gYmUgdXNlZCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbHMgbWFwcyBmb3IgZXhhbXBsZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzdGF0TWFwID0gZnVuY3Rpb24gKGNvbmZpZywgd2l0aENlbnRlclBvaW50cywgbWFwVHlwZSkge1xyXG4gICAgLy9idWlsZCBzdGF0IG1hcCBmcm9tIG1hcCB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gTWFwVGVtcGxhdGUubWFwVGVtcGxhdGUoY29uZmlnLCB3aXRoQ2VudGVyUG9pbnRzLCBtYXBUeXBlKVxyXG5cclxuICAgIC8vc3RhdGlzdGljYWwgZGF0YVxyXG5cclxuICAgIC8vdGhlIHN0YXRpc3RpY2FsIGRhdGEgY29uZmlndXJhdGlvbi5cclxuICAgIC8vQSBtYXAgY2FuIGhhdmUgc2V2ZXJhbCBzdGF0IGRhdGFzZXRzLiBUaGlzIGlzIGEgZGljdGlvbmFyeSBvZiBhbGwgc3RhdCBjb25maWd1cmF0aW9uXHJcbiAgICBvdXQuc3RhdF8gPSB7IGRlZmF1bHQ6IHVuZGVmaW5lZCB9XHJcbiAgICBvdXQuc3RhdCA9IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgLy9ubyBhcmd1bWVudDogZ2V0dGVyIC0gcmV0dXJuIHRoZSBkZWZhdWx0IHN0YXRcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuc3RhdF9bJ2RlZmF1bHQnXVxyXG4gICAgICAgIC8vdHdvIGFyZ3VtZW50czogc2V0dGVyIC0gc2V0IHRoZSBjb25maWcgayB3aXRoIHZhbHVlIHZcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIG91dC5zdGF0X1trXSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgICAgICAvL29uZSBzdHJpbmcgYXJndW1lbnQ6IGdldHRlciAtIHJldHVybiB0aGUgY29uZmlnIGtcclxuICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnIHx8IGsgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiBvdXQuc3RhdF9ba11cclxuICAgICAgICAvL29uZSBub24tc3RyaW5nIGFyZ3VtZW50OiBzZXR0ZXIgLSBzZXQgdGhlIGVudGlyZSBkaWN0aW9ubmFyeVxyXG4gICAgICAgIG91dC5zdGF0XyA9IGsuZGVmYXVsdCA/IGsgOiB7IGRlZmF1bHQ6IGsgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL3RoZSBzdGF0aXN0aWNhbCBkYXRhLCByZXRyaWV2ZWQgZnJvbSB0aGUgY29uZmlnIGluZm9ybWF0aW9uLiBBcyBhIGRpY3Rpb25hcnkuXHJcbiAgICBvdXQuc3RhdERhdGFfID0ge1xyXG4gICAgICAgIGRlZmF1bHQ6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLFxyXG4gICAgICAgIGNvbG9yOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSxcclxuICAgICAgICBzaXplOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSxcclxuICAgICAgICB2MTogU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKCksXHJcbiAgICAgICAgdjI6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLCAvL2JpdmFyaWF0ZVxyXG4gICAgICAgIHYzOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSwgLy90cml2YXJpYXRlXHJcbiAgICB9XHJcbiAgICBvdXQuc3RhdERhdGEgPSBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIC8vbm8gYXJndW1lbnQ6IGdldHRlciAtIHJldHVybiB0aGUgZGVmYXVsdCBzdGF0RGF0YVxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5zdGF0RGF0YV9bJ2RlZmF1bHQnXVxyXG4gICAgICAgIC8vb25lIGFyZ3VtZW50OiBnZXR0ZXJcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSByZXR1cm4gb3V0LnN0YXREYXRhX1trXVxyXG4gICAgICAgIC8vc2V0dGVyXHJcbiAgICAgICAgb3V0LnN0YXREYXRhX1trXSA9IHZcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy90ZXN0IGZvciBubyBkYXRhIGNhc2VcclxuICAgIG91dC5ub0RhdGFUZXh0XyA9ICdObyBkYXRhIGF2YWlsYWJsZSdcclxuICAgIC8vbGFuZ2FnZSAoY3VycmVudGx5IHVzZWQgb25seSBmb3IgZXVyb3N0YXQgZGF0YSBBUEkpXHJcbiAgICBvdXQubGFuZ3VhZ2VfID0gJ2VuJ1xyXG4gICAgLy90cmFuc2l0aW9uIHRpbWUgZm9yIHJlbmRlcmluZ1xyXG4gICAgb3V0LnRyYW5zaXRpb25EdXJhdGlvbl8gPSA1MDBcclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gdW5kZWZpbmVkXHJcbiAgICAvL2ZvciBtYXBzIHVzaW5nIHNwZWNpYWwgZmlsbCBwYXR0ZXJucywgdGhpcyBpcyB0aGUgZnVuY3Rpb24gdG8gZGVmaW5lIHRoZW0gaW4gdGhlIFNWRyBpbWFnZSAtIFNlZSBmdW5jdGlvbnM6IGdldEZpbGxQYXR0ZXJuTGVnZW5kIGFuZCBnZXRGaWxsUGF0dGVybkRlZmluaXRpb25GdW5cclxuICAgIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9hIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIG1hcCBidWlsZCBpcyBjb21wbGV0ZS5cclxuICAgIG91dC5jYWxsYmFja18gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL2xlZ2VuZCBjb25maWd1cmF0aW9uXHJcbiAgICBvdXQubGVnZW5kXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9sZWdlbmQgb2JqZWN0XHJcbiAgICBvdXQubGVnZW5kT2JqXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbJ2xlZ2VuZF8nLCAnbGVnZW5kT2JqXycsICdub0RhdGFUZXh0XycsICdsYW5ndWFnZV8nLCAndHJhbnNpdGlvbkR1cmF0aW9uXycsICd0b29sdGlwVGV4dF8nLCAnZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8nLCAnY2FsbGJhY2tfJ10uZm9yRWFjaChcclxuICAgICAgICBmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIGlmIChvdXRba2V5XSAmJiBjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG5cclxuICAgIC8vIG92ZXJyaWRlIGxlZ2VuZCBmb3IgdXBkYXRpbmcgYWZ0ZXIgYnVpbGRcclxuICAgIG91dC5sZWdlbmQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5sZWdlbmRfXHJcbiAgICAgICAgb3V0LmxlZ2VuZF8gPSB2XHJcbiAgICAgICAgLy91cGRhdGUgaWYgZXhpc3RpbmcgbGVnZW5kXHJcbiAgICAgICAgaWYgKG91dC5sZWdlbmRPYmpfKSBvdXQudXBkYXRlTGVnZW5kKClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LnVwZGF0ZUxlZ2VuZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKG91dC5sZWdlbmRPYmpfKSBvdXQubGVnZW5kT2JqKCkudXBkYXRlKClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCB0aGUgbWFwLlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbmNlLCBwcmVmZXJhYmx5IGFmdGVyIHRoZSBtYXAgYXR0cmlidXRlcyBoYXZlIGJlZW4gc2V0IHRvIHNvbWUgaW5pdGlhbCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIG91dC5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3V0LnByb2plY3Rpb25GdW5jdGlvbl8pIG91dC5wcm9qKCc0MzI2JykgLy93aGVuIHVzaW5nIGN1c3RvbSBkMyBwcm9qZWN0aW9uIGZ1bmN0aW9uIGFsd2F5cyByZXF1ZXN0IE5VVFMySlNPTiBpbiBXR1M4NFxyXG5cclxuICAgICAgICAvL2J1aWxkIG1hcCB0ZW1wbGF0ZSBiYXNlXHJcbiAgICAgICAgb3V0LmJ1aWxkTWFwVGVtcGxhdGVCYXNlKClcclxuXHJcbiAgICAgICAgLy9hZGQgYWRkaXRpb25hbCBmaWx0ZXJzIGZvciBmaWxsIHBhdHRlcm5zIGZvciBleGFtcGxlXHJcbiAgICAgICAgaWYgKG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXykge1xyXG4gICAgICAgICAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8ob3V0LnN2ZygpLCBvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICBpZiAob3V0LmxlZ2VuZCgpKSB7XHJcbiAgICAgICAgICAgIG91dC5idWlsZExlZ2VuZCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RlZmluZSB0b29sdGlwXHJcbiAgICAgICAgLy9wcmVwYXJlIG1hcCB0b29sdGlwXHJcbiAgICAgICAgaWYgKG91dC50b29sdGlwXykge1xyXG4gICAgICAgICAgICBvdXQuX3Rvb2x0aXAgPSB0cC50b29sdGlwKG91dC50b29sdGlwXylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL25vIGNvbmZpZyBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XHJcbiAgICAgICAgICAgIG91dC5fdG9vbHRpcCA9IHRwLnRvb2x0aXAoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sYXVuY2ggZ2VvIGRhdGEgcmV0cmlldmFsXHJcbiAgICAgICAgb3V0LnVwZGF0ZUdlb0RhdGEoKVxyXG5cclxuICAgICAgICAvL2xhdW5jaCBzdGF0IGRhdGEgcmV0cmlldmFsXHJcbiAgICAgICAgb3V0LnVwZGF0ZVN0YXREYXRhKClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIG91dC5idWlsZExlZ2VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2NyZWF0ZSBsZWdlbmQgb2JqZWN0XHJcbiAgICAgICAgb3V0LmxlZ2VuZE9iaihvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IoKShvdXQsIG91dC5sZWdlbmQoKSkpXHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gb3V0LmxlZ2VuZE9iaigpXHJcblxyXG4gICAgICAgIC8vZ2V0IGxlZ2VuZCBzdmcuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBjcmVhdGUgaXQgZW1iZWRlZCB3aXRoaW4gdGhlIG1hcFxyXG4gICAgICAgIGxldCBsZWdlbmRTdmcgPSBzZWxlY3QoJyMnICsgbGVnZW5kLnN2Z0lkKVxyXG4gICAgICAgIGlmIChsZWdlbmRTdmcuc2l6ZSgpID09IDApIHtcclxuICAgICAgICAgICAgLy9nZXQgbGVnZW5kIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBsZWdlbmQueCA9PSB1bmRlZmluZWQgPyBvdXQud2lkdGgoKSAtIDEwMCAtIGxlZ2VuZC5ib3hQYWRkaW5nIDogbGVnZW5kLnhcclxuICAgICAgICAgICAgY29uc3QgeSA9IGxlZ2VuZC55ID09IHVuZGVmaW5lZCA/IGxlZ2VuZC5ib3hQYWRkaW5nIDogbGVnZW5kLnlcclxuXHJcbiAgICAgICAgICAgIC8vYnVpbGQgbGVnZW5kIFNWRyBpbiBhIG5ldyBncm91cFxyXG4gICAgICAgICAgICBvdXQuc3ZnKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgbGVnZW5kLnN2Z0lkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZWdlbmQuYnVpbGQoKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVjayBpZiBhbGwgc3RhdCBkYXRhc2V0cyBoYXZlIGJlZW4gbG9hZGVkLiAqL1xyXG4gICAgY29uc3QgaXNTdGF0RGF0YVJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAobGV0IHN0YXRLZXkgaW4gb3V0LnN0YXRfKSB7XHJcbiAgICAgICAgICAgIGlmICghb3V0LnN0YXREYXRhX1tzdGF0S2V5XS5pc1JlYWR5KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEJVRyBIRVJFLiBFLkcuIGZvciBjaGJpIG1hcHMgdGhlIHVzZXIgY2FsbGJhY2sgaXMgbmV2ZXIgZXhlY3V0ZWQgZm9yIGFsbCBpbnNldCBtYXBzIGJlY2F1c2UgaXNSZWFkeSgpIHJldHVybnMgZmFsc2UsIGJlY2F1c2UgdjEgYW5kIHYyIGFyZSBzcGVjaWZpZWQgYnV0IG5vdCAnZGVmYXVsdCcuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGF1bmNoIG1hcCBnZW8gZGF0YSByZXRyaWV2YWwsIGFuZCBtYWtlL3VwZGF0ZSB0aGUgbWFwIG9uY2UgcmVjZWl2ZWQuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGF0dHJpYnV0ZXMgcmVsYXRlZCB0byB0aGUgbWFwIGdlb21ldHJpZXMgaGF2ZSBjaGFuZ2VkLCB0byByZXRyaWV2ZSB0aGlzIG5ldyBkYXRhIGFuZCByZWZyZXNoIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGVHZW9EYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVHZW9NYXBUZW1wbGF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vaWYgc3RhdCBkYXRhc2V0cyBoYXZlIG5vdCBiZWVuIGxvYWRlZCwgd2FpdCBhZ2FpblxyXG4gICAgICAgICAgICBpZiAoIWlzU3RhdERhdGFSZWFkeSgpKSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgIC8vcHJvY2VlZCB3aXRoIG1hcCBjb25zdHJ1Y3Rpb25cclxuICAgICAgICAgICAgb3V0LnVwZGF0ZVN0YXRWYWx1ZXMoKVxyXG4gICAgICAgICAgICAvL2V4ZWN1dGUgY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAgICAgICAgaWYgKG91dC5jYWxsYmFjaygpKSBvdXQuY2FsbGJhY2soKShvdXQpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGF1bmNoIG1hcCBnZW8gc3RhdCBkYXRhc2V0cyByZXRyaWV2YWwsIGFuZCBtYWtlL3VwZGF0ZSB0aGUgbWFwIG9uY2UgcmVjZWl2ZWQuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHNwZWNpZmljYXRpb25zIG9uIHRoZSBzdGF0IGRhdGEgc291cmNlcyBhdHRhY2hlZCB0byB0aGUgbWFwIGhhdmUgY2hhbmdlZCwgdG8gcmV0cmlldmUgdGhpcyBuZXcgZGF0YSBhbmQgcmVmcmVzaCB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlU3RhdERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgc3RhdEtleSBpbiBvdXQuc3RhdF8pIHtcclxuICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gc3RhdCBkYXRhIHNvdXJjZSBpcyBzcGVjaWZpZWQgYW5kIHN0YXQgZGF0YSB3aGVyZSBzcGVjaWZpZWQgcHJvZ3JhbW1hdGljYWxseVxyXG4gICAgICAgICAgICAvL2J1ZyAtIG1hcC5zdGF0RGF0YSgnc2l6ZScpLnNldERhdGEoeyBFUzogMTAwMDAsIERFOiAxMDAwMCwgRlI6IDUwMDAgfSkgcmVzdWx0cyBpbiBvdXQuc3RhdERhdGEoc3RhdEtleSkuZ2V0KCkgPSB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFvdXQuc3RhdChzdGF0S2V5KSAmJiBvdXQuc3RhdERhdGEoc3RhdEtleSkuZ2V0KCkpIHJldHVyblxyXG5cclxuICAgICAgICAgICAgLy9pZiBubyBjb25maWcgaXMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdCBkYXRhIHNvdXJjZTogcG9wdWxhdGlvbiBkZW5zaXR5IC0gd2h5P1xyXG4gICAgICAgICAgICAvL1RPRE8gbW92ZSB0aGF0IG91dCBvZiBsb29wID9cclxuICAgICAgICAgICAgaWYgKHN0YXRLZXkgPT0gJ2RlZmF1bHQnICYmICFvdXQuc3RhdChzdGF0S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgb3V0LnN0YXQoc3RhdEtleSwgeyBldXJvc3RhdERhdGFzZXRDb2RlOiAnZGVtb19yX2QzZGVucycsIHVuaXRUZXh0OiAnaW5oYWIuL2ttwrInIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vYnVpbGQgc3RhdCBkYXRhIG9iamVjdCBmcm9tIHN0YXQgY29uZmlndXJhdGlvbiBhbmQgc3RvcmUgaXRcclxuICAgICAgICAgICAgY29uc3Qgc3RhdERhdGEgPSBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEob3V0LnN0YXQoc3RhdEtleSkpXHJcbiAgICAgICAgICAgIG91dC5zdGF0RGF0YShzdGF0S2V5LCBzdGF0RGF0YSlcclxuXHJcbiAgICAgICAgICAgIC8vbGF1bmNoIHF1ZXJ5XHJcbiAgICAgICAgICAgIGxldCBubCA9IG91dC5udXRzTGV2ZWxfXHJcbiAgICAgICAgICAgIGlmIChvdXQubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBubCA9IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGF0RGF0YS5yZXRyaWV2ZUZyb21SZW1vdGUobmwsIG91dC5sYW5ndWFnZSgpLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIGdlb2RhdGEgaGFzIG5vdCBiZWVuIGxvYWRlZCwgd2FpdCBhZ2FpblxyXG4gICAgICAgICAgICAgICAgaWYgKCFvdXQuR2VvbWV0cmllcy5pc0dlb1JlYWR5KCkpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgLy9pZiBzdGF0IGRhdGFzZXRzIGhhdmUgbm90IGFsbCBiZWVuIGxvYWRlZCwgd2FpdCBhZ2FpblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0YXREYXRhUmVhZHkoKSkgcmV0dXJuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9wcm9jZWVkIHdpdGggbWFwIGNvbnN0cnVjdGlvblxyXG4gICAgICAgICAgICAgICAgb3V0LnVwZGF0ZVN0YXRWYWx1ZXMoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZXhlY3V0ZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5jYWxsYmFjaygpKSBvdXQuY2FsbGJhY2soKSgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlL3VwZGF0ZSB0aGUgbWFwIHdpdGggbmV3IHN0YXQgZGF0YS5cclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc3RhdCBkYXRhIGF0dGFjaGVkIHRvIHRoZSBtYXAgaGF2ZSBjaGFuZ2VkLCB0byByZWZyZXNoIHRoZSBtYXAuXHJcbiAgICAgKiBJZiB0aGUgc3RhdCBkYXRhIHNvdXJjZXMgaGF2ZSBjaGFuZ2VkLCBjYWxsICp1cGRhdGVTdGF0RGF0YSogaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZVN0YXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy91cGRhdGUgY2xhc3NpZmljYXRpb24gYW5kIHN0eWxlc1xyXG4gICAgICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbigpXHJcbiAgICAgICAgb3V0LnVwZGF0ZVN0eWxlKClcclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kLCBpZiBhbnlcclxuICAgICAgICBpZiAob3V0LmxlZ2VuZE9iaigpKSBvdXQubGVnZW5kT2JqKCkudXBkYXRlKClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgbWV0aG9kLlxyXG4gICAgICogTWFrZS91cGRhdGUgdGhlIG1hcCBhZnRlciBjbGFzc2lmaWNhdGlvbiBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjaGFuZ2VkLlxyXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBudW1iZXIgb2YgY2xhc3Nlcywgb3IgdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZCBoYXMgY2hhbmdlZCwgY2FsbCB0aGlzIG1ldGhvZCB0byB1cGRhdGUgdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgdXBkYXRlQ2xhc3NpZmljYXRpb24gZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBtZXRob2QuXHJcbiAgICAgKiBNYWtlL3VwZGF0ZSB0aGUgbWFwIGFmdGVyIHN0eWxpbmcgYXR0cmlidXRlcyBoYXZlIGJlZW4gY2hhbmdlZC5cclxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGUgc3R5bGUgKGNvbG9yPykgZm9yIG9uZSBsZWdlbmQgZWxlbWVudCBoYXMgY2hhbmdlZCwgY2FsbCB0aGlzIG1ldGhvZCB0byB1cGRhdGUgdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgdXBkYXRlU3R5bGUgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBtZXRob2QuXHJcbiAgICAgKiBGdW5jdGlvbiB3aGljaCByZXR1cm4gdGhlIGxlZ2VuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgZ2V0TGVnZW5kQ29uc3RydWN0b3IgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkJylcclxuICAgICAgICByZXR1cm4gTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIHRpbWUgc3RhbXAgb2YgdGhlIG1hcCwgZXZlbiBpZiBub3Qgc3BlY2lmaWVkIGluIHRoZSBkaW1lbnNpb24gaW5pdGlhbGx5LlxyXG4gICAgICogVGhpcyBhcHBsaWVzIG9ubHkgZm9yIHN0YXQgZGF0YSByZXRyaWV2ZWQgZnJvbSBFdXJvc3RhdCBBUEkuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgd2hlbiB0aGUgZGF0YSByZXRyaWV2ZWQgaXMgdGhlIGZyZXNoZXN0LCBhbmQgb25lIHdhbnRzIHRvIGtub3cgd2hhdCB0aGlzIGRhdGUgaXMsIGZvciBleGFtcGxlIHRvIGRpc3BsYXkgaXQgaW4gdGhlIG1hcCB0aXRsZS5cclxuICAgICAqL1xyXG4gICAgb3V0LmdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dC5zdGF0RGF0YSgnZGVmYXVsdCcpLmdldFRpbWUoKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNvbWUgbWFwIGF0dHJpYnV0ZXMgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBVUkwgcGFyYW1ldGVyczpcclxuICAgICAqIFwid1wiOndpZHRoLCBcImhcIjpoZWlnaHQsIFwieFwiOnhHZW9DZW50ZXIsIFwieVwiOnlHZW9DZW50ZXIsIFwielwiOnBpeEdlb1NpemUsIFwic1wiOnNjYWxlLCBcImx2bFwiOm51dHMgbGV2ZWwsIFwidGltZVwiOnRpbWUsXHJcbiAgICAgKiBcInByb2pcIjpDUlMsIFwiZ2VvXCI6Z2VvIHRlcnJpdG9yeSwgXCJueVwiOm51dHMgdmVyc2lvbiwgXCJsYW5ndWFnZVwiOmxhbmdhZ2UsIFwibnVtYmVyT2ZDbGFzc2VzXCI6Y2xhc3MgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIG91dC5zZXRGcm9tVVJMID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBnZXRVUkxQYXJhbWV0ZXJzKClcclxuICAgICAgICBpZiAob3B0cy53KSBvdXQud2lkdGgob3B0cy53KVxyXG4gICAgICAgIGlmIChvcHRzLmgpIG91dC5oZWlnaHQob3B0cy5oKVxyXG4gICAgICAgIGlmIChvcHRzLnggJiYgb3B0cy55KSBvdXQuZ2VvQ2VudGVyKFtvcHRzLngsIG9wdHMueV0pXHJcbiAgICAgICAgaWYgKG9wdHMueikgb3V0LnBpeGVsU2l6ZShvcHRzLnopXHJcbiAgICAgICAgaWYgKG9wdHMucykgb3V0LnNjYWxlKG9wdHMucylcclxuICAgICAgICBpZiAob3B0cy5sdmwpIG91dC5udXRzTGV2ZWwob3B0cy5sdmwpXHJcbiAgICAgICAgaWYgKG9wdHMudGltZSkge1xyXG4gICAgICAgICAgICBvdXQuZmlsdGVyc18udGltZSA9IG9wdHMudGltZVxyXG4gICAgICAgICAgICBkZWxldGUgb3V0LmZpbHRlcnNfLmxhc3RUaW1lUGVyaW9kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLnByb2opIG91dC5wcm9qKG9wdHMucHJvailcclxuICAgICAgICBpZiAob3B0cy5nZW8pIG91dC5nZW8ob3B0cy5nZW8pXHJcbiAgICAgICAgaWYgKG9wdHMubnkpIG91dC5udXRzWWVhcihvcHRzLm55KVxyXG4gICAgICAgIGlmIChvcHRzLmxhbmd1YWdlKSBvdXQubGFuZ3VhZ2Uob3B0cy5sYW5ndWFnZSlcclxuICAgICAgICBpZiAob3B0cy5udW1iZXJPZkNsYXNzZXMpIG91dC5udW1iZXJPZkNsYXNzZXMoK29wdHMubnVtYmVyT2ZDbGFzc2VzKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBleHBvcnRNYXBUb1NWR1xyXG4gICAgICogQGRlc2NyaXB0aW9uIEV4cG9ydHMgdGhlIGN1cnJlbnQgbWFwIHdpdGggc3R5bGluZyB0byBTVkcgYW5kIGRvd25sb2FkcyBpdFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgb3V0LmV4cG9ydE1hcFRvU1ZHID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENsb25lIHRoZSBvcmlnaW5hbCBTVkcgbm9kZSB0byBhdm9pZCBtb2RpZnlpbmcgdGhlIERPTVxyXG4gICAgICAgIGNvbnN0IHN2Z05vZGVDbG9uZSA9IG91dC5zdmdfLm5vZGUoKS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgICAvLyBBZGQgWE1MIG5hbWVzcGFjZXMgaWYgbm90IGFscmVhZHkgcHJlc2VudFxyXG4gICAgICAgIGlmICghc3ZnTm9kZUNsb25lLmhhc0F0dHJpYnV0ZSgneG1sbnMnKSkge1xyXG4gICAgICAgICAgICBzdmdOb2RlQ2xvbmUuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3ZnTm9kZUNsb25lLmhhc0F0dHJpYnV0ZSgneG1sbnM6eGxpbmsnKSkge1xyXG4gICAgICAgICAgICBzdmdOb2RlQ2xvbmUuc2V0QXR0cmlidXRlKCd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGFwcGVuZCB0aGUgY2xvbmUgdG8gdGhlIGRvY3VtZW50IHRvIGNvbXB1dGUgc3R5bGVzXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgQ1NTIHRvIGlubGluZSBzdHlsZXMgYmVmb3JlIHNhdmluZyB0aGUgU1ZHXHJcbiAgICAgICAgYXBwbHlJbmxpbmVTdHlsZXNGcm9tQ1NTKHN2Z05vZGVDbG9uZSlcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjbG9uZWQgU1ZHIGZyb20gdGhlIGRvY3VtZW50IGFmdGVyIGFwcGx5aW5nIHN0eWxlc1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnTm9kZUNsb25lKVxyXG5cclxuICAgICAgICBjb25zdCBzdmdVcmwgPSBnZXREb3dubG9hZFVSTChzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIGRvd25sb2FkIGxpbmsgYW5kIHRyaWdnZXIgZG93bmxvYWRcclxuICAgICAgICBjb25zdCBkb3dubG9hZExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcclxuICAgICAgICBkb3dubG9hZExpbmsuaHJlZiA9IHN2Z1VybFxyXG4gICAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9ICdldXJvc3RhdG1hcC5zdmcnXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZExpbmspXHJcbiAgICAgICAgZG93bmxvYWRMaW5rLmNsaWNrKClcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkTGluaylcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGV4cG9ydE1hcFRvUE5HXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRXhwb3J0cyB0aGUgY3VycmVudCBtYXAgd2l0aCBzdHlsaW5nIHRvIFBORyBhbmQgZG93bmxvYWRzIGl0XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBvdXQuZXhwb3J0TWFwVG9QTkcgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IHN2Z05vZGVDbG9uZSA9IG91dC5zdmdfLm5vZGUoKS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgICAvLyBDb252ZXJ0IENTUyB0byBpbmxpbmUgc3R5bGVzIGJlZm9yZSBzYXZpbmcgdGhlIFNWR1xyXG4gICAgICAgIGFwcGx5SW5saW5lU3R5bGVzRnJvbUNTUyhzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMTogU2VyaWFsaXplIHRoZSBTVkcgbm9kZSB0byBhIHN0cmluZ1xyXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpXHJcbiAgICAgICAgY29uc3Qgc3ZnU3RyaW5nID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMjogQ3JlYXRlIGEgQmxvYiBmcm9tIHRoZSBzZXJpYWxpemVkIFNWR1xyXG4gICAgICAgIGNvbnN0IHN2Z0Jsb2IgPSBuZXcgQmxvYihbc3ZnU3RyaW5nXSwgeyB0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04JyB9KVxyXG5cclxuICAgICAgICAvLyBTdGVwIDM6IENyZWF0ZSBhIFVSTCBmb3IgdGhlIEJsb2JcclxuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN2Z0Jsb2IpXHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIGZyb20gdGhlIFNWR1xyXG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgc3ZnTm9kZUNsb25lLmdldEF0dHJpYnV0ZSgnd2lkdGgnKVxyXG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBzdmdOb2RlQ2xvbmUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxyXG5cclxuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVkcgd2lkdGggb3IgaGVpZ2h0IGF0dHJpYnV0ZXMgYXJlIG1pc3Npbmcgb3IgaW52YWxpZC4nKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCA0OiBDcmVhdGUgYW4gSW1hZ2UgZWxlbWVudCBhbmQgbG9hZCB0aGUgQmxvYiBVUkxcclxuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxyXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFN0ZXAgNTogRHJhdyB0aGUgaW1hZ2Ugb24gYSBjYW52YXNcclxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcGFyc2VGbG9hdCh3aWR0aCkgLy8gU2V0IGNhbnZhcyB3aWR0aCBmcm9tIFNWRydzIHdpZHRoIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQpIC8vIFNldCBjYW52YXMgaGVpZ2h0IGZyb20gU1ZHJ3MgaGVpZ2h0IGF0dHJpYnV0ZVxyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCA2OiBDb252ZXJ0IHRoZSBjYW52YXMgdG8gYSBQTkcgYmxvYlxyXG4gICAgICAgICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChwbmdCbG9iKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGVwIDc6IERvd25sb2FkIHRoZSBQTkcgZmlsZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcG5nVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChwbmdCbG9iKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuaHJlZiA9IHBuZ1VybFxyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRMaW5rLmRvd25sb2FkID0gJ2V1cm9zdGF0LW1hcC5wbmcnXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkTGluaylcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5jbGljaygpXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkTGluaylcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBVUkxzXHJcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcclxuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwocG5nVXJsKVxyXG4gICAgICAgICAgICB9LCAnaW1hZ2UvcG5nJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgaW1hZ2Ugc291cmNlIHRvIHRoZSBCbG9iIFVSTFxyXG4gICAgICAgIGltZy5zcmMgPSB1cmxcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgc29tZSBVUkwgcGFyYW1ldGVycywgd2hpY2ggY291bGQgYmUgdGhlbiByZXVzZWQgYXMgbWFwIGRlZmluaXRpb24gcGFyYW1ldGVycy5cclxuICogVGhpcyBhbGxvdyBhIHF1aWNrIG1hcCBjdXN0b21pc2F0aW9uIGJ5IHNpbXBseSBhZGRpbmcgYW5kIGNoYW5naW5nIHNvbWUgVVJMIHBhcmFtZXRlcnMuXHJcbiAqIFNlZSBtYXAgbWV0aG9kOiBzZXRGcm9tVVJMKC4uLilcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVUkxQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgcHMgPSB7fVxyXG4gICAgY29uc3QgcCA9IFsndycsICdoJywgJ3gnLCAneScsICd6JywgJ3MnLCAnbHZsJywgJ3RpbWUnLCAncHJvaicsICdnZW8nLCAnbnknLCAnbGFuZ3VhZ2UnLCAnc2wnLCAnbnVtYmVyT2ZDbGFzc2VzJ11cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykgcHNbcFtpXV0gPSBnZXRVUkxQYXJhbWV0ZXJCeU5hbWUocFtpXSlcclxuICAgIHJldHVybiBwc1xyXG59XHJcbiIsIi8vIGUuZy4gdG8gYmUgdXNlZCB3aXRoIGRlcHJlY2F0ZWQgLnN0eWxlKCkgZnVuY3Rpb25zLiBUaGV5IHdpbGwgbm93IHVwZGF0ZSBDU1MgY2xhc3Nlcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNTU1J1bGUoc2VsZWN0b3IsIHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgLy8gVmFsaWRhdGUgdGhlIHNlbGVjdG9yXHJcbiAgICBpZiAoIXNlbGVjdG9yLnN0YXJ0c1dpdGgoJy4nKSAmJiAhc2VsZWN0b3Iuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yOiBNdXN0IHN0YXJ0IHdpdGggXCIuXCIgZm9yIGNsYXNzZXMgb3IgXCIjXCIgZm9yIElEcy4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIHRoZSBydWxlIGFscmVhZHkgZXhpc3RzIGluIGFueSBzdHlsZXNoZWV0XHJcbiAgICBjb25zdCBzdHlsZVNoZWV0cyA9IEFycmF5LmZyb20oZG9jdW1lbnQuc3R5bGVTaGVldHMpXHJcbiAgICBmb3IgKGNvbnN0IHN0eWxlU2hlZXQgb2Ygc3R5bGVTaGVldHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IHN0eWxlU2hlZXQuY3NzUnVsZXMgfHwgc3R5bGVTaGVldC5ydWxlc1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yVGV4dCA9PT0gc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb3BlcnR5IGlmIHRoZSBydWxlIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGVbcHJvcGVydHldID0gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gU29tZSBzdHlsZXNoZWV0cyAoZS5nLiwgY3Jvc3Mtb3JpZ2luKSBtYXkgbm90IGJlIGFjY2Vzc2libGVcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgYWNjZXNzIHJ1bGVzIGluIHN0eWxlc2hlZXQ6YCwgZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHJ1bGUgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IHN0eWxlc2hlZXQgYW5kIGFkZCBpdFxyXG4gICAgbGV0IGN1c3RvbVNoZWV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1c3RvbS1zdHlsZXMnKVxyXG4gICAgaWYgKCFjdXN0b21TaGVldCkge1xyXG4gICAgICAgIGN1c3RvbVNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxyXG4gICAgICAgIGN1c3RvbVNoZWV0LmlkID0gJ2N1c3RvbS1zdHlsZXMnXHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjdXN0b21TaGVldClcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIG5ldyBydWxlIHRvIHRoZSBjdXN0b20gc3R5bGVzaGVldFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjdXN0b21TaGVldC5zaGVldC5pbnNlcnRSdWxlKGAke3NlbGVjdG9yfSB7ICR7cHJvcGVydHl9OiAke3ZhbHVlfTsgfWAsIGN1c3RvbVNoZWV0LnNoZWV0LmNzc1J1bGVzLmxlbmd0aClcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaW5zZXJ0IHJ1bGU6ICR7c2VsZWN0b3J9IHsgJHtwcm9wZXJ0eX06ICR7dmFsdWV9OyB9YCwgZSlcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldEZvbnRTaXplRnJvbUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGNsYXNzXHJcbiAgICBjb25zdCB0ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICB0ZW1wRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWVcclxuXHJcbiAgICAvLyBBcHBseSBpbmxpbmUgc3R5bGVzIHRvIG1pbmltaXplIGxheW91dCBpbnRlcmZlcmVuY2VcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0bydcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5saW5lSGVpZ2h0ID0gJ25vcm1hbCdcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gJ2luaXRpYWwnXHJcblxyXG4gICAgLy8gQXBwZW5kIGRpcmVjdGx5IHRvIHRoZSBib2R5XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBFbGVtZW50KVxyXG5cclxuICAgIC8vIEdldCB0aGUgY29tcHV0ZWQgZm9udC1zaXplIHByb3BlcnR5IGFuZCBwYXJzZSBpdCB0byBhIG51bWJlclxyXG4gICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRlbXBFbGVtZW50KS5mb250U2l6ZSlcclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGJvZHlcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQpXHJcblxyXG4gICAgcmV0dXJuIGZvbnRTaXplIHx8IDBcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldENTU1Byb3BlcnR5RnJvbUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgcHJvcGVydHlOYW1lKSB7XHJcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgY2xhc3NcclxuICAgIGNvbnN0IHRlbXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIHRlbXBFbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxyXG5cclxuICAgIC8vIEFwcGx5IGlubGluZSBzdHlsZXMgdG8gbWluaW1pemUgbGF5b3V0IGludGVyZmVyZW5jZVxyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUud2lkdGggPSAnYXV0bydcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQgPSAnbm9ybWFsJ1xyXG5cclxuICAgIC8vIEFwcGVuZCBkaXJlY3RseSB0byB0aGUgYm9keVxyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRWxlbWVudClcclxuXHJcbiAgICAvLyBHZXQgdGhlIGNvbXB1dGVkIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcclxuICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZW1wRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpXHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZWxlbWVudCBmcm9tIHRoZSBkb2N1bWVudCBib2R5XHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KVxyXG5cclxuICAgIHJldHVybiBwcm9wZXJ0eVZhbHVlIHx8IG51bGxcclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhbGwgQ1NTIHJ1bGVzIGRlZmluZWQgaW4gdGhlIGRvY3VtZW50XHJcbmZ1bmN0aW9uIGdldEFsbENTU1J1bGVzKCkge1xyXG4gICAgbGV0IGNzc1J1bGVzID0gW11cclxuICAgIGZvciAobGV0IHNoZWV0IG9mIGRvY3VtZW50LnN0eWxlU2hlZXRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gU29tZSBzdHlsZXNoZWV0cyBtYXkgbm90IGJlIGFjY2Vzc2libGUgZHVlIHRvIENPUlMsIHNvIHdlIGNhdGNoIGFueSBlcnJvcnNcclxuICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBzaGVldC5jc3NSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgY3NzUnVsZXMucHVzaChydWxlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBhY2Nlc3Mgc3R5bGVzaGVldDonLCBzaGVldC5ocmVmLCBlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjc3NSdWxlc1xyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGV4cGxpY2l0bHkgZGVmaW5lZCBzdHlsZXMgZnJvbSBDU1MgZm9yIGFuIGVsZW1lbnRcclxuZnVuY3Rpb24gZ2V0U3R5bGVzRnJvbUNTUyhlbGVtZW50KSB7XHJcbiAgICBsZXQgbWF0Y2hlZFJ1bGVzID0gW11cclxuICAgIGNvbnN0IGNzc1J1bGVzID0gZ2V0QWxsQ1NTUnVsZXMoKVxyXG5cclxuICAgIGNzc1J1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudC5tYXRjaGVzKHJ1bGUuc2VsZWN0b3JUZXh0KSkge1xyXG4gICAgICAgICAgICBtYXRjaGVkUnVsZXMucHVzaChydWxlLnN0eWxlKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy8gQ3JlYXRlIGFuIG9iamVjdCBvZiB0aGUgZXhwbGljaXRseSBzZXQgc3R5bGVzXHJcbiAgICBsZXQgZXhwbGljaXRTdHlsZXMgPSB7fVxyXG4gICAgbWF0Y2hlZFJ1bGVzLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHN0eWxlW2ldXHJcbiAgICAgICAgICAgIGV4cGxpY2l0U3R5bGVzW3Byb3BlcnR5XSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gZXhwbGljaXRTdHlsZXNcclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGlubGluZSBzdHlsZXMgZXhwbGljaXRseSBzZXQgaW4gQ1NTLiBVc2VmdWwgZm9yIGV4cG9ydGluZyBTVkdzIHdpdGggQ1NTIHN0eWxlcy5cclxuZXhwb3J0IGNvbnN0IGFwcGx5SW5saW5lU3R5bGVzRnJvbUNTUyA9IChzdmdFbGVtZW50KSA9PiB7XHJcbiAgICBjb25zdCBhbGxFbGVtZW50cyA9IHN2Z0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpXHJcblxyXG4gICAgYWxsRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNzc1N0eWxlcyA9IGdldFN0eWxlc0Zyb21DU1MoZWxlbWVudClcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgZWFjaCBleHBsaWNpdGx5IGRlZmluZWQgQ1NTIHN0eWxlIGFzIGFuIGlubGluZSBzdHlsZVxyXG4gICAgICAgIE9iamVjdC5rZXlzKGNzc1N0eWxlcykuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjc3NTdHlsZXNbcHJvcGVydHldXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcHJvcGVydHkgYWxyZWFkeSBoYXMgYW4gaW5saW5lIHN0eWxlXHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW5saW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXHJcblxyXG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nSW5saW5lU3R5bGUgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIG5vIGV4aXN0aW5nIGlubGluZSBzdHlsZSwgc2V0IHRoZSBuZXcgc3R5bGVcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBHZW9KU09OIGZlYXR1cmUgcmVwcmVzZW50aW5nIGEgYm91bmRpbmcgYm94LCB3aXRoIG11bHRpcG9pbnQgZ2VvbWV0cnkuXHJcbiAqIFRoaXMgYm91bmRpbmcgYm94IGlzIGFuIGFycmF5IGxpa2UgdGhlIG9uZSBpbiB0b3BvanNvbiBiYm94IGVsZW1lbnQuXHJcbiAqIFt4bWluLHltaW4seG1heCx5bWF4XVxyXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgdG8gY2FsbCBkMy5maXRTaXplKFt3LCBoXSwgZ2V0VG9wb0pTT05FeHRlbnRBc0dlb0pTT04odG9wby5iYm94KSkpXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gYmIgVGhlIGJvdW5kaW5nIGJveCBbeG1pbix5bWluLHhtYXgseW1heF0uIEZvciB0b3BvanNvbiBkYXRhLCBqdXN0IGdpdmUgdGhlIHRvcG9qc29uLmJib3ggZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRCQk9YQXNHZW9KU09OID0gZnVuY3Rpb24gKGJiKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcclxuICAgICAgICBnZW9tZXRyeToge1xyXG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlQb2ludCcsXHJcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXHJcbiAgICAgICAgICAgICAgICBbYmJbMF0sIGJiWzFdXSxcclxuICAgICAgICAgICAgICAgIFtiYlsyXSwgYmJbM11dLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0sXHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIGluZGV4aW5nXHJcblxyXG4vKipcclxuICogSW5kZXggSlNPTlN0YXQgc3RhdCB2YWx1ZXMgYnkgJ2dlbycgY29kZS5cclxuICogUmV0dXJuIGEgc3RydWN0dXJlIGxpa2U6IHtnZW86e3ZhbHVlOjAsc3RhdHVzOlwiXCJ9fVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGpzRGF0YSBUaGUgSlNPTlN0YXQgZGF0YSB0byBpbmRleFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGpzb25zdGF0VG9JbmRleCA9IGZ1bmN0aW9uIChqc0RhdGEpIHtcclxuICAgIGNvbnN0IGluZCA9IHt9XHJcbiAgICBjb25zdCBnZW9zID0ganNEYXRhLkRpbWVuc2lvbignZ2VvJykuaWRcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2Vvcy5sZW5ndGg7IGkrKykgaW5kW2dlb3NbaV1dID0ganNEYXRhLkRhdGEoaSlcclxuICAgIHJldHVybiBpbmRcclxufVxyXG5cclxuLyoqXHJcbiAqIEluZGV4IENTViBzdGF0IHZhbHVlcyBieSAnZ2VvJyBjb2RlLlxyXG4gKiBSZXR1cm4gYSBzdHJ1Y3R1cmUgbGlrZToge2dlbzp7dmFsdWU6MCxzdGF0dXM6XCJcIn19XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY3N2RGF0YSBUaGUgQ1NWIGRhdGEgdG8gaW5kZXhcclxuICogQHBhcmFtIHsqfSBnZW9Db2wgVGhlIG5hbWUgb2YgdGhlIGdlbyBjb2x1bW4gaW4gdGhlIENTViBkYXRhXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVDb2wgVGhlIG5hbWUgb2YgdGhlIHN0YXRpc3RpY2FsIHZhbHVlIGNvbHVtbiBpbiB0aGUgQ1NWIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY3N2VG9JbmRleCA9IGZ1bmN0aW9uIChjc3ZEYXRhLCBnZW9Db2wsIHZhbHVlQ29sKSB7XHJcbiAgICBjb25zdCBpbmQgPSB7fVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3ZEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IGNzdkRhdGFbaV1cclxuICAgICAgICBjb25zdCB2ID0gZFt2YWx1ZUNvbF1cclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgaW5kW2RbZ2VvQ29sXV0gPSB7IHZhbHVlOiAnOicsIHN0YXR1czogJycgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZFtkW2dlb0NvbF1dID0geyB2YWx1ZTogaXNOYU4oK3YpID8gdiA6ICt2LCBzdGF0dXM6ICcnIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5kXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBzdHJpbmcgd2l0aCBzcGFjZSBhcyB0aG91c2FuZCBzZXBhcmF0b3JcclxuICogQGZ1bmN0aW9uIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yID0gZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgcmV0dXJuIG51bWJlci50b0xvY2FsZVN0cmluZygnZW4nKS5yZXBsYWNlKC8sL2dpLCAnICcpXHJcbn1cclxuXHJcbi8vUkVTVCBBUElcclxuZXhwb3J0IGNvbnN0IGdldEVzdGF0UmVzdERhdGFVUkxCYXNlID0gJ2h0dHBzOi8vZWMuZXVyb3BhLmV1L2V1cm9zdGF0L2FwaS9kaXNzZW1pbmF0aW9uL3N0YXRpc3RpY3MvMS4wL2RhdGEvJ1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIFVSTCB0byBmZXRjaCBkYXRhIGZyb20gZXVyb2Jhc2UgUkVTVCBBUEkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0Q29kZSBUaGUgRXVyb2Jhc2UgZGF0YXNldCBjb2RlXHJcbiAqIEBwYXJhbSB7b2JqZWN0PX0gZmlsdGVycyBUaGUgZmlsdGVyIHBhcmFtZXRlcnMgYXMgZm9yIGV4YW1wbGU6IHtrZXk6dmFsdWUsa2V5Olt2YWx1ZTEsdmFsdWUyLHZhbHVlM119XHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gbGFuZ1xyXG4gKiBAcGFyYW0ge251bWJlcj19IGZvcm1hdFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHZlcnNpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRFc3RhdERhdGFVUkwgPSBmdW5jdGlvbiAoZGF0YXNldENvZGUsIGZpbHRlcnMsIGxhbmcsIGZvcm1hdCkge1xyXG4gICAgbGFuZyA9IGxhbmcgfHwgJ2VuJ1xyXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICdqc29uJ1xyXG4gICAgdmFyIHVybCA9IFtdXHJcbiAgICB1cmwucHVzaChnZXRFc3RhdFJlc3REYXRhVVJMQmFzZSwgZGF0YXNldENvZGUsICc/JywgJ2Zvcm1hdD0nLCBmb3JtYXQsICcmbGFuZz0nLCBsYW5nKVxyXG4gICAgaWYgKGZpbHRlcnMpXHJcbiAgICAgICAgZm9yICh2YXIgcGFyYW0gaW4gZmlsdGVycykge1xyXG4gICAgICAgICAgICB2YXIgbyA9IGZpbHRlcnNbcGFyYW1dXHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHVybC5wdXNoKCcmJywgcGFyYW0sICc9Jywgb1tpXSlcclxuICAgICAgICAgICAgZWxzZSB1cmwucHVzaCgnJicsIHBhcmFtLCAnPScsIG8pXHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHVybC5qb2luKCcnKVxyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRVUkxQYXJhbWV0ZXJCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpXHJcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdbXFxcXD8mXScgKyBuYW1lICsgJz0oW14mI10qKScpLFxyXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKGxvY2F0aW9uLnNlYXJjaClcclxuICAgIHJldHVybiAhcmVzdWx0cyA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSlcclxufVxyXG5cclxuLy9mbGFnc1xyXG5leHBvcnQgY29uc3QgZmxhZ3MgPSB7XHJcbiAgICBiOiAnYnJlYWsgaW4gdGltZSBzZXJpZXMnLFxyXG4gICAgYzogJ2NvbmZpZGVudGlhbCcsXHJcbiAgICBkOiAnZGVmaW5pdGlvbiBkaWZmZXJzLCBzZWUgbWV0YWRhdGEnLFxyXG4gICAgZTogJ2VzdGltYXRlZCcsXHJcbiAgICBmOiAnZm9yZWNhc3QnLFxyXG4gICAgbjogJ25vdCBzaWduaWZpY2FudCcsXHJcbiAgICBwOiAncHJvdmlzaW9uYWwnLFxyXG4gICAgcjogJ3JldmlzZWQnLFxyXG4gICAgczogJ0V1cm9zdGF0IGVzdGltYXRlJyxcclxuICAgIHU6ICdsb3cgcmVsaWFiaWxpdHknLFxyXG4gICAgejogJ25vdCBhcHBsaWNhYmxlJyxcclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBFeGVjdXRlcyBhIGZ1bmN0aW9uIGZvciBhbGwgaW5zZXQgbWFwcy4gU29tZSBpbnNldHMgbWlnaHQgYmUgZXh0ZXJuYWwgU1ZHcyB3aGljaCBpcyB3aHkgdGhpcyBmdW5jdGlvbiB3YXMgY3JlYXRlZC5cclxuICogQHBhcmFtIHsqfSBpbnNldHMgbWFwLmluc2V0c1xyXG4gKiBAcGFyYW0geyp9IG1haW5TdmdJZCB0aGUgSUQgb2YgdGhlIG1hcCdzIHN2Z1xyXG4gKiBAcGFyYW0geyp9IGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGluc2V0XHJcbiAqIEBwYXJhbSB7Kn0gW3BhcmFtZXRlcj1udWxsXSB0aGUgcGFyYW1ldGVyIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7Kn0gW3BhcmFtZXRlcjI9bnVsbF0gdGhlIHBhcmFtZXRlciB0byBwYXNzIHRvIHRoZSBjYWxsYmFja1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGV4ZWN1dGVGb3JBbGxJbnNldHMgPSBmdW5jdGlvbiAoaW5zZXRzLCBtYWluU3ZnSWQsIGNhbGxiYWNrLCBwYXJhbWV0ZXIgPSBudWxsLCBwYXJhbWV0ZXIyID0gbnVsbCkge1xyXG4gICAgZm9yIChjb25zdCBnZW8gaW4gaW5zZXRzKSB7XHJcbiAgICAgICAgY29uc3QgaW5zZXRHcm91cCA9IGluc2V0c1tnZW9dXHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc2V0R3JvdXApKSB7XHJcbiAgICAgICAgICAgIGluc2V0R3JvdXAuZm9yRWFjaCgoaW5zZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgYXJyYXlzIGZvciBtdWx0aXBsZSBpbnNldHMgd2l0aCB0aGUgc2FtZSBnZW9cclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2V0LmZvckVhY2goKG5lc3RlZEluc2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRJbnNldC5zdmdJZF8gIT09IG1haW5TdmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmVzdGVkSW5zZXQsIHBhcmFtZXRlciwgcGFyYW1ldGVyMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNldC5zdmdJZF8gIT09IG1haW5TdmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnNldCwgcGFyYW1ldGVyLCBwYXJhbWV0ZXIyKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjYWxsYmFjayB0byB1bmlxdWUgaW5zZXRcclxuICAgICAgICAgICAgaWYgKGluc2V0R3JvdXAuc3ZnSWRfICE9PSBtYWluU3ZnSWQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc2V0R3JvdXAsIHBhcmFtZXRlciwgcGFyYW1ldGVyMilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZUZpcnN0TGV0dGVyID0gKHN0cmluZykgPT4gYCR7c3RyaW5nLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCl9JHtzdHJpbmcuc2xpY2UoMSl9YFxyXG5cclxuZXhwb3J0IGNvbnN0IGxvd2VyQ2FzZUFsbFdvcmRzRXhjZXB0Rmlyc3RMZXR0ZXJzID0gKHN0cmluZykgPT5cclxuICAgIHN0cmluZy5yZXBsYWNlQWxsKC9cXFMqL2csICh3b3JkKSA9PiBgJHt3b3JkLnNsaWNlKDAsIDEpfSR7d29yZC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpfWApXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG93bmxvYWRVUkwoc3ZnTm9kZSkge1xyXG4gICAgLy8gQ3JlYXRlIFhNTCBoZWFkZXIgdG8gZW5zdXJlIHRoZSBTVkcgaXMgcmVjb2duaXplZCBwcm9wZXJseVxyXG4gICAgY29uc3QgeG1sSGVhZGVyID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cIm5vXCI/PlxcbidcclxuXHJcbiAgICAvLyBjcmVhdGUgYmxvYlxyXG4gICAgY29uc3Qgc3ZnQ29udGVudCA9IHhtbEhlYWRlciArIHN2Z05vZGUub3V0ZXJIVE1MXHJcbiAgICBjb25zdCBzdmdCbG9iID0gbmV3IEJsb2IoW3N2Z0NvbnRlbnRdLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgnIH0pXHJcbiAgICBjb25zdCBzdmdVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN2Z0Jsb2IpXHJcbiAgICByZXR1cm4gc3ZnVXJsXHJcbn1cclxuXHJcbi8vIFJhc3Rlcml6ZSBmdW5jdGlvbiB3aXRoIGFkZGl0aW9uYWwgZXJyb3IgaGFuZGxpbmdcclxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShzdmcpIHtcclxuICAgIGNvbnN0IHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xyXG4gICAgY29uc3QgeGxpbmtucyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xyXG4gICAgY29uc3Qgc3ZnbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXHJcbiAgICBjb25zdCBmcmFnbWVudCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmICsgJyMnXHJcbiAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHN2ZywgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIG51bGwsIGZhbHNlKVxyXG4gICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHdhbGtlci5jdXJyZW50Tm9kZS5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlLmluY2x1ZGVzKGZyYWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IGF0dHIudmFsdWUucmVwbGFjZShmcmFnbWVudCwgJyMnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3ZnLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCAneG1sbnMnLCBzdmducylcclxuICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyh4bWxucywgJ3htbG5zOnhsaW5rJywgeGxpbmtucylcclxuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgd2luZG93LlhNTFNlcmlhbGl6ZXIoKVxyXG4gICAgY29uc3Qgc3RyaW5nID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmcpXHJcbiAgICByZXR1cm4gbmV3IEJsb2IoW3N0cmluZ10sIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWwnIH0pXHJcbn1cclxuXHJcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL3NhdmluZy1zdlxyXG4vL3N2ZyB0byBjYW52YXMgYmxvYiBwcm9taXNlXHJcbmV4cG9ydCBmdW5jdGlvbiByYXN0ZXJpemUoc3ZnKSB7XHJcbiAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0XHJcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHksIG4pID0+ICgocmVzb2x2ZSA9IHkpLCAocmVqZWN0ID0gbikpKVxyXG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKVxyXG4gICAgaW1hZ2Uub25lcnJvciA9IHJlamVjdFxyXG4gICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlY3QgPSBzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGhcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHRcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpXHJcbiAgICAgICAgY29udGV4dC5jYW52YXMudG9CbG9iKHJlc29sdmUpXHJcbiAgICB9XHJcbiAgICBpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHNlcmlhbGl6ZShzdmcpKVxyXG4gICAgcmV0dXJuIHByb21pc2VcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIFVSTCBwYXJhbWV0ZXIgYnkgbmFtZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUpIHtcclxuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKVxyXG4gICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgbmFtZSArICc9KFteJiNdKiknKSxcclxuICAgICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpXHJcbiAgICByZXR1cm4gIXJlc3VsdHMgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBoZXhUb1JnYiA9IChoZXgpID0+IHtcclxuICAgIGhleCA9IGhleC5yZXBsYWNlKCcjJywgJycpXHJcbiAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgIGhleCA9IGhleFxyXG4gICAgICAgICAgICAuc3BsaXQoJycpXHJcbiAgICAgICAgICAgIC5tYXAoKGgpID0+IGggKyBoKVxyXG4gICAgICAgICAgICAuam9pbignJylcclxuICAgIH1cclxuICAgIGNvbnN0IGludCA9IHBhcnNlSW50KGhleCwgMTYpXHJcbiAgICByZXR1cm4gWyhpbnQgPj4gMTYpICYgMjU1LCAoaW50ID4+IDgpICYgMjU1LCBpbnQgJiAyNTVdXHJcbn1cclxuXHJcbi8vYmxlbmRzIHR3byBjb2xvcnMgdXNpbmcgJ211bHRpcGx5JyBibGVuZGluZyBtb2RlLiBSZXR1cm5zIHRoZSBibGVuZGVkIGNvbG9yIGFzIGFuIFJHQiBzdHJpbmdcclxuZXhwb3J0IGNvbnN0IG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleCA9IChjb2xvcnMpID0+IHtcclxuICAgIC8vIENvbnZlcnQgaGV4IGNvbG9yIHRvIFJHQlxyXG4gICAgY29uc3QgaGV4VG9SZ2IgPSAoaGV4KSA9PiB7XHJcbiAgICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoJyMnLCAnJylcclxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICBoZXggPSBoZXhcclxuICAgICAgICAgICAgICAgIC5zcGxpdCgnJylcclxuICAgICAgICAgICAgICAgIC5tYXAoKGgpID0+IGggKyBoKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGludCA9IHBhcnNlSW50KGhleCwgMTYpXHJcbiAgICAgICAgcmV0dXJuIFsoaW50ID4+IDE2KSAmIDI1NSwgKGludCA+PiA4KSAmIDI1NSwgaW50ICYgMjU1XVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgUkdCIHRvIGhleFxyXG4gICAgY29uc3QgcmdiVG9IZXggPSAoW3IsIGcsIGJdKSA9PiBgIyR7W3IsIGcsIGJdLm1hcCgoYykgPT4gYy50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyl9YFxyXG5cclxuICAgIC8vIENvbnZlcnQgYWxsIGhleCBjb2xvcnMgdG8gUkdCIGFycmF5c1xyXG4gICAgY29uc3QgcmdiQ29sb3JzID0gY29sb3JzLm1hcChoZXhUb1JnYilcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSByZXN1bHQgd2l0aCB0aGUgZmlyc3QgY29sb3JcclxuICAgIGxldCBibGVuZGVkID0gWy4uLnJnYkNvbG9yc1swXV1cclxuXHJcbiAgICAvLyBTZXF1ZW50aWFsbHkgbXVsdGlwbHkgZWFjaCBjb2xvciB3aXRoIHRoZSByZXN1bHRcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmdiQ29sb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYmxlbmRlZCA9IGJsZW5kZWQubWFwKCh2LCBpZHgpID0+IE1hdGgucm91bmQoKHYgLyAyNTUpICogKHJnYkNvbG9yc1tpXVtpZHhdIC8gMjU1KSAqIDI1NSkpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBibGVuZGVkIGNvbG9yIGFzIGEgaGV4IGNvZGVcclxuICAgIHJldHVybiByZ2JUb0hleChibGVuZGVkKVxyXG59XHJcblxyXG4vLyBjb252ZXJ0IHJlY3QgYXR0cmlidXRlcyBpbnRvIGFuIFNWRyBwYXRoIHN0cmluZ1xyXG4vLyB1c2VkIGZvciB3b3JrYXJvdW5kIHdoZXJlYnkgY2xpcFBhdGhzIHdoaWNoIHVzZSByZWN0IGVsZW1lbnRzIGRvIG5vdCB3b3JrIGluIGFkb2JlIGlsbHVzdHJhdG9yXHJcbmV4cG9ydCBjb25zdCBjb252ZXJ0UmVjdGFuZ2xlc1RvUGF0aHMgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KHgsIDEwKVxyXG4gICAgdmFyIHkgPSBwYXJzZUZsb2F0KHksIDEwKVxyXG4gICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh3aWR0aCwgMTApXHJcbiAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQsIDEwKVxyXG5cclxuICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB3aWR0aCA8IDAgfHwgaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgIHJldHVybiAnJ1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnTScgKyB4ICsgJywnICsgeSArICdMJyArICh4ICsgd2lkdGgpICsgJywnICsgeSArICcgJyArICh4ICsgd2lkdGgpICsgJywnICsgKHkgKyBoZWlnaHQpICsgJyAnICsgeCArICcsJyArICh5ICsgaGVpZ2h0KSArICd6J1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZCA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgIGxldCByLCBnLCBiXHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGVsZW1lbnQgdG8gaGFuZGxlIG5hbWVkIGNvbG9yc1xyXG4gICAgaWYgKCFiYWNrZ3JvdW5kQ29sb3Iuc3RhcnRzV2l0aCgncmdiJykgJiYgIWJhY2tncm91bmRDb2xvci5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgICBjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgICB0ZW1wRGl2LnN0eWxlLmNvbG9yID0gYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRGl2KVxyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZW1wRGl2KS5jb2xvclxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVtcERpdilcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBjb21wdXRlZENvbG9yIC8vIENvbnZlcnQgbmFtZWQgY29sb3IgdG8gUkdCXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIGhleCBjb2xvcnMgbGlrZSAnI0ZGRkZGRicgb3IgJyNGRkYnXHJcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgIGxldCBoZXggPSBiYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgnIycsICcnKVxyXG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIGhleCA9IGhleFxyXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoYykgPT4gYyArIGMpXHJcbiAgICAgICAgICAgICAgICAuam9pbignJylcclxuICAgICAgICB9XHJcbiAgICAgICAgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMCwgMiksIDE2KVxyXG4gICAgICAgIGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDIsIDQpLCAxNilcclxuICAgICAgICBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpXHJcbiAgICB9XHJcbiAgICAvLyBIYW5kbGUgUkdCIGNvbG9ycyBsaWtlICdyZ2IoMjU1LDI1NSwyNTUpJ1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gYmFja2dyb3VuZENvbG9yLm1hdGNoKC9cXGQrL2cpXHJcbiAgICAgICAgciA9IHBhcnNlSW50KHJnYlswXSlcclxuICAgICAgICBnID0gcGFyc2VJbnQocmdiWzFdKVxyXG4gICAgICAgIGIgPSBwYXJzZUludChyZ2JbMl0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGx1bWluYW5jZVxyXG4gICAgY29uc3QgbHVtaW5hbmNlID0gMC4yMTI2ICogKHIgLyAyNTUpICsgMC43MTUyICogKGcgLyAyNTUpICsgMC4wNzIyICogKGIgLyAyNTUpXHJcblxyXG4gICAgLy8gUmV0dXJuIGJsYWNrIGZvciBsaWdodCBiYWNrZ3JvdW5kcywgd2hpdGUgZm9yIGRhcmsgYmFja2dyb3VuZHNcclxuICAgIHJldHVybiBsdW1pbmFuY2UgPiAwLjUgPyAnYmxhY2snIDogJ3doaXRlJ1xyXG59XHJcblxyXG4vLyBnZXQgY3NzIHNlbGVjdG9yLiBEaWZmZXJlbnQgbWFwcyBoYXZlIGRpZmZlcmVudCBzZWxlY3RvcnMgZm9yIHRoZWlyIHJlZ2lvbnNcclxuZXhwb3J0IGNvbnN0IGdldFJlZ2lvbnNTZWxlY3RvciA9IChtYXApID0+IHtcclxuICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgcmV0dXJuICcjZW0tdXNlci1yZWdpb25zIHBhdGgnXHJcbiAgICBpZiAobWFwLmdyaWRDYXJ0b2dyYW1fKSByZXR1cm4gJyNlbS1ncmlkLWNvbnRhaW5lciAuZW0tZ3JpZC1jZWxsJ1xyXG4gICAgaWYgKG1hcC5nZW9fID09PSAnV09STEQnKSByZXR1cm4gJyNlbS13b3JsZHJnIHBhdGgnXHJcbiAgICByZXR1cm4gJyNlbS1udXRzcmcgcGF0aCwgI2VtLWNudHJnIHBhdGgnXHJcbn1cclxuXHJcbi8vIGdldCBjc3Mgc2VsZWN0b3IgZm9yIGxlZ2VuZCBtb3VzZSBob3Zlci4gRGlmZmVyZW50IG1hcHMgaGF2ZSBkaWZmZXJlbnQgc2VsZWN0b3JzIGZvciB0aGVpciByZWdpb25zXHJcbmV4cG9ydCBjb25zdCBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IgPSAobWFwKSA9PiB7XHJcbiAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHJldHVybiAnI2VtLXVzZXItcmVnaW9ucydcclxuICAgIGlmIChtYXAuZ3JpZENhcnRvZ3JhbV8pIHJldHVybiAnI2VtLWdyaWQtY29udGFpbmVyJ1xyXG4gICAgaWYgKG1hcC5nZW9fID09PSAnV09STEQnKSByZXR1cm4gJyNlbS13b3JsZHJnJ1xyXG4gICAgcmV0dXJuICcjZW0tbnV0c3JnLCAjZW0tY250cmcnXHJcbn1cclxuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4LmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xub3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4LmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsImltcG9ydCAqIGFzIENob3JvcGxldGggZnJvbSAnLi9tYXB0eXBlcy9tYXAtY2hvcm9wbGV0aCdcclxuaW1wb3J0ICogYXMgUHJvcG9ydGlvbmFsU3ltYm9sIGZyb20gJy4vbWFwdHlwZXMvbWFwLXByb3BvcnRpb25hbC1zeW1ib2xzJ1xyXG5pbXBvcnQgKiBhcyBDYXRlZ29yaWNhbCBmcm9tICcuL21hcHR5cGVzL21hcC1jYXRlZ29yaWNhbCdcclxuaW1wb3J0ICogYXMgQml2YXJpYXRlQ2hvcm9wbGV0aCBmcm9tICcuL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLWJpdmFyaWF0ZSdcclxuaW1wb3J0ICogYXMgVHJpdmFyaWF0ZUNob3JvcGxldGggZnJvbSAnLi9tYXB0eXBlcy9tYXAtY2hvcm9wbGV0aC10cml2YXJpYXRlJ1xyXG5pbXBvcnQgKiBhcyBTdHJpcGVDb21wb3NpdGlvbiBmcm9tICcuL21hcHR5cGVzL21hcC1zdHJpcGUtY29tcG9zaXRpb24nXHJcbmltcG9ydCAqIGFzIFBpZUNoYXJ0cyBmcm9tICcuL21hcHR5cGVzL21hcC1waWVjaGFydHMnXHJcbmltcG9ydCAqIGFzIFNwYXJrbGluZXMgZnJvbSAnLi9tYXB0eXBlcy9tYXAtc3BhcmtsaW5lcydcclxuaW1wb3J0ICogYXMgRmxvd01hcCBmcm9tICcuL21hcHR5cGVzL21hcC1mbG93J1xyXG5pbXBvcnQgKiBhcyBtdCBmcm9tICcuL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCB7IERFRkFVTFRMQUJFTFMgfSBmcm9tICcuL2NvcmUvbGFiZWxzJ1xyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhIGV1cm9zdGF0LW1hcCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdHlwZSBUaGUgdHlwZSBvZiBtYXAgKCdjaCcgZm9yIGNob3JvcGxldGgsIGV0Yy4pXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC4gRXguOiB7IHRpdGxlOiBcIk1hcCB0aXRsZVwiLCBnZW9DZW50ZXI6IFsyMzMsNjU0XSwgLi4ufVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcpIHtcclxuICAgIC8vY2hvcm9wbGV0aCBtYXBcclxuICAgIGlmICh0eXBlID09ICdjaG9yb3BsZXRoJyB8fCB0eXBlID09ICdjaCcpIHJldHVybiBDaG9yb3BsZXRoLm1hcChjb25maWcpXHJcbiAgICAvL2NhdGVnb3JpY2FsIG1hcFxyXG4gICAgaWYgKHR5cGUgPT0gJ2NhdGVnb3JpY2FsJyB8fCB0eXBlID09ICdjdCcpIHJldHVybiBDYXRlZ29yaWNhbC5tYXAoY29uZmlnKVxyXG4gICAgLy9wcm9wb3J0aW9ubmFsIHN5bWJvbHMgbWFwXHJcbiAgICBpZiAodHlwZSA9PSAncHJvcG9ydGlvbmFsU3ltYm9sJyB8fCB0eXBlID09ICdwcycpIHJldHVybiBQcm9wb3J0aW9uYWxTeW1ib2wubWFwKGNvbmZpZylcclxuICAgIC8vYml2YXJpYXRlIGNob3JvcGxldGhcclxuICAgIGlmICh0eXBlID09ICdiaXZhcmlhdGVDaG9yb3BsZXRoJyB8fCB0eXBlID09ICdjaGJpJykgcmV0dXJuIEJpdmFyaWF0ZUNob3JvcGxldGgubWFwKGNvbmZpZylcclxuICAgIC8vdHJpdmFyaWF0ZSBjaG9yb3BsZXRoXHJcbiAgICBpZiAodHlwZSA9PSAndHJpdmFyaWF0ZUNob3JvcGxldGgnIHx8IHR5cGUgPT0gJ2NoYmknKSByZXR1cm4gVHJpdmFyaWF0ZUNob3JvcGxldGgubWFwKGNvbmZpZylcclxuICAgIC8vc3RyaXBlcyBjb21wb3NpdGlvblxyXG4gICAgaWYgKHR5cGUgPT0gJ3N0cmlwZUNvbXBvc2l0aW9uJyB8fCB0eXBlID09ICdzY29tcCcpIHJldHVybiBTdHJpcGVDb21wb3NpdGlvbi5tYXAoY29uZmlnKVxyXG4gICAgLy9wcm9wb3J0aW9uYWwgcGllIGNoYXJ0c1xyXG4gICAgaWYgKHR5cGUgPT0gJ3BpZUNoYXJ0JyB8fCB0eXBlID09ICdwaWUnKSByZXR1cm4gUGllQ2hhcnRzLm1hcChjb25maWcpXHJcbiAgICAvL3NwYXJrbGluZSBtYXBzXHJcbiAgICBpZiAodHlwZSA9PSAnc3BhcmtsaW5lJyB8fCB0eXBlID09ICdzcGFyaycgfHwgdHlwZSA9PSAnc3BhcmtsaW5lcycpIHJldHVybiBTcGFya2xpbmVzLm1hcChjb25maWcpXHJcbiAgICAvL2Zsb3cgbWFwc1xyXG4gICAgaWYgKHR5cGUgPT0gJ2Zsb3cnIHx8IHR5cGUgPT0gJ2Zsb3dtYXAnKSByZXR1cm4gRmxvd01hcC5tYXAoY29uZmlnKVxyXG5cclxuICAgIC8vYWRkIG5ldyBtYXAgdHlwZXMgaGVyZVxyXG4gICAgLy9pZih0eXBlID09IFwiWFhcIikgcmV0dXJuIG1hcFhYLm1hcChjb25maWcpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkIG1hcCB0eXBlOiAnICsgdHlwZSlcclxuICAgIHJldHVybiBtdC5zdGF0TWFwKGNvbmZpZywgdHJ1ZSwgdHlwZSlcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGJ1aWxkcyBmaWxsIHBhdHRlcm5zIHN0eWxlLlxyXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gaGFzIGZvciBhcmd1bWVudHMgdGhlIFNWRyBlbGVtZW50IHdoZXJlIHRvIHVzZSB0aGUgZmlsbCBwYXR0ZXJuLCBhbmQgdGhlIG51bWJlciBvZiBjbGFzc2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG9wdHMgVmFyaW91cyBwYXJhbWV0ZXJzIG9uIHRoZSBmaWxsIHBhdHRlcm4uXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRGaWxsUGF0dGVybkRlZmluaXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG4gICAgb3B0cy5zaGFwZSA9IG9wdHMuc2hhcGUgfHwgJ2NpcmNsZSdcclxuICAgIGNvbnN0IHBzID0gb3B0cy5wYXR0ZXJuU2l6ZSB8fCA1XHJcbiAgICBjb25zdCBzbWluID0gb3B0cy5taW5TaXplIHx8IDFcclxuICAgIGNvbnN0IHNtYXggPSBvcHRzLm1heFNpemUgfHwgNS41XHJcbiAgICBvcHRzLmJja0NvbG9yID0gb3B0cy5iY2tDb2xvciB8fCAnd2hpdGUnXHJcbiAgICBvcHRzLnN5bWJDb2xvciA9IG9wdHMuc3ltYkNvbG9yIHx8ICdibGFjaydcclxuICAgIHJldHVybiBmdW5jdGlvbiAoc3ZnLCBudW1iZXJPZkNsYXNzZXMpIHtcclxuICAgICAgICAvL2NsZWFyIHByZXZpb3VzXHJcbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmVtLWZpbGwtcGF0dGVybicpLnJlbW92ZSgpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzaSA9IHNtaW4gKyAoKHNtYXggLSBzbWluKSAqIGkpIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpXHJcbiAgICAgICAgICAgIGNvbnN0IHBhdHQgPSBzdmdcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdHRlcm4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZpbGwtcGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAncGF0dGVybl8nICsgaSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJzAnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAnMCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBwcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBwcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdwYXR0ZXJuVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxyXG4gICAgICAgICAgICBwYXR0LmFwcGVuZCgncmVjdCcpLmF0dHIoJ3gnLCAwKS5hdHRyKCd5JywgMCkuYXR0cignd2lkdGgnLCBwcykuYXR0cignaGVpZ2h0JywgcHMpLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpLnN0eWxlKCdmaWxsJywgb3B0cy5iY2tDb2xvcilcclxuICAgICAgICAgICAgaWYgKG9wdHMuc2hhcGUgPT0gJ3NxdWFyZScpXHJcbiAgICAgICAgICAgICAgICBwYXR0LmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzaSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc2kpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgb3B0cy5zeW1iQ29sb3IpXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHBhdHQuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHBzICogMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHBzICogMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgc2kgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgb3B0cy5zeW1iQ29sb3IpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0RmlsbFBhdHRlcm5EZWZpbml0aW9uRnVuID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgIGNvbnNvbGUud2FybignZ2V0RmlsbFBhdHRlcm5EZWZpbml0aW9uRnVuIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIGdldEZpbGxQYXR0ZXJuRGVmaW5pdGlvbkZ1bmN0aW9uKCkgaW5zdGVhZC4nKVxyXG4gICAgcmV0dXJuIGdldEZpbGxQYXR0ZXJuRGVmaW5pdGlvbkZ1bmN0aW9uKG9wdHMpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0TGFiZWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIERFRkFVTFRMQUJFTFNcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIGNhdGVnb3JpY2FsIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IGZvciB0aGUgbWFwXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICAvL3RoZSB3aWR0aCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlV2lkdGggPSAxM1xyXG4gICAgLy90aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVIZWlnaHQgPSAxNVxyXG4gICAgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVQYWRkaW5nID0gNVxyXG4gICAgLy90aGUgZm9udCBzaXplIG9mIHRoZSBsZWdlbmQgbGFiZWxcclxuICAgIG91dC5sYWJlbEZvbnRTaXplID0gMTJcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxlZ2VuZCBib3ggZWxlbWVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBsYWJlbFxyXG4gICAgb3V0LmxhYmVsT2Zmc2V0ID0gNVxyXG4gICAgLy9zaG93IG5vIGRhdGFcclxuICAgIG91dC5ub0RhdGEgPSB0cnVlXHJcbiAgICAvL25vIGRhdGEgbGFiZWwgdGV4dFxyXG4gICAgb3V0Lm5vRGF0YVRleHQgPSAnTm8gZGF0YSdcclxuICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgdGhlIGxlZ2VuZCBlbGVtZW50cyBtYW51YWxseSBhcyBhbiBhcnJheVxyXG4gICAgb3V0Lm9yZGVyID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBpZiAob3V0LmxnZy5ub2RlKCkgJiYgb3V0Lm1hcC5jbGFzc2lmaWVyXykge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBsZWdlbmQgYmFja2dyb3VuZCBib3hcclxuICAgICAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgICAgICBpZiAob3V0LnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQudGl0bGUpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IGNhdGVnb3J5IGNvZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IG1hcC5jbGFzc1RvRmlsbFN0eWxlKCkgPyBPYmplY3Qua2V5cyhtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKSA6IG1hcC5jbGFzc2lmaWVyXy5kb21haW4oKVxyXG4gICAgICAgICAgICBjb25zdCBlY2xzID0gb3V0Lm9yZGVyID8gb3V0Lm9yZGVyIDogZG9tYWluXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgbGVnZW5kIGVsZW1lbnRzIGZvciBjbGFzc2VzOiByZWN0YW5nbGUgKyBsYWJlbFxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVjbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vdGhlIGNsYXNzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2xfID0gZWNsc1tpXVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsID0gbWFwLmNsYXNzaWZpZXJfKGVjbF8pXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSBtYXAuY2xhc3NUb0ZpbGxTdHlsZV9bZWNsX11cclxuXHJcbiAgICAgICAgICAgICAgICAvL3RoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgKyBpICogKG91dC5zaGFwZUhlaWdodCArIG91dC5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmaWxsQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIG91dC5zaGFwZVdpZHRoICsgb3V0LmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChtYXAuY2xhc3NUb1RleHQoKSA/IG1hcC5jbGFzc1RvVGV4dCgpW2VjbF9dIDogZWNsXylcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgICAgICBpZiAob3V0Lm5vRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArIGVjbHMubGVuZ3RoICogKG91dC5zaGFwZUhlaWdodCArIG91dC5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtYXAubm9EYXRhRmlsbFN0eWxlXylcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIHVuaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgLy8nbm8gZGF0YScgbGFiZWxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGxlZ2VuZCBib3ggZGltZW5zaW9uc1xyXG4gICAgICAgICAgICBvdXQuc2V0Qm94RGltZW5zaW9uKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHJlZ2lvbnMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gb3V0Lmdlb18gPT09ICdXT1JMRCcgPyAnI2VtLXdvcmxkcmcnIDogJyNlbS1udXRzcmcnXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSBzZWxlY3RvciA9ICcjZW0tdXNlci1yZWdpb25zJyAvLyBmb3IgdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoJ1tlY2xdJylcclxuXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZWdpb25zIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5zdHlsZSgnZmlsbCcsICd3aGl0ZScpXHJcblxyXG4gICAgICAgIC8vIEhpZ2hsaWdodCBvbmx5IHRoZSBzZWxlY3RlZCByZWdpb25zIGJ5IHJlc3RvcmluZyB0aGVpciBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUmVnaW9ucyA9IGFsbFJlZ2lvbnMuZmlsdGVyKFwiW2VjbD0nXCIgKyBlY2wgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsZWN0ZWRSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgcmVnaW9ucyB0byB0aGVpciBvcmlnaW5hbCBjb2xvcnMgb24gbW91c2VvdXRcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IGxpbmUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Rm9udFNpemVGcm9tQ2xhc3MsIGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIGNob3JvcGxldGgtYml2YXJpYXRlIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IGZvciB0aGUgbWFwXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICAvL3NpemVcclxuICAgIG91dC5zcXVhcmVTaXplID0gMTAwXHJcblxyXG4gICAgLy9vcmllbnRhdGlvblxyXG4gICAgb3V0LnJvdGF0aW9uID0gMFxyXG5cclxuICAgIC8vbGFiZWxzXHJcbiAgICBvdXQubGFiZWwxID0gJ1ZhcmlhYmxlIDEnXHJcbiAgICBvdXQubGFiZWwyID0gJ1ZhcmlhYmxlIDInXHJcblxyXG4gICAgLy9nZXQgdGhlIGZvbnQgc2l6ZSBvZiB0aGUgdGV4dHNcclxuICAgIG91dC5heGlzVGl0bGVGb250U2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1iaXZhcmlhdGUtYXhpcy10aXRsZScpXHJcblxyXG4gICAgLy9icmVha3NcclxuICAgIG91dC5icmVha3MxID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuYnJlYWtzMiA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnNob3dCcmVha3MgPSBmYWxzZSAvLyBpZiBzZXQgdG8gdHJ1ZSBhbmQgYnJlYWtzMSBhbmQgYnJlYWtzMiBhcmUgdW5kZWZpbmVkIHRoZW4gYnJlYWtzIGFyZSBhdXRvbWF0aWNhbGx5IGRlZmluZWRcclxuXHJcbiAgICAvL2F4aXNcclxuICAgIG91dC55QXhpc0xhYmVsc09mZnNldCA9IHsgeDogNywgeTogMCB9XHJcbiAgICBvdXQueEF4aXNMYWJlbHNPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfVxyXG5cclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhID0gdHJ1ZVxyXG4gICAgLy9zaG93IG5vIGRhdGFcclxuICAgIG91dC5ub0RhdGFTaGFwZUhlaWdodCA9IDIwXHJcbiAgICBvdXQubm9EYXRhU2hhcGVXaWR0aCA9IDI1XHJcblxyXG4gICAgLy9ubyBkYXRhIHRleHQgbGFiZWxcclxuICAgIG91dC5ub0RhdGFUZXh0ID0gJ05vIGRhdGEnXHJcblxyXG4gICAgLy9vdmVycmlkZSBwYWRkaW5nXHJcbiAgICBvdXQuYm94UGFkZGluZyA9IG91dC5sYWJlbEZvbnRTaXplXHJcblxyXG4gICAgLy9hZGQgZXh0cmEgZGlzdGFuY2UgYmV0d2VlbiBsZWdlbmQgYW5kIG5vIGRhdGEgaXRlbVxyXG4gICAgb3V0Lm5vRGF0YVlPZmZzZXQgPSAyMFxyXG5cclxuICAgIC8vYXJyb3dzXHJcbiAgICBvdXQuYXJyb3dIZWlnaHQgPSAxNVxyXG4gICAgb3V0LmFycm93V2lkdGggPSAxNFxyXG4gICAgb3V0LmFycm93UGFkZGluZyA9IDEwIC8vIHBhZGRpbmcgYmV0d2VlbiBhcnJvdyBhbmQgYXhpcyBsYWJlbFxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDbGFzc2VzID0gb3V0Lm1hcC5udW1iZXJPZkNsYXNzZXMoKVxyXG4gICAgICAgIGNvbnN0IHN6ID0gb3V0LnNxdWFyZVNpemUgLyBudW1iZXJPZkNsYXNzZXNcclxuICAgICAgICBjb25zdCB4YyA9IG91dC5yb3RhdGlvbiA9PT0gMCA/IDAgOiAwLjcwNzEgKiBvdXQuc3F1YXJlU2l6ZSArIG91dC5ib3hQYWRkaW5nXHJcblxyXG4gICAgICAgIC8vIEhvcml6b250YWwgc2hpZnQgdG8gbW92ZSBldmVyeXRoaW5nIHJpZ2h0IChhZGp1c3QgdGhpcyB2YWx1ZSBhcyBuZWVkZWQpXHJcbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbE9mZnNldCA9IG91dC5heGlzVGl0bGVGb250U2l6ZSArIG91dC5hcnJvd1BhZGRpbmcgLy8gQWRqdXN0IHRoaXMgdmFsdWUgdG8gbW92ZSB0aGUgd2hvbGUgbGVnZW5kIHRvIHRoZSByaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvLyBEcmF3IGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIHtcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeGMgKyBob3Jpem9udGFsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgIGxldCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyA6IDApXHJcblxyXG4gICAgICAgIC8vIFNxdWFyZSBncm91cCB3aXRoIGhvcml6b250YWwgb2Zmc2V0XHJcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gbGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYml2YXJpYXRlLXNxdWFyZXMtY2hhcnQnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nICsgaG9yaXpvbnRhbE9mZnNldH0sJHt4YyArIHl9KSByb3RhdGUoJHtvdXQucm90YXRpb259KSB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZ30sMClgKVxyXG5cclxuICAgICAgICBjb25zdCBpbml0aWFsWCA9IG91dC55QXhpc0xhYmVsc09mZnNldC54XHJcblxyXG4gICAgICAgIC8vIERyYXcgcmVjdGFuZ2xlc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJPZkNsYXNzZXM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsMSA9IG51bWJlck9mQ2xhc3NlcyAtIGkgLSAxXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gbnVtYmVyT2ZDbGFzc2VzIC0gaiAtIDFcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGwgPSBvdXQubWFwLmNsYXNzVG9GaWxsU3R5bGUoKShlY2wxLCBlY2wyKVxyXG5cclxuICAgICAgICAgICAgICAgIHNxdWFyZVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtc3F1YXJlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGluaXRpYWxYICsgKG51bWJlck9mQ2xhc3NlcyAtIDEgLSBpKSAqIHN6KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaiAqIHN6KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHN6KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBzeilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmaWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbDEsIGVjbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgZWNsMSwgZWNsMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykucmFpc2UoKSAvLyByYWlzZSBsZWdlbmQgc3F1YXJlIHRvIGF2b2lkIHN0cm9rZSBpc3N1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wxLCBlY2wyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2V0IGJyZWFrcyBpZiB1c2VyIGhhc250IGRlZmluZWQgdGhlbSBidXQgaGFzIGVuYWJsZWQgdGhlbVxyXG4gICAgICAgIGlmICghb3V0LmJyZWFrczEgJiYgIW91dC5icmVha3MyICYmIG91dC5zaG93QnJlYWtzKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBxdWFudGlsZXMgZm9yIHRoZSBmaXJzdCB2YXJpYWJsZSAoWCBheGlzKSBhbmQgdHJ1bmNhdGUgdG8gb25lIGRlY2ltYWwgcGxhY2VcclxuICAgICAgICAgICAgb3V0LmJyZWFrczEgPSBtYXAuY2xhc3NpZmllcjFfLnF1YW50aWxlcygpLm1hcCgodmFsdWUpID0+IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCgwKSkpXHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgcXVhbnRpbGVzIGZvciB0aGUgc2Vjb25kIHZhcmlhYmxlIChZIGF4aXMpIGFuZCB0cnVuY2F0ZSB0byBvbmUgZGVjaW1hbCBwbGFjZVxyXG4gICAgICAgICAgICBvdXQuYnJlYWtzMiA9IG1hcC5jbGFzc2lmaWVyMl8ucXVhbnRpbGVzKCkubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDApKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgYnJlYWtzIGxhYmVscyAxIChYIGF4aXMpXHJcbiAgICAgICAgaWYgKG91dC5icmVha3MxKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LmJyZWFrczEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBpbml0aWFsWCArIHN6ICogKGkgKyAxKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG91dC5zcXVhcmVTaXplICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJylcclxuXHJcbiAgICAgICAgICAgICAgICBzcXVhcmVcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeCArIG91dC54QXhpc0xhYmVsc09mZnNldC54KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC54QXhpc0xhYmVsc09mZnNldC55KVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KG91dC5icmVha3MxW2ldKVxyXG5cclxuICAgICAgICAgICAgICAgIHNxdWFyZVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtdGljaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeCArIG91dC54QXhpc0xhYmVsc09mZnNldC54KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHggKyBvdXQueEF4aXNMYWJlbHNPZmZzZXQueClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBvdXQuc3F1YXJlU2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBvdXQuc3F1YXJlU2l6ZSArIDUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgYnJlYWtzIGxhYmVscyAyIChZIGF4aXMpXHJcbiAgICAgICAgaWYgKG91dC5icmVha3MyKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LmJyZWFrczIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBpbml0aWFsWFxyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHN6ICogKGkgKyAyKSAtIHN6XHJcblxyXG4gICAgICAgICAgICAgICAgc3F1YXJlXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHggKyBvdXQueUF4aXNMYWJlbHNPZmZzZXQueSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgLSBvdXQueUF4aXNMYWJlbHNPZmZzZXQueClcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChbLi4ub3V0LmJyZWFrczJdLnJldmVyc2UoKVtpXSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHJvdGF0ZSgtOTAsICR7eH0sICR7eX0pYClcclxuXHJcbiAgICAgICAgICAgICAgICBzcXVhcmVcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCAtIDUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgWCBheGlzIGFycm93XHJcbiAgICAgICAgbGV0IHhBeGlzQXJyb3dZID0gb3V0LnNxdWFyZVNpemUgKyBvdXQuYXJyb3dIZWlnaHQgKyBvdXQueEF4aXNMYWJlbHNPZmZzZXQueVxyXG4gICAgICAgIGlmIChvdXQuc2hvd0JyZWFrcyB8fCAob3V0LmJyZWFrczEgJiYgb3V0LmJyZWFrczIpKSB4QXhpc0Fycm93WSArPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKSAvIDEuNSAvLyBtb3ZlIG92ZXIgZm9yIHRpY2sgbGFiZWxzXHJcblxyXG4gICAgICAgIHNxdWFyZVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1heGlzLWFycm93JylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAnZCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lKCkoW1xyXG4gICAgICAgICAgICAgICAgICAgIFtpbml0aWFsWCwgeEF4aXNBcnJvd1ldLFxyXG4gICAgICAgICAgICAgICAgICAgIFtpbml0aWFsWCArIG91dC5zcXVhcmVTaXplLCB4QXhpc0Fycm93WV0sXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgWSBheGlzIGFycm93XHJcbiAgICAgICAgbGV0IHlBeGlzQXJyb3dYID0gLW91dC5hcnJvd0hlaWdodCArIG91dC55QXhpc0xhYmVsc09mZnNldC54XHJcbiAgICAgICAgaWYgKG91dC5zaG93QnJlYWtzIHx8IChvdXQuYnJlYWtzMSAmJiBvdXQuYnJlYWtzMikpIHlBeGlzQXJyb3dYIC09IG91dC5sYWJlbEZvbnRTaXplIC8gMiAvLyBtb3ZlIG92ZXIgZm9yIHRpY2sgbGFiZWxzXHJcblxyXG4gICAgICAgIHNxdWFyZVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1heGlzLWFycm93JylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAnZCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lKCkoW1xyXG4gICAgICAgICAgICAgICAgICAgIFt5QXhpc0Fycm93WCwgb3V0LnNxdWFyZVNpemVdLFxyXG4gICAgICAgICAgICAgICAgICAgIFt5QXhpc0Fycm93WCwgMF0sXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG5cclxuICAgICAgICAvLyBYIGF4aXMgdGl0bGVcclxuICAgICAgICBzcXVhcmVcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtYXhpcy10aXRsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgaW5pdGlhbFggKyBvdXQueEF4aXNMYWJlbHNPZmZzZXQueClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCB4QXhpc0Fycm93WSArIG91dC5hcnJvd1BhZGRpbmcpXHJcbiAgICAgICAgICAgIC50ZXh0KG91dC5sYWJlbDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcclxuICAgICAgICAgICAgLmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsICdoYW5naW5nJylcclxuXHJcbiAgICAgICAgLy8gWSBheGlzIHRpdGxlXHJcbiAgICAgICAgc3F1YXJlXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIC1vdXQuc3F1YXJlU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCB5QXhpc0Fycm93WCAtIG91dC5hcnJvd1BhZGRpbmcgKyAob3V0LnJvdGF0aW9uID09IC00NSA/IC00IDogLTEpKVxyXG4gICAgICAgICAgICAudGV4dChvdXQubGFiZWwyKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsIG91dC5yb3RhdGlvbiA8IDAgPyAndHJhbnNsYXRlKC01MXB4LCA5NXB4KSByb3RhdGUoOTBkZWcpJyA6ICdyb3RhdGUoLTkwZGVnKScpXHJcblxyXG4gICAgICAgIC8vIEZyYW1lXHJcbiAgICAgICAgc3F1YXJlXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWZyYW1lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBpbml0aWFsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc3F1YXJlU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zcXVhcmVTaXplKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC43KVxyXG5cclxuICAgICAgICAvLyBBcnJvdyBkZWZzXHJcbiAgICAgICAgc3F1YXJlXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdtYXJrZXInKVxyXG4gICAgICAgICAgICAuYXR0cigndmlld0JveCcsIGAwIDAgJHtvdXQuYXJyb3dXaWR0aH0gJHtvdXQuYXJyb3dIZWlnaHR9YClcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2Fycm93aGVhZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCA1KVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCBvdXQuYXJyb3dXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIG91dC5hcnJvd0hlaWdodClcclxuICAgICAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgJ00gMCAwIEwgNSA1IEwgMCAxMCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXItdW5pdHMnLCAnc3Ryb2tlV2lkdGgnKVxyXG5cclxuICAgICAgICAvLyAnTm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChvdXQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vRGF0YVlPZmZzZXQgPVxyXG4gICAgICAgICAgICAgICAgb3V0LnJvdGF0aW9uID09PSAwID8gb3V0Lm5vRGF0YVlPZmZzZXQgKyBvdXQuc3F1YXJlU2l6ZSAvIG91dC5tYXAubnVtYmVyT2ZDbGFzc2VzXyArIG91dC5hcnJvd0hlaWdodCAvIDIgOiBvdXQubm9EYXRhWU9mZnNldFxyXG5cclxuICAgICAgICAgICAgeSA9IG91dC5yb3RhdGlvbiA9PT0gMCA/IHkgKyBvdXQuc3F1YXJlU2l6ZSArIG5vRGF0YVlPZmZzZXQgOiB5ICsgMS40MTQyICogb3V0LnNxdWFyZVNpemUgKyBvdXQuYm94UGFkZGluZyAqIDIgKyBub0RhdGFZT2Zmc2V0XHJcblxyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtbm9kYXRhJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQubm9EYXRhU2hhcGVXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyAob3V0LnJvdGF0aW9uID09IDAgPyAwIDogLTEwKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5ub0RhdGFTaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5ub0RhdGFTaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG91dC5tYXAubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdpb25zID0gb3V0Lm1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcgPyBzZWxlY3RBbGwoJyNlbS1udXRzcmcnKSA6IHNlbGVjdCgnI2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gcmVnaW9ucy5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIilcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCAncmVkJylcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5SZyA9IG91dC5tYXAubnV0c0xldmVsXyA9PSAnbWl4ZWQnID8gc2VsZWN0QWxsKCcjZW0tbnV0c3JnJykgOiBzZWxlY3QoJyNlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IG5SZy5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIilcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBvdXQubWFwLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLW5vZGF0YS1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0Lm5vRGF0YVNoYXBlV2lkdGggKyAob3V0Lm5vRGF0YVNoYXBlV2lkdGggLyAyICsgNSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQubm9EYXRhU2hhcGVIZWlnaHQgKiAwLjUgKyAxICsgKG91dC5yb3RhdGlvbiA9PSAwID8gMCA6IC0xMCkpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQubm9EYXRhVGV4dClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICBvdXQuc2V0Qm94RGltZW5zaW9uKClcclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wxLCBlY2wyKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChgW2VjbDFdYClcclxuXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZWdpb25zIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5zdHlsZSgnZmlsbCcsICd3aGl0ZScpXHJcblxyXG4gICAgICAgIC8vIEhpZ2hsaWdodCBvbmx5IHRoZSBzZWxlY3RlZCByZWdpb25zIGJ5IHJlc3RvcmluZyB0aGVpciBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUmVnaW9ucyA9IGFsbFJlZ2lvbnMuZmlsdGVyKGBbZWNsMT0nJHtlY2wxfSddYCkuZmlsdGVyKGBbZWNsMj0nJHtlY2wyfSddYClcclxuICAgICAgICBzZWxlY3RlZFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHJlZ2lvbnNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCByZWdpb25zIHRvIHRoZWlyIG9yaWdpbmFsIGNvbG9ycyBvbiBtb3VzZW91dFxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoYFtlY2wxXWApXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCByZWdpb24ncyBvcmlnaW5hbCBjb2xvciBmcm9tIHRoZSBmaWxsX19fIGF0dHJpYnV0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4vbGVnZW5kJ1xyXG5pbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Rm9udFNpemVGcm9tQ2xhc3MsIG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIGNob3JvcGxldGgtdHJpdmFyaWF0ZSBtYXBzXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICAvLyBEZWZhdWx0IHNldHRpbmdzXHJcbiAgICBvdXQud2lkdGggPSAyMzBcclxuICAgIG91dC5oZWlnaHQgPSAyMzBcclxuXHJcbiAgICBvdXQubGFiZWwxID0gJ1ZhcmlhYmxlIDEnXHJcbiAgICBvdXQubGFiZWwyID0gJ1ZhcmlhYmxlIDInXHJcbiAgICBvdXQubGFiZWwzID0gJ1ZhcmlhYmxlIDMnIC8vIEFkZCBhIGxhYmVsIGZvciB0aGUgdGhpcmQgdmFyaWFibGVcclxuICAgIG91dC5heGlzVGl0bGVGb250U2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1iaXZhcmlhdGUtYXhpcy10aXRsZScpXHJcbiAgICBvdXQuc2hvd0JyZWFrcyA9IGZhbHNlXHJcbiAgICBvdXQubm9EYXRhID0gdHJ1ZVxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlSGVpZ2h0ID0gMjBcclxuICAgIG91dC5ub0RhdGFTaGFwZVdpZHRoID0gMjVcclxuICAgIG91dC5ub0RhdGFUZXh0ID0gJ05vIGRhdGEnXHJcbiAgICBvdXQuYm94UGFkZGluZyA9IDYwIC8vIGRlcGVuZHMgb24gdmFyaWFibGUgMSBsYWJlbCBsZW5ndGggcmVhbGx5XHJcbiAgICBvdXQubm9EYXRhWU9mZnNldCA9IDIwXHJcbiAgICBvdXQuYXJyb3dIZWlnaHQgPSAxNVxyXG4gICAgb3V0LmFycm93V2lkdGggPSAxNFxyXG4gICAgb3V0LmFycm93UGFkZGluZyA9IDEwXHJcblxyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGUgdGhlIHVwZGF0ZSBtZXRob2QgdG8gaGFuZGxlIHRyaXZhcmlhdGUgbGVnZW5kc1xyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuICAgICAgICBjb25zdCBudW1iZXJPZkNsYXNzZXMgPSBvdXQubWFwLm51bWJlck9mQ2xhc3NlcygpXHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjb250ZW50XHJcbiAgICAgICAgbGdnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIERyYXcgYmFja2dyb3VuZCBib3hcclxuICAgICAgICBvdXQubWFrZUJhY2tncm91bmRCb3goKVxyXG5cclxuICAgICAgICAvLyBBcHBseSBwYWRkaW5nIHRvIHRoZSBtYWluIDxnPiBncm91cFxyXG4gICAgICAgIGNvbnN0IHBhZGRlZEdyb3VwID0gbGdnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZ30sICR7b3V0LmJveFBhZGRpbmd9KWApXHJcblxyXG4gICAgICAgIC8vIERyYXcgdGl0bGVcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSB7XHJcbiAgICAgICAgICAgIHBhZGRlZEdyb3VwXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKSAvLyBTdGFydCBhdCAwIHdpdGhpbiB0aGUgcGFkZGVkIGdyb3VwXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC50aXRsZUZvbnRTaXplKSAvLyBWZXJ0aWNhbCBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aGUgdHJpdmFyaWF0ZSBWZW5uIGRpYWdyYW1cclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBbb3V0LmxhYmVsMSwgb3V0LmxhYmVsMiwgb3V0LmxhYmVsM11cclxuICAgICAgICBjb25zdCBjb2xvcnMgPSBbb3V0Lm1hcC5jb2xvcjFfLCBvdXQubWFwLmNvbG9yMl8sIG91dC5tYXAuY29sb3IzX11cclxuXHJcbiAgICAgICAgZHJhd1RyaXZhcmlhdGVWZW5uRGlhZ3JhbShwYWRkZWRHcm91cCwgY29sb3JzLCBsYWJlbHMpXHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSB0cml2YXJpYXRlIChWZW5uIERpYWdyYW0pIG9yIGJpdmFyaWF0ZSAoZ3JpZCkgbGVnZW5kXHJcbiAgICAgICAgLy8gaWYgKG51bWJlck9mQ2xhc3NlcyA9PT0gNykge1xyXG4gICAgICAgIC8vICAgICBkcmF3VHJpdmFyaWF0ZVZlbm5EaWFncmFtKGxnZywgb3V0KVxyXG4gICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgIGRyYXdUcml2YXJpYXRlVGVybmFyeVBsb3QobGdnLCBvdXQsIG51bWJlck9mQ2xhc3NlcylcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3VHJpdmFyaWF0ZVZlbm5EaWFncmFtKGNvbnRhaW5lciwgY29sb3JzLCBsYWJlbHMpIHtcclxuICAgIC8vc3BlY3MgZm9yIENpcmNsZSAxXHJcbiAgICBjb25zdCB4Q2VudGVyMSA9IDUwXHJcbiAgICBjb25zdCB5Q2VudGVyMSA9IDUwXHJcbiAgICBjb25zdCBjaXJjbGVSYWQgPSAzMFxyXG5cclxuICAgIC8vZHJhdyBDaXJjbGUgMVxyXG4gICAgLy8gY29uc3QgY2lyY2xlMSA9IGNvbnRhaW5lclxyXG4gICAgLy8gICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAvLyAgICAgLmF0dHIoJ3InLCBjaXJjbGVSYWQpXHJcbiAgICAvLyAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHhDZW50ZXIxICsgJywnICsgeUNlbnRlcjEgKyAnKScpXHJcblxyXG4gICAgLy9hZGQnbCBzcGVjcyBmb3IgQ2lyY2xlIDJcclxuICAgIGNvbnN0IG9mZnNldEZhY3RvciA9IDEuMlxyXG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0RmFjdG9yICogY2lyY2xlUmFkXHJcbiAgICBjb25zdCB4Q2VudGVyMiA9IHhDZW50ZXIxICsgb2Zmc2V0XHJcbiAgICBjb25zdCB5Q2VudGVyMiA9IHlDZW50ZXIxIC8vY3JlYXRpbmcgbmV3IHZhciBmb3IgY2xhcml0eVxyXG5cclxuICAgIC8vZHJhdyBDaXJjbGUgMlxyXG4gICAgLy8gY29uc3QgY2lyY2xlMiA9IGNvbnRhaW5lclxyXG4gICAgLy8gICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAvLyAgICAgLmF0dHIoJ3InLCBjaXJjbGVSYWQpXHJcbiAgICAvLyAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHhDZW50ZXIyICsgJywnICsgeUNlbnRlcjIgKyAnKScpXHJcblxyXG4gICAgLy9hZGQnbCBzcGVjcyBmb3IgQ2lyY2xlIDNcclxuICAgIGNvbnN0IHhDZW50ZXIzID0geENlbnRlcjEgKyBvZmZzZXQgLyAyXHJcbiAgICBjb25zdCB5Q2VudGVyMyA9IHlDZW50ZXIxICsgKE1hdGguc3FydCgzKSAqIG9mZnNldCkgLyAyXHJcblxyXG4gICAgLy9kcmF3IENpcmNsZSAzXHJcbiAgICAvLyBjb25zdCBjaXJjbGUzID0gY29udGFpbmVyXHJcbiAgICAvLyAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgIC8vICAgICAuYXR0cigncicsIGNpcmNsZVJhZClcclxuICAgIC8vICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeENlbnRlcjMgKyAnLCcgKyB5Q2VudGVyMyArICcpJylcclxuXHJcbiAgICAvL2NvbXB1dGUgZmlyc3QgcG9pbnRzIG9mIGludGVyc2VjdGlvblxyXG4gICAgY29uc3QgdHJpSGVpZ2h0ID0gTWF0aC5zcXJ0KGNpcmNsZVJhZCAqKiAyIC0gKG9mZnNldCAvIDIpICoqIDIpXHJcbiAgICAvL291dGVyIGludGVyc2VjdGlvbiBvZiBDaXJjbGVzIDEgYW5kIDJcclxuICAgIGNvbnN0IHhJc2VjdDEgPSB4Q2VudGVyM1xyXG4gICAgY29uc3QgeUlzZWN0MSA9IHlDZW50ZXIxIC0gdHJpSGVpZ2h0XHJcbiAgICAvL2lubmVyIGludGVyc2VjdGlvbiBvZiBDaXJjbGVzIDEgYW5kIDJcclxuICAgIGNvbnN0IHhJc2VjdDQgPSB4Q2VudGVyM1xyXG4gICAgY29uc3QgeUlzZWN0NCA9IHlDZW50ZXIxICsgdHJpSGVpZ2h0XHJcblxyXG4gICAgLy90cmVhdCBcInRyaUhlaWdodFwiIGFzIHRoZSBoeXBvdGVuZXVzZSBvZiBhIDMwLjYwLjkwIHRyaWFuZ2xlLlxyXG4gICAgLy90aGlzIHRlbGxzIHVzIHRoZSBzaGlmdCBmcm9tIHRoZSBtaWRwb2ludCBvZiBhIGxlZyBvZiB0aGUgdHJpYW5nbGVcclxuICAgIC8vdG8gdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxyXG4gICAgY29uc3QgeERlbHRhID0gKHRyaUhlaWdodCAqIE1hdGguc3FydCgzKSkgLyAyXHJcbiAgICBjb25zdCB5RGVsdGEgPSB0cmlIZWlnaHQgLyAyXHJcblxyXG4gICAgY29uc3QgeE1pZHBvaW50QzFDMyA9ICh4Q2VudGVyMSArIHhDZW50ZXIzKSAvIDJcclxuICAgIGNvbnN0IHhNaWRwb2ludEMyQzMgPSAoeENlbnRlcjIgKyB4Q2VudGVyMykgLyAyXHJcbiAgICBjb25zdCB5TWlkcG9pbnRCb3RoID0gKHlDZW50ZXIxICsgeUNlbnRlcjMpIC8gMlxyXG5cclxuICAgIC8vZmluZCB0aGUgcmVzdCBvZiB0aGUgcG9pbnRzIG9mIGludGVyc2VjdGlvblxyXG4gICAgY29uc3QgeElzZWN0MiA9IHhNaWRwb2ludEMxQzMgLSB4RGVsdGFcclxuICAgIGNvbnN0IHlJc2VjdDIgPSB5TWlkcG9pbnRCb3RoICsgeURlbHRhXHJcbiAgICBjb25zdCB4SXNlY3QzID0geE1pZHBvaW50QzJDMyArIHhEZWx0YVxyXG4gICAgY29uc3QgeUlzZWN0MyA9IHlNaWRwb2ludEJvdGggKyB5RGVsdGFcclxuXHJcbiAgICBjb25zdCB4SXNlY3Q1ID0geE1pZHBvaW50QzFDMyArIHhEZWx0YVxyXG4gICAgY29uc3QgeUlzZWN0NSA9IHlNaWRwb2ludEJvdGggLSB5RGVsdGFcclxuICAgIGNvbnN0IHhJc2VjdDYgPSB4TWlkcG9pbnRDMkMzIC0geERlbHRhXHJcbiAgICBjb25zdCB5SXNlY3Q2ID0geU1pZHBvaW50Qm90aCAtIHlEZWx0YVxyXG5cclxuICAgIGNvbnN0IHhQb2ludHMgPSBbeElzZWN0MSwgeElzZWN0MiwgeElzZWN0MywgeElzZWN0NCwgeElzZWN0NSwgeElzZWN0Nl1cclxuICAgIGNvbnN0IHlQb2ludHMgPSBbeUlzZWN0MSwgeUlzZWN0MiwgeUlzZWN0MywgeUlzZWN0NCwgeUlzZWN0NSwgeUlzZWN0Nl1cclxuXHJcbiAgICBjb25zdCBtYWtlSXJvblNoYXBlcyA9IChbeDEsIHgyLCB4MywgeTEsIHkyLCB5M10pID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gYE0gJHt4MX0gJHt5MX1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMSAke3gyfSAke3kyfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAwICR7eDN9ICR7eTN9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDEgJHt4MX0gJHt5MX1gXHJcbiAgICAgICAgcmV0dXJuIHBhdGhcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtYWtlU3VuU2hhcGVzID0gKFt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBgTSAke3gxfSAke3kxfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAwICR7eDJ9ICR7eTJ9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDAgJHt4M30gJHt5M31cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDEgMSAke3gxfSAke3kxfWBcclxuICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ha2VSb3VuZGVkVHJpID0gKFt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBgTSAke3gxfSAke3kxfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAxICR7eDJ9ICR7eTJ9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDEgJHt4M30gJHt5M31cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMSAke3gxfSAke3kxfWBcclxuICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlyb25Qb2ludHMgPSBbXHJcbiAgICAgICAgWzEsIDUsIDZdLFxyXG4gICAgICAgIFszLCA0LCA1XSxcclxuICAgICAgICBbMiwgNiwgNF0sXHJcbiAgICBdXHJcbiAgICBjb25zdCBzdW5Qb2ludHMgPSBbXHJcbiAgICAgICAgWzMsIDUsIDFdLFxyXG4gICAgICAgIFsyLCA0LCAzXSxcclxuICAgICAgICBbMSwgNiwgMl0sXHJcbiAgICBdXHJcbiAgICBjb25zdCByb3VuZGVkVHJpUG9pbnRzID0gW1s1LCA0LCA2XV1cclxuXHJcbiAgICAvLyBtYWluIGNpcmNsZXMgKHJhdyBjb2xvcnMpXHJcbiAgICBzdW5Qb2ludHMuZm9yRWFjaCgocG9pbnRzLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHB0Q3ljbGUgPSBwb2ludHMubWFwKChpKSA9PiB4UG9pbnRzW2kgLSAxXSkuY29uY2F0KHBvaW50cy5tYXAoKGkpID0+IHlQb2ludHNbaSAtIDFdKSlcclxuICAgICAgICBjb25zdCBzaGFwZSA9IG1ha2VTdW5TaGFwZXMocHRDeWNsZSlcclxuXHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBzaGFwZSkuYXR0cignY2xhc3MnLCAnc2VnbWVudCcpLmF0dHIoJ2ZpbGwnLCBjb2xvcnNbaW5kZXhdKS5hdHRyKCdvcGFjaXR5JywgMSlcclxuICAgIH0pXHJcblxyXG4gICAgLy8gZmlyc3QgaW50ZXJzZWN0cyAoY29tYmluYXRpb24gb2YgMiBjb2xvcnMpXHJcbiAgICBpcm9uUG9pbnRzLmZvckVhY2goKHBvaW50cywgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBwdEN5Y2xlID0gcG9pbnRzLm1hcCgoaSkgPT4geFBvaW50c1tpIC0gMV0pLmNvbmNhdChwb2ludHMubWFwKChpKSA9PiB5UG9pbnRzW2kgLSAxXSkpXHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBtYWtlSXJvblNoYXBlcyhwdEN5Y2xlKVxyXG5cclxuICAgICAgICBsZXQgY29sb3JcclxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xyXG4gICAgICAgICAgICBjb2xvciA9IG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3JzWzJdLCBjb2xvcnNbMF1dKSAvLyBwaW5rICsgY3lhblxyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT0gMSkge1xyXG4gICAgICAgICAgICBjb2xvciA9IG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3JzWzFdLCBjb2xvcnNbMF1dKSAvLyBjeWFuICsgeWVsbG93XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSAyKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcnNbMV0sIGNvbG9yc1syXV0pIC8vIHBpbmsgKyB5ZWxsb3dcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgc2hhcGUpLmF0dHIoJ2NsYXNzJywgJ3NlZ21lbnQnKS5hdHRyKCdmaWxsJywgY29sb3IpLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBudWNsZXVzIChjb21iaW5hdGlvbiBvZiBhbGwgMyBjb2xvcnMpXHJcbiAgICByb3VuZGVkVHJpUG9pbnRzLmZvckVhY2goKHBvaW50cywgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBwdEN5Y2xlID0gcG9pbnRzLm1hcCgoaSkgPT4geFBvaW50c1tpIC0gMV0pLmNvbmNhdChwb2ludHMubWFwKChpKSA9PiB5UG9pbnRzW2kgLSAxXSkpXHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBtYWtlUm91bmRlZFRyaShwdEN5Y2xlKVxyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KGNvbG9ycylcclxuXHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBzaGFwZSkuYXR0cignY2xhc3MnLCAnc2VnbWVudCcpLmF0dHIoJ2ZpbGwnLCBjb2xvcikuYXR0cignb3BhY2l0eScsIDEpXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnRhaW5lclxyXG4gICAgICAgIC5zZWxlY3RBbGwoJ3BhdGguc2VnbWVudCcpXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cignb3BhY2l0eScsIDAuOCkuZHVyYXRpb24oNTAwKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKCdvcGFjaXR5JywgMSkuZHVyYXRpb24oNTAwKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy8gbGFiZWwgaW50ZXJzZWN0c1xyXG4gICAgY29uc3QgeU9mZnNldCA9IGNvbnRhaW5lclxyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC50ZXh0KGxhYmVsc1swXSlcclxuICAgICAgICAuYXR0cigneCcsIHhDZW50ZXIxIC0gY2lyY2xlUmFkIC0gMylcclxuICAgICAgICAuYXR0cigneScsIHhDZW50ZXIxKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZW5uLWxhYmVsJylcclxuICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgIGNvbnRhaW5lclxyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC50ZXh0KGxhYmVsc1sxXSlcclxuICAgICAgICAuYXR0cigneCcsIHhDZW50ZXIyICsgY2lyY2xlUmFkICsgMylcclxuICAgICAgICAuYXR0cigneScsIHlDZW50ZXIyKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZW5uLWxhYmVsJylcclxuICAgIGNvbnRhaW5lclxyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC50ZXh0KGxhYmVsc1syXSlcclxuICAgICAgICAuYXR0cigneCcsIHhDZW50ZXIzKVxyXG4gICAgICAgIC5hdHRyKCd5JywgeUNlbnRlcjMgKyBjaXJjbGVSYWQgKyAxNSlcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAndmVubi1sYWJlbCcpXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyBhIHRyaXZhcmlhdGUgbGVnZW5kIGFzIGEgVmVubiBEaWFncmFtXHJcbiAqL1xyXG5mdW5jdGlvbiBkcmF3VHJpdmFyaWF0ZVZlbm5EaWFncmFtMihzdmcsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIGxhYmVscywgY29sb3JzKSB7XHJcbiAgICBjb25zdCByYWRpdXMgPSBjb250YWluZXJXaWR0aCAvIDUgLy8gUmFkaXVzIG9mIGVhY2ggY2lyY2xlXHJcbiAgICBjb25zdCBjZW50ZXJYID0gY29udGFpbmVyV2lkdGggLyAyXHJcbiAgICBjb25zdCBjZW50ZXJZID0gY29udGFpbmVySGVpZ2h0IC8gMlxyXG4gICAgY29uc3Qgb2Zmc2V0ID0gcmFkaXVzIC8gMS41XHJcblxyXG4gICAgLy8gRGVmaW5lIGNpcmNsZSBwb3NpdGlvbnNcclxuICAgIGNvbnN0IGNpcmNsZXMgPSBbXHJcbiAgICAgICAgeyBpZDogJ2NpcmNsZTEnLCBjeDogY2VudGVyWCAtIG9mZnNldCwgY3k6IGNlbnRlclksIGxhYmVsOiBsYWJlbHNbMF0sIGNvbG9yOiBjb2xvcnNbMF0gfSxcclxuICAgICAgICB7IGlkOiAnY2lyY2xlMicsIGN4OiBjZW50ZXJYICsgb2Zmc2V0LCBjeTogY2VudGVyWSwgbGFiZWw6IGxhYmVsc1sxXSwgY29sb3I6IGNvbG9yc1sxXSB9LFxyXG4gICAgICAgIHsgaWQ6ICdjaXJjbGUzJywgY3g6IGNlbnRlclgsIGN5OiBjZW50ZXJZICsgb2Zmc2V0ICogMS41LCBsYWJlbDogbGFiZWxzWzJdLCBjb2xvcjogY29sb3JzWzJdIH0sXHJcbiAgICBdXHJcblxyXG4gICAgLy8gRHJhdyBjaXJjbGVzXHJcbiAgICBjaXJjbGVzLmZvckVhY2goKHsgaWQsIGN4LCBjeSwgbGFiZWwsIGNvbG9yIH0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnY2lyY2xlJykuYXR0cignaWQnLCBpZCkuYXR0cignY3gnLCBjeCkuYXR0cignY3knLCBjeSkuYXR0cigncicsIHJhZGl1cykuc3R5bGUoJ2ZpbGwnLCBjb2xvcikuc3R5bGUoJ29wYWNpdHknLCAxKVxyXG5cclxuICAgICAgICAvLyBBZGQgbGFiZWxzIHdpdGggc3BlY2lmaWMgcG9zaXRpb25pbmdcclxuICAgICAgICBjb25zdCBsYWJlbFggPVxyXG4gICAgICAgICAgICBpbmRleCA9PT0gMFxyXG4gICAgICAgICAgICAgICAgPyBjeCAtIHJhZGl1cyAtIDEwIC8vIExlZnQgb2YgdGhlIGZpcnN0IGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgOiBpbmRleCA9PT0gMVxyXG4gICAgICAgICAgICAgICAgICA/IGN4ICsgcmFkaXVzICsgMTAgLy8gUmlnaHQgb2YgdGhlIHNlY29uZCBjaXJjbGVcclxuICAgICAgICAgICAgICAgICAgOiBjeCAvLyBCZWxvdyB0aGUgdGhpcmQgY2lyY2xlXHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsWSA9IGluZGV4IDwgMiA/IGN5IDogY3kgKyByYWRpdXMgKyAyMCAvLyBTYW1lIHkgZm9yIGZpcnN0IHR3byBjaXJjbGVzLCBiZWxvdyBmb3IgdGhlIHRoaXJkXHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIGxhYmVsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBsYWJlbFkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGluZGV4IDwgMiA/IChpbmRleCA9PT0gMCA/ICdlbmQnIDogJ3N0YXJ0JykgOiAnbWlkZGxlJykgLy8gQWRqdXN0IGFsaWdubWVudFxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndmVubi1sYWJlbCcpXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmF3cyBhIHRyaXZhcmlhdGUgbGVnZW5kIGFzIGEgdGVybmFyeSBwbG90XHJcbiAqL1xyXG5mdW5jdGlvbiBkcmF3VHJpdmFyaWF0ZVRlcm5hcnlQbG90KGxnZywgb3V0LCBudW1iZXJPZkNsYXNzZXMpIHtcclxuICAgIGNvbnN0IHNpemUgPSBvdXQuc3F1YXJlU2l6ZSAvLyBTaXplIG9mIHRoZSBsZWdlbmQgYXJlYVxyXG4gICAgY29uc3QgcGFkZGluZyA9IDIwIC8vIFBhZGRpbmcgYXJvdW5kIHRoZSBwbG90XHJcbiAgICBjb25zdCByYWRpdXMgPSA1IC8vIFJhZGl1cyBvZiBlYWNoIGNsYXNzIHBvaW50XHJcbiAgICBjb25zdCB0cmlhbmdsZUhlaWdodCA9IChNYXRoLnNxcnQoMykgLyAyKSAqIHNpemVcclxuXHJcbiAgICBjb25zdCB0ZXJuYXJ5R3JvdXAgPSBsZ2dcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAndHJpdmFyaWF0ZS10ZXJuYXJ5LXBsb3QnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmcgKyBzaXplIC8gMn0sICR7b3V0LmJveFBhZGRpbmcgKyB0cmlhbmdsZUhlaWdodCAvIDJ9KWApXHJcblxyXG4gICAgLy8gRHJhdyB0aGUgdHJpYW5nbGVcclxuICAgIGNvbnN0IHZlcnRpY2VzID0gW1xyXG4gICAgICAgIHsgeDogMCwgeTogLXRyaWFuZ2xlSGVpZ2h0IC8gMiB9LCAvLyBUb3AgdmVydGV4IChWYXJpYWJsZSAxKVxyXG4gICAgICAgIHsgeDogLXNpemUgLyAyLCB5OiB0cmlhbmdsZUhlaWdodCAvIDIgfSwgLy8gQm90dG9tLWxlZnQgdmVydGV4IChWYXJpYWJsZSAyKVxyXG4gICAgICAgIHsgeDogc2l6ZSAvIDIsIHk6IHRyaWFuZ2xlSGVpZ2h0IC8gMiB9LCAvLyBCb3R0b20tcmlnaHQgdmVydGV4IChWYXJpYWJsZSAzKVxyXG4gICAgXVxyXG5cclxuICAgIHRlcm5hcnlHcm91cFxyXG4gICAgICAgIC5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgIC5hdHRyKCdwb2ludHMnLCB2ZXJ0aWNlcy5tYXAoKGQpID0+IGAke2QueH0sJHtkLnl9YCkuam9pbignICcpKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG5cclxuICAgIC8vIExhYmVsIHRoZSB2ZXJ0aWNlc1xyXG4gICAgY29uc3QgbGFiZWxzID0gW291dC5sYWJlbDEsIG91dC5sYWJlbDIsIG91dC5sYWJlbDNdXHJcbiAgICB2ZXJ0aWNlcy5mb3JFYWNoKCh2ZXJ0ZXgsIGkpID0+IHtcclxuICAgICAgICB0ZXJuYXJ5R3JvdXBcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgdmVydGV4LngpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgdmVydGV4LnkgLSAoaSA9PT0gMCA/IDEwIDogLTIwKSkgLy8gT2Zmc2V0IGxhYmVsc1xyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndGVybmFyeS1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAudGV4dChsYWJlbHNbaV0pXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIFBsb3QgdGhlIHBvaW50cyBpbnNpZGUgdGhlIHRlcm5hcnkgcGxvdFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtYmVyT2ZDbGFzc2VzIC0gaTsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGsgPSBudW1iZXJPZkNsYXNzZXMgLSBpIC0gaiAtIDEgLy8gRW5zdXJlIHN1bSBvZiBpICsgaiArIGsgPSBudW1iZXJPZkNsYXNzZXMgLSAxXHJcbiAgICAgICAgICAgIGNvbnN0IHggPSAoKGogLSBrKSAqIHNpemUpIC8gKDIgKiAobnVtYmVyT2ZDbGFzc2VzIC0gMSkpIC8vIEhvcml6b250YWwgcG9zaXRpb25cclxuICAgICAgICAgICAgY29uc3QgeSA9IChpICogLXRyaWFuZ2xlSGVpZ2h0KSAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSAvLyBWZXJ0aWNhbCBwb3NpdGlvblxyXG5cclxuICAgICAgICAgICAgY29uc3QgZmlsbCA9IG91dC5tYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKGksIGosIGspXHJcblxyXG4gICAgICAgICAgICB0ZXJuYXJ5R3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCB4KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmaWxsKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBpLCBqLCBrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBpLCBqLCBrKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGksIGosIGspXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHJlZ2lvbnMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsMSwgZWNsMikge1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKGBbZWNsMV1gKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHJlZ2lvbnMgdG8gd2hpdGVcclxuICAgICAgICBhbGxSZWdpb25zLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWdpb25zID0gYWxsUmVnaW9ucy5maWx0ZXIoYFtlY2wxPScke2VjbDF9J11gKS5maWx0ZXIoYFtlY2wyPScke2VjbDJ9J11gKVxyXG4gICAgICAgIHNlbGVjdGVkUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gb3V0Lmdlb18gPT09ICdXT1JMRCcgPyAnI2VtLXdvcmxkcmcnIDogJyNlbS1udXRzcmcnXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSBzZWxlY3RvciA9ICcjZW0tdXNlci1yZWdpb25zJyAvLyBmb3IgdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoYFtlY2wxXWApXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCByZWdpb24ncyBvcmlnaW5hbCBjb2xvciBmcm9tIHRoZSBmaWxsX19fIGF0dHJpYnV0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCwgY3JlYXRlIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCB7IHNjYWxlQmFuZCwgc2NhbGVMaW5lYXIgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgYXhpc0xlZnQgfSBmcm9tICdkMy1heGlzJ1xyXG5pbXBvcnQgeyBtYXgsIGJpc2VjdG9yIH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Rm9udFNpemVGcm9tQ2xhc3MsIGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIGNob3JvcGxldGggbWFwc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgKGluaGVyaXQpXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICBvdXQubGFiZWxUeXBlID0gJ3RocmVzaG9sZHMnIC8vIHRocmVzaG9sZHMgfHwgcmFuZ2VzXHJcbiAgICAvL3RoZSBvcmRlciBvZiB0aGUgbGVnZW5kIGVsZW1lbnRzLiBTZXQgdG8gZmFsc2UgdG8gaW52ZXJ0LlxyXG4gICAgb3V0LmFzY2VuZGluZyA9IHRydWVcclxuICAgIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVXaWR0aCA9IDI1XHJcbiAgICAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZUhlaWdodCA9IDIwXHJcbiAgICAvL3RoZSBzZXBhcmF0aW9uIGxpbmUgbGVuZ3RoXHJcbiAgICBvdXQuc2VwTGluZUxlbmd0aCA9IG91dC5zaGFwZVdpZHRoXHJcbiAgICAvL3RpY2sgbGluZSBsZW5ndGggaW4gcGl4ZWxzXHJcbiAgICBvdXQudGlja0xlbmd0aCA9IDRcclxuICAgIC8vdGhlIG51bWJlciBvZiBkZWNpbWFsIGZvciB0aGUgbGVnZW5kIGxhYmVsc1xyXG4gICAgb3V0LmRlY2ltYWxzID0gMFxyXG4gICAgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubGFiZWxPZmZzZXQgPSAzXHJcbiAgICAvL2xhYmVsRm9ybWF0dGVyIGZ1bmN0aW9uXHJcbiAgICBvdXQubGFiZWxGb3JtYXR0ZXIgPSBudWxsXHJcbiAgICAvLyBtYW51YWxseSBkZWZpbmUgbGFiZWxzXHJcbiAgICBvdXQubGFiZWxzID0gbnVsbFxyXG5cclxuICAgIC8vYmFyIGNoYXJ0c1xyXG4gICAgb3V0LmJhckNoYXJ0ID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuYmFyQ2hhcnRDb3VudHMgPSB1bmRlZmluZWQgLy9zaG93IGNsYXNzIGNvdW50IGxhYmVsc1xyXG4gICAgb3V0LmJhckNoYXJ0TGFiZWxGb3JtYXQgPSB1bmRlZmluZWQgLy8gYWxsb3cgdXNlcnMgdG8gZm9ybWF0IHRoZSBiYXIgY2hhcnQgYmluIGxhYmVsc1xyXG5cclxuICAgIC8vZGl2ZXJnaW5nIGxpbmVcclxuICAgIG91dC5wb2ludE9mRGl2ZXJnZW5jZUxhYmVsID0gdW5kZWZpbmVkXHJcbiAgICBvdXQucG9pbnRPZkRpdmVyZ2VuY2UgPSB1bmRlZmluZWRcclxuICAgIG91dC5wb2ludE9mRGl2ZXJnZW5jZVBhZGRpbmcgPSA3XHJcbiAgICBvdXQuZGl2ZXJnaW5nTGluZUxlbmd0aCA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmRpdmVyZ2luZ0Fycm93TGVuZ3RoID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9zaG93IG5vIGRhdGFcclxuICAgIG91dC5ub0RhdGEgPSB0cnVlXHJcbiAgICAvL25vIGRhdGEgdGV4dCBsYWJlbFxyXG4gICAgb3V0Lm5vRGF0YVRleHQgPSAnTm8gZGF0YSdcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKSBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGlmIChvdXQubGdnLm5vZGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94IGFuZCB0aXRsZSBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgICBvdXQubWFrZUJhY2tncm91bmRCb3goKVxyXG4gICAgICAgICAgICBpZiAob3V0LnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3NzRm9udFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIGNzc0ZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KG91dC50aXRsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9leGl0IGVhcmx5IGlmIG5vIGNsYXNzaWZpZXJcclxuICAgICAgICAgICAgaWYgKCFtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGRlZmF1bHQgcG9pbnQgb2YgZGl2ZXJnZW5jZSBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCAmJiAhb3V0LnBvaW50T2ZEaXZlcmdlbmNlKSBvdXQucG9pbnRPZkRpdmVyZ2VuY2UgPSBtYXAubnVtYmVyT2ZDbGFzc2VzXyAvIDJcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQuYmFyQ2hhcnQpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUJhckNoYXJ0TGVnZW5kKClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGFiZWxUeXBlID09ICdyYW5nZXMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmFuZ2VzTGVnZW5kKClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGhyZXNob2xkc0xlZ2VuZCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRocmVzaG9sZHMoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPVxyXG4gICAgICAgICAgICBtYXAudGhyZXNob2xkc18ubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyBtYXAudGhyZXNob2xkc19cclxuICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbSh7IGxlbmd0aDogbWFwLm51bWJlck9mQ2xhc3Nlc18gfSlcclxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKF8sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jbGFzc2lmaWVyKCkuaW52ZXJ0RXh0ZW50KGluZGV4KVtvdXQuYXNjZW5kaW5nID8gMCA6IDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDEpIC8vIFJlbW92ZSB0aGUgZmlyc3QgZW50cnkgYW5kIHJldHVybiB0aGUgcmVzdCBhcyBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICByZXR1cm4gbWFwLmNvbG9yc19cclxuICAgICAgICAgICAgPyBtYXAuY29sb3JzX1xyXG4gICAgICAgICAgICA6IEFycmF5LmZyb20oeyBsZW5ndGg6IG1hcC5udW1iZXJPZkNsYXNzZXNfIH0pLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoaW5kZXgsIG1hcC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwLnN0YXREYXRhKCkuX2RhdGFfKS5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVGhyZXNob2xkc0xlZ2VuZCgpIHtcclxuICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuICAgICAgICAvLyBMYWJlbCBmb3JtYXR0ZXJcclxuICAgICAgICBjb25zdCBmb3JtYXRMYWJlbCA9IG91dC5sYWJlbEZvcm1hdHRlciB8fCBmb3JtYXQoYC4ke291dC5kZWNpbWFsc31mYClcclxuICAgICAgICBsZXQgYmFzZVkgPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIGJhc2VZID0gYmFzZVkgKyBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLXRpdGxlJykgKyA4IC8vIHRpdGxlIHNpemUgKyBwYWRkaW5nXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm51bWJlck9mQ2xhc3Nlc187IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gYmFzZVkgKyBpICogb3V0LnNoYXBlSGVpZ2h0XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBvdXQuYXNjZW5kaW5nID8gbS5udW1iZXJPZkNsYXNzZXMoKSAtIGkgLSAxIDogaVxyXG4gICAgICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSBtLmNsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG0ubnVtYmVyT2ZDbGFzc2VzXylcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgZm9yIGVhY2ggY2xhc3NcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBzZXBhcmF0aW9uIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZ2cuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXNlcGFyYXRvcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBvdXQuYm94UGFkZGluZyArIG91dC5zZXBMaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aWNrIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZ2cuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNlcExpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBvdXQuYm94UGFkZGluZyArIG91dC5zZXBMaW5lTGVuZ3RoICsgb3V0LnRpY2tMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChpIDwgbS5udW1iZXJPZkNsYXNzZXMoKSAtIDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1hcmsgbGFiZWwgc28gd2UgY2FuIG1vdmUgaXQgaW4gZHJhd0RpdmVyZ2luZ0xpbmVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbGdnXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIE1hdGgubWF4KG91dC5zaGFwZVdpZHRoLCBvdXQuc2VwTGluZUxlbmd0aCArIG91dC50aWNrTGVuZ3RoKSArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQob3V0LmxhYmVscyA/IG91dC5sYWJlbHNbaV0gOiBmb3JtYXRMYWJlbChtLmNsYXNzaWZpZXIoKS5pbnZlcnRFeHRlbnQoZWNsKVtvdXQuYXNjZW5kaW5nID8gMCA6IDFdKSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGxhYmVsIHNvIHdlIGNhbiBtb3ZlIGl0IGluIGRyYXdEaXZlcmdpbmdMaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwgJiYgaSA9PSBvdXQucG9pbnRPZkRpdmVyZ2VuY2UgLSAxKSBsYWJlbC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwgZW0tbGVnZW5kLWxhYmVsLWRpdmVyZ2VuY2UnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IGRpdmVyZ2luZyBsaW5lIGlmIGFwcGxpY2FibGUuIFdlIGRyYXcgaXQgYWZ0ZXJ3YXJkcyBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1heCBsZW5ndGggb2YgdGhlIGxlZ2VuZCBsYWJlbHMgc28gaXQgZG9lc250IGNvdmVyIHRoZW1cclxuICAgICAgICBpZiAob3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubnVtYmVyT2ZDbGFzc2VzXzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IGJhc2VZICsgaSAqIG91dC5zaGFwZUhlaWdodFxyXG4gICAgICAgICAgICAgICAgLy8gcG9pbnQgb2YgZGl2ZXJnZW5jZSBpbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgIGlmIChpID09IG91dC5wb2ludE9mRGl2ZXJnZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdEaXZlcmdpbmdMaW5lKHkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICdObyBkYXRhJyBib3ggYW5kIGxhYmVsIGlmIGFwcGxpY2FibGVcclxuICAgICAgICBpZiAob3V0Lm5vRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gYmFzZVkgKyBtLm51bWJlck9mQ2xhc3NlcygpICogb3V0LnNoYXBlSGVpZ2h0ICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG91dC5tYXAubm9EYXRhRmlsbFN0eWxlXylcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIG91dC5zaGFwZVdpZHRoICsgb3V0LmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQubm9EYXRhVGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2VzTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnXHJcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IGdldFRocmVzaG9sZHMoKVxyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYWJlbGxlciA9IChsYWJlbCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIGA+ICR7dGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIDFdfWAgLy90b3BcclxuICAgICAgICAgICAgaWYgKGkgPT09IHRocmVzaG9sZHMubGVuZ3RoKSByZXR1cm4gYDwgJHt0aHJlc2hvbGRzWzBdfWAgLy9ib3R0b21cclxuICAgICAgICAgICAgcmV0dXJuIGAke3RocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpIC0gMV19IC0gPCAke3RocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpXX0gIGAgLy9pbi1iZXR3ZWVuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyID0gb3V0LmxhYmVsRm9ybWF0dGVyIHx8IGRlZmF1bHRMYWJlbGxlclxyXG5cclxuICAgICAgICBsZXQgYmFzZVkgPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIGJhc2VZID0gYmFzZVkgKyBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLXRpdGxlJykgKyA4IC8vIHRpdGxlIHNpemUgKyBwYWRkaW5nXHJcblxyXG4gICAgICAgIC8vIGZvciBlYWNoIGNsYXNzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubnVtYmVyT2ZDbGFzc2VzXzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB5ID0gYmFzZVkgKyBpICogb3V0LnNoYXBlSGVpZ2h0XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBvdXQuYXNjZW5kaW5nID8gbWFwLm51bWJlck9mQ2xhc3NlcygpIC0gaSAtIDEgOiBpXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGxDb2xvciA9IG1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoZWNsLCBtYXAubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICAgICAgY29uc3QgaXRlbUNvbnRhaW5lciA9IGNvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgICAgICAvLyBzaGlmdCBsZWdlbmQgaXRlbXMgZG93biBhZnRlciBwb2ludCBvZiBkaXZlcmdlbmNlIGlmIGFwcGxpY2FibGVcclxuICAgICAgICAgICAgaWYgKG91dC5wb2ludE9mRGl2ZXJnZW5jZUxhYmVsICYmIGkgPj0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlKSB5ICs9IG91dC5wb2ludE9mRGl2ZXJnZW5jZVBhZGRpbmdcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGVcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnJhaXNlKClcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHNlcGFyYXRpb24gbGluZVxyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXNlcGFyYXRvcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBvdXQuYm94UGFkZGluZyArIG91dC5zZXBMaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBsYWJlbHNcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBNYXRoLm1heChvdXQuc2hhcGVXaWR0aCwgb3V0LnNlcExpbmVMZW5ndGggKyBvdXQudGlja0xlbmd0aCkgKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQubGFiZWxzID8gb3V0LmxhYmVsc1tpXSA6IGxhYmVsRm9ybWF0dGVyKG1hcC5jbGFzc2lmaWVyKCkuaW52ZXJ0RXh0ZW50KGVjbClbb3V0LmFzY2VuZGluZyA/IDAgOiAxXSwgaSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IGRpdmVyZ2luZyBsaW5lIGlmIGFwcGxpY2FibGUuIFdlIGRyYXcgaXQgYWZ0ZXJ3YXJkcyBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1heCBsZW5ndGggb2YgdGhlIGxlZ2VuZCBsYWJlbHMgc28gaXQgZG9lc250IGNvdmVyIHRoZW1cclxuICAgICAgICBpZiAob3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubnVtYmVyT2ZDbGFzc2VzXzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IGJhc2VZICsgaSAqIG91dC5zaGFwZUhlaWdodFxyXG4gICAgICAgICAgICAgICAgLy8gcG9pbnQgb2YgZGl2ZXJnZW5jZSBpbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgIGlmIChpID09IG91dC5wb2ludE9mRGl2ZXJnZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdEaXZlcmdpbmdMaW5lKHkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICdObyBkYXRhJyBib3ggYW5kIGxhYmVsIGlmIGFwcGxpY2FibGVcclxuICAgICAgICBpZiAob3V0Lm5vRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBub0RhdGFJdGVtQ29udGFpbmVyID0gY29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuICAgICAgICAgICAgbGV0IHkgPSBiYXNlWSArIG1hcC5udW1iZXJPZkNsYXNzZXMoKSAqIG91dC5zaGFwZUhlaWdodCArIG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIHkgKz0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlUGFkZGluZyAvLyBzaGlmdCBsZWdlbmQgaXRlbXMgZG93biBhZnRlciBwb2ludCBvZiBkaXZlcmdlbmNlXHJcbiAgICAgICAgICAgIG5vRGF0YUl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBvdXQubWFwLm5vRGF0YUZpbGxTdHlsZV8pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykucmFpc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMobWFwLmluc2V0VGVtcGxhdGVzXywgbWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhtYXAuaW5zZXRUZW1wbGF0ZXNfLCBtYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgbm9EYXRhSXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdEaXZlcmdpbmdMaW5lKHkpIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdlbmNlLWNvbnRhaW5lcicpXHJcbiAgICAgICAgY29uc3QgbWFya2VySGVpZ2h0ID0gNlxyXG4gICAgICAgIGNvbnN0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGlmIChvdXQubGFiZWxUeXBlID09ICdyYW5nZXMnKSB5ID0geSArIG91dC5wb2ludE9mRGl2ZXJnZW5jZVBhZGRpbmcgLyAyIC8vIG1vdmUgdG8gdGhlIG1pZGRsZSBvZiB0aGUgc3BhY2UgYmV0d2VlbiBsZWdlbmQgaXRlbVxyXG4gICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IG91dC5sZ2dcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5ub2RlcygpXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKG1heCwgbm9kZSkgPT4gTWF0aC5tYXgobWF4LCBub2RlLmdldEJCb3goKS53aWR0aCksIDApXHJcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IG91dC5kaXZlcmdpbmdMaW5lTGVuZ3RoIHx8IG1heExhYmVsTGVuZ3RoICsgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIDEwIC8vICsgcGFkZGluZ1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBob3Jpem9udGFsIGRpdmVyZ2VuY2UgbGluZVxyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgeClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCArIGxpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtZGl2ZXJnaW5nLWxpbmUnKVxyXG5cclxuICAgICAgICAvLyBkaXZlcmdlbmNlIGxpbmUgd2l0aCB1cCBhbmQgZG93biBhcnJvd3NcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbC5zcGxpdCgnfCcpXHJcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkxpbmVMZW5ndGggPSBvdXQuZGl2ZXJnaW5nQXJyb3dMZW5ndGggfHwgMzBcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uTGluZVggPSB4ICsgbGluZUxlbmd0aFxyXG4gICAgICAgICAgICAvLyBBZGQgYXJyb3doZWFkIG1hcmtlciBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGRlZnMgPSBjb250YWluZXIuYXBwZW5kKCdkZWZzJylcclxuICAgICAgICAgICAgZGVmcy5hcHBlbmQoJ21hcmtlcicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnYXJyb3doZWFkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIG1hcmtlckhlaWdodClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCBtYXJrZXJIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncmVmWCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncmVmWScsIG1hcmtlckhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgYDAgMCwgJHttYXJrZXJIZWlnaHR9ICR7bWFya2VySGVpZ2h0IC8gMn0sIDAgJHttYXJrZXJIZWlnaHR9YClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuXHJcbiAgICAgICAgICAgIC8vIFVwd2FyZCBsaW5lIHdpdGggYXJyb3doZWFkXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGRpcmVjdGlvbkxpbmVYKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGRpcmVjdGlvbkxpbmVYKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSAtIGRpcmVjdGlvbkxpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG5cclxuICAgICAgICAgICAgLy8gRG93bndhcmQgbGluZSB3aXRoIGFycm93aGVhZFxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdpbmctbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkgKyBkaXJlY3Rpb25MaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCAndXJsKCNhcnJvd2hlYWQpJylcclxuXHJcbiAgICAgICAgICAgIC8vIExhYmVscyBmb3IgdXB3YXJkIGFuZCBkb3dud2FyZCBsaW5lc1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGRpcmVjdGlvbkxpbmVYICsgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgLSBkaXJlY3Rpb25MaW5lTGVuZ3RoICsgMTApXHJcbiAgICAgICAgICAgICAgICAudGV4dChsYWJlbHNbMF0pXHJcblxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGRpcmVjdGlvbkxpbmVYICsgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBkaXJlY3Rpb25MaW5lTGVuZ3RoIC0gMTApXHJcbiAgICAgICAgICAgICAgICAudGV4dChsYWJlbHNbMV0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8ganVzdCB0aGUgc2luZ2xlIGxhYmVsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWRpdmVyZ2luZy1sYWJlbCBlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4ICsgbGluZUxlbmd0aCArIDUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbW92ZSB0aHJlc2hvbGQgbGFiZWwgb3V0IG9mIHRoZSB3YXkgb2YgdGhlIGxpbmVcclxuICAgICAgICBpZiAob3V0LmxhYmVsVHlwZSA9PSAndGhyZXNob2xkcycpIHtcclxuICAgICAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGl0IHRvIGVuZCBvZiBsaW5lXHJcbiAgICAgICAgICAgICAgICBvdXQubGdnLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbC1kaXZlcmdlbmNlJykuYXR0cigneCcsIHggKyBsaW5lTGVuZ3RoICsgMTApXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGljayBsaW5lXHJcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd4MScsIHggKyBsaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLmF0dHIoJ3gyJywgeCArIGxpbmVMZW5ndGggKyA1KVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSBpdCBzbyBpdCBkb2VzbnQgY2xhc2ggd2l0aCBwb2ludE9mRGl2ZXJnZW5jZUxhYmVsXHJcbiAgICAgICAgICAgICAgICBvdXQubGdnLnNlbGVjdEFsbCgnLmVtLWxlZ2VuZC1sYWJlbC1kaXZlcmdlbmNlJykucmVtb3ZlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVCYXJDaGFydExlZ2VuZCgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IGdldFRocmVzaG9sZHMoKVxyXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IGdldENvbG9ycygpXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldERhdGEoKVxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBjb3VudHMgZm9yIGVhY2ggdGhyZXNob2xkIHJhbmdlXHJcbiAgICAgICAgbGV0IGNvdW50cyA9IG5ldyBBcnJheShtYXAubnVtYmVyT2ZDbGFzc2VzXykuZmlsbCgwKVxyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgLy8gVXNlIG0uY2xhc3NpZmllcigpIHRvIGdldCB0aGUgY2xhc3MgaW5kZXhcclxuICAgICAgICAgICAgY29uc3QgY2xhc3NJbmRleCA9IG1hcC5jbGFzc2lmaWVyKCkodmFsdWUpXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjbGFzc0luZGV4IGlzIHZhbGlkIGFuZCBpbmNyZW1lbnQgdGhlIGNvdW50XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xhc3NJbmRleCA9PT0gJ251bWJlcicgJiYgY2xhc3NJbmRleCA+PSAwICYmIGNsYXNzSW5kZXggPCBjb3VudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudHNbY2xhc3NJbmRleF0rK1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gUmV2ZXJzZSB0aGUgY291bnRzIGFycmF5IGZvciBoaWdoZXN0IGNsYXNzZXMgb24gdG9wXHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRDb3VudHMgPSBjb3VudHMuc2xpY2UoKS5yZXZlcnNlKClcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIG51bWJlciBvZiBjb2xvcnMgbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIGJhcnNcclxuICAgICAgICBjb25zdCBjb2xvckNvdW50ID0gcmV2ZXJzZWRDb3VudHMubGVuZ3RoXHJcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggIT09IGNvbG9yQ291bnQpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBNaXNtYXRjaCBiZXR3ZWVuIG51bWJlciBvZiBjb2xvcnMgKCR7Y29sb3JzLmxlbmd0aH0pIGFuZCBudW1iZXIgb2YgYmFycyAoJHtjb2xvckNvdW50fSlgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGdnID0gb3V0LmxnZ1xyXG4gICAgICAgIGxldCBiYXNlWSA9IG91dC5ib3hQYWRkaW5nICsgMzBcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSBiYXNlWSA9IGJhc2VZICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpICsgOCAvLyB0aXRsZSBzaXplICsgcGFkZGluZ1xyXG5cclxuICAgICAgICAvLyBTZXQgdXAgZGltZW5zaW9uc1xyXG4gICAgICAgIGNvbnN0IHN2Z1dpZHRoID0gMzAwXHJcbiAgICAgICAgY29uc3Qgc3ZnSGVpZ2h0ID0gMzAwXHJcbiAgICAgICAgY29uc3QgbWFyZ2luID0geyB0b3A6IDIwLCByaWdodDogNjAsIGJvdHRvbTogMjAsIGxlZnQ6IDE1MCB9IC8vIEluY3JlYXNlZCBsZWZ0IG1hcmdpblxyXG4gICAgICAgIC8vIFNldCB1cCBzY2FsZXMgd2l0aCByZXZlcnNlZENvdW50c1xyXG4gICAgICAgIGNvbnN0IHlTY2FsZSA9IHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5kb21haW4ocmV2ZXJzZWRDb3VudHMubWFwKChfLCBpKSA9PiBpKSlcclxuICAgICAgICAgICAgLnJhbmdlKFttYXJnaW4udG9wLCBzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tXSlcclxuICAgICAgICAgICAgLnBhZGRpbmcoMC4xKVxyXG5cclxuICAgICAgICBjb25zdCB4U2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oWzAsIG1heChyZXZlcnNlZENvdW50cyldKVxyXG4gICAgICAgICAgICAubmljZSgpXHJcbiAgICAgICAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHN2Z1dpZHRoIC0gbWFyZ2luLnJpZ2h0XSlcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IDxnPiBlbGVtZW50IGZvciB0aGUgYmFyc1xyXG4gICAgICAgIGNvbnN0IGJhckdyb3VwID0gbGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1iYXJjaGFydCcpLnN0eWxlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDBweCwgMTBweCknKSAvLyBBZGQgYSBjbGFzcyB0byB0aGlzIGdyb3VwIGZvciBlYXN5IHJlZmVyZW5jZVxyXG5cclxuICAgICAgICAvLyBEcmF3IGJhcnMgd2l0aCBtb3VzZW92ZXIgaGlnaGxpZ2h0IGFuZCBzdHlsaW5nXHJcbiAgICAgICAgYmFyR3JvdXBcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5kYXRhKHJldmVyc2VkQ291bnRzKVxyXG4gICAgICAgICAgICAuam9pbigncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKF8sIGkpID0+IHlTY2FsZShpKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHlTY2FsZS5iYW5kd2lkdGgoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQpID0+IHhTY2FsZShkKSAtIG1hcmdpbi5sZWZ0KVxyXG4gICAgICAgICAgICAuYXR0cignZWNsJywgKF8sIGkpID0+IGkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgKF8sIGkpID0+IGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gaSAtIDFdKSAvLyBSZXZlcnNlIGNvbG9yIG9yZGVyIHRvIG1hdGNoIGNvdW50c1xyXG4gICAgICAgICAgICAuc3R5bGUoJ2N1cnNvcicsICdwb2ludGVyJykgLy8gU2V0IGN1cnNvciB0byBwb2ludGVyXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKF8sIGkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBwYXJzZUludChlY2wsIDEwKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRJbmRleCA9IGNvbG9ycy5sZW5ndGggLSAxIC0gY3VycmVudEluZGV4IC8vIHJldmVyc2VcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgcmV2ZXJzZWRJbmRleClcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChfLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFkZCBjb3VudCBsYWJlbHMgbmV4dCB0byBiYXJzXHJcbiAgICAgICAgaWYgKG91dC5iYXJDaGFydENvdW50cykge1xyXG4gICAgICAgICAgICBiYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dC5jb3VudC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShyZXZlcnNlZENvdW50cylcclxuICAgICAgICAgICAgICAgIC5qb2luKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjb3VudC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiB4U2NhbGUoZCkgKyA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoXywgaSkgPT4geVNjYWxlKGkpICsgeVNjYWxlLmJhbmR3aWR0aCgpIC8gMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzE0cHgnKSAvLyBTZXQgbGFiZWwgZm9udCBzaXplIHRvIDE0cHhcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiBkKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIFkgYXhpcyB3aXRoIGN1c3RvbSB0aWNrIGxhYmVscyBpbiByZXZlcnNlZCBvcmRlciBhdCAxNHB4XHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSBiYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sIDApYClcclxuICAgICAgICAgICAgLmNhbGwoXHJcbiAgICAgICAgICAgICAgICBheGlzTGVmdCh5U2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplT3V0ZXIoMClcclxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoMClcclxuICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmJhckNoYXJ0TGFiZWxGb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3V0LmJhckNoYXJ0TGFiZWxGb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKF8sIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSByZXR1cm4gYD4gJHt0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gMV19YCAvL3RvcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHRocmVzaG9sZHMubGVuZ3RoKSByZXR1cm4gYDwgJHt0aHJlc2hvbGRzWzBdfWAgLy9ib3R0b21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gaSAtIDFdfSAtIDwgJHt0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gaV19ICBgIC8vaW4tYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzE0cHgnKSAvLyBTZXQgWS1heGlzIHRpY2sgbGFiZWwgZm9udCBzaXplIHRvIDE0cHhcclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKCdbZWNsXScpXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVnaW9ucyB0byB3aGl0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBhbGxSZWdpb25zLmZpbHRlcihcIltlY2w9J1wiICsgZWNsICsgXCInXVwiKVxyXG4gICAgICAgIHNlbGVjdGVkUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9kZXByZWNhdGVkXHJcbiAgICBvdXQubGFiZWxEZWNOYiA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdsYWJlbERlY05iIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIGRlY2ltYWxzIGluc3RlYWQuJyksIG91dClcclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ2QzLWZvcm1hdCdcclxuXHJcbi8vc2V0IGxlZ2VuZCBsYWJlbHMgbG9jYWxlXHJcbmZvcm1hdERlZmF1bHRMb2NhbGUoe1xyXG4gICAgZGVjaW1hbDogJy4nLFxyXG4gICAgdGhvdXNhbmRzOiAnICcsXHJcbiAgICBncm91cGluZzogWzNdLFxyXG4gICAgY3VycmVuY3k6IFsnJywgJ+KCrCddLFxyXG59KVxyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBwcm9wb3J0aW9uYWwgc3ltYm9sIG1hcFxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgY29uZmlnc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gY29uZmlnW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNvbG9yTGVnZW5kID09IGZhbHNlKSBvdXQuY29sb3JMZWdlbmQgPSBmYWxzZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGxlZ2VuZCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmIChtLmxlZ2VuZF8pXHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBtLmxlZ2VuZF8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ2NvbG9yTGVnZW5kJyB8fCBrZXkgPT0gJ3NpemVMZWdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIG0ubGVnZW5kX1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5sZWdlbmRfW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV1bcF0gPSBtLmxlZ2VuZF9ba2V5XVtwXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRba2V5XSA9IG0ubGVnZW5kX1trZXldXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgYnVpbGRGbG93TGVnZW5kKClcclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgd2hpY2ggaWxsdXN0cmF0ZXMgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgZmxvdyBzeW1ib2wgc2l6ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gY29udGFpbmVyIHBhcmVudCBsZWdlbmQgb2JqZWN0IGZyb20gY29yZS9sZWdlbmQuanNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRGbG93TGVnZW5kKG0pIHt9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4vbGVnZW5kJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2wgbWFwXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy9zcGFjaW5nIGJldHdlZW4gY29sb3IgJiBzaXplIGxlZ2VuZHMgKGlmIGFwcGxpY2FibGUpXHJcbiAgICBvdXQubGVnZW5kU3BhY2luZyA9IDE1XHJcblxyXG4gICAgLy9zaXplIGxlZ2VuZCBjb25maWcgKGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIHZhbHVlcyBvZiBkaWZmZXJlbnQgcGllIHNpemVzKVxyXG4gICAgb3V0LnNpemVMZWdlbmQgPSB7XHJcbiAgICAgICAgdGl0bGU6IG51bGwsXHJcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAzMCwgLy9wYWRkaW5nIGJldHdlZW4gdGl0bGUgYW5kIGJvZHlcclxuICAgICAgICB2YWx1ZXM6IG51bGwsXHJcbiAgICB9XHJcblxyXG4gICAgLy9jb2xvdXIgbGVnZW5kIGNvbmZpZyAobGVnZW5kIGlsbHVzdHJhdGluZyB0aGUgdmFsdWVzIG9mIGRpZmZlcmVudCBwaWUgY29sb3VycylcclxuICAgIG91dC5jb2xvckxlZ2VuZCA9IHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICBsYWJlbE9mZnNldDogNSwgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICAgICAgc2hhcGVXaWR0aDogMjUsIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICAgICAgc2hhcGVIZWlnaHQ6IDIwLCAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgICAgICBzaGFwZVBhZGRpbmc6IDUsIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgICAgIG5vRGF0YTogdHJ1ZSwgLy9zaG93IG5vIGRhdGFcclxuICAgICAgICBub0RhdGFUZXh0OiAnTm8gZGF0YScsIC8vbm8gZGF0YSBsYWJlbCB0ZXh0XHJcbiAgICB9XHJcblxyXG4gICAgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ID0gMFxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgY29uZmlnc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gY29uZmlnW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vIGxlZ2VuZCBmb3Igc2l6ZXNcclxuICAgICAgICBpZiAobWFwLnNpemVDbGFzc2lmaWVyXykge1xyXG4gICAgICAgICAgICBidWlsZFNpemVMZWdlbmQoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGVnZW5kIGZvciBwcyBjb2xvciB2YWx1ZXNcclxuICAgICAgICBidWlsZENvbG9yTGVnZW5kKClcclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgd2hpY2ggaWxsdXN0cmF0ZXMgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgcGllIGNoYXJ0IHNpemVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBtIG1hcFxyXG4gICAgICogQHBhcmFtIHsqfSBsZ2cgcGFyZW50IGxlZ2VuZCBvYmplY3QgZnJvbSBjb3JlL2xlZ2VuZC5qc1xyXG4gICAgICogQHBhcmFtIHsqfSBjb25maWcgc2l6ZSBsZWdlbmQgY29uZmlnIG9iamVjdCAoc2l6ZUxlZ2VuZCBvYmplY3Qgc3BlY2lmaWVkIGFzIHByb3BlcnR5IG9mIGxlZ2VuZCgpIGNvbmZpZyBvYmplY3QpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2l6ZUxlZ2VuZCgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3QgY29uZmlnID0gb3V0LnNpemVMZWdlbmRcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZS1zaXplLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IG1hcC5zaXplQ2xhc3NpZmllcl8uZG9tYWluKClcclxuXHJcbiAgICAgICAgLy8gQXNzaWduIGRlZmF1bHQgY2lyY2xlIHJhZGlpIGlmIG5vbmUgc3BlY2lmaWVkIGJ5IHVzZXJcclxuICAgICAgICBpZiAoIWNvbmZpZy52YWx1ZXMpIHtcclxuICAgICAgICAgICAgY29uZmlnLnZhbHVlcyA9IFtNYXRoLmZsb29yKGRvbWFpblsxXSksIE1hdGguZmxvb3IoZG9tYWluWzBdKV1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBjaXJjbGUgc2l6ZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxlZ2VuZFxyXG4gICAgICAgIGxldCBtYXhTaXplID0gbWFwLnNpemVDbGFzc2lmaWVyXyhtYXgoY29uZmlnLnZhbHVlcykpXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgdGl0bGUgdG8gdGhlIGNvbnRhaW5lciBpZiBhdmFpbGFibGVcclxuICAgICAgICBpZiAoIWNvbmZpZy50aXRsZSAmJiBvdXQudGl0bGUpIGNvbmZpZy50aXRsZSA9IG91dC50aXRsZSAvLyBBbGxvdyByb290IGxlZ2VuZCB0aXRsZVxyXG4gICAgICAgIGxldCB0aXRsZUhlaWdodCA9IDAgLy8gVGhpcyB3aWxsIGJlIGFkanVzdGVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHRpdGxlIGV4aXN0c1xyXG4gICAgICAgIGlmIChjb25maWcudGl0bGUpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKSAvLyBQb3NpdGlvbiB0aGUgdGl0bGUgYXQgdGhlIGxlZnQgZWRnZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKSAvLyBUaXRsZSBhdCB0b3AsIHdpdGhpbiBwYWRkaW5nXHJcbiAgICAgICAgICAgICAgICAudGV4dChjb25maWcudGl0bGUpXHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3QgdGl0bGUgaGVpZ2h0ICh1c2luZyB0aGUgdGl0bGUgZm9udCBzaXplIGFzIGEgcHJveHkpXHJcbiAgICAgICAgICAgIHRpdGxlSGVpZ2h0ID0gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyArIGNvbmZpZy50aXRsZVBhZGRpbmdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdyBwb3NpdGlvbiB0aGUgY2lyY2xlcyAqKmJlbG93KiogdGhlIHRpdGxlXHJcbiAgICAgICAgbGV0IHkgPSB0aXRsZUhlaWdodCArIG91dC5ib3hQYWRkaW5nICsgbWF4U2l6ZSAqIDIgLy8gUG9zaXRpb24gY2lyY2xlcyBhZnRlciB0aXRsZSBoZWlnaHRcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBsZWdlbmQgY2lyY2xlc1xyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1zID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShjb25maWcudmFsdWVzKVxyXG4gICAgICAgICAgICAuam9pbignZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtaXRlbScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWF4U2l6ZSArIG91dC5ib3hQYWRkaW5nfSwgJHt5fSlgKSAvLyBEeW5hbWljYWxseSBtb3ZlIHRoZSBjaXJjbGVzIGRvd25cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGNpcmNsZXMgdG8gZWFjaCBncm91cFxyXG4gICAgICAgIGxlZ2VuZEl0ZW1zXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtY2lyY2xlJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgKGQpID0+IC1tYXAuc2l6ZUNsYXNzaWZpZXJfKGQpKSAvLyBQb3NpdGlvbiBjaXJjbGVzIGJhc2VkIG9uIHRoZWlyIHNpemVcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBtYXAuc2l6ZUNsYXNzaWZpZXJfKSAvLyBSYWRpdXMgaXMgY2FsY3VsYXRlZCBmcm9tIHNpemUgY2xhc3NpZmllclxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgbGFiZWxzIHRvIGVhY2ggZ3JvdXBcclxuICAgICAgICBsZWdlbmRJdGVtc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+IC0yICogbWFwLnNpemVDbGFzc2lmaWVyXyhkKSAtIG91dC5sYWJlbEZvbnRTaXplIC0gMikgLy8gUG9zaXRpb24gbGFiZWxzIHJlbGF0aXZlIHRvIGNpcmNsZXNcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAzMCkgLy8gU2V0IHRoZSB4LXBvc2l0aW9uIGZvciB0aGUgbGFiZWxzXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4bWw6c3BhY2UnLCAncHJlc2VydmUnKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gZC50b0xvY2FsZVN0cmluZygnZW4nKS5yZXBsYWNlKC8sL2dpLCAnICcpKSAvLyBGb3JtYXQgdGhlIGxhYmVsIHRleHRcclxuXHJcbiAgICAgICAgLy8gQWRkIGxpbmVzIHBvaW50aW5nIHRvIHRoZSB0b3Agb2YgdGhlIGNvcnJlc3BvbmRpbmcgY2lyY2xlXHJcbiAgICAgICAgbGVnZW5kSXRlbXNcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIDMwKVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAoZCkgPT4gLTIgKiBtYXAuc2l6ZUNsYXNzaWZpZXJfKGQpKSAvLyBQb3NpdGlvbiBsaW5lcyByZWxhdGl2ZSB0byBjaXJjbGVzXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIChkKSA9PiAtMiAqIG1hcC5zaXplQ2xhc3NpZmllcl8oZCkpIC8vIFNhbWUgcG9zaXRpb24gZm9yIHRoZSB5MiB0byBtYWtlIGEgaG9yaXpvbnRhbCBsaW5lXHJcblxyXG4gICAgICAgIC8vIFNhdmUgdGhlIGhlaWdodCB2YWx1ZSBmb3IgcG9zaXRpb25pbmcgdGhlIGNvbG9yIGxlZ2VuZCAoaWYgbmVlZGVkKVxyXG4gICAgICAgIG91dC5fc2l6ZUxlZ2VuZEhlaWdodCA9IHlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgb2YgdGhlIHBpZSBjaGFydHMnIGRpZmZlcmVudCBjb2xvdXJzXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZENvbG9yTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBjb25maWcgPSBvdXQuY29sb3JMZWdlbmRcclxuICAgICAgICAvL2NvbnRhaW5lclxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tcGllLWNvbG9yLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChjb25maWcudGl0bGUpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ICsgb3V0LmxlZ2VuZFNwYWNpbmcgKyBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoY29uZmlnLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICBsZXQgaSA9IDBcclxuICAgICAgICBjb25zdCBzY3MgPSBtYXAuY2F0Q29sb3JzKClcclxuICAgICAgICBmb3IgKGxldCBjb2RlIGluIHNjcykge1xyXG4gICAgICAgICAgICAvL3RoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgeSA9XHJcbiAgICAgICAgICAgICAgICBvdXQuX3NpemVMZWdlbmRIZWlnaHQgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmxlZ2VuZFNwYWNpbmcgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmJveFBhZGRpbmcgK1xyXG4gICAgICAgICAgICAgICAgKGNvbmZpZy50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArXHJcbiAgICAgICAgICAgICAgICBpICogKGNvbmZpZy5zaGFwZUhlaWdodCArIGNvbmZpZy5zaGFwZVBhZGRpbmcpXHJcbiAgICAgICAgICAgIC8vdGhlIGNvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IG1hcC5jYXRDb2xvcnMoKVtjb2RlXSB8fCAnbGlnaHRncmF5J1xyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29uZmlnLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29uZmlnLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgc2NzW2NvZGVdKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC41KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vbGFiZWxcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIGNvbmZpZy5zaGFwZVdpZHRoICsgY29uZmlnLmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgY29uZmlnLnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChtYXAuY2F0TGFiZWxzKClbY29kZV0gfHwgY29kZSlcclxuXHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChjb25maWcubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPVxyXG4gICAgICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ICtcclxuICAgICAgICAgICAgICAgIG91dC5sZWdlbmRTcGFjaW5nICtcclxuICAgICAgICAgICAgICAgIG91dC5ib3hQYWRkaW5nICtcclxuICAgICAgICAgICAgICAgIChjb25maWcudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgK1xyXG4gICAgICAgICAgICAgICAgaSAqIChjb25maWcuc2hhcGVIZWlnaHQgKyBjb25maWcuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29uZmlnLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29uZmlnLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbWFwLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vJ25vIGRhdGEnIGxhYmVsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBjb25maWcuc2hhcGVXaWR0aCArIGNvbmZpZy5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIGNvbmZpZy5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KGNvbmZpZy5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgc2VnbWVudHMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgY29kZSkge1xyXG4gICAgICAgIGNvbnN0IGFsbFNlZ21lbnRzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCcucGllY2hhcnQnKS5zZWxlY3RBbGwoJ3BhdGhbY29kZV0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHNlZ21lbnRzIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsU2VnbWVudHMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgc2VnbWVudHMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTZWdtZW50cyA9IGFsbFNlZ21lbnRzLmZpbHRlcihcInBhdGhbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKVxyXG4gICAgICAgIHNlbGVjdGVkU2VnbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHNlZ21lbnRzXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgc2VnbWVudHMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3QgYWxsU2VnbWVudHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJy5waWVjaGFydCcpLnNlbGVjdEFsbCgncGF0aFtjb2RlXScpXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCBzZWdtZW50cydzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsU2VnbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgc3ltYm9sc0xpYnJhcnkgfSBmcm9tICcuLi9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMnXHJcbmltcG9ydCB7IHN5bWJvbCB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuaW1wb3J0IHsgZm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcblxyXG4vL3NldCBsZWdlbmQgbGFiZWxzIGxvY2FsZVxyXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcclxuICAgIGRlY2ltYWw6ICcuJyxcclxuICAgIHRob3VzYW5kczogJyAnLFxyXG4gICAgZ3JvdXBpbmc6IFszXSxcclxuICAgIGN1cnJlbmN5OiBbJycsICfigqwnXSxcclxufSlcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbCBtYXBcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IGZvciB0aGUgbWFwXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICBvdXQuYXNjZW5kaW5nID0gZmFsc2UgLy90aGUgb3JkZXIgb2YgdGhlIGxlZ2VuZCBlbGVtZW50cy4gU2V0IHRvIGZhbHNlIHRvIGludmVydC5cclxuICAgIG91dC5sZWdlbmRTcGFjaW5nID0gMzUgLy9zcGFjaW5nIGJldHdlZW4gY29sb3IgJiBzaXplIGxlZ2VuZHMgKGlmIGFwcGxpY2FibGUpXHJcbiAgICBvdXQubGFiZWxGb250U2l6ZSA9IDEyIC8vdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGVnZW5kIGxhYmVsc1xyXG5cclxuICAgIG91dC5ub0RhdGFTaGFwZVdpZHRoID0gMjVcclxuICAgIG91dC5ub0RhdGFTaGFwZUhlaWdodCA9IDIwXHJcblxyXG4gICAgLy9zaXplIGxlZ2VuZCBjb25maWcgKGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIHZhbHVlcyBvZiBkaWZmZXJlbnQgc3ltYm9sIHNpemVzKVxyXG4gICAgb3V0LnNpemVMZWdlbmQgPSB7XHJcbiAgICAgICAgdGl0bGU6IG51bGwsXHJcbiAgICAgICAgdGl0bGVGb250U2l6ZTogMTIsXHJcbiAgICAgICAgdGl0bGVQYWRkaW5nOiA1LCAvL3BhZGRpbmcgYmV0d2VlbiB0aXRsZSBhbmQgbGVnZW5kIGJvZHlcclxuICAgICAgICB2YWx1ZXM6IHVuZGVmaW5lZCwgLy9tYW51YWxseSBkZWZpbmUgcmF3IGRhdGEgdmFsdWVzXHJcbiAgICAgICAgY2VsbE5iOiAzLCAvL251bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbGVnZW5kXHJcbiAgICAgICAgc2hhcGVQYWRkaW5nOiA1LCAvL3RoZSB5IGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIHNoYXBlIGVsZW1lbnRzXHJcbiAgICAgICAgc2hhcGVPZmZzZXQ6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgIHNoYXBlRmlsbDogJ3doaXRlJyxcclxuICAgICAgICBzaGFwZVN0cm9rZTogbnVsbCxcclxuICAgICAgICBsYWJlbE9mZnNldDogeyB4OiAxMCwgeTogMCB9LCAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbGFiZWxcclxuICAgICAgICBkZWNpbWFsczogMCwgLy90aGUgbnVtYmVyIG9mIGRlY2ltYWwgZm9yIHRoZSBsZWdlbmQgbGFiZWxzXHJcbiAgICAgICAgbGFiZWxGb3JtYXR0ZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICBfdG90YWxCYXJzSGVpZ2h0OiAwLFxyXG4gICAgICAgIF90b3RhbEQzU3ltYm9sc0hlaWdodDogMCxcclxuICAgICAgICBub0RhdGE6IGZhbHNlLCAvLyBzaG93IG5vIGRhdGEgbGVnZW5kIGl0ZW1cclxuICAgICAgICBub0RhdGFUZXh0OiAnTm8gZGF0YScsIC8vbm8gZGF0YSB0ZXh0IGxhYmVsXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29sb3IgbGVnZW5kIGNvbmZpZyAobGVnZW5kIGlsbHVzdHJhdGluZyB0aGUgZGF0YS1kcml2ZW4gY29sb3VyIGNsYXNzZXMpXHJcbiAgICBvdXQuY29sb3JMZWdlbmQgPSB7XHJcbiAgICAgICAgdGl0bGU6IG51bGwsXHJcbiAgICAgICAgdGl0bGVGb250U2l6ZTogMTIsXHJcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAxMCwgLy9wYWRkaW5nIGJldHdlZW4gdGl0bGUgYW5kIGxlZ2VuZCBib2R5XHJcbiAgICAgICAgbWFyZ2luVG9wOiAzMCwgLy8gbWFyZ2luIHRvcCAoZGlzdGFuY2UgYmV0d2VlbiBjb2xvciBhbmQgc2l6ZSBsZWdlbmQpXHJcbiAgICAgICAgc2hhcGVXaWR0aDogMjUsIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICAgICAgc2hhcGVIZWlnaHQ6IDIwLCAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgICAgICBzaGFwZVBhZGRpbmc6IDEsIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIHNoYXBlIGVsZW1lbnRzIGluIHRoZSBjb2xvciBsZWdlbmRcclxuICAgICAgICBsYWJlbE9mZnNldDogeyB4OiA1LCB5OiAwIH0sIC8vZGlzdGFuY2UgKHgpIGJldHdlZW4gbGFiZWwgdGV4dCBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgc2hhcGUgZWxlbWVudFxyXG4gICAgICAgIGRlY2ltYWxzOiAwLCAvL3RoZSBudW1iZXIgb2YgZGVjaW1hbCBmb3IgdGhlIGxlZ2VuZCBsYWJlbHNcclxuICAgICAgICBsYWJlbEZvcm1hdHRlcjogdW5kZWZpbmVkLCAvLyB1c2VyLWRlZmluZWQgZDMgZm9ybWF0IGZ1bmN0aW9uXHJcbiAgICAgICAgbm9EYXRhOiB0cnVlLCAvL3Nob3cgbm8gZGF0YVxyXG4gICAgICAgIG5vRGF0YVRleHQ6ICdObyBkYXRhJywgLy9ubyBkYXRhIHRleHQgbGFiZWxcclxuICAgICAgICBzZXBMaW5lTGVuZ3RoOiAyNCwgLy8gLy90aGUgc2VwYXJhdGlvbiBsaW5lIGxlbmd0aFxyXG4gICAgICAgIHNlcExpbmVTdHJva2U6ICdibGFjaycsIC8vdGhlIHNlcGFyYXRpb24gbGluZSBjb2xvclxyXG4gICAgICAgIHNlcExpbmVTdHJva2VXaWR0aDogMSwgLy90aGUgc2VwYXJhdGlvbiBsaW5lIHdpZHRoXHJcbiAgICAgICAgdGlja0xlbmd0aDogNSwgLy8gdGhyZXNob2xkIHRpY2tzIGxlbmd0aCBpbiBweFxyXG4gICAgfVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgY29uZmlnc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gY29uZmlnW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNvbG9yTGVnZW5kID09IGZhbHNlKSBvdXQuY29sb3JMZWdlbmQgPSBmYWxzZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBpZiAob3V0LmxnZy5ub2RlKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbSA9IG91dC5tYXBcclxuICAgICAgICAgICAgY29uc3QgbGdnID0gb3V0LmxnZ1xyXG5cclxuICAgICAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBsZWdlbmQgYmFja2dyb3VuZCBib3hcclxuICAgICAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IGhlaWdodCBjb3VudGVyc1xyXG4gICAgICAgICAgICBvdXQuc2l6ZUxlZ2VuZC5fdG90YWxCYXJzSGVpZ2h0ID0gMFxyXG4gICAgICAgICAgICBvdXQuc2l6ZUxlZ2VuZC5fdG90YWxEM1N5bWJvbHNIZWlnaHQgPSAwXHJcblxyXG4gICAgICAgICAgICAvLyBsZWdlbmQgZm9yIHNpemVcclxuICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kTm9kZSA9IGxnZy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdzaXplLWxlZ2VuZC1jb250YWluZXInKVxyXG4gICAgICAgICAgICBpZiAobS5jbGFzc2lmaWVyU2l6ZV8pIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkU2l6ZUxlZ2VuZChtLCBvdXQuc2l6ZUxlZ2VuZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBsZWdlbmQgZm9yIHBzIGNvbG9yIHZhbHVlc1xyXG4gICAgICAgICAgICBvdXQuX2NvbG9yTGVnZW5kTm9kZSA9IGxnZy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdjb2xvci1sZWdlbmQtY29udGFpbmVyJylcclxuXHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIGl0IGJlbG93IHNpemUgbGVnZW5kXHJcbiAgICAgICAgICAgIGlmIChvdXQuX3NpemVMZWdlbmROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuX2NvbG9yTGVnZW5kTm9kZS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsJHtvdXQuX3NpemVMZWdlbmROb2RlLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0fSlgKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobS5jbGFzc2lmaWVyQ29sb3JfICYmIG91dC5jb2xvckxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRDb2xvckxlZ2VuZChtLCBvdXQuY29sb3JMZWdlbmQpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGxlZ2VuZCBib3ggZGltZW5zaW9uc1xyXG4gICAgICAgICAgICBvdXQuc2V0Qm94RGltZW5zaW9uKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgd2hpY2ggaWxsdXN0cmF0ZXMgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgc3ltYm9sIHNpemVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBtYXAgbWFwIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRhaW5lciBwYXJlbnQgbGVnZW5kIG9iamVjdCBmcm9tIGNvcmUvbGVnZW5kLmpzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2l6ZUxlZ2VuZChtKSB7XHJcbiAgICAgICAgaWYgKCFtLnBzQ3VzdG9tU1ZHXyAmJiBtLnBzU2hhcGVfID09ICdjaXJjbGUnKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkQ2lyY2xlTGVnZW5kKG0sIG91dC5zaXplTGVnZW5kKVxyXG4gICAgICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUubm9kZSgpLmdldEJCb3goKS5oZWlnaHQgKyAyNVxyXG4gICAgICAgICAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbm8tZGF0YS1sZWdlbmQnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG4gICAgICAgICAgICAgICAgYnVpbGROb0RhdGFMZWdlbmQoY29udGFpbmVyLCBvdXQuc2l6ZUxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH0gZWxzZSBpZiAobS5wc1NoYXBlXyA9PSAnc3Bpa2UnKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkU3Bpa2VMZWdlbmQobSwgb3V0LnNpemVMZWdlbmQpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kZWZpbmUgZm9ybWF0IGZvciBsYWJlbHNcclxuICAgICAgICBsZXQgbGFiZWxGb3JtYXR0ZXIgPSBvdXQuc2l6ZUxlZ2VuZC5sYWJlbEZvcm1hdHRlciB8fCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3JcclxuICAgICAgICAvL2RyYXcgdGl0bGVcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQudGl0bGUpIHtcclxuICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kTm9kZVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQuc2l6ZUxlZ2VuZC50aXRsZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkb21haW4gPSBtLmNsYXNzaWZpZXJTaXplXy5kb21haW4oKVxyXG4gICAgICAgIGxldCBtYXhWYWwgPSBkb21haW5bMV0gLy9tYXhpbXVtIHZhbHVlIG9mIGRhdGFzZXQgKHVzZWQgZm9yIGZpcnN0IG9yIGxhc3Qgc3ltYm9sIGJ5IGRlZmF1bHQpXHJcblxyXG4gICAgICAgIC8vIGlmIHVzZXIgZGVmaW5lcyB2YWx1ZXMgZm9yIGxlZ2VuZCBtYW51YWxseVxyXG4gICAgICAgIGlmIChvdXQuc2l6ZUxlZ2VuZC52YWx1ZXMpIHtcclxuICAgICAgICAgICAgb3V0LnNpemVMZWdlbmQuY2VsbE5iID0gb3V0LnNpemVMZWdlbmQudmFsdWVzLmxlbmd0aFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3Nlczogc3ltYm9sICsgbGFiZWxcclxuXHJcbiAgICAgICAgLy8gZm9yIGN1c3RvbSBwYXRoc1xyXG4gICAgICAgIG0uY3VzdG9tU3ltYm9scyA9IHsgbm9kZUhlaWdodHM6IDAgfSAvLyBzYXZlIHNvbWUgY3VzdG9tIHNldHRpbmdzIGZvciBidWlsZEN1c3RvbVNWR0l0ZW1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvdXQuc2l6ZUxlZ2VuZC5jZWxsTmIgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgLy9kZWZpbmUgY2xhc3MgbnVtYmVyXHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBvdXQuYXNjZW5kaW5nID8gb3V0LnNpemVMZWdlbmQuY2VsbE5iIC0gaSArIDEgOiBpXHJcbiAgICAgICAgICAgIC8vZGVmaW5lIHJhdyB2YWx1ZVxyXG4gICAgICAgICAgICBsZXQgdmFsID0gb3V0LnNpemVMZWdlbmQudmFsdWVzID8gb3V0LnNpemVMZWdlbmQudmFsdWVzW2MgLSAxXSA6IG1heFZhbCAvIGNcclxuICAgICAgICAgICAgLy9jYWxjdWxhdGUgc2hhcGUgc2l6ZVxyXG4gICAgICAgICAgICBsZXQgc3ltYm9sU2l6ZSA9IG0uY2xhc3NpZmllclNpemVfKHZhbClcclxuXHJcbiAgICAgICAgICAgIGlmIChtLnBzU2hhcGVfID09ICdiYXInKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZEJhcnNJdGVtKG1hcCwgdmFsLCBzeW1ib2xTaXplLCBpLCBsYWJlbEZvcm1hdHRlcilcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtLnBzU2hhcGVfID09ICdjdXN0b20nIHx8IG0ucHNDdXN0b21TVkdfKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZEN1c3RvbVNWR0l0ZW0obWFwLCB2YWwsIHN5bWJvbFNpemUsIGksIGxhYmVsRm9ybWF0dGVyKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnVpbGREM1N5bWJvbEl0ZW0obWFwLCB2YWwsIHN5bWJvbFNpemUsIGksIGxhYmVsRm9ybWF0dGVyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGxldCB5ID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodFxyXG4gICAgICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB5ICs9IG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCArIDVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX3NpemVMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLW5vLWRhdGEtbGVnZW5kJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYClcclxuXHJcbiAgICAgICAgICAgIGJ1aWxkTm9EYXRhTGVnZW5kKGNvbnRhaW5lciwgb3V0LnNpemVMZWdlbmQubm9EYXRhVGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRTcGlrZUxlZ2VuZChtYXAsIHNpemVMZWdlbmRDb25maWcpIHtcclxuICAgICAgICBjb25zdCBzcGlrZSA9IChsZW5ndGgsIHdpZHRoID0gbWFwLnBzU3Bpa2VXaWR0aF8pID0+IGBNJHstd2lkdGggLyAyfSwwTDAsJHstbGVuZ3RofUwke3dpZHRoIC8gMn0sMGBcclxuXHJcbiAgICAgICAgbGV0IG1heFNpemUgPSBtYXAuY2xhc3NpZmllclNpemVfKG1hcC5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClbMV0pXHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB2YWx1ZXMgZm9yIHRoZSBsZWdlbmRcclxuICAgICAgICBsZXQgbGVnZW5kVmFsdWVzID0gb3V0LnNpemVMZWdlbmQudmFsdWVzIHx8IG1hcC5jbGFzc2lmaWVyU2l6ZV8udGlja3MoNCkuc2xpY2UoMSkgLy8gVXNlIHVzZXItZGVmaW5lZCB2YWx1ZXMgb3IgZGVmYXVsdCB0aWNrc1xyXG5cclxuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1sZWdlbmQtbGFiZWwnKSAvLyBBZGp1c3QgZm9udCBzaXplXHJcbiAgICAgICAgY29uc3QgbGFiZWxTcGFjaW5nID0gZm9udFNpemUgLSAyIC8vIEVuc3VyZSBsYWJlbHMgYXJlIGp1c3QgYmVsb3cgdGhlIHNwaWtlc1xyXG5cclxuICAgICAgICBjb25zdCBsZWdlbmQgPSBvdXQuX3NpemVMZWdlbmROb2RlXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tc3Bpa2UtbGVnZW5kJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZyArIDV9LDApYClcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBgJHtmb250U2l6ZX1weGApXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoKVxyXG4gICAgICAgICAgICAuZGF0YShsZWdlbmRWYWx1ZXMpIC8vIE5vdyB1c2VzIHVzZXItZGVmaW5lZCB2YWx1ZXMgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgLmpvaW4oJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQsIGkpID0+IGB0cmFuc2xhdGUoJHs0MCAqIGkgKyBvdXQuYm94UGFkZGluZ30sJHttYXhTaXplICsgNX0pYCkgLy8gSW5jcmVhc2Ugc3BhY2luZ1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgc3Bpa2VzXHJcbiAgICAgICAgbGVnZW5kXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIG1hcC5wc0ZpbGxfKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgbWFwLnBzRmlsbE9wYWNpdHlfKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgbWFwLnBzU3Ryb2tlXylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIG1hcC5wc1N0cm9rZVdpZHRoXylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAoZCkgPT4gc3Bpa2UobWFwLmNsYXNzaWZpZXJTaXplXyhkKSkpIC8vIENvcnJlY3RseSBtYXBzIHZhbHVlcyB0byBzcGlrZSBzaXplXHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBsYWJlbHMgZGlyZWN0bHkgYmVsb3cgZWFjaCBzcGlrZVxyXG4gICAgICAgIGxlZ2VuZFxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsIGxhYmVsU3BhY2luZykgLy8gRW5zdXJlIHRleHQgaXMgcmlnaHQgYmVsb3cgc3Bpa2VzXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiBtYXAuY2xhc3NpZmllclNpemVfLnRpY2tGb3JtYXQoNCwgJ3MnKShkKSlcclxuXHJcbiAgICAgICAgLy8g8J+UuSBBZGQgXCJObyBEYXRhXCIgaXRlbSB3aXRoIG1vcmUgc3BhY2luZ1xyXG4gICAgICAgIGlmIChvdXQuc2l6ZUxlZ2VuZC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgbGV0IGxhc3RMYWJlbFkgPSBtYXhTaXplICsgbGFiZWxTcGFjaW5nICsgZm9udFNpemUgKyA1IC8vIEFkanVzdCBwb3NpdGlvbiBiZWxvdyB0aGUgbGFiZWxzXHJcbiAgICAgICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbm8tZGF0YS1sZWdlbmQnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHtsYXN0TGFiZWxZfSlgKVxyXG4gICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5zaXplTGVnZW5kLm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vJ25vIGRhdGEnIGxlZ2VuZCBib3hcclxuICAgIGZ1bmN0aW9uIGJ1aWxkTm9EYXRhTGVnZW5kKGNvbnRhaW5lciwgbm9EYXRhVGV4dCkge1xyXG4gICAgICAgIGxldCBtID0gb3V0Lm1hcFxyXG5cclxuICAgICAgICAvL2FwcGVuZCBzeW1ib2wgJiBzdHlsZVxyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbS5ub0RhdGFGaWxsU3R5bGUoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LmNvbG9yTGVnZW5kID8gb3V0LmNvbG9yTGVnZW5kLnNoYXBlV2lkdGggOiBvdXQubm9EYXRhU2hhcGVXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5jb2xvckxlZ2VuZCA/IG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCA6IG91dC5ub0RhdGFTaGFwZUhlaWdodClcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsICduZCcpXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vJ25vIGRhdGEnIGxhYmVsXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuY29sb3JMZWdlbmQgPyBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aCArIG91dC5jb2xvckxlZ2VuZC5sYWJlbE9mZnNldC54IDogb3V0Lm5vRGF0YVNoYXBlV2lkdGggKyA1KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG91dC5jb2xvckxlZ2VuZCA/IG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCAvIDIgOiBvdXQubm9EYXRhU2hhcGVIZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAudGV4dChub0RhdGFUZXh0KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgdGhpcyB0byBlc3RhdCBsb2dpYyBvZiBtYWtpbmcgYWxsIG90aGVyIGNsYXNzZXMgdHJhbnNwYXJlbnQ/XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gb3V0Lmdlb18gPT09ICdXT1JMRCcgPyAnI2VtLXdvcmxkcmcnIDogJyNlbS1udXRzcmcnXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSBzZWxlY3RvciA9ICcjZW0tdXNlci1yZWdpb25zJyAvLyBmb3IgdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBjb25zdCBzZWwgPSBtYXAuc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoXCJbZWNsPSdcIiArIGVjbCArIFwiJ11cIilcclxuICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBtYXAuaG92ZXJDb2xvcigpKVxyXG4gICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gb3V0Lmdlb18gPT09ICdXT1JMRCcgPyAnI2VtLXdvcmxkcmcnIDogJyNlbS1udXRzcmcnXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSBzZWxlY3RvciA9ICcjZW0tdXNlci1yZWdpb25zJyAvLyBmb3IgdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBjb25zdCBzZWwgPSBtYXAuc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoXCJbZWNsPSdcIiArIGVjbCArIFwiJ11cIilcclxuICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGJ1aWxkcyBhIHNpemUgbGVnZW5kIGl0ZW0gZm9yIHByb3BvcnRpb25hbCBEMyBzaGFwZXMgKGUuZy4gc3F1YXJlLCB0cmlhbmdsZSwgc3RhcilcclxuICAgICAqIEBwYXJhbSB7Kn0gbSBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeW1ib2xTaXplIHRoZSBzaXplIG9mIHRoZSBzeW1ib2wgaXRlbVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZEQzU3ltYm9sSXRlbShtLCB2YWx1ZSwgc3ltYm9sU2l6ZSwgaW5kZXgsIGxhYmVsRm9ybWF0dGVyKSB7XHJcbiAgICAgICAgbGV0IHN5bWJvbEhlaWdodCA9IG91dC5tYXAucHNTaGFwZV8gPT0gJ3RyaWFuZ2xlJyB8fCBvdXQubWFwLnBzU2hhcGVfID09ICdkaWFtb25kJyA/IHN5bWJvbFNpemUgOiBzeW1ib2xTaXplIC8gMlxyXG4gICAgICAgIGlmIChvdXQuc2l6ZUxlZ2VuZC5fdG90YWxEM1N5bWJvbHNIZWlnaHQgPT0gMCkgb3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ICs9IHN5bWJvbEhlaWdodCArIG91dC5ib3hQYWRkaW5nIC8vYWRkIGZpcnN0IGl0ZW0gaGVpZ2h0IHRvIHlcclxuICAgICAgICBsZXQgbWF4U2l6ZSA9IG0uY2xhc3NpZmllclNpemVfKG0uY2xhc3NpZmllclNpemVfLmRvbWFpbigpWzFdKVxyXG4gICAgICAgIC8vIHggYW5kIHkgcG9zaXRpb24gb2YgaXRlbSBpbiBsZWdlbmRcclxuICAgICAgICBsZXQgeCA9IG1heFNpemVcclxuICAgICAgICBsZXQgeSA9XHJcbiAgICAgICAgICAgIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LnNpemVMZWdlbmQudGl0bGVQYWRkaW5nIDogMCkgK1xyXG4gICAgICAgICAgICBvdXQuc2l6ZUxlZ2VuZC5fdG90YWxEM1N5bWJvbHNIZWlnaHQgK1xyXG4gICAgICAgICAgICAob3V0LnNpemVMZWdlbmQuc2hhcGVQYWRkaW5nICogaW5kZXggLSAxKVxyXG5cclxuICAgICAgICBvdXQuc2l6ZUxlZ2VuZC5fdG90YWxEM1N5bWJvbHNIZWlnaHQgKz0gc3ltYm9sU2l6ZVxyXG5cclxuICAgICAgICAvL2NvbnRhaW5lciBmb3Igc3ltYm9sIGFuZCBsYWJlbFxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKS5hdHRyKCdjbGFzcycsICdlbS1zaXplLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy8gZHJhdyBEMyBzeW1ib2xcclxuICAgICAgICBsZXQgc2hhcGUgPSBnZXRTaGFwZSgpXHJcbiAgICAgICAgbGV0IGQgPSBzaGFwZS5zaXplKHN5bWJvbFNpemUgKiBzeW1ib2xTaXplKSgpXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLy8gLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBzZWNvbmRhcnkgc3RhdCB2YXJpYWJsZSBpcyB1c2VkIGZvciBzeW1ib2wgY29sb3VyaW5nLCB0aGVuIGRvbnQgY29sb3VyIHRoZSBsZWdlbmQgc3ltYm9scyB1c2luZyBwc0ZpbGwoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG0uY2xhc3NpZmllckNvbG9yXyA/IG91dC5zaXplTGVnZW5kLnNoYXBlRmlsbCA6IG0ucHNGaWxsX1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIG0ucHNGaWxsT3BhY2l0eSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIG91dC5zaXplTGVnZW5kLnNoYXBlU3Ryb2tlID8gb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgOiBtLnBzU3Ryb2tlKCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgbS5wc1N0cm9rZVdpZHRoKCkpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnh9LCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueX0pYFxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvL2xhYmVsIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IGxhYmVsWCA9IG1heFNpemUgLyAyICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueCArIG91dC5ib3hQYWRkaW5nXHJcblxyXG4gICAgICAgIC8vYXBwZW5kIGxhYmVsXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lci5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKS5hdHRyKCd4JywgbGFiZWxYKS5hdHRyKCd5JywgMCkudGV4dChsYWJlbEZvcm1hdHRlcih2YWx1ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gbVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHsqfSBzeW1ib2xTaXplXHJcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4XHJcbiAgICAgKiBAcGFyYW0geyp9IGxhYmVsRm9ybWF0dGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ3VzdG9tU1ZHSXRlbShtLCB2YWx1ZSwgc3ltYm9sU2l6ZSwgaW5kZXgsIGxhYmVsRm9ybWF0dGVyKSB7XHJcbiAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZyAvL3NldCBYIG9mZnNldFxyXG4gICAgICAgIGxldCB5XHJcblxyXG4gICAgICAgIC8vZmlyc3QgaXRlbVxyXG4gICAgICAgIGlmICghbS5jdXN0b21TeW1ib2xzLnByZXZTeW1iKSB7XHJcbiAgICAgICAgICAgIHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LnNpemVMZWdlbmQudGl0bGVQYWRkaW5nIDogMCkgKyAyMFxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMuaW5pdGlhbFRyYW5zbGF0ZVkgPSB5XHJcbiAgICAgICAgICAgIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGUgPSBzeW1ib2xTaXplXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2ZvbGxvd2luZyBpdGVtc1xyXG4gICAgICAgIGlmIChtLmN1c3RvbVN5bWJvbHMucHJldlN5bWIpIHtcclxuICAgICAgICAgICAgbGV0IHByZXZOb2RlID0gbS5jdXN0b21TeW1ib2xzLnByZXZTeW1iLm5vZGUoKVxyXG4gICAgICAgICAgICBsZXQgYmJveCA9IHByZXZOb2RlLmdldEJCb3goKVxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMubm9kZUhlaWdodHMgPSBtLmN1c3RvbVN5bWJvbHMubm9kZUhlaWdodHMgKyBiYm94LmhlaWdodCAqIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGVcclxuICAgICAgICAgICAgeSA9IG0uY3VzdG9tU3ltYm9scy5pbml0aWFsVHJhbnNsYXRlWSArIG0uY3VzdG9tU3ltYm9scy5ub2RlSGVpZ2h0cyArIG91dC5zaXplTGVnZW5kLnNoYXBlUGFkZGluZyAqIChpbmRleCAtIDEpXHJcbiAgICAgICAgICAgIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGUgPSBzeW1ib2xTaXplXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnRhaW5lciBmb3Igc3ltYm9sIGFuZCBsYWJlbFxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKS5hdHRyKCdjbGFzcycsICdlbS1zaXplLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy8gZHJhdyBzdGFuZGFyZCBzeW1ib2xcclxuICAgICAgICBtLmN1c3RvbVN5bWJvbHMucHJldlN5bWIgPSBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtc3ltYm9sJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHNlY29uZGFyeSBzdGF0IHZhcmlhYmxlIGlzIHVzZWQgZm9yIHN5bWJvbCBjb2xvdXJpbmcsIHRoZW4gZG9udCBjb2xvdXIgdGhlIGxlZ2VuZCBzeW1ib2xzIHVzaW5nIHBzRmlsbCgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5jbGFzc2lmaWVyQ29sb3JfID8gb3V0LnNpemVMZWdlbmQuc2hhcGVGaWxsIDogbS5wc0ZpbGxfXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgbS5wc0ZpbGxPcGFjaXR5KCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA6IG0ucHNTdHJva2UoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBtLnBzU3Ryb2tlV2lkdGgoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuaHRtbChvdXQubWFwLnBzQ3VzdG9tU1ZHXylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLnBzQ3VzdG9tU1ZHXykgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KSBzY2FsZSgke3N5bWJvbFNpemV9KWBcclxuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KWBcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9sYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBsYWJlbFggPSB4ICsgbS5jbGFzc2lmaWVyU2l6ZV8obS5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClbMF0pICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueFxyXG4gICAgICAgIGxldCBsYWJlbFkgPSBvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55IC8gMiArIDEgLy95ICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueVxyXG5cclxuICAgICAgICAvL2FwcGVuZCBsYWJlbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXIuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJykuYXR0cigneCcsIGxhYmVsWCkuYXR0cigneScsIGxhYmVsWSkudGV4dChsYWJlbEZvcm1hdHRlcih2YWx1ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gbVxyXG4gICAgICogQHBhcmFtIHsqfSBzeW1ib2xTaXplXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQmFyc0l0ZW0obSwgdmFsdWUsIHN5bWJvbFNpemUsIGluZGV4LCBsYWJlbEZvcm1hdHRlcikge1xyXG4gICAgICAgIC8vIGZvciB2ZXJ0aWNhbCBiYXJzIHdlIGRvbnQgdXNlIGEgZHluYW1pYyBYIG9mZnNldCBiZWNhdXNlIGFsbCBiYXJzIGhhdmUgdGhlIHNhbWUgd2lkdGhcclxuICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgLy93ZSBhbHNvIGRvbnQgbmVlZCB0aGUgeSBvZmZzZXRcclxuICAgICAgICBsZXQgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC5zaXplTGVnZW5kLnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuc2l6ZUxlZ2VuZC50aXRsZVBhZGRpbmcgOiAwKSArIG91dC5zaXplTGVnZW5kLl90b3RhbEJhcnNIZWlnaHQgKyAxMFxyXG5cclxuICAgICAgICBvdXQuc2l6ZUxlZ2VuZC5fdG90YWxCYXJzSGVpZ2h0ICs9IHN5bWJvbFNpemUgKyAxMFxyXG5cclxuICAgICAgICAvL3NldCBzaGFwZSBzaXplIGFuZCBkZWZpbmUgJ2QnIGF0dHJpYnV0ZVxyXG4gICAgICAgIGxldCBzaGFwZSA9IGdldFNoYXBlKClcclxuICAgICAgICBsZXQgZCA9IHNoYXBlLnNpemUoc3ltYm9sU2l6ZSAqIHN5bWJvbFNpemUpKClcclxuXHJcbiAgICAgICAgLy9jb250YWluZXIgZm9yIHN5bWJvbCBhbmQgbGFiZWxcclxuICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgIC8vIGRyYXcgYmFyIHN5bWJvbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBzZWNvbmRhcnkgc3RhdCB2YXJpYWJsZSBpcyB1c2VkIGZvciBzeW1ib2wgY29sb3VyaW5nLCB0aGVuIGRvbnQgY29sb3VyIHRoZSBsZWdlbmQgc3ltYm9scyB1c2luZyBwc0ZpbGwoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG0uY2xhc3NpZmllckNvbG9yXyA/IG91dC5zaXplTGVnZW5kLnNoYXBlRmlsbCA6IG0ucHNGaWxsX1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIG0ucHNGaWxsT3BhY2l0eSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIG91dC5zaXplTGVnZW5kLnNoYXBlU3Ryb2tlID8gb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgOiBtLnBzU3Ryb2tlKCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgbS5wc1N0cm9rZVdpZHRoKCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC41KVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYXAucHNDdXN0b21TVkdfKSByZXR1cm4gYHRyYW5zbGF0ZSgke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnh9LCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueX0pIHNjYWxlKCR7c3ltYm9sU2l6ZX0pYFxyXG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gYHRyYW5zbGF0ZSgke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnh9LCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueX0pYFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIC8vbGFiZWwgcG9zaXRpb25cclxuICAgICAgICBsZXQgbGFiZWxYID0geCArIG91dC5tYXAucHNCYXJXaWR0aF8gKyBvdXQuc2l6ZUxlZ2VuZC5sYWJlbE9mZnNldC54XHJcbiAgICAgICAgbGV0IGxhYmVsWSA9IHN5bWJvbFNpemUgLyAyICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueVxyXG5cclxuICAgICAgICAvL2FwcGVuZCBsYWJlbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXIuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJykuYXR0cigneCcsIGxhYmVsWCkuYXR0cigneScsIGxhYmVsWSkudGV4dChsYWJlbEZvcm1hdHRlcih2YWx1ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYnVpbGRzIGEgbmVzdGVkIGNpcmNsZSBsZWdlbmQgZm9yIHByb3BvcnRpb25hbCBjaXJjbGVzXHJcbiAgICAgKiBAcGFyYW0geyp9IG0gbWFwXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ2lyY2xlTGVnZW5kKG0pIHtcclxuICAgICAgICAvL2Fzc2lnbiBkZWZhdWx0IGNpcmNsZSByYWRpdXNlcyBpZiBub25lIHNwZWNpZmllZCBieSB1c2VyXHJcbiAgICAgICAgbGV0IGRvbWFpbiA9IG0uY2xhc3NpZmllclNpemVfLmRvbWFpbigpXHJcbiAgICAgICAgaWYgKCFvdXQuc2l6ZUxlZ2VuZC52YWx1ZXMpIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBsZWdlbmQgdmFsdWVzXHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZFZhbHVlcyA9IFtNYXRoLmZsb29yKGRvbWFpblsxXSksIE1hdGguZmxvb3IoZG9tYWluWzFdIC8gMiksIE1hdGguZmxvb3IoZG9tYWluWzBdKV1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1c2VyIGRlZmluZWQgbGVnZW5kIHZhbHVlc1xyXG4gICAgICAgICAgICBvdXQuX3NpemVMZWdlbmRWYWx1ZXMgPSBvdXQuc2l6ZUxlZ2VuZC52YWx1ZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgIGlmICghb3V0LnNpemVMZWdlbmQudGl0bGUgJiYgb3V0LnRpdGxlKSBvdXQuc2l6ZUxlZ2VuZC50aXRsZSA9IG91dC50aXRsZSAvL2lmIHVuc3BlY2lmaWVkLCBzZXQgc2l6ZSBsZWdlbmQgdGl0bGUgYXMgcm9vdCBsZWdlbmQgdGl0bGVcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQudGl0bGUpIHtcclxuICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kTm9kZVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5ib3hQYWRkaW5nICsgb3V0LnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQuc2l6ZUxlZ2VuZC50aXRsZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtYXhSYWRpdXMgPSBtLmNsYXNzaWZpZXJTaXplXyhtYXgob3V0Ll9zaXplTGVnZW5kVmFsdWVzKSkgLy9tYXhpbXVtIGNpcmNsZSByYWRpdXMgdG8gYmUgc2hvd24gaW4gbGVnZW5kXHJcbiAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZyArIG1heFJhZGl1c1xyXG4gICAgICAgIGxldCB5ID0gb3V0LmJveFBhZGRpbmcgKyBtYXhSYWRpdXMgKiAyICsgKG91dC5zaXplTGVnZW5kLnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuc2l6ZUxlZ2VuZC50aXRsZVBhZGRpbmcgOiAwKSArIDIwXHJcblxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjaXJjbGUtbGVnZW5kJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3JpZ2h0JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgIC5kYXRhKG91dC5fc2l6ZUxlZ2VuZFZhbHVlcy5maWx0ZXIoKGQpID0+IG0uY2xhc3NpZmllclNpemVfKGQpKSkgLy8gRmlsdGVyIGRhdGEgYmVmb3JlIGJpbmRpbmdcclxuICAgICAgICAgICAgLmpvaW4oJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0nKVxyXG5cclxuICAgICAgICAvL2NpcmNsZXNcclxuICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtY2lyY2xlJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgKGQpID0+IC1tLmNsYXNzaWZpZXJTaXplXyhkKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBtLmNsYXNzaWZpZXJTaXplXylcclxuXHJcbiAgICAgICAgLy9sYWJlbHNcclxuICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSAtMSAtIDIgKiBtLmNsYXNzaWZpZXJTaXplXyhkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXhSYWRpdXMgKyA1KVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoJ2VuJykucmVwbGFjZSgvLC9naSwgJyAnKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIC8vbGluZSBwb2ludGluZyB0byB0b3Agb2YgY29ycmVzcG9uZGluZyBjaXJjbGU6XHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JywgMilcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnZ3JleScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IC0xIC0gMiAqIG0uY2xhc3NpZmllclNpemVfKGQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCBtYXhSYWRpdXMgKyA1KVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSAtMSAtIDIgKiBtLmNsYXNzaWZpZXJTaXplXyhkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIGEgbGVnZW5kIGlsbHVzdHJhdGluZyB0aGUgc3RhdGlzdGljYWwgdmFsdWVzIG9mIGRpZmZlcmVudCBzeW1ib2wgY29sb3Vyc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gbSBtYXBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRDb2xvckxlZ2VuZChtKSB7XHJcbiAgICAgICAgLy9kZWZpbmUgZm9ybWF0IGZvciBsYWJlbHNcclxuICAgICAgICBsZXQgZiA9IG91dC5jb2xvckxlZ2VuZC5sYWJlbEZvcm1hdHRlciB8fCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3JcclxuICAgICAgICBjb25zdCBzdmdNYXAgPSBtLnN2ZygpXHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5fY29sb3JMZWdlbmROb2RlXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuY29sb3JMZWdlbmQubWFyZ2luVG9wKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LmNvbG9yTGVnZW5kLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geCBwb3NpdGlvbiBvZiBjb2xvciBsZWdlbmQgY2VsbHNcclxuICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcblxyXG4gICAgICAgIC8vZHJhdyBsZWdlbmQgZWxlbWVudHMgZm9yIGNsYXNzZXM6IHJlY3RhbmdsZSArIGxhYmVsXHJcbiAgICAgICAgbGV0IG51bWJlck9mQ2xhc3NlcyA9IG0ucHNDbGFzc2VzX1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2xhc3NlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmNvbG9yTGVnZW5kLnRpdGxlUGFkZGluZyArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3AgKyBpICogb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0IC8vIGFjY291bnQgZm9yIHRpdGxlICsgbWFyZ2luXHJcblxyXG4gICAgICAgICAgICAvL3RoZSBjbGFzcyBudW1iZXIsIGRlcGVuZGluZyBvbiBvcmRlclxyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBvdXQuYXNjZW5kaW5nID8gaSA6IG51bWJlck9mQ2xhc3NlcyAtIGkgLSAxXHJcblxyXG4gICAgICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fY29sb3JMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgICAgIC8vYXBwZW5kIHN5bWJvbCAmIHN0eWxlXHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG0ucHNDbGFzc1RvRmlsbFN0eWxlKCkoZWNsLCBudW1iZXJPZkNsYXNzZXMpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LmNvbG9yTGVnZW5kLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vc2VwYXJhdGlvbiBsaW5lXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtc2VwYXJhdG9yJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgMCArIG91dC5jb2xvckxlZ2VuZC5zZXBMaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIDApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aWNrIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aWNrJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG91dC5jb2xvckxlZ2VuZC5zZXBMaW5lTGVuZ3RoICsgb3V0LmNvbG9yTGVnZW5kLnRpY2tMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgMClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgICAgICBpZiAoaSA8IG51bWJlck9mQ2xhc3NlcyAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5jb2xvckxlZ2VuZC5zZXBMaW5lTGVuZ3RoICsgb3V0LmNvbG9yTGVnZW5kLnRpY2tMZW5ndGggKyBvdXQuY29sb3JMZWdlbmQubGFiZWxPZmZzZXQueClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGYobS5jbGFzc2lmaWVyQ29sb3JfLmludmVydEV4dGVudChvdXQuYXNjZW5kaW5nID8gZWNsICsgMSA6IGVjbCAtIDEpW291dC5hc2NlbmRpbmcgPyAwIDogMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGxldCB5ID0gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuY29sb3JMZWdlbmQubWFyZ2luVG9wICsgbnVtYmVyT2ZDbGFzc2VzICogb3V0LmNvbG9yTGVnZW5kLnNoYXBlSGVpZ2h0ICsgMjAgLy8gYWRkIDIwIHRvIHNlcGFyYXRlIGl0IGZyb20gdGhlIHJlc3RcclxuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IG91dC5fY29sb3JMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLW5vLWRhdGEtbGVnZW5kJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYClcclxuXHJcbiAgICAgICAgICAgIGJ1aWxkTm9EYXRhTGVnZW5kKGNvbnRhaW5lciwgb3V0LmNvbG9yTGVnZW5kLm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIHJldHVybnMgdGhlIGQzLnN5bWJvbCBvYmplY3QgY2hvc2VuIGJ5IHRoZSB1c2VyXHJcbiAgICAgKiBAcmV0dXJuIHtkMy5zaGFwZSB8fCBTVkd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNoYXBlKCkge1xyXG4gICAgICAgIGxldCBzaGFwZVxyXG4gICAgICAgIGlmIChvdXQubWFwLnBzQ3VzdG9tU1ZHXykge1xyXG4gICAgICAgICAgICBzaGFwZSA9IG91dC5tYXAucHNDdXN0b21TVkdfXHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXQubWFwLnBzQ3VzdG9tU2hhcGVfKSB7XHJcbiAgICAgICAgICAgIHNoYXBlID0gb3V0Lm1hcC5wc0N1c3RvbVNoYXBlX1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0Lm1hcC5wc1NoYXBlXyA9PSAnYmFyJykge1xyXG4gICAgICAgICAgICAvL2ZvciByZWN0YW5nbGVzLCB3ZSB1c2UgYSBjdXN0b20gZDMgc3ltYm9sXHJcbiAgICAgICAgICAgIGxldCBkcmF3UmVjdGFuZ2xlID0gKGNvbnRleHQsIHNpemUpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLnNxcnQoc2l6ZSlcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBoZWlnaHQpXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhvdXQubWFwLnBzQmFyV2lkdGhfLCBoZWlnaHQpXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhvdXQubWFwLnBzQmFyV2lkdGhfLCAwKVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgMClcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzaGFwZSA9IHN5bWJvbCgpLnR5cGUoeyBkcmF3OiBkcmF3UmVjdGFuZ2xlIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHN5bWJvbFR5cGUgPSBzeW1ib2xzTGlicmFyeVtvdXQubWFwLnBzU2hhcGVfXSB8fCBzeW1ib2xzTGlicmFyeVsnY2lyY2xlJ11cclxuICAgICAgICAgICAgc2hhcGUgPSBzeW1ib2woKS50eXBlKHN5bWJvbFR5cGUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaGFwZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpZ2hsaWdodCBzZWxlY3RlZCByZWdpb25zIG9uIG1vdXNlb3ZlclxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGVjbCkge1xyXG4gICAgICAgIC8vZm9yIHBzLCB0aGUgc3ltYm9scyBhcmUgdGhlIGNoaWxkcmVuIG9mIGVhY2ggZW0tcHJvcC1zeW1ib2xzIGVsZW1lbnRcclxuICAgICAgICBjb25zdCBhbGxTeW1ib2xzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJykuc2VsZWN0QWxsKCdbZWNsXScpXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgc3ltYm9scyB0byB3aGl0ZVxyXG4gICAgICAgIGFsbFN5bWJvbHMuZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gc2VsZWN0KHRoaXMuY2hpbGROb2Rlc1swXSlcclxuICAgICAgICAgICAgc3ltYm9sLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFN5bWJvbHMgPSBhbGxTeW1ib2xzLmZpbHRlcihcIltlY2w9J1wiICsgZWNsICsgXCInXVwiKVxyXG4gICAgICAgIHNlbGVjdGVkU3ltYm9scy5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICBzeW1ib2wuc3R5bGUoJ2ZpbGwnLCBzeW1ib2wuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgcmVnaW9ucyB0byB0aGVpciBvcmlnaW5hbCBjb2xvcnMgb24gbW91c2VvdXRcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICAvL2ZvciBwcywgdGhlIHN5bWJvbHMgYXJlIHRoZSBjaGlsZHJlbiBvZiBlYWNoIGVtLXByb3Atc3ltYm9scyBlbGVtZW50XHJcbiAgICAgICAgY29uc3QgYWxsU3ltYm9scyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxTeW1ib2xzLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IHNlbGVjdCh0aGlzLmNoaWxkTm9kZXNbMF0pXHJcbiAgICAgICAgICAgIHN5bWJvbC5zdHlsZSgnZmlsbCcsIHN5bWJvbC5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHJlZ2lvbnNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4vbGVnZW5kJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBjaG9yb3BsZXRoIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IGZvciB0aGUgbWFwXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICAvL3RoZSB3aWR0aCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlV2lkdGggPSAyNVxyXG4gICAgLy90aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVIZWlnaHQgPSAyMFxyXG4gICAgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVQYWRkaW5nID0gNVxyXG4gICAgLy90aGUgZm9udCBzaXplIG9mIHRoZSBsZWdlbmQgbGFiZWxcclxuICAgIG91dC5sYWJlbEZvbnRTaXplID0gMTJcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxlZ2VuZCBib3ggZWxlbWVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBsYWJlbFxyXG4gICAgb3V0LmxhYmVsT2Zmc2V0ID0gNVxyXG4gICAgLy9zaG93IG5vIGRhdGFcclxuICAgIG91dC5ub0RhdGEgPSB0cnVlXHJcbiAgICAvL25vIGRhdGEgbGFiZWwgdGV4dFxyXG4gICAgb3V0Lm5vRGF0YVRleHQgPSAnTm8gZGF0YSdcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKSBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGNvbnN0IG0gPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3Qgc3ZnTWFwID0gbS5zdmcoKVxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGxnZy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuXHJcbiAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgaWYgKG91dC50aXRsZSkge1xyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWduZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICBsZXQgaSA9IDBcclxuICAgICAgICBjb25zdCBzY3MgPSBtLmNhdENvbG9ycygpXHJcbiAgICAgICAgZm9yIChsZXQgY29kZSBpbiBzY3MpIHtcclxuICAgICAgICAgICAgLy90aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBlbGVtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgKyBpICogKG91dC5zaGFwZUhlaWdodCArIG91dC5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAvL3RoZSBjb2xvclxyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSBtLmNhdENvbG9ycygpW2NvZGVdIHx8ICdsaWdodGdyYXknXHJcblxyXG4gICAgICAgICAgICAvL3JlY3RhbmdsZVxyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgc2NzW2NvZGVdKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC41KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnJhaXNlKClcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIG91dC5zaGFwZVdpZHRoICsgb3V0LmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgLnRleHQobS5jYXRMYWJlbHMoKVtjb2RlXSB8fCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdHRlcm4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwicmVjdFtjb2RlPSdcIiArIGNvZGUgKyBcIiddXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG0uaG92ZXJDb2xvcigpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gbS5jYXRDb2xvcnMoKVtjb2RlXSB8fCAnbGlnaHRncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Z01hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInJlY3RbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjb2wpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgaSsrXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLydubyBkYXRhJyBsZWdlbmQgYm94XHJcbiAgICAgICAgaWYgKG91dC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArIGkgKiAob3V0LnNoYXBlSGVpZ2h0ICsgb3V0LnNoYXBlUGFkZGluZylcclxuXHJcbiAgICAgICAgICAgIC8vcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnTWFwLnNlbGVjdCgnI2VtLW51dHNyZycpLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKS5zdHlsZSgnZmlsbCcsIG0uaG92ZXJDb2xvcigpKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIG0uaG92ZXJDb2xvcigpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc3ZnTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyNlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiW25kPSduZCddXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm5vRGF0YUZpbGxTdHlsZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgbS5ub0RhdGFGaWxsU3R5bGUoKSlcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLydubyBkYXRhJyBsYWJlbFxyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIG91dC5zaGFwZVdpZHRoICsgb3V0LmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdmdNYXAuc2VsZWN0KCcjZW0tbnV0c3JnJykuc2VsZWN0QWxsKFwiW25kPSduZCddXCIpLnN0eWxlKCdmaWxsJywgbS5ob3ZlckNvbG9yKCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzdmdNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnI2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ubm9EYXRhRmlsbFN0eWxlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICBvdXQuc2V0Qm94RGltZW5zaW9uKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgY29kZSkge1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ3BhdHRlcm4nKS5zZWxlY3RBbGwoJ3JlY3QnKTtcclxuICAgIFxyXG4gICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgY29sb3JzIGlmIG5vdCBhbHJlYWR5IHN0b3JlZFxyXG4gICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoIWVsLmF0dHIoJ2RhdGEtb3JpZ2luYWwtZmlsbCcpKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5hdHRyKCdkYXRhLW9yaWdpbmFsLWZpbGwnLCBlbC5zdHlsZSgnZmlsbCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbC5zdHlsZSgnZmlsbCcsICd3aGl0ZScpOyAvLyBTZXQgYWxsIHJlZ2lvbnMgdG8gd2hpdGVcclxuICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgIC8vIEhpZ2hsaWdodCBvbmx5IHRoZSBzZWxlY3RlZCByZWdpb25zIGJ5IHJlc3RvcmluZyB0aGVpciBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChcInBhdHRlcm5cIikuc2VsZWN0QWxsKFwicmVjdFtjb2RlPSdcIiArIGNvZGUgKyBcIiddXCIpO1xyXG4gICAgICAgIHNlbGVjdGVkUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSBzZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlKCdmaWxsJywgZWwuYXR0cignZGF0YS1vcmlnaW5hbC1maWxsJykpOyAvLyBSZXN0b3JlIG9yaWdpbmFsIGZpbGxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCkge1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ3BhdHRlcm4nKS5zZWxlY3RBbGwoJ3JlY3QnKTtcclxuICAgIFxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCByZWdpb24ncyBvcmlnaW5hbCBjb2xvciBmcm9tIHRoZSBzdG9yZWQgYXR0cmlidXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSBzZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRmlsbCA9IGVsLmF0dHIoJ2RhdGEtb3JpZ2luYWwtZmlsbCcpO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZSgnZmlsbCcsIG9yaWdpbmFsRmlsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIEEgZXVyb3N0YXQtbWFwIGxlZ2VuZC4gVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgLy9idWlsZCBsZWdlbmQgb2JqZWN0XHJcbiAgICBjb25zdCBvdXQgPSB7fVxyXG5cclxuICAgIC8vbGluayBtYXAgdG8gbGVnZW5kXHJcbiAgICBvdXQubWFwID0gbWFwXHJcblxyXG4gICAgLy90aGUgU1ZHIHdoZXJlIHRvIG1ha2UgdGhlIGxlZ2VuZFxyXG4gICAgb3V0LnN2Z0lkID0gJ2xlZ2VuZF8nICsgTWF0aC5yb3VuZCgxMGUxNSAqIE1hdGgucmFuZG9tKCkpXHJcbiAgICBvdXQuc3ZnID0gdW5kZWZpbmVkXHJcbiAgICBvdXQubGdnID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy90aGUgbGVnZW5kIGVsZW1lbnQgcG9zaXRpb24sIGluIGNhc2UgaXQgaXMgZW1iZWRlZCB3aXRoaW4gdGhlIG1hcCBTVkdcclxuICAgIG91dC54ID0gdW5kZWZpbmVkXHJcbiAgICBvdXQueSA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vdGhlIGxlZ2VuZCBib3hcclxuICAgIG91dC5ib3hQYWRkaW5nID0gN1xyXG4gICAgb3V0LmJveE9wYWNpdHkgPSAwLjdcclxuXHJcbiAgICAvL2xlZ2VuZCB0aXRsZVxyXG4gICAgb3V0LnRpdGxlID0gJydcclxuICAgIC8vIHdlIG5vdyB1c2UgQ1NTIGluc3RlYWQgb2YgaW5saW5lIHN0eWxlc1xyXG4gICAgb3V0LnRpdGxlRm9udFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgIC8vIHdlIG5vdyB1c2UgQ1NTIGluc3RlYWQgb2YgaW5saW5lIHN0eWxlc1xyXG4gICAgb3V0LmxhYmVsRm9udFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLWxhYmVsJylcclxuXHJcbiAgICAvKiogQnVpbGQgbGVnZW5kLiAqL1xyXG4gICAgb3V0LmJ1aWxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vc2V0IFNWRyBlbGVtZW50IGFuZCBhZGQgbWFpbiBkcmF3aW5nIGdyb3VwXHJcbiAgICAgICAgb3V0LnN2ZyA9IHNlbGVjdCgnIycgKyBvdXQuc3ZnSWQpXHJcbiAgICAgICAgLy8gY2xlYXIgcHJldmlvdXMgbGVnZW5kKHMpXHJcbiAgICAgICAgb3V0LnN2Zy5zZWxlY3RBbGwoJyNlbS1sZWdlbmQtJyArIG91dC5zdmdJZCkucmVtb3ZlKClcclxuICAgICAgICAvLyBhcHBlbmQgbmV3IGxlZ2VuZCBncm91cFxyXG4gICAgICAgIG91dC5sZ2cgPSBvdXQuc3ZnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tbGVnZW5kLScgKyBvdXQuc3ZnSWQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBsZWdlbmQgZWxlbWVudC5cclxuICAgICAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgbWV0aG9kIHRvIGJlIGRlZmluZWQgZm9yIGVhY2ggc3BlY2lmaWMgbGVnZW5kLlxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdMZWdlbmQgdXBkYXRlIGZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZCcpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIG91dC51cGRhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2dcclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL2NoZWNrIGlmIHByb3ZpZGVkIGV4dGVybmFsIHN2Z0lkIGhhcyBjaGFuZ2VkXHJcbiAgICAgICAgY29uc3QgbGVnZW5kU1ZHID0gb3V0LnN2Z1xyXG4gICAgICAgIGlmIChsZWdlbmRTVkcuYXR0cignaWQnKSAhPT0gbWFwLmxlZ2VuZF8uc3ZnSWQpIHtcclxuICAgICAgICAgICAgb3V0LmJ1aWxkKCkgLy8gc2V0cyBuZXcgc3ZnIGFuZCBsZ2dcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LnVwZGF0ZUNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgLy8gVXBkYXRlIGxlZ2VuZCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmIChtYXAubGVnZW5kXykge1xyXG4gICAgICAgICAgICBkZWVwTWVyZ2VFeGlzdGluZ0tleXMob3V0LCBtYXAubGVnZW5kXylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHNcclxuICAgICAgICAvLyAvLyB1cGRhdGUgbGVnZW5kIHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgLy8gaWYgKG0ubGVnZW5kXylcclxuICAgICAgICAvLyAgICAgZm9yIChsZXQga2V5IGluIG0ubGVnZW5kXykge1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSA9PSAnY29sb3JMZWdlbmQnIHx8IGtleSA9PSAnc2l6ZUxlZ2VuZCcpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBmb3IgKGxldCBwIGluIG91dFtrZXldKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgbS5sZWdlbmRfXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGlmIChtLmxlZ2VuZF9ba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBvdXRba2V5XVtwXSA9IG0ubGVnZW5kX1trZXldW3BdXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIG91dFtrZXldID0gbS5sZWdlbmRfW2tleV1cclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vSXQgcGVyZm9ybXMgYSBzaGFsbG93IGNvcHkg4oCUIG5lc3RlZCBvYmplY3RzIHdpbGwgYmUgY29waWVkIGJ5IHJlZmVyZW5jZSwgbm90IGR1cGxpY2F0ZWQuXHJcbiAgICAvL0l0IG1vZGlmaWVzIHRoZSB0YXJnZXQgb2JqZWN0IChvdXQpIGluIHBsYWNlLlxyXG4gICAgLy9Vc2VmdWwgZm9yIG1lcmdpbmcgb2JqZWN0cyBvciBleHRlbmRpbmcgZXhpc3Rpbmcgb25lcy5cclxuICAgIGZ1bmN0aW9uIGRlZXBNZXJnZUV4aXN0aW5nS2V5cyh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyA9IHt9LCBzZWVuID0gbmV3IFdlYWtTZXQoKSwgZGVwdGggPSAwKSB7XHJcbiAgICAgICAgY29uc3QgTUFYX0RFUFRIID0gb3B0aW9ucy5tYXhEZXB0aCB8fCAxMDBcclxuXHJcbiAgICAgICAgaWYgKHNlZW4uaGFzKHRhcmdldCkpIHJldHVybiB0YXJnZXRcclxuICAgICAgICBzZWVuLmFkZCh0YXJnZXQpXHJcblxyXG4gICAgICAgIGlmIChkZXB0aCA+IE1BWF9ERVBUSCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYE1heCByZWN1cnNpb24gZGVwdGggKCR7TUFYX0RFUFRIfSkgcmVhY2hlZC5gKVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWYWwgPSBzb3VyY2Vba2V5XVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZnVuY3Rpb25zOiBvdmVyd3JpdGUgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlVmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCBwbGFpbiBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlVmFsKSAmJiBpc1BsYWluT2JqZWN0KHRhcmdldFZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWVwTWVyZ2VFeGlzdGluZ0tleXModGFyZ2V0VmFsLCBzb3VyY2VWYWwsIG9wdGlvbnMsIHNlZW4sIGRlcHRoICsgMSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFycmF5czogb3ZlcndyaXRlIChvciBtZXJnZSBpZiBvcHRpb24gc2V0KVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVZhbCkgJiYgQXJyYXkuaXNBcnJheSh0YXJnZXRWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvcHRpb25zLm1lcmdlQXJyYXlzID8gWy4uLm5ldyBTZXQoWy4uLnRhcmdldFZhbCwgLi4uc291cmNlVmFsXSldIDogWy4uLnNvdXJjZVZhbF1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIERhdGVzXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVZhbCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBEYXRlKHNvdXJjZVZhbC5nZXRUaW1lKCkpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBSZWdFeHBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlVmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgUmVnRXhwKHNvdXJjZVZhbClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIE1hcCBhbmQgU2V0XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVZhbCBpbnN0YW5jZW9mIE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbmV3IE1hcChzb3VyY2VWYWwpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVZhbCBpbnN0YW5jZW9mIFNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbmV3IFNldChzb3VyY2VWYWwpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSBwcmltaXRpdmVzIGFuZCBvdGhlciB0eXBlc1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVZhbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGVscGVyIHRvIGNoZWNrIGZvciBwbGFpbiBvYmplY3RzXHJcbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94ICovXHJcbiAgICBvdXQubWFrZUJhY2tncm91bmRCb3ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LmxnZy5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdpZCcsICdsZWdlbmRCUicpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1iYWNrZ3JvdW5kJykuc3R5bGUoJ29wYWNpdHknLCBvdXQuYm94T3BhY2l0eSlcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2V0IGxlZ2VuZCBib3ggZGltZW5zaW9ucywgZW5zdXJpbmcgaXQgaGFzIHN1aXRhYmxlIGRpbWVuc2lvbnMgdG8gZml0IHRvIGFsbCBsZWdlbmQgZ3JhcGhpYyBlbGVtZW50cyAqL1xyXG4gICAgb3V0LnNldEJveERpbWVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3V0LmxnZy5ub2RlKCkpIHtcclxuICAgICAgICAgICAgLy9nZXQgbGVnZW5kIGVsZW1lbnRzIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICBjb25zdCBiYiA9IG91dC5sZ2cubm9kZSgpLmdldEJCb3goeyBzdHJva2U6IHRydWUgfSlcclxuICAgICAgICAgICAgLy9hcHBseSB0byBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgY29uc3QgcCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgIG91dC5zdmdcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyNsZWdlbmRCUicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGJiLnggLSBwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBiYi55IC0gcClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGJiLndpZHRoICsgMiAqIHApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYmIuaGVpZ2h0ICsgMiAqIHApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QsIHN0eWxlIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBzY2FsZU9yZGluYWwgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgc2NoZW1lU2V0MyB9IGZyb20gJ2QzLXNjYWxlLWNocm9tYXRpYydcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBDYXRlZ29yaWNhbExlZ2VuZCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kLWNhdGVnb3JpY2FsJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY2F0ZWdvcmljYWwgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIGZhbHNlLCAnY3QnKVxyXG5cclxuICAgIC8qKiBGaWxsIHN0eWxlIGZvciBlYWNoIGNhdGVnb3J5L2NsYXNzLiBFeC46IHsgdXJiOiBcIiNmZGI0NjJcIiwgaW50OiBcIiNmZmZmYjNcIiwgcnVyOiBcIiNjY2ViYzVcIiB9ICovXHJcbiAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUZXh0IGxhYmVsIGZvciBlYWNoIGNhdGVnb3J5L2NsYXNzLiBFeC46IHsgXCJ1cmJcIjogXCJVcmJhblwiLCBcImludFwiOiBcIkludGVybWVkaWF0ZVwiLCBcInJ1clwiOiBcIlJ1cmFsXCIgfSAqL1xyXG4gICAgb3V0LmNsYXNzVG9UZXh0XyA9IHVuZGVmaW5lZFxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSB0b29sdGlwVGV4dEZ1bkNhdFxyXG5cclxuICAgIC8vdGhlIGNsYXNzaWZpZXI6IGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbJ2NsYXNzVG9GaWxsU3R5bGVfJywgJ2NsYXNzVG9UZXh0XycsICdub0RhdGFGaWxsU3R5bGVfJywgJ3Rvb2x0aXBUZXh0XycsICdjbGFzc2lmaWVyXyddLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbJ2NsYXNzVG9GaWxsU3R5bGUnLCAnY2xhc3NUb1RleHQnLCAnbm9EYXRhRmlsbFN0eWxlJywgJ3Rvb2x0aXBUZXh0JywgJ2NsYXNzaWZpZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICAvL2dldCBkb21haW4gKHVuaXF1ZSB2YWx1ZXMpXHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gb3V0LnN0YXREYXRhKCkuZ2V0VW5pcXVlVmFsdWVzKClcclxuXHJcbiAgICAgICAgLy9nZXQgcmFuZ2UgWzAsMSwyLDMsLi4uLGRvbWFpbi5sZW5ndGgtMV1cclxuICAgICAgICBjb25zdCByYW5nZSA9IFsuLi5BcnJheShkb21haW4ubGVuZ3RoKS5rZXlzKCldXHJcblxyXG4gICAgICAgIC8vbWFrZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgLy9vbmx5IHVzZSB1c2VyLWRlZmluZSBjbGFzc2VzXHJcbiAgICAgICAgY29uc3QgY3RmcyA9IG91dC5jbGFzc1RvRmlsbFN0eWxlXyA/IG91dC5jbGFzc1RvRmlsbFN0eWxlKCkgOiB1bmRlZmluZWRcclxuICAgICAgICBpZiAoY3Rmcykge1xyXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gT2JqZWN0LmtleXMoY3RmcylcclxuICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoXHJcbiAgICAgICAgICAgICAgICBzY2FsZU9yZGluYWwoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oY2F0ZWdvcmllcykgLy8gT25seSBjbGFzc2lmeSBrbm93biBjYXRlZ29yaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKGNhdGVnb3JpZXMubWFwKChfLCBpKSA9PiBpKSkgLy8gQXNzaWduIG51bWVyaWNhbCBjbGFzc2VzXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2UgYWxsIHVuaXF1ZSB2YWx1ZXMgaWYgbm8gdXNlci1kZWZpbmVkIGNsYXNzZXMgZXhpc3RcclxuICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVPcmRpbmFsKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgY2xhc3NpZmllciBhbmQgc2V0ICdlY2wnIGF0dHJpYnV0ZSB0byByZWdpb25zIGJhc2VkIG9uIHZhbHVlXHJcbiAgICAgICAgY29uc3QgY2xhc3NpZnlSZWdpb25zID0gKHJlZ2lvbnMpID0+IHtcclxuICAgICAgICAgICAgcmVnaW9ucy5hdHRyKCdlY2wnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAnOicpIHJldHVybiAnbmQnIC8vIE5vIGRhdGFcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlzTmFOKHYpID8gdiA6ICt2IC8vIENvbnZlcnQgbnVtYmVycywga2VlcCBzdHJpbmdzIGFzIGlzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8g8J+UuSBFbnN1cmUgb25seSBrbm93biB2YWx1ZXMgYXJlIGNsYXNzaWZpZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzaWZpZXJEb21haW4gPSBvdXQuY2xhc3NpZmllcigpLmRvbWFpbigpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNsYXNzaWZpZXJEb21haW4uaW5jbHVkZXModmFsdWUpKSByZXR1cm4gLy8gU2tpcCB1bmtub3duIHZhbHVlc1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NpZmllcigpKHZhbHVlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcikpXHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBtaXhlZCBOVVRTIGxldmVsLCBzZXBhcmF0aW5nIE5VVFMgbGV2ZWwgMFxyXG4gICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICBjb25zdCBudXRzMFJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobnV0czBSZWdpb25zKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm8gY29sb3Igc3BlY2lmaWVkLCB1c2Ugc29tZSBkZWZhdWx0IGNvbG9yc1xyXG4gICAgICAgIGlmICghb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdGZzID0ge31cclxuICAgICAgICAgICAgY29uc3QgZG9tID0gb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5sZW5ndGg7IGkrKykgY3Rmc1tkb21baV1dID0gc2NoZW1lU2V0M1tpICUgMTJdXHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGN0ZnMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseVN0eWxlVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVUb01hcChtYXApIHtcclxuICAgICAgICAvLyBBcHBseSBjb2xvciBhbmQgZXZlbnRzIHRvIHJlZ2lvbnMgaWYgU1ZHIGV4aXN0c1xyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmQgc2V0IGluaXRpYWwgZmlsbCBjb2xvcnMgd2l0aCBkYXRhLWRyaXZlbiBsb2dpY1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgcmVnaW9uc0ZpbGxGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICByZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBhZGRNb3VzZUV2ZW50c1RvUmVnaW9ucyhtYXAsIHJlZ2lvbnMpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb250IGNvbG9yIGZvciBncmlkIGNhcnRvZ3JhbXMgKGNvbnRyYXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC10ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29sb3IgPSBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKGNlbGxDb2xvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgdHJhbnNpdGlvbiB0byByZWdpb25zOicsIGVycilcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBhZGRpdGlvbmFsIHNldHRpbmdzIGZvciBtaXhlZCBOVVRTIGxldmVsIHZpZXdcclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYWJlbHMgZm9yIHN0YXRpc3RpY2FsIHZhbHVlcyBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICBpZiAob3V0LmxhYmVsc18pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXy52YWx1ZXMpIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMobWFwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gbWl4aW5nIGRpZmZlcmVudCBOVVRTIGxldmVscyAoZS5nLiBzaG93aW5nIE5VVFMgMSBhbmQgTlVUUyAyIGRhdGEgc2ltdWx0YW5lb3VzbHkpXHJcbiAgICBjb25zdCBzdHlsZU1peGVkTlVUUyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBtYXAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbChnZXRSZWdpb25zU2VsZWN0b3IobWFwKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWNsIHx8IGx2bCA9PT0gJzAnID8gJ2Jsb2NrJyA6ICdub25lJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHNlbC5zdHlsZSgnc3Ryb2tlJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBlY2wgJiYgbHZsICE9PSAnMCcgPyBzdHJva2UgfHwgJyM3NzcnIDogbnVsbFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVjbCAmJiBsdmwgIT09ICcwJyA/IHN0cm9rZVdpZHRoIHx8IDAuMiA6IG51bGxcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWdpb25zRmlsbEZ1bmN0aW9uID0gZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgY29uc3QgZWNsID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbCcpIC8vICd0aGlzJyByZWZlcnMgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcclxuICAgICAgICBpZiAob3V0Lkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKVxyXG4gICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmNsYXNzVG9GaWxsU3R5bGVfW291dC5jbGFzc2lmaWVyKCkuZG9tYWluKClbZWNsXV1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3V0Lmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIG91dC5jbnRyZ0ZpbGxTdHlsZV9cclxuICAgICAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV9bb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVtlY2xdXVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGxTdHlsZSB8fCBvdXQuY250cmdGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOVVRTIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudHJ5SWQgPSByZy5wcm9wZXJ0aWVzLmlkLnNsaWNlKDAsIDIpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jbGFzc1RvRmlsbFN0eWxlX1tvdXQuY2xhc3NpZmllcigpLmRvbWFpbigpW2VjbF1dXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMgPSBmdW5jdGlvbiAobWFwLCByZWdpb25zKSB7XHJcbiAgICAgICAgLy8gU2V0IHVwIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKSAvLyBBcHBseSBoaWdobGlnaHQgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKSAvLyBSZXZlcnQgdG8gb3JpZ2luYWwgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKipcclxuICogU3BlY2lmaWMgZnVuY3Rpb24gZm9yIHRvb2x0aXAgdGV4dC5cclxuICpcclxuICogQHBhcmFtIHsqfSByZyBUaGUgcmVnaW9uIHRvIHNob3cgaW5mb3JtYXRpb24gb24uXHJcbiAqIEBwYXJhbSB7Kn0gbWFwIFRoZSBtYXAgZWxlbWVudFxyXG4gKi9cclxuY29uc3QgdG9vbHRpcFRleHRGdW5DYXQgPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgY29uc3QgYnVmID0gW11cclxuICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj4nICsgcmcucHJvcGVydGllcy5uYSArICcgKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPC9kaXY+JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+JyArIHJnLnByb3BlcnRpZXMubmEgKyAnPC9kaXY+JylcclxuICAgIH1cclxuICAgIC8vZ2V0IHN0YXQgdmFsdWVcclxuICAgIGNvbnN0IHN2ID0gbWFwLnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAvL2Nhc2Ugd2hlbiBubyBkYXRhIGF2YWlsYWJsZVxyXG4gICAgaWYgKCFzdiB8fCAoc3YudmFsdWUgIT0gMCAmJiAhc3YudmFsdWUpKSB7XHJcbiAgICAgICAgYnVmLnB1c2gobWFwLm5vRGF0YVRleHRfKVxyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbCA9IHN2LnZhbHVlXHJcbiAgICBpZiAobWFwLmNsYXNzVG9UZXh0Xykge1xyXG4gICAgICAgIGNvbnN0IGxibCA9IG1hcC5jbGFzc1RvVGV4dF9bdmFsXVxyXG4gICAgICAgIC8vZGlzcGxheSBsYWJlbCBhbmQgdmFsdWVcclxuICAgICAgICBidWYucHVzaChgXHJcbiAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPlxyXG4gICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgPHRib2R5PlxyXG4gICAgPHRyPlxyXG4gICAgPHRkPlxyXG4gICAgJHtsYmwgPyBsYmwgOiB2YWx9XHJcbiAgICA8L3RkPlxyXG4gICAgPC90cj5cclxuICAgIDwvdGJvZHk+XHJcbiAgICA8L3RhYmxlPlxyXG4gICAgPC9kaXY+XHJcbmApXHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG4gICAgfVxyXG4gICAgLy9kaXNwbGF5IGp1c3QgdmFsdWVcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0XCI+XHJcbiAgICA8dGFibGUgY2xhc3M9XCJudXRzLXRhYmxlXCI+XHJcbiAgICA8dGJvZHk+XHJcbiAgICA8dHI+XHJcbiAgICA8dGQ+XHJcbiAgICAke3ZhbH1cclxuICAgIDwvdGQ+XHJcbiAgICA8L3RyPlxyXG4gICAgPC90Ym9keT5cclxuICAgIDwvdGFibGU+XHJcbiAgICA8L2Rpdj5cclxuYClcclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVSZ2IgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBCaXZhcmlhdGVMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLWJpdmFyaWF0ZSdcclxuaW1wb3J0IHsgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciwgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBiaXZhcmlhdGUgY2hvcm9wbGV0aCBtYXAuXHJcbiAqIFNlZTogaHR0cHM6Ly9naXN0Ym9rLnVjZ2lzLm9yZy9ib2stdG9waWNzL211bHRpdmFyaWF0ZS1tYXBwaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgZmFsc2UsICdjaGJpJylcclxuXHJcbiAgICAvL251bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgY2xhc3NpZmljYXRpb24uIFNhbWUgZm9yIGJvdGggdmFyaWFibGVzLlxyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSAzXHJcbiAgICAvL3N0ZXZlbnMuZ3JlZW5ibHVlXHJcbiAgICAvL1RPRE8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZGl2ZXJnaW5nIGNvbG9yIHJhbXBzID9cclxuICAgIG91dC5zdGFydENvbG9yXyA9ICcjZThlOGU4J1xyXG4gICAgb3V0LmNvbG9yMV8gPSAnIzczYWU4MCdcclxuICAgIG91dC5jb2xvcjJfID0gJyM2YzgzYjUnXHJcbiAgICBvdXQuZW5kQ29sb3JfID0gJyMyYTVhNWInXHJcbiAgICAvL2EgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvcnMgZm9yIHRoZSBjbGFzc2VzIGksalxyXG4gICAgb3V0LmNsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyOiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybiBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyMV8gPSB1bmRlZmluZWRcclxuICAgIG91dC5jbGFzc2lmaWVyMl8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHRvb2x0aXBUZXh0RnVuQml2XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ3N0YXJ0Q29sb3JfJyxcclxuICAgICAgICAnY29sb3IxXycsXHJcbiAgICAgICAgJ2NvbG9yMl8nLFxyXG4gICAgICAgICdlbmRDb2xvcl8nLFxyXG4gICAgICAgICdjbGFzc1RvRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyMV8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyMl8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgWydudW1iZXJPZkNsYXNzZXMnLCAnc3RhcnRDb2xvcicsICdjb2xvcjEnLCAnY29sb3IyJywgJ2VuZENvbG9yJywgJ2NsYXNzVG9GaWxsU3R5bGUnLCAnbm9EYXRhRmlsbFN0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9zZXQgY2xhc3NpZmllcnNcclxuICAgICAgICBjb25zdCBzZXR1cENsYXNzaWZpZXJzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RhdDEgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgICAgICBsZXQgc3RhdDIgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0QXJyYXkoKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBbLi4uQXJyYXkob3V0Lm51bWJlck9mQ2xhc3NlcygpKS5rZXlzKCldXHJcbiAgICAgICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIxXykgb3V0LmNsYXNzaWZpZXIxKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDEpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgaWYgKCFvdXQuY2xhc3NpZmllcjJfKSBvdXQuY2xhc3NpZmllcjIoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihzdGF0MikucmFuZ2UocmFuZ2UpKVxyXG5cclxuICAgICAgICAgICAgLy9kZWZpbmUgYml2YXJpYXRlIHNjYWxlXHJcbiAgICAgICAgICAgIGlmICghb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBzY2FsZUJpdmFyaWF0ZShvdXQubnVtYmVyT2ZDbGFzc2VzKCksIG91dC5zdGFydENvbG9yKCksIG91dC5jb2xvcjEoKSwgb3V0LmNvbG9yMigpLCBvdXQuZW5kQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKHNjYWxlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjbGFzc2lmeVJlZ2lvbnMgPSAocmVnaW9ucykgPT4ge1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmcucHJvcGVydGllcy5pZC5sZW5ndGggPT0gNCkgY29uc29sZS5sb2cocmcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIyXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbmQnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdjEgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YyID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YxIHx8ICFzdjIpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2ID0gc3YxLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBzdjIudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgc2V0dXBDbGFzc2lmaWVycygpXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNsYXNzaWZpY2F0aW9uIGFuZCBhc3NpZ24gJ2VjbCcgYXR0cmlidXRlIGJhc2VkIG9uIG1hcCB0eXBlXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNsYXNzaWZ5UmVnaW9ucyhtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKSlcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtaXhlZCBOVVRTIGxldmVsLCBzZXBhcmF0aW5nIE5VVFMgbGV2ZWwgMFxyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG51dHMwUmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoJ3BhdGguZW0tbnV0c3JnMCcpXHJcbiAgICAgICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobnV0czBSZWdpb25zKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgc3R5bGUgdG8gaW5zZXRzXHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0c1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlTdHlsZVRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseVN0eWxlVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vYXBwbHkgc3R5bGUgdG8gbnV0cyByZWdpb25zXHJcblxyXG4gICAgICAgIC8vIHNldCBjb2xvdXIgb2YgcmVnaW9uc1xyXG4gICAgICAgIGlmIChtYXAuc3ZnKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wxID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDEnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDIgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMicpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlY2wxICYmICFlY2wyKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJykgLy8gR0lTQ08tMjY3OCAtIGxhY2sgb2YgZGF0YSBubyBsb25nZXIgbWVhbnMgbm8gZGF0YSwgaW5zdGVhZCBpdCBpcyBleHBsaWNpdGx5IHNldCB1c2luZyAnOicuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVjbDIgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSgrZWNsMSwgK2VjbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMobWFwLCByZWdpb25zKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZvbnQgY29sb3IgZm9yIGdyaWQgY2FydG9ncmFtcyAoY29udHJhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbG9yID0gc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQoY2VsbENvbG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiBtaXhpbmcgZGlmZmVyZW50IE5VVFMgbGV2ZWxzIChlLmcuIHNob3dpbmcgTlVUUyAxIGFuZCBOVVRTIDIgZGF0YSBzaW11bHRhbmVvdXNseSlcclxuICAgIGNvbnN0IHN0eWxlTWl4ZWROVVRTID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBzZWwuYXR0cignZWNsMScpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gc2VsLmF0dHIoJ2VjbDInKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGRpc3BsYXkgdmlzaWJpbGl0eXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVjbDEgfHwgZWNsMiB8fCBsdmwgPT09ICcwJ1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHN0eWxlcyBlZmZpY2llbnRseVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdkaXNwbGF5JywgaXNWaXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJylcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGVjbDEgfHwgZWNsMikgJiYgbHZsICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpIHx8ICcjNzc3J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKSB8fCAwLjJcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ3N0cm9rZScsIHN0cm9rZSkuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zID0gZnVuY3Rpb24gKG1hcCwgcmVnaW9ucykge1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmlsbCA9IHNlbC5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJpdmFyaWF0ZUxlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmNvbnN0IHNjYWxlQml2YXJpYXRlID0gZnVuY3Rpb24gKG51bWJlck9mQ2xhc3Nlcywgc3RhcnRDb2xvciwgY29sb3IxLCBjb2xvcjIsIGVuZENvbG9yKSB7XHJcbiAgICAvL2NvbG9yIHJhbXBzLCBieSByb3dcclxuICAgIGNvbnN0IGNzID0gW11cclxuICAgIC8vaW50ZXJwb2xhdGUgZnJvbSBmaXJzdCBhbmQgbGFzdCBjb2x1bW5zXHJcbiAgICBjb25zdCByYW1wUzEgPSBpbnRlcnBvbGF0ZVJnYihzdGFydENvbG9yLCBjb2xvcjEpXHJcbiAgICBjb25zdCByYW1wMkUgPSBpbnRlcnBvbGF0ZVJnYihjb2xvcjIsIGVuZENvbG9yKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHQgPSBpIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpXHJcbiAgICAgICAgY29uc3QgY29sRnVuID0gaW50ZXJwb2xhdGVSZ2IocmFtcFMxKHQpLCByYW1wMkUodCkpXHJcbiAgICAgICAgY29uc3Qgcm93ID0gW11cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bWJlck9mQ2xhc3NlczsgaisrKSByb3cucHVzaChjb2xGdW4oaiAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSkpXHJcbiAgICAgICAgY3MucHVzaChyb3cpXHJcbiAgICB9XHJcbiAgICAvL1RPRE8gY29tcHV0ZSBvdGhlciBtYXRyaXggYmFzZWQgb24gcm93cywgYW5kIGF2ZXJhZ2UgYm90aD9cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbDEsIGVjbDIpIHtcclxuICAgICAgICByZXR1cm4gY3NbZWNsMV1bZWNsMl1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNwZWNpZmljIGZ1bmN0aW9uIGZvciB0b29sdGlwIHRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcmcgVGhlIHJlZ2lvbiB0byBzaG93IGluZm9ybWF0aW9uIG9uLlxyXG4gKiBAcGFyYW0geyp9IG1hcCBUaGUgbWFwIGVsZW1lbnRcclxuICovXHJcbmNvbnN0IHRvb2x0aXBUZXh0RnVuQml2ID0gZnVuY3Rpb24gKHJnLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcbiAgICAvL3JlZ2lvbiBuYW1lXHJcbiAgICBjb25zdCByZWdpb25OYW1lID0gcmcucHJvcGVydGllcy5uYSB8fCByZy5wcm9wZXJ0aWVzLm5hbWVcclxuICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIiA+JyArIHJlZ2lvbk5hbWUgKyAnICgnICsgcmcucHJvcGVydGllcy5pZCArICcpIDwvZGl2PicpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vcmVnaW9uIG5hbWVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiID4nICsgcmVnaW9uTmFtZSArICc8L2Rpdj4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhdCAxIHZhbHVlXHJcbiAgICBjb25zdCBzdjEgPSBtYXAuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICBjb25zdCB1bml0MSA9IG1hcC5zdGF0RGF0YSgndjEnKS51bml0VGV4dCgpXHJcbiAgICAvL3N0YXQgMiB2YWx1ZVxyXG4gICAgY29uc3Qgc3YyID0gbWFwLnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDIgPSBtYXAuc3RhdERhdGEoJ3YyJykudW5pdFRleHQoKVxyXG5cclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiIHN0eWxlPVwiYmFja2dyb3VuZDogI2ZmZmZmZjtjb2xvcjogIzE3MWEyMjtwYWRkaW5nOiA0cHg7Zm9udC1zaXplOjE1cHg7XCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgIDx0Ym9keT5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICR7c3YxICYmIHN2MS52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpIDogJyd9ICR7dW5pdDEgJiYgc3YxICYmIHN2MS52YWx1ZSA/IHVuaXQxIDogJyd9XHJcbiAgICAgICAgJHshc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICR7c3YyICYmIHN2Mi52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjIudmFsdWUpIDogJyd9ICR7dW5pdDIgJiYgc3YyICYmIHN2Mi52YWx1ZSA/IHVuaXQyIDogJyd9XHJcbiAgICAgICAgJHshc3YyIHx8IChzdjIudmFsdWUgIT0gMCAmJiAhc3YyLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVSZ2IgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBUcml2YXJpYXRlTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aC10cml2YXJpYXRlJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yLCBleGVjdXRlRm9yQWxsSW5zZXRzLCBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgsIGdldFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgdHJpdmFyaWF0ZSBjaG9yb3BsZXRoIG1hcC5cclxuICogU2VlOiBodHRwczovL2dpc3Rib2sudWNnaXMub3JnL2Jvay10b3BpY3MvbXVsdGl2YXJpYXRlLW1hcHBpbmdcclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCBmYWxzZSwgJ2NodHJpJylcclxuXHJcbiAgICAvL251bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgY2xhc3NpZmljYXRpb24uIFNhbWUgZm9yIGJvdGggdmFyaWFibGVzLlxyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSAzXHJcbiAgICAvL3N0ZXZlbnMuZ3JlZW5ibHVlXHJcbiAgICAvL1RPRE8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZGl2ZXJnaW5nIGNvbG9yIHJhbXBzID9cclxuICAgIG91dC5zdGFydENvbG9yXyA9ICcjZThlOGU4J1xyXG4gICAgb3V0LmNvbG9yMV8gPSAnIzA5RjhGRidcclxuICAgIG91dC5jb2xvcjJfID0gJyNGNUQzMDAnXHJcbiAgICBvdXQuY29sb3IzXyA9ICcjRkYxNDkzJ1xyXG4gICAgb3V0LmVuZENvbG9yXyA9ICcjMmE1YTViJ1xyXG4gICAgLy9hIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3JzIGZvciB0aGUgY2xhc3NlcyBpLGpcclxuICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlXyA9IHVuZGVmaW5lZFxyXG4gICAgLy90aGUgY2xhc3NpZmllcjogYSBmdW5jdGlvbiB3aGljaCByZXR1cm4gYSBjbGFzcyBudW1iZXIgZnJvbSBhIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllcjFfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllcjJfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllcjNfID0gdW5kZWZpbmVkXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHRvb2x0aXBUZXh0RnVuY3Rpb25Ucml2YXJpYXRlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ3N0YXJ0Q29sb3JfJyxcclxuICAgICAgICAnY29sb3IxXycsXHJcbiAgICAgICAgJ2NvbG9yMl8nLFxyXG4gICAgICAgICdjb2xvcjNfJyxcclxuICAgICAgICAnZW5kQ29sb3JfJyxcclxuICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjFfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjJfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFsnbnVtYmVyT2ZDbGFzc2VzJywgJ3N0YXJ0Q29sb3InLCAnY29sb3IxJywgJ2NvbG9yMicsICdjb2xvcjMnLCAnZW5kQ29sb3InLCAnY2xhc3NUb0ZpbGxTdHlsZScsICdub0RhdGFGaWxsU3R5bGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChtYXApIHtcclxuICAgICAgICAvL3NldCBjbGFzc2lmaWVyc1xyXG4gICAgICAgIGxldCBzdGF0MSA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXRBcnJheSgpXHJcbiAgICAgICAgbGV0IHN0YXQyID0gb3V0LnN0YXREYXRhKCd2MicpLmdldEFycmF5KClcclxuICAgICAgICBsZXQgc3RhdDMgPSBvdXQuc3RhdERhdGEoJ3YzJykuZ2V0QXJyYXkoKVxyXG5cclxuICAgICAgICBjb25zdCByYW5nZSA9IFsuLi5BcnJheSg3KS5rZXlzKCldXHJcbiAgICAgICAgaWYgKCFvdXQuY2xhc3NpZmllcjFfKSBvdXQuY2xhc3NpZmllcjEoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihzdGF0MSkucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIyXykgb3V0LmNsYXNzaWZpZXIyKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDIpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICBpZiAoIW91dC5jbGFzc2lmaWVyM18pIG91dC5jbGFzc2lmaWVyMyhzY2FsZVF1YW50aWxlKCkuZG9tYWluKHN0YXQzKS5yYW5nZShyYW5nZSkpXHJcblxyXG4gICAgICAgIC8vYXNzaWduIGNsYXNzIHRvIG51dHMgcmVnaW9ucywgYmFzZWQgb24gdGhlaXIgdmFsdWVcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDEnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIyXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMycsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MycpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyM18oK3YpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3JlZ2lvbkNsYXNzJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMSA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wxJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDInKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDMgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMycpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnIHx8IGVjbDIgPT09ICduZCcgfHwgZWNsMyA9PT0gJ25kJykgcmV0dXJuICduZCcgLy8gSGFuZGxlICdubyBkYXRhJ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoZSBjbGFzc2lmaWVyIHJlc3VsdHMgaW50byBhIHNpbmdsZSBjbGFzcyAoMS03KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmICFlY2wyICYmICFlY2wzKSByZXR1cm4gMSAvLyBvbmx5IHZhcmlhYmxlIDEgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsMSAmJiBlY2wyICYmICFlY2wzKSByZXR1cm4gMiAvLyBvbmx5IHZhcmlhYmxlIDIgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsMSAmJiAhZWNsMiAmJiBlY2wzKSByZXR1cm4gMyAvLyBvbmx5IHZhcmlhYmxlIDMgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmIGVjbDIgJiYgIWVjbDMpIHJldHVybiA0IC8vIHZhcmlhYmxlcyAxICYgMiBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVjbDEgJiYgIWVjbDIgJiYgZWNsMykgcmV0dXJuIDUgLy8gdmFyaWFibGVzIDEgJiAzIHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgZWNsMiAmJiBlY2wzKSByZXR1cm4gNiAvLyB2YXJpYWJsZXMgMiAmIDMgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmIGVjbDIgJiYgZWNsMykgcmV0dXJuIDcgLy8gYWxsIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIC5hdHRyKCduZCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAvLyAgICAgY29uc3Qgc3YxID0gb3V0LnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKSB8fCBvdXQuc3RhdERhdGEoKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgLy8gICAgIGNvbnN0IHN2MiA9IG91dC5zdGF0RGF0YSgndjInKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgLy8gICAgIGlmICghc3YxIHx8ICFzdjIpIHJldHVyblxyXG4gICAgICAgICAgICAvLyAgICAgbGV0IHYgPSBzdjEudmFsdWVcclxuICAgICAgICAgICAgLy8gICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgLy8gICAgIHYgPSBzdjIudmFsdWVcclxuICAgICAgICAgICAgLy8gICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiAnJ1xyXG4gICAgICAgICAgICAvLyB9KVxyXG5cclxuICAgICAgICAgICAgLy93aGVuIG1peGluZyBOVVRTLCBsZXZlbCAwIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0IChjbGFzcyBudXRzcmcwKVxyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5lbS1udXRzcmcwJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIxXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjJfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDMnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YzJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyM18oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kZWZpbmUgdHJpdmFyaWF0ZSBzY2FsZVxyXG4gICAgICAgICAgICBpZiAoIW91dC5jbGFzc1RvRmlsbFN0eWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVUcml2YXJpYXRlKG91dC5jb2xvcjEoKSwgb3V0LmNvbG9yMigpLCBvdXQuY29sb3IzKCkpXHJcbiAgICAgICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShzY2FsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy93aGVuIG1peGluZyBOVVRTLCBsZXZlbCAwIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0ICh1c2luZyBjbGFzcyBudXRzcmcwKVxyXG4gICAgICAgICAgICBpZiAob3V0Lm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnN2Z19cclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wxJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDInLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyMl8oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMycsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjMnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIzXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNjYWxlVHJpdmFyaWF0ZSA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMiwgY29sb3IzKSB7XHJcbiAgICAgICAgLy8gQmxlbmRpbmcgcHJpbWFyeSBjb2xvcnMgYW5kIHRoZWlyIG92ZXJsYXBzXHJcbiAgICAgICAgY29uc3Qgb3ZlcmxhcENvbG9ycyA9IFtcclxuICAgICAgICAgICAgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcjEsIGNvbG9yMl0pLCAvLyBDbGFzcyA0IChPdmVybGFwIG9mIGNvbG9yMSBhbmQgY29sb3IyKVxyXG4gICAgICAgICAgICBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yMiwgY29sb3IzXSksIC8vIENsYXNzIDUgKE92ZXJsYXAgb2YgY29sb3IyIGFuZCBjb2xvcjMpXHJcbiAgICAgICAgICAgIG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3IxLCBjb2xvcjNdKSwgLy8gQ2xhc3MgNiAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcjEsIGNvbG9yMiwgY29sb3IzXSksIC8vIENsYXNzIDcgKE92ZXJsYXAgb2YgYWxsIHRocmVlKVxyXG4gICAgICAgIF1cclxuXHJcbiAgICAgICAgLy8gQ2xhc3MtdG8tY29sb3IgbWFwcGluZ1xyXG4gICAgICAgIGNvbnN0IGNsYXNzQ29sb3JzID0gW1xyXG4gICAgICAgICAgICBjb2xvcjEsIC8vIENsYXNzIDEgKEZpcnN0IGNvbG9yKVxyXG4gICAgICAgICAgICBjb2xvcjIsIC8vIENsYXNzIDIgKFNlY29uZCBjb2xvcilcclxuICAgICAgICAgICAgY29sb3IzLCAvLyBDbGFzcyAzIChUaGlyZCBjb2xvcilcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1swXSwgLy8gQ2xhc3MgNCAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMilcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1sxXSwgLy8gQ2xhc3MgNSAoT3ZlcmxhcCBvZiBjb2xvcjIgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1syXSwgLy8gQ2xhc3MgNiAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1szXSwgLy8gQ2xhc3MgNyAoT3ZlcmxhcCBvZiBhbGwgdGhyZWUpXHJcbiAgICAgICAgXVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gZnVuY3Rpb24gdG8gZ2V0IGNvbG9yIGJhc2VkIG9uIHJlZ2lvbidzIGNsYXNzICgxIHRvIDcpXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc0luZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc0luZGV4ID49IDEgJiYgY2xhc3NJbmRleCA8PSA3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NDb2xvcnNbY2xhc3NJbmRleCAtIDFdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAvLyBSZXR1cm4gbnVsbCBvciBhIGRlZmF1bHQgY29sb3IgaWYgdGhlIGNsYXNzSW5kZXggaXMgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBzdHlsZSB0byBpbnNldHNcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseVN0eWxlVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9hcHBseSBzdHlsZSB0byBudXRzIHJlZ2lvbnNcclxuXHJcbiAgICAgICAgLy8gc2V0IGNvbG91ciBvZiByZWdpb25zXHJcbiAgICAgICAgaWYgKG1hcC5zdmcoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKG91dC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMScpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMiA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wyJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wzID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDMnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wyID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wzID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgIWVjbDIgJiYgIWVjbDMpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKSAvLyBHSVNDTy0yNjc4IC0gbGFjayBvZiBkYXRhIG5vIGxvbmdlciBtZWFucyBubyBkYXRhLCBpbnN0ZWFkIGl0IGlzIGV4cGxpY2l0bHkgc2V0IHVzaW5nICc6Jy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlZ2lvbkNsYXNzID0gc2VsZWN0KHRoaXMpLmF0dHIoJ3JlZ2lvbkNsYXNzJylcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8ocmVnaW9uQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlTWl4ZWROVVRTKG1hcClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBUcml2YXJpYXRlTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuY29uc3Qgc3R5bGVNaXhlZE5VVFMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICBtYXAuc3ZnKClcclxuICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgIC5zdHlsZSgnZGlzcGxheScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50cnlJZCA9IHJnLnByb3BlcnRpZXMuaWQuc2xpY2UoMCwgMilcclxuICAgICAgICAgICAgcmV0dXJuIGVjbCB8fCBsdmwgPT09ICcwJyA/ICdibG9jaycgOiAnbm9uZSdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpXHJcbiAgICAgICAgICAgIHJldHVybiBlY2wgJiYgbHZsICE9PSAnMCcgPyBzdHJva2UgfHwgJyM3NzcnIDogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBsdmwgPSBzZWwuYXR0cignbHZsJylcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKVxyXG4gICAgICAgICAgICByZXR1cm4gZWNsICYmIGx2bCAhPT0gJzAnID8gc3Ryb2tlV2lkdGggfHwgMC4yIDogbnVsbFxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcGVjaWZpYyBmdW5jdGlvbiBmb3IgdG9vbHRpcCB0ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHJnIFRoZSByZWdpb24gdG8gc2hvdyBpbmZvcm1hdGlvbiBvbi5cclxuICogQHBhcmFtIHsqfSBtYXAgVGhlIG1hcCBlbGVtZW50XHJcbiAqL1xyXG5jb25zdCB0b29sdGlwVGV4dEZ1bmN0aW9uVHJpdmFyaWF0ZSA9IGZ1bmN0aW9uIChyZywgbWFwKSB7XHJcbiAgICBjb25zdCBidWYgPSBbXVxyXG4gICAgLy9yZWdpb24gbmFtZVxyXG4gICAgaWYgKHJnLnByb3BlcnRpZXMuaWQpIHtcclxuICAgICAgICAvL25hbWUgYW5kIGNvZGVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiID4nICsgcmcucHJvcGVydGllcy5uYSArICcgKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPC9kaXY+JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCIgPicgKyByZy5wcm9wZXJ0aWVzLm5hICsgJzwvZGl2PicpXHJcbiAgICB9XHJcblxyXG4gICAgLy9zdGF0IDEgdmFsdWVcclxuICAgIGNvbnN0IHN2MSA9IG1hcC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgIGNvbnN0IHVuaXQxID0gbWFwLnN0YXREYXRhKCd2MScpLnVuaXRUZXh0KClcclxuICAgIC8vc3RhdCAyIHZhbHVlXHJcbiAgICBjb25zdCBzdjIgPSBtYXAuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICBjb25zdCB1bml0MiA9IG1hcC5zdGF0RGF0YSgndjInKS51bml0VGV4dCgpXHJcbiAgICAvL3N0YXQgMyB2YWx1ZVxyXG4gICAgY29uc3Qgc3YzID0gbWFwLnN0YXREYXRhKCd2MycpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDMgPSBtYXAuc3RhdERhdGEoJ3YyJykudW5pdFRleHQoKVxyXG5cclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiIHN0eWxlPVwiYmFja2dyb3VuZDogI2ZmZmZmZjtjb2xvcjogIzE3MWEyMjtwYWRkaW5nOiA0cHg7Zm9udC1zaXplOjE1cHg7XCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgIDx0Ym9keT5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgIFZhcmlhYmxlIDE6ICR7c3YxICYmIHN2MS52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpIDogJyd9ICR7dW5pdDEgJiYgc3YxICYmIHN2MS52YWx1ZSA/IHVuaXQxIDogJyd9XHJcbiAgICAgICAgJHshc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICBWYXJpYWJsZSAyOiAke3N2MiAmJiBzdjIudmFsdWUgPyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YyLnZhbHVlKSA6ICcnfSAke3VuaXQyICYmIHN2MiAmJiBzdjIudmFsdWUgPyB1bml0MiA6ICcnfVxyXG4gICAgICAgICR7IXN2MiB8fCAoc3YyLnZhbHVlICE9IDAgJiYgIXN2Mi52YWx1ZSkgPyBtYXAubm9EYXRhVGV4dF8gOiAnJ31cclxuICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICAgICAgPHRyPlxyXG4gICAgICAgIDx0ZD5cclxuICAgICAgICAgVmFyaWFibGUgMzogJHtzdjMgJiYgc3YzLnZhbHVlID8gc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2My52YWx1ZSkgOiAnJ30gJHt1bml0MyAmJiBzdjMgJiYgc3YzLnZhbHVlID8gdW5pdDMgOiAnJ31cclxuICAgICAgICAkeyFzdjMgfHwgKHN2My52YWx1ZSAhPSAwICYmICFzdjMudmFsdWUpID8gbWFwLm5vRGF0YVRleHRfIDogJyd9XHJcbiAgICAgICAgPC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2NhbGVRdWFudGlsZSwgc2NhbGVRdWFudGl6ZSwgc2NhbGVUaHJlc2hvbGQgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVZbEduQnUgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCB7IHBpZWNld2lzZSwgaW50ZXJwb2xhdGVMYWIgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBDaG9yb3BsZXRoTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kLCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBqZW5rcywgY2ttZWFucyB9IGZyb20gJ3NpbXBsZS1zdGF0aXN0aWNzJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGNocm9yb3BsZXRoIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCBmYWxzZSwgJ2NoJylcclxuXHJcbiAgICAvL3RoZSBudW1iZXIgb2YgY2xhc3Nlc1xyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSA3XHJcbiAgICAvL3RoZSBjbGFzc2lmaWNhdGlvbiBtZXRob2RcclxuICAgIG91dC5jbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSAncXVhbnRpbGUnIC8vIG9yOiBlcXVpbnRlciwgdGhyZXNob2xkXHJcbiAgICAvL3RoZSB0aHJlc2hvbGQsIHdoZW4gdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZCBpcyAndGhyZXNob2xkJ1xyXG4gICAgb3V0LnRocmVzaG9sZHNfID0gWzBdXHJcbiAgICAvL2NvbG9ycyB0byB1c2UgZm9yIGNsYXNzZXNcclxuICAgIG91dC5jb2xvcnNfID0gbnVsbFxyXG4gICAgLy93aGVuIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHksIGVuc3VyZSB0aGUgdGhyZXNob2xkIGFyZSBuaWNlIHJvdW5kZWQgdmFsdWVzXHJcbiAgICBvdXQubWFrZUNsYXNzaWZOaWNlXyA9IHRydWVcclxuICAgIC8vdGhlIGNvbG9yIGZ1bmN0aW9uIFswLDFdIC0+IGNvbG9yXHJcbiAgICBsZXQgZXVyb3N0YXRNdWx0aWh1ZSA9IFsnI0ZGRUI5OScsICcjRDFFOUIwJywgJyM4REQ2QjknLCAnIzU4QzFDMCcsICcjMzc5MkI2JywgJyMxMzQ4OTEnLCAnIzFkMmI2ZiddXHJcbiAgICBvdXQuY29sb3JGdW5jdGlvbl8gPSAodCkgPT4gcGllY2V3aXNlKGludGVycG9sYXRlTGFiLCBldXJvc3RhdE11bHRpaHVlKShNYXRoLm1pbihNYXRoLm1heCgwLCB0KSwgMSkpIC8vIGRlZmF1bHRcclxuICAgIC8vYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIGZyb20gdGhlIGNsYXNzIGlcclxuICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlXyA9IHVuZGVmaW5lZFxyXG4gICAgLy90aGUgY2xhc3NpZmllcjogYSBmdW5jdGlvbiB3aGljaCByZXR1cm4gYSBjbGFzcyBudW1iZXIgZnJvbSBhIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllcl8gPSB1bmRlZmluZWRcclxuICAgIC8vIHNldCB0b29sdGlwIGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gY2hvcm9wbGV0aFRvb2x0aXBGdW5jdGlvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ251bWJlck9mQ2xhc3Nlc18nLFxyXG4gICAgICAgICdjbGFzc2lmaWNhdGlvbk1ldGhvZF8nLFxyXG4gICAgICAgICd0aHJlc2hvbGRzXycsXHJcbiAgICAgICAgJ21ha2VDbGFzc2lmTmljZV8nLFxyXG4gICAgICAgICdjb2xvckZ1bmN0aW9uXycsXHJcbiAgICAgICAgJ2NsYXNzVG9GaWxsU3R5bGVfJyxcclxuICAgICAgICAnbm9EYXRhRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpZXJfJyxcclxuICAgICAgICAnY29sb3JzXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBvZiBzb21lIHNwZWNpYWwgZ2V0dGVycy9zZXR0ZXJzXHJcbiAgICBvdXQuY29sb3JGdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuY29sb3JGdW5jdGlvbl9cclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LmNvbG9yRnVuY3Rpb25fID0gdlxyXG4gICAgICAgIC8vIHVwZGF0ZSBjbGFzcyBzdHlsZSBmdW5jdGlvblxyXG4gICAgICAgIGlmIChvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8pIHtcclxuICAgICAgICAgICAgLy8gaWYgZG90IGRlbnNpdHlcclxuICAgICAgICAgICAgb3V0LmNsYXNzVG9GaWxsU3R5bGUoZ2V0RmlsbFBhdHRlcm5MZWdlbmQoKSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRDb2xvckxlZ2VuZChvdXQuY29sb3JGdW5jdGlvbigpLCBvdXQuY29sb3JzXykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuICAgIG91dC50aHJlc2hvbGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC50aHJlc2hvbGRzX1xyXG4gICAgICAgIG91dC50aHJlc2hvbGRzXyA9IHZcclxuICAgICAgICBvdXQubnVtYmVyT2ZDbGFzc2VzKHYubGVuZ3RoICsgMSlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcbiAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fXHJcbiAgICAgICAgb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fID0gdlxyXG4gICAgICAgIGlmIChvdXQuc3ZnKCkpIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXyhvdXQuc3ZnKCksIG91dC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ251bWJlck9mQ2xhc3NlcycsXHJcbiAgICAgICAgICAgICdjbGFzc2lmaWNhdGlvbk1ldGhvZCcsXHJcbiAgICAgICAgICAgICd0aHJlc2hvbGQnLFxyXG4gICAgICAgICAgICAnbWFrZUNsYXNzaWZOaWNlJyxcclxuICAgICAgICAgICAgJ2NvbG9yRnVuY3Rpb24nLFxyXG4gICAgICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdub0RhdGFGaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAnY29sb3JzXycsXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChtYXApIHtcclxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSByYW5nZSBbMCwgMSwgMiwgLi4uLCBuYi0xXVxyXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlUmFuZ2UgPSAobmIpID0+IFsuLi5BcnJheShuYikua2V5cygpXVxyXG5cclxuICAgICAgICAvLyBDb25maWd1cmUgY2xhc3NpZmllciBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgY2xhc3NpZmljYXRpb24gbWV0aG9kXHJcbiAgICAgICAgY29uc3Qgc2V0dXBDbGFzc2lmaWVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBvdXQuc3RhdERhdGEoKS5nZXRBcnJheSgpXHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2VuZXJhdGVSYW5nZShvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAob3V0LmNsYXNzaWZpY2F0aW9uTWV0aG9kXykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncXVhbnRpbGUnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihkYXRhQXJyYXkpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXF1YWwtaW50ZXJ2YWwnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXF1aW50ZXInOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUXVhbnRpemUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbbWluKGRhdGFBcnJheSksIG1heChkYXRhQXJyYXkpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShyYW5nZSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYWtlQ2xhc3NpZk5pY2VfKSBvdXQuY2xhc3NpZmllcigpLm5pY2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0aHJlc2hvbGQnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lm51bWJlck9mQ2xhc3NlcyhvdXQudGhyZXNob2xkc18ubGVuZ3RoICsgMSlcclxuICAgICAgICAgICAgICAgICAgICBvdXQuY2xhc3NpZmllcihzY2FsZVRocmVzaG9sZCgpLmRvbWFpbihvdXQudGhyZXNob2xkc18pLnJhbmdlKGdlbmVyYXRlUmFuZ2Uob3V0Lm51bWJlck9mQ2xhc3Nlc18pKSlcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnamVua3MnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgamVua3NCcmVha3MgPSBqZW5rcyhkYXRhQXJyYXksIG91dC5udW1iZXJPZkNsYXNzZXNfKSAvLyBDYWxjdWxhdGUgYnJlYWtzIGZvciBKZW5rc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGplbmtzQnJlYWtzLnNsaWNlKDEsIC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKHNjYWxlVGhyZXNob2xkKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKSAvLyBVc2UgSmVua3MgYnJlYWtzIGluIHNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NrbWVhbnMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNrbWVhbnMgYnJlYWtzLCBleHRyYWN0aW5nIHRoZSBtYXhpbXVtIHZhbHVlIGZyb20gZWFjaCBjbHVzdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2ttZWFuc0JyZWFrcyA9IGNrbWVhbnMoZGF0YUFycmF5LCBvdXQubnVtYmVyT2ZDbGFzc2VzXykubWFwKChjbHVzdGVyKSA9PiBjbHVzdGVyLnBvcCgpKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGRvbWFpbiBmb3Igc2NhbGVUaHJlc2hvbGQgZXhjbHVkaW5nIHRoZSBsYXN0IHZhbHVlLCBhcyBpdCBzZXJ2ZXMgYXMgdGhlIHVwcGVyIGJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gY2ttZWFuc0JyZWFrcy5zbGljZSgwLCAtMSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBja21lYW5zIGJyZWFrcyBpbiB0aGUgc2NhbGVUaHJlc2hvbGQgYW5kIHNldCB0aGUgY2xhc3NpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKHNjYWxlVGhyZXNob2xkKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNsYXNzaWZpZXIgYW5kIHNldCAnZWNsJyBhdHRyaWJ1dGUgdG8gcmVnaW9ucyBiYXNlZCBvbiB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IGNsYXNzaWZ5UmVnaW9ucyA9IChyZWdpb25zKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZ2lvbnMuYXR0cignZWNsJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25EYXRhID0gb3V0LnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lvbkRhdGEpIHJldHVybiAvLyBMYWNrIG9mIGRhdGEgaXMgaGFuZGxlZCBleHBsaWNpdGx5XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlZ2lvbkRhdGEudmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJzonIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyArb3V0LmNsYXNzaWZpZXJfKHZhbHVlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgc2V0dXBDbGFzc2lmaWVyKClcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgY2xhc3NpZmljYXRpb24gYW5kIGFzc2lnbiAnZWNsJyBhdHRyaWJ1dGUgYmFzZWQgb24gbWFwIHR5cGVcclxuICAgICAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICAgICAgY2xhc3NpZnlSZWdpb25zKG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpKVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIG1peGVkIE5VVFMgbGV2ZWwsIHNlcGFyYXRpbmcgTlVUUyBsZXZlbCAwXHJcbiAgICAgICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnV0czBSZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgncGF0aC5lbS1udXRzcmcwJylcclxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5UmVnaW9ucyhudXRzMFJlZ2lvbnMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBzdHlsZSB0byBpbnNldHNcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5U3R5bGVUb01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlTdHlsZVRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVUb01hcChtYXApIHtcclxuICAgICAgICAvLyBEZWZpbmUgZnVuY3Rpb24gdG8gZ2V0IGEgY2xhc3MnIGNvbG9yXHJcbiAgICAgICAgaWYgKG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXykge1xyXG4gICAgICAgICAgICAvLyBEb3QgZGVuc2l0eSBzdHlsZVxyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRGaWxsUGF0dGVybkxlZ2VuZCgpKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENvbG9yIGxlZ2VuZCBzdHlsZVxyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRDb2xvckxlZ2VuZChvdXQuY29sb3JGdW5jdGlvbigpLCBvdXQuY29sb3JzXykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBseSBjb2xvciBhbmQgZXZlbnRzIHRvIHJlZ2lvbnMgaWYgU1ZHIGV4aXN0c1xyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmQgc2V0IGluaXRpYWwgZmlsbCBjb2xvcnMgd2l0aCBkYXRhLWRyaXZlbiBsb2dpY1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgcmVnaW9uc0ZpbGxGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICByZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBhZGRNb3VzZUV2ZW50c1RvUmVnaW9ucyhtYXAsIHJlZ2lvbnMpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb250IGNvbG9yIGZvciBncmlkIGNhcnRvZ3JhbXMgKGNvbnRyYXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC10ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29sb3IgPSBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKGNlbGxDb2xvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgdHJhbnNpdGlvbiB0byByZWdpb25zOicsIGVycilcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBhZGRpdGlvbmFsIHNldHRpbmdzIGZvciBtaXhlZCBOVVRTIGxldmVsIHZpZXdcclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYWJlbHMgZm9yIHN0YXRpc3RpY2FsIHZhbHVlcyBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICBpZiAob3V0LmxhYmVsc18pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXy52YWx1ZXMpIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMobWFwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIENob3JvcGxldGhMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiBtaXhpbmcgZGlmZmVyZW50IE5VVFMgbGV2ZWxzIChlLmcuIHNob3dpbmcgTlVUUyAxIGFuZCBOVVRTIDIgZGF0YSBzaW11bHRhbmVvdXNseSlcclxuICAgIGNvbnN0IHN0eWxlTWl4ZWROVVRTID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGRpc3BsYXkgdmlzaWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZWNsIHx8IGx2bCA9PT0gJzAnXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGVzIGVmZmljaWVudGx5XHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2Rpc3BsYXknLCBpc1Zpc2libGUgPyAnYmxvY2snIDogJ25vbmUnKVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlY2wgJiYgbHZsICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpIHx8ICcjNzc3J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKSB8fCAwLjJcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ3N0cm9rZScsIHN0cm9rZSkuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlZ2lvbnNGaWxsRnVuY3Rpb24gPSBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICBjb25zdCBlY2wgPSBzZWxlY3QodGhpcykuYXR0cignZWNsJykgLy8gJ3RoaXMnIHJlZmVycyB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykge1xyXG4gICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG91dC5nZW9fID09PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXb3JsZCB0ZW1wbGF0ZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBvdXQuY250cmdGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gb3V0LmNsYXNzVG9GaWxsU3R5bGVfKGVjbCwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsbFN0eWxlIHx8IG91dC5jbnRyZ0ZpbGxTdHlsZV9cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5VVFMgdGVtcGxhdGUgbG9naWNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50cnlJZCA9IHJnLnByb3BlcnRpZXMuaWQuc2xpY2UoMCwgMilcclxuICAgICAgICAgICAgICAgIGlmICghZWNsKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJylcclxuICAgICAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG91dC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zID0gZnVuY3Rpb24gKG1hcCwgcmVnaW9ucykge1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKSAvLyBBcHBseSBoaWdobGlnaHQgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKSAvLyBSZXZlcnQgdG8gb3JpZ2luYWwgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vL2J1aWxkIGEgY29sb3IgbGVnZW5kIG9iamVjdFxyXG5leHBvcnQgY29uc3QgZ2V0Q29sb3JMZWdlbmQgPSBmdW5jdGlvbiAoY29sb3JGdW5jdGlvbiwgY29sb3JBcnJheSkge1xyXG4gICAgY29sb3JGdW5jdGlvbiA9IGNvbG9yRnVuY3Rpb24gfHwgaW50ZXJwb2xhdGVZbEduQnVcclxuICAgIGlmIChjb2xvckFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3JBcnJheVtlY2xdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9uKGVjbCAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGEgZmlsbCBwYXR0ZXJuIGxlZ2VuZCBvYmplY3QgeyBuZDpcIndoaXRlXCIsIDA6XCJ1cmwoI3BhdHRlcm5fMClcIiwgMTpcInVybCgjcGF0dGVybl8xKVwiLCAuLi4gfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEZpbGxQYXR0ZXJuTGVnZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wpIHtcclxuICAgICAgICByZXR1cm4gJ3VybCgjcGF0dGVybl8nICsgZWNsICsgJyknXHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGNob3JvcGxldGhUb29sdGlwRnVuY3Rpb24gPSBmdW5jdGlvbiAocmVnaW9uLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcblxyXG4gICAgLy8gSGVhZGVyIHdpdGggcmVnaW9uIG5hbWUgYW5kIElEXHJcbiAgICBjb25zdCByZWdpb25OYW1lID0gcmVnaW9uLnByb3BlcnRpZXMubmEgfHwgcmVnaW9uLnByb3BlcnRpZXMubmFtZVxyXG4gICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgYnVmLnB1c2goYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj5cclxuICAgICAgICAgICAgPGI+JHtyZWdpb25OYW1lfTwvYj4ke3JlZ2lvbklkID8gYCAoJHtyZWdpb25JZH0pYCA6ICcnfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYClcclxuXHJcbiAgICAvLyBSZXRyaWV2ZSByZWdpb24ncyBkYXRhIHZhbHVlIGFuZCB1bml0XHJcbiAgICBjb25zdCBzdGF0RGF0YSA9IG1hcC5zdGF0RGF0YSgpXHJcbiAgICBjb25zdCBzdiA9IHN0YXREYXRhLmdldChyZWdpb25JZClcclxuICAgIGNvbnN0IHVuaXQgPSBzdGF0RGF0YS51bml0VGV4dCgpIHx8ICcnXHJcblxyXG4gICAgLy8gTm8gZGF0YSBjYXNlXHJcbiAgICBpZiAoIXN2IHx8IChzdi52YWx1ZSAhPT0gMCAmJiAhc3YudmFsdWUpIHx8IHN2LnZhbHVlID09PSAnOicpIHtcclxuICAgICAgICBidWYucHVzaChgXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0IG5vLWRhdGFcIj5cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cIm51dHMtdGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+JHttYXAubm9EYXRhVGV4dF99PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBgKVxyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBEYXRhIGRpc3BsYXlcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPlxyXG4gICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJudXRzLXRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD4ke3NwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdi52YWx1ZSl9ICR7dW5pdH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYClcclxuXHJcbiAgICAvLyBPcHRpb25hbCBzdGF0dXMgZmxhZ1xyXG4gICAgY29uc3Qgc3RhdHVzRmxhZyA9IHN2LnN0YXR1c1xyXG4gICAgaWYgKHN0YXR1c0ZsYWcgJiYgbWFwLnRvb2x0aXBfLnNob3dGbGFncykge1xyXG4gICAgICAgIGNvbnN0IGZsYWdUZXh0ID0gbWFwLnRvb2x0aXBfLnNob3dGbGFncyA9PT0gJ3Nob3J0JyA/IHN0YXR1c0ZsYWcgOiBmbGFnc1tzdGF0dXNGbGFnXSB8fCBzdGF0dXNGbGFnXHJcbiAgICAgICAgYnVmLnB1c2goYCA8c3BhbiBjbGFzcz1cInN0YXR1cy1mbGFnXCI+JHtmbGFnVGV4dH08L3NwYW4+YClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbn1cclxuIiwiLy8gSW1wb3J0IHJlcXVpcmVkIEQzIG1vZHVsZXNcclxuLy8gaW1wb3J0IHsgc2Fua2V5LCBzYW5rZXlMaW5rSG9yaXpvbnRhbCB9IGZyb20gJ2QzLXNhbmtleSdcclxuaW1wb3J0IHsgbGlua0hvcml6b250YWwgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgc3VtLCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2NhbGVMaW5lYXIgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBGbG93TGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtZmxvdydcclxuaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgZ2V0UmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZmxvdyBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgdHJ1ZSwgJ2Zsb3cnKVxyXG4gICAgb3V0LnN0cm9rZVdpZHRoU2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICBvdXQubGFiZWxPZmZzZXRYID0gMTVcclxuICAgIG91dC5sYWJlbE9mZnNldFkgPSA1XHJcbiAgICBvdXQubGFiZWxGb3JtYXR0ZXIgPSAoZCkgPT4gZm9ybWF0KCcuMnMnKShkKVxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IGZsb3dNYXBUb29sdGlwRnVuY3Rpb25cclxuICAgIG91dC5mbG93Q29sb3JfID0gJyM3MmJiNmYnXHJcbiAgICBvdXQuZmxvd092ZXJsYXlDb2xvcnNfID0gWycjYmJkN2VlJywgJyNjN2UzYzYnXSAvLyBleHBvcnRlciwgaW1wb3J0ZXJzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmbG93bWFwLXNwZWNpZmljIHNldHRlcnMvZ2V0dGVyc1xyXG4gICAgICovXHJcbiAgICA7WydmbG93R3JhcGhfJywgJ2Zsb3dDb2xvcl8nLCAnZmxvd092ZXJsYXlDb2xvcnNfJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHR5cGU6IFwiRmVhdHVyZVwiXHJcbiAgICAgICAgLy8gcHJvcGVydGllczogT2JqZWN0IHtpZDogXCJFU1wiLCBuYTogXCJFc3Bhw7FhXCJ9XHJcbiAgICAgICAgLy8gZ2VvbWV0cnk6IE9iamVjdCB7dHlwZTogXCJNdWx0aVBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IEFycmF5KDcpfVxyXG4gICAgICAgIC8vIHNvdXJjZTogXCJGUlwiXHJcbiAgICAgICAgLy8gdGFyZ2V0OiBcIkVTXCJcclxuICAgICAgICAvLyB2YWx1ZTogNDU0MjIzMjcuNTZcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHN0cm9rZSB3aWR0aCBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBvdXQuZmxvd0dyYXBoXy5saW5rc1xyXG4gICAgICAgIG91dC5zdHJva2VXaWR0aFNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFswLCBtYXgoZGF0YSwgKGQpID0+IGQudmFsdWUpXSlcclxuICAgICAgICAgICAgLnJhbmdlKFsyLCAxMF0pXHJcblxyXG4gICAgICAgIGNyZWF0ZUZsb3dNYXBTVkcob3V0LmZsb3dHcmFwaF8pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHt9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL1RPRE86IGRlZmluZSBsZWdlbmRcclxuICAgICAgICByZXR1cm4gRmxvd0xlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY3JlYXRlIGEgbWFwIHdpdGggU2Fua2V5IGRpYWdyYW0gYW5kIG90aGVyIGVsZW1lbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGggLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIGRhdGEgZm9yIHRoZSBtYXBcclxuICAgICAqIGV4YW1wbGVHcmFwaCA9IHtcclxuICAgICAgICAgICAgICAgIG5vZGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyBpZDogJ0ZSJywgeDogNjgxLjE4NTE4MDA3NTkyNjMsIHk6IDIzMC4zMTEyNDc2MzY0ODU4MyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6ICdERScsIHg6IDgyNC41NDM3NzgyMTU0NDg5LCB5OiAxMjMuNzAzMDI2NDkwMzIxOTkgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBsaW5rczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgc291cmNlOiAnRlInLCB0YXJnZXQ6ICdERScsIHZhbHVlOiA4MjAxODM2OS43MiB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93TWFwU1ZHKGdyYXBoKSB7XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gb3V0LnN2Z19cclxuXHJcbiAgICAgICAgLy8gaWYgbm9kZXMgaW4gdGhlIGdyYXBoIGRvbnQgaGF2ZSBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdGhlbiB1c2UgbnV0czJqc29uIGNlbnRyb2lkcyBpbnN0ZWFkXHJcbiAgICAgICAgYWRkQ29vcmRpbmF0ZXNUb0dyYXBoKGdyYXBoKVxyXG5cclxuICAgICAgICB2YXIgeyBub2RlcywgbGlua3MgfSA9IHNhbmtleShncmFwaClcclxuXHJcbiAgICAgICAgLy8gRGVmaW5lIG1hcmtlciBhbmQgZ3JhZGllbnQgSURzXHJcbiAgICAgICAgY29uc3QgZGVmcyA9IHN2Zy5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgICAgIGNvbnN0IGFycm93SWQgPSBnZW5lcmF0ZVVuaXF1ZUlkKCdhcnJvdycpXHJcbiAgICAgICAgY29uc3QgYXJyb3dPdXRsaW5lSWQgPSBnZW5lcmF0ZVVuaXF1ZUlkKCdhcnJvdy1vdXRsaW5lJylcclxuICAgICAgICBjb25zdCBncmFkaWVudElkcyA9IGxpbmtzLm1hcCgoKSA9PiBnZW5lcmF0ZVVuaXF1ZUlkKCdncmFkaWVudCcpKVxyXG5cclxuICAgICAgICAvLyBBZGQgYXJyb3cgbWFya2Vyc1xyXG4gICAgICAgIGFkZEFycm93TWFya2VyKGRlZnMsIGFycm93SWQsIG91dC5mbG93Q29sb3JfKVxyXG4gICAgICAgIGFkZEFycm93TWFya2VyKGRlZnMsIGFycm93T3V0bGluZUlkLCAnI2ZmZmZmZicpXHJcblxyXG4gICAgICAgIC8vIEFkZCBmbG93IGdyYWRpZW50c1xyXG4gICAgICAgIGFkZEZsb3dHcmFkaWVudHMoZGVmcywgZ3JhZGllbnRJZHMsIGxpbmtzKVxyXG5cclxuICAgICAgICAvLyBEZWZpbmUgb3VyIGNvbnRhaW5lciBTVkdcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBzZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IHNhbmtleUNvbnRhaW5lciA9IHpvb21Hcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93LWNvbnRhaW5lcicpXHJcblxyXG4gICAgICAgIC8vIEFkZCBnZW9ncmFwaGljYWwgbGF5ZXJzXHJcbiAgICAgICAgYWRkT3ZlcmxheVBvbHlnb25zKHNhbmtleUNvbnRhaW5lciwgZ3JhcGgpXHJcblxyXG4gICAgICAgIC8vIEFkZCBTYW5rZXkgZmxvd3NcclxuICAgICAgICBhZGRTYW5rZXlGbG93cyhzYW5rZXlDb250YWluZXIsIGxpbmtzLCBhcnJvd0lkLCBhcnJvd091dGxpbmVJZCwgZ3JhZGllbnRJZHMpXHJcblxyXG4gICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIG5vZGVzIChmaWxsIGdhcHMpXHJcbiAgICAgICAgYWRkRmlsbEdhcHMoc2Fua2V5Q29udGFpbmVyLCBub2RlcylcclxuXHJcbiAgICAgICAgLy8gQWRkIGxhYmVscyB0byBub2Rlc1xyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXykgYWRkTGFiZWxzKHNhbmtleUNvbnRhaW5lciwgbm9kZXMpXHJcblxyXG4gICAgICAgIHJldHVybiBzdmcubm9kZSgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGdlb2dyYXBoaWNhbCBsYXllcnMgKHJlZ2lvbnMsIFBPSSBvdmVybGF5LCBib3JkZXJzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiBTVkcgY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZE92ZXJsYXlQb2x5Z29ucyhzdmcsIGdyYXBoKSB7XHJcbiAgICAgICAgY29uc3QgaW1wb3J0ZXJJZHMgPSBbXVxyXG4gICAgICAgIGNvbnN0IGV4cG9ydGVySWRzID0gW11cclxuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IG91dC5HZW9tZXRyaWVzLmdldFJlZ2lvbkZlYXR1cmVzKClcclxuICAgICAgICBpZiAoZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgZ3JhcGgubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBmZWF0dXJlLnByb3BlcnRpZXMuaWQpIHJldHVybiBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzSW1wb3J0ZXIgPSBncmFwaC5saW5rcy5zb21lKChsaW5rKSA9PiBsaW5rLnNvdXJjZSA9PSBub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ltcG9ydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVySWRzLnB1c2gobm9kZS5pZClcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlcklkcy5wdXNoKG5vZGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjb3VsZCBub3QgZmluZCBnZW9tZXRyeSBmb3InLCBub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy91cGRhdGUgZXhpc3RpbmcgcmVnaW9uIGZpbGxzXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG91dClcclxuICAgICAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG91dC5zdmdfLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHJcbiAgICAgICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCAocmVnaW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydGVySWRzLmluY2x1ZGVzKHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKSkgcmV0dXJuIG91dC5mbG93T3ZlcmxheUNvbG9yc19bMF1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZXJJZHMuaW5jbHVkZXMocmVnaW9uLnByb3BlcnRpZXMuaWQpKSByZXR1cm4gb3V0LmZsb3dPdmVybGF5Q29sb3JzX1sxXVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgbm9kZXMgaW4gdGhlIGdyYXBoIGRvbnQgaGF2ZSBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdGhlbiB1c2UgbnV0czJqc29uIGNlbnRyb2lkcyBpbnN0ZWFkXHJcbiAgICBmdW5jdGlvbiBhZGRDb29yZGluYXRlc1RvR3JhcGgoZ3JhcGgpIHtcclxuICAgICAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZS54ICYmICFub2RlLnkgJiYgb3V0Lkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBvdXQuR2VvbWV0cmllcy5jZW50cm9pZEZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBmZWF0dXJlLnByb3BlcnRpZXMuaWQpIHJldHVybiBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjZW50cm9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbkNvb3JkcyA9IG91dC5fcHJvamVjdGlvbihbY2VudHJvaWQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGNlbnRyb2lkLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXSlcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnggPSBzY3JlZW5Db29yZHNbMF1cclxuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSBzY3JlZW5Db29yZHNbMV1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignY291bGQgbm90IGZpbmQgY29vcmRpbmF0ZXMgZm9yJywgbm9kZS5pZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGNlbnRyb2lkcyBkYXRhLCBjYWxjdWxhdGUgb24gdGhlIGZseVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBvdXQuR2VvbWV0cmllcy5nZXRSZWdpb25GZWF0dXJlcygpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXMuZmluZCgoZmVhdHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09IGZlYXR1cmUucHJvcGVydGllcy5pZCkgcmV0dXJuIGZlYXR1cmVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50cm9pZCA9IGZlYXR1cmUucHJvcGVydGllcy5jZW50cm9pZCB8fCBvdXQuX3BhdGhGdW5jdGlvbi5jZW50cm9pZChmZWF0dXJlKVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuQ29vcmRzID0gb3V0Ll9wcm9qZWN0aW9uKFtjZW50cm9pZFswXSwgY2VudHJvaWRbMV1dKVxyXG4gICAgICAgICAgICAgICAgbm9kZS54ID0gc2NyZWVuQ29vcmRzWzBdXHJcbiAgICAgICAgICAgICAgICBub2RlLnkgPSBzY3JlZW5Db29yZHNbMV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgY29uc29sZS5sb2coZ3JhcGgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgRE9NIElEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gUHJlZml4IGZvciB0aGUgSURcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVuaXF1ZSBJRFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZUlkKHByZWZpeCkge1xyXG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gYXJyb3cgbWFya2VyIHRvIHRoZSBkZWZzIHNlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzIC0gRDMgc2VsZWN0aW9uIG9mIGRlZnNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIE1hcmtlciBJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gRmlsbCBjb2xvciBvZiB0aGUgbWFya2VyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEFycm93TWFya2VyKGRlZnMsIGlkLCBjb2xvcikge1xyXG4gICAgICAgIGRlZnMuYXBwZW5kKCdtYXJrZXInKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCBpZClcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCAxLjUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGNvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsICdNMCwwIHEwLDEsMC41LDEuNSBxLTAuNSwwLjUsLTAuNSwxLjUgcTAuNzUsLTAuNzUsMiwtMS41IHEtMS4yNSwtMC43NSwtMiwtMS41WicpXHJcblxyXG4gICAgICAgIC8vIGFkZCBhIGNvcHkgZm9yIG1vdXNlb3ZlciB3aXRoIGhvdmVyZWQgY29sb3JcclxuICAgICAgICBkZWZzLmFwcGVuZCgnbWFya2VyJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgaWQgKyAnbW91c2VvdmVyJylcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCAxLjUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMCBxMCwxLDAuNSwxLjUgcS0wLjUsMC41LC0wLjUsMS41IHEwLjc1LC0wLjc1LDIsLTEuNSBxLTEuMjUsLTAuNzUsLTIsLTEuNVonKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBsaW5lYXIgZ3JhZGllbnQgZGVmaW5pdGlvbnMgZm9yIGZsb3cgbGlua3NcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzIC0gRDMgc2VsZWN0aW9uIG9mIGRlZnNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdyYWRpZW50SWRzIC0gQXJyYXkgb2YgZ3JhZGllbnQgSURzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5rcyAtIFNhbmtleSBsaW5rcyBkYXRhXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZEZsb3dHcmFkaWVudHMoZGVmcywgZ3JhZGllbnRJZHMsIGxpbmtzKSB7XHJcbiAgICAgICAgZGVmcy5zZWxlY3RBbGwoJ2xpbmVhckdyYWRpZW50JylcclxuICAgICAgICAgICAgLmRhdGEobGlua3MpXHJcbiAgICAgICAgICAgIC5qb2luKCdsaW5lYXJHcmFkaWVudCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChfLCBpKSA9PiBncmFkaWVudElkc1tpXSlcclxuICAgICAgICAgICAgLmF0dHIoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCAoZCkgPT4gZC5zb3VyY2UueDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIChkKSA9PiBkLnRhcmdldC54MClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgKGQpID0+IGQueTApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIChkKSA9PiBkLnkxKVxyXG4gICAgICAgICAgICAuY2FsbCgoZykgPT4gZy5hcHBlbmQoJ3N0b3AnKS5hdHRyKCdvZmZzZXQnLCAnNSUnKS5hdHRyKCdzdG9wLWNvbG9yJywgb3V0LmZsb3dPdmVybGF5Q29sb3JzX1swXSkpXHJcbiAgICAgICAgICAgIC5jYWxsKChnKSA9PiBnLmFwcGVuZCgnc3RvcCcpLmF0dHIoJ29mZnNldCcsICc1MCUnKS5hdHRyKCdzdG9wLWNvbG9yJywgb3V0LmZsb3dDb2xvcl8pKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBTYW5rZXkgZmxvd3MgKGxpbmtzIHdpdGggbWFya2VycyBhbmQgZ3JhZGllbnRzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiBTVkdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmtzIC0gU2Fua2V5IGxpbmtzIGRhdGFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcnJvd0lkIC0gQXJyb3cgbWFya2VyIElEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJyb3dPdXRsaW5lSWQgLSBBcnJvdyBvdXRsaW5lIG1hcmtlciBJRFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3JhZGllbnRJZHMgLSBHcmFkaWVudCBJRHNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkU2Fua2V5Rmxvd3Moc3ZnLCBsaW5rcywgYXJyb3dJZCwgYXJyb3dPdXRsaW5lSWQsIGdyYWRpZW50SWRzKSB7XHJcbiAgICAgICAgY29uc3QgZmxvd3NHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93cy1ncm91cCcpXHJcblxyXG4gICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmssIGkpID0+IHtcclxuICAgICAgICAgICAgLy8gT3V0bGluZSBwYXRoXHJcbiAgICAgICAgICAgIGZsb3dzR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGxpbmspKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNmZmZmZmYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZsb3ctbGluay1vdXRsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBsaW5rLndpZHRoICsgMS41KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCBgdXJsKCMke2Fycm93T3V0bGluZUlkfSlgKVxyXG5cclxuICAgICAgICAgICAgLy8gTWFpbiBwYXRoXHJcbiAgICAgICAgICAgIGZsb3dzR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpKGxpbmspKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1saW5rJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBgdXJsKCMke2dyYWRpZW50SWRzW2ldfSlgKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGxpbmsud2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZH0pYClcclxuICAgICAgICAgICAgICAgIC8vIGFkZCBob3ZlciBlZmZlY3RcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3ZlcmVkQ29sb3IgPSBvdXQuaG92ZXJDb2xvcl9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBzdHJva2UgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignc3Ryb2tlJywgaG92ZXJlZENvbG9yKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcmtlci1lbmQgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZCArICdtb3VzZW92ZXInfSlgKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUb29sdGlwIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKGxpbmssIG91dCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgc3Ryb2tlIGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ3N0cm9rZScsIGB1cmwoIyR7Z3JhZGllbnRJZHNbaV19KWApXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgbWFya2VyLWVuZCB0byB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignbWFya2VyLWVuZCcsIGB1cmwoIyR7YXJyb3dJZH0pYClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9vbHRpcCBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHJlY3RhbmdsZXMgdG8gZmlsbCBnYXBzIGxlZnQgYnkgU2Fua2V5IGxpbmtzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnIC0gRDMgc2VsZWN0aW9uIG9mIFNWR1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgLSBTYW5rZXkgbm9kZXMgZGF0YVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRGaWxsR2FwcyhzdmcsIG5vZGVzKSB7XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1mbG93LWZpbGwtaW4tZ2FwcycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZGF0YShub2RlcylcclxuICAgICAgICAgICAgLmpvaW4oJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChkKSA9PiBkLmRlcHRoICYmIGQuaGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiBkLngwIC0gMC41KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiBkLnkwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQpID0+IGQueTEgLSBkLnkwKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIG91dC5mbG93Q29sb3JfKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGxhYmVscyBmb3IgZGF0YSBwb2ludHMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnIC0gRDMgc2VsZWN0aW9uIG9mIHRoZSBTVkcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkTGFiZWxzKHN2Zywgbm9kZXMpIHtcclxuICAgICAgICAvLyBGaWx0ZXIgdGhlIG5vZGVzXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWROb2RlcyA9IG5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS50YXJnZXRMaW5rcyAmJiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbHMnKVxyXG5cclxuICAgICAgICAvLyBBZGQgaGFsbyBlZmZlY3RcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxzU2hhZG93R3JvdXAgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbC1zaGFkb3cnKVxyXG4gICAgICAgICAgICBsYWJlbHNTaGFkb3dHcm91cFxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShmaWx0ZXJlZE5vZGVzKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gJ3N0YXJ0JyA6ICdlbmQnKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gZC54ICsgb3V0LmxhYmVsT2Zmc2V0WCA6IGQueCAtIG91dC5sYWJlbE9mZnNldFgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gZC55ICsgb3V0LmxhYmVsT2Zmc2V0WSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiBvdXQubGFiZWxGb3JtYXR0ZXIoZC52YWx1ZSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgbGFiZWxzXHJcbiAgICAgICAgY29uc3QgbGFiZWxzR3JvdXAgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1sYWJlbCcpXHJcbiAgICAgICAgLy9hZGQgYmFja2dyb3VuZFxyXG4gICAgICAgIC8vIEFkZCBiYWNrZ3JvdW5kIHJlY3RhbmdsZXMgYW5kIHRleHRcclxuICAgICAgICBjb25zdCBsYWJlbEVsZW1lbnRzID0gbGFiZWxzR3JvdXBcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpIC8vIFVzZSBhIGdyb3VwIGZvciBlYWNoIGxhYmVsIHRvIGNvbWJpbmUgcmVjdCBhbmQgdGV4dFxyXG4gICAgICAgICAgICAuZGF0YShmaWx0ZXJlZE5vZGVzKVxyXG4gICAgICAgICAgICAuam9pbignZycpIC8vIEFwcGVuZCBhIGdyb3VwIGZvciBlYWNoIGxhYmVsXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gYHRyYW5zbGF0ZSgke2QueH0sICR7ZC55fSlgKSAvLyBQb3NpdGlvbiBncm91cCBhdCB0aGUgbm9kZVxyXG5cclxuICAgICAgICAvLyBBZGQgdGV4dCBmaXJzdCB0byBjYWxjdWxhdGUgaXRzIHNpemVcclxuICAgICAgICBsYWJlbEVsZW1lbnRzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGFiZWwtdGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIChkKSA9PiAoZC54ID4gZC50YXJnZXRMaW5rc1swXS5zb3VyY2UueCA/ICdzdGFydCcgOiAnZW5kJykpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IChkLnggPiBkLnRhcmdldExpbmtzWzBdLnNvdXJjZS54ID8gb3V0LmxhYmVsT2Zmc2V0WCA6IC1vdXQubGFiZWxPZmZzZXRYKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQubGFiZWxPZmZzZXRZKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gb3V0LmxhYmVsRm9ybWF0dGVyKGQudmFsdWUpKVxyXG5cclxuICAgICAgICAvLyBBZGQgYmFja2dyb3VuZCByZWN0YW5nbGVzIGFmdGVyIHRleHQgaXMgcmVuZGVyZWRcclxuXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfLmJhY2tncm91bmRzKSB7XHJcbiAgICAgICAgICAgIGxhYmVsRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IHNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJveCA9IHRleHRFbGVtZW50Lm5vZGUoKS5nZXRCQm94KCkgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiB0aGUgdGV4dFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdYID0gNSAvLyBIb3Jpem9udGFsIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdZID0gMiAvLyBWZXJ0aWNhbCBwYWRkaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlY3RhbmdsZSBjZW50ZXJlZCBiZWhpbmQgdGhlIHRleHRcclxuICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAndGV4dCcpIC8vIEluc2VydCByZWN0IGJlZm9yZSB0ZXh0IGluIERPTVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGJib3gueCAtIHBhZGRpbmdYKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYmJveC55IC0gcGFkZGluZ1kpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYmJveC53aWR0aCArIDIgKiBwYWRkaW5nWClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYmJveC5oZWlnaHQgKyAyICogcGFkZGluZ1kpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIGFwcGVuZCBhIHJlY3RhbmdsZSBiZWhpbmQgdGhlIGxhYmVsXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRMYWJlbFJlY3QobGFiZWxUZXh0LCBjb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IDUgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDIgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHRleHQgZWxlbWVudCB0byBnZXQgdGhlIHNpemVcclxuICAgICAgICBjb25zdCBiYm94ID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlzaWJpbGl0eScsICdoaWRkZW4nKSAvLyBNYWtlIHRoZSB0ZW1wb3JhcnkgdGV4dCBpbnZpc2libGVcclxuICAgICAgICAgICAgLnRleHQobGFiZWxUZXh0KSAvLyBTZXQgdGhlIGxhYmVsIHRleHQgdG8gZ2V0IGl0cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgLm5vZGUoKVxyXG4gICAgICAgICAgICAuZ2V0QkJveCgpIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBiYm94LndpZHRoXHJcbiAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSBiYm94LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgYWZ0ZXIgZ2V0dGluZyB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdCgndGV4dFt2aXNpYmlsaXR5PVwiaGlkZGVuXCJdJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIHRvIGJlIGNlbnRlcmVkIG9uIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgeCA9IC1sYWJlbFdpZHRoIC8gMiAtIHBhZGRpbmdYIC8vIENlbnRlciB0aGUgcmVjdCBob3Jpem9udGFsbHlcclxuICAgICAgICBjb25zdCB5ID0gLWxhYmVsSGVpZ2h0IC8gMiAtIHBhZGRpbmdZIC8vIENlbnRlciB0aGUgcmVjdCB2ZXJ0aWNhbGx5XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHgpIC8vIFBvc2l0aW9uIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSkgLy8gUG9zaXRpb24gcmVjdCB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGxhYmVsV2lkdGggKyAyICogcGFkZGluZ1gpIC8vIFdpZHRoIG9mIHRoZSByZWN0IHdpdGggcGFkZGluZ1xyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgbGFiZWxIZWlnaHQgKyAyICogcGFkZGluZ1kpIC8vIEhlaWdodCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxhYmVsLWJhY2tncm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZyb20gdGhpcyBwb2ludCBvbiBhbGwgY29kZSBpcyByZWxhdGVkIHdpdGggc3BhdGlhbCBzYW5rZXkuIEFkb3B0ZWQgZnJvbSB0aGlzIG5vdGVib29rOiBodHRwczovL29ic2VydmFibGVocS5jb20vQGJheXJlL2RlY29uc3RydWN0ZWQtc2Fua2V5LWRpYWdyYW1cclxuICAgIC8vIFNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGpvZXdkYXZpZXMvZmxvdy1tYXAtb2YtZXVyb3BlXHJcbiAgICBmdW5jdGlvbiBjbG9uZSh7IG5vZGVzLCBsaW5rcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLm1hcCgoZCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgZCkpLCBsaW5rczogbGlua3MubWFwKChkKSA9PiBPYmplY3QuYXNzaWduKHt9LCBkKSkgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNhbmtleSh7IG5vZGVzLCBsaW5rcyB9KSB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGggPSBjbG9uZSh7IG5vZGVzLCBsaW5rcyB9KVxyXG4gICAgICAgIGNvbXB1dGVOb2RlTGlua3MoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVWYWx1ZXMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVEZXB0aHMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZU5vZGVIZWlnaHRzKGdyYXBoKVxyXG4gICAgICAgIGNvbXB1dGVOb2RlQnJlYWR0aHMoZ3JhcGgpXHJcbiAgICAgICAgY29tcHV0ZUxpbmtCcmVhZHRocyhncmFwaClcclxuICAgICAgICByZXR1cm4gZ3JhcGhcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUxpbmtzKHsgbm9kZXMsIGxpbmtzIH0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IFtpLCBub2RlXSBvZiBub2Rlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgbm9kZS5pbmRleCA9IGlcclxuICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcyA9IFtdXHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlQnlJZCA9IG5ldyBNYXAobm9kZXMubWFwKChkLCBpKSA9PiBbaWQoZCwgaSwgbm9kZXMpLCBkXSkpXHJcbiAgICAgICAgZm9yIChjb25zdCBbaSwgbGlua10gb2YgbGlua3MuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGxpbmsuaW5kZXggPSBpXHJcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBsaW5rXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykgc291cmNlID0gbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBzb3VyY2UpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JykgdGFyZ2V0ID0gbGluay50YXJnZXQgPSBmaW5kKG5vZGVCeUlkLCB0YXJnZXQpXHJcbiAgICAgICAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspXHJcbiAgICAgICAgICAgIHRhcmdldC50YXJnZXRMaW5rcy5wdXNoKGxpbmspXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIChsaW5rU29ydCAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gICAgIGZvciAoY29uc3QgeyBzb3VyY2VMaW5rcywgdGFyZ2V0TGlua3MgfSBvZiBub2Rlcykge1xyXG4gICAgICAgIC8vICAgICAgICAgc291cmNlTGlua3Muc29ydChsaW5rU29ydClcclxuICAgICAgICAvLyAgICAgICAgIHRhcmdldExpbmtzLnNvcnQobGlua1NvcnQpXHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZChub2RlQnlJZCwgaWQpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZUJ5SWQuZ2V0KGlkKVxyXG4gICAgICAgIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nOiAnICsgaWQpXHJcbiAgICAgICAgcmV0dXJuIG5vZGVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBuZXcgU2V0KG5vZGVzKVxyXG4gICAgICAgIGxldCBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgbGV0IHggPSAwXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuc2l6ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5kZXB0aCA9IHhcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQgfSBvZiBub2RlLnNvdXJjZUxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5hZGQodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgrK3ggPiBuKSB0aHJvdyBuZXcgRXJyb3IoJ2NpcmN1bGFyIGxpbmsnKVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dFxyXG4gICAgICAgICAgICBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlSGVpZ2h0cyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBuZXcgU2V0KG5vZGVzKVxyXG4gICAgICAgIGxldCBuZXh0ID0gbmV3IFNldCgpXHJcbiAgICAgICAgbGV0IHggPSAwXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuc2l6ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgc291cmNlIH0gb2Ygbm9kZS50YXJnZXRMaW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKHNvdXJjZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKyt4ID4gbikgdGhyb3cgbmV3IEVycm9yKCdjaXJjdWxhciBsaW5rJylcclxuICAgICAgICAgICAgY3VycmVudCA9IG5leHRcclxuICAgICAgICAgICAgbmV4dCA9IG5ldyBTZXQoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB2ZXJ0aWNhbGx5IHN0YWNrcyBsaW5rcyB3aXRoIHRoZSBzYW1lIG9yaWdpbi4gQ2F1c2VzIGlzc3VlcyBvbiB3b3JsZCBtYXBzXHJcbiAgICAvLyBmdW5jdGlvbiBjb21wdXRlTGlua0JyZWFkdGhzKHsgbm9kZXMgfSkge1xyXG4gICAgLy8gICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgLy8gICAgICAgICBsZXQgeTAgPSBub2RlLnkwOyAgLy8gSW5pdGlhbCB5MCBwb3NpdGlvblxyXG4gICAgLy8gICAgICAgICBsZXQgeTEgPSB5MDtcclxuICAgIC8vICAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIG5vZGUuc291cmNlTGlua3MpIHtcclxuICAgIC8vICAgICAgICAgICAgIGxpbmsueTAgPSB5MCArIGxpbmsud2lkdGggLyAyOyAgLy8gQWRqdXN0aW5nIHkwIGR5bmFtaWNhbGx5XHJcbiAgICAvLyAgICAgICAgICAgICB5MCArPSBsaW5rLndpZHRoOyAgLy8gTW92aW5nIHkwIGRvd24gZm9yIHRoZSBuZXh0IGxpbmtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2Ygbm9kZS50YXJnZXRMaW5rcykge1xyXG4gICAgLy8gICAgICAgICAgICAgbGluay55MSA9IHkxICsgbGluay53aWR0aCAvIDI7XHJcbiAgICAvLyAgICAgICAgICAgICB5MSArPSBsaW5rLndpZHRoO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVMaW5rQnJlYWR0aHMoeyBub2RlcyB9KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIG11bHRpcGxlIGxpbmtzIG9yaWdpbmF0ZSBmcm9tIHRoZSBzYW1lIHNvdXJjZSwgc2V0IHRoZW0gdG8gdGhlIHNhbWUgeTBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpeGVkWTAgPSBub2RlLnkgLy8gVXNlIHRoZSBub2RlJ3MgeSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay55MCA9IGZpeGVkWTAgLy8gRm9yY2UgYWxsIGxpbmtzIHRvIHVzZSB0aGUgc2FtZSB5MFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgZm9yIG90aGVyIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBsZXQgeTAgPSBub2RlLnkwXHJcbiAgICAgICAgICAgICAgICBsZXQgeTEgPSB5MFxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIG5vZGUuc291cmNlTGlua3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rLnkwID0geTAgKyBsaW5rLndpZHRoIC8gMlxyXG4gICAgICAgICAgICAgICAgICAgIHkwICs9IGxpbmsud2lkdGhcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLnRhcmdldExpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay55MSA9IHkxICsgbGluay53aWR0aCAvIDJcclxuICAgICAgICAgICAgICAgICAgICB5MSArPSBsaW5rLndpZHRoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaG9yaXpvbnRhbFNvdXJjZShkKSB7XHJcbiAgICAgICAgcmV0dXJuIFtkLnNvdXJjZS54MSwgZC55MF1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBob3Jpem9udGFsVGFyZ2V0KGQpIHtcclxuICAgICAgICByZXR1cm4gW2QudGFyZ2V0LngwLCBkLnkxXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlVmFsdWVzKHsgbm9kZXMgfSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBub2RlLnZhbHVlID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICBzdW0obm9kZS5zb3VyY2VMaW5rcywgKGQpID0+IGQudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgc3VtKG5vZGUudGFyZ2V0TGlua3MsIChkKSA9PiBkLnZhbHVlKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlb3JkZXJMaW5rcyhub2Rlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBzb3VyY2VMaW5rcywgdGFyZ2V0TGlua3MgfSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBzb3VyY2VMaW5rcy5zb3J0KGFzY2VuZGluZ1RhcmdldFkpXHJcbiAgICAgICAgICAgIHRhcmdldExpbmtzLnNvcnQoYXNjZW5kaW5nU291cmNlWSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXNjZW5kaW5nVGFyZ2V0WSA9IChhLCBiKSA9PiBhLnRhcmdldC55IC0gYi50YXJnZXQueVxyXG4gICAgY29uc3QgYXNjZW5kaW5nU291cmNlWSA9IChhLCBiKSA9PiBhLnNvdXJjZS55IC0gYi5zb3VyY2UueVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlQnJlYWR0aHMoeyBub2RlcyB9KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG91dC5zdHJva2VXaWR0aFNjYWxlKG5vZGUudmFsdWUpXHJcbiAgICAgICAgICAgIG5vZGUueDAgPSBub2RlLngxID0gbm9kZS54XHJcbiAgICAgICAgICAgIG5vZGUueTAgPSBub2RlLnkgLSBoZWlnaHQgLyAyXHJcbiAgICAgICAgICAgIG5vZGUueTEgPSBub2RlLnkwICsgaGVpZ2h0XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLnNvdXJjZUxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLndpZHRoID0gb3V0LnN0cm9rZVdpZHRoU2NhbGUobGluay52YWx1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZW9yZGVyTGlua3Mobm9kZXMpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaWQgPSAoZCkgPT4gZC5pZCAvLyB1c2VkIGluIHNhbmtleSBpbXBvcnRcclxuXHJcbiAgICBjb25zdCBzYW5rZXlMaW5rSG9yaXpvbnRhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbGlua0hvcml6b250YWwoKS5zb3VyY2UoaG9yaXpvbnRhbFNvdXJjZSkudGFyZ2V0KGhvcml6b250YWxUYXJnZXQpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG5jb25zdCBmbG93TWFwVG9vbHRpcEZ1bmN0aW9uID0gZnVuY3Rpb24gKGxpbmssIG1hcCkge1xyXG4gICAgY29uc3QgYnVmID0gW11cclxuXHJcbiAgICAvLyBIZWFkZXIgd2l0aCByZWdpb24gbmFtZSBhbmQgSURcclxuICAgIGNvbnN0IHRpdGxlID0gYCR7bGluay5zb3VyY2UuaWR9ID4gJHtsaW5rLnRhcmdldC5pZH1gXHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPlxyXG4gICAgICAgICAgICA8Yj4ke3RpdGxlfTwvYj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgLy8gVmFsdWVcclxuICAgIGJ1Zi5wdXNoKGA8ZGl2IGNsYXNzPSdlc3RhdC12aXMtdG9vbHRpcC10ZXh0Jz5cclxuICAgICAgICAke2xpbmsudGFyZ2V0LnZhbHVlfVxyXG4gICAgICAgIDwvZGl2PmApXHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNjYWxlU3FydCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgYXJjLCBwaWUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgZXh0ZW50LCBzdW0gfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVPclJkLCBzY2hlbWVDYXRlZ29yeTEwIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJ1xyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIFBpZWNoYXJ0TGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtcGllY2hhcnRzJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRSZWdpb25zU2VsZWN0b3IsIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb3BvcnRpb25hbCBwaWUgY2hhcnQgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIHRydWUsICdwaWUnKVxyXG5cclxuICAgIC8vIHBpZSBjaGFydHNcclxuICAgIG91dC5waWVNaW5SYWRpdXNfID0gNVxyXG4gICAgb3V0LnBpZU1heFJhZGl1c18gPSAxNVxyXG4gICAgb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXNfID0gMFxyXG4gICAgb3V0LnBpZVN0cm9rZUZpbGxfID0gJ3doaXRlJ1xyXG4gICAgb3V0LnBpZVN0cm9rZVdpZHRoXyA9IDAuM1xyXG5cclxuICAgIC8vdG9vbHRpcCBwaWUgY2hhcnRcclxuICAgIG91dC50b29sdGlwUGllUmFkaXVzXyA9IDQwXHJcbiAgICBvdXQudG9vbHRpcFBpZUlubmVyUmFkaXVzXyA9IDBcclxuXHJcbiAgICAvL2NvbG9ycyAtIGluZGV4ZWQgYnkgY2F0ZWdvcnkgY29kZVxyXG4gICAgb3V0LmNhdENvbG9yc18gPSB1bmRlZmluZWRcclxuICAgIC8vbGFiZWxzIC0gaW5kZXhlZCBieSBjYXRlZ29yeSBjb2RlXHJcbiAgICBvdXQuY2F0TGFiZWxzXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vICdvdGhlcicgc2VjdGlvbiBvZiB0aGUgcGllIGNoYXJ0IGZvciB3aGVuICdvdXQudG90YWxDb2RlXycgaXMgZGVmaW5lZCB3aXRoIHN0YXRQaWUoKVxyXG4gICAgb3V0LnBpZU90aGVyQ29sb3JfID0gJyNGRkNDODAnXHJcbiAgICBvdXQucGllT3RoZXJUZXh0XyA9ICdPdGhlcidcclxuXHJcbiAgICAvL3Nob3cgcGllY2hhcnRzIG9ubHkgd2hlbiBkYXRhIGZvciBhbGwgY2F0ZWdvcmllcyBpcyBjb21wbGV0ZS5cclxuICAgIC8vT3RoZXJ3aXNlLCBjb25zaWRlciB0aGUgcmVnaW9ucyBhcyBiZWluZyB3aXRoIG5vIGRhdGEgYXQgYWxsLlxyXG4gICAgb3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlXyA9IGZhbHNlXHJcblxyXG4gICAgb3V0LnNpemVDbGFzc2lmaWVyXyA9IG51bGwgLy9kMyBzY2FsZSBmb3Igc2NhbGluZyBwaWUgc2l6ZXNcclxuICAgIG91dC5zdGF0UGllXyA9IG51bGxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7W1xyXG4gICAgICAgICdjYXRDb2xvcnNfJyxcclxuICAgICAgICAnY2F0TGFiZWxzXycsXHJcbiAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwaWVNYXhSYWRpdXNfJyxcclxuICAgICAgICAncGllTWluUmFkaXVzXycsXHJcbiAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXNfJyxcclxuICAgICAgICAncGllT3RoZXJDb2xvcl8nLFxyXG4gICAgICAgICdwaWVPdGhlclRleHRfJyxcclxuICAgICAgICAncGllU3Ryb2tlRmlsbF8nLFxyXG4gICAgICAgICdwaWVTdHJva2VXaWR0aF8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnY2F0Q29sb3JzJyxcclxuICAgICAgICAgICAgJ2NhdExhYmVscycsXHJcbiAgICAgICAgICAgICdzaG93T25seVdoZW5Db21wbGV0ZScsXHJcbiAgICAgICAgICAgICdub0RhdGFGaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAncGllTWF4UmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZU1pblJhZGl1cycsXHJcbiAgICAgICAgICAgICdwaWVDaGFydElubmVyUmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZU90aGVyQ29sb3InLFxyXG4gICAgICAgICAgICAncGllT3RoZXJUZXh0JyxcclxuICAgICAgICAgICAgJ3BpZVN0cm9rZUZpbGwnLFxyXG4gICAgICAgICAgICAncGllU3Ryb2tlV2lkdGgnLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLyoqIFRoZSBjb2RlcyBvZiB0aGUgY2F0ZWdvcmllcyB0byBjb25zaWRlciBmb3IgdGhlIGNvbXBvc2l0aW9uLiAqL1xyXG4gICAgb3V0LnN0YXRDb2Rlc18gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUaGUgY29kZSBvZiB0aGUgXCJ0b3RhbFwiIGNhdGVnb3J5IGluIHRoZSBldXJvc3RhdCBkYXRhYmFzZSAqL1xyXG4gICAgb3V0LnRvdGFsQ29kZV9fID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRlZmluZSBhIHBpZSBjaGFydCBtYXAgZWFzaWx5LCB3aXRob3V0IHJlcGV0aXRpb24gb2YgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBPbmx5IGZvciBldXJvYmFzZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0IEEgcGF0dGVybiBmb3IgdGhlIHN0YXQgZGF0YSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaW0gVGhlIGRpbWVuc2lvbiAoZGVmaW5lZCBpbiBldXJvc3RhdCBSRVNUIEFQSSkgb2YgdGhlIGNvbXBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29kZXMgVGhlIGNhdGVnb3J5IGNvZGVzIG9mIHRoZSBjb21wb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxzIE9wdGlvbmFsOiBUaGUgbGFiZWxzIGZvciB0aGUgY2F0ZWdvcnkgY29kZXNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBPcHRpb25hbDogVGhlIGNvbG9ycyBmb3IgdGhlIGNhdGVnb3J5XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdENvZGUgT3B0aW9uYWw6IFRoZSBjYXRlZ29yeSBjb2RlIG9mIHRoZSB0b3RhbCAodXNlZCB0byBjYWxjdWxhdGUgdG90YWwgJiBcIm90aGVyXCIgdmFsdWVzIGlmIGNvZGVzIGFycmF5IGRvbnQgcmVwcmVzZW50IGFsbCBwb3NzaWJsZSBjYXRlZ29yaWVzKVxyXG4gICAgICovXHJcbiAgICBvdXQuc3RhdFBpZSA9IGZ1bmN0aW9uIChzdGF0LCBkaW0sIGNvZGVzLCBsYWJlbHMsIGNvbG9ycywgdENvZGUpIHtcclxuICAgICAgICAvL2FkZCBvbmUgZGF0YXNldCAoc3RhdCkgY29uZmlnIGZvciBlYWNoIGNhdGVnb3J5IChjb2RlKVxyXG4gICAgICAgIHN0YXQuZmlsdGVycyA9IHN0YXQuZmlsdGVycyB8fCB7fVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9jYXRlZ29yeSBjb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBjb2Rlc1tpXVxyXG4gICAgICAgICAgICBzdGF0LmZpbHRlcnNbZGltXSA9IGNvZGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHtcclxuICAgICAgICAgICAgICAgIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2NfLmZpbHRlcnMgPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdC5maWx0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBzY18uZmlsdGVyc1trZXldID0gc3RhdC5maWx0ZXJzW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQuc3RhdChjb2RlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgcmV0cmlldmUgYW5kIGFzc2lnbiBjb2xvclxyXG4gICAgICAgICAgICBpZiAoY29sb3JzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzXyA9IG91dC5jYXRDb2xvcnNfIHx8IHt9XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzX1tjb2RlXSA9IGNvbG9yc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChsYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfW2NvZGVdID0gbGFiZWxzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IG91dC5zdGF0Q29kZXNfXHJcbiAgICAgICAgb3V0LnN0YXRDb2Rlc18gPSBjb2Rlc1xyXG5cclxuICAgICAgICAvL3NldCBvdXQudG90YWxDb2RlX1xyXG4gICAgICAgIGlmICh0Q29kZSkge1xyXG4gICAgICAgICAgICBvdXQudG90YWxDb2RlXyA9IHRDb2RlXHJcbiAgICAgICAgICAgIHN0YXQuZmlsdGVyc1tkaW1dID0gdENvZGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIHNjXy5maWx0ZXJzID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQuZmlsdGVycykgc2NfLmZpbHRlcnNba2V5XSA9IHN0YXQuZmlsdGVyc1trZXldXHJcbiAgICAgICAgICAgIG91dC5zdGF0KHRDb2RlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL3doZW4gdG90YWwgY29kZSBpcyB1c2VkLCBhbiAnb3RoZXInIHNlY3Rpb24gaXMgYWRkZWQgdG8gdGhlIHBpZVxyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzX1snb3RoZXInXSA9IG91dC5waWVPdGhlckNvbG9yX1xyXG4gICAgICAgICAgICBvdXQuY2F0TGFiZWxzX1snb3RoZXInXSA9IG91dC5waWVPdGhlclRleHRfXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgLy9pZiBub3QgcHJvdmlkZWQsIGdldCBsaXN0IG9mIHN0YXQgY29kZXMgZnJvbSB0aGUgbWFwIHN0YXQgZGF0YVxyXG4gICAgICAgIGlmICghb3V0LnN0YXRDb2Rlc18pIHtcclxuICAgICAgICAgICAgLy9nZXQgbGlzdCBvZiBzdGF0IGNvZGVzLlxyXG4gICAgICAgICAgICBvdXQuc3RhdENvZGVzXyA9IE9iamVjdC5rZXlzKG91dC5zdGF0RGF0YV8pXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIFwiZGVmYXVsdFwiLCBpZiBwcmVzZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3V0LnN0YXRDb2Rlc18uaW5kZXhPZignZGVmYXVsdCcpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSBvdXQuc3RhdENvZGVzXy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RlZmluZSBzaXplIHNjYWxpbmcgZnVuY3Rpb25cclxuICAgICAgICBsZXQgZG9tYWluID0gZ2V0RGF0YXNldE1heE1pbigpXHJcbiAgICAgICAgaWYgKCFpc05hTihkb21haW5bMF0pKSB7XHJcbiAgICAgICAgICAgIG91dC5zaXplQ2xhc3NpZmllcl8gPSBzY2FsZVNxcnQoKS5kb21haW4oZG9tYWluKS5yYW5nZShbb3V0LnBpZU1pblJhZGl1c18sIG91dC5waWVNYXhSYWRpdXNfXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgYnVpbGQgZGVmYXVsdCBjb2xvciByYW1wXHJcbiAgICAgICAgaWYgKCFvdXQuY2F0Q29sb3JzXykge1xyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzKHt9KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5zdGF0Q29kZXNfLmxlbmd0aDsgaSsrKSBvdXQuY2F0Q29sb3JzX1tvdXQuc3RhdENvZGVzX1tpXV0gPSBzY2hlbWVDYXRlZ29yeTEwW2kgJSAxMF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgaW5pdGlhbGlzZSBjYXRlZ29yeSBsYWJlbHNcclxuICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcblxyXG4gICAgICAgIC8vYnVpbGQgYW5kIGFzc2lnbiBwaWUgY2hhcnRzIHRvIHRoZSByZWdpb25zXHJcbiAgICAgICAgLy9jb2xsZWN0IG51dHMgaWRzIGZyb20gZyBlbGVtZW50cy4gVE9ETzogZmluZCBiZXR0ZXIgd2F5IG9mIHNoYXJpbmcgcmVnaW9ucyB3aXRoIHBpZXNcclxuICAgICAgICBsZXQgcmVnaW9uRmVhdHVyZXMgPSBbXVxyXG4gICAgICAgIGlmIChvdXQuc3ZnXykge1xyXG4gICAgICAgICAgICBsZXQgcyA9IG91dC5zdmdfLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ltID0gcy5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAgICAgc3ltLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbkZlYXR1cmVzLnB1c2gocmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncGllXycgKyByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgcmVnaW9uIGhvdmVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihvdXQpXHJcbiAgICAgICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGFkZFBpZUNoYXJ0c1RvTWFwKHJlZ2lvbkZlYXR1cmVzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNvbXB1dGUgY29tcG9zaXRpb24gZm9yIHJlZ2lvbiBpZCwgZm9yIGVhY2ggY2F0ZWdvcnkuXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGgsIGZvciBlYWNoIGNhdGVnb3J5LCB0aGUgc2hhcmUgWzAsMV0gb2YgdGhlIGNhdGVnb3J5LlxyXG4gICAgICogQHBhcmFtIHsqfSBpZFxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGxldCBjb21wID0ge30sXHJcbiAgICAgICAgICAgIHN1bSA9IDBcclxuICAgICAgICAvL2dldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5LiBDb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL3JldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuc3RhdENvZGVzX1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzID0gb3V0LnN0YXREYXRhKHNjKS5nZXQoaWQpXHJcblxyXG4gICAgICAgICAgICAvL2Nhc2Ugd2hlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xyXG4gICAgICAgICAgICBpZiAoIXMgfHwgKHMudmFsdWUgIT0gMCAmJiAhcy52YWx1ZSkgfHwgaXNOYU4ocy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZWxzZSBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21wW3NjXSA9IHMudmFsdWVcclxuICAgICAgICAgICAgc3VtICs9IHMudmFsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gb3V0LnRvdGFsQ29kZV8gaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIHN1bSBpbnN0ZWFkIG9mIHRoZSBzdW0gb2YgdGhlIHNwZWNpZmllZCBjYXRlZ29yaWVzLlxyXG4gICAgICAgIGlmIChvdXQudG90YWxDb2RlXykge1xyXG4gICAgICAgICAgICBsZXQgcyA9IG91dC5zdGF0RGF0YShvdXQudG90YWxDb2RlXykuZ2V0KGlkKVxyXG4gICAgICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICAgICAgc3VtID0gcy52YWx1ZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VtID09IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jYXNlIHdoZW4gbm8gZGF0YVxyXG4gICAgICAgIGlmIChzdW0gPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL2NvbXB1dGUgcmF0aW9zXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb21wW291dC5zdGF0Q29kZXNfW2ldXSAvPSBzdW1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYWRkIFwib3RoZXJcIiBjYXRlZ29yeSB3aGVuIG91dC50b3RhbENvZGVfIGlzIHVzZWRcclxuICAgICAgICBpZiAob3V0LnRvdGFsQ29kZV8pIHtcclxuICAgICAgICAgICAgbGV0IHRvdGFsUGVyYyA9IDBcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbXApIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsUGVyYyA9IHRvdGFsUGVyYyArIGNvbXBba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbXBbJ290aGVyJ10gPSAxIC0gdG90YWxQZXJjXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGdldERhdGFzZXRNYXhNaW5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXRzIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHRvdGFsIG9mIGFsbCBkaW1lbnNpb25zIGNvbWJpbmVkIGZvciBlYWNoIHJlZ2lvbi4gVXNlZCB0byBkZWZpbmUgdGhlIGRvbWFpbiBvZiB0aGUgcGllIHNpemUgc2NhbGluZyBmdW5jdGlvbi5cclxuICAgICAqIEByZXR1cm5zIFttaW4sbWF4XVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXREYXRhc2V0TWF4TWluKCkge1xyXG4gICAgICAgIGxldCB0b3RhbHMgPSBbXVxyXG4gICAgICAgIGxldCBzZWwgPSBvdXQuc3ZnKCkuc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJykuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykuZGF0YSgpXHJcblxyXG4gICAgICAgIHNlbC5mb3JFYWNoKChyZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaWQgPSByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGdldFJlZ2lvblRvdGFsKGlkKVxyXG4gICAgICAgICAgICBpZiAodG90YWwpIHtcclxuICAgICAgICAgICAgICAgIHRvdGFscy5wdXNoKHRvdGFsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IG1pbm1heCA9IGV4dGVudCh0b3RhbHMpXHJcbiAgICAgICAgcmV0dXJuIG1pbm1heFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFic29sdXRlIHRvdGFsIHZhbHVlIG9mIGNvbWJpbmVkIHN0YXRpc3RpY2FsIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyByZWdpb24uIEUuZyB0b3RhbCBsaXZlc3RvY2tcclxuICAgICAqIEBwYXJhbSB7Kn0gaWQgbnV0cyByZWdpb24gaWRcclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0UmVnaW9uVG90YWwgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgc3VtID0gMFxyXG4gICAgICAgIGxldCBzXHJcbiAgICAgICAgaWYgKG91dC50b3RhbENvZGVfKSB7XHJcbiAgICAgICAgICAgIC8vd2hlbiB0b3RhbCBpcyBhIHN0YXQgY29kZVxyXG4gICAgICAgICAgICBzID0gb3V0LnN0YXREYXRhKG91dC50b3RhbENvZGVfKS5nZXQoaWQpXHJcbiAgICAgICAgICAgIC8vY2FzZSB3aGVuIHNvbWUgZGF0YSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2dldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5LiBDb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LnN0YXRDb2Rlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vcmV0cmlldmUgY29kZSBhbmQgc3RhdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuc3RhdENvZGVzX1tpXVxyXG4gICAgICAgICAgICAgICAgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KGlkKVxyXG4gICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gc29tZSBkYXRhIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN1bSArPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2FzZSB3aGVuIG5vIGRhdGFcclxuICAgICAgICBpZiAoc3VtID09IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gc3VtXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkUGllQ2hhcnRzVG9NYXAocmVnaW9uRmVhdHVyZXMpIHtcclxuICAgICAgICByZWdpb25GZWF0dXJlcy5mb3JFYWNoKChyZWdpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgICAgICAgICAvL3ByZXBhcmUgZGF0YSBmb3IgcGllIGNoYXJ0XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXVxyXG4gICAgICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmVnaW9uSWQpXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXApIGRhdGEucHVzaCh7IGNvZGU6IGtleSwgdmFsdWU6IGNvbXBba2V5XSB9KVxyXG5cclxuICAgICAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICAgICAgLy8gY2FuIGJlIG1vcmUgdGhhbiBvbmUgY2VudGVyIHBvaW50IGZvciBlYWNoIG51dHMgSUQgKGUuZy4gTWFsdGEgd2hlbiBpbmNsdWRlZCBpbiBpbnNldHMpXHJcbiAgICAgICAgICAgIGxldCBub2RlcyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoJyNwaWVfJyArIHJlZ2lvbklkKVxyXG5cclxuICAgICAgICAgICAgLy8gZGVmaW5lIHJhZGl1c1xyXG4gICAgICAgICAgICBjb25zdCByID0gb3V0LnNpemVDbGFzc2lmaWVyXyhnZXRSZWdpb25Ub3RhbChyZWdpb25JZCkpXHJcbiAgICAgICAgICAgIGNvbnN0IGlyID0gb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXNfXHJcblxyXG4gICAgICAgICAgICAvL21ha2UgcGllIGNoYXJ0LiBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9waWUtY2hhcnRcclxuICAgICAgICAgICAgY29uc3QgcGllXyA9IHBpZSgpXHJcbiAgICAgICAgICAgICAgICAuc29ydChudWxsKVxyXG4gICAgICAgICAgICAgICAgLnZhbHVlKChkKSA9PiBkLnZhbHVlKVxyXG4gICAgICAgICAgICBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgb3V0LnBpZVN0cm9rZUZpbGxfKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIG91dC5waWVTdHJva2VXaWR0aF8gKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BpZWNoYXJ0JylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocGllXyhkYXRhKSlcclxuICAgICAgICAgICAgICAgIC5qb2luKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jYXRDb2xvcnNfW2QuZGF0YS5jb2RlXSB8fCAnbGlnaHRncmF5J1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsX19fJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNhdENvbG9yc19bZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NvZGUnLCAoZCkgPT4gZC5kYXRhLmNvZGUpIC8vZm9yIG1vdXNlb3ZlciBsZWdlbmQgaGlnaGxpZ2h0aW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGFyYygpLmlubmVyUmFkaXVzKGlyKS5vdXRlclJhZGl1cyhyKSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYSB0aGljayBzdHJva2Ugd2lkdGggdG8gdGhlIHBhcmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gc2VsZWN0KHNlbC5ub2RlKCkucGFyZW50Tm9kZSlcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKS5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJykgLy8gU2V0IHN0cm9rZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZWdpb24sIG91dCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdHJva2VcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBzZWxlY3Qoc2VsLm5vZGUoKS5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgb3V0LnBpZVN0cm9rZVdpZHRoXykuc3R5bGUoJ3N0cm9rZScsIG91dC5waWVTdHJva2VGaWxsXykgLy8gU2V0IHN0cm9rZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gUGllY2hhcnRMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgICAgIC8vZ2V0IHRvb2x0aXBcclxuICAgICAgICBjb25zdCB0cCA9IHNlbGVjdCgnI3Rvb2x0aXBfZXVyb3N0YXQnKVxyXG5cclxuICAgICAgICAvL2NsZWFyXHJcbiAgICAgICAgdHAuaHRtbCgnJylcclxuICAgICAgICB0cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICBpZiAocmcucHJvcGVydGllcy5pZCkge1xyXG4gICAgICAgICAgICAvL25hbWUgYW5kIGNvZGVcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VzdGF0LXZpcy10b29sdGlwLWJhcicpXHJcbiAgICAgICAgICAgICAgICAuaHRtbChyZy5wcm9wZXJ0aWVzLm5hICsgJyAoJyArIHJnLnByb3BlcnRpZXMuaWQgKyAnKScpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VzdGF0LXZpcy10b29sdGlwLWJhcicpLmh0bWwocmcucHJvcGVydGllcy5uYSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBkYXRhIGZvciBwaWUgY2hhcnRcclxuICAgICAgICBjb25zdCBkYXRhID0gW11cclxuICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wKSBkYXRhLnB1c2goeyBjb2RlOiBrZXksIHZhbHVlOiBjb21wW2tleV0gfSlcclxuXHJcbiAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKS5odG1sKG91dC5ub0RhdGFUZXh0KCkpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICAvLyBzZXQgdGhlIGRpbWVuc2lvbnMgYW5kIG1hcmdpbnMgb2YgdGhlIGdyYXBoXHJcbiAgICAgICAgbGV0IHdpZHRoID0gMTUwXHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDE1MFxyXG4gICAgICAgIGxldCBtYXJnaW4gPSAyNVxyXG5cclxuICAgICAgICAvLyBUaGUgcmFkaXVzIG9mIHRoZSBwaWVwbG90IGlzIGhhbGYgdGhlIHdpZHRoIG9yIGhhbGYgdGhlIGhlaWdodCAoc21hbGxlc3Qgb25lKS4gSSBzdWJ0cmFjdCBhIGJpdCBvZiBtYXJnaW4uXHJcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIC0gbWFyZ2luXHJcblxyXG4gICAgICAgIC8vd2lkdGggPSB0cC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0cC5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtcGllY2hhcnQtY29udGFpbmVyJylcclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtcGllY2hhcnQtc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdib3gnLCBgMCwgMCwgJHt3aWR0aH0sICR7aGVpZ2h0fWApXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0IC0gbWFyZ2luIC8gMilcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB3aWR0aCAvIDIgKyAnLCcgKyBoZWlnaHQgLyAyICsgJyknKVxyXG5cclxuICAgICAgICAvL21ha2UgcGllIGNoYXJ0LiBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9waWUtY2hhcnRcclxuICAgICAgICBjb25zdCBwaWVfID0gcGllKClcclxuICAgICAgICAgICAgLnNvcnQobnVsbClcclxuICAgICAgICAgICAgLnZhbHVlKChkKSA9PiBkLnZhbHVlKVxyXG5cclxuICAgICAgICBjb25zdCBpbm5lckFyYyA9IGFyYygpXHJcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKSAvLyBUaGlzIGlzIHRoZSBzaXplIG9mIHRoZSBkb251dCBob2xlXHJcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgKiAwLjgpXHJcblxyXG4gICAgICAgIC8vIEFub3RoZXIgYXJjIHRoYXQgd29uJ3QgYmUgZHJhd24uIEp1c3QgZm9yIGxhYmVscyBwb3NpdGlvbmluZ1xyXG4gICAgICAgIGNvbnN0IG91dGVyQXJjID0gYXJjKClcclxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuXHJcbiAgICAgICAgY29uc3QgcGllRGF0YSA9IHBpZV8oZGF0YSlcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCdhbGxTbGljZXMnKVxyXG4gICAgICAgICAgICAuZGF0YShwaWVEYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBpbm5lckFyYylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2F0Q29sb3JzKClbZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjcpXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgcG9seWxpbmVzIGJldHdlZW4gY2hhcnQgYW5kIGxhYmVsczpcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCdhbGxQb2x5bGluZXMnKVxyXG4gICAgICAgICAgICAuZGF0YShwaWVEYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwb2x5bGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLmRhdGEudmFsdWUgPiAwLjAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQSA9IGlubmVyQXJjLmNlbnRyb2lkKGQpIC8vIGxpbmUgaW5zZXJ0aW9uIGluIHRoZSBzbGljZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc0IgPSBvdXRlckFyYy5jZW50cm9pZChkKSAvLyBsaW5lIGJyZWFrOiB3ZSB1c2UgdGhlIG90aGVyIGFyYyBnZW5lcmF0b3IgdGhhdCBoYXMgYmVlbiBidWlsdCBvbmx5IGZvciB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpIC8vIExhYmVsIHBvc2l0aW9uID0gYWxtb3N0IHRoZSBzYW1lIGFzIHBvc0JcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWRhbmdsZSA9IGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDIgLy8gd2UgbmVlZCB0aGUgYW5nbGUgdG8gc2VlIGlmIHRoZSBYIHBvc2l0aW9uIHdpbGwgYmUgYXQgdGhlIGV4dHJlbWUgcmlnaHQgb3IgZXh0cmVtZSBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zQ1swXSA9IHJhZGl1cyAqIDAuOTUgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKSAvLyBtdWx0aXBseSBieSAxIG9yIC0xIHRvIHB1dCBpdCBvbiB0aGUgcmlnaHQgb3Igb24gdGhlIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Bvc0EsIHBvc0IsIHBvc0NdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbGFiZWxzOlxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJ2FsbExhYmVscycpXHJcbiAgICAgICAgICAgIC5kYXRhKHBpZURhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuZGF0YS52YWx1ZSA+IDAuMDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IChkLmRhdGEudmFsdWUgKiAxMDApLnRvRml4ZWQoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4obikpIHJldHVybiBuICsgJyUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpXHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgICAgICBwb3NbMF0gPSByYWRpdXMgKiAwLjk5ICogKG1pZGFuZ2xlIDwgTWF0aC5QSSA/IDEgOiAtMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3MgKyAnKSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkYW5nbGUgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG5cclxuICAgICAgICAvLyBhZGQgcmVnaW9uIHZhbHVlcyB0byB0b29sdGlwXHJcbiAgICAgICAgbGV0IGJyZWFrZG93bkRpdiA9IHRwLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnZW0tdG9vbHRpcC1waWVjaGFydC1icmVha2Rvd24nKVxyXG5cclxuICAgICAgICAvLyBzaG93IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBjb2RlIGFuZCBzdGF0IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IHNjID0gb3V0LnN0YXRDb2Rlc19baV1cclxuICAgICAgICAgICAgY29uc3QgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzIGFuZCBzLnZhbHVlIGFyZSB2YWxpZCAoaGFuZGxlIG51bGwsIHVuZGVmaW5lZCwgb3IgMClcclxuICAgICAgICAgICAgaWYgKHMgJiYgcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHMudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdHJpbmcgPSBgPHN0cm9uZz4ke291dC5jYXRMYWJlbHNfW3NjXX08L3N0cm9uZz46ICR7cy52YWx1ZS50b0ZpeGVkKCl9PGJyPmBcclxuICAgICAgICAgICAgICAgIGJyZWFrZG93bkRpdi5odG1sKGJyZWFrZG93bkRpdi5odG1sKCkgKyBzdHJpbmcpIC8vIHNhZmVseSB1cGRhdGUgdGhlIEhUTUxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd3JpdGUgdG90YWwgKGhhbmRsZSBudWxsLCB1bmRlZmluZWQsIG9yIDAgdmFsdWVzIGZvciB0b3RhbClcclxuICAgICAgICBsZXQgdG90YWwgPSBnZXRSZWdpb25Ub3RhbChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgIGlmICh0b3RhbCAhPT0gdW5kZWZpbmVkICYmIHRvdGFsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGJyZWFrZG93bkRpdi5odG1sKGJyZWFrZG93bkRpdi5odG1sKCkgKyBgPHN0cm9uZz5Ub3RhbDwvc3Ryb25nPjogJHt0b3RhbC50b0ZpeGVkKCl9PGJyPmApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzY2FsZVNxcnQsIHNjYWxlTGluZWFyLCBzY2FsZVF1YW50aWxlLCBzY2FsZVF1YW50aXplLCBzY2FsZVRocmVzaG9sZCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG4vLyBpbXBvcnQge2V4dGVudH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVPclJkIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJ1xyXG5pbXBvcnQgeyBmb3JjZVNpbXVsYXRpb24sIGZvcmNlTWFueUJvZHksIGZvcmNlQ2VudGVyLCBmb3JjZUNvbGxpZGUsIGZvcmNlWCwgZm9yY2VZIH0gZnJvbSAnZDMtZm9yY2UnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgUHJvcG9ydGlvbmFsU3ltYm9sTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtcHJvcG9ydGlvbmFsLXN5bWJvbHMnXHJcbmltcG9ydCB7IHN5bWJvbCwgc3ltYm9sQ2lyY2xlLCBzeW1ib2xEaWFtb25kLCBzeW1ib2xTdGFyLCBzeW1ib2xDcm9zcywgc3ltYm9sU3F1YXJlLCBzeW1ib2xUcmlhbmdsZSwgc3ltYm9sV3llIH0gZnJvbSAnZDMtc2hhcGUnXHJcbmltcG9ydCB7IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciwgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIGV4ZWN1dGVGb3JBbGxJbnNldHMsIGdldFJlZ2lvbnNTZWxlY3RvciwgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb3BvcnRpb25hbCBzeW1ib2wgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIHRydWUsICdwcycpXHJcblxyXG4gICAgLy9zaGFwZVxyXG4gICAgb3V0LnBzU2hhcGVfID0gJ2NpcmNsZScgLy8gYWNjZXB0ZWQgdmFsdWVzOiBjaXJjbGUsIGJhciwgc3F1YXJlLCBzdGFyLCBkaWFtb25kLCB3eWUsIGNyb3NzXHJcbiAgICBvdXQucHNDdXN0b21TaGFwZV8gLy8gc2VlIGh0dHA6Ly91c2luZy1kM2pzLmNvbS8wNV8xMF9zeW1ib2xzLmh0bWwjaF82NmlJUTVzSklUXHJcbiAgICBvdXQucHNDdXN0b21TVkdfIC8vIHNlZSBodHRwOi8vYmwub2Nrcy5vcmcvamVzc2loYW1lbC85NjQ4NDk1XHJcbiAgICBvdXQucHNTcGlrZVdpZHRoXyA9IDcgLy8gJ3NwaWtlJyBzaGFwZSB3aWR0aHNcclxuICAgIG91dC5wc09mZnNldF8gPSB7IHg6IDAsIHk6IDAgfVxyXG5cclxuICAgIC8vc2l6ZVxyXG4gICAgb3V0LnBzTWF4U2l6ZV8gPSAzMCAvLyBtYXggc3ltYm9sIHNpemVcclxuICAgIG91dC5wc01pblNpemVfID0gNSAvLyBtaW4gc3ltYm9sIHNpemVcclxuICAgIG91dC5wc0JhcldpZHRoXyA9IDEwIC8vZm9yIHZlcnRpY2FsIGJhcnNcclxuICAgIG91dC5wc01heFZhbHVlXyA9IHVuZGVmaW5lZCAvLyBhbGxvdyB0aGUgdXNlciB0byBtYW51YWxseSBkZWZpbmUgdGhlIGRvbWFpbiBvZiB0aGUgc2l6aW5nIHNjYWxlLiBFLmcuIGlmIHRoZSB1c2VyIHdhbnRzIHRvIHVzZSB0aGUgc2FtZSBzY2FsZSBhY3Jvc3MgZGlmZmVyZW50IG1hcHMuXHJcbiAgICBvdXQucHNNaW5WYWx1ZV8gPSB1bmRlZmluZWRcclxuICAgIG91dC5wc1NpemVTY2FsZV8gPSB1bmRlZmluZWQgLy8gJ3NxcnQnIG9yICdsaW5lYXInXHJcblxyXG4gICAgLy9jb2xvdXJcclxuICAgIG91dC5wc0ZpbGxfID0gJyMyZDUwYTAnIC8vc2FtZSBmaWxsIGZvciBhbGwgc3ltYm9scyB3aGVuIG5vIHZpc3VhbCB2YXJpYWJsZSAoc2V0RGF0YSgpKSBmb3IgJ2NvbG9yJyBpcyBzcGVjaWZpZWRcclxuICAgIG91dC5wc0ZpbGxPcGFjaXR5XyA9IDFcclxuICAgIG91dC5wc1N0cm9rZV8gPSAnI2ZmZmZmZidcclxuICAgIG91dC5wc1N0cm9rZVdpZHRoXyA9IDAuMlxyXG4gICAgb3V0LnBzQ2xhc3Nlc18gPSA1IC8vIG51bWJlciBvZiBjbGFzc2VzIHRvIHVzZSBmb3IgY29sb3VyaW5nXHJcbiAgICBvdXQucHNDb2xvcnNfID0gbnVsbCAvL2NvbG91cnMgdG8gdXNlIGZvciB0aHJlc2hvbGQgY29sb3VyaW5nXHJcbiAgICBvdXQucHNDb2xvckZ1bl8gPSBpbnRlcnBvbGF0ZU9yUmRcclxuICAgIG91dC5wc0NsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkIC8vYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIGZyb20gdGhlIGNsYXNzIGlcclxuXHJcbiAgICAvL3RoZSB0aHJlc2hvbGQsIHdoZW4gdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZCBpcyAndGhyZXNob2xkJ1xyXG4gICAgb3V0LnBzVGhyZXNob2xkXyA9IFswXVxyXG4gICAgLy90aGUgY2xhc3NpZmljYXRpb24gbWV0aG9kXHJcbiAgICBvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPSAncXVhbnRpbGUnIC8vIG9yOiBlcXVpbnRlciwgdGhyZXNob2xkXHJcbiAgICAvL3doZW4gY29tcHV0ZWQgYXV0b21hdGljYWxseSwgZW5zdXJlIHRoZSB0aHJlc2hvbGQgYXJlIG5pY2Ugcm91bmRlZCB2YWx1ZXNcclxuICAgIG91dC5tYWtlQ2xhc3NpZk5pY2VfID0gdHJ1ZVxyXG4gICAgLy9cclxuICAgIC8vdGhlIGNsYXNzaWZpZXI6IGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuIHRoZSBzeW1ib2wgc2l6ZS9jb2xvciBmcm9tIHRoZSBzdGF0IHZhbHVlLlxyXG4gICAgb3V0LmNsYXNzaWZpZXJTaXplXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmNsYXNzaWZpZXJDb2xvcl8gPSB1bmRlZmluZWRcclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gdG9vbHRpcFRleHRGdW5Qc1xyXG5cclxuICAgIC8vZG9ybGluZyBjYXJ0b2dyYW1cclxuICAgIG91dC5kb3JsaW5nXyA9IGZhbHNlXHJcbiAgICBvdXQuZG9ybGluZ1N0cmVuZ3RoXyA9IHsgeDogMSwgeTogMSB9XHJcbiAgICBvdXQuZG9ybGluZ0l0ZXJhdGlvbnNfID0gMVxyXG4gICAgb3V0LnBzQ29kZUxhYmVsc18gPSBmYWxzZSAvLyBzaG93IGNvdW50cnkgY29kZXMgaW4gc3ltYm9sc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ3BzTWF4U2l6ZV8nLFxyXG4gICAgICAgICdwc01pblNpemVfJyxcclxuICAgICAgICAncHNNYXhWYWx1ZV8nLFxyXG4gICAgICAgICdwc01pblZhbHVlXycsXHJcbiAgICAgICAgJ3BzRmlsbF8nLFxyXG4gICAgICAgICdwc0ZpbGxPcGFjaXR5XycsXHJcbiAgICAgICAgJ3BzU3Ryb2tlXycsXHJcbiAgICAgICAgJ3BzU3Ryb2tlV2lkdGhfJyxcclxuICAgICAgICAnY2xhc3NpZmllclNpemVfJyxcclxuICAgICAgICAnY2xhc3NpZmllckNvbG9yXycsXHJcbiAgICAgICAgJ3BzU2hhcGVfJyxcclxuICAgICAgICAncHNDdXN0b21TaGFwZV8nLFxyXG4gICAgICAgICdwc0JhcldpZHRoXycsXHJcbiAgICAgICAgJ3BzQ2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwc0NvbG9yRnVuXycsXHJcbiAgICAgICAgJ3BzU2l6ZVNjYWxlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwc1RocmVzaG9sZF8nLFxyXG4gICAgICAgICdwc0NvbG9yc18nLFxyXG4gICAgICAgICdwc0N1c3RvbVNWR18nLFxyXG4gICAgICAgICdwc09mZnNldF8nLFxyXG4gICAgICAgICdwc0NsYXNzaWZpY2F0aW9uTWV0aG9kXycsXHJcbiAgICAgICAgJ3BzQ2xhc3Nlc18nLFxyXG4gICAgICAgICdkb3JsaW5nXycsXHJcbiAgICAgICAgJ2RvcmxpbmdTdHJlbmd0aF8nLFxyXG4gICAgICAgICdwc1NwaWtlV2lkdGhfJyxcclxuICAgICAgICAncHNDb2RlTGFiZWxzXycsXHJcbiAgICAgICAgJ2RvcmxpbmdJdGVyYXRpb25zXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdwc01heFNpemUnLFxyXG4gICAgICAgICAgICAncHNNaW5TaXplJyxcclxuICAgICAgICAgICAgJ3BzRmlsbCcsXHJcbiAgICAgICAgICAgICdwc0ZpbGxPcGFjaXR5JyxcclxuICAgICAgICAgICAgJ3BzU3Ryb2tlJyxcclxuICAgICAgICAgICAgJ3BzU3Ryb2tlV2lkdGgnLFxyXG4gICAgICAgICAgICAnY2xhc3NpZmllclNpemUnLFxyXG4gICAgICAgICAgICAnY2xhc3NpZmllckNvbG9yJyxcclxuICAgICAgICAgICAgJ3BzU2hhcGUnLFxyXG4gICAgICAgICAgICAncHNDdXN0b21TaGFwZScsXHJcbiAgICAgICAgICAgICdwc0JhcldpZHRoJyxcclxuICAgICAgICAgICAgJ3BzQ2xhc3NUb0ZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdwc0NvbG9yRnVuJyxcclxuICAgICAgICAgICAgJ25vRGF0YUZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdwc1RocmVzaG9sZCcsXHJcbiAgICAgICAgICAgICdwc0NvbG9ycycsXHJcbiAgICAgICAgICAgICdwc0N1c3RvbVNWRycsXHJcbiAgICAgICAgICAgICdwc09mZnNldCcsXHJcbiAgICAgICAgICAgICdwc0NsYXNzaWZpY2F0aW9uTWV0aG9kJyxcclxuICAgICAgICAgICAgJ3BzQ2xhc3NlcycsXHJcbiAgICAgICAgICAgICdkb3JsaW5nSXRlcmF0aW9uc18nLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBvZiBzb21lIHNwZWNpYWwgZ2V0dGVycy9zZXR0ZXJzXHJcbiAgICBvdXQucHNDb2xvckZ1biA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnBzQ29sb3JGdW5fXHJcbiAgICAgICAgb3V0LnBzQ29sb3JGdW5fID0gdlxyXG4gICAgICAgIG91dC5wc0NsYXNzVG9GaWxsU3R5bGVfID0gZ2V0Q29sb3JMZWdlbmQob3V0LnBzQ29sb3JGdW5fLCBvdXQucHNDb2xvcnNfKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuICAgIG91dC5wc1RocmVzaG9sZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnBzVGhyZXNob2xkX1xyXG4gICAgICAgIG91dC5wc1RocmVzaG9sZF8gPSB2XHJcbiAgICAgICAgb3V0LnBzQ2xhc3Nlcyh2Lmxlbmd0aCArIDEpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9kZWZpbmUgY2xhc3NpZmllcnMgZm9yIHNpemluZyBhbmQgY29sb3VyaW5nIChvdXQuY2xhc3NpZmllclNpemVfICYgb3V0LmNsYXNzaWZpZXJDb2xvcl8pXHJcbiAgICAgICAgZGVmaW5lQ2xhc3NpZmllcnMoKVxyXG5cclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhc3NpZ25zIGEgY29sb3IgdG8gZWFjaCBzeW1ib2wsIGJhc2VkIG9uIHRoZWlyIHN0YXRpc3RpY2FsIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSB7XHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQuY2xhc3NpZmllckNvbG9yXykge1xyXG4gICAgICAgICAgICAgICAgLy9hc3NpZ24gY29sb3IgY2xhc3MgdG8gZWFjaCBzeW1ib2wsIGJhc2VkIG9uIHRoZWlyIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGUgc3ltYm9sIHBhdGggaGFzbnQgYmVlbiBhcHBlbmRlZC4gT25seSB0aGUgcGFyZW50IGcuZW0tY2VudHJvaWQgZWxlbWVudCAoaW4gbWFwLXRlbXBsYXRlKVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yRGF0YSA9IG1hcC5zdGF0RGF0YSgnY29sb3InKVxyXG4gICAgICAgICAgICAgICAgbWFwLnN2Z18uc2VsZWN0QWxsKCcuZW0tY2VudHJvaWQnKS5hdHRyKCdlY2wnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IGNvbG9yRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSAwICYmICF2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjID0gK291dC5jbGFzc2lmaWVyQ29sb3JfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGRlZmluZXMgY2xhc3NpZmllciBmdW5jdGlvbnMgKG91dC5jbGFzc2lmaWVyQ29sb3IgYW5kIG91dC5jbGFzc2lmaWVyU2l6ZSkgZm9yIGJvdGggc3ltYm9sIHNpemUgYW5kIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlZmluZUNsYXNzaWZpZXJzKCkge1xyXG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHNjYWxlXHJcbiAgICAgICAgaWYgKCFvdXQucHNTaXplU2NhbGVfKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQucHNTaGFwZV8gPT0gJ3NwaWtlJykge1xyXG4gICAgICAgICAgICAgICAgb3V0LnBzU2l6ZVNjYWxlXyA9ICdsaW5lYXInXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXQucHNTaXplU2NhbGVfID0gJ3NxcnQnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2ltcGx5IHJldHVybiB0aGUgYXJyYXkgWzAsMSwyLDMsLi4uLG5iLTFdXHJcbiAgICAgICAgY29uc3QgZ2V0QSA9IGZ1bmN0aW9uIChuYikge1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLkFycmF5KG5iKS5rZXlzKCldXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1c2Ugc2l6ZSBkYXRhc2V0XHJcbiAgICAgICAgbGV0IHNpemVEb21haW5cclxuICAgICAgICBsZXQgZGF0YSA9IG91dC5zdGF0RGF0YSgnc2l6ZScpLmdldEFycmF5KClcclxuICAgICAgICAvLyBsZXQgZG9tYWluID0gZXh0ZW50KGRhdGEpXHJcbiAgICAgICAgbGV0IG1pbiA9IG91dC5wc01pblZhbHVlXyA/IG91dC5wc01pblZhbHVlXyA6IG91dC5zdGF0RGF0YSgnc2l6ZScpLmdldE1pbigpXHJcbiAgICAgICAgbGV0IG1heCA9IG91dC5wc01heFZhbHVlXyA/IG91dC5wc01heFZhbHVlXyA6IG91dC5zdGF0RGF0YSgnc2l6ZScpLmdldE1heCgpXHJcblxyXG4gICAgICAgIHNpemVEb21haW4gPSBkYXRhID8gW21pbiwgbWF4XSA6IFtvdXQuc3RhdERhdGEoKS5nZXRNaW4oKSwgb3V0LnN0YXREYXRhKCkuZ2V0TWF4KCldXHJcblxyXG4gICAgICAgIGxldCBzY2FsZSA9IG91dC5wc1NpemVTY2FsZV8gPT0gJ3NxcnQnID8gc2NhbGVTcXJ0IDogc2NhbGVMaW5lYXJcclxuICAgICAgICBvdXQuY2xhc3NpZmllclNpemUoc2NhbGUoKS5kb21haW4oc2l6ZURvbWFpbikucmFuZ2UoW291dC5wc01pblNpemVfLCBvdXQucHNNYXhTaXplX10pKVxyXG5cclxuICAgICAgICAvLyBjb2xvdXJcclxuICAgICAgICBpZiAob3V0LnN0YXREYXRhKCdjb2xvcicpLmdldEFycmF5KCkpIHtcclxuICAgICAgICAgICAgLy91c2Ugc3VpdGFibGUgY2xhc3NpZmljYXRpb24gdHlwZSBmb3IgY29sb3VyaW5nXHJcbiAgICAgICAgICAgIGlmIChvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPT09ICdxdWFudGlsZScpIHtcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aWxlLXNjYWxlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3V0LnN0YXREYXRhKCdjb2xvcicpLmdldEFycmF5KClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0QShvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyQ29sb3Ioc2NhbGVRdWFudGlsZSgpLmRvbWFpbihkb21haW4pLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQucHNDbGFzc2lmaWNhdGlvbk1ldGhvZF8gPT09ICdlcXVpbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3F1YW50aXplLXNjYWxlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3V0LnN0YXREYXRhKCdjb2xvcicpLmdldEFycmF5KClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0QShvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyQ29sb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVRdWFudGl6ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oW21pbihkb21haW4pLCBtYXgoZG9tYWluKV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShyYW5nZSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFrZUNsYXNzaWZOaWNlXykgb3V0LmNsYXNzaWZpZXJDb2xvcigpLm5pY2UoKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9PT0gJ3RocmVzaG9sZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlI3RocmVzaG9sZC1zY2FsZXNcclxuICAgICAgICAgICAgICAgIG91dC5wc0NsYXNzZXMob3V0LnBzVGhyZXNob2xkKCkubGVuZ3RoICsgMSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0QShvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyQ29sb3Ioc2NhbGVUaHJlc2hvbGQoKS5kb21haW4ob3V0LnBzVGhyZXNob2xkKCkpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgcHJvcG9ydGlvbmFsIHN5bWJvbCBzdHlsaW5nIHRvIGEgbWFwIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9zZWUgaHR0cHM6Ly9ibC5vY2tzLm9yZy9tYm9zdG9jay80MzQyMDQ1IGFuZCBodHRwczovL2Jvc3Qub2Nrcy5vcmcvbWlrZS9idWJibGUtbWFwL1xyXG4gICAgICAgIC8vZGVmaW5lIHN0eWxlIHBlciBjbGFzc1xyXG4gICAgICAgIGlmICghb3V0LnBzQ2xhc3NUb0ZpbGxTdHlsZSgpKSBvdXQucHNDbGFzc1RvRmlsbFN0eWxlKGdldENvbG9yTGVnZW5kKG91dC5wc0NvbG9yRnVuXywgb3V0LnBzQ29sb3JzXykpXHJcblxyXG4gICAgICAgIC8vIGlmIHNpemUgZGF0YXNldCBub3QgZGVmaW5lZCB0aGVuIHVzZSBkZWZhdWx0XHJcbiAgICAgICAgbGV0IHNpemVEYXRhID0gbWFwLnN0YXREYXRhKCdzaXplJykuZ2V0QXJyYXkoKSA/IG1hcC5zdGF0RGF0YSgnc2l6ZScpIDogbWFwLnN0YXREYXRhKClcclxuXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIC8vY2xlYXIgcHJldmlvdXMgc3ltYm9sc1xyXG4gICAgICAgICAgICBsZXQgcHJldlN5bWJvbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJzpub3QoI2VtLWluc2V0cy1ncm91cCkgZy5lbS1jZW50cm9pZCA+IConKVxyXG4gICAgICAgICAgICBwcmV2U3ltYm9scy5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgLy9jaGFuZ2UgZHJhdyBvcmRlciBhY2NvcmRpbmcgdG8gc2l6ZSwgdGhlbiByZWNsYXNzaWZ5ICh0aGVyZSB3YXMgYW4gaXNzdWUgd2l0aCBub2RlcyBjaGFuZ2luZyBlY2wgYXR0cmlidXRlcylcclxuICAgICAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVN5bWJvbHNEcmF3T3JkZXIobWFwKVxyXG4gICAgICAgICAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG1hcClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYXBwZW5kIHN5bWJvbHNcclxuICAgICAgICAgICAgbGV0IHN5bWJcclxuICAgICAgICAgICAgaWYgKG91dC5wc0N1c3RvbVNWR18pIHtcclxuICAgICAgICAgICAgICAgIHN5bWIgPSBhcHBlbmRDdXN0b21TeW1ib2xzVG9NYXAobWFwLCBzaXplRGF0YSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQucHNTaGFwZV8gPT0gJ2JhcicpIHtcclxuICAgICAgICAgICAgICAgIHN5bWIgPSBhcHBlbmRCYXJzVG9NYXAobWFwLCBzaXplRGF0YSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQucHNTaGFwZV8gPT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgICAgIHN5bWIgPSBhcHBlbmRDaXJjbGVzVG9NYXAobWFwLCBzaXplRGF0YSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQucHNTaGFwZV8gPT0gJ3NwaWtlJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYiA9IGFwcGVuZFNwaWtlc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaXJjbGUsIGNyb3NzLCBzdGFyLCB0cmlhbmdsZSwgZGlhbW9uZCwgc3F1YXJlLCB3eWUgb3IgY3VzdG9tXHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kRDNTeW1ib2xzVG9NYXAobWFwLCBzaXplRGF0YSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZG9ybGluZyBjYXJ0b2dyYW1cclxuICAgICAgICAgICAgaWYgKG91dC5kb3JsaW5nXykge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlEb3JsaW5nRm9yY2UobWFwLCBzaXplRGF0YSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2ltdWxhdGlvbikgc3RvcFNpbXVsYXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhcHBlbmRMYWJlbHNUb1N5bWJvbHMobWFwLCBzaXplRGF0YSlcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBzdHlsZSBvZiBzeW1ib2xzXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICAgICAgbGV0IHJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cclxuICAgICAgICAgICAgaWYgKG1hcC5nZW9fICE9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFN5bWJvbHNUb01peGVkTlVUUyhtYXAsIHNpemVEYXRhLCByZWdpb25zKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG51dHMgcmVnaW9ucyBmaWxsIGNvbG91ciBvbmx5IGZvciB0aG9zZSB3aXRoIHNpemVEYXRhXHJcbiAgICAgICAgICAgICAgICAvLyByZWdpb25zLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VtLWNudHJnJykpIHJldHVybiAvLyBTa2lwIGNvdW50cnkgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvLyBOTyBJTlBVVFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZV9cclxuICAgICAgICAgICAgICAgIC8vICAgICB9IGVsc2UgaWYgKChzdiAmJiBzdi52YWx1ZSkgfHwgKHN2ICYmIHN2LnZhbHVlID09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmIChzdi52YWx1ZSA9PSAnOicpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIC8vIERBVEEgTk9UIEFWQUlMQUJMRVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgLy8gREFUQVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJylcclxuICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB9KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFwcGx5ICduZCcgY2xhc3MgdG8gbm8gZGF0YSBmb3IgbGVnZW5kIGl0ZW0gaG92ZXJcclxuICAgICAgICAgICAgICAgIHJlZ2lvbnMuYXR0cignZWNsJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICghc3YudmFsdWUgJiYgc3YgIT09IDAgJiYgc3YudmFsdWUgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PIElOUFVUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoc3YgJiYgc3YudmFsdWUpIHx8IChzdiAmJiBzdi52YWx1ZSA9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3YudmFsdWUgPT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEQVRBIE5PVCBBVkFJTEFCTEVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd29ybGQgY291bnRyaWVzIGZpbGwgb25seSB0aG9zZSB3aXRoIGRhdGFcclxuICAgICAgICAgICAgICAgIC8vIHJlZ2lvbnMuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghc3YgfHwgKCFzdi52YWx1ZSAmJiBzdiAhPT0gMCAmJiBzdi52YWx1ZSAhPT0gMCkgfHwgc3YudmFsdWUgPT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiBvdXQud29ybGRGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc2V0IGNvbG9yL3N0cm9rZS9vcGFjaXR5IHN0eWxlc1xyXG4gICAgICAgICAgICBzZXRTeW1ib2xTdHlsZXMoc3ltYilcclxuXHJcbiAgICAgICAgICAgIGFkZE1vdXNlRXZlbnRzKG1hcClcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYWJlbHMgZm9yIHN0YXRpc3RpY2FsIHZhbHVlcyBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICBpZiAob3V0LmxhYmVsc18/LnZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgb3V0LnVwZGF0ZVZhbHVlc0xhYmVscyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGVuZExhYmVsc1RvU3ltYm9scyA9IGZ1bmN0aW9uIChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgbGV0IHN5bWJvbENvbnRhaW5lcnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAvL2NvdW50cnkgY29kZSBsYWJlbHNcclxuICAgICAgICBpZiAob3V0LnBzQ29kZUxhYmVsc18pIHtcclxuICAgICAgICAgICAgY29uc3QgY291bnRyeUNvZGVMYWJlbCA9IHN5bWJvbENvbnRhaW5lcnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtPy52YWx1ZSAhPT0gJzonICYmIGRhdHVtPy52YWx1ZSAhPSBudWxsIC8vIElnbm9yZSBgJzonYCwgYG51bGxgLCBhbmQgYHVuZGVmaW5lZGBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jaXJjbGUtY29kZS1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0/LnZhbHVlID09PSAnOicgPyAnJyA6IGQucHJvcGVydGllcy5pZCAvLyBIaWRlIHRleHQgaWYgdmFsdWUgaXMgJzonXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdzYW5zLXNlcmlmJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IGRhdHVtID8gb3V0LmNsYXNzaWZpZXJTaXplXyhkYXR1bS52YWx1ZSkgOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2l6ZSBhZGp1c3RtZW50IGZhY3RvciBkZXBlbmRzIG9uIHN5bWJvbCB0eXBlLCBhbmQgd2hldGhlciBzdGF0IHZhbHVlcyBhcmUgYWxzbyBhZGRlZCB0byB0aGUgY2lyY2xlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmYWN0b3IgPSBvdXQubGFiZWxzXz8udmFsdWVzICYmIHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpPy52YWx1ZSA/IDAuOCA6IDAuOVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQucHNTaGFwZV8gPT09ICdzcXVhcmUnKSBmYWN0b3IgPSBmYWN0b3IgLSAwLjRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7cmFkaXVzICogZmFjdG9yfXB4YFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZChvdXQucHNGaWxsXykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAoZCkgPT4gKG91dC5sYWJlbHNfPy52YWx1ZXMgJiYgc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZCk/LnZhbHVlID8gJy0wLjNlbScgOiAnMCcpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zdGF0IGxhYmVsc1xyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXz8udmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRMYWJlbHMgPSBzeW1ib2xDb250YWluZXJzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bT8udmFsdWUgIT09ICc6JyAmJiBkYXR1bT8udmFsdWUgIT0gbnVsbCAvLyBJZ25vcmUgYCc6J2AsIGBudWxsYCwgYW5kIGB1bmRlZmluZWRgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY2lyY2xlLXN0YXQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdHVtPy52YWx1ZSkgcmV0dXJuIGRhdHVtLnZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdzYW5zLXNlcmlmJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IGRhdHVtID8gb3V0LmNsYXNzaWZpZXJTaXplXyhkYXR1bS52YWx1ZSkgOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3JhZGl1cyAqIDAuNH1weGBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQob3V0LnBzRmlsbF8pKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgKGQpID0+IChvdXQucHNDb2RlTGFiZWxzXyA/ICcwLjZlbScgOiAnMCcpKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBsZXQgc3ltYm9scyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgIHN5bWJvbHNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzLmNoaWxkTm9kZXNbMF0pXHJcbiAgICAgICAgICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIHNlbC5zdHlsZSgnZmlsbCcpKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgb3V0LmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzLmNoaWxkTm9kZXNbMF0pXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmlsbCA9IHNlbC5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbmV3RmlsbClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIHNldHMgY29sb3Ivc3Ryb2tlL29wYWNpdHkgc3R5bGVzIG9mIGFsbCBzeW1ib2xzXHJcbiAgICAgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gc3ltYiBzeW1ib2xzIGQzIHNlbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRTeW1ib2xTdHlsZXMoc3ltYikge1xyXG4gICAgICAgIHN5bWIuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIG91dC5wc0ZpbGxPcGFjaXR5KCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgb3V0LnBzU3Ryb2tlKCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgb3V0LnBzU3Ryb2tlV2lkdGgoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5jbGFzc2lmaWVyQ29sb3JfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgcHMsIGVjbCBhdHRyaWJ1dGUgYmVsb25ncyB0byB0aGUgcGFyZW50IGcuZW0tY2VudHJvaWQgbm9kZSBjcmVhdGVkIGluIG1hcC10ZW1wbGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlY2wgfHwgZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZV8gfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gb3V0LnBzQ2xhc3NUb0ZpbGxTdHlsZV8oZWNsLCBvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dC5wc0ZpbGxfXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsX19fJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGwgPSBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGwgLy8gc2F2ZSBmb3IgbGVnZW5kIG1vdXNlb3ZlclxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIGRyYXcgb3JkZXIgb2YgdGhlIHN5bWJvbHMgYWNjb3JkaW5nIHRvIHRoZWlyIGRhdGEgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlU3ltYm9sc0RyYXdPcmRlcihtYXApIHtcclxuICAgICAgICBsZXQgem9vbUdyb3VwID0gbWFwLnN2Z18gPyBtYXAuc3ZnXy5zZWxlY3QoJyN6b29tZ3JvdXAnICsgbWFwLnN2Z0lkXykgOiBudWxsXHJcbiAgICAgICAgY29uc3QgZ2NwID0gem9vbUdyb3VwLnNlbGVjdCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgbGV0IHNpemVEYXRhID0gbWFwLnN0YXREYXRhKCdzaXplJykuZ2V0QXJyYXkoKSA/IG1hcC5zdGF0RGF0YSgnc2l6ZScpIDogbWFwLnN0YXREYXRhKClcclxuXHJcbiAgICAgICAgbWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgYSBzaG91bGQgY29tZSBiZWZvcmUgYi5cclxuICAgICAgICAgICAgLy8gQSBwb3NpdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCBhIHNob3VsZCBjb21lIGFmdGVyIGIuXHJcbiAgICAgICAgICAgIC8vIFplcm8gb3IgTmFOIGluZGljYXRlcyB0aGF0IGEgYW5kIGIgYXJlIGNvbnNpZGVyZWQgZXF1YWwuXHJcbiAgICAgICAgICAgIGxldCB2YWxBID0gc2l6ZURhdGEuZ2V0KGEucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgbGV0IHZhbEIgPSBzaXplRGF0YS5nZXQoYi5wcm9wZXJ0aWVzLmlkKVxyXG5cclxuICAgICAgICAgICAgaWYgKHZhbEEgfHwgdmFsQT8udmFsdWUgPT0gMCB8fCB2YWxCIHx8IHZhbEI/LnZhbHVlID09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICgodmFsQSB8fCB2YWxBPy52YWx1ZSA9PSAwKSAmJiAodmFsQiB8fCB2YWxCPy52YWx1ZSA9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdGggdmFsdWVzIGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmlnZ2VzdCBjaXJjbGVzIGF0IHRoZSBib3R0b21cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsQi52YWx1ZSAtIHZhbEEudmFsdWVcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHZhbEEgfHwgdmFsQT8udmFsdWUgPT0gMCkgJiYgKCF2YWxCIHx8ICF2YWxCPy52YWx1ZSA9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdmFsQSBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTFcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHZhbEIgfHwgdmFsQj8udmFsdWUgPT0gMCkgJiYgKCF2YWxBIHx8ICF2YWxBPy52YWx1ZSA9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdmFsQiBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCBjZW50cm9pZHMgPSBnY3BcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgICAgIC5kYXRhKG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpXHJcbiAgICAgICAgICAgIC5qb2luKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzBdLnRvRml4ZWQoMykgKyAnLCcgKyBkLnByb3BlcnRpZXMuY2VudHJvaWRbMV0udG9GaXhlZCgzKSArICcpJ1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgY29sb3JzXHJcbiAgICAgICAgLy9zZXRTeW1ib2xTdHlsZXMoc3ltYm9scylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRTcGlrZXNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgLy9UaGUgc3Bpa2UgZnVuY3Rpb24gY3JlYXRlcyBhIHRyaWFuZ3VsYXIgcGF0aCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoIChoZWlnaHQpIHdpdGggYSBiYXNlIHdpZHRoIG9mIDcgcGl4ZWxzLlxyXG4gICAgICAgIGNvbnN0IHNwaWtlID0gKGxlbmd0aCwgd2lkdGggPSBvdXQucHNTcGlrZVdpZHRoXykgPT4gYE0key13aWR0aCAvIDJ9LDBMMCwkey1sZW5ndGh9TCR7d2lkdGggLyAyfSwwYFxyXG4gICAgICAgIGxldCBzeW1ib2xDb250YWluZXJzID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBjaXJjbGVzIHRvIGVhY2ggc3ltYm9sIGNvbnRhaW5lclxyXG4gICAgICAgIGNvbnN0IHNwaWtlcyA9IHN5bWJvbENvbnRhaW5lcnNcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0dW0gPyBvdXQuY2xhc3NpZmllclNpemVfKGRhdHVtLnZhbHVlKSA6IDBcclxuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gc3Bpa2UodmFsdWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCkgPT4gZC5jb2xvciB8fCAnc3RlZWxibHVlJykgLy8gQWRqdXN0IGNvbG9yIGFzIG5lZWRlZFxyXG4gICAgICAgICAgICAvLy5hdHRyKCdmaWxsJywgbWFwLnBzRmlsbF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCBtYXAucHNGaWxsT3BhY2l0eV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBtYXAucHNTdHJva2VfKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgbWFwLnBzU3Ryb2tlV2lkdGhfKVxyXG5cclxuICAgICAgICByZXR1cm4gc3Bpa2VzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQXBwZW5kcyA8Y2lyY2xlPiBlbGVtZW50cyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcCBTVkdcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBzaXplRGF0YSBzdGF0aXN0aWNhbCBkYXRhIGZvciBzaXplIGUuZy4gbWFwLnN0YXREYXRhKCdzaXplJylcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFwcGVuZENpcmNsZXNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgbGV0IHN5bWJvbENvbnRhaW5lcnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGNpcmNsZXMgdG8gZWFjaCBzeW1ib2wgY29udGFpbmVyXHJcbiAgICAgICAgY29uc3QgY2lyY2xlcyA9IHN5bWJvbENvbnRhaW5lcnNcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gZGF0dW0gPyBvdXQuY2xhc3NpZmllclNpemVfKGRhdHVtLnZhbHVlKSA6IDBcclxuICAgICAgICAgICAgICAgIHJldHVybiByYWRpdXNcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IGQuY29sb3IgfHwgJ3N0ZWVsYmx1ZScpIC8vIEFkanVzdCBjb2xvciBhcyBuZWVkZWRcclxuXHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZXNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseURvcmxpbmdGb3JjZShtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgbGV0IHN5bWJvbENvbnRhaW5lcnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuXHJcbiAgICAgICAgaWYgKG91dC5zaW11bGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHN0b3BTaW11bGF0aW9uKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGZvcmNlIHNpbXVsYXRpb25cclxuICAgICAgICBjb25zb2xlLmxvZygnbmV3IGRvcmxpbmcgc2ltdWxhdGlvbicpXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24gPSBmb3JjZVNpbXVsYXRpb24obWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcylcclxuICAgICAgICAgICAgLmZvcmNlKFxyXG4gICAgICAgICAgICAgICAgJ3gnLFxyXG4gICAgICAgICAgICAgICAgZm9yY2VYKChkKSA9PiBkLnByb3BlcnRpZXMuY2VudHJvaWRbMF0pLnN0cmVuZ3RoKG91dC5kb3JsaW5nU3RyZW5ndGhfLngpIC8vIFN0cm9uZ2VyIHB1bGwgdG8gb3JpZ2luYWwgeFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5mb3JjZShcclxuICAgICAgICAgICAgICAgICd5JyxcclxuICAgICAgICAgICAgICAgIGZvcmNlWSgoZCkgPT4gZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzFdKS5zdHJlbmd0aChvdXQuZG9ybGluZ1N0cmVuZ3RoXy55KSAvLyBTdHJvbmdlciBwdWxsIHRvIG9yaWdpbmFsIHlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuZm9yY2UoXHJcbiAgICAgICAgICAgICAgICAnY29sbGlkZScsXHJcbiAgICAgICAgICAgICAgICBmb3JjZUNvbGxpZGUoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LnBzU2hhcGVfID09PSAnc3F1YXJlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNpemUgLyAyKSAqIE1hdGguU1FSVDIgLy8gQWRqdXN0IGZvciBkaWFnb25hbCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZSAvLyBEZWZhdWx0IGZvciBjaXJjbGVzXHJcbiAgICAgICAgICAgICAgICB9KS5pdGVyYXRpb25zKG91dC5kb3JsaW5nSXRlcmF0aW9uc18pIC8vIE1vcmUgaXRlcmF0aW9ucyB0byBpbXByb3ZlIGNvbGxpc2lvbiBoYW5kbGluZ1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC8vLmFscGhhVGFyZ2V0KDAuMykgLy8gSGVscHMga2VlcCBjZW50cm9pZHMgYW5jaG9yZWRcclxuICAgICAgICAgICAgLm9uKCd0aWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGVsZW1lbnRzIHdpdGggdGhlIG5ldyBwb3NpdGlvbnMgYW5kIHJhZGlpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2xDb250YWluZXJzLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiAndHJhbnNsYXRlKCcgKyBkLnggKyAnLCcgKyBkLnkgKyAnKScpXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vb3V0LnNpbXVsYXRpb24uYWxwaGEoMSkucmVzdGFydCgpIC8vIEVuc3VyZXMgc2ltdWxhdGlvbiBzdGFydHMgd2l0aCBmdWxsIHN0cmVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RvcFNpbXVsYXRpb24oKSB7XHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24uc3RvcCgpIC8vIFN0b3BzIHRoZSBpbnRlcm5hbCB0aWNrIGxvb3BcclxuICAgICAgICBvdXQuc2ltdWxhdGlvbi5vbigndGljaycsIG51bGwpIC8vIFJlbW92ZSB0aWNrIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24ub24oJ2VuZCcsIG51bGwpIC8vIFJlbW92ZSBlbmQgZXZlbnQgbGlzdGVuZXJcclxuICAgICAgICBvdXQuc2ltdWxhdGlvbiA9IG51bGwgLy8gUmVtb3ZlIHJlZmVyZW5jZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGVuZHMgPHBhdGg+IGVsZW1lbnRzIGNvbnRhaW5pbmcgc3ltYm9scyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcCBTVkdcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBzaXplRGF0YSBlLmcuIG1hcC5zdGF0RGF0YSgnc2l6ZScpXHJcbiAgICAgKiBAcmV0dXJuIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBlbmREM1N5bWJvbHNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChyZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmIChzdiAmJiBzdi52YWx1ZSAhPT0gJzonKSByZXR1cm4gcmdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BzJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHNpemVcclxuICAgICAgICAgICAgICAgIGlmICghc2l6ZURhdGEpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmIChzdiAhPSAwICYmICFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oK3N2LnZhbHVlKSB8fCAwXHJcblxyXG4gICAgICAgICAgICAgICAgLy9hcHBseSBzaXplIHRvIHNoYXBlXHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnBzQ3VzdG9tU2hhcGVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dC5wc0N1c3RvbVNoYXBlXy5zaXplKHNpemUgKiBzaXplKSgpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbFR5cGUgPSBzeW1ib2xzTGlicmFyeVtvdXQucHNTaGFwZV9dIHx8IHN5bWJvbHNMaWJyYXJ5WydjaXJjbGUnXVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2woKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudHlwZShzeW1ib2xUeXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2l6ZShzaXplICogc2l6ZSkoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGVuZHMgPHJlY3Q+IGVsZW1lbnRzIGNvbnRhaW5pbmcgYmFycyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcCBTVkdcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBzaXplRGF0YSBlLmcuIG1hcC5zdGF0RGF0YSgnc2l6ZScpXHJcbiAgICAgKiBAcmV0dXJuIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRCYXJzVG9NYXAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIG1hcFxyXG4gICAgICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tcHJvcC1zeW1ib2xzJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChyZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN2ICYmIHN2LnZhbHVlICE9PSAnOicpIHJldHVybiByZ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5wc0JhcldpZHRoXylcclxuICAgICAgICAgICAgICAgIC8vZm9yIHZlcnRpY2FsIGJhcnMgd2Ugc2NhbGUgdGhlIGhlaWdodCBhdHRyaWJ1dGUgdXNpbmcgdGhlIGNsYXNzaWZpZXJcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YgfHwgIXN2LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2ID0gb3V0LmNsYXNzaWZpZXJTaXplXygrc3YudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBiUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgkey10aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDJ9YCArIGAsIC0ke3RoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKX0pYFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gdG8gdXNlIHRyYW5zaXRpb25zIHdlIG5lZWQgdG8gcmVmYWN0b3IgdGhlIGRyYXdpbmcgZnVuY3Rpb25zIHRvIHByb21pc2VzIGUuZy4gYXBwZW5kQmFyc1RvTWFwKCkudGhlbigoKT0+e30pXHJcbiAgICAgICAgICAgIC8vdGhpcyBpcyBiZWNhdXNlIC5hdHRyKCdmaWxsX19fJywgZnVuY3Rpb24gKCkge3NlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcpfSkgZG9lc250IHdvcmsgdW5sZXNzIHlvdSBleGVjdXRlIGl0IGFmdGVyIHRoZSB0cmFuc2l0aW9uIGVuZHMuXHJcbiAgICAgICAgICAgIC8vIGUuZy5cclxuICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAvLyAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAvLyAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAocmcpIHt9KVxyXG4gICAgICAgICAgICAvLyAuZW5kKClcclxuICAgICAgICAgICAgLy8gLnRoZW4oKVxyXG4gICAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIGN1c3RvbSBTVkcgc3ltYm9scyBmb3IgZWFjaCByZWdpb24gaW4gdGhlIG1hcFxyXG4gICAgICogQHBhcmFtIHsqfSBtYXBcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGFcclxuICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFwcGVuZEN1c3RvbVN5bWJvbHNUb01hcChtYXAsIHNpemVEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcFxyXG4gICAgICAgICAgICAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc3YgJiYgc3YudmFsdWUgIT09ICc6JykgcmV0dXJuIHJnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwcycpXHJcbiAgICAgICAgICAgIC5odG1sKG91dC5wc0N1c3RvbVNWR18pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHNpemVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oK3N2LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke291dC5wc09mZnNldF8ueCAqIHNpemV9LCR7b3V0LnBzT2Zmc2V0Xy55ICogc2l6ZX0pIHNjYWxlKCR7c2l6ZX0pYFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGFkZHMgcHJvcG9ydGlvbmFsIHN5bWJvbHMgdG8gZWFjaCByZWdpb25zIGluIGEgbWFwIHdpdGggbWl4ZWQgTlVUUyBsZXZlbHMgKElNQUdFKVxyXG4gICAgICogQHBhcmFtIHsqfSBtYXBcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGFcclxuICAgICAqIEBwYXJhbSB7Kn0gcmVnaW9uc1xyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkU3ltYm9sc1RvTWl4ZWROVVRTKG1hcCwgc2l6ZURhdGEsIHJlZ2lvbnMpIHtcclxuICAgICAgICAvLyBUb2dnbGUgc3ltYm9sIHZpc2liaWxpdHkgLSBvbmx5IHNob3cgcmVnaW9ucyB3aXRoIHNpemVEYXRhIHN0YXQgdmFsdWVzIHdoZW4gbWl4aW5nIGRpZmZlcmVudCBOVVRTIGxldmVsc1xyXG4gICAgICAgIGxldCBzeW1iID0gbWFwXHJcbiAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHN5bWJvbCBmb3Igbm8gaW5wdXRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcC5nZW9fID09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Jsb2NrJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyB0b2dnbGUgZGlzcGxheSBvZiBtaXhlZCBOVVRTIGxldmVsc1xyXG4gICAgICAgIHJlZ2lvbnMuc3R5bGUoJ2Rpc3BsYXknLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2VtLWNudHJnJykpIHJldHVybiAvLyBTa2lwIGNvdW50cnkgcmVnaW9uc1xyXG4gICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICBpZiAoIXN2IHx8ICghc3YudmFsdWUgJiYgc3YgIT09IDAgJiYgc3YudmFsdWUgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBzeW1ib2wgZm9yIG5vIGRhdGFcclxuICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSdcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXAuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Jsb2NrJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gbnV0cyBib3JkZXIgc3Ryb2tlXHJcbiAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsdmwgPSBzZWwuYXR0cignbHZsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHNlbC5zdHlsZSgnc3Ryb2tlJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICFzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobHZsICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cm9rZSB8fCAnIzc3NydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBudXRzIGJvcmRlciBzdHJva2Ugd2lkdGhcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHNlbC5zdHlsZSgnc3Ryb2tlLXdpZHRoJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICFzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvdXQuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGx2bCAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJva2VXaWR0aCB8fCAnIzc3NydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBzeW1iXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHN0eWxlIHRvIGluc2V0c1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHNcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdlbyBpbiBvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb10ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXRzIHdpdGggc2FtZSBnZW8gdGhhdCBkbyBub3Qgc2hhcmUgdGhlIHNhbWUgcGFyZW50IGluc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIDIgZGlmZmVyZW50IGluc2V0cyB3aXRoIHRoZSBzYW1lIGdlby4gRS5nLiAzIGluc2V0cyBmb3IgUFQyMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV0ubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dW2ldW2NdLnN2Z0lkXyAhPT0gb3V0LnN2Z0lkXykgYXBwbHlTdHlsZVRvTWFwKG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXVtjXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV0uc3ZnSWRfICE9PSBvdXQuc3ZnSWRfKSBhcHBseVN0eWxlVG9NYXAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmlxdWUgaW5zZXQgZ2VvX1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb10uc3ZnSWRfICE9PSBvdXQuc3ZnSWRfKSBhcHBseVN0eWxlVG9NYXAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gUHJvcG9ydGlvbmFsU3ltYm9sTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLy9idWlsZCBhIGNvbG9yIGxlZ2VuZCBvYmplY3RcclxuZXhwb3J0IGNvbnN0IGdldENvbG9yTGVnZW5kID0gZnVuY3Rpb24gKGNvbG9yRnVuLCBjb2xvckFycmF5KSB7XHJcbiAgICBjb2xvckZ1biA9IGNvbG9yRnVuIHx8IGludGVycG9sYXRlT3JSZFxyXG4gICAgaWYgKGNvbG9yQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckFycmF5W2VjbF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuKGVjbCAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBnaXZlIGEgZDMgc3ltYm9sIGZyb20gYSBzaGFwZSBuYW1lXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3ltYm9sc0xpYnJhcnkgPSB7XHJcbiAgICBjcm9zczogc3ltYm9sQ3Jvc3MsXHJcbiAgICBzcXVhcmU6IHN5bWJvbFNxdWFyZSxcclxuICAgIGRpYW1vbmQ6IHN5bWJvbERpYW1vbmQsXHJcbiAgICB0cmlhbmdsZTogc3ltYm9sVHJpYW5nbGUsXHJcbiAgICBzdGFyOiBzeW1ib2xTdGFyLFxyXG4gICAgd3llOiBzeW1ib2xXeWUsXHJcbiAgICBjaXJjbGU6IHN5bWJvbENpcmNsZSxcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwZWNpZmljIGZ1bmN0aW9uIGZvciB0b29sdGlwIHRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcmcgVGhlIHJlZ2lvbiB0byBzaG93IGluZm9ybWF0aW9uIG9uLlxyXG4gKiBAcGFyYW0geyp9IG1hcCBUaGUgbWFwIGVsZW1lbnRcclxuICovXHJcbmNvbnN0IHRvb2x0aXBUZXh0RnVuUHMgPSBmdW5jdGlvbiAocmVnaW9uLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcblxyXG4gICAgLy8gSGVhZGVyIHdpdGggcmVnaW9uIG5hbWUgYW5kIElEXHJcbiAgICBjb25zdCByZWdpb25OYW1lID0gcmVnaW9uLnByb3BlcnRpZXMubmFcclxuICAgIGNvbnN0IHJlZ2lvbklkID0gcmVnaW9uLnByb3BlcnRpZXMuaWRcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+XHJcbiAgICAgICAgICAgIDxiPiR7cmVnaW9uTmFtZX08L2I+JHtyZWdpb25JZCA/IGAgKCR7cmVnaW9uSWR9KWAgOiAnJ31cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgLy9zdGF0IDEgdmFsdWVcclxuICAgIGNvbnN0IHYxID0gbWFwLnN0YXREYXRhKCdzaXplJykuZ2V0QXJyYXkoKSA/IG1hcC5zdGF0RGF0YSgnc2l6ZScpIDogbWFwLnN0YXREYXRhKClcclxuICAgIGNvbnN0IHN2MSA9IHYxLmdldChyZWdpb24ucHJvcGVydGllcy5pZClcclxuICAgIGlmICghc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSkgYnVmLnB1c2gobWFwLm5vRGF0YVRleHRfKVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy91bml0IDFcclxuICAgICAgICBjb25zdCB1bml0MSA9IHYxLnVuaXRUZXh0KClcclxuICAgICAgICBidWYucHVzaChgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIj4ke3NwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpfSAke3VuaXQxID8gdW5pdDEgOiAnICd9PC9kaXY+YClcclxuICAgIH1cclxuXHJcbiAgICAvL3N0YXQgMiB2YWx1ZVxyXG4gICAgaWYgKG1hcC5zdGF0RGF0YSgnY29sb3InKS5nZXRBcnJheSgpKSB7XHJcbiAgICAgICAgY29uc3Qgc3YyID0gbWFwLnN0YXREYXRhKCdjb2xvcicpLmdldChyZWdpb24ucHJvcGVydGllcy5pZClcclxuICAgICAgICBpZiAoIXN2MiB8fCAoc3YyLnZhbHVlICE9IDAgJiYgIXN2Mi52YWx1ZSkpIGJ1Zi5wdXNoKG1hcC5ub0RhdGFUZXh0XylcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9zdGF0IDJcclxuICAgICAgICAgICAgY29uc3QgdW5pdDIgPSBtYXAuc3RhdERhdGEoJ2NvbG9yJykudW5pdFRleHQoKVxyXG4gICAgICAgICAgICBidWYucHVzaChgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHRcIj4ke3NwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjIudmFsdWUpfSAke3VuaXQyID8gdW5pdDIgOiAnICd9PC9kaXY+YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCwgY3JlYXRlIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVMb2csIHNjYWxlU3FydCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBsaW5lLCBhcmVhIH0gZnJvbSAnZDMtc2hhcGUnXHJcbmltcG9ydCB7IGV4dGVudCwgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgYXhpc0JvdHRvbSwgYXhpc0xlZnQsIGF4aXNSaWdodCB9IGZyb20gJ2QzLWF4aXMnXHJcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBsZ2NoIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aCdcclxuaW1wb3J0IHsgZ2V0UmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BhcmtsaW5lIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCB0cnVlLCAnc3BhcmsnKVxyXG5cclxuICAgIG91dC5zcGFya0xpbmVDb2xvcl8gPSAnYmxhY2snXHJcbiAgICBvdXQuc3BhcmtBcmVhQ29sb3JfID0gJyM0MWFmYWEnXHJcbiAgICBvdXQuc3BhcmtMaW5lV2lkdGhfID0gMzBcclxuICAgIG91dC5zcGFya0xpbmVIZWlnaHRfID0gMjBcclxuICAgIG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8gPSAwLjRcclxuICAgIG91dC5zcGFya0xpbmVPcGFjaXR5XyA9IDAuNlxyXG4gICAgb3V0LnNwYXJrVHlwZV8gPSAnbGluZSdcclxuICAgIG91dC5zcGFya0xpbmVDaXJjbGVSYWRpdXNfID0gMFxyXG4gICAgb3V0LnNwYXJrVG9vbHRpcENoYXJ0XyA9IHtcclxuICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgIGhlaWdodDogNTAsXHJcbiAgICAgICAgbWFyZ2luOiB7IGxlZnQ6IDYwLCByaWdodDogNDAsIHRvcDogNDAsIGJvdHRvbTogNDAgfSxcclxuICAgICAgICBjaXJjbGVSYWRpdXM6IDEuNSxcclxuICAgIH1cclxuXHJcbiAgICAvL3Nob3cgc3BhcmtsaW5lcyBvbmx5IHdoZW4gZGF0YSBmb3IgYWxsIGRhdGVzIGlzIGNvbXBsZXRlLlxyXG4gICAgLy9PdGhlcndpc2UsIGNvbnNpZGVyIHRoZSByZWdpb25zIGFzIGJlaW5nIHdpdGggbm8gZGF0YSBhdCBhbGwuXHJcbiAgICBvdXQuc2hvd09ubHlXaGVuQ29tcGxldGVfID0gZmFsc2VcclxuICAgIG91dC5zcGFya1BlcmNlbnRhZ2VDaGFuZ2VfID0gZmFsc2UgLy8gc2hvdyBwZXJjZW50YWdlIGNoYW5nZSBpbnN0ZWFkIG9mIHJhdyBjb3VudHNcclxuXHJcbiAgICBvdXQuc3RhdFNwYXJrXyA9IG51bGxcclxuICAgIG91dC5zcGFya0hlaWdodENsYXNzaWZpZXJfID0gbnVsbFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ3NwYXJrTGluZUNvbG9yXycsXHJcbiAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlXycsXHJcbiAgICAgICAgJ3NwYXJrVHlwZV8nLFxyXG4gICAgICAgICdzcGFya0xpbmVXaWR0aF8nLFxyXG4gICAgICAgICdzcGFya0xpbmVIZWlnaHRfJyxcclxuICAgICAgICAnc3BhcmtMaW5lU3Ryb2tlV2lkdGhfJyxcclxuICAgICAgICAnc3BhcmtMaW5lT3BhY2l0eV8nLFxyXG4gICAgICAgICdzcGFya0xpbmVDaXJjbGVSYWRpdXNfJyxcclxuICAgICAgICAnc3BhcmtMaW5lQXJlYUNvbG9yXycsXHJcbiAgICAgICAgJ3NwYXJrVG9vbHRpcENoYXJ0XycsXHJcbiAgICAgICAgJ3NwYXJrUGVyY2VudGFnZUNoYW5nZV8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnc3BhcmtMaW5lQ29sb3InLFxyXG4gICAgICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGUnLFxyXG4gICAgICAgICAgICAnc3BhcmtUeXBlJyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZVdpZHRoJyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZUhlaWdodCcsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVTdHJva2VXaWR0aCcsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVPcGFjaXR5JyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZUNpcmNsZVJhZGl1c18nLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lQXJlYUNvbG9yJyxcclxuICAgICAgICAgICAgJ3NwYXJrVG9vbHRpcENoYXJ0XycsXHJcbiAgICAgICAgICAgICdzcGFya1BlcmNlbnRhZ2VDaGFuZ2VfJyxcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0byBkZWZpbmUgYSBzcGFya2xpbmUgbWFwIGVhc2lseSwgd2l0aG91dCByZXBldGl0aW9uIG9mIGluZm9ybWF0aW9uLlxyXG4gICAgICogT25seSBmb3IgZXVyb2Jhc2UgZGF0YSBzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gc3RhdCBBIHBhdHRlcm4gZm9yIHRoZSBzdGF0IGRhdGEgc291cmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRlcyBUaGUgZGF0ZXMgb2YgdGhlIGNvbXBvc2l0aW9uICh0aW1lIHBhcmFtZXRlcilcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVscyBPcHRpb25hbDogVGhlIGxhYmVscyBmb3IgdGhlIGRhdGVzXHJcbiAgICAgKi9cclxuICAgIG91dC5zdGF0U3BhcmsgPSBmdW5jdGlvbiAoc3RhdCwgZGF0ZXMsIGxhYmVscykge1xyXG4gICAgICAgIC8vYWRkIG9uZSBkYXRhc2V0IGNvbmZpZyBmb3IgZWFjaCBjYXRlZ29yeVxyXG4gICAgICAgIHN0YXQuZmlsdGVycyA9IHN0YXQuZmlsdGVycyB8fCB7fVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9jYXRlZ29yeSBjb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBkYXRlc1tpXVxyXG4gICAgICAgICAgICBzdGF0LmZpbHRlcnMudGltZSA9IGRhdGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIHNjXy5maWx0ZXJzID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQuZmlsdGVycykgc2NfLmZpbHRlcnNba2V5XSA9IHN0YXQuZmlsdGVyc1trZXldXHJcbiAgICAgICAgICAgIG91dC5zdGF0KGRhdGUsIHNjXylcclxuXHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChsYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfW2RhdGVdID0gbGFiZWxzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IHN0YXRDb2Rlc1xyXG4gICAgICAgIG91dC5fc3RhdERhdGVzID0gZGF0ZXNcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgY29kZXMgb2YgdGhlIGNhdGVnb3JpZXMgdG8gY29uc2lkZXIgZm9yIHRoZSBjb21wb3NpdGlvbi4gKi9cclxuICAgIG91dC5fc3RhdERhdGVzID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBjb21wdXRlIGNvbXBvc2l0aW9uIGZvciByZWdpb24gaWQsIGZvciBlYWNoIGRhdGUuXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGgsIGZvciBlYWNoIGRhdGUsIGl0cyBzdGF0aXN0aWNhbCB2YWx1ZSBmb3IgdGhlIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIHsqfSBpZFxyXG4gICAgICogQHJldHVybnMgW3tkYXRlLHZhbHVlfV1cclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0Q29tcG9zaXRpb24gPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgY29tcCA9IFtdLFxyXG4gICAgICAgICAgICBzdW0gPSAwXHJcblxyXG4gICAgICAgIC8vIEdldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5IGFuZCBjb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuX3N0YXREYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBjb2RlIGFuZCBzdGF0IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBvdXQuX3N0YXREYXRlc1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzID0gb3V0LnN0YXREYXRhKGRhdGUpLmdldChpZClcclxuXHJcbiAgICAgICAgICAgIC8vIENhc2Ugd2hlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xyXG4gICAgICAgICAgICBpZiAoIXMgfHwgKHMudmFsdWUgIT0gMCAmJiAhcy52YWx1ZSkgfHwgaXNOYU4ocy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZWxzZSBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21wLnB1c2goeyBkYXRlOiBkYXRlLCB2YWx1ZTogcy52YWx1ZSB9KVxyXG4gICAgICAgICAgICBzdW0gKz0gcy52YWx1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FzZSB3aGVuIG5vIGRhdGFcclxuICAgICAgICBpZiAoc3VtID09IDApIHJldHVybiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHllYXItb24teWVhciBwZXJjZW50YWdlIGNoYW5nZVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29tcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gY29tcFtpIC0gMV0udmFsdWVcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY29tcFtpXS52YWx1ZVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2UgY2hhbmdlIGZyb20gcHJldmlvdXMgdmFsdWVcclxuICAgICAgICAgICAgY29tcFtpXS5wZXJjZW50YWdlQ2hhbmdlID0gcHJldmlvdXNWYWx1ZSA9PT0gMCA/IDAuMDAxIDogKChjdXJyZW50VmFsdWUgLSBwcmV2aW91c1ZhbHVlKSAvIHByZXZpb3VzVmFsdWUpICogMTAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgZmlyc3QgZGF0YSBwb2ludCBkb2Vzbid0IGhhdmUgYSBwcmV2aW91cyB2YWx1ZSB0byBjb21wYXJlIHdpdGhcclxuICAgICAgICAvL2NvbXBbMF0ucGVyY2VudGFnZUNoYW5nZSA9IDAuMDAxIC8vIG9yIHlvdSBjYW4gbGVhdmUgaXQgdW5kZWZpbmVkIG9yIG51bGwsIGRlcGVuZGluZyBvbiBob3cgeW91IHdhbnQgdG8gaGFuZGxlIGl0XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2lmIG5vdCBwcm92aWRlZCwgZ2V0IGxpc3Qgb2Ygc3RhdCBjb2RlcyBmcm9tIHRoZSBtYXAgc3RhdCBkYXRhXHJcbiAgICAgICAgaWYgKCFvdXQuX3N0YXREYXRlcykge1xyXG4gICAgICAgICAgICAvL2dldCBsaXN0IG9mIHN0YXQgY29kZXMuXHJcbiAgICAgICAgICAgIG91dC5fc3RhdERhdGVzID0gT2JqZWN0LmtleXMob3V0LnN0YXREYXRhXylcclxuICAgICAgICAgICAgLy9yZW1vdmUgXCJkZWZhdWx0XCIsIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvdXQuX3N0YXREYXRlcy5pbmRleE9mKCdkZWZhdWx0JylcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIG91dC5fc3RhdERhdGVzLnNwbGljZShpbmRleCwgMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRlZmluZSBzaXplIHNjYWxpbmcgZnVuY3Rpb25cclxuICAgICAgICAvLyBEZWZpbmUgdGhlIGRvbWFpbiBjb3JyZWN0bHkgZm9yIHRoZSBsb2cgc2NhbGVcclxuICAgICAgICBvdXQuZG9tYWluID0gb3V0LnNwYXJrUGVyY2VudGFnZUNoYW5nZV8gPyBbMWUtMywgMTBdIDogZ2V0RGF0YXNldE1heE1pbigpIC8vIEF2b2lkIDAgZm9yIGxvZyBzY2FsZVxyXG5cclxuICAgICAgICAvLyBmb3IgYXJlYSBjaGFydHNcclxuICAgICAgICBvdXQud2lkdGhDbGFzc2lmaWVyXyA9IHNjYWxlU3FydCgpLmRvbWFpbihvdXQuZG9tYWluKS5yYW5nZShbMCwgb3V0LnNwYXJrTGluZVdpZHRoX10pXHJcbiAgICAgICAgb3V0LmhlaWdodENsYXNzaWZpZXJfID0gc2NhbGVTcXJ0KCkuZG9tYWluKG91dC5kb21haW4pLnJhbmdlKFswLCBvdXQuc3BhcmtMaW5lSGVpZ2h0X10pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vYnVpbGQgYW5kIGFzc2lnbiBwaWUgY2hhcnRzIHRvIHRoZSByZWdpb25zXHJcbiAgICAgICAgLy9jb2xsZWN0IG51dHMgaWRzIGZyb20gZyBlbGVtZW50cy4gVE9ETzogZmluZCBiZXR0ZXIgd2F5IG9mIGdldHRpbmcgSURzXHJcbiAgICAgICAgbGV0IG51dHNJZHMgPSBbXVxyXG4gICAgICAgIGxldCBzID0gb3V0LnN2ZygpLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgbGV0IHN5bSA9IHMuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykuYXR0cignaWQnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgbnV0c0lkcy5wdXNoKHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgIHJldHVybiAnc3BhcmtfJyArIHJnLnByb3BlcnRpZXMuaWRcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBzZXQgcmVnaW9uIGhvdmVyIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3Iob3V0KVxyXG4gICAgICAgIGxldCByZWdpb25zID0gb3V0LnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBvdXQuaG92ZXJDb2xvcl8pXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldENvbXBvc2l0aW9uKHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRGaWxsID0gc2VsLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0ZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIGFkZFNwYXJrTGluZXNUb01hcChudXRzSWRzKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTcGFya0xpbmVzVG9NYXAoaWRzKSB7XHJcbiAgICAgICAgaWRzLmZvckVhY2goKG51dHNpZCkgPT4ge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBzdmcgZm9yIHNwYXJrbGluZVxyXG4gICAgICAgICAgICAvLyBjYW4gYmUgbW9yZSB0aGFuIG9uZSBjZW50ZXIgcG9pbnQgZm9yIGVhY2ggbnV0cyBJRCAoZS5nLiBNYWx0YSB3aGVuIGluY2x1ZGVkIGluIGluc2V0cylcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBvdXQuc3ZnKCkuc2VsZWN0KCcjc3BhcmtfJyArIG51dHNpZClcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBnZXRDb21wb3NpdGlvbihudXRzaWQpXHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlU3BhcmtMaW5lQ2hhcnQobm9kZSwgZGF0YSwgb3V0LnNwYXJrTGluZVdpZHRoXywgb3V0LnNwYXJrTGluZUhlaWdodF8pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNwYXJrTGluZUNoYXJ0KG5vZGUsIGRhdGEsIHcsIGgsIGlzRm9yVG9vbHRpcCA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBleHRlbnQgb2YgdGhlIHdob2xlIGRhdGFzZXRcclxuICAgICAgICBsZXQgZXh0ID0gb3V0LmRvbWFpblxyXG4gICAgICAgIGxldCBoZWlnaHQgPSBvdXQuc3BhcmtUeXBlXyA9PT0gJ2FyZWEnID8gb3V0LndpZHRoQ2xhc3NpZmllcl8oZXh0WzFdKSA6IGhcclxuICAgICAgICBsZXQgd2lkdGggPSBvdXQuc3BhcmtUeXBlXyA9PT0gJ2FyZWEnID8gb3V0LmhlaWdodENsYXNzaWZpZXJfKGV4dFsxXSkgOiB3XHJcblxyXG4gICAgICAgIGxldCBzY2FsZWREYXRhXHJcblxyXG4gICAgICAgIC8vIERlZmluZSBYIHNjYWxlXHJcbiAgICAgICAgbGV0IHhTY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLmRvbWFpbihbb3V0Ll9zdGF0RGF0ZXNbMF0sIG91dC5fc3RhdERhdGVzW291dC5fc3RhdERhdGVzLmxlbmd0aCAtIDFdXSlcclxuICAgICAgICAgICAgLnJhbmdlKFswLjUsIHdpZHRoIC0gMC41XSlcclxuXHJcbiAgICAgICAgLy8gUHJlY29tcHV0ZSB0aGUgc2NhbGVkIHZhbHVlcyBmb3IgdGhlIGRhdGEgcG9pbnRzXHJcbiAgICAgICAgaWYgKG91dC5zcGFya1BlcmNlbnRhZ2VDaGFuZ2VfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhbml0aXplTG9nVmFsdWUgPSAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIDAuMDAxIC8vIEF2b2lkIHplcm9cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXJQb3NpdGlvbiA9IGhlaWdodCAvIDJcclxuXHJcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgZm9yIHNjYWxpbmdcclxuICAgICAgICAgICAgY29uc3QgcG9zaXRpdmVEYXRhID0gZGF0YS5maWx0ZXIoKGQpID0+IGQucGVyY2VudGFnZUNoYW5nZSA+IDApLm1hcCgoZCkgPT4gc2FuaXRpemVMb2dWYWx1ZShkLnBlcmNlbnRhZ2VDaGFuZ2UpKVxyXG4gICAgICAgICAgICBjb25zdCBuZWdhdGl2ZURhdGEgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5wZXJjZW50YWdlQ2hhbmdlIDwgMCkubWFwKChkKSA9PiBzYW5pdGl6ZUxvZ1ZhbHVlKGQucGVyY2VudGFnZUNoYW5nZSkpXHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGluZyBwb3NpdGl2ZSB2YWx1ZXMgdXNpbmcgYSBwb3NpdGl2ZSBsb2cgc2NhbGVcclxuICAgICAgICAgICAgY29uc3QgbWF4UG9zaXRpdmUgPSBtYXgocG9zaXRpdmVEYXRhKSB8fCAxXHJcbiAgICAgICAgICAgIGNvbnN0IG1pblBvc2l0aXZlID0gMC4wMDAxXHJcbiAgICAgICAgICAgIGNvbnN0IG1pbk5lZ2F0aXZlID0gbWluKG5lZ2F0aXZlRGF0YSkgfHwgLTFcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlTG9nUG9zaXRpdmUgPSBzY2FsZUxvZygpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKFttaW5Qb3NpdGl2ZSwgbWF4UG9zaXRpdmVdKSAvLyBGb3IgcG9zaXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoW2hlaWdodCAvIDIsIDBdKSAvLyBQb3NpdGl2ZSB2YWx1ZXMgYWJvdmUgY2VudGVyXHJcblxyXG4gICAgICAgICAgICBjb25zdCBzY2FsZUxvZ05lZ2F0aXZlID0gc2NhbGVMb2coKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbLTAuMDEsIG1pbk5lZ2F0aXZlXSkgLy8gRm9yIG5lZ2F0aXZlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQgLyAyLCBoZWlnaHRdKSAvLyBOZWdhdGl2ZSB2YWx1ZXMgYmVsb3cgY2VudGVyXHJcblxyXG4gICAgICAgICAgICBpZiAoIXBvc2l0aXZlRGF0YS5sZW5ndGggfHwgIW5lZ2F0aXZlRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBkYXRhJylcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJlY29tcHV0ZSBzY2FsZWQgWSBkYXRhXHJcbiAgICAgICAgICAgIHNjYWxlZERhdGEgPSBkYXRhLm1hcCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZC5zY2FsZWRZVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIGQucGVyY2VudGFnZUNoYW5nZSA8IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzY2FsZUxvZ05lZ2F0aXZlKHNhbml0aXplTG9nVmFsdWUoZC5wZXJjZW50YWdlQ2hhbmdlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzY2FsZUxvZ1Bvc2l0aXZlKHNhbml0aXplTG9nVmFsdWUoZC5wZXJjZW50YWdlQ2hhbmdlKSlcclxuXHJcbiAgICAgICAgICAgICAgICBkLnNjYWxlZFhWYWx1ZSA9IHhTY2FsZShkLmRhdGUpXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQuc2NhbGVkWVZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05hTiBkZXRlY3RlZCBpbiBzY2FsZWRWYWx1ZTonLCBkKVxyXG4gICAgICAgICAgICAgICAgICAgIGQuc2NhbGVkWVZhbHVlID0gMC4wMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGF4aXNcclxuICAgICAgICAgICAgaWYgKGlzRm9yVG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBYIEF4aXNcclxuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYXhpcycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgaGVpZ2h0ICsgJyknKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGF4aXNCb3R0b20oeFNjYWxlKS50aWNrcyhvdXQuX3N0YXREYXRlcy5sZW5ndGgpLnRpY2tGb3JtYXQoZm9ybWF0KCcuMGYnKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsICctLjhlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4xNWVtJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgtNjUpJylcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIFkgQXhpcyBmb3IgcG9zaXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGl2ZVRpY2tWYWx1ZXNZID0gWzFdXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZWdhdGl2ZVRpY2tWYWx1ZXNZID0gWy0wLjVdXHJcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ktYXhpcy1uZWdhdGl2ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoLTEwLCAkezB9KWApIC8vIFBvc2l0aW9uIGZvciBuZWdhdGl2ZSBheGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXhpc0xlZnQoc2NhbGVMb2dOZWdhdGl2ZSkudGlja1ZhbHVlcyhuZWdhdGl2ZVRpY2tWYWx1ZXNZKS50aWNrRm9ybWF0KGZvcm1hdCgnLC4ycicpKSlcclxuXHJcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ktYXhpcy1wb3NpdGl2ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHstMTB9LCAwKWApXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXhpc0xlZnQoc2NhbGVMb2dQb3NpdGl2ZSkudGlja1ZhbHVlcyhwb3NpdGl2ZVRpY2tWYWx1ZXNZKS50aWNrRm9ybWF0KGZvcm1hdCgnLC4ycicpKSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBhZGQgYSBjdXN0b20gbGFiZWwgZm9yIDBcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndGljaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtoZWlnaHQgLyAyfSlgKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2N1cnJlbnRDb2xvcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KCcwJykgLy8gQ3VzdG9tIGxhYmVsIGZvciBzbWFsbCB2YWx1ZSAoMC4xMClcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwb3NpdGl2ZVRpY2tWYWx1ZXNZLCBuZWdhdGl2ZVRpY2tWYWx1ZXNZKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmF3IGNvdW50cyAobGluZWFyIHNjYWxlIGZvciBib3RoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSlcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHlTY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgICAgIC5kb21haW4oZXh0KVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQgLSAwLjUsIDBdKVxyXG5cclxuICAgICAgICAgICAgc2NhbGVkRGF0YSA9IGRhdGEubWFwKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkLnNjYWxlZFhWYWx1ZSA9IHhTY2FsZShkLmRhdGUpXHJcbiAgICAgICAgICAgICAgICBkLnNjYWxlZFlWYWx1ZSA9IHlTY2FsZShkLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vRHJhdyBheGlzXHJcbiAgICAgICAgICAgIGlmIChpc0ZvclRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgWCBBeGlzXHJcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGhlaWdodCArICcpJylcclxuICAgICAgICAgICAgICAgICAgICAuY2FsbChheGlzQm90dG9tKHhTY2FsZSkudGlja3Mob3V0Ll9zdGF0RGF0ZXMubGVuZ3RoKS50aWNrRm9ybWF0KGZvcm1hdCgnLjBmJykpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHgnLCAnLS44ZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMTVlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICdyb3RhdGUoLTY1KScpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBZIEF4aXNcclxuICAgICAgICAgICAgICAgIGxldCBkb21haW5ZID0geVNjYWxlLmRvbWFpbigpXHJcbiAgICAgICAgICAgICAgICBsZXQgdGlja1ZhbHVlcyA9IFtkb21haW5ZWzBdLCAoKGRvbWFpbllbMF0gKyBkb21haW5ZWzFdKSAvIDIpLnRvRml4ZWQoMSksIGRvbWFpbllbMV1dXHJcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGF4aXNMZWZ0KHlTY2FsZSkudGlja1ZhbHVlcyh0aWNrVmFsdWVzKS50aWNrRm9ybWF0KGZvcm1hdCgnLC4ycicpKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGluZUdlbmVyYXRvciA9IGxpbmUoKVxyXG4gICAgICAgICAgICAueCgoZCwgaSkgPT4gZC5zY2FsZWRYVmFsdWUpXHJcbiAgICAgICAgICAgIC55KChkKSA9PiBkLnNjYWxlZFlWYWx1ZSlcclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aGUgYXJlYSAoZm9yIGFyZWEgY2hhcnQpXHJcbiAgICAgICAgaWYgKG91dC5zcGFya1R5cGVfID09PSAnYXJlYScpIHtcclxuICAgICAgICAgICAgbm9kZS5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIHR5cGVvZiBvdXQuc3BhcmtBcmVhQ29sb3JfID09PSAnZnVuY3Rpb24nID8gKGQsIGkpID0+IG91dC5zcGFya0FyZWFDb2xvcl8oZCwgaSkgOiBvdXQuc3BhcmtBcmVhQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHR5cGVvZiBvdXQuc3BhcmtMaW5lQ29sb3JfID09PSAnZnVuY3Rpb24nID8gKGQsIGkpID0+IG91dC5zcGFya0xpbmVDb2xvcl8oZCwgaSkgOiBvdXQuc3BhcmtMaW5lQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8gPT09ICdmdW5jdGlvbicgPyAoZCwgaSkgPT4gb3V0LnNwYXJrTGluZVN0cm9rZVdpZHRoXyhkLCBpKSA6IG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8gKyAncHgnXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIG91dC5zcGFya0xpbmVPcGFjaXR5XylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAwLjMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAgICAgJ2QnLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZWEoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAueCgoZCwgaSkgPT4gZC5zY2FsZWRYVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC55MChoZWlnaHQpIC8vIEJhc2VsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC55MSgoZCkgPT4gZC5zY2FsZWRZVmFsdWUpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IGB0cmFuc2xhdGUoMCwtJHtoZWlnaHQgLyAyfSlgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aGUgbGluZVxyXG4gICAgICAgIG5vZGUuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKHNjYWxlZERhdGEpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBvdXQuc3BhcmtMaW5lT3BhY2l0eV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCB0eXBlb2Ygb3V0LnNwYXJrTGluZUNvbG9yXyA9PT0gJ2Z1bmN0aW9uJyA/IChkLCBpKSA9PiBvdXQuc3BhcmtMaW5lQ29sb3JfKGQsIGkpIDogb3V0LnNwYXJrTGluZUNvbG9yXylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJyxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBvdXQuc3BhcmtMaW5lU3Ryb2tlV2lkdGhfID09PSAnZnVuY3Rpb24nID8gKGQsIGkpID0+IG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8oZCwgaSkgOiBvdXQuc3BhcmtMaW5lU3Ryb2tlV2lkdGhfICsgJ3B4J1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgbGluZUdlbmVyYXRvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiAoaXNGb3JUb29sdGlwID8gbnVsbCA6IGB0cmFuc2xhdGUoMCwke291dC5zcGFya1BlcmNlbnRhZ2VDaGFuZ2VfID8gLWRbMF0uc2NhbGVkWVZhbHVlIDogLWRbMF0uc2NhbGVkWVZhbHVlfSlgKSkgLy9vcmlnaW4gb2YgbGluZSBpcyBmaXJzdCBkYXRhIHBvaW50IGxvY2F0aW9uXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgZG90c1xyXG4gICAgICAgIG5vZGUuc2VsZWN0QWxsKCdteUNpcmNsZXMnKVxyXG4gICAgICAgICAgICAuZGF0YShkYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAncmVkJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgKGQsIGkpID0+IGQuc2NhbGVkWFZhbHVlKVxyXG4gICAgICAgICAgICAuYXR0cignY3knLCAoZCkgPT4gZC5zY2FsZWRZVmFsdWUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgb3V0LnNwYXJrTGluZUNpcmNsZVJhZGl1c18pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gKGlzRm9yVG9vbHRpcCA/IG51bGwgOiBgdHJhbnNsYXRlKDAsLSR7aGVpZ2h0IC8gMn0pYCkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gZ2V0RGF0YXNldE1heE1pblxyXG4gICAgICogQGRlc2NyaXB0aW9uIGdldHMgdGhlIG1heGltdW0gYW5kIG1pbmltdW0gdmFsdWVzIG9mIGFsbCBkYXRlcyBmb3IgZWFjaCByZWdpb24uIFVzZWQgdG8gZGVmaW5lIHRoZSBkb21haW4gb2YgdGhlIHNwYXJrbGluZSBZIGF4aXMuXHJcbiAgICAgKiBAcmV0dXJucyBbbWluLG1heF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YXNldE1heE1pbigpIHtcclxuICAgICAgICBsZXQgbWF4cyA9IFtdXHJcbiAgICAgICAgbGV0IHNlbCA9IG91dC5zdmcoKS5zZWxlY3RBbGwoJyNlbS1wcm9wLXN5bWJvbHMnKS5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKS5kYXRhKClcclxuXHJcbiAgICAgICAgc2VsLmZvckVhY2goKHJnKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpZCA9IHJnLnByb3BlcnRpZXMuaWRcclxuICAgICAgICAgICAgbGV0IG1heCA9IGdldFJlZ2lvbk1heChpZClcclxuICAgICAgICAgICAgaWYgKG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4cy5wdXNoKG1heClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCBtaW5tYXggPSBleHRlbnQobWF4cylcclxuICAgICAgICByZXR1cm4gbWlubWF4XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWJzb2x1dGUgdG90YWwgdmFsdWUgb2YgY29tYmluZWQgc3RhdGlzdGljYWwgdmFsdWVzIGZvciBhIHNwZWNpZmljIHJlZ2lvbi4gRS5nIHRvdGFsIGxpdmVzdG9ja1xyXG4gICAgICogQHBhcmFtIHsqfSBpZCBudXRzIHJlZ2lvbiBpZFxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRSZWdpb25NYXggPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgbWF4ID0gMFxyXG4gICAgICAgIGxldCBzXHJcblxyXG4gICAgICAgIC8vZ2V0IHN0YXQgdmFsdWUgZm9yIGVhY2ggZGF0ZSBhbmQgZmluZCB0aGUgbWF4XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuX3N0YXREYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL3JldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuX3N0YXREYXRlc1tpXVxyXG4gICAgICAgICAgICBzID0gb3V0LnN0YXREYXRhKHNjKS5nZXQoaWQpXHJcbiAgICAgICAgICAgIC8vY2FzZSB3aGVuIHNvbWUgZGF0YSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHMudmFsdWUgPiBtYXgpIG1heCA9IHMudmFsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2FzZSB3aGVuIG5vIGRhdGFcclxuICAgICAgICBpZiAobWF4ID09IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gbWF4XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL1RPRE8gZGVmaW5lIGxlZ2VuZFxyXG4gICAgICAgIHJldHVybiBsZ2NoLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gZnVuY3Rpb24gKHJlZ2lvbiwgbWFwKSB7XHJcbiAgICAgICAgY29uc3QgYnVmID0gW11cclxuXHJcbiAgICAgICAgLy8gSGVhZGVyIHdpdGggcmVnaW9uIG5hbWUgYW5kIElEXHJcbiAgICAgICAgY29uc3QgcmVnaW9uTmFtZSA9IHJlZ2lvbi5wcm9wZXJ0aWVzLm5hXHJcbiAgICAgICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPlxyXG4gICAgICAgICAgICAgICAgPGI+JHtyZWdpb25OYW1lfTwvYj4ke3JlZ2lvbklkID8gYCAoJHtyZWdpb25JZH0pYCA6ICcnfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBgKVxyXG5cclxuICAgICAgICAvLyBQcmVwYXJlIGRhdGEgZm9yIHNwYXJrbGluZSBjaGFydFxyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG91dC5zcGFya1Rvb2x0aXBDaGFydF8uaGVpZ2h0XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBvdXQuc3BhcmtUb29sdGlwQ2hhcnRfLndpZHRoXHJcbiAgICAgICAgY29uc3QgbWFyZ2luID0gb3V0LnNwYXJrVG9vbHRpcENoYXJ0Xy5tYXJnaW5cclxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Q29tcG9zaXRpb24ocmVnaW9uLnByb3BlcnRpZXMuaWQpXHJcblxyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBTVkcgZWxlbWVudCBkZXRhY2hlZCBmcm9tIHRoZSBkb2N1bWVudFxyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBjcmVhdGUoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtY2hhcnQtY29udGFpbmVyJylcclxuICAgICAgICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtY2hhcnQtc3ZnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXHJcblxyXG4gICAgICAgICAgICBjb25zdCBnID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sICR7bWFyZ2luLnRvcH0pYClcclxuXHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBjaGFydCB3aXRoaW4gdGhlIFNWR1xyXG4gICAgICAgICAgICBjcmVhdGVTcGFya0xpbmVDaGFydChnLCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCB0cnVlKVxyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIG5vZGUgdG8gYW4gSFRNTCBzdHJpbmcgYW5kIGFkZCBpdCB0byB0aGUgYnVmZmVyXHJcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGNvbnRhaW5lci5ub2RlKCkub3V0ZXJIVE1MKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBidWZmZXIgYXMgYSBzaW5nbGUgc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLy9idWlsZCBhIGNvbG9yIGxlZ2VuZCBvYmplY3RcclxuZXhwb3J0IGNvbnN0IGdldENvbG9yTGVnZW5kID0gZnVuY3Rpb24gKGNvbG9yRnVuKSB7XHJcbiAgICBjb2xvckZ1biA9IGNvbG9yRnVuIHx8IGludGVycG9sYXRlWWxPclJkXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuKGVjbCAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSlcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGFyYywgcGllIH0gZnJvbSAnZDMtc2hhcGUnXHJcbmltcG9ydCB7IHNjaGVtZUNhdGVnb3J5MTAgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbi8vc2NoZW1lU2V0MyBzY2hlbWVEYXJrMiBzY2hlbWVQYXN0ZWwxIHNjaGVtZVRhYmxlYXUxMFxyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIFN0cmlwZUNvbXBvc2l0aW9uTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtc3RyaXBlLWNvbXBvc2l0aW9uJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgZ2V0UmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuLyoqXHJcbiAqIFJldHVybiBhIHN0cmlwZSBjb21wb3NpdGlvbiBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgZmFsc2UsICdzY29tcCcpXHJcblxyXG4gICAgLy93aWR0aCBvZiB0aGUgc3RyaXBlcyBzZXJpZVxyXG4gICAgb3V0LnN0cmlwZVdpZHRoXyA9IDUwXHJcbiAgICAvL29yaWVudGF0aW9uIC0gdmVydGljYWwgYnkgZGVmYXVsdFxyXG4gICAgb3V0LnN0cmlwZU9yaWVudGF0aW9uXyA9IDBcclxuXHJcbiAgICAvL2NvbG9ycyAtIGluZGV4ZWQgYnkgY2F0ZWdvcnkgY29kZVxyXG4gICAgb3V0LmNhdENvbG9yc18gPSB1bmRlZmluZWRcclxuICAgIC8vbGFiZWxzIC0gaW5kZXhlZCBieSBjYXRlZ29yeSBjb2RlXHJcbiAgICBvdXQuY2F0TGFiZWxzXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vc2hvdyBzdHJpcGVzIG9ubHkgd2hlbiBkYXRhIGZvciBhbGwgY2F0ZWdvcmllcyBpcyBjb21wbGV0ZS5cclxuICAgIC8vT3RoZXJ3aXNlLCBjb25zaWRlciB0aGUgcmVnaW9ucyBhcyBiZWluZyB3aXRoIG5vIGRhdGEgYXQgYWxsLlxyXG4gICAgb3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlXyA9IGZhbHNlXHJcblxyXG4gICAgLy90b29sdGlwIHBpZSBjaGFydFxyXG4gICAgb3V0LnBpZUNoYXJ0UmFkaXVzXyA9IDQwXHJcbiAgICBvdXQucGllQ2hhcnRJbm5lclJhZGl1c18gPSAxNVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ3N0cmlwZVdpZHRoXycsXHJcbiAgICAgICAgJ3N0cmlwZU9yaWVudGF0aW9uXycsXHJcbiAgICAgICAgJ2NhdENvbG9yc18nLFxyXG4gICAgICAgICdjYXRMYWJlbHNfJyxcclxuICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGVfJyxcclxuICAgICAgICAnbm9EYXRhRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ3BpZUNoYXJ0UmFkaXVzXycsXHJcbiAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ3N0cmlwZVdpZHRoJyxcclxuICAgICAgICAgICAgJ3N0cmlwZU9yaWVudGF0aW9uJyxcclxuICAgICAgICAgICAgJ2NhdENvbG9ycycsXHJcbiAgICAgICAgICAgICdjYXRMYWJlbHMnLFxyXG4gICAgICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGUnLFxyXG4gICAgICAgICAgICAnbm9EYXRhRmlsbFN0eWxlJyxcclxuICAgICAgICAgICAgJ3BpZUNoYXJ0UmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXMnLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRlZmluZSBhIHN0cmlwZSBtYXAgZWFzaWx5LCB3aXRob3V0IHJlcGV0aXRpb24gb2YgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBPbmx5IGZvciBldXJvYmFzZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0IEEgcGF0dGVybiBmb3IgdGhlIHN0YXQgZGF0YSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaW0gVGhlIGRpbWVuc2lvbiBvZiB0aGUgY29tcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2RlcyBUaGUgY2F0ZWdvcnkgY29kZXMgb2YgdGhlIGNvbXBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsYWJlbHMgT3B0aW9uYWw6IFRoZSBsYWJlbHMgZm9yIHRoZSBjYXRlZ29yeSBjb2Rlc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sb3JzIE9wdGlvbmFsOiBUaGUgY29sb3JzIGZvciB0aGUgY2F0ZWdvcnlcclxuICAgICAqL1xyXG4gICAgb3V0LnN0YXRDb21wID0gZnVuY3Rpb24gKHN0YXQsIGRpbSwgY29kZXMsIGxhYmVscywgY29sb3JzKSB7XHJcbiAgICAgICAgLy9hZGQgb25lIGRhdGFzZXQgY29uZmlnIGZvciBlYWNoIGNhdGVnb3J5XHJcbiAgICAgICAgc3RhdC5maWx0ZXJzID0gc3RhdC5maWx0ZXJzIHx8IHt9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL2NhdGVnb3J5IGNvZGVcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGNvZGVzW2ldXHJcbiAgICAgICAgICAgIHN0YXQuZmlsdGVyc1tkaW1dID0gY29kZVxyXG4gICAgICAgICAgICBjb25zdCBzY18gPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdCkgc2NfW2tleV0gPSBzdGF0W2tleV1cclxuICAgICAgICAgICAgc2NfLmZpbHRlcnMgPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdC5maWx0ZXJzKSBzY18uZmlsdGVyc1trZXldID0gc3RhdC5maWx0ZXJzW2tleV1cclxuICAgICAgICAgICAgb3V0LnN0YXQoY29kZSwgc2NfKVxyXG5cclxuICAgICAgICAgICAgLy9pZiBzcGVjaWZpZWQsIHJldHJpZXZlIGFuZCBhc3NpZ24gY29sb3JcclxuICAgICAgICAgICAgaWYgKGNvbG9ycykge1xyXG4gICAgICAgICAgICAgICAgb3V0LmNhdENvbG9yc18gPSBvdXQuY2F0Q29sb3JzXyB8fCB7fVxyXG4gICAgICAgICAgICAgICAgb3V0LmNhdENvbG9yc19bY29kZV0gPSBjb2xvcnNbaV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgcmV0cmlldmUgYW5kIGFzc2lnbiBsYWJlbFxyXG4gICAgICAgICAgICBpZiAobGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0TGFiZWxzX1tjb2RlXSA9IGxhYmVsc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NldCBzdGF0Q29kZXNcclxuICAgICAgICBzdGF0Q29kZXMgPSBjb2Rlc1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBjb2RlcyBvZiB0aGUgY2F0ZWdvcmllcyB0byBjb25zaWRlciBmb3IgdGhlIGNvbXBvc2l0aW9uLiAqL1xyXG4gICAgbGV0IHN0YXRDb2RlcyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY29tcHV0ZSBjb21wb3NpdGlvbiBmb3IgcmVnaW9uIGlkLCBmb3IgZWFjaCBjYXRlZ29yeS5cclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCwgZm9yIGVhY2ggY2F0ZWdvcnksIHRoZSBzaGFyZSBbMCwxXSBvZiB0aGUgY2F0ZWdvcnkuXHJcbiAgICAgKiBAcGFyYW0geyp9IGlkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldENvbXBvc2l0aW9uID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgbGV0IGNvbXAgPSB7fSxcclxuICAgICAgICAgICAgc3VtID0gMFxyXG4gICAgICAgIC8vZ2V0IHN0YXQgdmFsdWUgZm9yIGVhY2ggY2F0ZWdvcnkuIENvbXB1dGUgdGhlIHN1bS5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRDb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL3JldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3Qgc2MgPSBzdGF0Q29kZXNbaV1cclxuICAgICAgICAgICAgY29uc3QgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KGlkKVxyXG5cclxuICAgICAgICAgICAgLy9jYXNlIHdoZW4gc29tZSBkYXRhIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgaWYgKCFzIHx8IChzLnZhbHVlICE9IDAgJiYgIXMudmFsdWUpIHx8IGlzTmFOKHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlKCkpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGVsc2UgY29udGludWVcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29tcFtzY10gPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIHN1bSArPSBzLnZhbHVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2Nhc2Ugd2hlbiBubyBkYXRhXHJcbiAgICAgICAgaWYgKHN1bSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSByYXRpb3NcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRDb2Rlcy5sZW5ndGg7IGkrKykgY29tcFtzdGF0Q29kZXNbaV1dIC89IHN1bVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9pZiBub3QgcHJvdmlkZWQsIGdldCBsaXN0IG9mIHN0YXQgY29kZXMgZnJvbSB0aGUgbWFwIHN0YXQgZGF0YVxyXG4gICAgICAgIGlmICghc3RhdENvZGVzKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGxpc3Qgb2Ygc3RhdCBjb2Rlcy5cclxuICAgICAgICAgICAgc3RhdENvZGVzID0gT2JqZWN0LmtleXMob3V0LnN0YXREYXRhXylcclxuICAgICAgICAgICAgLy9yZW1vdmUgXCJkZWZhdWx0XCIsIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdGF0Q29kZXMuaW5kZXhPZignZGVmYXVsdCcpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSBzdGF0Q29kZXMuc3BsaWNlKGluZGV4LCAxKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9pZiBub3Qgc3BlY2lmaWVkLCBidWlsZCBkZWZhdWx0IGNvbG9yIHJhbXBcclxuICAgICAgICBpZiAoIW91dC5jYXRDb2xvcnMoKSkge1xyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzKHt9KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRDb2Rlcy5sZW5ndGg7IGkrKykgb3V0LmNhdENvbG9ycygpW3N0YXRDb2Rlc1tpXV0gPSBzY2hlbWVDYXRlZ29yeTEwW2kgJSAxMF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgaW5pdGlhbGlzZSBjYXRlZ29yeSBsYWJlbHNcclxuICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcblxyXG4gICAgICAgIC8vYnVpbGQgYW5kIGFzc2lnbiB0ZXh0dXJlIHRvIHRoZSByZWdpb25zXHJcbiAgICAgICAgb3V0LnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoZ2V0UmVnaW9uc1NlbGVjdG9yKG91dCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGQucHJvcGVydGllcy5pZFxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBjb21wb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRpb24gPSBnZXRDb21wb3NpdGlvbihpZClcclxuXHJcbiAgICAgICAgICAgICAgICAvL2Nhc2Ugd2hlbiBubyBvciBtaXNzaW5nIGRhdGFcclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9zaXRpb24pIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHN0cmlwZSBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ID0gb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3BhdHRlcm5fJyArIGlkKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJzAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJzAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zdHJpcGVXaWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwYXR0ZXJuVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxyXG4gICAgICAgICAgICAgICAgLy91c2Ugb3JpZW50YXRpb24sIGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zdHJpcGVPcmllbnRhdGlvbigpKSBwYXR0LmF0dHIoJ3BhdHRlcm5UcmFuc2Zvcm0nLCAncm90YXRlKCcgKyBvdXQuc3RyaXBlT3JpZW50YXRpb24oKSArICcpJylcclxuXHJcbiAgICAgICAgICAgICAgICAvL2JhY2tncm91bmRcclxuICAgICAgICAgICAgICAgIHBhdHQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zdHJpcGVXaWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdsaWdodGdyYXknKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFrZSBzdHJpcGVzLCBvbmUgcGVyIGNhdGVnb3J5XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IDBcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgaW4gY29tcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2dldCBzdHJpcGUgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkeCA9IGNvbXBvc2l0aW9uW2NvZGVdXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkeCkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBkeCAqPSBvdXQuc3RyaXBlV2lkdGgoKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dldCBzdHJpcGUgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBvdXQuY2F0Q29sb3JzKClbY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgc3RyaXBlIHRvIHBhdHRlcm46IGEgdGhpbiByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgICAgICBwYXR0LmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjb2RlJywgY29kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY29sKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RyYW5zaXRpb24gYWxvbmcgeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGR4KVxyXG4gICAgICAgICAgICAgICAgICAgIHggKz0gZHhcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBwYXR0ZXJuIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd1cmwoI3BhdHRlcm5fJyArIGlkICsgJyknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCduZCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWdldENvbXBvc2l0aW9uKGQucHJvcGVydGllcy5pZCkgPyAnbmQnIDogJydcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gc2V0IHJlZ2lvbiBob3ZlciBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG91dClcclxuICAgICAgICBsZXQgcmVnaW9ucyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIHNlbC5zdHlsZSgnZmlsbCcpKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgb3V0LmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEZpbGwgPSBzZWwuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGwgPSBzZWwuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmlwZUNvbXBvc2l0aW9uTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gZnVuY3Rpb24gKHJnLCBtYXApIHtcclxuICAgICAgICAvL2dldCB0b29sdGlwXHJcbiAgICAgICAgY29uc3QgdHAgPSBzZWxlY3QoJyN0b29sdGlwX2V1cm9zdGF0JylcclxuXHJcbiAgICAgICAgLy9jbGVhclxyXG4gICAgICAgIHRwLmh0bWwoJycpXHJcbiAgICAgICAgdHAuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy93cml0ZSByZWdpb24gbmFtZVxyXG4gICAgICAgIGNvbnN0IHJlZ2lvbk5hbWUgPSByZy5wcm9wZXJ0aWVzLm5hIHx8IHJnLnByb3BlcnRpZXMubmFtZVxyXG4gICAgICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgICAgIC8vbmFtZSBhbmQgY29kZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmh0bWwoJzxiPicgKyByZWdpb25OYW1lICsgJzwvYj4gKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPGJyPicpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmh0bWwoJzxiPicgKyByZWdpb25OYW1lICsgJzwvYj48YnI+JylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBkYXRhIGZvciBwaWUgY2hhcnRcclxuICAgICAgICBjb25zdCBkYXRhID0gW11cclxuICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wKSBkYXRhLnB1c2goeyBjb2RlOiBrZXksIHZhbHVlOiBjb21wW2tleV0gfSlcclxuXHJcbiAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKS5odG1sKG91dC5ub0RhdGFUZXh0KCkpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICBjb25zdCByID0gb3V0LnBpZUNoYXJ0UmFkaXVzKCksXHJcbiAgICAgICAgICAgIGlyID0gb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXMoKVxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IHRwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgWy1yLCAtciwgMiAqIHIsIDIgKiByXSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMiAqIHIpXHJcblxyXG4gICAgICAgIC8vbWFrZSBwaWUgY2hhcnQuIFNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGQzL3BpZS1jaGFydFxyXG4gICAgICAgIGNvbnN0IHBpZV8gPSBwaWUoKVxyXG4gICAgICAgICAgICAuc29ydChudWxsKVxyXG4gICAgICAgICAgICAudmFsdWUoKGQpID0+IGQudmFsdWUpXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZGFya2dyYXknKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdGEocGllXyhkYXRhKSlcclxuICAgICAgICAgICAgLmpvaW4oJ3BhdGgnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jYXRDb2xvcnMoKVtkLmRhdGEuY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBhcmMoKS5pbm5lclJhZGl1cyhpcikub3V0ZXJSYWRpdXMocikpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRvb2x0aXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICBjb25maWcgPSBjb25maWcgfHwge31cclxuICAgIGNvbmZpZy5jb250YWluZXJJZCA9IGNvbmZpZy5jb250YWluZXJJZCB8fCAnbWFwJ1xyXG4gICAgY29uZmlnLmRpdiA9IGNvbmZpZy5kaXYgfHwgJ3Rvb2x0aXBfZXVyb3N0YXQnXHJcbiAgICBjb25maWcubWF4V2lkdGggPSBjb25maWcubWF4V2lkdGggfHwgJzIwMHB4J1xyXG4gICAgY29uZmlnLmZvbnRTaXplID0gY29uZmlnLmZvbnRTaXplIHx8ICcxNHB4J1xyXG4gICAgY29uZmlnLmJhY2tncm91bmQgPSBjb25maWcuYmFja2dyb3VuZCB8fCAnd2hpdGUnXHJcbiAgICBjb25maWcucGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nIHx8ICcwcHgnXHJcbiAgICBjb25maWcuYm9yZGVyID0gY29uZmlnLmJvcmRlciB8fCAnMHB4J1xyXG4gICAgY29uZmlnLmJvcmRlclJhZGl1cyA9IGNvbmZpZy5ib3JkZXJSYWRpdXMgfHwgJzBweCdcclxuICAgIGNvbmZpZy5ib3hTaGFkb3cgPSBjb25maWcuYm94U2hhZG93IHx8ICcwcHggMHB4IDBweCBncmV5J1xyXG5cclxuICAgIGNvbmZpZy50cmFuc2l0aW9uRHVyYXRpb24gPSBjb25maWcudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDBcclxuICAgIGNvbmZpZy54T2Zmc2V0ID0gY29uZmlnLnhPZmZzZXQgfHwgMzBcclxuICAgIGNvbmZpZy55T2Zmc2V0ID0gY29uZmlnLnlPZmZzZXQgfHwgMjBcclxuXHJcbiAgICBsZXQgdG9vbHRpcFxyXG5cclxuICAgIGZ1bmN0aW9uIG15KCkge1xyXG4gICAgICAgIHRvb2x0aXAgPSBzZWxlY3QoJyMnICsgY29uZmlnLmRpdilcclxuICAgICAgICBpZiAodG9vbHRpcC5lbXB0eSgpKSB0b29sdGlwID0gc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKS5hdHRyKCdpZCcsIGNvbmZpZy5kaXYpXHJcblxyXG4gICAgICAgIHRvb2x0aXAuYXR0cignY2xhc3MnLCAndG9vbHRpcC1ldXJvc3RhdCcpXHJcbiAgICB9XHJcblxyXG4gICAgbXkubW91c2VvdmVyID0gZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgICBpZiAoaHRtbCkgdG9vbHRpcC5odG1sKGh0bWwpXHJcbiAgICAgICAgbGV0IHggPSBldmVudC5wYWdlWFxyXG4gICAgICAgIGxldCB5ID0gZXZlbnQucGFnZVlcclxuICAgICAgICBteS5lbnN1cmVUb29sdGlwT25TY3JlZW4oeCwgeSlcclxuICAgIH1cclxuXHJcbiAgICBteS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBsZXQgeCA9IGV2ZW50LnBhZ2VYXHJcbiAgICAgICAgbGV0IHkgPSBldmVudC5wYWdlWVxyXG4gICAgICAgIHRoaXMuZW5zdXJlVG9vbHRpcE9uU2NyZWVuKHgsIHkpXHJcbiAgICB9XHJcblxyXG4gICAgbXkubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdG9vbHRpcC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICB9XHJcblxyXG4gICAgbXkuc3R5bGUgPSBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHJldHVybiB0b29sdGlwLnN0eWxlKGspXHJcbiAgICAgICAgdG9vbHRpcC5zdHlsZShrLCB2KVxyXG4gICAgICAgIHJldHVybiBteVxyXG4gICAgfVxyXG5cclxuICAgIG15LmF0dHIgPSBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHJldHVybiB0b29sdGlwLmF0dHIoaylcclxuICAgICAgICB0b29sdGlwLmF0dHIoaywgdilcclxuICAgICAgICByZXR1cm4gbXlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBlbnN1cmVUb29sdGlwT25TY3JlZW5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBQcmV2ZW50cyB0aGUgdG9vbHRpcCBmcm9tIG92ZXJmbG93aW5nIG9mZiBzY3JlZW5cclxuICAgICAqL1xyXG4gICAgbXkuZW5zdXJlVG9vbHRpcE9uU2NyZWVuID0gZnVuY3Rpb24gKGV2ZW50WCwgZXZlbnRZKSB7XHJcbiAgICAgICAgdG9vbHRpcC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgbGV0IG5vZGUgPSB0b29sdGlwLm5vZGUoKVxyXG5cclxuICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBldmVudFggKyBjb25maWcueE9mZnNldCArICdweCdcclxuICAgICAgICBub2RlLnN0eWxlLnRvcCA9IGV2ZW50WSAtIGNvbmZpZy55T2Zmc2V0ICsgJ3B4J1xyXG5cclxuICAgICAgICBsZXQgcGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29uZmlnLmNvbnRhaW5lcklkKVxyXG4gICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIC8vIGdldCB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXHJcbiAgICAgICAgbGV0IHBhcmVudFdpZHRoID0gcmVjdC53aWR0aFxyXG4gICAgICAgIGxldCBwYXJlbnRIZWlnaHQgPSByZWN0LmhlaWdodFxyXG5cclxuICAgICAgICAvL3RvbyBmYXIgcmlnaHRcclxuICAgICAgICAvL3Rha2luZyBpbnRvIGFjY291bnQgb2ZmIHNjcmVlbiBzcGFjZSBidXQgc2hvdWxkbnQgYmVcclxuICAgICAgICBpZiAobm9kZS5vZmZzZXRMZWZ0ID4gcmVjdC5sZWZ0ICsgcGFyZW50V2lkdGggLSBub2RlLmNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gZXZlbnRYIC0gbm9kZS5jbGllbnRXaWR0aCAtIGNvbmZpZy54T2Zmc2V0XHJcbiAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG1vdXNlIGNvdmVycyB0b29sdGlwXHJcbiAgICAgICAgICAgIGlmIChub2RlLm9mZnNldExlZnQgKyBub2RlLmNsaWVudFdpZHRoID4gZXZlbnRYKSB7XHJcbiAgICAgICAgICAgICAgICAvL21vdmUgdG9vbHRpcCBsZWZ0IHNvIGl0IGRvZXNudCBjb3ZlciBtb3VzZVxyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQyID0gZXZlbnRYIC0gbm9kZS5jbGllbnRXaWR0aCAtIGNvbmZpZy54T2Zmc2V0XHJcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0MiArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBub2RlLnN0eWxlLnRvcCA9IG5vZGUub2Zmc2V0VG9wICsgY29uZmlnLnlPZmZzZXQgKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RvbyBmYXIgZG93blxyXG4gICAgICAgIGlmIChub2RlLm9mZnNldFRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ID4gcmVjdC50b3AgKyBwYXJlbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgPSBub2RlLm9mZnNldFRvcCAtIG5vZGUuY2xpZW50SGVpZ2h0ICsgJ3B4J1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBteSgpXHJcbiAgICByZXR1cm4gbXlcclxufVxyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCJpbXBvcnQgJy4vY3NzL2luZGV4LmNzcydcclxuZXhwb3J0ICogZnJvbSAnLi9ldXJvc3RhdC1tYXAnXHJcbi8vZXhwb3J0IHsgc3RhdERhdGEgfSBmcm9tIFwiLi9jb3JlL3N0YXQtZGF0YS5qc1wiO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=