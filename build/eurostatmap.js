(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["eurostatmap"] = factory();
	else
		root["eurostatmap"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* STYLING OF NUTS REGIONS AND BOUNDARIES */
/* Default region fill */
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    fill: #e1e1e1;
}

.em-nutsrg,
.em-cntrg,
.em-grid-cell,
#em-user-regions {
    cursor: pointer;
}

/*  boundaries stroke-width */
.em-bn-0 {
    stroke: none;
}
.em-bn-1,
.em-bn-2,
.em-bn-3,
/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-bn-co {
    stroke-width: 0.2;
}

/* all boudnaries and regions linecap/linejoin */
#em-nutsbn,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-co,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'],
.em-cntrg,
.em-nutsrg,
.em-grid-cell {
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* national boundaries */
.em-cntbn {
    stroke: #000;
    stroke-width: 0.6px;
}

/* NUTS boundaries stroke color */
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-nutsrg [lvl='3'],
.em-nutsrg [lvl='2'],
.em-nutsrg [lvl='1'] {
    stroke: #696969;
}

/* coastal boundaries */
.em-bn-co {
    stroke: white;
}

/* kosovo */
.em-kosovo-bn {
    stroke: #000;
    stroke-width: 0.15;
}



/* dont fill certain elements */
.em-frame,
.em-graticule,
.em-cntbn,
.em-bn-0,
.em-bn-1,
.em-bn-2,
.em-bn-3,
.em-kosovo-bn,
.em-bn-co {
    fill: none;
}

/* target non cc/eu/efta borders */
/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {
    stroke-width: 0;
} */
`, "",{"version":3,"sources":["webpack://./src/css/NUTS.css"],"names":[],"mappings":"AAAA,2CAA2C;AAC3C,wBAAwB;AACxB;;;IAGI,aAAa;AACjB;;AAEA;;;;IAII,eAAe;AACnB;;AAEA,6BAA6B;AAC7B;IACI,YAAY;AAChB;AACA;;;;;;;;IAQI,iBAAiB;AACrB;;AAEA,gDAAgD;AAChD;;;;;;;;;;;;;;IAcI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA,wBAAwB;AACxB;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA,iCAAiC;AACjC;;;;;;IAMI,eAAe;AACnB;;AAEA,uBAAuB;AACvB;IACI,aAAa;AACjB;;AAEA,WAAW;AACX;IACI,YAAY;IACZ,kBAAkB;AACtB;;;;AAIA,+BAA+B;AAC/B;;;;;;;;;IASI,UAAU;AACd;;AAEA,kCAAkC;AAClC;;GAEG","sourcesContent":["/* STYLING OF NUTS REGIONS AND BOUNDARIES */\r\n/* Default region fill */\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    fill: #e1e1e1;\r\n}\r\n\r\n.em-nutsrg,\r\n.em-cntrg,\r\n.em-grid-cell,\r\n#em-user-regions {\r\n    cursor: pointer;\r\n}\r\n\r\n/*  boundaries stroke-width */\r\n.em-bn-0 {\r\n    stroke: none;\r\n}\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n/* when using MIXED NUTS levels, we add stroke to the regions, then show/hide those that have/dont have data */\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-bn-co {\r\n    stroke-width: 0.2;\r\n}\r\n\r\n/* all boudnaries and regions linecap/linejoin */\r\n#em-nutsbn,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-co,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'],\r\n.em-cntrg,\r\n.em-nutsrg,\r\n.em-grid-cell {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n/* national boundaries */\r\n.em-cntbn {\r\n    stroke: #000;\r\n    stroke-width: 0.6px;\r\n}\r\n\r\n/* NUTS boundaries stroke color */\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-nutsrg [lvl='3'],\r\n.em-nutsrg [lvl='2'],\r\n.em-nutsrg [lvl='1'] {\r\n    stroke: #696969;\r\n}\r\n\r\n/* coastal boundaries */\r\n.em-bn-co {\r\n    stroke: white;\r\n}\r\n\r\n/* kosovo */\r\n.em-kosovo-bn {\r\n    stroke: #000;\r\n    stroke-width: 0.15;\r\n}\r\n\r\n\r\n\r\n/* dont fill certain elements */\r\n.em-frame,\r\n.em-graticule,\r\n.em-cntbn,\r\n.em-bn-0,\r\n.em-bn-1,\r\n.em-bn-2,\r\n.em-bn-3,\r\n.em-kosovo-bn,\r\n.em-bn-co {\r\n    fill: none;\r\n}\r\n\r\n/* target non cc/eu/efta borders */\r\n/* .em-bn-oth:not(.em-bn-co):not(.em-bn-cc):not(.em-bn-eu):not(.em-bn-efta) {\r\n    stroke-width: 0;\r\n} */\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-annotation-group {
    /* pointer-events: none; */
}
`, "",{"version":3,"sources":["webpack://./src/css/annotations.css"],"names":[],"mappings":"AAAA;IACI,0BAA0B;AAC9B","sourcesContent":[".em-annotation-group {\r\n    /* pointer-events: none; */\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/index.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./map.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./tooltip.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./legend.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./labels.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./annotations.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/annotations.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./NUTS.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/NUTS.css");
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! -!../../node_modules/css-loader/dist/cjs.js!./world.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css");
// Imports









var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_map_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_tooltip_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_legend_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_labels_css__WEBPACK_IMPORTED_MODULE_5__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_annotations_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_NUTS_css__WEBPACK_IMPORTED_MODULE_7__["default"]);
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_world_css__WEBPACK_IMPORTED_MODULE_8__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `
`, "",{"version":3,"sources":[],"names":[],"mappings":"","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/labels.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/labels.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#em-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}

.em-label {
    font-size: 12px;
}
.em-label-background {
    fill: #ffffff;
    pointer-events: none;
}
.em-label-shadow {
    font-size: 12px;
    stroke-width: 2px;
    stroke: white;
}
.em-stat-label {
    opacity: 1;
    font-size: 13px;
    stroke-width: 3px;
    fill: #313131;
    font-weight: bold;
}
.em-stat-label-shadow {
    opacity: 1;
    font-size: 13px;
    stroke-width: 4px;
    stroke: white;
}
.em-label-cc {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-cc {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-countries {
    font-size: 12px;
    stroke: #505050;
    stroke-width: 0.5px;
}
.em-label-shadow-countries {
    font-size: 12px;
    stroke: white;
    stroke-width: 3px;
}
.em-label-seas {
    font-size: 9px;
    fill: #003399;
    stroke: #003399;
    stroke-width: 0.2px;
    letter-spacing: 3px;
}
.em-label-shadow-seas {
    font-size: 9px;
    letter-spacing: 3px;
    stroke: white;
    stroke-width: 3px;
}

.em-flow-labels {
    text-anchor: middle;
    stroke-linejoin: round;
    font-family: Arial, Helvetica, sans-serif;
    dominant-baseline: central;
}
.em-flow-label {
    font-size: 13px;
    fill: black;
    font-weight: bold;
}
.em-flow-label-shadow {
    font-size: 13px;
    stroke-width: 4px;
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/labels.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;;AAEA;IACI,eAAe;AACnB;AACA;IACI,aAAa;IACb,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB;AACA;IACI,UAAU;IACV,eAAe;IACf,iBAAiB;IACjB,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,UAAU;IACV,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,eAAe;IACf,mBAAmB;AACvB;AACA;IACI,eAAe;IACf,aAAa;IACb,iBAAiB;AACrB;AACA;IACI,cAAc;IACd,aAAa;IACb,eAAe;IACf,mBAAmB;IACnB,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;IACnB,aAAa;IACb,iBAAiB;AACrB;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,yCAAyC;IACzC,0BAA0B;AAC9B;AACA;IACI,eAAe;IACf,WAAW;IACX,iBAAiB;AACrB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,aAAa;AACjB","sourcesContent":["#em-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n\r\n.em-label {\r\n    font-size: 12px;\r\n}\r\n.em-label-background {\r\n    fill: #ffffff;\r\n    pointer-events: none;\r\n}\r\n.em-label-shadow {\r\n    font-size: 12px;\r\n    stroke-width: 2px;\r\n    stroke: white;\r\n}\r\n.em-stat-label {\r\n    opacity: 1;\r\n    font-size: 13px;\r\n    stroke-width: 3px;\r\n    fill: #313131;\r\n    font-weight: bold;\r\n}\r\n.em-stat-label-shadow {\r\n    opacity: 1;\r\n    font-size: 13px;\r\n    stroke-width: 4px;\r\n    stroke: white;\r\n}\r\n.em-label-cc {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-cc {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-countries {\r\n    font-size: 12px;\r\n    stroke: #505050;\r\n    stroke-width: 0.5px;\r\n}\r\n.em-label-shadow-countries {\r\n    font-size: 12px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n.em-label-seas {\r\n    font-size: 9px;\r\n    fill: #003399;\r\n    stroke: #003399;\r\n    stroke-width: 0.2px;\r\n    letter-spacing: 3px;\r\n}\r\n.em-label-shadow-seas {\r\n    font-size: 9px;\r\n    letter-spacing: 3px;\r\n    stroke: white;\r\n    stroke-width: 3px;\r\n}\r\n\r\n.em-flow-labels {\r\n    text-anchor: middle;\r\n    stroke-linejoin: round;\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    dominant-baseline: central;\r\n}\r\n.em-flow-label {\r\n    font-size: 13px;\r\n    fill: black;\r\n    font-weight: bold;\r\n}\r\n.em-flow-label-shadow {\r\n    font-size: 13px;\r\n    stroke-width: 4px;\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/legend.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/legend.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.em-legend-background {
    fill: white;
    opacity: 0.7;
    rx: 0;
    ry: 0;
    pointer-events: none;
}
.em-legend-label {
    font-size: 15px;
    stroke: none;
    fill: black;
    dominant-baseline: unset;
}
.em-legend-title {
    font-size: 16px;
    fill: black;
}
.em-legend-separator {
    stroke: white;
    stroke-width: 1;
}
.em-legend-tick {
    stroke: #d8d8d8;
    stroke-width: 1;
}
.em-bivariate-frame {
    fill: none;
    stroke: black;
}
.em-bivariate-nodata {
    stroke: black;
    stroke-width: 0.5;
    cursor: pointer;
}
.em-bivariate-axis-title {
    font-size: 15px;
}
.em-bivariate-nodata-label {
    font-size: 14px;
    dominant-baseline: middle;
}
.em-bivariate-tick {
    stroke: black;
    stroke-width: 1;
}
.em-bivariate-tick-label {
    text-anchor: middle;
    font-size: 12px;
}
.em-bivariate-square,
.em-legend-rect {
    cursor: pointer;
    stroke: white;
}

.em-bivariate-square:hover,
.em-legend-rect:hover {
    stroke-width: 2;
    stroke: red;
}

.em-pie-size-legend-line {
    stroke-dasharray: 2;
    stroke: grey;
}

.em-legend-diverging-line {
    stroke: black;
}

.em-legend-histogram-bar {
    cursor: pointer;
}
`, "",{"version":3,"sources":["webpack://./src/css/legend.css"],"names":[],"mappings":"AAAA;IACI,WAAW;IACX,YAAY;IACZ,KAAK;IACL,KAAK;IACL,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,YAAY;IACZ,WAAW;IACX,wBAAwB;AAC5B;AACA;IACI,eAAe;IACf,WAAW;AACf;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,eAAe;IACf,eAAe;AACnB;AACA;IACI,UAAU;IACV,aAAa;AACjB;AACA;IACI,aAAa;IACb,iBAAiB;IACjB,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,yBAAyB;AAC7B;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,eAAe;AACnB;AACA;;IAEI,eAAe;IACf,aAAa;AACjB;;AAEA;;IAEI,eAAe;IACf,WAAW;AACf;;AAEA;IACI,mBAAmB;IACnB,YAAY;AAChB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,eAAe;AACnB","sourcesContent":[".em-legend-background {\r\n    fill: white;\r\n    opacity: 0.7;\r\n    rx: 0;\r\n    ry: 0;\r\n    pointer-events: none;\r\n}\r\n.em-legend-label {\r\n    font-size: 15px;\r\n    stroke: none;\r\n    fill: black;\r\n    dominant-baseline: unset;\r\n}\r\n.em-legend-title {\r\n    font-size: 16px;\r\n    fill: black;\r\n}\r\n.em-legend-separator {\r\n    stroke: white;\r\n    stroke-width: 1;\r\n}\r\n.em-legend-tick {\r\n    stroke: #d8d8d8;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-frame {\r\n    fill: none;\r\n    stroke: black;\r\n}\r\n.em-bivariate-nodata {\r\n    stroke: black;\r\n    stroke-width: 0.5;\r\n    cursor: pointer;\r\n}\r\n.em-bivariate-axis-title {\r\n    font-size: 15px;\r\n}\r\n.em-bivariate-nodata-label {\r\n    font-size: 14px;\r\n    dominant-baseline: middle;\r\n}\r\n.em-bivariate-tick {\r\n    stroke: black;\r\n    stroke-width: 1;\r\n}\r\n.em-bivariate-tick-label {\r\n    text-anchor: middle;\r\n    font-size: 12px;\r\n}\r\n.em-bivariate-square,\r\n.em-legend-rect {\r\n    cursor: pointer;\r\n    stroke: white;\r\n}\r\n\r\n.em-bivariate-square:hover,\r\n.em-legend-rect:hover {\r\n    stroke-width: 2;\r\n    stroke: red;\r\n}\r\n\r\n.em-pie-size-legend-line {\r\n    stroke-dasharray: 2;\r\n    stroke: grey;\r\n}\r\n\r\n.em-legend-diverging-line {\r\n    stroke: black;\r\n}\r\n\r\n.em-legend-histogram-bar {\r\n    cursor: pointer;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/map.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/map.css ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* General text settings */
text {
    pointer-events: none;
}

a text {
    pointer-events: all;
}

/* Main map */
.em-map,
.em-legend {
    font-family: Arial, Helvetica, sans-serif;
}

/* Coastal margin */
#em-coast-margin {
    filter: url(#em-coastal-blur);
    stroke-linejoin: round;
    stroke-linecap: round;
    fill: none;
    stroke-width: 5;
    stroke: rgb(161, 198, 237);
}

/* Title and subtitle styling */
.em-title,
.em-inset-title {
    fill: black;
    stroke: none;
}

.em-title {
    font-size: 21px;
    font-weight: bold;
}

.em-inset-title {
    font-size: 12px;
}

.em-subtitle,
.em-inset-subtitle {
    fill: #848280;
    stroke: none;
    stroke-linejoin: round;
    paint-order: stroke;
}

.em-subtitle {
    font-size: 18px;
    font-weight: 100;
}

.em-inset-subtitle {
    font-size: 12px;
}

.em-source-pretext {
    font-size: 11px;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link {
    font-size: 11px;
    fill: #0e47cb;
    cursor: pointer;
    text-decoration: underline;
    transform: translate(-5px, -5px);
}
.em-source-dataset-link:hover {
    fill: #082b7a;
    cursor: pointer;
    text-decoration: underline;
}

.em-frame {
    stroke-width: 0;
    stroke: grey;
}

.em-insets .em-frame {
    /* this will give a frame to inset maps */
    stroke: grey;
    stroke-width: 0.3px !important;
}

.em-sea {
    fill: white;
    /* pointer-events: none; */
}
.em-scalebar-line {
    stroke: black;
    stroke-width: 0.8px;
}
.em-scalebar-label {
    font-size: 9px;
    text-anchor: middle;
}

/* Bottom text and symbol styling */
.em-footnote {
    pointer-events: all;
    cursor: default;
    font-size: 11px;
    transform: translate(5px, -5px);
}
.em-footnote a {
    fill: #0e47cb;
    text-decoration: underline;
}
.em-footnote a:hover {
    fill: #0a328e;
}

.em-centroid {
    cursor: pointer;
}

/* Graticule styling */
.em-graticule {
    stroke: lightgray;
    stroke-width: 1;
}

.em-flow-link {
    cursor: pointer;
}
.em-flow-link-outline {
    cursor: pointer;
}
.em-flow-labels {
    font-size: 15px;
    stroke-width: 1px;
    fill: black;
    pointer-events: none;
}
.em-flow-labels-halo {
    font-size: 15px;
    stroke-width: 2px;
    fill: white;
    pointer-events: none;
}

.em-grid-rect,
.em-grid-hexagon {
    stroke: white;
}
`, "",{"version":3,"sources":["webpack://./src/css/map.css"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B;IACI,oBAAoB;AACxB;;AAEA;IACI,mBAAmB;AACvB;;AAEA,aAAa;AACb;;IAEI,yCAAyC;AAC7C;;AAEA,mBAAmB;AACnB;IACI,6BAA6B;IAC7B,sBAAsB;IACtB,qBAAqB;IACrB,UAAU;IACV,eAAe;IACf,0BAA0B;AAC9B;;AAEA,+BAA+B;AAC/B;;IAEI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,iBAAiB;AACrB;;AAEA;IACI,eAAe;AACnB;;AAEA;;IAEI,aAAa;IACb,YAAY;IACZ,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,eAAe;IACf,gBAAgB;AACpB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,gCAAgC;AACpC;AACA;IACI,eAAe;IACf,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,gCAAgC;AACpC;AACA;IACI,aAAa;IACb,eAAe;IACf,0BAA0B;AAC9B;;AAEA;IACI,eAAe;IACf,YAAY;AAChB;;AAEA;IACI,yCAAyC;IACzC,YAAY;IACZ,8BAA8B;AAClC;;AAEA;IACI,WAAW;IACX,0BAA0B;AAC9B;AACA;IACI,aAAa;IACb,mBAAmB;AACvB;AACA;IACI,cAAc;IACd,mBAAmB;AACvB;;AAEA,mCAAmC;AACnC;IACI,mBAAmB;IACnB,eAAe;IACf,eAAe;IACf,+BAA+B;AACnC;AACA;IACI,aAAa;IACb,0BAA0B;AAC9B;AACA;IACI,aAAa;AACjB;;AAEA;IACI,eAAe;AACnB;;AAEA,sBAAsB;AACtB;IACI,iBAAiB;IACjB,eAAe;AACnB;;AAEA;IACI,eAAe;AACnB;AACA;IACI,eAAe;AACnB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;AACA;IACI,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,oBAAoB;AACxB;;AAEA;;IAEI,aAAa;AACjB","sourcesContent":["/* General text settings */\r\ntext {\r\n    pointer-events: none;\r\n}\r\n\r\na text {\r\n    pointer-events: all;\r\n}\r\n\r\n/* Main map */\r\n.em-map,\r\n.em-legend {\r\n    font-family: Arial, Helvetica, sans-serif;\r\n}\r\n\r\n/* Coastal margin */\r\n#em-coast-margin {\r\n    filter: url(#em-coastal-blur);\r\n    stroke-linejoin: round;\r\n    stroke-linecap: round;\r\n    fill: none;\r\n    stroke-width: 5;\r\n    stroke: rgb(161, 198, 237);\r\n}\r\n\r\n/* Title and subtitle styling */\r\n.em-title,\r\n.em-inset-title {\r\n    fill: black;\r\n    stroke: none;\r\n}\r\n\r\n.em-title {\r\n    font-size: 21px;\r\n    font-weight: bold;\r\n}\r\n\r\n.em-inset-title {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-subtitle,\r\n.em-inset-subtitle {\r\n    fill: #848280;\r\n    stroke: none;\r\n    stroke-linejoin: round;\r\n    paint-order: stroke;\r\n}\r\n\r\n.em-subtitle {\r\n    font-size: 18px;\r\n    font-weight: 100;\r\n}\r\n\r\n.em-inset-subtitle {\r\n    font-size: 12px;\r\n}\r\n\r\n.em-source-pretext {\r\n    font-size: 11px;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link {\r\n    font-size: 11px;\r\n    fill: #0e47cb;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n    transform: translate(-5px, -5px);\r\n}\r\n.em-source-dataset-link:hover {\r\n    fill: #082b7a;\r\n    cursor: pointer;\r\n    text-decoration: underline;\r\n}\r\n\r\n.em-frame {\r\n    stroke-width: 0;\r\n    stroke: grey;\r\n}\r\n\r\n.em-insets .em-frame {\r\n    /* this will give a frame to inset maps */\r\n    stroke: grey;\r\n    stroke-width: 0.3px !important;\r\n}\r\n\r\n.em-sea {\r\n    fill: white;\r\n    /* pointer-events: none; */\r\n}\r\n.em-scalebar-line {\r\n    stroke: black;\r\n    stroke-width: 0.8px;\r\n}\r\n.em-scalebar-label {\r\n    font-size: 9px;\r\n    text-anchor: middle;\r\n}\r\n\r\n/* Bottom text and symbol styling */\r\n.em-footnote {\r\n    pointer-events: all;\r\n    cursor: default;\r\n    font-size: 11px;\r\n    transform: translate(5px, -5px);\r\n}\r\n.em-footnote a {\r\n    fill: #0e47cb;\r\n    text-decoration: underline;\r\n}\r\n.em-footnote a:hover {\r\n    fill: #0a328e;\r\n}\r\n\r\n.em-centroid {\r\n    cursor: pointer;\r\n}\r\n\r\n/* Graticule styling */\r\n.em-graticule {\r\n    stroke: lightgray;\r\n    stroke-width: 1;\r\n}\r\n\r\n.em-flow-link {\r\n    cursor: pointer;\r\n}\r\n.em-flow-link-outline {\r\n    cursor: pointer;\r\n}\r\n.em-flow-labels {\r\n    font-size: 15px;\r\n    stroke-width: 1px;\r\n    fill: black;\r\n    pointer-events: none;\r\n}\r\n.em-flow-labels-halo {\r\n    font-size: 15px;\r\n    stroke-width: 2px;\r\n    fill: white;\r\n    pointer-events: none;\r\n}\r\n\r\n.em-grid-rect,\r\n.em-grid-hexagon {\r\n    stroke: white;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/tooltip.css ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.estat-vis-tooltip-text {
    background: #ffffff;
    color: #171a22;
    padding: 4px;
    font-size: 16px;
}
.estat-vis-tooltip-bar {
    background: #515560;
    color: #ffffff;
    padding: 6px;
    font-size: 16px;
}
.tooltip-eurostat {
    font-family: Arial;
    max-width: 250px;
    overflow: hidden;
    background: white;
    padding: 0px;
    border: 0px;
    border-radius: 0px;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);
    position: absolute;
    font-family: Helvetica, Arial, sans-serif;
    pointer-events: none;
    opacity: 0;
    z-index: 99999999;
}
.em-tooltip-piechart-breakdown {
    padding: 10px;
    font-size: 14px;
}
.em-tooltip-piechart-container {
    text-align: center;
}
`, "",{"version":3,"sources":["webpack://./src/css/tooltip.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,mBAAmB;IACnB,cAAc;IACd,YAAY;IACZ,eAAe;AACnB;AACA;IACI,kBAAkB;IAClB,gBAAgB;IAChB,gBAAgB;IAChB,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,kBAAkB;IAClB,2EAA2E;IAC3E,kBAAkB;IAClB,yCAAyC;IACzC,oBAAoB;IACpB,UAAU;IACV,iBAAiB;AACrB;AACA;IACI,aAAa;IACb,eAAe;AACnB;AACA;IACI,kBAAkB;AACtB","sourcesContent":[".estat-vis-tooltip-text {\r\n    background: #ffffff;\r\n    color: #171a22;\r\n    padding: 4px;\r\n    font-size: 16px;\r\n}\r\n.estat-vis-tooltip-bar {\r\n    background: #515560;\r\n    color: #ffffff;\r\n    padding: 6px;\r\n    font-size: 16px;\r\n}\r\n.tooltip-eurostat {\r\n    font-family: Arial;\r\n    max-width: 250px;\r\n    overflow: hidden;\r\n    background: white;\r\n    padding: 0px;\r\n    border: 0px;\r\n    border-radius: 0px;\r\n    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1), 0px 1px 3px rgba(0, 0, 0, 0.08);\r\n    position: absolute;\r\n    font-family: Helvetica, Arial, sans-serif;\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    z-index: 99999999;\r\n}\r\n.em-tooltip-piechart-breakdown {\r\n    padding: 10px;\r\n    font-size: 14px;\r\n}\r\n.em-tooltip-piechart-container {\r\n    text-align: center;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/world.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/world.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#g_worldbn,
.em-worldrg,
.em-worldbn {
    stroke-linecap: round;
    stroke-linejoin: round;
}

.em-worldbn {
    stroke: #000;
    stroke-width: 0.3px;
}

.em-worldbn {
    fill: none;
}

.em-worldrg {
    fill: #efefef;
    cursor: pointer;
}

.em-bn-d {
    /* disputed */
    stroke: #000;
    stroke-width: 0.1;
    fill: none;
}
`, "",{"version":3,"sources":["webpack://./src/css/world.css"],"names":[],"mappings":"AAAA;;;IAGI,qBAAqB;IACrB,sBAAsB;AAC1B;;AAEA;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA;IACI,UAAU;AACd;;AAEA;IACI,aAAa;IACb,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,YAAY;IACZ,iBAAiB;IACjB,UAAU;AACd","sourcesContent":["#g_worldbn,\r\n.em-worldrg,\r\n.em-worldbn {\r\n    stroke-linecap: round;\r\n    stroke-linejoin: round;\r\n}\r\n\r\n.em-worldbn {\r\n    stroke: #000;\r\n    stroke-width: 0.3px;\r\n}\r\n\r\n.em-worldbn {\r\n    fill: none;\r\n}\r\n\r\n.em-worldrg {\r\n    fill: #efefef;\r\n    cursor: pointer;\r\n}\r\n\r\n.em-bn-d {\r\n    /* disputed */\r\n    stroke: #000;\r\n    stroke-width: 0.1;\r\n    fill: none;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/d3-array/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/array.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var array = Array.prototype;

var slice = array.slice;
var map = array.map;


/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bisectLeft: () => (/* binding */ bisectLeft),
/* harmony export */   bisectRight: () => (/* binding */ bisectRight),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");



var ascendingBisect = (0,_bisector__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return (0,_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
  };
}


/***/ }),

/***/ "./node_modules/d3-array/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-array/src/cross.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/cross.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__.pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/deviation.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/deviation.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, f) {
  var v = (0,_variance__WEBPACK_IMPORTED_MODULE_0__["default"])(array, f);
  return v ? Math.sqrt(v) : v;
}


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}


/***/ }),

/***/ "./node_modules/d3-array/src/histogram.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/histogram.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-array/src/constant.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-array/src/identity.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__["default"],
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__["default"];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = (0,_ticks__WEBPACK_IMPORTED_MODULE_6__.tickStep)(x0, x1, tz);
      tz = (0,_range__WEBPACK_IMPORTED_MODULE_5__["default"])(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[(0,_bisect__WEBPACK_IMPORTED_MODULE_1__["default"])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)) : (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : threshold;
  };

  return histogram;
}


/***/ }),

/***/ "./node_modules/d3-array/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/identity.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-array/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascending: () => (/* reexport safe */ _ascending__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   bisect: () => (/* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   bisectLeft: () => (/* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__.bisectLeft),
/* harmony export */   bisectRight: () => (/* reexport safe */ _bisect__WEBPACK_IMPORTED_MODULE_0__.bisectRight),
/* harmony export */   bisector: () => (/* reexport safe */ _bisector__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   cross: () => (/* reexport safe */ _cross__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   descending: () => (/* reexport safe */ _descending__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   deviation: () => (/* reexport safe */ _deviation__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   extent: () => (/* reexport safe */ _extent__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   histogram: () => (/* reexport safe */ _histogram__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   max: () => (/* reexport safe */ _max__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   mean: () => (/* reexport safe */ _mean__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   median: () => (/* reexport safe */ _median__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   merge: () => (/* reexport safe */ _merge__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   min: () => (/* reexport safe */ _min__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   pairs: () => (/* reexport safe */ _pairs__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   permute: () => (/* reexport safe */ _permute__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   quantile: () => (/* reexport safe */ _quantile__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   range: () => (/* reexport safe */ _range__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   scan: () => (/* reexport safe */ _scan__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   shuffle: () => (/* reexport safe */ _shuffle__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   sum: () => (/* reexport safe */ _sum__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   thresholdFreedmanDiaconis: () => (/* reexport safe */ _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   thresholdScott: () => (/* reexport safe */ _threshold_scott__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   thresholdSturges: () => (/* reexport safe */ _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   tickIncrement: () => (/* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__.tickIncrement),
/* harmony export */   tickStep: () => (/* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__.tickStep),
/* harmony export */   ticks: () => (/* reexport safe */ _ticks__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   transpose: () => (/* reexport safe */ _transpose__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   variance: () => (/* reexport safe */ _variance__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   zip: () => (/* reexport safe */ _zip__WEBPACK_IMPORTED_MODULE_26__["default"])
/* harmony export */ });
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ "./node_modules/d3-array/src/cross.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-array/src/descending.js");
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./deviation */ "./node_modules/d3-array/src/deviation.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./histogram */ "./node_modules/d3-array/src/histogram.js");
/* harmony import */ var _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./threshold/freedmanDiaconis */ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js");
/* harmony import */ var _threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold/scott */ "./node_modules/d3-array/src/threshold/scott.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./max */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mean */ "./node_modules/d3-array/src/mean.js");
/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./median */ "./node_modules/d3-array/src/median.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-array/src/merge.js");
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");
/* harmony import */ var _permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./permute */ "./node_modules/d3-array/src/permute.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./scan */ "./node_modules/d3-array/src/scan.js");
/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./shuffle */ "./node_modules/d3-array/src/shuffle.js");
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sum */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");
/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./zip */ "./node_modules/d3-array/src/zip.js");





























/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/mean.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/mean.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}


/***/ }),

/***/ "./node_modules/d3-array/src/median.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/median.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_1__["default"])(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_1__["default"])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return (0,_quantile__WEBPACK_IMPORTED_MODULE_2__["default"])(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]), 0.5);
}


/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x === null ? NaN : +x;
}


/***/ }),

/***/ "./node_modules/d3-array/src/pairs.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/pairs.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   pair: () => (/* binding */ pair)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}


/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/d3-array/src/scan.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/scan.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__["default"];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}


/***/ }),

/***/ "./node_modules/d3-array/src/shuffle.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/shuffle.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "./node_modules/d3-array/src/quantile.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__.map.call(values, _number__WEBPACK_IMPORTED_MODULE_2__["default"]).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return Math.ceil((max - min) / (2 * ((0,_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.75) - (0,_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/scott.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/scott.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "./node_modules/d3-array/src/deviation.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, min, max) {
  return Math.ceil((max - min) / (3.5 * (0,_deviation__WEBPACK_IMPORTED_MODULE_0__["default"])(values) * Math.pow(values.length, -1 / 3)));
}


/***/ }),

/***/ "./node_modules/d3-array/src/threshold/sturges.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/sturges.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tickIncrement: () => (/* binding */ tickIncrement),
/* harmony export */   tickStep: () => (/* binding */ tickStep)
/* harmony export */ });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/transpose.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/transpose.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = (0,_min__WEBPACK_IMPORTED_MODULE_0__["default"])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}


/***/ }),

/***/ "./node_modules/d3-array/src/variance.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/variance.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = (0,_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}


/***/ }),

/***/ "./node_modules/d3-array/src/zip.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/zip.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_transpose__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments);
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   arcosh: () => (/* binding */ arcosh),
/* harmony export */   arsinh: () => (/* binding */ arsinh),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   cosh: () => (/* binding */ cosh),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sinci: () => (/* binding */ sinci),
/* harmony export */   sinh: () => (/* binding */ sinh),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   sqrt1_2: () => (/* binding */ sqrt1_2),
/* harmony export */   sqrt2: () => (/* binding */ sqrt2),
/* harmony export */   sqrtPi: () => (/* binding */ sqrtPi),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tanh: () => (/* binding */ tanh),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/robinson.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/robinson.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   robinsonRaw: () => (/* binding */ robinsonRaw)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/src/math.js");



var K = [
  [0.9986, -0.062],
  [1.0000, 0.0000],
  [0.9986, 0.0620],
  [0.9954, 0.1240],
  [0.9900, 0.1860],
  [0.9822, 0.2480],
  [0.9730, 0.3100],
  [0.9600, 0.3720],
  [0.9427, 0.4340],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.8350, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1.0000]
];

K.forEach(function(d) {
  d[1] *= 1.0144;
});

function robinsonRaw(lambda, phi) {
  var i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) * 36 / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i),
      di = i - i0,
      ax = (k = K[i0])[0],
      ay = k[1],
      bx = (k = K[++i0])[0],
      by = k[1],
      cx = (k = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, ++i0)])[0],
      cy = k[1],
      k;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    (phi > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}

robinsonRaw.invert = function(x, y) {
  var yy = y / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
      phi = yy * 90,
      i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi / 5)),
      i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i));
  do {
    var ay = K[i0][1],
        by = K[i0 + 1][1],
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1],
        u = cy - ay,
        v = cy - 2 * by + ay,
        t = 2 * ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(yy) - by) / u,
        c = v / u,
        di = t * (1 - c * t * (1 - 2 * c * t));
    if (di >= 0 || i0 === 1) {
      phi = (y >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(18, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(phi) / 5);
        i0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.floor)(i);
        di = i - i0;
        ay = K[i0][1];
        by = K[i0 + 1][1];
        cy = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][1];
        phi -= (delta = (y >= 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
      } while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K[i0][0],
      bx = K[i0 + 1][0],
      cx = K[(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(19, i0 + 2)][0];
  return [
    x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])(robinsonRaw)
      .scale(152.63);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/adder.js":
/*!******************************************!*\
  !*** ./node_modules/d3-geo/src/adder.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Adder;
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/cartesian.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/cartesian.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cartesian: () => (/* binding */ cartesian),
/* harmony export */   cartesianAddInPlace: () => (/* binding */ cartesianAddInPlace),
/* harmony export */   cartesianCross: () => (/* binding */ cartesianCross),
/* harmony export */   cartesianDot: () => (/* binding */ cartesianDot),
/* harmony export */   cartesianNormalizeInPlace: () => (/* binding */ cartesianNormalizeInPlace),
/* harmony export */   cartesianScale: () => (/* binding */ cartesianScale),
/* harmony export */   spherical: () => (/* binding */ spherical)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stream.js */ "./node_modules/d3-geo/src/stream.js");




var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(cx * cx + cy * cy + cz * cz),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(m)) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
}


/***/ }),

/***/ "./node_modules/d3-geo/src/circle.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/circle.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circleStream: () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "./node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0, 0], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/antimeridian.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/antimeridian.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/circle.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/circle.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "./node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.merge)(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rectangle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rectangle.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.merge)(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rejoin.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rejoin.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/compose.js":
/*!********************************************!*\
  !*** ./node_modules/d3-geo/src/compose.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/constant.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/constant.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graticule),
/* harmony export */   graticule10: () => (/* binding */ graticule10)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X)
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function(x) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(x))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.range)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function(y) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   haversin: () => (/* binding */ haversin),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder.js */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var areaSum = (0,_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    areaRingSum = (0,_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
    areaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(areaRingSum));
    areaRingSum.reset();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (areaStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (centroidStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathContext)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};


/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure.js */ "./node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-geo/src/path/string.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
    return _area_js__WEBPACK_IMPORTED_MODULE_1__["default"].result();
  };

  path.measure = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _measure_js__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.bounds = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_5__["default"]) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_6__["default"]) : new _context_js__WEBPACK_IMPORTED_MODULE_7__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/measure.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder.js */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var lengthSum = (0,_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lengthStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathString)
/* harmony export */ });
function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}


/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/polygonContains.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo/src/polygonContains.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder.js */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");




var sum = (0,_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

function longitude(point) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi)
    return point[0];
  else
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_1__.tau - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_1__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_1__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_1__.tau : delta;

      // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) ^ (winding & 1);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fitExtent: () => (/* binding */ fitExtent),
/* harmony export */   fitHeight: () => (/* binding */ fitHeight),
/* harmony export */   fitSize: () => (/* binding */ fitSize),
/* harmony export */   fitWidth: () => (/* binding */ fitWidth)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians, sa = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.sin)(alpha), ca = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.cos)(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_3__.degrees;
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitExtent)(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitSize)(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitWidth)(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitHeight)(projection, height, object);
  };

  return projection;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   projectionMutator: () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "./node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "./node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "./node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"], // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"], // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__["default"]), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__["default"])(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/resample.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/resample.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/rotation.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/rotation.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rotateRadians: () => (/* binding */ rotateRadians)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/indexRollupNext.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-svg-annotation/indexRollupNext.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotation: () => (/* binding */ annotation),
/* harmony export */   annotationBadge: () => (/* binding */ d3Badge),
/* harmony export */   annotationCallout: () => (/* binding */ d3Callout),
/* harmony export */   annotationCalloutCircle: () => (/* binding */ d3CalloutCircle),
/* harmony export */   annotationCalloutCurve: () => (/* binding */ d3CalloutCurve),
/* harmony export */   annotationCalloutElbow: () => (/* binding */ d3CalloutElbow),
/* harmony export */   annotationCalloutRect: () => (/* binding */ d3CalloutRect),
/* harmony export */   annotationCustomType: () => (/* binding */ customType),
/* harmony export */   annotationLabel: () => (/* binding */ d3Label),
/* harmony export */   annotationTypeBase: () => (/* binding */ Type),
/* harmony export */   annotationXYThreshold: () => (/* binding */ d3XYThreshold),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js");
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");





var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Annotation = function () {
  function Annotation(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === undefined ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === undefined ? 0 : _ref$y,
        nx = _ref.nx,
        ny = _ref.ny,
        _ref$dy = _ref.dy,
        dy = _ref$dy === undefined ? 0 : _ref$dy,
        _ref$dx = _ref.dx,
        dx = _ref$dx === undefined ? 0 : _ref$dx,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? "grey" : _ref$color,
        data = _ref.data,
        type = _ref.type,
        subject = _ref.subject,
        connector = _ref.connector,
        note = _ref.note,
        disable = _ref.disable,
        id = _ref.id,
        className = _ref.className;
    classCallCheck(this, Annotation);

    this._dx = nx !== undefined ? nx - x : dx;
    this._dy = ny !== undefined ? ny - y : dy;
    this._x = x;
    this._y = y;
    this._color = color;
    this.id = id;
    this._className = className || "";

    this._type = type || "";
    this.data = data;

    this.note = note || {};
    this.connector = connector || {};
    this.subject = subject || {};

    this.disable = disable || [];
  }

  createClass(Annotation, [{
    key: "updatePosition",
    value: function updatePosition() {
      if (this.type.setPosition) {
        this.type.setPosition();
        if (this.type.subject && this.type.subject.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawSubject();
        }
      }
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.type.clearComponents && this.type.clearComponents();
    }
  }, {
    key: "updateOffset",
    value: function updateOffset() {
      if (this.type.setOffset) {
        this.type.setOffset();

        if (this.type.connector.selectAll(":not(.handle)").nodes().length !== 0) {
          this.type.redrawConnector();
        }

        this.type.redrawNote();
      }
    }
  }, {
    key: "className",
    get: function get$$1() {
      return this._className;
    },
    set: function set$$1(className) {
      this._className = className;
      if (this.type.setClassName) this.type.setClassName();
    }
  }, {
    key: "type",
    get: function get$$1() {
      return this._type;
    },
    set: function set$$1(type) {
      this._type = type;
      this.clearComponents();
    }
  }, {
    key: "x",
    get: function get$$1() {
      return this._x;
    },
    set: function set$$1(x) {
      this._x = x;
      this.updatePosition();
    }
  }, {
    key: "y",
    get: function get$$1() {
      return this._y;
    },
    set: function set$$1(y) {
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "color",
    get: function get$$1() {
      return this._color;
    },
    set: function set$$1(color) {
      this._color = color;
      this.updatePosition();
    }
  }, {
    key: "dx",
    get: function get$$1() {
      return this._dx;
    },
    set: function set$$1(dx) {
      this._dx = dx;
      this.updateOffset();
    }
  }, {
    key: "dy",
    get: function get$$1() {
      return this._dy;
    },
    set: function set$$1(dy) {
      this._dy = dy;
      this.updateOffset();
    }
  }, {
    key: "nx",
    set: function set$$1(nx) {
      this._dx = nx - this._x;
      this.updateOffset();
    }
  }, {
    key: "ny",
    set: function set$$1(ny) {
      this._dy = ny - this._y;
      this.updateOffset();
    }
  }, {
    key: "offset",
    get: function get$$1() {
      return { x: this._dx, y: this._dy };
    },
    set: function set$$1(_ref2) {
      var x = _ref2.x,
          y = _ref2.y;

      this._dx = x;
      this._dy = y;
      this.updateOffset();
    }
  }, {
    key: "position",
    get: function get$$1() {
      return { x: this._x, y: this._y };
    },
    set: function set$$1(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      this._x = x;
      this._y = y;
      this.updatePosition();
    }
  }, {
    key: "translation",
    get: function get$$1() {
      return {
        x: this._x + this._dx,
        y: this._y + this._dy
      };
    }
  }, {
    key: "json",
    get: function get$$1() {
      var json = {
        x: this._x,
        y: this._y,
        dx: this._dx,
        dy: this._dy
      };

      if (this.data && Object.keys(this.data).length > 0) json.data = this.data;
      if (this.type) json.type = this.type;
      if (this._className) json.className = this._className;

      if (Object.keys(this.connector).length > 0) json.connector = this.connector;
      if (Object.keys(this.subject).length > 0) json.subject = this.subject;
      if (Object.keys(this.note).length > 0) json.note = this.note;

      return json;
    }
  }]);
  return Annotation;
}();

var AnnotationCollection = function () {
  function AnnotationCollection(_ref) {
    var annotations = _ref.annotations,
        accessors = _ref.accessors,
        accessorsInverse = _ref.accessorsInverse;
    classCallCheck(this, AnnotationCollection);

    this.accessors = accessors;
    this.accessorsInverse = accessorsInverse;
    this.annotations = annotations;
  }

  createClass(AnnotationCollection, [{
    key: "clearTypes",
    value: function clearTypes(newSettings) {
      this.annotations.forEach(function (d) {
        d.type = undefined;
        d.subject = newSettings && newSettings.subject || d.subject;
        d.connector = newSettings && newSettings.connector || d.connector;
        d.note = newSettings && newSettings.note || d.note;
      });
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors() {
      var _this = this;

      this.annotations.forEach(function (d) {
        d.type.setPositionWithAccessors(_this.accessors);
      });
    }
  }, {
    key: "editMode",
    value: function editMode(_editMode) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.editMode = _editMode;
          a.type.updateEditMode();
        }
      });
    }
  }, {
    key: "updateDisable",
    value: function updateDisable(disable) {
      this.annotations.forEach(function (a) {
        a.disable = disable;
        if (a.type) {
          disable.forEach(function (d) {
            if (a.type[d]) {
              a.type[d].remove && a.type[d].remove();
              a.type[d] = undefined;
            }
          });
        }
      });
    }
  }, {
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.updateTextWrap) {
          a.type.updateTextWrap(textWrap);
        }
      });
    }
  }, {
    key: "updateText",
    value: function updateText() {
      this.annotations.forEach(function (a) {
        if (a.type && a.type.drawText) {
          a.type.drawText();
        }
      });
    }
  }, {
    key: "updateNotePadding",
    value: function updateNotePadding(notePadding) {
      this.annotations.forEach(function (a) {
        if (a.type) {
          a.type.notePadding = notePadding;
        }
      });
    }
  }, {
    key: "json",
    get: function get$$1() {
      var _this2 = this;

      return this.annotations.map(function (a) {
        var json = a.json;
        if (_this2.accessorsInverse && a.data) {
          json.data = {};
          Object.keys(_this2.accessorsInverse).forEach(function (k) {
            json.data[k] = _this2.accessorsInverse[k]({ x: a.x, y: a.y });

            //TODO make this feasible to map back to data for other types of subjects
          });
        }
        return json;
      });
    }
  }, {
    key: "noteNodes",
    get: function get$$1() {
      return this.annotations.map(function (a) {
        return _extends({}, a.type.getNoteBBoxOffset(), { positionX: a.x, positionY: a.y });
      });
    }

    //TODO: come back and rethink if a.x and a.y are applicable in all situations
    // get connectorNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))
    // }

    // get subjectNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))
    // }

    // get annotationNodes() {
    //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))
    // }

  }]);
  return AnnotationCollection;
}();

var pointHandle = function pointHandle(_ref) {
  var _ref$cx = _ref.cx,
      cx = _ref$cx === undefined ? 0 : _ref$cx,
      _ref$cy = _ref.cy,
      cy = _ref$cy === undefined ? 0 : _ref$cy;

  return { move: { x: cx, y: cy } };
};

var circleHandles = function circleHandles(_ref2) {
  var _ref2$cx = _ref2.cx,
      cx = _ref2$cx === undefined ? 0 : _ref2$cx,
      _ref2$cy = _ref2.cy,
      cy = _ref2$cy === undefined ? 0 : _ref2$cy,
      r1 = _ref2.r1,
      r2 = _ref2.r2,
      padding = _ref2.padding;

  var h = { move: { x: cx, y: cy } };

  if (r1 !== undefined) {
    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
  }

  if (r2 !== undefined) {
    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
  }

  if (padding !== undefined) {
    h.padding = { x: cx + r1 + padding, y: cy };
  }

  return h;
};





//arc handles
var addHandles = function addHandles(_ref5) {
  var group = _ref5.group,
      handles = _ref5.handles,
      _ref5$r = _ref5.r,
      r = _ref5$r === undefined ? 10 : _ref5$r;

  //give it a group and x,y to draw handles
  //then give it instructions on what the handles change
  var h = group.selectAll("circle.handle").data(handles);

  h.enter().append("circle").attr("class", "handle").attr("fill", "grey").attr("fill-opacity", 0.1).attr("cursor", "move").attr("stroke-dasharray", 5).attr("stroke", "grey").call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
    return d.start && d.start(d);
  }).on("drag", function (d) {
    return d.drag && d.drag(d);
  }).on("end", function (d) {
    return d.end && d.end(d);
  }));

  group.selectAll("circle.handle").attr("cx", function (d) {
    return d.x;
  }).attr("cy", function (d) {
    return d.y;
  }).attr("r", function (d) {
    return d.r || r;
  }).attr("class", function (d) {
    return "handle " + (d.className || "");
  });

  h.exit().remove();
};

var leftRightDynamic = function leftRightDynamic(align, y) {
  if (align === "dynamic" || align === "left" || align === "right") {
    if (y < 0) {
      align = "top";
    } else {
      align = "bottom";
    }
  }
  return align;
};

var topBottomDynamic = function topBottomDynamic(align, x) {
  if (align === "dynamic" || align === "top" || align === "bottom") {
    if (x < 0) {
      align = "right";
    } else {
      align = "left";
    }
  }
  return align;
};

var orientationTopBottom = ["topBottom", "top", "bottom"];
var orientationLeftRight = ["leftRight", "left", "right"];

var noteAlignment = (function (_ref) {
  var _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$bbox = _ref.bbox,
      bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
      align = _ref.align,
      orientation = _ref.orientation,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

  var x = -bbox.x;
  var y = 0; //-bbox.y
  if (orientationTopBottom.indexOf(orientation) !== -1) {
    align = topBottomDynamic(align, offset.x);
    if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
      y -= bbox.height + padding;
    } else {
      y += padding;
    }

    if (align === "middle") {
      x -= bbox.width / 2;
    } else if (align === "right") {
      x -= bbox.width;
    }
  } else if (orientationLeftRight.indexOf(orientation) !== -1) {
    align = leftRightDynamic(align, offset.y);
    if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
      x -= bbox.width + padding;
    } else {
      x += padding;
    }

    if (align === "middle") {
      y -= bbox.height / 2;
    } else if (align === "top") {
      y -= bbox.height;
    }
  }

  return { x: x, y: y };
});

var lineBuilder = function lineBuilder(_ref) {
  var data = _ref.data,
      _ref$curve = _ref.curve,
      curve = _ref$curve === undefined ? d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveLinear : _ref$curve,
      canvasContext = _ref.canvasContext,
      className = _ref.className,
      classID = _ref.classID;

  var lineGen = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.line)().curve(curve);

  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {
    builder.attrs = {
      d: lineGen(data)
    };
  }

  return builder;
};

var arcBuilder = function arcBuilder(_ref2) {
  var data = _ref2.data,
      canvasContext = _ref2.canvasContext,
      className = _ref2.className,
      classID = _ref2.classID;


  var builder = {
    type: 'path',
    className: className,
    classID: classID,
    data: data
  };

  var arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__.arc)().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

  if (canvasContext) {
    arcShape.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {

    builder.attrs = {
      d: arcShape()
    };
  }

  return builder;
};

var noteVertical = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      bbox = _ref.bbox,
      offset = _ref.offset;

  align = leftRightDynamic(align, offset.y);

  if (align === "top") {
    y -= bbox.height;
  } else if (align === "middle") {
    y -= bbox.height / 2;
  }

  var data = [[x, y], [x, y + bbox.height]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var noteHorizontal = (function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      offset = _ref.offset,
      bbox = _ref.bbox;

  align = topBottomDynamic(align, offset.x);

  if (align === "right") {
    x -= bbox.width;
  } else if (align === "middle") {
    x -= bbox.width / 2;
  }

  var data = [[x, y], [x + bbox.width, y]];
  return { components: [lineBuilder({ data: data, className: "note-line" })] };
});

var lineSetup = function lineSetup(_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;

  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    var angle = Math.asin(-y2 / h);
    var r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0);

    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
  }

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  return [[x1, y1], [x2, y2]];
};

var connectorLine = (function (connectorData) {
  var data = lineSetup(connectorData);
  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorElbow = (function (_ref) {
  var type = _ref.type,
      subjectType = _ref.subjectType;


  var annotation = type.annotation;
  var offset = annotation.position;

  var x1 = annotation.x - offset.x,
      x2 = x1 + annotation.dx,
      y1 = annotation.y - offset.y,
      y2 = y1 + annotation.dy;

  var subjectData = annotation.subject;

  if (subjectType === "rect") {
    var width = subjectData.width,
        height = subjectData.height;


    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;y1 = y2;
    }
  }

  var data = [[x1, y1], [x2, y2]];

  var diffY = y2 - y1;
  var diffX = x2 - x1;
  var xe = x2;
  var ye = y2;
  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

  if (Math.abs(diffX) < Math.abs(diffY)) {
    xe = x2;
    ye = y1 + diffX * opposite;
  } else {
    ye = y2;
    xe = x1 + diffY * opposite;
  }

  if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
    var r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0);
    var length = r / Math.sqrt(2);

    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
      x1 = length * (x2 < 0 ? -1 : 1);
      y1 = length * (y2 < 0 ? -1 : 1);
      data = [[x1, y1], [xe, ye], [x2, y2]];
    } else if (Math.abs(diffX) > Math.abs(diffY)) {
      var angle = Math.asin(-y2 / r);
      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      data = [[x1, y2], [x2, y2]];
    } else {
      var _angle = Math.acos(x2 / r);
      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
      data = [[x2, y1], [x2, y2]];
    }
  } else {
    data = [[x1, y1], [xe, ye], [x2, y2]];
  }

  return { components: [lineBuilder({ data: data, className: "connector" })] };
});

var connectorCurve = (function (_ref) {
  var type = _ref.type,
      connectorData = _ref.connectorData,
      subjectType = _ref.subjectType;


  if (!connectorData) {
    connectorData = {};
  }
  if (!connectorData.points || typeof connectorData.points === "number") {
    connectorData.points = createPoints(type.annotation.offset, connectorData.points);
  }
  if (!connectorData.curve) {
    connectorData.curve = d3_shape__WEBPACK_IMPORTED_MODULE_2__.curveCatmullRom;
  }

  var handles = [];

  if (type.editMode) {
    var cHandles = connectorData.points.map(function (c, i) {
      return _extends({}, pointHandle({ cx: c[0], cy: c[1] }), { index: i });
    });

    var updatePoint = function updatePoint(index) {
      connectorData.points[index][0] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      connectorData.points[index][1] += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      type.redrawConnector();
    };

    handles = type.mapHandles(cHandles.map(function (h) {
      return _extends({}, h.move, { drag: updatePoint.bind(type, h.index) });
    }));
  }

  var data = lineSetup({ type: type, subjectType: subjectType });
  data = [data[0]].concat(toConsumableArray(connectorData.points), [data[1]]);
  var components = [lineBuilder({ data: data, curve: connectorData.curve, className: "connector" })];

  return { components: components, handles: handles };
});

var createPoints = function createPoints(offset) {
  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
  var p = [];

  var i = 1;
  for (; i <= anchors; i++) {
    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
  }
  return p;
};

var connectorArrow = (function (_ref) {
  var annotation = _ref.annotation,
      start = _ref.start,
      end = _ref.end,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var offset = annotation.position;
  if (!start) {
    start = [annotation.dx, annotation.dy];
  } else {
    start = [-end[0] + start[0], -end[1] + start[1]];
  }
  if (!end) {
    end = [annotation.x - offset.x, annotation.y - offset.y];
  }

  var x1 = end[0],
      y1 = end[1];

  var dx = start[0];
  var dy = start[1];

  var size = 10 * scale;
  var angleOffset = 16 / 180 * Math.PI;
  var angle = Math.atan(dy / dx);

  if (dx < 0) {
    angle += Math.PI;
  }

  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

  //TODO add in reverse
  // if (canvasContext.arrowReverse){
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // } else {
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // }

  return {
    components: [lineBuilder({
      data: data,
      className: "connector-end connector-arrow",
      classID: "connector-end"
    })]
  };
});

var connectorDot = (function (_ref) {
  var line$$1 = _ref.line,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var dot = arcBuilder({
    className: "connector-end connector-dot",
    classID: "connector-end",
    data: { radius: 3 * Math.sqrt(scale) }
  });
  dot.attrs.transform = "translate(" + line$$1.data[0][0] + ", " + line$$1.data[0][1] + ")";

  return { components: [dot] };
});

var subjectCircle = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.radius && !subjectData.outerRadius) {
    subjectData.radius = 20;
  }

  var handles = [];
  var c = arcBuilder({ data: subjectData, className: "subject" });
  if (type.editMode) {
    var h = circleHandles({
      r1: c.data.outerRadius || c.data.radius,
      r2: c.data.innerRadius,
      padding: subjectData.radiusPadding
    });

    var updateRadius = function updateRadius(attr) {
      var r = subjectData[attr] + d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx * Math.sqrt(2);
      subjectData[attr] = r;
      type.redrawSubject();
      type.redrawConnector();
    };

    var cHandles = [_extends({}, h.r1, {
      drag: updateRadius.bind(type, subjectData.outerRadius !== undefined ? "outerRadius" : "radius")
    })];

    if (subjectData.innerRadius) {
      cHandles.push(_extends({}, h.r2, { drag: updateRadius.bind(type, "innerRadius") }));
    }
    handles = type.mapHandles(cHandles);
  }

  c.attrs["fill-opacity"] = 0;

  return { components: [c], handles: handles };
});

var subjectRect = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  if (!subjectData.width) {
    subjectData.width = 100;
  }
  if (!subjectData.height) {
    subjectData.height = 100;
  }

  var handles = [];
  var width = subjectData.width,
      height = subjectData.height;


  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
  var rect = lineBuilder({ data: data, className: "subject" });

  if (type.editMode) {
    var updateWidth = function updateWidth() {
      subjectData.width = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x;
      type.redrawSubject();
      type.redrawConnector();
    };

    var updateHeight = function updateHeight() {
      subjectData.height = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y;
      type.redrawSubject();
      type.redrawConnector();
    };

    var rHandles = [{ x: width, y: height / 2, drag: updateWidth.bind(type) }, { x: width / 2, y: height, drag: updateHeight.bind(type) }];

    handles = type.mapHandles(rHandles);
  }
  rect.attrs["fill-opacity"] = 0.1;
  return { components: [rect], handles: handles };
});

var subjectThreshold = (function (_ref) {
  var subjectData = _ref.subjectData,
      type = _ref.type;

  var offset = type.annotation.position;

  var x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x,
      x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x,
      y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y,
      y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y;

  var data = [[x1, y1], [x2, y2]];
  return { components: [lineBuilder({ data: data, className: 'subject' })] };
});

var subjectBadge = (function (_ref) {
  var _ref$subjectData = _ref.subjectData,
      subjectData = _ref$subjectData === undefined ? {} : _ref$subjectData,
      _ref$type = _ref.type,
      type = _ref$type === undefined ? {} : _ref$type;
  var annotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var typeSettings = type.typeSettings && type.typeSettings.subject;

  if (!subjectData.radius) {
    if (typeSettings && typeSettings.radius) {
      subjectData.radius = typeSettings.radius;
    } else {
      subjectData.radius = 14;
    }
  }
  if (!subjectData.x) {
    if (typeSettings && typeSettings.x) {
      subjectData.x = typeSettings.x;
    }
  }
  if (!subjectData.y) {
    if (typeSettings && typeSettings.y) {
      subjectData.y = typeSettings.y;
    }
  }

  var handles = [];
  var components = [];
  var radius = subjectData.radius;
  var innerRadius = radius * 0.7;
  var x = 0;
  var y = 0;

  var notCornerOffset = Math.sqrt(2) * radius;
  var placement = {
    xleftcorner: -radius,
    xrightcorner: radius,
    ytopcorner: -radius,
    ybottomcorner: radius,
    xleft: -notCornerOffset,
    xright: notCornerOffset,
    ytop: -notCornerOffset,
    ybottom: notCornerOffset
  };

  if (subjectData.x && !subjectData.y) {
    x = placement["x" + subjectData.x];
  } else if (subjectData.y && !subjectData.x) {
    y = placement["y" + subjectData.y];
  } else if (subjectData.x && subjectData.y) {
    x = placement["x" + subjectData.x + "corner"];
    y = placement["y" + subjectData.y + "corner"];
  }

  var transform = "translate(" + x + ", " + y + ")";
  var circlebg = arcBuilder({ className: "subject", data: { radius: radius } });
  circlebg.attrs.transform = transform;
  circlebg.attrs.fill = annotation.color;
  circlebg.attrs["stroke-linecap"] = "round";
  circlebg.attrs["stroke-width"] = "3px";

  var circle = arcBuilder({
    className: "subject-ring",
    data: { outerRadius: radius, innerRadius: innerRadius }
  });

  circle.attrs.transform = transform;
  // circle.attrs.fill = annotation.color
  circle.attrs["stroke-width"] = "3px";
  circle.attrs.fill = "white";

  var pointer = void 0;
  if (x && y || !x && !y) {
    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
    });
  } else if (x || y) {
    var notCornerPointerXY = function notCornerPointerXY(v) {
      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
    };

    pointer = lineBuilder({
      className: "subject-pointer",
      data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
    });
  }

  if (pointer) {
    pointer.attrs.fill = annotation.color;
    pointer.attrs["stroke-linecap"] = "round";
    pointer.attrs["stroke-width"] = "3px";
    components.push(pointer);
  }

  if (type.editMode) {
    var dragBadge = function dragBadge() {
      subjectData.x = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x < -radius * 2 ? "left" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.x > radius * 2 ? "right" : undefined;
      subjectData.y = d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y < -radius * 2 ? "top" : d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.y > radius * 2 ? "bottom" : undefined;

      type.redrawSubject();
    };

    var bHandles = { x: x * 2, y: y * 2, drag: dragBadge.bind(type) };
    if (!bHandles.x && !bHandles.y) {
      bHandles.y = -radius;
    }

    handles = type.mapHandles([bHandles]);
  }

  var text = void 0;
  if (subjectData.text) {
    text = {
      type: "text",
      className: "badge-text",
      attrs: {
        fill: "white",
        stroke: "none",
        "font-size": ".7em",
        text: subjectData.text,
        "text-anchor": "middle",
        dy: ".25em",
        x: x,
        y: y
      }
    };
  }

  components.push(circlebg);
  components.push(circle);
  components.push(text);

  return { components: components, handles: handles };
});

//Note options
//Connector options
//Subject options
var Type = function () {
  function Type(_ref) {
    var a = _ref.a,
        annotation = _ref.annotation,
        editMode = _ref.editMode,
        dispatcher = _ref.dispatcher,
        notePadding = _ref.notePadding,
        accessors = _ref.accessors;
    classCallCheck(this, Type);

    this.a = a;

    this.note = annotation.disable.indexOf("note") === -1 && a.select("g.annotation-note");
    this.noteContent = this.note && a.select("g.annotation-note-content");
    this.connector = annotation.disable.indexOf("connector") === -1 && a.select("g.annotation-connector");
    this.subject = annotation.disable.indexOf("subject") === -1 && a.select("g.annotation-subject");
    this.dispatcher = dispatcher;

    if (dispatcher) {
      var handler = addHandlers.bind(null, dispatcher, annotation);
      handler({ component: this.note, name: "note" });
      handler({ component: this.connector, name: "connector" });
      handler({ component: this.subject, name: "subject" });
    }

    this.annotation = annotation;
    this.editMode = annotation.editMode || editMode;
    this.notePadding = notePadding !== undefined ? notePadding : 3;
    this.offsetCornerX = 0;
    this.offsetCornerY = 0;

    if (accessors && annotation.data) {
      this.init(accessors);
    }
  }

  createClass(Type, [{
    key: "init",
    value: function init(accessors) {
      if (!this.annotation.x) {
        this.mapX(accessors);
      }
      if (!this.annotation.y) {
        this.mapY(accessors);
      }
    }
  }, {
    key: "mapY",
    value: function mapY(accessors) {
      if (accessors.y) {
        this.annotation.y = accessors.y(this.annotation.data);
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      if (accessors.x) {
        this.annotation.x = accessors.x(this.annotation.data);
      }
    }
  }, {
    key: "updateEditMode",
    value: function updateEditMode() {
      this.a.selectAll("circle.handle").remove();
    }
  }, {
    key: "drawOnSVG",
    value: function drawOnSVG(component, builders) {
      var _this = this;

      if (!Array.isArray(builders)) {
        builders = [builders];
      }

      builders.filter(function (b) {
        return b;
      }).forEach(function (_ref2) {
        var type = _ref2.type,
            className = _ref2.className,
            attrs = _ref2.attrs,
            handles = _ref2.handles,
            classID = _ref2.classID;

        if (type === "handle") {
          addHandles({ group: component, r: attrs && attrs.r, handles: handles });
        } else {
          newWithClass(component, [_this.annotation], type, className, classID);
          var el = component.select(type + "." + (classID || className));
          var addAttrs = Object.keys(attrs);
          var removeAttrs = [];

          var currentAttrs = el.node().attributes;
          for (var i = currentAttrs.length - 1; i >= 0; i--) {
            var name = currentAttrs[i].name;
            if (addAttrs.indexOf(name) === -1 && name !== "class") removeAttrs.push(name);
          }

          addAttrs.forEach(function (attr) {
            if (attr === "text") {
              el.text(attrs[attr]);
            } else {
              el.attr(attr, attrs[attr]);
            }
          });

          removeAttrs.forEach(function (attr) {
            return el.attr(attr, null);
          });
        }
      });
    }

    //TODO: how to extend this to a drawOnCanvas mode?

  }, {
    key: "getNoteBBox",
    value: function getNoteBBox() {
      return bboxWithoutHandles(this.note, ".annotation-note-content text");
    }
  }, {
    key: "getNoteBBoxOffset",
    value: function getNoteBBoxOffset() {
      var bbox = bboxWithoutHandles(this.note, ".annotation-note-content");
      var transform = this.noteContent.attr("transform").split(/\(|\,|\)/g);
      bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx;
      bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy;
      bbox.offsetX = this.annotation.dx;
      bbox.offsetY = this.annotation.dy;
      return bbox;
    }
  }, {
    key: "drawSubject",
    value: function drawSubject() {
      var _this2 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var subjectData = this.annotation.subject;
      var type = context.type;
      var subjectParams = { type: this, subjectData: subjectData };

      var subject = {};
      if (type === "circle") subject = subjectCircle(subjectParams);else if (type === "rect") subject = subjectRect(subjectParams);else if (type === "threshold") subject = subjectThreshold(subjectParams);else if (type === "badge") subject = subjectBadge(subjectParams, this.annotation);

      var _subject = subject,
          _subject$components = _subject.components,
          components = _subject$components === undefined ? [] : _subject$components,
          _subject$handles = _subject.handles,
          handles = _subject$handles === undefined ? [] : _subject$handles;

      components.forEach(function (c) {
        if (c && c.attrs && !c.attrs.stroke) {
          c.attrs.stroke = _this2.annotation.color;
        }
      });

      if (this.editMode) {
        handles = handles.concat(this.mapHandles([{ drag: this.dragSubject.bind(this) }]));
        components.push({ type: "handle", handles: handles });
      }

      return components;
    }
  }, {
    key: "drawConnector",
    value: function drawConnector() {
      var _this3 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var connectorData = this.annotation.connector;
      var type = connectorData.type || context.type;
      var connectorParams = { type: this, connectorData: connectorData };
      connectorParams.subjectType = this.typeSettings && this.typeSettings.subject && this.typeSettings.subject.type;

      var connector = {};
      if (type === "curve") connector = connectorCurve(connectorParams);else if (type === "elbow") connector = connectorElbow(connectorParams);else connector = connectorLine(connectorParams);
      var _connector = connector,
          _connector$components = _connector.components,
          components = _connector$components === undefined ? [] : _connector$components,
          _connector$handles = _connector.handles,
          handles = _connector$handles === undefined ? [] : _connector$handles;

      var line$$1 = components[0];
      //TODO: genericize this into fill t/f stroke t/f
      if (line$$1) {
        line$$1.attrs.stroke = this.annotation.color;
        line$$1.attrs.fill = "none";
      }
      var endType = connectorData.end || context.end;
      var end = {};
      if (endType === "arrow") {
        var s = line$$1.data[1];
        var e = line$$1.data[0];
        var distance = Math.sqrt(Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2));
        if (distance < 5 && line$$1.data[2]) {
          s = line$$1.data[2];
        }
        end = connectorArrow({
          annotation: this.annotation,
          start: s,
          end: e,
          scale: connectorData.endScale
        });
      } else if (endType === "dot") {
        end = connectorDot({ line: line$$1, scale: connectorData.endScale });
      } else if (!endType || endType === "none") {
        this.connector && this.connector.select(".connector-end").remove();
      }

      if (end.components) {
        end.components.forEach(function (c) {
          c.attrs.fill = _this3.annotation.color;
          c.attrs.stroke = _this3.annotation.color;
        });
        components = components.concat(end.components);
      }

      if (this.editMode) {
        if (handles.length !== 0) components.push({ type: "handle", handles: handles });
      }
      return components;
    }
  }, {
    key: "drawNote",
    value: function drawNote() {
      var _this4 = this;

      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var noteData = this.annotation.note;
      var align = noteData.align || context.align || "dynamic";
      var noteParams = {
        bbox: context.bbox,
        align: align,
        offset: this.annotation.offset
      };
      var lineType = noteData.lineType || context.lineType;
      var note = {};
      if (lineType === "vertical") note = noteVertical(noteParams);else if (lineType === "horizontal") note = noteHorizontal(noteParams);

      var _note = note,
          _note$components = _note.components,
          components = _note$components === undefined ? [] : _note$components,
          _note$handles = _note.handles,
          handles = _note$handles === undefined ? [] : _note$handles;

      components.forEach(function (c) {
        c.attrs.stroke = _this4.annotation.color;
      });

      if (this.editMode) {
        handles = this.mapHandles([{ x: 0, y: 0, drag: this.dragNote.bind(this) }]);
        components.push({ type: "handle", handles: handles });

        var dragging = this.dragNote.bind(this),
            start = this.dragstarted.bind(this),
            end = this.dragended.bind(this);
        this.note.call((0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.drag)().container((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)("g.annotations").node()).on("start", function (d) {
          return start(d);
        }).on("drag", function (d) {
          return dragging(d);
        }).on("end", function (d) {
          return end(d);
        }));
      } else {
        this.note.on("mousedown.drag", null);
      }
      return components;
    }
  }, {
    key: "drawNoteContent",
    value: function drawNoteContent(context) {
      var noteData = this.annotation.note;
      var padding = noteData.padding !== undefined ? noteData.padding : this.notePadding;
      var orientation = noteData.orientation || context.orientation || "topBottom";
      var lineType = noteData.lineType || context.lineType;
      var align = noteData.align || context.align || "dynamic";

      if (lineType === "vertical") orientation = "leftRight";else if (lineType === "horizontal") orientation = "topBottom";

      var noteParams = {
        padding: padding,
        bbox: context.bbox,
        offset: this.annotation.offset,
        orientation: orientation,
        align: align
      };

      var _noteAlignment = noteAlignment(noteParams),
          x = _noteAlignment.x,
          y = _noteAlignment.y;

      this.offsetCornerX = x + this.annotation.dx;
      this.offsetCornerY = y + this.annotation.dy;
      this.note && this.noteContent.attr("transform", "translate(" + x + ", " + y + ")");

      return [];
    }
  }, {
    key: "drawOnScreen",
    value: function drawOnScreen(component, drawFunction) {
      return this.drawOnSVG(component, drawFunction);
    }
  }, {
    key: "redrawSubject",
    value: function redrawSubject() {
      this.subject && this.drawOnScreen(this.subject, this.drawSubject());
    }
  }, {
    key: "redrawConnector",
    value: function redrawConnector() {
      this.connector && this.drawOnScreen(this.connector, this.drawConnector());
    }
  }, {
    key: "redrawNote",
    value: function redrawNote() {
      var bbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNoteBBox();

      this.noteContent && this.drawOnScreen(this.noteContent, this.drawNoteContent({ bbox: bbox }));
      this.note && this.drawOnScreen(this.note, this.drawNote({ bbox: bbox }));
    }
  }, {
    key: "setPosition",
    value: function setPosition() {
      var position = this.annotation.position;
      this.a.attr("transform", "translate(" + position.x + ", " + position.y + ")");
    }
  }, {
    key: "clearComponents",
    value: function clearComponents() {
      this.subject && this.subject.select("*").remove();
      this.connector && this.connector.select("*").remove();
      // this.note && this.note.select("*").remove()
    }
  }, {
    key: "setOffset",
    value: function setOffset() {
      if (this.note) {
        var offset = this.annotation.offset;
        this.note.attr("transform", "translate(" + offset.x + ", " + offset.y + ")");
      }
    }
  }, {
    key: "setPositionWithAccessors",
    value: function setPositionWithAccessors(accessors) {
      if (accessors && this.annotation.data) {
        this.mapX(accessors);
        this.mapY(accessors);
      }
      this.setPosition();
    }
  }, {
    key: "setClassName",
    value: function setClassName() {
      this.a.attr("class", "annotation " + (this.className && this.className()) + " " + (this.editMode ? "editable" : "") + " " + (this.annotation.className || ""));
    }
  }, {
    key: "draw",
    value: function draw() {
      this.setClassName();
      this.setPosition();
      this.setOffset();
      this.redrawSubject();
      this.redrawConnector();
      this.redrawNote();
    }
  }, {
    key: "dragstarted",
    value: function dragstarted() {
      d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.sourceEvent.stopPropagation();
      this.dispatcher && this.dispatcher.call("dragstart", this.a, this.annotation);
      this.a.classed("dragging", true);
      this.a.selectAll("circle.handle").style("pointer-events", "none");
    }
  }, {
    key: "dragended",
    value: function dragended() {
      this.dispatcher && this.dispatcher.call("dragend", this.a, this.annotation);
      this.a.classed("dragging", false);
      this.a.selectAll("circle.handle").style("pointer-events", "all");
    }
  }, {
    key: "dragSubject",
    value: function dragSubject() {
      var position = this.annotation.position;
      position.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      position.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.position = position;
    }
  }, {
    key: "dragNote",
    value: function dragNote() {
      var offset = this.annotation.offset;
      offset.x += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dx;
      offset.y += d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.dy;
      this.annotation.offset = offset;
    }
  }, {
    key: "mapHandles",
    value: function mapHandles(handles) {
      var _this5 = this;

      return handles.map(function (h) {
        return _extends({}, h, {
          start: _this5.dragstarted.bind(_this5),
          end: _this5.dragended.bind(_this5)
        });
      });
    }
  }]);
  return Type;
}();

var customType = function customType(initialType, typeSettings, _init) {
  return function (_initialType) {
    inherits(customType, _initialType);

    function customType(settings) {
      classCallCheck(this, customType);

      var _this6 = possibleConstructorReturn(this, (customType.__proto__ || Object.getPrototypeOf(customType)).call(this, settings));

      _this6.typeSettings = typeSettings;

      if (typeSettings.disable) {
        typeSettings.disable.forEach(function (d) {
          _this6[d] && _this6[d].remove();

          _this6[d] = undefined;
          if (d === "note") {
            _this6.noteContent = undefined;
          }
        });
      }
      return _this6;
    }

    createClass(customType, [{
      key: "className",
      value: function className() {
        return "" + (typeSettings.className || get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this) && get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this).call(this) || "");
      }
    }, {
      key: "drawSubject",
      value: function drawSubject(context) {
        this.typeSettings.subject = _extends({}, typeSettings.subject, this.typeSettings.subject);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawSubject", this).call(this, _extends({}, context, this.typeSettings.subject));
      }
    }, {
      key: "drawConnector",
      value: function drawConnector(context) {
        this.typeSettings.connector = _extends({}, typeSettings.connector, this.typeSettings.connector);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawConnector", this).call(this, _extends({}, context, typeSettings.connector, this.typeSettings.connector));
      }
    }, {
      key: "drawNote",
      value: function drawNote(context) {
        this.typeSettings.note = _extends({}, typeSettings.note, this.typeSettings.note);
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNote", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }, {
      key: "drawNoteContent",
      value: function drawNoteContent(context) {
        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNoteContent", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
      }
    }], [{
      key: "init",
      value: function init(annotation, accessors) {
        get(customType.__proto__ || Object.getPrototypeOf(customType), "init", this).call(this, annotation, accessors);
        if (_init) {
          annotation = _init(annotation, accessors);
        }
        return annotation;
      }
    }]);
    return customType;
  }(initialType);
};

var d3NoteText = function (_Type) {
  inherits(d3NoteText, _Type);

  function d3NoteText(params) {
    classCallCheck(this, d3NoteText);

    var _this7 = possibleConstructorReturn(this, (d3NoteText.__proto__ || Object.getPrototypeOf(d3NoteText)).call(this, params));

    _this7.textWrap = params.textWrap || 120;
    _this7.drawText();
    return _this7;
  }

  createClass(d3NoteText, [{
    key: "updateTextWrap",
    value: function updateTextWrap(textWrap) {
      this.textWrap = textWrap;
      this.drawText();
    }

    //TODO: add update text functionality

  }, {
    key: "drawText",
    value: function drawText() {
      if (this.note) {
        newWithClass(this.note, [this.annotation], "g", "annotation-note-content");

        var noteContent = this.note.select("g.annotation-note-content");
        newWithClass(noteContent, [this.annotation], "rect", "annotation-note-bg");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-label");
        newWithClass(noteContent, [this.annotation], "text", "annotation-note-title");

        var titleBBox = { height: 0 };
        var label = this.a.select("text.annotation-note-label");
        var wrapLength = this.annotation.note && this.annotation.note.wrap || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrap || this.textWrap;

        var wrapSplitter = this.annotation.note && this.annotation.note.wrapSplitter || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrapSplitter;

        var bgPadding = this.annotation.note && this.annotation.note.bgPadding || this.typeSettings && this.typeSettings.note && this.typeSettings.note.bgPadding;

        var bgPaddingFinal = { top: 0, bottom: 0, left: 0, right: 0 };
        if (typeof bgPadding === "number") {
          bgPaddingFinal = {
            top: bgPadding,
            bottom: bgPadding,
            left: bgPadding,
            right: bgPadding
          };
        } else if (bgPadding && (typeof bgPadding === "undefined" ? "undefined" : _typeof(bgPadding)) === "object") {
          bgPaddingFinal = _extends(bgPaddingFinal, bgPadding);
        }

        if (this.annotation.note.title) {
          var title = this.a.select("text.annotation-note-title");
          title.text(this.annotation.note.title);
          title.attr("fill", this.annotation.color);
          title.attr("font-weight", "bold");
          title.call(wrap, wrapLength, wrapSplitter);
          titleBBox = title.node().getBBox();
        }

        label.text(this.annotation.note.label).attr("dx", "0");
        label.call(wrap, wrapLength, wrapSplitter);

        label.attr("y", titleBBox.height * 1.1 || 0);
        label.attr("fill", this.annotation.color);

        var bbox = this.getNoteBBox();

        this.a.select("rect.annotation-note-bg").attr("width", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right).attr("height", bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom).attr("x", bbox.x - bgPaddingFinal.left).attr("y", -bgPaddingFinal.top).attr("fill", "white").attr("fill-opacity", 0);
      }
    }
  }]);
  return d3NoteText;
}(Type);

var d3Label = customType(d3NoteText, {
  className: "label",
  note: { align: "middle" }
});

var d3Callout = customType(d3NoteText, {
  className: "callout",
  note: { lineType: "horizontal" }
});

var d3CalloutElbow = customType(d3Callout, {
  className: "callout elbow",
  connector: { type: "elbow" }
});

var d3CalloutCurve = customType(d3Callout, {
  className: "callout curve",
  connector: { type: "curve" }
});

var d3Badge = customType(Type, {
  className: "badge",
  subject: { type: "badge" },
  disable: ["connector", "note"]
});

var d3CalloutCircle = customType(d3NoteText, {
  className: "callout circle",
  subject: { type: "circle" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var d3CalloutRect = customType(d3NoteText, {
  className: "callout rect",
  subject: { type: "rect" },
  note: { lineType: "horizontal" },
  connector: { type: "elbow" }
});

var ThresholdMap = function (_d3Callout) {
  inherits(ThresholdMap, _d3Callout);

  function ThresholdMap() {
    classCallCheck(this, ThresholdMap);
    return possibleConstructorReturn(this, (ThresholdMap.__proto__ || Object.getPrototypeOf(ThresholdMap)).apply(this, arguments));
  }

  createClass(ThresholdMap, [{
    key: "mapY",
    value: function mapY(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapY", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {
        a.y = accessors.y(a.data);
      }
      if ((a.subject.x1 || a.subject.x2) && !a.x) {
        a.x = a.subject.x1 || a.subject.x2;
      }
    }
  }, {
    key: "mapX",
    value: function mapX(accessors) {
      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapX", this).call(this, accessors);
      var a = this.annotation;
      if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {
        a.x = accessors.x(a.data);
      }
      if ((a.subject.y1 || a.subject.y2) && !a.y) {
        a.y = a.subject.y1 || a.subject.y2;
      }
    }
  }]);
  return ThresholdMap;
}(d3Callout);

var d3XYThreshold = customType(ThresholdMap, {
  className: "callout xythreshold",
  subject: { type: "threshold" }
});

var newWithClass = function newWithClass(a, d, type, className, classID) {
  var group = a.selectAll(type + "." + (classID || className)).data(d);
  group.enter().append(type).merge(group).attr("class", className);

  group.exit().remove();
  return a;
};

var addHandlers = function addHandlers(dispatcher, annotation, _ref3) {
  var component = _ref3.component,
      name = _ref3.name;

  if (component) {
    component.on("mouseover.annotations", function () {
      dispatcher.call(name + "over", component, annotation);
    }).on("mouseout.annotations", function () {
      return dispatcher.call(name + "out", component, annotation);
    }).on("click.annotations", function () {
      return dispatcher.call(name + "click", component, annotation);
    });
  }
};

//Text wrapping code adapted from Mike Bostock
var wrap = function wrap(text, width, wrapSplitter) {
  var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.2;

  text.each(function () {
    var text = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this),
        words = text.text().split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
      return w !== "";
    });
    var word = void 0,
        line$$1 = [],
        tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", 0.8 + "em");

    while (word = words.pop()) {
      line$$1.push(word);
      tspan.text(line$$1.join(" "));
      if (tspan.node().getComputedTextLength() > width && line$$1.length > 1) {
        line$$1.pop();
        tspan.text(line$$1.join(" "));
        line$$1 = [word];
        tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + "em").text(word);
      }
    }
  });
};

var bboxWithoutHandles = function bboxWithoutHandles(selection) {
  var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ":not(.handle)";

  if (!selection) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }

  return selection.selectAll(selector).nodes().reduce(function (p, c) {
    var bbox = c.getBBox();
    p.x = Math.min(p.x, bbox.x);
    p.y = Math.min(p.y, bbox.y);
    p.width = Math.max(p.width, bbox.width);

    var yOffset = c && c.attributes && c.attributes.y;
    p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
    return p;
  }, { x: 0, y: 0, width: 0, height: 0 });
};

function annotation() {
  var annotations = [],
      collection = void 0,
      context = void 0,
      //TODO: add canvas functionality
  disable = [],
      accessors = {},
      accessorsInverse = {},
      editMode = false,
      ids = void 0,
      type = d3Callout,
      textWrap = void 0,
      notePadding = void 0,
      annotationDispatcher = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_3__.dispatch)("subjectover", "subjectout", "subjectclick", "connectorover", "connectorout", "connectorclick", "noteover", "noteout", "noteclick", "dragend", "dragstart"),
      sel = void 0;

  var annotation = function annotation(selection) {
    sel = selection;
    //TODO: check to see if this is still needed
    if (!editMode) {
      selection.selectAll("circle.handle").remove();
    }

    var translatedAnnotations = annotations.map(function (a) {
      if (!a.type) {
        a.type = type;
      }
      if (!a.disable) {
        a.disable = disable;
      }
      return new Annotation(a);
    });

    collection = collection || new AnnotationCollection({
      annotations: translatedAnnotations,
      accessors: accessors,
      accessorsInverse: accessorsInverse,
      ids: ids
    });

    var annotationG = selection.selectAll("g").data([collection]);
    annotationG.enter().append("g").attr("class", "annotations");

    var group = selection.select("g.annotations");
    newWithClass(group, collection.annotations, "g", "annotation");

    var annotation = group.selectAll("g.annotation");

    annotation.each(function (d) {
      var a = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(this);

      a.attr("class", "annotation");

      newWithClass(a, [d], "g", "annotation-connector");
      newWithClass(a, [d], "g", "annotation-subject");
      newWithClass(a, [d], "g", "annotation-note");
      newWithClass(a.select("g.annotation-note"), [d], "g", "annotation-note-content");
      d.type = d.type.toString() === "[object Object]" ? d.type : new d.type({
        a: a,
        annotation: d,
        textWrap: textWrap,
        notePadding: notePadding,
        editMode: editMode,
        dispatcher: annotationDispatcher,
        accessors: accessors
      });
      d.type.draw();
      d.type.drawText && d.type.drawText();
    });
  };

  annotation.json = function () {
    /* eslint-disable no-console */
    console.log("Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.", collection.json);
    /* eslint-enable no-console */
    window.copy(JSON.stringify(collection.json.map(function (a) {
      delete a.type;
      return a;
    })));
    return annotation;
  };

  annotation.update = function () {
    if (annotations && collection) {
      annotations = collection.annotations.map(function (a) {
        a.type.draw();
        return a;
      });
    }
    return annotation;
  };

  annotation.updateText = function () {
    if (collection) {
      collection.updateText(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.updatedAccessors = function () {
    collection.setPositionWithAccessors();
    annotations = collection.annotations;
    return annotation;
  };

  annotation.disable = function (_) {
    if (!arguments.length) return disable;
    disable = _;
    if (collection) {
      collection.updateDisable(disable);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.textWrap = function (_) {
    if (!arguments.length) return textWrap;
    textWrap = _;
    if (collection) {
      collection.updateTextWrap(textWrap);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.notePadding = function (_) {
    if (!arguments.length) return notePadding;
    notePadding = _;
    if (collection) {
      collection.updateNotePadding(notePadding);
      annotations = collection.annotations;
    }
    return annotation;
  };
  //todo think of how to handle when undefined is sent
  annotation.type = function (_, settings) {
    if (!arguments.length) return type;
    type = _;
    if (collection) {
      collection.annotations.map(function (a) {
        a.type.note && a.type.note.selectAll("*:not(.annotation-note-content)").remove();
        a.type.noteContent && a.type.noteContent.selectAll("*").remove();
        a.type.subject && a.type.subject.selectAll("*").remove();
        a.type.connector && a.type.connector.selectAll("*").remove();
        a.type.typeSettings = {};
        a.type = type;

        a.subject = settings && settings.subject || a.subject;
        a.connector = settings && settings.connector || a.connector;
        a.note = settings && settings.note || a.note;
      });

      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.annotations = function (_) {
    if (!arguments.length) return collection && collection.annotations || annotations;
    annotations = _;

    if (collection && collection.annotations) {
      var rerun = annotations.some(function (d) {
        return !d.type || d.type.toString() !== "[object Object]";
      });

      if (rerun) {
        collection = null;
        annotation(sel);
      } else {
        collection.annotations = annotations;
      }
    }
    return annotation;
  };

  annotation.context = function (_) {
    if (!arguments.length) return context;
    context = _;
    return annotation;
  };

  annotation.accessors = function (_) {
    if (!arguments.length) return accessors;
    accessors = _;
    return annotation;
  };

  annotation.accessorsInverse = function (_) {
    if (!arguments.length) return accessorsInverse;
    accessorsInverse = _;
    return annotation;
  };

  annotation.ids = function (_) {
    if (!arguments.length) return ids;
    ids = _;
    return annotation;
  };

  annotation.editMode = function (_) {
    if (!arguments.length) return editMode;
    editMode = _;

    if (sel) {
      sel.selectAll("g.annotation").classed("editable", editMode);
    }

    if (collection) {
      collection.editMode(editMode);
      annotations = collection.annotations;
    }
    return annotation;
  };

  annotation.collection = function (_) {
    if (!arguments.length) return collection;
    collection = _;
    return annotation;
  };

  annotation.on = function () {
    var value = annotationDispatcher.on.apply(annotationDispatcher, arguments);
    return value === annotationDispatcher ? annotation : value;
  };

  return annotation;
}

var index = {
  annotation: annotation,
  annotationTypeBase: Type,
  annotationLabel: d3Label,
  annotationCallout: d3Callout,
  annotationCalloutCurve: d3CalloutCurve,
  annotationCalloutElbow: d3CalloutElbow,
  annotationCalloutCircle: d3CalloutCircle,
  annotationCalloutRect: d3CalloutRect,
  annotationXYThreshold: d3XYThreshold,
  annotationBadge: d3Badge,
  annotationCustomType: customType
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);
//# sourceMappingURL=indexRollupNext.js.map


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dispatch: () => (/* reexport safe */ _src_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _src_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js");



/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-dispatch/src/dispatch.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.x, y: d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__.dispatch)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__.mouse, this, arguments);
    if (!gesture) return;
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
    mousemoving = false;
    mousedownx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX;
    mousedowny = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    if (!mousemoving) {
      var dx = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientX - mousedownx, dy = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.select)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view).on("mousemove.drag mouseup.drag", null);
    (0,_nodrag__WEBPACK_IMPORTED_MODULE_2__.yesdrag)(d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.view, mousemoving);
    (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__.touch, this, arguments)) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent__WEBPACK_IMPORTED_MODULE_3__.nopropagation)();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.customEvent)(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/event.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragEvent)
/* harmony export */ });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drag: () => (/* reexport safe */ _drag__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   dragDisable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   dragEnable: () => (/* reexport safe */ _nodrag__WEBPACK_IMPORTED_MODULE_1__.yesdrag)
/* harmony export */ });
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/drag.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js");




/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/nodrag.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.select)(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-drag/src/noevent.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__.event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (path);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clientPoint: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   create: () => (/* reexport safe */ _create__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   creator: () => (/* reexport safe */ _creator__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   customEvent: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.customEvent),
/* harmony export */   event: () => (/* reexport safe */ _selection_on__WEBPACK_IMPORTED_MODULE_17__.event),
/* harmony export */   local: () => (/* reexport safe */ _local__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   matcher: () => (/* reexport safe */ _matcher__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mouse: () => (/* reexport safe */ _mouse__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   namespace: () => (/* reexport safe */ _namespace__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   namespaces: () => (/* reexport safe */ _namespaces__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   select: () => (/* reexport safe */ _select__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   selectAll: () => (/* reexport safe */ _selectAll__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   selection: () => (/* reexport safe */ _selection_index__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   selector: () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   selectorAll: () => (/* reexport safe */ _selectorAll__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   style: () => (/* reexport safe */ _selection_style__WEBPACK_IMPORTED_MODULE_13__.styleValue),
/* harmony export */   touch: () => (/* reexport safe */ _touch__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   touches: () => (/* reexport safe */ _touches__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   window: () => (/* reexport safe */ _window__WEBPACK_IMPORTED_MODULE_16__["default"])
/* harmony export */ });
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/create.js");
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mouse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js");
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _selection_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./touch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js");
/* harmony import */ var _touches__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./touches */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js");
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");




















/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/local.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ local)
/* harmony export */ });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/mouse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  var event = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespaces.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/select.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectAll.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__.Selection([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/constant.js");




var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__.Selection(this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./join */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sort */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./call */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodes */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./node */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./size */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./empty */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./each */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./property */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classed */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./text */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./html */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./raise */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lower */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./append */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./insert */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./datum */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./dispatch */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/dispatch.js");
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  join: _join__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_8__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_9__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_10__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_11__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_12__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_13__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_14__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_15__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_16__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_17__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_18__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_19__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_20__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_21__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_22__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_23__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_24__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_25__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_26__["default"],
  clone: _clone__WEBPACK_IMPORTED_MODULE_27__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_28__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_29__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_30__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/insert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/join.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/lower.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/merge.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/node.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/nodes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customEvent: () => (/* binding */ customEvent),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   event: () => (/* binding */ event)
/* harmony export */ });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/order.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/property.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/raise.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/remove.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/select.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/selectAll.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/size.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sort.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/sparse.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/style.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/text.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selector.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selectorAll.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/selection/on.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touch.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/touches.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/point.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, touches) {
  if (touches == null) touches = (0,_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = (0,_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-selection/src/window.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arc: () => (/* reexport safe */ _src_arc__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   area: () => (/* reexport safe */ _src_area__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   curveBasis: () => (/* reexport safe */ _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   curveBasisClosed: () => (/* reexport safe */ _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   curveBasisOpen: () => (/* reexport safe */ _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   curveBundle: () => (/* reexport safe */ _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   curveCardinal: () => (/* reexport safe */ _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   curveCardinalClosed: () => (/* reexport safe */ _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   curveCardinalOpen: () => (/* reexport safe */ _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   curveCatmullRom: () => (/* reexport safe */ _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   curveCatmullRomClosed: () => (/* reexport safe */ _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   curveCatmullRomOpen: () => (/* reexport safe */ _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   curveLinear: () => (/* reexport safe */ _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   curveLinearClosed: () => (/* reexport safe */ _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   curveMonotoneX: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneX),
/* harmony export */   curveMonotoneY: () => (/* reexport safe */ _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__.monotoneY),
/* harmony export */   curveNatural: () => (/* reexport safe */ _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   curveStep: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   curveStepAfter: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepAfter),
/* harmony export */   curveStepBefore: () => (/* reexport safe */ _src_curve_step__WEBPACK_IMPORTED_MODULE_28__.stepBefore),
/* harmony export */   line: () => (/* reexport safe */ _src_line__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   pie: () => (/* reexport safe */ _src_pie__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   radialArea: () => (/* reexport safe */ _src_radialArea__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   radialLine: () => (/* reexport safe */ _src_radialLine__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   stack: () => (/* reexport safe */ _src_stack__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   stackOffsetExpand: () => (/* reexport safe */ _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   stackOffsetNone: () => (/* reexport safe */ _src_offset_none__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   stackOffsetSilhouette: () => (/* reexport safe */ _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   stackOffsetWiggle: () => (/* reexport safe */ _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   stackOrderAscending: () => (/* reexport safe */ _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   stackOrderDescending: () => (/* reexport safe */ _src_order_descending__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   stackOrderInsideOut: () => (/* reexport safe */ _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   stackOrderNone: () => (/* reexport safe */ _src_order_none__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   stackOrderReverse: () => (/* reexport safe */ _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   symbol: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   symbolCircle: () => (/* reexport safe */ _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   symbolCross: () => (/* reexport safe */ _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   symbolDiamond: () => (/* reexport safe */ _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   symbolSquare: () => (/* reexport safe */ _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   symbolStar: () => (/* reexport safe */ _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   symbolTriangle: () => (/* reexport safe */ _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   symbolWye: () => (/* reexport safe */ _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   symbols: () => (/* reexport safe */ _src_symbol__WEBPACK_IMPORTED_MODULE_6__.symbols)
/* harmony export */ });
/* harmony import */ var _src_arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/arc */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js");
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _src_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _src_pie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pie */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js");
/* harmony import */ var _src_radialArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/radialArea */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js");
/* harmony import */ var _src_radialLine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");
/* harmony import */ var _src_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/symbol */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _src_symbol_circle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _src_symbol_cross__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _src_symbol_diamond__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _src_symbol_square__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _src_symbol_star__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _src_symbol_triangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _src_symbol_wye__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _src_curve_basisClosed__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/curve/basisClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var _src_curve_basisOpen__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/curve/basisOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var _src_curve_basis__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/curve/basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var _src_curve_bundle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/curve/bundle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var _src_curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/curve/cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _src_curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/curve/cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _src_curve_cardinal__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/curve/cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var _src_curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/curve/catmullRomClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var _src_curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/curve/catmullRomOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var _src_curve_catmullRom__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/curve/catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var _src_curve_linearClosed__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/curve/linearClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var _src_curve_linear__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _src_curve_monotone__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/curve/monotone */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var _src_curve_natural__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/curve/natural */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var _src_curve_step__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/curve/step */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var _src_stack__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/stack */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js");
/* harmony import */ var _src_offset_expand__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/offset/expand */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js");
/* harmony import */ var _src_offset_none__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _src_offset_silhouette__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/offset/silhouette */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js");
/* harmony import */ var _src_offset_wiggle__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/offset/wiggle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js");
/* harmony import */ var _src_order_ascending__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/order/ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");
/* harmony import */ var _src_order_descending__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/order/descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js");
/* harmony import */ var _src_order_insideOut__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/order/insideOut */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js");
/* harmony import */ var _src_order_none__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _src_order_reverse__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/order/reverse */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js");












































/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/arc.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function asin(x) {
  return x >= 1 ? _math__WEBPACK_IMPORTED_MODULE_1__.halfPi : x <= -1 ? -_math__WEBPACK_IMPORTED_MODULE_1__.halfPi : Math.asin(x);
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_1__.halfPi,
        da = Math.abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_2__["default"])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math__WEBPACK_IMPORTED_MODULE_1__.tau - _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
      context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
          rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var p0 = asin(rp / r0 * Math.sin(ap)),
            p1 = asin(rp / r1 * Math.sin(ap));
        if ((da0 -= p0 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Math.cos(a01),
          y01 = r1 * Math.sin(a01),
          x10 = r0 * Math.cos(a10),
          y10 = r0 * Math.sin(a10);

      // Apply rounded corners?
      if (rc > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        var x11 = r1 * Math.cos(a11),
            y11 = r1 * Math.sin(a11),
            x00 = r0 * Math.cos(a00),
            y00 = r0 * Math.sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < _math__WEBPACK_IMPORTED_MODULE_1__.pi) {
          var oc = da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
              lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) || !(da0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > _math__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math__WEBPACK_IMPORTED_MODULE_1__.pi / 2;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x0 = _point__WEBPACK_IMPORTED_MODULE_3__.x,
      x1 = null,
      y0 = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      y1 = _point__WEBPACK_IMPORTED_MODULE_3__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line__WEBPACK_IMPORTED_MODULE_2__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Basis: () => (/* binding */ Basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Basis(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisClosed.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basisOpen.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: (0,_basis__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisOpen(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/bundle.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis__WEBPACK_IMPORTED_MODULE_0__.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cardinal: () => (/* binding */ Cardinal),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalClosed: () => (/* binding */ CardinalClosed),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardinalOpen: () => (/* binding */ CardinalOpen),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_cardinal__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal__WEBPACK_IMPORTED_MODULE_1__.Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalClosed */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_2__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalOpen */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_catmullRom__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linearClosed.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new LinearClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/monotone.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   monotoneX: () => (/* binding */ monotoneX),
/* harmony export */   monotoneY: () => (/* binding */ monotoneY)
/* harmony export */ });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/natural.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Natural(context);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   curveRadialLinear: () => (/* binding */ curveRadialLinear),
/* harmony export */   "default": () => (/* binding */ curveRadial)
/* harmony export */ });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");


var curveRadialLinear = curveRadial(_linear__WEBPACK_IMPORTED_MODULE_0__["default"]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/step.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   stepAfter: () => (/* binding */ stepAfter),
/* harmony export */   stepBefore: () => (/* binding */ stepBefore)
/* harmony export */ });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var x = _point__WEBPACK_IMPORTED_MODULE_2__.x,
      y = _point__WEBPACK_IMPORTED_MODULE_2__.y,
      defined = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_3__["default"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/noop.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/expand.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/silhouette.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/wiggle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sum: () => (/* binding */ sum)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var sums = series.map(sum);
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/descending.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/insideOut.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/ascending.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending__WEBPACK_IMPORTED_MODULE_1__.sum),
      order = (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/reverse.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(series) {
  return (0,_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/pie.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_2__["default"],
      sortValues = _descending__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      endAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(_math__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/point.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialArea.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/area.js");
/* harmony import */ var _radialLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radialLine */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var a = (0,_area__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return (0,_radialLine__WEBPACK_IMPORTED_MODULE_2__.radialLine)(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return a;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/radialLine.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   radialLine: () => (/* binding */ radialLine)
/* harmony export */ });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/line.js");



function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c((0,_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return radialLine((0,_line__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__.curveRadialLinear));
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/stack.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _offset_none__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./offset/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _order_none__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order/none */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/order/none.js");





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var keys = (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([]),
      order = _order_none__WEBPACK_IMPORTED_MODULE_3__["default"],
      offset = _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"],
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? _order_none__WEBPACK_IMPORTED_MODULE_3__["default"] : typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__.slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"] : _, stack) : offset;
  };

  return stack;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   symbols: () => (/* binding */ symbols)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-svg-annotation/node_modules/d3-path/src/path.js");
/* harmony import */ var _symbol_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/star */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/square */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_star__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_triangle__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye__WEBPACK_IMPORTED_MODULE_6__["default"]
];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var type = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_symbol_circle__WEBPACK_IMPORTED_MODULE_0__["default"]),
      size = (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_8__["default"])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/circle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/cross.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/diamond.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/square.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/star.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / Math.sin(7 * _math__WEBPACK_IMPORTED_MODULE_0__.pi / 10),
    kx = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr,
    ky = -Math.cos(_math__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/triangle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var sqrt3 = Math.sqrt(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-svg-annotation/node_modules/d3-shape/src/symbol/wye.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./src/css/index.css":
/*!***************************!*\
  !*** ./src/css/index.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./index.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   object: () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bbox: () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   feature: () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   merge: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mergeArcs: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   mesh: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   meshArcs: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   neighbors: () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   quantize: () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   transform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   untransform: () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "./node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "./node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mergeArcs: () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   meshArcs: () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "./node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be 2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./src/core/annotations.js":
/*!*********************************!*\
  !*** ./src/core/annotations.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendAnnotations: () => (/* binding */ appendAnnotations)
/* harmony export */ });
/* harmony import */ var d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-svg-annotation */ "./node_modules/d3-svg-annotation/indexRollupNext.js");


function appendAnnotations(map) {
    if (map.svg_) {
        const zoomGroup = map.svg_.select('#em-zoom-group-' + map.svgId_)
        //clear previous
        zoomGroup.selectAll('.em-annotation-group').remove()

        const annotationsConfig = map.annotations_

        if (annotationsConfig) {
            // Define a map that maps the type string to the corresponding annotation function
            const annotationTypeMap = {
                annotationLabel: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel,
                annotationCallout: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCallout,
                annotationCalloutRect: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutRect,
                annotationCalloutCircle: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationCalloutCircle,
                annotationXYThreshold: d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationXYThreshold, // Add any other types you need
            }

            // Map annotations data to ensure each annotation has the proper function
            const annotationsWithTypes = annotationsConfig.annotations.map((d) => {
                // Replace the 'type' string with the corresponding annotation function
                const annotationType = annotationTypeMap[d.type] || d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel // Default to annotationLabel
                return { ...d, type: annotationType } // Update 'type' with the function reference
            })
            const makeAnnotations = (0,d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotation)().type(d3_svg_annotation__WEBPACK_IMPORTED_MODULE_0__.annotationLabel).annotations(annotationsWithTypes).editMode(annotationsConfig.editMode)

            // append new
            zoomGroup.append('g').attr('class', 'em-annotation-group').call(makeAnnotations)
        }
    }
}


/***/ }),

/***/ "./src/core/cartograms.js":
/*!********************************!*\
  !*** ./src/core/cartograms.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildGridCartogramBase: () => (/* binding */ buildGridCartogramBase)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");



// draw grid cartogram geometries
const buildGridCartogramBase = function (out) {
    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(`#em-zoom-group-${out.svgId_}`)
    const gridGroup = zoomGroup.append('g').attr('id', 'em-grid-container')

    // Ensure margins exist with default values
    out.gridCartogramMargins_ = out.gridCartogramMargins_ || { top: 80, right: 80, bottom: 80, left: 80 }

    // Get grid layout
    const gridLayout = getGridLayout(out)
    const position = parseGridLayout(gridLayout)
    const gridData = getGridData(position, out)

    // Draw the appropriate grid
    if (out.gridCartogramShape_ === 'hexagon') {
        drawHexagonGrid(gridGroup, gridData, out)
    } else {
        drawSquareGrid(gridGroup, gridData, out)
    }

    // Center the grid
    centerGrid(gridGroup, out.width_, out.height_, out.gridCartogramMargins_)
}

/** Determines the grid layout based on settings */
const getGridLayout = (out) => {
    const squareGrid = `
        ,IS,  ,  ,NO,SE,FI,  ,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    const hexagonGrid = `
        ,IS,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,
        ,  ,  ,  ,NO,SE,FI,EE,  ,  ,  ,  ,
        ,  ,  ,  ,  ,  ,  ,LV,  ,  ,  ,  ,
        ,IE,UK,  ,  ,DK,  ,LT,  ,  ,  ,  ,
        ,  ,  ,  ,NL,DE,PL,  ,  ,  ,  ,  ,
        ,  ,  ,BE,LU,CZ,SK,UA,  ,  ,  ,  ,
        ,  ,FR,CH,LI,AT,HU,RO,MD,  ,  ,  ,
        ,PT,ES,  ,IT,SI,HR,RS,BG,  ,  ,  ,
        ,  ,  ,  ,  ,  ,BA,ME,MK,  ,  ,  ,  
        ,  ,  ,  ,  ,  ,  ,AL,EL,TR,GE,  ,  
        ,  ,  ,  ,MT,  ,  ,  ,  ,CY,  ,  ,  `

    return out.gridCartogramPositions_ || (out.gridCartogramShape_ === 'hexagon' ? hexagonGrid : squareGrid)
}

/** Parses the grid layout and maps each ID to its position */
const parseGridLayout = (gridLayout) => {
    const positionById = new Map()
    ;(0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__.csvParseRows)(gridLayout.trim(), (row, j) => {
        row.forEach((id, i) => {
            if ((id = id.trim())) {
                positionById.set(id, [i, j])
            }
        })
    })
    return positionById
}

/** Converts parsed positions into structured grid data */
const getGridData = (position, out) => {
    return Array.from(position, ([id, [col, row]]) => {
        const feature = out.Geometries.geoJSONs.nutsrg.find((rg) => rg.properties.id == id)
        return {
            id,
            col,
            row,
            properties: {
                id: id,
                name: feature ? feature.properties.na : '',
            },
        }
    })
}

/** Draws a square grid */
const drawSquareGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const cellWidth = (out.width_ - margins.left - margins.right) / numCols - cellPadding
    const cellHeight = (out.height_ - margins.top - margins.bottom) / numRows - cellPadding
    const cellSize = Math.min(cellWidth, cellHeight)

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => `translate(${d.col * (cellSize + cellPadding) + margins.left}, ${d.row * (cellSize + cellPadding) + margins.top})`)
        .each(function (d) {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('rect').attr('width', cellSize).attr('height', cellSize).attr('class', 'em-grid-rect')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('x', cellSize / 2)
                .attr('y', cellSize / 2 + 5)
        })
}

/** Draws a hexagon grid */
const drawHexagonGrid = (gridGroup, gridData, out) => {
    const numCols = Math.max(...gridData.map((d) => d.col)) + 1
    const numRows = Math.max(...gridData.map((d) => d.row)) + 1

    const margins = out.gridCartogramMargins_
    const cellPadding = out.gridCartogramCellPadding_ || 0 // Keep cell padding

    const baseHexRadius = Math.min(
        (out.width_ - margins.left - margins.right) / (numCols * 1.5),
        (out.height_ - margins.top - margins.bottom) / (numRows * Math.sqrt(3))
    )

    const hexRadius = baseHexRadius
    const hexHeight = Math.sqrt(3) * hexRadius

    gridGroup
        .selectAll('.em-grid-cell')
        .data(gridData)
        .enter()
        .append('g')
        .attr('class', 'em-grid-cell')
        .attr('transform', (d) => {
            const x = d.col * (1.5 * hexRadius + cellPadding) + margins.left
            const y = d.row * (hexHeight + cellPadding) + (d.col % 2 === 1 ? (hexHeight + cellPadding) / 2 : 0) + margins.top
            return `translate(${x}, ${y})`
        })
        .each(function (d) {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).append('path').attr('d', drawHexagon(hexRadius)).attr('class', 'em-grid-hexagon')

            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
                .append('text')
                .attr('class', 'em-grid-text')
                .attr('text-anchor', 'middle')
                .attr('font-size', 15)
                .style('pointer-events', 'none')
                .attr('fill', 'black')
                .text(d.id)
                .attr('y', 5)
        })
}

/** Generates the hexagon path */
const drawHexagon = (r) => {
    const angle = Math.PI / 3
    return (
        Array.from({ length: 6 }, (_, i) => {
            const x = r * Math.cos(angle * i)
            const y = r * Math.sin(angle * i)
            return `${i === 0 ? 'M' : 'L'}${x},${y}`
        }).join(' ') + ' Z'
    )
}

/** Centers the grid within the SVG */
const centerGrid = (gridGroup, svgWidth, svgHeight, margins) => {
    gridGroup.each(function () {
        const bbox = this.getBBox()
        const dx = (svgWidth - margins.left - margins.right - bbox.width) / 2 - bbox.x + margins.left
        const dy = (svgHeight - margins.top - margins.bottom - bbox.height) / 2 - bbox.y + margins.top
        gridGroup.attr('transform', `translate(${dx}, ${dy})`)
    })
}


/***/ }),

/***/ "./src/core/deprecated.js":
/*!********************************!*\
  !*** ./src/core/deprecated.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defineDeprecatedFunctions: () => (/* binding */ defineDeprecatedFunctions)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/core/utils.js");


/* prettier-ignore */
// to keep track of deprecated functions whilst keeping the current version clean.
// also passes any important parameters to the new functions (if they exist) and overwrites any CSS style rules.
// To be removed when completely phased out.

const defineDeprecatedFunctions = (out) => {
    // styles
    out.seaFillStyle = (v) => (console.warn('seaFillStyle() is now DEPRECATED, please use the .em-sea CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-sea','fill',v), out);
    out.cntrgFillStyle = (v) => (console.warn('cntrgFillStyle() is now DEPRECATED, please use the .em-cntrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-cntrg','fill',v), out);
    out.nutsrgFillStyle = (v) => (console.warn('nutsrgFillStyle() is now DEPRECATED, please use the .em-nutsrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-nutsrg','fill',v), out);
    out.nutsbnStroke = (v) => {
        console.warn('nutsbnStroke() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke',v['3'])
        }
        return out
    };
    out.nutsbnStrokeWidth = (v) => {
        console.warn('nutsbnStrokeWidth() is now DEPRECATED, please use the .bn_0, .bn_1, .bn_2, .bn_3 CSS classes')
        if (v['0']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_0','stroke-width',v['0'])
        }
        if (v['1']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_1','stroke-width',v['1'])
        }
        if (v['2']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_2','stroke-width',v['2'])
        }
        if (v['3']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.bn_3','stroke-width',v['3'])
        }
        return out
    };
    out.graticuleStroke = (v) => (console.warn('graticuleStroke() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke',v), out);
    out.graticuleStrokeWidth = (v) => (console.warn('graticuleStrokeWidth() is now DEPRECATED, please use the .em-graticule CSS class'), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-graticule','stroke-width',v), out);
    out.nutsrgSelFillSty = (v) => (console.warn('nutsrgSelFillSty() is now DEPRECATED, please use hoverColor() instead'), out.hoverColor_ = v, out);
    out.titleFontSize = (v) => (console.warn('map.titleFontSize() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','font-size',v), out);
    out.subtitleFontSize = (v) => (console.warn('map.subtitleFontSize() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-size',v), out);
    out.subtitleFontWeight = (v) => (console.warn('map.subtitleFontWeight() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','font-weight',v), out);
    out.titleFill = (v) => (console.warn('map.titleFill() is now DEPRECATED. please use the .em-title CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-title','fill',v), out);
    out.subtitleFill = (v) => (console.warn('map.subtitleFill() is now DEPRECATED. please use the .em-subtitle CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-subtitle','fill',v), out);
    out.cntbnStroke = (v) => {
        console.warn('cntbnStroke() is now DEPRECATED, please use the .em-cntbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v['co'])
        }
        return out
    };
    out.cntbnStrokeWidth = (v) => {
        console.warn('cntbnStrokeWidth() is now DEPRECATED, please use the .em-cntbn .em-worldbn .em-bn-eu .em-bn-efta .em-bn-cc .em-bn-oth CSS classes')
        if (v['eu']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-eu','stroke-width',v['eu'])
        }
        if (v['efta']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-efta','stroke-width',v['efta'])
        }
        if (v['cc']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-cc','stroke-width',v['cc'])
        }
        if (v['oth']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-oth','stroke-width',v['oth'])
        }
        if (v['co']) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v['co'])
        }
        return out
    };
    out.worldStroke = (v) => (console.warn('map.worldStroke() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke',v), out);
    out.worldStrokeWidth = (v) => (console.warn('map.worldStrokeWidth() is now DEPRECATED. please use the .em-worldbn .em-bn-co .em-bn-d CSS classes'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldbn','stroke-width',v), out);
    out.worldCoastStroke = (v) => (console.warn('map.worldCoastStroke() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke',v), out);
    out.worldCoastStrokeWidth = (v) => (console.warn('map.worldCoastStrokeWidth() is now DEPRECATED. please use the .em-bn-co CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-bn-co','stroke-width',v), out);
    out.worldFillStyle = (v) => (console.warn('map.worldFillStyle() is now DEPRECATED. please use the .em-worldrg CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-worldrg','fill',v), out); 
    out.coastalMarginWidth = (v) => (console.warn('map.coastalMarginWidth() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke-width',v), out);  
    out.coastalMarginColor = (v) => (console.warn('map.coastalMarginColor() is now DEPRECATED. please use the #em-coast-margin CSS rule'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('#em-coast-margin','stroke',v), out);
    out.fontFamily = (v) => (console.warn('map.fontFamily() is now DEPRECATED. please use the .em-map CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-map','font-family',v), out);
    out.botTxtFontSize = (v) => (console.warn('map.botTxtFontSize() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','font-size',v), out);
    out.botTxtFill = (v) => (console.warn('map.botTxtFill() is now DEPRECATED. please use the .em-footnote CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-footnote','fill',v), out);
    out.scalebarFontSize = (v) => (console.warn('map.scalebarFontSize() is now DEPRECATED. please use the .em-scalebar-label CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-scalebar-label','font-size',v), out);
    out.frameStroke = (v)=> (console.warn('map.frameStroke() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke',v), out);
    out.frameStrokeWidth = (v)=> (console.warn('map.frameStrokeWidth() is now DEPRECATED. please use the .em-frame CSS class'),(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateCSSRule)('.em-frame','stroke-width',v), out);

   //other
    out.psClassifMethod = (v) => (console.warn('psClassifMethod() is now DEPRECATED. please use psClassificationMethod instead'),out.psClassificationMethod_ = v, out);
    out.geoCenter = (v) => (console.warn('map.geoCenter() is now deprecated. Please use map.position({x,y,z}) instead.'), out.position_.x = v[0], out.position_.y = v[1], out);
    out.pixelSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.pixSize = (v) => (console.warn('map.pixelSize() is now deprecated. Please use the z property in map.position({x,y,z}) instead.'), out.position_.z = v, out);
    out.tooltipText = (v) => (console.warn('map.tooltipText() is now deprecated. Please use map.tooltip(config.textFunction) instead. See API reference for details.'), out.tooltip_.textFunction = v, out);
    out.classifMethod = (v) => (console.warn('map.classifMethod() is now DEPRECATED. please use map.classificationMethod() instead.'), out.classificationMethod_ = v,out);
    out.threshold = (v) => (console.warn('map.threshold() is now DEPRECATED. please use map.thresholds() instead.'), out.thresholds_ = v,out);
    out.psThreshold = (v) => (console.warn('map.psThreshold() is now DEPRECATED. please use map.psThresholds() instead.'), out.psThresholds_ = v,out);
    out.clnb = (v) => (console.warn('map.clnb() is now DEPRECATED. please use map.numberOfClasses() instead.'), out.numberOfClasses_ = v,out);
    out.nutsLvl = (v) => (console.warn('map.nutsLvl() is now DEPRECATED. please use map.nutsLevel() instead.'), out.nutsLevel_ = v,out);
    out.lg = (v) => (console.warn('map.lg() is now DEPRECATED. please use map.language() instead.'), out.language_ = v,out);
    out.bottomText = (v) => (console.warn('bottomText is now DEPRECATED. Please use the footnote() method and em-footnote CSS class instead.'),out.footnote_ = v,out);
    out.botTxtFontSize = (v) => (console.warn('botTxtFontSize is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtFill = (v) => (console.warn('botTxtFill is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtPadding = (v) => (console.warn('botTxtPadding is now DEPRECATED. Please use the em-footnote CSS class instead.'),out);
    out.botTxtTooltipTxt = (v) => (console.warn('botTxtTooltipTxt is now DEPRECATED. Please use footnoteTooltipText() instead.'),out);
    out.tooltipShowFlags = (v) =>(console.warn('tooltipShowFlags is now DEPRECATED. Please use out.tooltip({showFlags}) instead.'),out.tooltip_.showFlags = v,out);
    out.colorFun = (v) =>(console.warn('colorFun is now DEPRECATED. Please use out.colorFunction() instead.'),out.colorFunction_ = v,out);
    out.filtersDefinitionFun = (v)=>(console.warn('filtersDefinitionFun is now DEPRECATED. Please use out.filtersDefinitionFunction() instead.'),out.filtersDefinitionFunction_ = v,out);
    
    //labelling
    out.labelling = (v) =>(console.warn('labelling is now DEPRECATED. Please use out.labels({}) configuration object instead. See documentation for details.'),out);
    out.labelsConfig = (v) =>(console.warn('labelsConfig is now DEPRECATED. Please use out.labels({config:yourConfig}) configuration object instead. See documentation for details.'),out.labels_ =Object.assign(out.labels_ || {}, { config: v }),out);
    out.statLabelsPositions = (v) =>(console.warn('statLabelsPositions is now DEPRECATED. Please use out.labels({statLabelsPositions:yourPositions}) instead. See documentation for details.'),out.labels_ = Object.assign(out.labels_ || {}, { statLabelsPositions: v }),out);
    out.labelsToShow = (v) =>(console.warn('labelsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadowsToShow = (v) =>(console.warn('labelShadowsToShow is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) function instead. See documentation for details.'),out);
    out.labelShadow = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelShadowWidth = (v) =>(console.warn('labelShadow is now DEPRECATED. Please use out.labels({labelShadow:boolean}) instead. See documentation for details.'),out);
    out.labelFilterFunction =(v) =>(console.warn('labelFilterFunction is now DEPRECATED. Please use out.labels({labelFilterFunction:yourFunction(region,map)}) instead. See documentation for details.'),out);
    out.labelFill = (v) => (console.warn('map.labelFill() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStroke = (v) => (console.warn('map.labelStroke() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelStrokeWidth = (v) => (console.warn('map.labelStrokeWidth() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelOpacity = (v) => (console.warn('map.labelOpacity() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelValuesFontSize = (v) => (console.warn('map.labelValuesFontSize() is now DEPRECATED. please use the .em-stat-labels CSS class'), out);
    out.labelShadowWidth = (v) => (console.warn('map.labelShadowWidth() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);
    out.labelShadowColor = (v) => (console.warn('map.labelShadowColor() is now DEPRECATED. please use the .em-stat-labels-shadows CSS class'), out);

    out.countriesToShow = (v) => (console.warn('map.countriesToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
    out.bordersToShow = (v) => (console.warn('map.bordersToShow() is now DEPRECATED. please use the map.filterGeometriesFunction() function if you wish to filter the default geometries.'), out);
}


/***/ }),

/***/ "./src/core/geometries.js":
/*!********************************!*\
  !*** ./src/core/geometries.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Geometries: () => (/* binding */ Geometries)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _kosovo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kosovo */ "./src/core/kosovo.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/graticule.js");
// takes care of the map's geometries






// Geometries class wrapped as a function
const Geometries = function (map, withCenterPoints) {
    let out = {}

    // defaults
    out.defaultGeoData = undefined
    out.allNUTSGeoData = undefined
    out.geoJSONs = {
        mixed: { rg0: undefined, rg1: undefined, rg2: undefined, rg3: undefined },
        cntbn: undefined,
        cntrg: undefined,
        nutsbn: undefined,
        nutsrg: undefined,
        gra: undefined,
        worldrg: undefined,
        worldbn: undefined,
        kosovo: undefined,
    }

    // user defined geometries (layers)
    out.userGeometries = undefined

    // user defined statistical regions
    out.statisticalRegions = undefined

    //centroids for prop symbols etc
    out.centroidsData = undefined //raw
    out.centroidsFeatures = undefined //geojson features

    // get geojson features of all statistical regions
    out.getRegionFeatures = function () {
        if (map.geo_ == 'WORLD') {
            return out.geoJSONs.worldrg
        } else {
            if (map.nutsLevel_ === 'mixed') {
                return [out.geoJSONs.mixed.rg0, out.geoJSONs.mixed.rg1, out.geoJSONs.mixed.rg2, out.geoJSONs.mixed.rg3]
            } else {
                return out.geoJSONs.nutsrg.concat(out.geoJSONs.cntrg)
            }
        }
    }

    /**
     * Retrieves and parses 'default' geo data (for NUTS or World maps)
     */
    out.getDefaultGeoData = function (geo, filterGeometriesFunction, nutsLevel) {
        const promises = out.getDefaultGeoDataPromise()
        return Promise.all(promises)
            .then((results) => {
                if (filterGeometriesFunction) {
                    results = filterGeometriesFunction(results)
                }
                out.allNUTSGeoData = results
                out.defaultGeoData = results[0]

                if (withCenterPoints) {
                    out.centroidsData = nutsLevel === 'mixed' ? [results[4], results[5], results[6], results[7]] : results[1]
                }

                const isWorld = geo === 'WORLD'
                // Decode TopoJSON to GeoJSON
                if (isWorld) {
                    out.geoJSONs.worldrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_RG_20M_2020_4326).features
                    out.geoJSONs.worldbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.CNTR_BN_20M_2020_4326).features
                    out.geoJSONs.kosovo = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.NUTS_BN_20M_2021_RS_XK_border).features
                    out.geoJSONs.graticule = [(0,d3_geo__WEBPACK_IMPORTED_MODULE_3__["default"])().step([30, 30])()]
                } else {
                    out.geoJSONs.graticule = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.gra).features
                    out.geoJSONs.nutsrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsrg).features
                    out.geoJSONs.nutsbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.nutsbn).features
                    out.geoJSONs.cntrg = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntrg).features
                    out.geoJSONs.cntbn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.defaultGeoData, out.defaultGeoData.objects.cntbn).features
                }

                return results
            })
            .catch((err) => {
                return Promise.reject(err)
            })
    }

    /**
     * Returns an array of promises for Nuts2JSON topojson data.
     */
    out.getDefaultGeoDataPromise = function () {
        const nutsLevels = [0, 1, 2, 3]
        const promises = []

        const buildUrl = (base, year, geo, proj, scale, level, withCenter = false) => {
            let path = `${base}/${year}`

            // Include geo part if it's specified and not 'EUR' or 'WORLD'
            if (geo && geo !== 'EUR' && geo !== 'WORLD') path += `/${geo}`

            // Add projection
            path += `/${geo == 'WORLD' ? '4326' : proj}` // world geodata is always 4326, then reprojected

            // Add scale only if not using center points
            if (!withCenter && scale) path += `/${scale}`

            // Append the appropriate file name
            path += `/${withCenter ? 'nutspt_' : ''}${level}.json`

            return path
        }

        if (map.nutsLevel_ === 'mixed' && map.geo_ !== 'WORLD') {
            nutsLevels.forEach((lvl) => promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl))))
            if (withCenterPoints) {
                nutsLevels.forEach((lvl) =>
                    promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, lvl, true)))
                )
            }
        } else if (map.geo_ === 'WORLD') {
            const worldMapTopojsonURL = window.location.hostname.includes('ec.europa.eu')
                ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/IMAGE/WORLD_4326.json'
                : 'https://raw.githubusercontent.com/eurostat/eurostat-map/master/src/assets/topojson/WORLD_4326.json'
            promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(worldMapTopojsonURL))
        } else {
            promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_)))
            if (withCenterPoints) {
                promises.push((0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(buildUrl(map.nuts2jsonBaseURL_, map.nutsYear_, map.geo_, map.proj_, map.scale_, map.nutsLevel_, true)))
            }
        }

        return promises
    }
    /** Checks if all geo data is ready */
    out.isGeoReady = function () {
        if (!out.defaultGeoData && !out.userGeometries) return false

        let allReady = true

        ;(0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(map.insetTemplates_, null, (inset) => {
            if (!inset.Geometries.isGeoReady()) {
                allReady = false
            }
        })

        return allReady
    }

    out.setUserGeometries = function (geometries) {
        this.userGeometries = geometries

        // get regions that are linked to the statistics
        geometries.forEach((geometry) => {
            if (geometry.statisticalRegions) {
                this.statisticalRegions = geometry
            }
        })
    }

    out.addDefaultGeometriesToMap = function (container, drawGraticule, pathFunction, nutsLevel, nutsYear, geo, proj, scale) {
        if (this.geoJSONs.graticule && drawGraticule) {
            //draw graticule
            container
                .append('g')
                .attr('id', 'em-graticule')
                .attr('class', 'em-graticule')
                .selectAll('path')
                .data(this.geoJSONs.graticule)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw country regions
        if (this.geoJSONs.cntrg) {
            container
                .append('g')
                .attr('id', 'em-cntrg')
                .attr('class', 'em-cntrg')
                .selectAll('path')
                .data(this.geoJSONs.cntrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
                .attr('id', (cntrg) => {
                    // add ids for RS and EL so that we can choose not to add statistical data to them.
                    const id = cntrg.properties.id
                    if (id == 'RS' || id == 'EL') {
                        return 'em-cntrg-' + id
                    }
                })
        }

        //draw world map
        if (this.geoJSONs.worldrg) {
            container
                .append('g')
                .attr('id', 'em-worldrg')
                .attr('class', 'em-worldrg')
                .selectAll('path')
                .data(this.geoJSONs.worldrg)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }

        //draw NUTS regions
        if (this.geoJSONs.nutsrg) {
            if (nutsLevel == 'mixed') {
                this.geoJSONs.mixed.rg0 = this.geoJSONs.nutsrg
                this.geoJSONs.mixed.rg1 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[1], out.allNUTSGeoData[1].objects.nutsrg).features
                this.geoJSONs.mixed.rg2 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[2], out.allNUTSGeoData[2].objects.nutsrg).features
                this.geoJSONs.mixed.rg3 = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(out.allNUTSGeoData[3], out.allNUTSGeoData[3].objects.nutsrg).features

                //for mixed NUTS, we add every NUTS region across all levels and hide level 1,2,3 by default, only showing them when they have stat data
                // see updateClassification and updateStyle in map-choropleth.js for hiding/showing
                ;[this.geoJSONs.mixed.rg0, this.geoJSONs.mixed.rg1, this.geoJSONs.mixed.rg2, this.geoJSONs.mixed.rg3].forEach((r, i) => {
                    //append each nuts level to map
                    container
                        .append('g')
                        .attr('id', 'em-nutsrg')
                        .attr('class', `em-nutsrg em-nutsrg-${i}`)
                        .selectAll('path')
                        .data(r)
                        .enter()
                        .append('path')
                        .attr('d', pathFunction)
                        .attr('lvl', i) //to be able to distinguish nuts levels
                })

                //add kosovo
                if (geo == 'EUR' && (proj == '3035' || proj == '4326')) {
                    // add kosovo manually
                    addKosovoBorder(container, pathFunction, proj, scale, nutsYear)
                }
            } else {
                // when nutsLevel is not 'mixed'
                container
                    .append('g')
                    .attr('id', 'em-nutsrg')
                    .attr('class', 'em-nutsrg')
                    .selectAll('path')
                    .data(this.geoJSONs.nutsrg)
                    .enter()
                    .append('path')
                    .attr('d', pathFunction)
            }
        }

        //draw country boundaries
        if (this.geoJSONs.cntbn) {
            container
                .append('g')
                .attr('id', 'em-cntbn')
                .attr('class', 'em-cntbn')
                .selectAll('path')
                .data(this.geoJSONs.cntbn)
                .enter()
                .append('path')
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .attr('d', pathFunction)
                .attr('id', (bn) => 'em-bn-' + bn.properties.id)
                .attr('class', function (bn) {
                    let classList = []

                    if (bn.properties.eu === 'T') classList.push('em-bn-eu')
                    if (bn.properties.efta === 'T') classList.push('em-bn-efta')
                    if (bn.properties.cc === 'T') classList.push('em-bn-cc')
                    if (bn.properties.oth === 'T') classList.push('em-bn-oth')
                    if (bn.properties.co === 'T') classList.push('em-bn-co')

                    return classList.join(' ') // Use join with a space to create a valid class string
                })
        }

        //draw NUTS boundaries
        if (this.geoJSONs.nutsbn && nutsLevel !== 'mixed') {
            this.geoJSONs.nutsbn.sort(function (bn1, bn2) {
                return bn2.properties.lvl - bn1.properties.lvl
            })
            container
                .append('g')
                .attr('id', 'em-nutsbn')
                .attr('class', 'em-nutsbn')
                .selectAll('path')
                .data(this.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    if (bn.properties.eu == 'T') return bn
                    if (bn.properties.efta == 'T') return bn
                    if (bn.properties.cc == 'T') return bn
                    if (bn.properties.oth == 'T') return bn
                    if (bn.properties.co == 'T') return bn
                })
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    let props = bn.properties
                    //KOSOVO
                    if (props.id > 100000) {
                        return 'em-kosovo-bn'
                    }
                    if (props.co === 'T') return 'em-bn-co'
                    const cl = ['em-bn-' + props.lvl]
                    //if (bn.oth === "T") cl.push("bn-oth");
                    return cl.join(' ')
                })
        }

        //draw world boundaries
        if (this.geoJSONs.worldbn) {
            container
                .append('g')
                .attr('id', 'em-worldbn')
                .attr('class', 'em-worldbn')
                .selectAll('path')
                .data(this.geoJSONs.worldbn)
                .enter()
                .append('path')
                .attr('d', pathFunction)
                .attr('class', function (bn) {
                    if (bn.properties.POL_STAT > 0) {
                        //disputed
                        return 'em-bn-d'
                    }
                    return bn.properties.COAS_FLAG === 'T' ? 'em-bn-co' : 'em-worldbn'
                })
            //.attr("id", (bn) => bn.properties.CNTR_BN_ID)
        }

        if (this.geoJSONs.kosovo) {
            //add kosovo to world maps
            container
                .append('g')
                .attr('id', 'em-kosovo-bn')
                .attr('class', 'em-kosovo-bn')
                .selectAll('path')
                .data(this.geoJSONs.kosovo)
                .enter()
                .append('path')
                .attr('d', pathFunction)
        }
    }

    function addKosovoBorder(container, pathFunction, proj, scale, nutsYear) {
        let kosovoFeature = _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear] ? _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[nutsYear][proj][scale] : _kosovo__WEBPACK_IMPORTED_MODULE_2__.kosovoBnFeatures[2024][proj][scale]
        let kosovoBn = (0,topojson_client__WEBPACK_IMPORTED_MODULE_0__.feature)(kosovoFeature, 'nutsbn_1').features
        container
            .append('g')
            .attr('id', 'em-kosovo-bn')
            .attr('class', 'em-kosovo-bn em-bn-cc')
            .selectAll('path')
            .data(kosovoBn)
            .enter()
            .append('path')
            .attr('d', pathFunction)
    }

    /**
     * @description Adds user-defined geometries to the map
     * E.g.
     * map.geometries([
     *  { id: 'regions', features: geoJSON.features, class: (feature) => 'region' },
     *  { id: 'borders', features: bordersData, class: (feature) => 'border' }
     * ])
     * @param geometries array of objects, each containing an array of geoJSON features
     * @param container d3 selection of the parent that we append the geometries to
     * @param pathFunction d3 path function
     */
    out.addUserGeometriesToMap = function (geometries, container, pathFunction) {
        geometries.forEach((geometry) => {
            let group = container
                .append('g')
                .attr('id', geometry.statisticalRegions ? 'em-user-regions' : '')
                .attr('class', geometry.class ? geometry.class : '')

            let elements = group.selectAll('path').data(geometry.features).enter().append('path').attr('d', pathFunction)

            // Allow custom call chain modifications through onEach
            if (typeof geometry.onEach === 'function') {
                geometry.onEach(elements)
            }
        })
    }

    return out
}


/***/ }),

/***/ "./src/core/insets.js":
/*!****************************!*\
  !*** ./src/core/insets.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildInsets: () => (/* binding */ buildInsets),
/* harmony export */   removeInsets: () => (/* binding */ removeInsets)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");



/**
 * Build inset maps for a map template
 */
const buildInsets = function (out, withCenterPoints) {
    if (!out.insetBoxPosition_) {
        out.insetBoxPosition_ = [out.width_ - out.insetBoxWidth_ - 2 * out.insetBoxPadding_, 2 * out.insetBoxPadding_]
    }

    // add container to drawing group
    // Cannot read properties of undefined (reading 'svgId')
    let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId_)
    let drawingGroup = svg.select('#em-drawing-' + out.svgId_)
    const ing = drawingGroup
        .append('g')
        .attr('id', 'em-insets-group')
        .attr('class', 'em-insets')
        .attr('transform', 'translate(' + out.insetBoxPosition_[0] + ',' + out.insetBoxPosition_[1] + ')')

    if (out.insets_ === 'default') {
        //if needed, use default inset config
        out.insets_ = defaultInsetConfig(out.insetBoxWidth_, out.insetBoxPadding_)
    }

    // append each inset to map
    for (let i = 0; i < out.insets_.length; i++) {
        const config = out.insets_[i]
        config.svgId = config.svgId || 'inset' + config.geo + Math.random().toString(36).substring(7)

        //get svg element.
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + config.svgId)
        if (svg.size() == 0) {
            // Create it as an embeded SVG if it does not exist
            const x = config.x == undefined ? out.insetBoxPadding_ : config.x
            const y = config.y == undefined ? out.insetBoxPadding_ + i * (out.insetBoxPadding_ + out.insetBoxWidth_) : config.y
            const ggeo = ing
                .append('g')
                .attr('id', 'em-inset-' + config.svgId)
                .attr('class', 'em-inset')
                .attr('transform', 'translate(' + x + ',' + y + ')')
            ggeo.append('svg').attr('id', config.svgId)
        }

        // build inset
        // GISCO-2676 - PT azores inset has 2 insets with the same Geo, so second was overriding first:
        if (out.insetTemplates_[config.geo]) {
            //if inset already exists in map with same geo, then push both to an array
            let inset = buildInset(config, out, withCenterPoints)
            inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = [out.insetTemplates_[config.geo], inset]
        } else {
            let inset = buildInset(config, out, withCenterPoints)
            let drawnInset = inset.buildMapTemplateBase()
            out.insetTemplates_[config.geo] = drawnInset
        }
    }

    return out
}

/** Build template for inset, based on main one */
const buildInset = function (config, out, withCenterPoints) {
    //TODO find a better way to do that

    //copy map
    //for(let key__ in map) {
    //mt[key__] = map[key__];
    //}

    const mt = (0,_map_template__WEBPACK_IMPORTED_MODULE_0__.mapTemplate)(config, withCenterPoints)

    //define default values for inset configs
    config = config || {}
    config.proj = config.proj || _defaultCRS[config.geo]
    config.scale = config.scale || out.insetScale_
    config.footnote = config.footnote || ''
    config.showSourceLink = config.showSourceLink || false
    config.zoomExtent = config.zoomExtent || out.insetZoomExtent_
    config.width = config.width || out.insetBoxWidth_
    config.height = config.height || out.insetBoxWidth_
    config.insets = config.insets || []
    config.insetTemplates = config.insetTemplates || {}
    config.callback = config.callback || undefined

    //copy main map attributes
    ;[
        'nutsLevel_',
        'nutsYear_',
        'hoverColor_',
        //'nutsbnStroke_', // DEPRECATED
        // 'nutsbnStrokeWidth_', // DEPRECATED
        'cntrgFillStyle_', // DEPRECATED
        'cntbnStroke_', // DEPRECATED
        'cntbnStrokeWidth_', // DEPRECATED
        'seaFillStyle_', // DEPRECATED
        'drawCoastalMargin_',
        'coastalMarginColor_', // DEPRECATED
        'coastalMarginWidth_', // DEPRECATED
        'coastalMarginStdDev_',
        'graticuleStroke_', // DEPRECATED
        'graticuleStrokeWidth_', // DEPRECATED
        'lg_',
        'projectionFunction_',
        'filterGeometriesFunction_',
        'processCentroids_',
    ].forEach(function (att) {
        mt[att] = out[att]
    })

    //copy stat map attributes/methods
    ;['stat', 'statData', 'legend', 'legendObj', 'noDataText', 'language', 'transitionDuration', 'tooltip_', 'classToText_'].forEach(function (att) {
        mt[att] = out[att]
    })

    //apply config values for inset
    for (let key in config) mt[key + '_'] = config[key]

    mt.isInset = true // flag for inset-specific settings e.g. CSS class for titles
    return mt
}

/**
 * Remove insets maps from the DOM
 */
const removeInsets = function (out) {
    if (out.insetTemplates_) {
        for (let template in out.insetTemplates_) {
            let id = out.insetTemplates_[template].svgId_
            let existing = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + id)
            // if (existing) existing.remove()
            if (existing) existing.html('') // empty them, but dont remove them.
        }
        out.insetTemplates_ = {} //  GISCO-2676
    }
}

/**
 * Default inset setting.
 * @param {*} s The width of the inset box
 * @param {*} p The padding
 */
const defaultInsetConfig = function (s, p) {
    const out = [
        { geo: 'IC', x: 0, y: 0, width: s, height: 0.3 * s },
        { geo: 'CARIB', x: 0, y: 0.3 * s + p, width: 0.5 * s, height: s },
        { geo: 'GF', x: 0.5 * s, y: 0.3 * s + p, width: 0.5 * s, height: 0.75 * s },
        {
            geo: 'YT',
            x: 0.5 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'RE',
            x: 0.75 * s,
            y: 1.05 * s + p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT20',
            x: 0,
            y: 1.3 * s + 2 * p,
            width: 0.75 * s,
            height: 0.25 * s,
        },
        {
            geo: 'PT30',
            x: 0.75 * s,
            y: 1.3 * s + 2 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        { geo: 'MT', x: 0, y: 1.55 * s + 3 * p, width: 0.25 * s, height: 0.25 * s },
        {
            geo: 'LI',
            x: 0.25 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_SV',
            x: 0.5 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        {
            geo: 'SJ_JM',
            x: 0.75 * s,
            y: 1.55 * s + 3 * p,
            width: 0.25 * s,
            height: 0.25 * s,
        },
        /*{geo:"IC", x:0, y:0}, {geo:"RE", x:dd, y:0}, {geo:"YT", x:2*dd, y:0},
		{geo:"GP", x:0, y:dd}, {geo:"MQ", x:dd, y:dd}, {geo:"GF",scale:"10M", x:2*dd, y:dd},
		{geo:"PT20", x:0, y:2*dd}, {geo:"PT30", x:dd, y:2*dd}, {geo:"MT", x:2*dd, y:2*dd},
		{geo:"LI",scale:"01M", x:0, y:3*dd}, {geo:"SJ_SV", x:dd, y:3*dd}, {geo:"SJ_JM",scale:"01M", x:2*dd, y:3*dd},*/
        //{geo:"CARIB", x:0, y:330}, {geo:"IS", x:dd, y:330}
    ]
    //hide graticule for insets
    for (let i = 0; i < out.length; i++) out[i].drawGraticule = false
    return out
}

/** Default CRS for each geo area */
const _defaultCRS = {
    EUR: '3035',
    IC: '32628',
    GP: '32620',
    MQ: '32620',
    GF: '32622',
    RE: '32740',
    YT: '32738',
    MT: '3035',
    PT20: '32626',
    PT30: '32628',
    LI: '3035',
    IS: '3035',
    SJ_SV: '3035',
    SJ_JM: '3035',
    CARIB: '32620',
    WORLD: '54030',
}


/***/ }),

/***/ "./src/core/kosovo.js":
/*!****************************!*\
  !*** ./src/core/kosovo.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   kosovoBnFeatures: () => (/* binding */ kosovoBnFeatures)
/* harmony export */ });
// mixed nuts dont draw nutsbn so we add them manually
const kosovoBnFeatures = {
  2021:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[3061,1303],[-152,-59],[-32,-66],[-65,72],[-96,7],[-16,59],[-64,19],[-56,-39],[-120,39],[-184,-19],[-16,26],[32,52],[-16,72],[24,40],[8,183]],[[2885,0],[-8,46],[-65,85],[-40,-7],[-40,40],[0,111],[80,13],[25,46],[72,13],[40,98],[-56,118],[144,196],[-24,79],[88,59],[-24,98],[-8,20],[24,39],[8,52],[48,72],[-88,125]],[[825,2638],[-112,-98],[-72,-7],[-88,-118],[-176,-39],[56,-91],[88,-33],[24,-53],[56,-39],[24,-91],[-56,-46],[24,-105],[-56,-92],[-104,0],[-48,-104],[-16,-40],[-57,7],[-40,-53],[-16,-78],[113,-118],[-97,-65],[-88,-99],[-80,20],[-80,-39],[-24,-13]],[[1098,2304],[-193,66],[24,39],[-16,39],[65,13],[0,33],[-65,79],[-88,65]],[[2308,1689],[-153,-20],[-64,59],[-40,7],[-96,-27],[-104,138],[-8,92],[-32,78],[-64,26],[-32,-59],[-24,0],[-56,86],[-40,137],[-25,65],[-56,0],[-56,46],[-64,-72],[-120,53],[-88,-40],[-88,46]]],"transform":{"scale":[37.761044752777565,38.54734205626113],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[962,0],[-29,75],[48,131],[21,35],[11,38],[32,117],[-24,44]],[[1021,440],[-64,-29],[-70,36],[-120,2],[3,121]],[[770,570],[-126,16],[-40,91],[-45,4],[-51,93],[-142,4]],[[275,891],[-131,-99],[30,-36],[24,-31],[-6,-86],[-98,-86],[13,-64],[-27,-38],[-80,-31]],[[366,778],[-37,22],[-54,91]]],"transform":{"scale":[113.2099448513097,114.12782081303801],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[536,0],[-24,45],[15,30],[45,92],[-1,44],[-2,37]],[[569,248],[-130,9],[-10,64]],[[429,321],[-64,10],[-78,94],[-83,13]],[[153,502],[-73,-51],[26,-84],[-48,-53],[-3,-52],[-55,-25]],[[204,438],[-51,64]]],"transform":{"scale":[203.12309601494124,202.56551463031246],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[310,138],[-36,-2],[-40,42]],[[234,178],[-123,65]],[[84,278],[-84,-147]],[[111,243],[-27,35]],[[292,0],[18,138]]],"transform":{"scale":[372.84281730215633,364.87611898580536],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":1000004,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":1000003,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":1000001,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":1000002,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":1000005,"lvl":1,"eu":"F","efta":"F","cc":"T","oth":"T","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1900,1275],[-30,27],[-27,-13],[-34,23],[-87,6],[25,59],[1,70],[20,34],[24,167]],[[1792,1648],[-116,1],[-62,77],[-89,-8],[-60,148],[7,86],[-4,15],[-13,60],[-45,28],[-33,-48],[-26,4],[-31,142],[-11,53],[5,43],[-19,44],[-39,8],[-40,49],[-52,-59],[-93,71],[-38,-6],[-16,-26]],[[945,2388],[-54,27],[-20,28],[-22,-3],[-17,22],[-25,1],[-10,10],[4,17],[27,14],[-15,29],[1,16],[68,1],[-8,16],[-5,30],[-14,29],[-27,42],[-25,22],[-30,41]],[[773,2730],[-89,-69],[-64,-4],[-82,-92],[-133,-15],[27,-93],[64,-43],[16,-50],[38,-44],[9,-75],[-48,-51],[5,-41],[6,-50],[-52,-84],[-78,14],[-35,-66],[-33,-61],[-45,11],[-35,-42],[-18,-72],[33,-71],[48,-55]],[[1017,2330],[-72,58]],[[307,1677],[-36,-12],[-25,-21],[-26,-10],[-76,-90],[-17,4],[-30,31],[-52,-14],[-26,-23],[-19,1]],[[2319,1185],[-116,-32],[-39,-52],[-42,70],[-68,23],[-12,58],[-43,23],[-42,-23],[-57,23]],[[2044,0],[-4,43],[-38,82],[-34,9],[-24,43],[13,97],[61,4],[32,41],[49,0],[37,82],[-26,118],[130,167],[-8,73],[74,46],[-2,18],[-9,92],[24,35],[7,49],[48,52],[-55,134]]],"transform":{"scale":[0.0006038339283908974,0.00036983475567765975],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '10M':{"type":"Topology","arcs":[[[659,439],[-54,17],[17,111]],[[622,567],[-93,31],[-25,92],[-36,11],[-29,97],[-23,1],[-63,3]],[[328,822],[-33,74],[-27,44]],[[268,940],[-72,-44],[-38,-31],[27,-86],[-14,-65],[-81,-78],[16,-58]],[[353,802],[-25,20]],[[106,578],[-41,-19],[-65,-28]],[[805,408],[-54,-21],[-92,52]],[[709,0],[-22,72],[0,17],[40,36],[18,67],[53,101],[16,64],[-9,51]]],"transform":{"scale":[0.001740521547911524,0.0010740945563829907],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '20M':{"type":"Topology","arcs":[[[380,252],[-21,26],[0,48]],[[359,326],[-49,17],[-56,107],[-51,11]],[[189,472],[-34,68]],[[155,540],[-66,-39],[18,-66],[-54,-68],[8,-35]],[[61,332],[-21,-13],[-10,-12],[-13,5],[-17,-7]],[[464,234],[-84,18]],[[409,0],[-14,46],[61,110],[8,78]]],"transform":{"scale":[0.003018276831896498,0.0018697201537037245],"translate":[20.35292839300007,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}},
      '60M':{"type":"Topology","arcs":[[[235,156],[-13,46]],[[222,202],[-96,84]],[[117,293],[-21,42]],[[96,335],[-58,-129]],[[126,286],[-9,7]],[[38,206],[-38,-17]],[[287,145],[-52,11]],[[253,0],[34,145]]],"transform":{"scale":[0.004879722822299564,0.0030138772626866006],"translate":[20.352928393000074,42.26281764300006]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000002,"co":"F","oth":"F",}},{"type":"LineString","arcs":[1],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000003,"co":"F","oth":"F",}},{"type":"LineString","arcs":[2],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000004,"co":"F","oth":"F",}},{"type":"LineString","arcs":[3],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000005,"co":"F","oth":"F",}},{"type":"LineString","arcs":[4],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000006,"co":"F","oth":"F",}},{"type":"LineString","arcs":[5],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000001,"co":"F","oth":"F",}},{"type":"LineString","arcs":[6],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000007,"co":"F","oth":"F",}},{"type":"LineString","arcs":[7],"properties":{"eu":"F","efta":"F","cc":"T","lvl":0,"id":1000008,"co":"F","oth":"F",}}]}}}
    }
  },
  2024:{
    3035: {
      '03M':{"type":"Topology","arcs":[[[728,1508],[-48,12],[-22,18],[-15,-5],[-16,13],[-22,-4],[-10,8],[0,13],[21,13],[-16,17],[0,13],[58,9],[-5,8],[-10,22],[-16,17],[-27,25],[-21,13],[-32,26]],[[1912,0],[-6,30],[-42,51],[-32,0],[-21,30],[0,69],[53,8],[21,35],[43,4],[26,60],[-37,81],[96,129],[-16,51],[58,43],[0,9],[-21,64],[16,26],[5,34],[32,43],[-58,85]],[[250,942],[-27,-13],[-21,-17],[-21,-8],[-59,-73],[-16,0],[-26,17],[-43,-13],[-21,-21],[-16,0]],[[1657,861],[-27,13],[-21,-13],[-32,13],[-74,-9],[16,47],[-6,47],[11,26],[5,120]],[[1529,1105],[-100,-17],[-64,47],[-75,-17],[-63,94],[-6,60],[-5,13],[-16,38],[-42,13],[-22,-38],[-21,0],[-42,94],[-16,34],[0,30],[-21,30],[-32,0],[-38,30],[-42,-47],[-85,39],[-32,-9],[-10,-21]],[[547,1726],[-69,-60],[-53,-13],[-59,-73],[-111,-25],[32,-60],[58,-22],[16,-34],[37,-26],[16,-51],[-37,-39],[5,-30],[11,-34],[-37,-64],[-64,4],[-26,-51],[-22,-47],[-42,4],[-21,-34],[-11,-52],[37,-47],[43,-30]],[[797,1478],[-69,30]],[[2029,852],[-96,-38],[-32,-39],[-42,43],[-59,4],[-16,39],[-42,13],[-32,-22],[-53,9]]],"transform":{"scale":[56.97629608361119,58.91534666536319],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[242,508],[-33,47],[-27,27]],[[637,0],[-25,46],[-2,12],[30,29],[7,47],[34,75],[7,45],[-12,33]],[[83,318],[-32,-18],[-51,-26]],[[552,290],[-46,5],[3,78]],[[509,373],[-79,8],[-30,59],[-30,3],[-34,62],[-19,-1],[-52,-6]],[[182,582],[-55,-39],[-28,-25],[30,-56],[-5,-45],[-59,-62],[18,-37]],[[265,498],[-23,10]],[[676,287],[-43,-21],[-81,24]]],"transform":{"scale":[171.07449827433382,174.72145763645509],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[50,191],[-17,-11],[-8,-10],[-11,1],[-14,-6]],[[305,224],[-44,6],[-58,68],[-44,2]],[[109,350],[-52,-36],[21,-45],[-38,-54],[10,-24]],[[159,300],[-14,6]],[[145,306],[-36,44]],[[381,0],[-17,31],[41,85],[-1,57]],[[404,173],[-74,2]],[[330,175],[-20,15],[-5,34]]],"transform":{"scale":[286.13294356075795,290.536823841191],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[258,111],[-47,1]],[[32,123],[-32,-17]],[[211,112],[-16,32]],[[195,144],[-94,49]],[[70,225],[-38,-102]],[[101,193],[-8,4]],[[93,197],[-23,28]],[[243,0],[15,111]]],"transform":{"scale":[447.98943164212585,451.9461704196305],"translate":[5167020.037451873,2202278.5103255166]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}}
    },
    4326: {
      '03M':{"type":"Topology","arcs":[[[1543,0],[-4,32],[-28,65],[-24,5],[-19,33],[10,70],[47,5],[23,33],[38,0],[28,59],[-19,92],[94,124],[-5,54],[56,37],[0,11],[-9,70],[19,27],[4,38],[38,38],[-42,102]],[[1750,895],[-85,-27],[-32,-37],[-29,54],[-56,16],[-5,43],[-32,16],[-33,-16],[-43,16]],[[1435,960],[-23,22],[-19,-11],[-28,16],[-66,5],[19,44],[0,54],[14,26],[19,125]],[[230,1262],[-24,-5],[-23,-16],[-19,-11],[-56,-65],[-14,0],[-24,27],[-37,-11],[-19,-21],[-14,5]],[[1351,1241],[-84,0],[-47,59],[-71,-6],[-42,114],[5,64],[-5,11],[-9,43],[-33,22],[-24,-38],[-23,6],[-23,108],[-5,37],[0,33],[-14,32],[-28,5],[-29,38],[-42,-43],[-70,54],[-28,-5],[-10,-22]],[[582,2055],[-66,-49],[-47,-5],[-61,-70],[-103,-11],[19,-70],[51,-32],[10,-38],[28,-32],[9,-54],[-37,-44],[4,-26],[5,-38],[-37,-65],[-61,11],[-29,-49],[-23,-48],[-33,11],[-28,-33],[-14,-54],[28,-54],[33,-43]],[[769,1753],[-56,48]],[[713,1801],[-42,17],[-14,21],[-19,0],[-9,16],[-19,0],[-10,6],[5,16],[19,11],[-9,21],[0,11],[51,0],[-5,11],[-4,22],[-10,26],[-23,27],[-19,22],[-23,27]]],"transform":{"scale":[0.0007994261320208862,0.0004913384355349169],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '10M':{"type":"Topology","arcs":[[[539,0],[-17,52],[0,13],[30,27],[13,48],[41,74],[13,47],[-8,38]],[[611,299],[-41,-16],[-69,37]],[[501,320],[-41,13],[12,81]],[[80,421],[-31,-12],[-49,-20]],[[472,414],[-71,24],[-18,66],[-28,7],[-21,72],[-18,0],[-47,2]],[[203,686],[-54,-32],[-29,-22],[21,-63],[-12,-47],[-60,-57],[11,-44]],[[269,585],[-20,16]],[[249,601],[-25,53],[-21,32]]],"transform":{"scale":[0.002290098349828638,0.0014718665962452685],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '20M':{"type":"Topology","arcs":[[[337,0],[-12,36],[51,84],[6,62]],[[382,182],[-69,13]],[[313,195],[-17,20],[-1,37]],[[50,256],[-17,-10],[-8,-8],[-11,3],[-14,-5]],[[295,252],[-40,13],[-46,82],[-41,9]],[[127,417],[-54,-30],[15,-51],[-44,-53],[6,-27]],[[168,356],[-12,10]],[[156,366],[-29,51]]],"transform":{"scale":[0.0036618323062750017,0.0024213440887871805],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}},
      '60M':{"type":"Topology","arcs":[[[220,0],[29,116]],[[249,116],[-45,8]],[[204,124],[-12,37]],[[192,161],[-83,66]],[[109,227],[-8,6]],[[33,163],[-33,-12]],[[83,266],[-50,-103]],[[101,233],[-18,33]]],"transform":{"scale":[0.005617750767056427,0.003795866485053587],"translate":[20.35361768088405,42.262163108155406]},"objects":{"nutsbn_1":{"type":"GeometryCollection","geometries":[{"type":"LineString","arcs":[0],"properties":{"id":"1000008","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[1],"properties":{"id":"1000007","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[2],"properties":{"id":"1000002","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[3],"properties":{"id":"1000003","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[4],"properties":{"id":"1000006","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[5],"properties":{"id":"1000001","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[6],"properties":{"id":"1000005","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}},{"type":"LineString","arcs":[7],"properties":{"id":"1000004","lvl":0,"eu":"F","efta":"F","cc":"T","oth":"F","co":"F"}}]}}}
    }
  }
}

/***/ }),

/***/ "./src/core/labels.js":
/*!****************************!*\
  !*** ./src/core/labels.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULTLABELS: () => (/* binding */ DEFAULTLABELS),
/* harmony export */   addLabelsToMap: () => (/* binding */ addLabelsToMap),
/* harmony export */   statLabelsTextFunction: () => (/* binding */ statLabelsTextFunction),
/* harmony export */   updateLabels: () => (/* binding */ updateLabels),
/* harmony export */   updateValuesLabels: () => (/* binding */ updateValuesLabels)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");



// handles all map labels e.g. stat values, or labels specified in map.labels({labels:[text:'myLabel', x:123, y: 123]})

/**
 * @function addLabelsToMap
 * @param map eurostatmap map instance
 * @param zg zoomgroup (d3 selection of zoomable elements)
 * @description appends text labels to the map. Labels can be countries, country codes, ocean names or statistical values
 */
const addLabelsToMap = function (map, zg) {
    // set defaults
    if (!map.labels_.config) map.labels_.config = DEFAULTLABELS
    if (!map.labels_.statLabelsPositions) map.labels_.statLabelsPositions = DEFAULTSTATLABELPOSITIONS

    // clear existing or append new container
    let existing = zg.select('#em-labels')
    let labelsContainer = existing.empty() ? zg.append('g').attr('id', 'em-labels') : existing

    //for statistical values on maps without centroids, we need to add centroids initially, then add text to them later once the stat data is loaded
    if (map.labels_?.values && map._mapType !== 'ps') appendStatLabelCentroidsToMap(map, labelsContainer)

    // get labels array
    let labelsArray = map.labels_?.labels || DEFAULTLABELS[`${map.geo}_${map.proj_}.cc`]

    // append other labels to map
    if (labelsArray) {
        //common styles between all label shadows
        const shadowg = labelsContainer.append('g').attr('class', 'em-label-shadows').attr('text-anchor', 'middle')

        //common styles between all labels
        const labelg = labelsContainer.append('g').attr('class', 'em-labels').attr('text-anchor', 'middle')

        //SHADOWS
        if (map.labels_?.shadows) {
            let shadows = shadowg
                .selectAll('text')
                .data(labelsArray)
                .enter()
                .append('text')
                .attr('id', (d) => 'em-label-shadow-' + d.text.replace(/\s+/g, '-'))
                .attr('class', (d) => 'em-label-shadow em-label-shadow-' + d.class)
                .attr('x', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[0]
                })
                .attr('y', function (d) {
                    if (d.rotate) {
                        return 0 //for rotated text, x and y positions must be specified in the transform property
                    }
                    return map._projection([d.x, d.y])[1]
                })
                .attr('dy', -7) // set y position of bottom of text
                .attr('transform', (d) => {
                    if (d.rotate) {
                        let pos = map._projection([d.x, d.y])
                        let x = pos[0]
                        let y = pos[1]
                        return `translate(${x},${y}) rotate(${d.rotate})`
                    } else {
                        return 'rotate(0)'
                    }
                })
                .text(function (d) {
                    return d.text
                }) // define the text to display
        }

        //LABEL texts
        labelg
            .selectAll('text')
            .data(labelsArray)
            .enter()
            .append('text')
            .attr('id', (d) => 'em-label-' + d.text.replace(/\s+/g, '-'))
            .attr('class', (d) => 'em-label em-label-' + d.class)
            //position label
            .attr('x', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[0]
            })
            .attr('y', function (d) {
                if (d.rotate) {
                    return 0 //for rotated text, x and y positions must be specified in the transform property
                }
                return map._projection([d.x, d.y])[1]
            })
            .attr('dy', -7) // set y position of bottom of text
            //transform labels which have a "rotate" property in the labels config. For rotated labels, their X,Y must also be set in the transform.
            // note: dont apply to country code labels
            .attr('transform', (d) => {
                if (d.rotate) {
                    let pos = map._projection([d.x, d.y])
                    let x = pos[0]
                    let y = pos[1]
                    return `translate(${x},${y}) rotate(${d.rotate})`
                } else {
                    return 'rotate(0)'
                }
            })
            .text(function (d) {
                return d.text
            }) // define the text to display
    }
}

/**
 * @function updateLabels
 * @description update existing map labels
 */
const updateLabels = function (map) {
    if (map.svg_) {
        // Clear previous labels
        let prevLabels = map.svg_.selectAll('#em-labels > *')
        if (prevLabels) prevLabels.remove()

        // Main map
        if (map.labels_) {
            const masterConfig = map.labels_
            let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
            addLabelsToMap(map, zg)
            if (masterConfig.values && map.updateValuesLabels) {
                map.updateValuesLabels(map)
            }

            // Define the callback to apply to each inset
            const applyLabelsCallback = (map) => {
                if (masterConfig) {
                    let zg = map.svg_.select('#em-zoom-group-' + map.svgId_)
                    if (map.labels_) addLabelsToMap(map, zg)
                    if (masterConfig.values && map.updateValuesLabels) {
                        map.updateValuesLabels(map)
                    }
                }
            }

            // Apply labels to all insets using the executeForAllInsets function
            if (map.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_0__.executeForAllInsets)(map.insetTemplates_, map.svgId_, applyLabelsCallback)
            }
        }
    }
}

/**
 * @description update the statistical values labels on the map
 * @param {Object} map eurostat-map map instance
 * @return {map} out
 * NOTE: THIS FUNCTION IS NOT CALLED FOR PROPORTIONAL SYMBOL MAPS
 */
const updateValuesLabels = function (map) {
    if (!map) {
        console.warn('No map specified')
        return
    }

    //clear previous labels
    let prevLabels = map.svg_.selectAll('g.em-stat-label > *')
    prevLabels.remove()
    let prevShadows = map.svg_.selectAll('g.em-stat-label-shadow > *')
    prevShadows.remove()
    let statLabels = map.svg_.selectAll('g.em-stat-label')

    // filter stat-label elements to only show those with data
    const filterFunction = map.labels_?.statLabelsFilterFunction ? map.labels_?.statLabelsFilterFunction : defaultStatLabelFilter
    const statData = map.statData()
    statLabels
        .filter((rg) => filterFunction(rg, map))
        // .append('text')
        .each(function (d) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this)
            const labelText = statLabelsTextFunction(d, statData) // Use 'd' directly for the label text

            // Append rectangle behind label
            if (map.labels_.backgrounds) appendRect(labelText, sel)

            // Append text after the rectangle
            sel.append('text').text(labelText).attr('class', 'em-stat-label-text')
        })

    // Function to append a rectangle behind the label
    function appendRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    //add shadows to labels
    if (map.labels_?.shadows) {
        map.svg_
            .selectAll('g.em-stat-label-shadow')
            .filter((rg) => filterFunction(rg, map))
            .append('text')
            .text((d) => statLabelsTextFunction(d, statData)) // Use 'd' directly for the label text)
    }
    return map
}

/**
 * @description text function for statistical labelling
 * @param {Object} d d3 selection json data element
 * @return {string}
 */
const statLabelsTextFunction = (d, statData) => {
    if (statData && statData?.get) {
        const sv = statData.get(d.properties.id)
        if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
            return ''
        } else {
            if (sv.value !== ':') {
                return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.spaceAsThousandSeparator)(sv.value)
            }
        }
    }
}

/**
 * @description function for filtering statistical labels
 * @param {Object} d d3 selection json data element
 * @return {boolean}
 */
const defaultStatLabelFilter = (region, map) => {
    const s = map.statData()
    const sv = s.get(region.properties.id)
    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
        return false
    } else {
        return true
    }
}

const appendStatLabelCentroidsToMap = function (map, labelsContainer) {
    //values label shadows parent <g>
    const gsls = labelsContainer.append('g').attr('class', 'em-stat-labels-shadows').attr('text-anchor', 'middle')

    // values labels parent <g>
    const statLabelsGroup = labelsContainer.append('g').attr('class', 'em-stat-labels').attr('text-anchor', 'middle')

    // our features array
    let statLabelRegions = []

    // deafult geometries
    if (map.Geometries.geoJSONs.nutsrg) {
        //allow for stat label positioning by adding a g element here, then adding the values in the mapType updateValuesLabels function
        if (map.nutsLevel_ == 'mixed') {
            statLabelRegions = map.Geometries.geoJSONs.mixed.rg0.concat(
                map.Geometries.geoJSONs.mixed.rg1,
                map.Geometries.geoJSONs.mixed.rg2,
                map.Geometries.geoJSONs.mixed.rg3,
                map.Geometries.geoJSONs.cntrg // NEW: allow labels for cntrg
            )
        } else {
            statLabelRegions = map.Geometries.geoJSONs.nutsrg.concat(map.Geometries.geoJSONs.cntrg)
        }
    } else if (map.Geometries.userGeometries) {
        // user defined geometries
        statLabelRegions = map.Geometries.statisticalRegions.features
    }

    //TODO: dont add labels for regions that are not visible? what about panning and zooming though. Only really an issue for mixed NUTS.

    // stats labels
    const filteredRegions = statLabelRegions.filter((d, i, self) => i === self.findIndex((t) => t.properties.id === d.properties.id))
    statLabelsGroup
        .selectAll('g')
        .data(filteredRegions)
        .enter()
        .append('g')
        .attr('transform', function (d) {
            // use predefined label positioning
            if (map.labels_.statLabelsPositions[d.properties.id]) {
                const position = map.labels_.statLabelsPositions[d.properties.id]
                let pos = map._projection([position.x, position.y])
                let x = pos[0].toFixed(3)
                let y = pos[1].toFixed(3)
                return `translate(${x},${y})`
            } else {
                let centroid = map._pathFunction.centroid(d)

                if (map.labels_.processValueLabelCentroids) {
                    centroid = map.labels_.processValueLabelCentroids(d, centroid)
                }
                // otherwise we calculate centroids
                return 'translate(' + centroid + ')'
            }
        })
        .attr('class', 'em-stat-label')

    // stat labels shadows
    if (map.labels_?.shadows) {
        gsls.selectAll('g')
            .data(statLabelRegions)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                // use predefined label positioning
                if (map.labels_.statLabelsPositions[d.properties.id]) {
                    let pos = map._projection([
                        map.labels_.statLabelsPositions[d.properties.id].x,
                        map.labels_.statLabelsPositions[d.properties.id].y,
                    ])
                    let x = pos[0].toFixed(3)
                    let y = pos[1].toFixed(3)
                    return `translate(${x},${y})`
                } else {
                    let centroid = map._pathFunction.centroid(d)

                    if (map.labels_.processValueLabelCentroids) {
                        centroid = map.labels_.processValueLabelCentroids(d, centroid)
                    }
                    // otherwise we calculate centroids
                    return 'translate(' + centroid + ')'
                }
            })

            .attr('class', 'em-stat-label-shadow')
    }
}

/**
 * Default labels for country / geographical names.
 * Using centroids would clash with proportional symbols, and are generally not ideal placements, so labels are positioned independently
 * Labels are provided for all supported languages: "en","fr" and "de" (defined using map.language())
 */
const DEFAULTLABELS = {
    EUR_3035: {
        cc: [
            { text: 'AL', x: 5150000, y: 2060000, class: 'cc', size: 7 },
            { text: 'AT', x: 4670000, y: 2690000, class: 'cc', size: 18 },
            { text: 'BE', x: 3930000, y: 3010000, class: 'cc', size: 17 },
            { text: 'BG', x: 5567000, y: 2250000, class: 'cc', size: 22 },
            { text: 'HR', x: 4840000, y: 2480000, class: 'cc', size: 10 },
            { text: 'CY', x: 6426000, y: 1480000, class: 'cc', size: 10 },
            { text: 'CZ', x: 4707000, y: 2920000, class: 'cc', size: 18 },
            { text: 'DK', x: 4316000, y: 3621000, class: 'cc', size: 20 },
            { text: 'EE', x: 5220000, y: 3990000, class: 'cc', size: 12 },
            { text: 'FI', x: 5150000, y: 4424000, class: 'cc', size: 20 },
            { text: 'FR', x: 3767740, y: 2662817, class: 'cc', size: 22 },
            { text: 'DE', x: 4347284, y: 3093276, class: 'cc', size: 22 },
            { text: 'EL', x: 5370000, y: 1750000, class: 'cc', size: 22 },
            { text: 'HU', x: 5020000, y: 2630000, class: 'cc', size: 17 },
            { text: 'IS', x: 3040000, y: 4833000, class: 'cc', size: 10 },
            { text: 'IE', x: 3136000, y: 3394000, class: 'cc', size: 17 },
            { text: 'IT', x: 4469967, y: 2181963, class: 'cc', size: 22 },
            { text: 'LV', x: 5290000, y: 3800000, class: 'cc', size: 12 },
            { text: 'LT', x: 5190000, y: 3630000, class: 'cc', size: 12 },
            { text: 'LU', x: 4120000, y: 2940000, class: 'cc', size: 12 },
            { text: 'MT', x: 4731000, y: 1300000, class: 'cc', size: 10 },
            { text: 'ME', x: 5073000, y: 2185000, class: 'cc', size: 7 },
            { text: 'GE', x: 6942680, y: 2660000, class: 'cc' },
            { text: 'UA', x: 5890000, y: 3050000, class: 'cc' },
            { text: 'BA', x: 4949262, y: 2338688, class: 'cc' },
            { text: 'MD', x: 5740000, y: 2790000, class: 'cc' },

            { text: 'MK', x: 5300000, y: 2080000, class: 'cc', size: 10 },
            { text: 'NL', x: 4020000, y: 3208000, class: 'cc', size: 17 },
            { text: 'NO', x: 4300000, y: 4147000, class: 'cc', size: 20 },
            { text: 'PL', x: 4964000, y: 3200000, class: 'cc', size: 22 },
            { text: 'PT', x: 2770000, y: 1990000, class: 'cc', size: 18 },
            { text: 'RO', x: 5451000, y: 2600000, class: 'cc', size: 22 },
            { text: 'RS', x: 5200000, y: 2350000, class: 'cc', size: 10 },
            { text: 'SK', x: 5040000, y: 2860000, class: 'cc', size: 12 },
            { text: 'SI', x: 4675000, y: 2500000, class: 'cc', size: 10 },
            { text: 'ES', x: 3160096, y: 1900000, class: 'cc', size: 22 },
            { text: 'SE', x: 4630000, y: 4000000, class: 'cc', size: 20 },
            { text: 'CH', x: 4170000, y: 2600000, class: 'cc', size: 16 },
            { text: 'TR', x: 6510000, y: 2100000, class: 'cc', size: 22 },
            { text: 'UK', x: 3558000, y: 3250000, class: 'cc', size: 17 },
        ],
        en: [
            { text: 'MEDITERRANEAN SEA', x: 3980000, y: 1600000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTIC OCEAN', x: 2820000, y: 2540000, class: 'seas', size: 12, letterSpacing: 2 },
            { text: 'NORTH SEA', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'BALTIC SEA', x: 4900000, y: 3730000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGIAN SEA', x: 3850000, y: 4800000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'BLACK SEA', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 4 },
            { text: 'ALBANIA', cc: 'AL', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUSTRIA', cc: 'AT', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIUM', cc: 'BE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIA', cc: 'BG', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIA', cc: 'HR', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CYPRUS', cc: 'CY', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'CZECHIA', cc: 'CZ', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DENMARK', cc: 'DK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIA', cc: 'EE', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINLAND', cc: 'FI', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', cc: 'FR', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'GERMANY', cc: 'DE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GREECE', cc: 'EL', x: 5470000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HUNGARY', cc: 'HU', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ICELAND', cc: 'IS', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRELAND', cc: 'IE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALY', cc: 'IT', x: 4469967, y: 2181963, class: 'countries', size: 12 },
            { text: 'LATVIA', cc: 'LV', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITHUANIA', cc: 'LT', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', cc: 'LU', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', cc: 'MT', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', cc: 'ME', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'N. MACEDONIA', cc: 'MK', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NETHERLANDS', cc: 'NL', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWAY', cc: 'NO', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLAND', cc: 'PL', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', cc: 'PT', x: 2830000, y: 1990000, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROMANIA', cc: 'RO', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIA', cc: 'RS', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAKIA', cc: 'SK', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVENIA', cc: 'SI', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPAIN', cc: 'ES', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SWEDEN', cc: 'SE', x: 4630000, y: 4100000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SWITZERLAND', cc: 'CH', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURKEY', cc: 'TR', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'U.K.', cc: 'UK', x: 3558000, y: 3250000, class: 'countries', size: 12 },
        ],
        fr: [
            { text: 'MER MDITERRANE', x: 5472000, y: 1242000, class: 'seas', size: 12 },
            { text: 'OCAN ATLANTIQUE', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'MER DU NORD', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'MER BALTIQUE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'MER DE NORVGE', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'MER NOIRE', x: 6265000, y: 2472000, class: 'seas', size: 12 },
            { text: 'ALBANIE', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'AUTRICHE', x: 4670000, y: 2629000, class: 'countries', size: 10 },
            { text: 'BELGIQUE', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIE', x: 5567000, y: 2256000, class: 'countries', size: 12 },
            { text: 'CROATIE', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'CHYPRE', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TCHQUIE', x: 4707000, y: 2885000, class: 'countries', size: 12 },
            { text: 'DANEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTONIE', x: 5220000, y: 3990000, class: 'countries', size: 10 },
            { text: 'FINLANDE', x: 5125000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANCE', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'ALLEMAGNE', x: 4347284, y: 3093276, class: 'countries', size: 12 },
            { text: 'GRCE', x: 5420000, y: 1860000, class: 'countries', size: 12 },
            { text: 'HONGRIE', x: 5020000, y: 2654000, class: 'countries', size: 10 },
            { text: 'ISLANDE', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLANDE', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIE', x: 4500000, y: 2181963, class: 'countries', size: 12 },
            { text: 'LETTONIE', x: 5290000, y: 3776000, class: 'countries', size: 10 },
            { text: 'LITUANIE', x: 5190000, y: 3630000, class: 'countries', size: 10 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTE', x: 4731000, y: 1335000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'MAC. DU NORD', x: 5300000, y: 2082000, class: 'countries', size: 7 },
            { text: 'PAYS-BAS', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORVEGE', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLOGNE', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'ROUMANIE', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIE', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOVAQUIE', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOVNIE', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -35 },
            { text: 'ESPAGNE', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SUDE', x: 4700000, y: 4401000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SUISSE', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TURQUIE', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'ROYAUME-UNI', x: 3558000, y: 3250000, class: 'countries', size: 10 },
        ],
        de: [
            { text: 'MITTELMEER', x: 5472000, y: 1200000, class: 'seas', size: 12, letterSpacing: 7 },
            { text: 'ATLANTISCHER OZEAN', x: 2820000, y: 2540000, class: 'seas', size: 12 },
            { text: 'NORDSEE', x: 3915000, y: 3700000, class: 'seas', size: 12 },
            { text: 'OSTSEE', x: 4900000, y: 3672000, class: 'seas', size: 10, rotate: -50 },
            { text: 'NORWEGISCHE MEER', x: 3850000, y: 4800000, class: 'seas', size: 12 },
            { text: 'SCHWARZE MEER', x: 6300000, y: 2500000, class: 'seas', size: 12, letterSpacing: 1 },
            { text: 'ALBANIEN', x: 5100000, y: 2060000, class: 'countries', size: 7, rotate: 80 },
            { text: 'STERREICH', x: 4650000, y: 2629000, class: 'countries', size: 7 },
            { text: 'BELGIEN', x: 3900000, y: 3030000, class: 'countries', size: 7, rotate: 30 },
            { text: 'BULGARIEN', x: 5567000, y: 2256000, class: 'countries', size: 10 },
            { text: 'KROATIEN', x: 4876000, y: 2455000, class: 'countries', size: 7 },
            { text: 'ZYPERN', x: 6426000, y: 1480000, class: 'countries', size: 10 },
            { text: 'TSCHECHIEN', x: 4707000, y: 2885000, class: 'countries', size: 7 },
            { text: 'DNEMARK', x: 4316000, y: 3621000, class: 'countries', size: 10 },
            { text: 'ESTLAND', x: 5220000, y: 3990000, class: 'countries', size: 7 },
            { text: 'FINNLAND', x: 5150000, y: 4424000, class: 'countries', size: 12 },
            { text: 'FRANKREICH', x: 3767740, y: 2662817, class: 'countries', size: 12 },
            { text: 'DEUTSCHLAND', x: 4347284, y: 3093276, class: 'countries', size: 10 },
            { text: 'GRIECHENLAND', x: 5550000, y: 1500000, class: 'countries', size: 10 },
            { text: 'UNGARN', x: 5020000, y: 2630000, class: 'countries', size: 10 },
            { text: 'ISLAND', x: 3040000, y: 4833000, class: 'countries', size: 10 },
            { text: 'IRLAND', x: 3136000, y: 3394000, class: 'countries', size: 10 },
            { text: 'ITALIEN', x: 4469967, y: 2181963, class: 'countries', size: 12, rotate: 35 },
            { text: 'LETTLAND', x: 5290000, y: 3800000, class: 'countries', size: 7 },
            { text: 'LITAUEN', x: 5190000, y: 3630000, class: 'countries', size: 7 },
            { text: 'LUX.', x: 4120000, y: 2940000, class: 'countries', size: 7 },
            { text: 'MALTA', x: 4731000, y: 1330000, class: 'countries', size: 7 },
            { text: 'MONT.', x: 5073000, y: 2185000, class: 'countries', size: 7 },
            { text: 'NORDMAZEDONIEN', x: 5350000, y: 2082000, class: 'countries', size: 7 },
            { text: 'NIEDERLANDE', x: 3977000, y: 3208000, class: 'countries', size: 7 },
            { text: 'NORWEGEN', x: 4330000, y: 4147000, class: 'countries', size: 12, rotate: -75 },
            { text: 'POLEN', x: 4964000, y: 3269000, class: 'countries', size: 12 },
            { text: 'PORTUGAL', x: 2836136, y: 1956179, class: 'countries', size: 10, rotate: -75 },
            { text: 'RUMNIEN', x: 5451000, y: 2600000, class: 'countries', size: 12 },
            { text: 'SERBIEN', x: 5200000, y: 2300000, class: 'countries', size: 7 },
            { text: 'SLOWAKEI', x: 5040000, y: 2835000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SLOWENIEN', x: 4735000, y: 2522000, class: 'countries', size: 7, rotate: -30 },
            { text: 'SPANIEN', x: 3160096, y: 1850000, class: 'countries', size: 12 },
            { text: 'SCHWEDEN', x: 4670000, y: 4180000, class: 'countries', size: 12, rotate: -75 },
            { text: 'SCHWEIZ', x: 4200000, y: 2564000, class: 'countries', size: 7 },
            { text: 'TRUTHAHN', x: 6510000, y: 2100000, class: 'countries', size: 12 },
            { text: 'VEREINIGTES', x: 3550000, y: 3520000, class: 'countries', size: 10 },
            { text: 'KNIGREICH', x: 3550000, y: 3420000, class: 'countries', size: 10 },
        ],
    },
    IC_32628: {
        cc: [{ text: 'ES', x: 420468, y: 3180647, class: 'cc', size: 12 }],
        en: [{ text: 'Canary Islands', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        fr: [{ text: 'Les les Canaries', x: 420468, y: 3180647, class: 'countries', size: 12 }],
        de: [{ text: 'Kanarische Inseln', x: 410000, y: 3180647, class: 'countries', size: 12 }],
    },
    GP_32620: {
        cc: [{ text: 'FR', x: 667000, y: 1740000, class: 'cc', size: 12 }],
        en: [{ text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 12 }],
    },
    MQ_32620: {
        cc: [{ text: 'FR', x: 716521, y: 1621322, class: 'cc', size: 12 }],
        en: [{ text: 'Martinique', x: 716521, y: 1621322, class: 'countries', size: 12 }],
    },
    GF_32622: {
        cc: [{ text: 'FR', x: 266852, y: 444074, class: 'cc', size: 12 }],
        en: [{ text: 'Guyane', x: 266852, y: 444074, class: 'countries', size: 12 }],
        de: [{ text: 'Guayana', x: 266852, y: 444074, class: 'countries', size: 12 }],
    },
    RE_32740: {
        cc: [{ text: 'FR', x: 348011, y: 7680000, class: 'cc', size: 10 }],
        en: [{ text: 'Runion', x: 348011, y: 7680000, class: 'countries', size: 10 }],
    },
    YT_32738: {
        cc: [{ text: 'FR', x: 516549, y: 8593920, class: 'cc', size: 10 }],
        en: [{ text: 'Mayotte', x: 516549, y: 8593920, class: 'countries', size: 10 }],
    },
    MT_3035: {
        cc: [{ text: 'MT', x: 4719755, y: 1410701, class: 'cc', size: 10 }],
        en: [{ text: 'Malta', x: 4719755, y: 1410701, class: 'countries', size: 10 }],
    },
    PT20_32626: {
        cc: [{ text: 'PT', x: 397418, y: 4320000, class: 'cc', size: 10 }],
        en: [{ text: 'Azores', x: 397418, y: 4320000, class: 'countries', size: 10 }],
        fr: [{ text: 'Aores', x: 397418, y: 4271471, class: 'countries', size: 10 }],
        de: [{ text: 'Azoren', x: 397418, y: 4271471, class: 'countries', size: 10 }],
    },
    PT30_32628: {
        cc: [{ text: 'PT', x: 333586, y: 3624000, class: 'cc', size: 10, rotate: 30 }],
        en: [{ text: 'Madeira', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
        fr: [{ text: 'Madre', x: 333586, y: 3624000, class: 'countries', size: 10, rotate: 30 }],
    },
    LI_3035: {
        cc: [{ text: 'LI', x: 4287060, y: 2660000, class: 'cc', size: 12 }],
        en: [{ text: 'Liechtenstein', x: 4287060, y: 2679000, class: 'countries', size: 7 }],
    },
    IS_3035: {
        cc: [{ text: 'IS', x: 3011804, y: 4960000, class: 'cc', size: 12 }],
        en: [{ text: 'Iceland', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        fr: [{ text: 'Islande', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
        de: [{ text: 'Island', x: 3011804, y: 4960000, class: 'countries', size: 12 }],
    },
    SJ_SV_3035: {
        cc: [{ text: 'NO', x: 4570000, y: 6260000, class: 'cc', size: 10 }],
        en: [{ text: 'Svalbard', x: 4570000, y: 6260000, class: 'countries', size: 10 }],
        de: [{ text: 'Spitzbergen', x: 4570000, y: 6260000, class: 'countries', size: 7 }],
    },
    SJ_JM_3035: {
        cc: [{ text: 'NO', x: 3647762, y: 5420300, class: 'cc', size: 10 }],
        en: [{ text: 'Jan Mayen', x: 3647762, y: 5420300, class: 'countries', size: 7 }],
    },
    CARIB_32620: {
        cc: [
            { text: 'FR', x: 700000, y: 1810000, class: 'cc', size: 10 },
            { text: 'FR', x: 640000, y: 1590000, class: 'cc', size: 10 },
            { text: 'FR', x: 540000, y: 1962000, class: 'cc', size: 7 },
        ],
        en: [
            { text: 'Guadeloupe', x: 700000, y: 1810000, class: 'countries', size: 10 },
            { text: 'Martinique', x: 570000, y: 1590000, class: 'countries', size: 10 },
            { text: 'Saint Martin', x: 597000, y: 1962000, class: 'countries', size: 7 },
        ],
    },
    // note: WORLD x/y are in EPSG:4326 then reprojected by d3 to EPSG:54030
    WORLD_54030: {
        en: [
            { text: 'NORTH ATLANTIC', x: -45, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH ATLANTIC', x: -15, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTH PACIFIC', x: -126, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'NORTH', x: -136, y: 25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'PACIFIC', x: -134, y: 20, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'INDIAN OCEAN', x: 80, y: -25, class: 'seas', size: 10, letterSpacing: 1 },
            { text: 'SOUTHERN OCEAN', x: -5, y: -67, class: 'seas', size: 10, letterSpacing: 6 },
        ],
    },
}

const DEFAULTSTATLABELPOSITIONS = {
    AL: { x: 5150000, y: 2000000 },
    AT: { x: 4670000, y: 2740000 },
    BE: { x: 3930000, y: 3060000 },
    BG: { x: 5567000, y: 2300000 },
    HR: { x: 4657718, y: 2400243 },
    CY: { x: 6426000, y: 1570000 },
    CH: { x: 4170000, y: 2600000 },
    CZ: { x: 4707000, y: 2950000 },
    DK: { x: 4316000, y: 3621000 },
    EE: { x: 5220000, y: 4050000 },
    FI: { x: 5150000, y: 4424000 },
    FR: { x: 3767740, y: 2662817 },
    DE: { x: 4347284, y: 3093276 },
    EL: { x: 5370000, y: 1750000 },
    HU: { x: 5020000, y: 2670000 },
    IS: { x: 3040000, y: 4833000 },
    IE: { x: 3136000, y: 3394000 },
    IT: { x: 4500000, y: 2181963 },
    LV: { x: 5290000, y: 3840000 },
    LT: { x: 5190000, y: 3670000 },
    LU: { x: 4120000, y: 2940000 },
    MT: { x: 4880000, y: 1480000 },
    GE: { x: 6912680, y: 2696554 },
    UA: { x: 5865507, y: 3130158 },
    BA: { x: 4959262, y: 2368688 },
    MD: { x: 5736016, y: 2835957 },
    ME: { x: 5073000, y: 2230000 },
    MK: { x: 5300000, y: 2130000 },
    NL: { x: 4020000, y: 3208000 },
    NO: { x: 4300000, y: 4147000 },
    PL: { x: 4964000, y: 3200000 },
    PT: { x: 2760000, y: 1990000 },
    RO: { x: 5451000, y: 2600000 },
    RS: { x: 5200000, y: 2370000 },
    SK: { x: 5040000, y: 2890000 },
    SI: { x: 4660000, y: 2550000 },
    ES: { x: 3200000, y: 2000000 },
    SE: { x: 4630000, y: 4000000 },
    TR: { x: 6510000, y: 2100000 },
    UK: { x: 3558000, y: 3250000 },
    RU: { x: 6842086, y: 3230517 },
}


/***/ }),

/***/ "./src/core/map-template.js":
/*!**********************************!*\
  !*** ./src/core/map-template.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapTemplate: () => (/* binding */ mapTemplate)
/* harmony export */ });
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/src/robinson.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _annotations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotations */ "./src/core/annotations.js");
/* harmony import */ var _labels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./labels */ "./src/core/labels.js");
/* harmony import */ var _deprecated__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deprecated */ "./src/core/deprecated.js");
/* harmony import */ var _geometries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geometries */ "./src/core/geometries.js");
/* harmony import */ var _insets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./insets */ "./src/core/insets.js");
/* harmony import */ var _stamps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stamps */ "./src/core/stamps.js");
/* harmony import */ var _cartograms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cartograms */ "./src/core/cartograms.js");














// set default d3 locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_9__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', ''],
})

/**
 * The map template: only the geometrical part.
 * To be used as a base map for a statistical map.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const mapTemplate = function (config, withCenterPoints, mapType) {
    //build map template object
    const out = {}
    out._mapType = mapType

    // expose imported function to other modules
    out.updateValuesLabels = _labels__WEBPACK_IMPORTED_MODULE_3__.updateValuesLabels

    //map
    out.svgId_ = 'map'
    out.svg_ = undefined
    out.width_ = Math.min(795, window.innerWidth)
    out.height_ = 0
    out.containerId_ = undefined

    //geographical focus
    out.gridCartogram_ = false // draw geometries as grid cells
    out.gridCartogramShape_ = 'square' // square or hexagon
    out.gridCartogramMargins_ = { top: 80, right: 50, bottom: 80, left: 150 }
    out.gridCartogramCellPadding_ = 4
    out.gridCartogramPositions_ = undefined //user defined cartograms
    out.nutsLevel_ = 3 // 0,1,2,3, or 'mixed'
    out.nutsYear_ = 2024
    out.geo_ = 'EUR'
    out.proj_ = '3035'
    out.projectionFunction_ = undefined // e.g. d3.geoRobinson()
    out.filterGeometriesFunction_ = undefined // user defined filter function
    out.scale_ = '20M' //TODO choose automatically, depending on pixelSize ?
    out.zoomExtent_ = undefined
    out.maxBounds_ = { xMin: -Infinity, yMin: -Infinity, xMax: Infinity, yMax: Infinity }
    out.geometries_ = undefined // [{id:String, data:geojson, class:function}] user-defined geometries
    out.processCentroids_ = undefined // runs over symbol centroids
    out.position_ = { x: undefined, y: undefined, z: undefined } // map view

    //map title
    out.title_ = ''
    out.titlePosition_ = undefined

    //map subtitle
    out.subtitle_ = ''
    out.subtitlePosition_ = undefined

    //scalebar
    out.showScalebar_ = false
    out.scalebarPosition_ = []
    out.scalebarUnits_ = ' km' //label
    out.scalebarTextOffset_ = [0, 12]
    out.scalebarMaxWidth_ = 150 //px
    out.scalebarHeight_ = 90 //px
    out.scalebarStrokeWidth_ = 1 //px
    out.scalebarSegmentHeight_ = 6
    out.scalebarTickHeight_ = 8

    // stamp annotation
    out.stamp_ = undefined //e.g {x,y,text,size}

    //tooltip
    out.tooltip_ = {
        fontSize: '14px',
        transitionDuration: 200,
        xOffset: 0,
        yOffset: 0,
        textFunction: null,
        showFlags: false,
    } //  See tooltip.js for more details

    // region mouseover color
    out.hoverColor_ = 'red'

    //coastal margin
    out.drawCoastalMargin_ = false
    out.coastalMarginStdDev_ = 3

    //graticule
    out.drawGraticule_ = false

    //background map toggle (e.g. for dorling)
    out.backgroundMap_ = true

    //labelling
    // see docs\reference.md#labelling
    out.labels_ = undefined

    //annotations
    out.annotations_ = undefined
    out.annotationsAdded = false //simple flag to know when annotations have already been added

    //hatching
    out.patternFill_ = undefined // e.g. {pattern:'hatching',regionIds:['DE','FR']}

    //dataset source link
    out.showSourceLink_ = true

    //default copyright and disclaimer text
    out.footnote_ = 'Administrative boundaries: \u00A9EuroGeographics \u00A9UN-FAO \u00A9INSTAT \u00A9Turkstat' //"(C)EuroGeographics (C)UN-FAO (C)Turkstat";
    out.footnoteTooltipText_ =
        'The designations employed and the presentation of material on this map do not imply the expression of any opinion whatsoever on the part of the European Union concerning the legal status of any country, territory, city or area or of its authorities, or concerning the delimitation of its frontiers or boundaries. Kosovo*: This designation is without prejudice to positions on status, and is in line with UNSCR 1244/1999 and the ICJ Opinion on the Kosovo declaration of independence.'

    out.nuts2jsonBaseURL_ = window.location.hostname.includes('ec.europa.eu')
        ? 'https://ec.europa.eu/assets/estat/E/E4/gisco/pub/nuts2json/v2'
        : 'https://raw.githubusercontent.com/eurostat/Nuts2json/master/pub/v2'

    //style for no data regions
    out.noDataFillStyle_ = '#bcbcbc'

    /**
     * Insets.
     * The map template has a recursive structure.
     */

    //insets to show, as a list of map template configs. Ex.: [{geo:"MT"},{geo:"LI"},{geo:"PT20"}]
    out.insets_ = []
    //inset templates - each inset is a map-template instance.
    out.insetTemplates_ = {}

    out.insetBoxPosition_ = undefined
    out.insetBoxPadding_ = 5
    out.insetBoxWidth_ = 210
    //out.insetZoomExtent_ = [1, 3];
    out.insetZoomExtent_ = null //zoom disabled as default
    out.insetScale_ = '03M'

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    for (const att in out) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    }

    // warn existing users of functions that have been banished to the shadow realm.
    (0,_deprecated__WEBPACK_IMPORTED_MODULE_4__.defineDeprecatedFunctions)(out)

    // convert geo to uppercase
    out.geo = function (v) {
        if (!arguments.length) return out.geo_
        out.geo_ = v.toUpperCase()
        return out
    }

    //special ones which affect also the insets
    ;['tooltip_', 'nuts2jsonBaseURL_', 'processCentroids_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]

            if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
                //override default properties
                for (const p in v) {
                    out[att][p] = v[p]
                }
            } else {
                out[att] = v
            }

            //recursive call to inset components
            if (out.insetTemplates_) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(
                    out.insetTemplates_,
                    out.svgId_,
                    (inset, value) => {
                        const fnName = att.substring(0, att.length - 1)
                        inset[fnName](value)
                    },
                    v
                )
            }
            return out
        }
    })

    //title getter and setter
    out.title = function (v) {
        if (!arguments.length) return out.title_
        out.title_ = v
        if (out.svg())
            out.svg()
                .select('#title' + out.geo())
                .text(v)
        return out
    }

    //subtitle getter and setter
    out.subtitle = function (v) {
        if (!arguments.length) return out.subtitle_
        out.subtitle_ = v
        if (out.svg())
            out.svg()
                .select('#subtitle' + out.geo())
                .text(v)
        return out
    }

    //insets getter/setter
    out.insets = function () {
        if (!arguments.length) return out.insets_
        if (arguments.length == 1 && arguments[0] === 'default') out.insets_ = 'default'
        else if (arguments.length == 1 && arguments[0] === false) out.insets_ = false
        else if (arguments.length == 1 && Array.isArray(arguments[0])) out.insets_ = arguments[0]
        else out.insets_ = arguments
        return out
    }

    // dynamic draw graticule
    out.drawGraticule = function (v) {
        if (!arguments.length) return out.drawGraticule_
        out.drawGraticule_ = v

        //update graticule
        let graticule = out.svg_ ? out.svg().select('#em-graticule') : null
        let zg = out.svg_ ? out.svg_.select('#em-zoom-group-' + out.svgId_) : null

        // if existing and argument is false
        if (graticule) {
            if (graticule._groups[0][0] && v == false) {
                //remove graticule
                graticule.remove()

                // if map already created and argument is true
            } else if (out.Geometries.geoJSONs.graticule && out._pathFunction && zg && v == true) {
                //remove existing graticule
                graticule.remove()
                // add new graticule
                zg.append('g')
                    .attr('id', 'em-graticule')
                    .selectAll('path')
                    .data(out.Geometries.geoJSONs.graticule)
                    .enter()
                    .append('path')
                    .attr('d', out._pathFunction)
                    .attr('class', 'em-graticule')

                out.svg()
                    .select('#em-graticule')
                    .each(function () {
                        // move graticule behind land mass
                        out.geo_ == 'WORLD'
                            ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                            : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                    })
            }
        }
        return out
    }

    //coastal margin override
    out.drawCoastalMargin = function (v) {
        if (!arguments.length) return out.drawCoastalMargin_
        out.drawCoastalMargin_ = v

        //update existing
        if (out.svg_) {
            let margin = (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#em-coast-margin')
            let filter = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-coastal-blur')
            let zg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-zoom-group-' + out.svgId_) || null
            if (margin._groups[0][0] && v == false) {
                // remove existing
                margin.remove()
            } else if (v == true && out._pathFunction && zg) {
                //remove existing graticule
                margin.remove()
                filter.remove()
                //add filter
                out.svg_
                    .append('filter')
                    .attr('id', 'em-coastal-blur')
                    .attr('x', '-200%')
                    .attr('y', '-200%')
                    .attr('width', '400%')
                    .attr('height', '400%')
                    .append('feGaussianBlur')
                    .attr('in', 'SourceGraphic')
                    .attr('stdDeviation', out.coastalMarginStdDev_)

                //draw for main map - geometries are still in memory so no rebuild needed
                const drawNewCoastalMargin = (map) => {
                    // zoom group might not be inside main map (out.svg_)
                    const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#em-zoom-group-' + map.svgId_)
                    //draw new coastal margin
                    const cg = zoomGroup.append('g').attr('id', 'em-coast-margin')

                    //countries bn
                    if (map._geom.cntbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-cnt')
                            .selectAll('path')
                            .data(map._geom.cntbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //nuts bn
                    if (map._geom.nutsbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.nutsbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.co === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                    //world bn
                    if (map._geom.worldbn)
                        cg.append('g')
                            .attr('id', 'em-coast-margin-nuts')
                            .selectAll('path')
                            .data(map._geom.worldbn)
                            .enter()
                            .filter(function (bn) {
                                return bn.properties.COAS_FLAG === 'T'
                            })
                            .append('path')
                            .attr('d', map._pathFunction)
                }

                //draw for insets - requires geometries so we have to rebuild base template
                if (out.insetTemplates_ && out.drawCoastalMargin_) {
                    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, drawNewCoastalMargin)
                    drawNewCoastalMargin(out)
                }

                // move margin to back (in front of sea)
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#em-coast-margin').each(function () {
                    out.geo_ == 'WORLD'
                        ? this.parentNode.insertBefore(this, this.parentNode.childNodes[3])
                        : this.parentNode.insertBefore(this, this.parentNode.childNodes[1])
                })
            }
        }
        return out
    }

    //annotations override (update after first call)
    out.annotations = function (v) {
        //get
        if (!arguments.length) return out.annotations_
        //set
        out.annotations_ = v
        //update
        ;(0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
        return out
    }

    //stamps override (update after first call)
    out.stamp = function (v) {
        //get
        if (!arguments.length) return out.stamp_
        //set
        out.stamp_ = v
        //update
        ;(0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        return out
    }

    //labels override (update after first call)
    out.labels = function (v) {
        //get
        if (!arguments.length) return out.labels_
        //set
        out.labels_ = v
        //update
        ;(0,_labels__WEBPACK_IMPORTED_MODULE_3__.updateLabels)(out)
        return out
    }

    // initiate Geometries class
    out.Geometries = (0,_geometries__WEBPACK_IMPORTED_MODULE_5__.Geometries)(out, withCenterPoints)

    /**
     * Requests geographic data and then builds the map template
     */
    out.updateGeoMapTemplate = function (callback) {
        // Erase previous data
        out.Geometries.defaultGeoData = null
        out.Geometries.allNUTSGeoData = null
        out.Geometries.centroidsData = null

        if (out.geometries_) {
            out.Geometries.setUserGeometries(out.geometries_)
            // use custom user-defined geometries
            out.buildMapTemplate()

            // Execute callback if defined
            if (callback) callback()
        } else {
            // use default
            out.Geometries.getDefaultGeoData(out.geo_, out.filterGeometriesFunction_, out.nutsLevel_).then(() => {
                out.buildMapTemplate()

                // Execute callback if defined
                if (callback) callback()
            })
        }

        // Use executeForAllInsets for recursive inset updates
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.insetTemplates_, out.svgId_, (inset) => {
            inset.updateGeoMapTemplate(callback)
        })

        return out
    }

    /**
     * Build a map object, including container, frame, map svg, insets and d3 zoom
     */
    out.buildMapTemplateBase = function () {
        //get svg element. Create it if it does not exists
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#' + out.svgId())
        if (svg.size() == 0) {
            svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('body').append('svg').attr('id', out.svgId())
        }
        svg.attr('class', 'em-map')
        out.svg_ = svg

        //set container for cases where container contains various maps
        if (!out.containerId_) out.containerId_ = out.svgId_
        //tooltip needs to know container to prevent overflow
        if (!out.tooltip_.containerId) {
            out.tooltip_.containerId = out.containerId_
        }

        //clear SVG (to avoid building multiple svgs on top of each other during multiple build() calls)
        (0,d3_selection__WEBPACK_IMPORTED_MODULE_10__["default"])('#' + out.svgId() + ' > *').remove()

        //set SVG dimensions
        if (out.geo_.toUpperCase() == 'WORLD') {
            //if no height was specified, use 45% of the width.
            if (!out.height()) out.height(0.55 * out.width())
            svg.attr('width', out.width()).attr('height', out.height())

            //WORLD geo only accepts proj 54030 (robinson) at the moment
            out.proj_ = 54030
        }
        //if no height was specified, use 85% of the width.
        if (!out.height()) out.height(0.85 * out.width())
        svg.attr('width', out.width()).attr('height', out.height())

        // each map template needs a clipPath to avoid overflow. See GISCO-2707
        svg.append('defs')
            .attr('class', 'em-defs')
            .append('clipPath')
            .attr('id', out.svgId_ + '-clip-path')
            .append('path')
            .attr('d', (0,_utils__WEBPACK_IMPORTED_MODULE_1__.convertRectanglesToPaths)(0, 0, out.width_, out.height_))

        if (out.drawCoastalMargin_) {
            //define filter for coastal margin
            svg.append('filter')
                .attr('id', 'em-coastal-blur')
                .attr('x', '-200%')
                .attr('y', '-200%')
                .attr('width', '400%')
                .attr('height', '400%')
                .append('feGaussianBlur')
                .attr('in', 'SourceGraphic')
                .attr('stdDeviation', out.coastalMarginStdDev_)
        }

        //create drawing group, as first child
        const dg = svg
            .insert('g', ':first-child')
            .attr('id', 'em-drawing-' + out.svgId_)
            .attr('class', 'em-drawing-group')
            .attr('clip-path', 'url(#' + out.svgId_ + '-clip-path' + ')')

        //create main zoom group
        const zg = dg
            .append('g')
            .attr('id', 'em-zoom-group-' + out.svgId_)
            .attr('class', 'em-zoom-group') //out.geo changed to out.svgId in order to be unique

        // build insets
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.removeInsets)(out) //remove existing
        ;(0,_insets__WEBPACK_IMPORTED_MODULE_6__.buildInsets)(out, withCenterPoints) //build new

        //draw frame
        dg.append('rect')
            .attr('id', 'em-frame-' + out.geo_)
            .attr('class', 'em-frame')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', out.width_)
            .attr('height', out.height_)

        if (out.stamp_) {
            (0,_stamps__WEBPACK_IMPORTED_MODULE_7__.appendStamp)(out.stamp_, out)
        }

        return out
    }

    /**
     * Buid an empty map template, based on the geometries only.
     */
    out.buildMapTemplate = function () {
        //prepare drawing group
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //remove all children
        zoomGroup.selectAll('*').remove()

        // separate logic for cartograms
        if (out.gridCartogram_ == true) {
            (0,_cartograms__WEBPACK_IMPORTED_MODULE_8__.buildGridCartogramBase)(out)
            out.footnote_ = false //dont need copyright
        } else {
            // default geographic logic

            // position
            if (!out.position_.x || !out.position_.y) {
                defineDefaultPosition()
            }
            out.position_.z = out.position_.z || getDefaultZ()

            // d3 projection/path functions
            defineProjection()
            definePathFunction()

            // d3 zoom
            if (out.zoomExtent()) {
                defineMapZoom()
            }

            if (out.backgroundMap_) {
                drawBackgroundMap(out)
            }
        }

        //prepare group for proportional symbols, with centroids
        if (withCenterPoints) {
            addCentroidsToMap(out)
        }

        // add geographical labels to map
        if (out.labels_) {
            (0,_labels__WEBPACK_IMPORTED_MODULE_3__.addLabelsToMap)(out, zoomGroup)
        }

        //annotations
        if (out.annotations_) {
            (0,_annotations__WEBPACK_IMPORTED_MODULE_2__.appendAnnotations)(out)
            out.annotationsAdded = true
        }

        //title
        if (out.title()) {
            //define default position
            let cssClass = out.isInset ? 'em-inset-title' : 'em-title'
            if (!out.titlePosition()) out.titlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssClass) + (out.isInset ? 0 : 10)])
            //draw title
            out.svg()
                .append('text')
                .attr('id', 'title' + out.geo_)
                .attr('class', cssClass)
                .attr('x', out.titlePosition()[0])
                .attr('y', out.titlePosition()[1])
                .html(out.title())
        }

        //subtitle
        if (out.subtitle()) {
            let cssSubtitleClass = out.isInset ? 'em-inset-subtitle' : 'em-subtitle'
            let cssTitleClass = out.isInset ? 'em-inset-title' : 'em-title'
            //define default position
            if (!out.subtitlePosition()) out.subtitlePosition([10, (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssTitleClass) + (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)(cssSubtitleClass) + 15])
            //draw subtitle
            out.svg()
                .append('text')
                .attr('id', 'subtitle' + out.geo_)
                .attr('class', cssSubtitleClass)
                .attr('x', out.subtitlePosition()[0])
                .attr('y', out.subtitlePosition()[1])
                .html(out.subtitle())
        }

        //bottom text
        if (out.footnote_) {
            addFootnote()
        }

        //source dataset URL
        if (out.showSourceLink_) {
            let stat
            if (withCenterPoints) {
                stat = out.stat('size')
            } else {
                stat = out.stat()
            }
            if (stat) {
                if (stat.eurostatDatasetCode) {
                    //dataset link
                    let code = stat.eurostatDatasetCode
                    let url = `https://ec.europa.eu/eurostat/databrowser/view/${code}/default/table?lang=en`
                    let link = out
                        .svg()
                        .append('a')
                        .attr('class', 'em-source-dataset-link')
                        .attr('href', url)
                        .attr('target', '_blank')
                        .append('text')
                        .attr('class', 'em-source-dataset-link-text')
                        .attr('x', out.width_)
                        .attr('y', out.height_)
                        .text('EUROSTAT')
                        .attr('text-anchor', 'end')

                    //pretext "Source:"
                    let linkW = link.node().getComputedTextLength()
                    out.svg()
                        .append('text')
                        .attr('class', 'em-source-pretext')
                        .attr('x', out.width_ - linkW - 2)
                        .attr('y', out.height_)
                        .text('Source:')
                        .attr('text-anchor', 'end')
                }
            }
        }

        // scalebar
        if (out.showScalebar_) {
            if (out.scalebarPosition_.length !== 2) {
                out.scalebarPosition_[0] = 15
                out.scalebarPosition_[1] = out.height_ - 50
            }
            addScalebarToMap()
        }

        return out
    }

    const drawBackgroundMap = function (out) {
        //draw background map
        const zoomGroup = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw sea
        zoomGroup
            .append('rect')
            .attr('id', 'sea')
            .attr('class', 'em-sea')
            .attr('x', -5 * out.width_)
            .attr('y', -5 * out.height_)
            .attr('width', 11 * out.width_)
            .attr('height', 11 * out.height_)

        //sphere for world map
        if (out.geo_ == 'WORLD') {
            zoomGroup.append('path').datum({ type: 'Sphere' }).attr('id', 'sphere').attr('d', out._pathFunction).attr('class', 'em-graticule')
        }

        // coastal margin
        if (out.drawCoastalMargin_) {
            addCoastalMarginToMap()
        }

        // draw polygons and borders
        if (out.geometries_) {
            out.Geometries.addUserGeometriesToMap(out.geometries_, zoomGroup, out._pathFunction)
        } else {
            out.Geometries.addDefaultGeometriesToMap(
                zoomGroup,
                out.drawGraticule_,
                out._pathFunction,
                out.nutsLevel_,
                out.nutsYear_,
                out.geo_,
                out.proj_,
                out.scale_
            )
        }
    }

    const defineDefaultPosition = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            out.position_.x = out.position_.x || defaultPosition.geoCenter[0]
            out.position_.y = out.position_.y || defaultPosition.geoCenter[1]
        } else if (out.Geometries.defaultGeoData?.bbox) {
            // default to center of geoData bbox
            out.position_.x = out.position_.x || 0.5 * (out.Geometries.defaultGeoData.bbox[0] + out.Geometries.defaultGeoData.bbox[2])
            out.position_.y = out.position_.y || 0.5 * (out.Geometries.defaultGeoData.bbox[1] + out.Geometries.defaultGeoData.bbox[3])
        } else {
            //TODO: auto-define user=defined geometries geoCenter
            // out.position_.x = Geometries.userGeometries
            // out.position_.y = Geometries.userGeometries
        }

        // optional: set from URL
        setViewFromURL()
    }

    const getDefaultZ = function () {
        const defaultPosition = _defaultPosition[out.geo_ + '_' + out.proj_]
        if (defaultPosition) {
            return (defaultPosition.pixelSize * 800) / out.width_
        } else if (out.Geometries.defaultGeoData?.bbox) {
            return Math.min(
                (out.Geometries.defaultGeoData.bbox[2] - out.Geometries.defaultGeoData.bbox[0]) / out.width_,
                (out.Geometries.defaultGeoData.bbox[3] - out.Geometries.defaultGeoData.bbox[1]) / out.height_
            )
        } else {
            return 100
        }
    }

    const defineProjection = function () {
        // Define projection based on the geographical context

        if (out.geo_ === 'WORLD') {
            // Use Robinson projection for the world with optional custom projection function
            out._projection =
                out.projectionFunction_ ||
                (0,d3_geo_projection__WEBPACK_IMPORTED_MODULE_12__["default"])()
                    .translate([out.width_ / 2, out.height_ / 2])
                    .scale((out.width_ - 20) / (2 * Math.PI))
        } else {
            // For non-WORLD geo, use custom or default identity projection with calculated bounding box
            out._projection =
                out.projectionFunction_ || (0,d3_geo__WEBPACK_IMPORTED_MODULE_13__["default"])().reflectY(true).fitSize([out.width_, out.height_], (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getBBOXAsGeoJSON)(getCurrentBbox()))
        }
    }

    // Helper function to calculate current view as bbox
    const getCurrentBbox = function () {
        const halfWidth = 0.5 * out.position_.z * out.width_
        const halfHeight = 0.5 * out.position_.z * out.height_
        const bbox = [out.position_.x - halfWidth, out.position_.y - halfHeight, out.position_.x + halfWidth, out.position_.y + halfHeight]
        return bbox
    }

    const definePathFunction = function () {
        out._pathFunction = (0,d3_geo__WEBPACK_IMPORTED_MODULE_14__["default"])().projection(out._projection)
    }

    const defineMapZoom = function () {
        let svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('#' + out.svgId())
        let previousT = d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity
        const xoo = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()
            .scaleExtent(out.zoomExtent())
            .on('zoom', function (e) {
                const t = e.transform
                if (t.k !== previousT.k) {
                    zoomHandler(e, previousT)
                } else {
                    panHandler(e)
                }

                // apply default transform to map
                const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
                zoomGroup.attr('transform', t)
                previousT = t
            })

        svg.call(xoo)
    }

    // Zoom handler function
    const zoomHandler = function (event, previousT) {
        const transform = event.transform
        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k

        // Use the projection to get the projected center in EPSG:3035
        const [projectedX, projectedY] = out._projection.invert([centerX, centerY])

        // set new position
        out.position_.x = projectedX
        out.position_.y = projectedY
        out.position_.z = getMetresPerPixel(transform.k / previousT.k)

        // adjust stroke dynamically according to zoom
        scaleStrokeWidths(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.values) scaleLabelTexts(transform)

        // adjust stroke dynamically according to zoom
        if (out.labels_?.backgrounds) scaleLabelBackgrounds(transform)
    }

    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelBackgrounds = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('.em-label-background')
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            // Get the original width, height, x, and y from data attributes or current attributes
            const originalWidth = parseFloat(element.attr('data-width')) || parseFloat(element.attr('width'))
            const originalHeight = parseFloat(element.attr('data-height')) || parseFloat(element.attr('height'))
            const originalX = parseFloat(element.attr('data-x')) || parseFloat(element.attr('x'))
            const originalY = parseFloat(element.attr('data-y')) || parseFloat(element.attr('y'))

            // Only process elements that have valid width, height, x, and y
            if (originalWidth > 0 && originalHeight > 0 && !isNaN(originalX) && !isNaN(originalY)) {
                // Store the original width, height, x, and y for the first time if not already stored
                if (!element.attr('data-width')) {
                    element.attr('data-width', originalWidth)
                    element.attr('data-height', originalHeight)
                    element.attr('data-x', originalX)
                    element.attr('data-y', originalY)
                }

                // Calculate the target width, height, x, and y based on zoom factor (inverse scaling)
                const targetWidth = originalWidth * (1 / zoomFactor) // Inverse scaling
                const targetHeight = originalHeight * (1 / zoomFactor) // Inverse scaling
                const targetX = originalX * (1 / zoomFactor) // Adjust x position
                const targetY = originalY * (1 / zoomFactor) // Adjust y position

                // Add the style change to a batch array
                updates.push({ element, targetWidth, targetHeight, targetX, targetY })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetWidth, targetHeight, targetX, targetY }) => {
            element.attr('width', targetWidth).attr('height', targetHeight).attr('x', targetX).attr('y', targetY)
        })
    }
    /**
     * @description adjusts text elements dynamically according to zoom
     * @param {*} transform
     */
    const scaleLabelTexts = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const labels = zoomGroup.select('#em-labels')
        const elements = labels.selectAll('*') // Select all labels
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get font-size from inline or computed style
            const inlineFontSize = element.attr('font-size')
            const cssFontSize = computedStyle.fontSize
            const fontSize = inlineFontSize || cssFontSize

            // Only process elements that have a font size defined
            if (fontSize && parseFloat(fontSize) > 0) {
                const originalFontSize = parseFloat(element.attr('data-fs')) || parseFloat(inlineFontSize) || parseFloat(cssFontSize)

                // Store the original font size for the first time
                if (!element.attr('data-fs')) {
                    element.attr('data-fs', originalFontSize)
                }

                // Calculate the target font size based on zoom factor
                const targetFontSize = originalFontSize / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetFontSize })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetFontSize }) => {
            element.style.setProperty('font-size', `${targetFontSize}px`, 'important')
        })
    }

    /**
     * @description adjusts all stroke-widths dynamically according to zoom
     * @param {*} transform
     */
    const scaleStrokeWidths = function (transform) {
        const zoomGroup = out.svg_.select('#em-zoom-group-' + out.svgId_)
        const elements = zoomGroup.selectAll('*') // Select all elements in the zoom group
        const zoomFactor = transform.k
        const updates = []

        elements.each(function () {
            const element = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
            const computedStyle = window.getComputedStyle(this)

            // Get stroke-width from inline or computed style
            const inlineStrokeWidth = element.attr('stroke-width')
            const cssStrokeWidth = computedStyle.strokeWidth
            const strokeWidth = inlineStrokeWidth || cssStrokeWidth

            // Only process elements that have a stroke width defined
            if (strokeWidth && parseFloat(strokeWidth) > 0) {
                const originalStrokeWidth = parseFloat(element.attr('data-sw')) || parseFloat(inlineStrokeWidth) || parseFloat(cssStrokeWidth)

                // Store the original stroke width for the first time
                if (!element.attr('data-sw')) {
                    element.attr('data-sw', originalStrokeWidth)
                }

                // Calculate the target stroke width
                const targetStrokeWidth = originalStrokeWidth / zoomFactor

                // Add the style change to a batch array
                updates.push({ element: this, targetStrokeWidth })
            }
        })

        // Apply all style changes at once
        updates.forEach(({ element, targetStrokeWidth }) => {
            element.style.setProperty('stroke-width', `${targetStrokeWidth}px`, 'important')
        })
    }

    /**
     * @description get the current view's metres per pixel, based on a zoomFactor
     * @param {number} zoomFactor this zoom / previous zoom
     * @return {number}
     */
    const getMetresPerPixel = function (zoomFactor) {
        // Get current bounding box width in meters
        const bbox = getCurrentBbox()
        const bboxWidth = bbox[2] - bbox[0] // BBOX width in meters

        // Calculate meters per pixel
        const metersPerPixel = bboxWidth / (out.width_ * zoomFactor)

        return metersPerPixel
    }

    // Pan handler function
    const panHandler = function (event, previousT) {
        const transform = event.transform

        // Compute the projected center
        const centerX = (out.width_ / 2 - transform.x) / transform.k
        const centerY = (out.height_ / 2 - transform.y) / transform.k
        let [geoX, geoY] = out._projection.invert([centerX, centerY])

        // Clamp geoX and geoY to max bounds and adjust the event transform
        if (out.maxBounds_.xMin !== undefined && geoX < out.maxBounds_.xMin) {
            geoX = out.maxBounds_.xMin
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMin !== undefined && geoY < out.maxBounds_.yMin) {
            geoY = out.maxBounds_.yMin
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }
        if (out.maxBounds_.xMax !== undefined && geoX > out.maxBounds_.xMax) {
            geoX = out.maxBounds_.xMax
            transform.x = out.width_ / 2 - out._projection([geoX, geoY])[0] * transform.k
        }
        if (out.maxBounds_.yMax !== undefined && geoY > out.maxBounds_.yMax) {
            geoY = out.maxBounds_.yMax
            transform.y = out.height_ / 2 - out._projection([geoX, geoY])[1] * transform.k
        }

        // set new position
        out.position_.x = geoX
        out.position_.y = geoY
    }

    /** Get x,y,z elements from URL and assign them to the view. */
    const setViewFromURL = function () {
        const x = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('x'),
            y = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('y'),
            z = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)('z')
        if (x != null && x != undefined && !isNaN(+x)) out.position_.x = +x
        if (y != null && y != undefined && !isNaN(+y)) out.position_.y = +y
        if (z != null && z != undefined && !isNaN(+z)) out.position_.z = +z
    }

    const addFootnote = function () {
        out.svg()
            .append('text')
            .attr('id', 'em-footnote')
            .attr('class', 'em-footnote')
            .attr('x', 0)
            .attr('y', out.height_)
            .html(out.footnote_)
            .on('mouseover', function () {
                out._tooltip.mw___ = out._tooltip.style('max-width')
                out._tooltip.style('max-width', '400px')
                if (out.footnoteTooltipText_) out._tooltip.mouseover(out.footnoteTooltipText_)
            })
            .on('mousemove', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                if (out.footnoteTooltipText_) out._tooltip.mouseout(e)
                out._tooltip.style('max-width', out._tooltip.mw___)
            })
    }

    const addCoastalMarginToMap = function () {
        const zg = out.svg().select('#em-zoom-group-' + out.svgId_)
        //draw coastal margin
        const cg = zg.append('g').attr('id', 'em-coast-margin').attr('class', 'em-coast-margin')

        //countries bn
        if (out.Geometries.geoJSONs.cntbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-cnt')
                .attr('class', 'em-coast-margin-cnt')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.cntbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //nuts bn
        if (out.Geometries.geoJSONs.nutsbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-nuts')
                .attr('class', 'em-coast-margin-nuts')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.nutsbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.co === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }

        //world bn
        if (out.Geometries.geoJSONs.worldbn) {
            cg.append('g')
                .attr('id', 'em-coast-margin-world')
                .attr('class', 'em-coast-margin-world')
                .selectAll('path')
                .data(out.Geometries.geoJSONs.worldbn)
                .enter()
                .filter(function (bn) {
                    return bn.properties.COAS_FLAG === 'T'
                })
                .append('path')
                .attr('d', out._pathFunction)
        }
    }

    const addCentroidsToMap = function (map) {
        let centroidFeatures

        if (!map.Geometries.centroidsData) {
            // if centroids data is absent (e.g. for world maps) then calculate manually
            if (map.geo_ == 'WORLD') {
                centroidFeatures = []
                map.Geometries.geoJSONs.worldrg.forEach((feature) => {
                    let newFeature = { ...feature }
                    // exception for France (because guyane)
                    if (feature.properties.id == 'FR') {
                        newFeature.geometry = {
                            coordinates: [2.2, 46.2],
                            type: 'Point',
                        }
                    } else {
                        newFeature.geometry = {
                            coordinates: (0,d3_geo__WEBPACK_IMPORTED_MODULE_15__["default"])(feature),
                            type: 'Point',
                        }
                    }
                    centroidFeatures.push(newFeature)
                })
            }
        } else {
            if (map.nutsLevel_ == 'mixed') {
                centroidFeatures = [
                    ...map.Geometries.centroidsData[0].features,
                    ...map.Geometries.centroidsData[1].features,
                    ...map.Geometries.centroidsData[2].features,
                    ...map.Geometries.centroidsData[3].features,
                ]
            } else {
                centroidFeatures = map.Geometries.centroidsData.features
            }
        }

        if (map.processCentroids_) centroidFeatures = map.processCentroids_(centroidFeatures)

        // calculate screen coordinates and save centroids to map
        map.Geometries.centroidFeatures = centroidFeatures.map((d) => {
            let coords = map._projection(d.geometry.coordinates)
            d.properties.centroid = coords
            return d
        })

        // em-prop-symbols is the g element containing all proportional symbols for the map
        const zg = map.svg().select('#em-zoom-group-' + map.svgId_)
        const gcp = zg.append('g').attr('id', 'em-prop-symbols')

        // add centroid elements
        // then symbols are drawn/appended to these containers in the map-type js file
        const symbolContainers = gcp
            .selectAll('g')
            .data(map.Geometries.centroidFeatures)
            .enter()
            .append('g')
            .attr('transform', function (d) {
                return 'translate(' + d.properties.centroid[0].toFixed(3) + ',' + d.properties.centroid[1].toFixed(3) + ')'
            })
            .attr('class', 'em-centroid') // OUR SYMBOL CONTAINER
            .attr('id', (d) => 'ps' + d.properties.id)
    }

    /**
     * @function addScalebarToMap
     * @description appends an SVG scalebar to the map. Uses pixelSize to calculate units in km
     */
    const addScalebarToMap = function () {
        // Julien's nice scalebars
        const marginLeft = 5
        const maxLengthPix = out.scalebarMaxWidth_
        const textOffsetX = out.scalebarTextOffset_[0]
        const textOffsetY = out.scalebarTextOffset_[1]
        const pixelSizeM = out.position_.z
        const maxLengthM = maxLengthPix * pixelSizeM
        const niceLengthM = niceScaleBarLength(maxLengthM)
        const niceLengthPixel = niceLengthM[0] / pixelSizeM
        const scaleBarStartDigit = niceLengthM[1]
        const subdivisionNbs = {
            1: 4,
            2: 2,
            5: 5,
        }

        const scalebarGroup = out
            .svg()
            .append('g')
            .attr('class', 'em-scalebar')
            .attr('transform', `translate(${out.scalebarPosition_[0]},${out.scalebarPosition_[1]})`)
            .attr('width', maxLengthPix + 20)
            .attr('height', out.scalebarHeight_)

        // top line full width
        // scalebarGroup
        //     .append('line')
        //     .attr('class', 'em-scalebar-line')
        //     .attr('x1', marginLeft)
        //     .attr('y1', 1)
        //     .attr('x2', niceLengthPixel + marginLeft)
        //     .attr('y2', 1)

        //bottom line full width
        // scalebarGroup
        //     .append('line')
        //     .attr('class', 'em-scalebar-line')
        //     .attr('x1', marginLeft)
        //     .attr('y1', out.scalebarSegmentHeight_)
        //     .attr('x2', niceLengthPixel + marginLeft)
        //     .attr('y2', out.scalebarSegmentHeight_)

        //first tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', marginLeft)
            .attr('y1', 1)
            .attr('x2', marginLeft)
            .attr('y2', out.scalebarTickHeight_)

        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text('0')

        //middle ticks
        const subdivisionNb = subdivisionNbs[scaleBarStartDigit]
        const divisionWidth = niceLengthPixel / subdivisionNb
        const divisionMinWidth = 15
        const midlineY = out.scalebarSegmentHeight_ / 2 + 1
        if (divisionWidth >= divisionMinWidth) {
            for (let i = 1; i < subdivisionNb; i++) {
                scalebarGroup
                    .append('line')
                    .attr('class', 'em-scalebar-line')
                    .attr('x1', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y1', 1)
                    .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                    .attr('y2', out.scalebarTickHeight_)
                scalebarGroup
                    .append('text')
                    .attr('class', 'em-scalebar-label')
                    .attr('x', marginLeft + textOffsetX + i * divisionWidth)
                    .attr('y', out.scalebarTickHeight_ + textOffsetY)
                    .text(getScalebarLabel((niceLengthM[0] / subdivisionNb) * i))

                if (i == 1) {
                    scalebarGroup
                        .append('line')
                        .attr('class', 'em-scalebar-line em-scalebar-midline')
                        .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                        .attr('y1', midlineY)
                        .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                        .attr('y2', midlineY)
                } else {
                    let x1 = marginLeft + out.scalebarStrokeWidth_ / 2 + (i - 1) * divisionWidth
                    if (x1 > 0) {
                        scalebarGroup
                            .append('line')
                            .attr('class', 'em-scalebar-line em-scalebar-midline')
                            .attr('x1', x1)
                            .attr('y1', midlineY)
                            .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + i * divisionWidth)
                            .attr('y2', midlineY)
                    }
                }
            }

            // Draw final midline segment (last segment)
            if (divisionWidth >= divisionMinWidth) {
                scalebarGroup
                    .append('line')
                    .attr('class', 'em-scalebar-line em-scalebar-midline')
                    .attr('x1', marginLeft + (subdivisionNb - 1) * divisionWidth)
                    .attr('y1', midlineY)
                    .attr('x2', marginLeft + subdivisionNb * divisionWidth)
                    .attr('y2', midlineY)
            }
        } else {
            // single full-length horizontal mid-line
            scalebarGroup
                .append('line')
                .attr('class', 'em-scalebar-line em-scalebar-midline')
                .attr('x1', marginLeft + out.scalebarStrokeWidth_ - 1)
                .attr('y1', midlineY)
                .attr('x2', marginLeft + out.scalebarStrokeWidth_ / 2 + divisionWidth * subdivisionNb)
                .attr('y2', midlineY)
        }

        //last tick
        scalebarGroup
            .append('line')
            .attr('class', 'em-scalebar-line')
            .attr('x1', niceLengthPixel + marginLeft)
            .attr('y1', 1)
            .attr('x2', niceLengthPixel + marginLeft)
            .attr('y2', out.scalebarTickHeight_)
        scalebarGroup
            .append('text')
            .attr('class', 'em-scalebar-label')
            .attr('x', niceLengthPixel + marginLeft + textOffsetX)
            .attr('y', out.scalebarTickHeight_ + textOffsetY)
            .text(getScalebarLabel(niceLengthM[0]) + out.scalebarUnits_)
    }

    const niceScaleBarLength = function (scaleBarLength) {
        //compute the 'nice' power of ten
        const pow10 = Math.pow(10, Math.floor(Math.log(scaleBarLength) / Math.log(10)))

        //check if 5 times this value fits
        if (5 * pow10 <= scaleBarLength) return [5 * pow10, 5]

        //check if 2 times this value fits
        if (2 * pow10 <= scaleBarLength) return [2 * pow10, 2]

        //returns the power of ten
        return [pow10, 1]
    }

    const getScalebarLabel = function (valueM) {
        if (valueM < 0.01) return valueM * 1000 + 'mm'
        if (valueM < 1) return valueM * 100 + 'cm'
        if (valueM < 1000) return valueM * 1 + 'm'
        return valueM / 1000
    }

    return out
}

/** Default geocenter positions and pixelSize (for default width = 800px) for territories and projections. */
const _defaultPosition = {
    EUR_3035: { geoCenter: [4790000, 3420000], pixelSize: 6400 },
    IC_32628: { geoCenter: [443468, 3145647], pixelSize: 1000 },
    GP_32620: { geoCenter: [669498, 1784552], pixelSize: 130 },
    MQ_32620: { geoCenter: [716521, 1621322], pixelSize: 130 },
    GF_32622: { geoCenter: [266852, 444074], pixelSize: 500 },
    RE_32740: { geoCenter: [348011, 7661627], pixelSize: 130 },
    YT_32738: { geoCenter: [516549, 8583920], pixelSize: 70 },
    MT_3035: { geoCenter: [4719755, 1441701], pixelSize: 70 },
    PT20_32626: { geoCenter: [397418, 4271471], pixelSize: 1500 },
    PT30_32628: { geoCenter: [333586, 3622706], pixelSize: 150 },
    LI_3035: { geoCenter: [4287060, 2672000], pixelSize: 40 },
    IS_3035: { geoCenter: [3011804, 4960000], pixelSize: 700 },
    SJ_SV_3035: { geoCenter: [4570000, 6160156], pixelSize: 800 },
    SJ_JM_3035: { geoCenter: [3647762, 5408300], pixelSize: 100 },
    CARIB_32620: { geoCenter: [636345, 1669439], pixelSize: 500 },
    WORLD_54030: { geoCenter: [14, 17], pixelSize: 9000 },
}


/***/ }),

/***/ "./src/core/pattern-fill.js":
/*!**********************************!*\
  !*** ./src/core/pattern-fill.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyPatternFill: () => (/* binding */ applyPatternFill)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");



function applyPatternFill(map, configs = []) {
    if (!Array.isArray(configs)) {
        console.warn('patternFill expects an array of configs')
        return
    }

    let defs = map.svg().select('defs')
    if (defs.empty()) {
        defs = map.svg().append('defs')
    }

    // Prepare: map each regionId to an array of patternIds
    const regionToPatternIds = {}

    configs.forEach((config) => {
        const { pattern = 'hatching', regionIds = [], color = '#000', strokeWidth = 1, customPattern } = config

        let patternId

        if (customPattern) {
            const idMatch = customPattern.match(/id=['"]([^'"]+)['"]/)
            if (idMatch) {
                patternId = idMatch[1]

                if (map.svg().select(`#${patternId}`).empty()) {
                    defs.node().insertAdjacentHTML('beforeend', customPattern)
                }
            } else {
                console.warn('customPattern must include an id attribute.')
                return
            }
        } else {
            const colorKey = color.replace('#', '').toLowerCase()
            patternId = `${pattern}-${colorKey}-sw${strokeWidth}`
            definePattern(map, patternId, pattern, color, strokeWidth)
        }

        config.patternId = patternId

        regionIds.forEach((regionId) => {
            if (!regionToPatternIds[regionId]) {
                regionToPatternIds[regionId] = []
            }
            regionToPatternIds[regionId].push(patternId)
        })
    })

    // Apply all patterns for each region (stacking them)
    map.svg()
        .selectAll((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getRegionsSelector)(map))
        .each(function (d) {
            const id = d?.properties?.id
            const patternIds = regionToPatternIds[id]

            if (patternIds && patternIds.length) {
                const original = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this)

                patternIds.forEach((patternId) => {
                    const clone = original.node().cloneNode(true)

                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(clone)
                        .attr('fill', `url(#${patternId})`)
                        .attr('pointer-events', 'none')
                        .attr('class', (original.attr('class') || '') + ' pattern-fill-overlay')

                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parentNode).append(() => clone)
                })
            }
        })
}

function definePattern(map, patternId, patternName, color, strokeWidth) {
    const defs = map.svg().select('defs')

    if (
        map
            .svg()
            .select(`#${CSS.escape(patternId)}`)
            .empty()
    ) {
        const pattern = defs.append('pattern').attr('id', patternId).attr('patternUnits', 'userSpaceOnUse').attr('width', 8).attr('height', 8)

        if (patternName === 'hatching') {
            pattern.append('path').attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2').attr('stroke', color).attr('stroke-width', strokeWidth)
        } else if (patternName === 'crosshatch') {
            pattern.append('path').attr('d', 'M0,0 l8,8 M8,0 l-8,8').attr('stroke', color).attr('stroke-width', strokeWidth)
        } else if (patternName === 'dots') {
            pattern.append('circle').attr('cx', 4).attr('cy', 4).attr('r', strokeWidth).attr('fill', color)
        } else {
            console.warn(`Unknown pattern "${patternName}", defaulting to hatching.`)
            pattern.append('path').attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2').attr('stroke', color).attr('stroke-width', strokeWidth)
        }
    }
}


/***/ }),

/***/ "./src/core/stamps.js":
/*!****************************!*\
  !*** ./src/core/stamps.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendStamp: () => (/* binding */ appendStamp)
/* harmony export */ });
const appendStamp = (stampConfig, map) => {
    if (map.svg_) {
        const existing = map.svg_.select('#em-stamp')
        existing.remove()

        if (stampConfig) {
            const container = map.svg_.append('g').attr('id', 'em-stamp')

            // Set defaults
            if (!stampConfig.size) stampConfig.size = 60
            if (!stampConfig.x) stampConfig.x = 230
            if (!stampConfig.y) stampConfig.y = 100
            if (!stampConfig.textColor) stampConfig.textColor = '#000'
            if (!stampConfig.stampColor) stampConfig.stampColor = '#000'
            if (!stampConfig.strokeWidth) stampConfig.strokeWidth = 1
            if (!stampConfig.lineHeight) stampConfig.lineHeight = 15

            // Draw the circle
            container
                .append('circle')
                .attr('r', stampConfig.size)
                .attr('cx', stampConfig.x)
                .attr('cy', stampConfig.y)
                .attr('id', 'em-stamp-circle')
                .attr('fill', 'none')
                .attr('stroke', stampConfig.stampColor)
                .attr('stroke-width', stampConfig.strokeWidth)

            // Handle text
            const text = stampConfig.text
            const targetWidth = Math.sqrt(measureWidth(text.trim()) * stampConfig.lineHeight)
            const lines = getLines(getWords(text.trim()), targetWidth)
            const textRadius = getTextRadius(lines, stampConfig.lineHeight)

            // Append inside circle
            container
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('fill', stampConfig.textColor)
                .attr('id', 'em-stamp-text')
                .attr('transform', `translate(${stampConfig.x},${stampConfig.y}) scale(${stampConfig.size / textRadius})`)
                .selectAll('tspan')
                .data(lines)
                .enter()
                .append('tspan')
                .attr('x', 0)
                .attr('y', (d, i) => (i - lines.length / 2 + 0.8) * stampConfig.lineHeight)
                .text((d) => d.text.replaceAll('~', ' ').replaceAll('', '')) // Removes  (line breaker) and ~ (non breaking space)
        }
    }
}

// Splitting by both spaces and pilcrows
const getWords = (text) => {
    return text
        .split(/(?<=)|\s+/g)
        .map((word) => word.trim())
        .filter((word) => word.length > 0)
}

// Computes text width
const measureWidth = (text) => {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text')

    textElement.textContent = text
    svg.appendChild(textElement)
    document.body.appendChild(svg)

    const width = textElement.getComputedTextLength()
    document.body.removeChild(svg)

    return width + 10
}

// Compute text radius
const getTextRadius = (lines, lineHeight) => {
    let radius = 0
    for (let i = 0, n = lines.length; i < n; ++i) {
        const dy = (Math.abs(i - n / 2 + 0.5) + 0.5) * lineHeight
        const dx = lines[i].width / 2
        radius = Math.max(radius, Math.sqrt(dx ** 2 + dy ** 2))
    }
    return radius
}

// Handles forced line breaks
const getLines = (words, targetWidth) => {
    let lines = []
    let line = { width: 0, text: '' }

    for (let i = 0, n = words.length; i < n; ++i) {
        if (words[i] === '') {
            // Push current line (if it has text)
            if (line.text) lines.push(line)
            // Start a new empty line
            line = { width: 0, text: '' }
            continue
        }

        let lineText1 = (line.text ? line.text + ' ' : '') + words[i]
        let lineWidth1 = measureWidth(lineText1)

        if ((line.width + lineWidth1) / 2 < targetWidth) {
            line.width = lineWidth1
            line.text = lineText1
        } else {
            lines.push(line)
            line = { width: measureWidth(words[i]), text: words[i] }
        }
    }

    if (line.text) lines.push(line) // Push last line if it exists

    return lines
}


/***/ }),

/***/ "./src/core/stat-data.js":
/*!*******************************!*\
  !*** ./src/core/stat-data.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   statData: () => (/* binding */ statData)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonstat-toolkit */ "./node_modules/jsonstat-toolkit/import.mjs");





/**
 * A statistical dataset, to be used for a statistical map.
 *
 * @param {*} config
 */
const statData = function (config) {
    //build stat data object
    const out = {}

    out.__data = undefined //for debugging

    //out.maxNumberOfDecimalsInDataset = undefined

    /**
     * The statistical values, indexed by NUTS id.
     * Each stat value is an object {value,status}.
     */
    out._data_ = undefined

    /**
     * Return the stat value {value,status} from a nuts id.
     * If no argument is specified, returns the entire index.
     * @param {*} nutsId
     */
    out.get = (nutsId) => {
        if (!nutsId) {
            return out._data_
        } else {
            if (out._data_) {
                return out._data_[nutsId]
            } else {
                return undefined
            }
        }
    }

    /**
     * Return the stat value from a nuts id.
     * @param {*} nutsId
     */
    out.getValue = (nutsId) => {
        const s = out.get(nutsId)
        return s ? s.value : undefined
    }

    /**
     * Set a stat value from a nuts id.
     *
     * @param {String} nutsId
     * @param {Object || String || Number} stat The new statistical data. The format can be either {value:34.324,status:"e"} or a the value only.
     */
    out.set = (nutsId, stat) => {
        out._data_ = out._data_ || {}
        const s = out._data_[nutsId]

        if (s) {
            if (stat.value) {
                s.value = stat.value
                s.status = stat.status
            } else {
                // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
                s.value = stat
                //s.value = isNaN(+stat) ? stat : +stat
            }
        } else {
            // be careful here setting values here, we need to maintain strings with trailing zeros because in JSON 1.0 === 1 and they are removed. User might want stats labels with trailing zeros.
            out._data_[nutsId] = stat.value ? stat : { value: stat }
            //out._data_[nutsId] = stat.value ? stat : { value: isNaN(+stat) ? stat : +stat}
        }
        return out
    }

    /**
     * Set statistical data, already indexed by nutsId.
     *
     * @param {Object} data Something like: { "PT":0.2, "LU":0.6, ...}, or with status: { "PT": {value:0.2, status:"e"}, "LU":0.6, ...}
     */
    out.setData = (data) => {
        out.__data = data // for debugging
        out._data_ = {} // overwrite existing data
        Object.keys(data).forEach((nutsId) => out.set(nutsId, data[nutsId]))
        return out
    }

    //eg for sparklines
    out.setManualMultiDate = function (dataObject) {
        out._data_ = out._data_ || {}

        for (const regionId in dataObject) {
            const dateValueMap = dataObject[regionId]
            out._data_[regionId] = {}

            for (const date in dateValueMap) {
                const value = dateValueMap[date]
                out._data_[regionId][date] = { value: value }
            }
        }

        return out
    }

    /** Return all stat values as an array. This can be used to classify the values. */
    out.getArray = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || s)
        }
    }

    /** Return stat unique values. This can be used for categorical maps. */
    out.getUniqueValues = function () {
        return Object.values(out._data_)
            .map((s) => s.value)
            .filter((item, i, ar) => ar.indexOf(item) === i)
    }

    /** Get min value. */
    out.getMin = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.min(acc, v))
        }
    }
    /** Get max value. */
    out.getMax = function () {
        if (out._data_) {
            return Object.values(out._data_)
                .map((s) => s.value)
                .filter((s) => s == 0 || (s && s !== ':'))
                .reduce((acc, v) => Math.max(acc, v))
        }
    }

    /** Check if the stat data is ready. */
    out.isReady = function () {
        return out._data_ != undefined
    }

    /** Some metadata */
    out.metadata = undefined

    //a text for the statitics unit of measure, to be shown in the tooltip
    out.unitText_ = undefined

    /**
     * Retrieve stat data from remote data sources.
     *
     * @param {*} nutsLevel
     * @param {*} callback
     */
    out.retrieveFromRemote = function (nutsLevel, lang, callback) {
        if (out.eurostatDatasetCode_) updateEurobase(nutsLevel, lang, callback)
        else if (out.csvURL_) updateCSV(callback)
        return out
    }

    //TODO decompose into Eurobase/jsonstat and CSV types ?

    /**
     * Eurobase/jsonstat data source
     * See https://ec.europa.eu/eurostat/web/json-and-unicode-web-services/getting-started/rest-request
     */

    /** The Eurobase dataset code */
    out.eurostatDatasetCode_ = undefined
    /** The Eurobase code */
    out.filters_ = { lastTimePeriod: 1 }
    /** The precision (number of decimal places) */
    out.precision_ = 2

    /**
     * Return promise for Eurobase/jsonstat data.
     */
    const getEurobasePromise = function (nutsLevel, lang) {
        //set precision //DEPRECATED 16/11/2021 https://ec.europa.eu/eurostat/online-help/public/en/NAVIGATION_WDDSTranslator_migration_en/#DECOMMISSION
        //out.filters_["precision"] = out.precision_;
        //select only required geo groups, depending on the specified nuts level
        if (!out.filters_.geo) {
            out.filters_['geoLevel'] = nutsLevel + '' === '0' ? 'country' : 'nuts' + nutsLevel
        }

        //force filtering of euro-geo-aggregates
        //out.filters_["filterNonGeo"] = 1; //DEPRECATED 16/11/2021

        //retrieve stat data from Eurostat API
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getEstatDataURL)(out.eurostatDatasetCode_, out.filters_, lang))
    }

    //for eurobase statistical data to retrieve from Eurostat API
    const updateEurobase = function (nutsLevel, lang, callback) {
        //erase previous data
        out._data_ = null

        getEurobasePromise(nutsLevel, lang).then(function (data___) {
            //decode stat data
            const jsd = (0,jsonstat_toolkit__WEBPACK_IMPORTED_MODULE_1__["default"])(data___)

            //store jsonstat metadata
            out.metadata = {
                label: jsd.label,
                href: jsd.href,
                source: jsd.source,
                updated: jsd.updated,
                extension: jsd.extension,
            }
            out.metadata.time = jsd.Dimension('time').id[0]

            //index
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.jsonstatToIndex)(jsd)
            //TODO: use maybe https://github.com/badosa/JSON-stat/blob/master/utils/fromtable.md to build directly an index ?

            if (callback) callback()
        })
    }

    /**
     * Return the time stamp of the jsonstat dataset.
     */
    out.getTime = function () {
        const t = out.filters_.time
        if (t) return t
        if (!out._data_) return
        return out.metadata.time
    }

    /**
     * CSV data source
     */

    /** The CSV file URL */
    out.csvURL_ = undefined
    /** The CSV column with the NUTS ids */
    out.geoCol_ = 'geo'
    /** The CSV column with the statistical values */
    out.valueCol_ = 'value'

    /**
     * Return promise for CSV data.
     */
    const getCSVPromise = function (nutsLevel) {
        return (0,d3_fetch__WEBPACK_IMPORTED_MODULE_3__.csv)(out.csvURL_)
    }

    //for statistical data to retrieve from CSV file
    const updateCSV = function (callback) {
        //erase previous data
        out._data_ = null

        //retrieve csv data
        getCSVPromise().then(function (data___) {
            //decode stat data
            out._data_ = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.csvToIndex)(data___, out.geoCol_, out.valueCol_)

            //store some metadata
            out.metadata = { href: out.csvURL_ }

            if (callback) callback()
        })
    }

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['unitText_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config) for (let key in config) out[key + '_'] = config[key]

    return out
}


/***/ }),

/***/ "./src/core/stat-map.js":
/*!******************************!*\
  !*** ./src/core/stat-map.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getURLParameters: () => (/* binding */ getURLParameters),
/* harmony export */   statMap: () => (/* binding */ statMap)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/core/utils.js");
/* harmony import */ var _map_template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-template */ "./src/core/map-template.js");
/* harmony import */ var _stat_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat-data */ "./src/core/stat-data.js");
/* harmony import */ var _legend_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../legend/legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tooltip/tooltip */ "./src/tooltip/tooltip.js");







/**
 * An abstract statistical map: A map template with statistical data, without any particular styling rule.
 *
 * @param {*} withCenterPoints Set to true (or 1) to add regions center points to the map template, to be used for proportional symbols maps for example.
 */
const statMap = function (config, withCenterPoints, mapType) {
    //build stat map from map template
    const out = _map_template__WEBPACK_IMPORTED_MODULE_1__.mapTemplate(config, withCenterPoints, mapType)

    //statistical data

    //the statistical data configuration.
    //A map can have several stat datasets. This is a dictionary of all stat configuration
    out.stat_ = { default: undefined }
    out.stat = function (k, v) {
        //no argument: getter - return the default stat
        if (!arguments.length) return out.stat_['default']
        //two arguments: setter - set the config k with value v
        if (arguments.length == 2) {
            out.stat_[k] = v
            return out
        }
        //one string argument: getter - return the config k
        if (typeof k === 'string' || k instanceof String) return out.stat_[k]
        //one non-string argument: setter - set the entire dictionnary
        out.stat_ = k.default ? k : { default: k }
        return out
    }

    //the statistical data, retrieved from the config information. As a dictionary.
    out.statData_ = {
        default: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        color: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        size: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v1: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(),
        v2: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //bivariate
        v3: _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(), //trivariate
    }
    out.statData = function (k, v) {
        if (!arguments.length) return out.statData_['default']

        // lazy create if not exist
        if (arguments.length === 1) {
            if (!out.statData_[k]) out.statData_[k] = _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData()
            return out.statData_[k]
        }

        // setter
        out.statData_[k] = v
        return out
    }

    //test for no data case
    out.noDataText_ = 'No data available'
    //langage (currently used only for eurostat data API)
    out.language_ = 'en'
    //transition time for rendering
    out.transitionDuration_ = 500
    //specific tooltip text function
    out.tooltip_.textFunction = undefined
    //for maps using special fill patterns, this is the function to define them in the SVG image - See functions: getFillPatternLegend and getFillPatternDefinitionFun
    out.filtersDefinitionFunction_ = undefined
    //a callback function to execute after the map build is complete.
    out.callback_ = undefined

    //legend configuration
    out.legend_ = undefined
    //legend object
    out.legendObj_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['legend_', 'legendObj_', 'noDataText_', 'language_', 'transitionDuration_', 'tooltipText_', 'filtersDefinitionFunction_', 'callback_'].forEach(
        function (att) {
            out[att.substring(0, att.length - 1)] = function (v) {
                if (!arguments.length) return out[att]
                out[att] = v
                return out
            }
        }
    )

    //override attribute values with config values
    if (config) for (let key in config) if (out[key] && config[key] != undefined) out[key](config[key])

    // override legend for updating after build
    out.legend = function (v) {
        if (!arguments.length) return out.legend_

        // clear existing legend
        if (v == false) {
            const legend = out.legendObj()
            if (legend) {
                const legendSvg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#' + legend.svgId)
                if (legendSvg.size() > 0) {
                    legendSvg.selectAll('*').remove()
                }
            }
            out.legend_ = v
            return out
        }
        //set new legend config
        out.legend_ = v
        //update if existing legend
        if (out.legendObj_) out.updateLegend()
        return out
    }

    out.updateLegend = function (v) {
        if (out.legendObj_) out.legendObj().update()
        return out
    }

    /**
     * Build the map.
     * This method should be called once, preferably after the map attributes have been set to some initial values.
     */
    out.build = function () {
        if (out.projectionFunction_) out.proj('4326') //when using custom d3 projection function always request NUTS2JSON in WGS84

        //build map template base
        out.buildMapTemplateBase()

        //add additional filters for fill patterns for example
        if (out.filtersDefinitionFunction_) {
            out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        }

        //legend element
        if (out.legend()) {
            out.buildLegend()
        }

        //define tooltip
        //prepare map tooltip
        if (out.tooltip_) {
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip(out.tooltip_)
        } else {
            //no config specified, use default
            out._tooltip = _tooltip_tooltip__WEBPACK_IMPORTED_MODULE_4__.tooltip()
        }

        //launch geo data retrieval
        out.updateGeoData()

        //launch stat data retrieval
        out.updateStatData()

        return out
    }

    out.buildLegend = function () {
        //create legend object
        out.legendObj(out.getLegendConstructor()(out, out.legend()))
        const legend = out.legendObj()

        //get legend svg. If it does not exist, create it embeded within the map
        let legendSvg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])('#' + legend.svgId)
        if (legendSvg.size() == 0) {
            //get legend position
            const x = legend.x == undefined ? out.width() - 100 - legend.boxPadding : legend.x
            const y = legend.y == undefined ? legend.boxPadding : legend.y

            //build legend SVG in a new group
            out.svg()
                .append('g')
                .attr('id', legend.svgId)
                .attr('class', 'em-legend')
                .attr('transform', 'translate(' + x + ',' + y + ')')
        }

        legend.build()
    }

    /** Check if all stat datasets have been loaded. */
    const isStatDataReady = function () {
        for (const key in out.statData_) {
            const hasConfig = !!out.stat_[key]
            const hasManualData = !!(out.statData_[key] && out.statData_[key].get())

            if (!hasConfig && !hasManualData) continue
            if (!out.statData_[key].isReady()) return false
        }
        return true
    }

    /**
     * Launch map geo data retrieval, and make/update the map once received.
     * This method should be called after attributes related to the map geometries have changed, to retrieve this new data and refresh the map.
     */
    out.updateGeoData = function () {
        out.updateGeoMapTemplate(() => {
            //if stat datasets have not been loaded, wait again
            if (!isStatDataReady()) return

            //proceed with map construction
            out.updateStatValues()
            //execute callback function
            if (out.callback()) out.callback()(out)
        })

        return out
    }

    /**
     * Launch map geo stat datasets retrieval, and make/update the map once received.
     * This method should be called after specifications on the stat data sources attached to the map have changed, to retrieve this new data and refresh the map.
     */
    out.updateStatData = function () {
        for (let statKey in out.stat_) {
            const config = out.stat(statKey)
            const manualData = out.statData(statKey).get?.()

            // Skip if neither stat config nor manual data
            if (!config && !manualData) continue

            // If there's a config, build the statData object (or replace existing)
            if (config) {
                const statData = _stat_data__WEBPACK_IMPORTED_MODULE_2__.statData(config)
                out.statData(statKey, statData)

                // Launch remote retrieval
                let nl = out.nutsLevel_
                if (nl === 'mixed') nl = 0

                statData.retrieveFromRemote(nl, out.language(), () => {
                    if (!out.Geometries.isGeoReady()) return
                    if (!isStatDataReady()) return

                    out.updateStatValues()
                    if (out.callback()) out.callback()(out)
                })
            }
        }

        return out
    }

    /**
     * Make/update the map with new stat data.
     * This method should be called after stat data attached to the map have changed, to refresh the map.
     * If the stat data sources have changed, call *updateStatData* instead.
     */
    out.updateStatValues = function () {
        //update classification and styles
        out.updateClassification()
        out.updateStyle()

        //update legend, if any
        if (out.legend_ && out.legendObj()) out.legendObj().update()

        return out
    }

    /**
     * Abstract method.
     * Make/update the map after classification attributes have been changed.
     * For example, if the number of classes, or the classification method has changed, call this method to update the map.
     */
    out.updateClassification = function () {
        console.log('Map updateClassification function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Make/update the map after styling attributes have been changed.
     * For example, if the style (color?) for one legend element has changed, call this method to update the map.
     */
    out.updateStyle = function () {
        console.log('Map updateStyle function not implemented')
        return out
    }

    /**
     * Abstract method.
     * Function which return the legend constructor function for the map.
     */
    out.getLegendConstructor = function () {
        console.log('Map getLegendConstructor function not implemented')
        return _legend_legend__WEBPACK_IMPORTED_MODULE_3__.legend
    }

    /**
     * Retrieve the time stamp of the map, even if not specified in the dimension initially.
     * This applies only for stat data retrieved from Eurostat API.
     * This method is useful for example when the data retrieved is the freshest, and one wants to know what this date is, for example to display it in the map title.
     */
    out.getTime = function () {
        return out.statData('default').getTime()
    }

    /**
     * Set some map attributes based on the following URL parameters:
     * "w":width, "h":height, "x":xGeoCenter, "y":yGeoCenter, "z":pixGeoSize, "s":scale, "lvl":nuts level, "time":time,
     * "proj":CRS, "geo":geo territory, "ny":nuts version, "language":langage, "numberOfClasses":class number
     */
    out.setFromURL = function () {
        const opts = getURLParameters()
        if (opts.w) out.width(opts.w)
        if (opts.h) out.height(opts.h)
        if (opts.x && opts.y) out.geoCenter([opts.x, opts.y])
        if (opts.z) out.pixelSize(opts.z)
        if (opts.s) out.scale(opts.s)
        if (opts.lvl) out.nutsLevel(opts.lvl)
        if (opts.time) {
            out.filters_.time = opts.time
            delete out.filters_.lastTimePeriod
        }
        if (opts.proj) out.proj(opts.proj)
        if (opts.geo) out.geo(opts.geo)
        if (opts.ny) out.nutsYear(opts.ny)
        if (opts.language) out.language(opts.language)
        if (opts.numberOfClasses) out.numberOfClasses(+opts.numberOfClasses)
        return out
    }

    /**
     * @function exportMapToSVG
     * @description Exports the current map with styling to SVG and downloads it
     *
     */
    out.exportMapToSVG = function () {
        // Clone the original SVG node to avoid modifying the DOM
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Add XML namespaces if not already present
        if (!svgNodeClone.hasAttribute('xmlns')) {
            svgNodeClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
        }
        if (!svgNodeClone.hasAttribute('xmlns:xlink')) {
            svgNodeClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
        }

        // Temporarily append the clone to the document to compute styles
        document.body.appendChild(svgNodeClone)

        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Remove the cloned SVG from the document after applying styles
        document.body.removeChild(svgNodeClone)

        const svgUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getDownloadURL)(svgNodeClone)

        // Create a download link and trigger download
        const downloadLink = document.createElement('a')
        downloadLink.href = svgUrl
        downloadLink.download = 'eurostatmap.svg'
        document.body.appendChild(downloadLink)
        downloadLink.click()
        document.body.removeChild(downloadLink)

        return out
    }

    /**
     * @function exportMapToPNG
     * @description Exports the current map with styling to PNG and downloads it
     *
     */
    out.exportMapToPNG = function (width, height) {
        const svgNodeClone = out.svg_.node().cloneNode(true)
        // Convert CSS to inline styles before saving the SVG
        ;(0,_utils__WEBPACK_IMPORTED_MODULE_0__.applyInlineStylesFromCSS)(svgNodeClone)

        // Step 1: Serialize the SVG node to a string
        const serializer = new XMLSerializer()
        const svgString = serializer.serializeToString(svgNodeClone)

        // Step 2: Create a Blob from the serialized SVG
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' })

        // Step 3: Create a URL for the Blob
        const url = URL.createObjectURL(svgBlob)

        // Get the width and height attributes from the SVG
        width = width || svgNodeClone.getAttribute('width')
        height = height || svgNodeClone.getAttribute('height')

        if (!width || !height) {
            throw new Error('SVG width or height attributes are missing or invalid.')
        }

        // Step 4: Create an Image element and load the Blob URL
        const img = new Image()
        img.onload = function () {
            // Step 5: Draw the image on a canvas
            const canvas = document.createElement('canvas')
            canvas.width = parseFloat(width) // Set canvas width from SVG's width attribute
            canvas.height = parseFloat(height) // Set canvas height from SVG's height attribute

            const context = canvas.getContext('2d')
            context.drawImage(img, 0, 0, canvas.width, canvas.height)

            // Step 6: Convert the canvas to a PNG blob
            canvas.toBlob(function (pngBlob) {
                // Step 7: Download the PNG file
                const pngUrl = URL.createObjectURL(pngBlob)
                const downloadLink = document.createElement('a')
                downloadLink.href = pngUrl
                downloadLink.download = 'eurostat-map.png'
                document.body.appendChild(downloadLink)
                downloadLink.click()
                document.body.removeChild(downloadLink)

                // Clean up URLs
                URL.revokeObjectURL(url)
                URL.revokeObjectURL(pngUrl)
            }, 'image/png')
        }

        // Set the image source to the Blob URL
        img.src = url
        return out
    }

    return out
}

/**
 * Retrieve some URL parameters, which could be then reused as map definition parameters.
 * This allow a quick map customisation by simply adding and changing some URL parameters.
 * See map method: setFromURL(...)
 */
const getURLParameters = function () {
    const ps = {}
    const p = ['w', 'h', 'x', 'y', 'z', 's', 'lvl', 'time', 'proj', 'geo', 'ny', 'language', 'sl', 'numberOfClasses']
    for (let i = 0; i < p.length; i++) ps[p[i]] = getURLParameterByName(p[i])
    return ps
}


/***/ }),

/***/ "./src/core/utils.js":
/*!***************************!*\
  !*** ./src/core/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyInlineStylesFromCSS: () => (/* binding */ applyInlineStylesFromCSS),
/* harmony export */   convertRectanglesToPaths: () => (/* binding */ convertRectanglesToPaths),
/* harmony export */   csvToIndex: () => (/* binding */ csvToIndex),
/* harmony export */   executeForAllInsets: () => (/* binding */ executeForAllInsets),
/* harmony export */   flags: () => (/* binding */ flags),
/* harmony export */   getBBOXAsGeoJSON: () => (/* binding */ getBBOXAsGeoJSON),
/* harmony export */   getCSSPropertyFromClass: () => (/* binding */ getCSSPropertyFromClass),
/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),
/* harmony export */   getEstatDataURL: () => (/* binding */ getEstatDataURL),
/* harmony export */   getEstatRestDataURLBase: () => (/* binding */ getEstatRestDataURLBase),
/* harmony export */   getFontSizeFromClass: () => (/* binding */ getFontSizeFromClass),
/* harmony export */   getLegendRegionsSelector: () => (/* binding */ getLegendRegionsSelector),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   getRegionsSelector: () => (/* binding */ getRegionsSelector),
/* harmony export */   getTextColorForBackground: () => (/* binding */ getTextColorForBackground),
/* harmony export */   getURLParameterByName: () => (/* binding */ getURLParameterByName),
/* harmony export */   hexToRgb: () => (/* binding */ hexToRgb),
/* harmony export */   jsonstatToIndex: () => (/* binding */ jsonstatToIndex),
/* harmony export */   lowerCaseAllWordsExceptFirstLetters: () => (/* binding */ lowerCaseAllWordsExceptFirstLetters),
/* harmony export */   multiplyBlendMultipleHex: () => (/* binding */ multiplyBlendMultipleHex),
/* harmony export */   rasterize: () => (/* binding */ rasterize),
/* harmony export */   serialize: () => (/* binding */ serialize),
/* harmony export */   spaceAsThousandSeparator: () => (/* binding */ spaceAsThousandSeparator),
/* harmony export */   updateCSSRule: () => (/* binding */ updateCSSRule),
/* harmony export */   upperCaseFirstLetter: () => (/* binding */ upperCaseFirstLetter)
/* harmony export */ });
// e.g. to be used with deprecated .style() functions. They will now update CSS classes.
function updateCSSRule(selector, property, value) {
    // Validate the selector
    if (!selector.startsWith('.') && !selector.startsWith('#')) {
        throw new Error('Invalid selector: Must start with "." for classes or "#" for IDs.')
    }

    // Check if the rule already exists in any stylesheet
    const styleSheets = Array.from(document.styleSheets)
    for (const styleSheet of styleSheets) {
        try {
            const rules = styleSheet.cssRules || styleSheet.rules
            for (const rule of rules) {
                if (rule.selectorText === selector) {
                    // Update the property if the rule exists
                    rule.style[property] = value
                    return
                }
            }
        } catch (e) {
            // Some stylesheets (e.g., cross-origin) may not be accessible
            console.warn(`Could not access rules in stylesheet:`, e)
        }
    }

    // If the rule doesn't exist, create a new stylesheet and add it
    let customSheet = document.getElementById('custom-styles')
    if (!customSheet) {
        customSheet = document.createElement('style')
        customSheet.id = 'custom-styles'
        document.head.appendChild(customSheet)
    }

    // Add the new rule to the custom stylesheet
    try {
        customSheet.sheet.insertRule(`${selector} { ${property}: ${value}; }`, customSheet.sheet.cssRules.length)
    } catch (e) {
        console.error(`Failed to insert rule: ${selector} { ${property}: ${value}; }`, e)
    }
}

const getFontSizeFromClass = function (className) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'
    tempElement.style.fontSize = 'initial'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed font-size property and parse it to a number
    const fontSize = parseFloat(window.getComputedStyle(tempElement).fontSize)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return fontSize || 0
}

const getCSSPropertyFromClass = function (className, propertyName) {
    // Create a temporary element with the specified class
    const tempElement = document.createElement('div')
    tempElement.className = className

    // Apply inline styles to minimize layout interference
    tempElement.style.position = 'absolute'
    tempElement.style.visibility = 'hidden'
    tempElement.style.height = 'auto'
    tempElement.style.width = 'auto'
    tempElement.style.lineHeight = 'normal'

    // Append directly to the body
    document.body.appendChild(tempElement)

    // Get the computed value of the specified property
    const propertyValue = window.getComputedStyle(tempElement).getPropertyValue(propertyName)

    // Remove the temporary element from the document body
    document.body.removeChild(tempElement)

    return propertyValue || null
}

// Helper function to get all CSS rules defined in the document
function getAllCSSRules() {
    let cssRules = []
    for (let sheet of document.styleSheets) {
        try {
            // Some stylesheets may not be accessible due to CORS, so we catch any errors
            for (let rule of sheet.cssRules) {
                cssRules.push(rule)
            }
        } catch (e) {
            console.warn('Unable to access stylesheet:', sheet.href, e)
        }
    }
    return cssRules
}

// Helper function to get explicitly defined styles from CSS for an element
function getStylesFromCSS(element) {
    let matchedRules = []
    const cssRules = getAllCSSRules()

    cssRules.forEach((rule) => {
        if (element.matches(rule.selectorText)) {
            matchedRules.push(rule.style)
        }
    })

    // Create an object of the explicitly set styles
    let explicitStyles = {}
    matchedRules.forEach((style) => {
        for (let i = 0; i < style.length; i++) {
            const property = style[i]
            explicitStyles[property] = style.getPropertyValue(property)
        }
    })

    return explicitStyles
}

// Helper function to apply inline styles explicitly set in CSS. Useful for exporting SVGs with CSS styles.
const applyInlineStylesFromCSS = (svgElement) => {
    const allElements = svgElement.querySelectorAll('*')

    allElements.forEach((element) => {
        const cssStyles = getStylesFromCSS(element)

        // Apply each explicitly defined CSS style as an inline style
        Object.keys(cssStyles).forEach((property) => {
            const value = cssStyles[property]

            // Check if the property already has an inline style
            const existingInlineStyle = element.style.getPropertyValue(property)

            if (!existingInlineStyle && value) {
                // If no existing inline style, set the new style
                element.style.setProperty(property, value)
            }
        })
    })
}

/**
 * Return a GeoJSON feature representing a bounding box, with multipoint geometry.
 * This bounding box is an array like the one in topojson bbox element.
 * [xmin,ymin,xmax,ymax]
 * This is useful for to call d3.fitSize([w, h], getTopoJSONExtentAsGeoJSON(topo.bbox)))
 *
 * @param {*} bb The bounding box [xmin,ymin,xmax,ymax]. For topojson data, just give the topojson.bbox element.
 */
const getBBOXAsGeoJSON = function (bb) {
    return {
        type: 'Feature',
        geometry: {
            type: 'MultiPoint',
            coordinates: [
                [bb[0], bb[1]],
                [bb[2], bb[3]],
            ],
        },
    }
}

// indexing

/**
 * Index JSONStat stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} jsData The JSONStat data to index
 */
const jsonstatToIndex = function (jsData) {
    const ind = {}
    const geos = jsData.Dimension('geo').id
    for (let i = 0; i < geos.length; i++) ind[geos[i]] = jsData.Data(i)
    return ind
}

/**
 * Index CSV stat values by 'geo' code.
 * Return a structure like: {geo:{value:0,status:""}}
 *
 * @param {*} csvData The CSV data to index
 * @param {*} geoCol The name of the geo column in the CSV data
 * @param {*} valueCol The name of the statistical value column in the CSV file.
 */
const csvToIndex = function (csvData, geoCol, valueCol) {
    const ind = {}
    for (let i = 0; i < csvData.length; i++) {
        const d = csvData[i]
        const v = d[valueCol]
        if (!v) {
            ind[d[geoCol]] = { value: ':', status: '' }
        } else {
            ind[d[geoCol]] = { value: isNaN(+v) ? v : +v, status: '' }
        }
    }
    return ind
}

/**
 * @description returns string with space as thousand separator
 * @function spaceAsThousandSeparator
 * @param {number} number
 */
const spaceAsThousandSeparator = function (number) {
    return number.toLocaleString('en').replace(/,/gi, ' ')
}

//REST API
const getEstatRestDataURLBase = 'https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/'

/**
 * Build URL to fetch data from eurobase REST API.
 * @param {string} datasetCode The Eurobase dataset code
 * @param {object=} filters The filter parameters as for example: {key:value,key:[value1,value2,value3]}
 * @param {number=} lang
 * @param {number=} format
 * @param {number=} version
 */
const getEstatDataURL = function (datasetCode, filters, lang, format) {
    lang = lang || 'en'
    format = format || 'json'
    var url = []
    url.push(getEstatRestDataURLBase, datasetCode, '?', 'format=', format, '&lang=', lang)
    if (filters)
        for (var param in filters) {
            var o = filters[param]
            if (Array.isArray(o)) for (var i = 0; i < o.length; i++) url.push('&', param, '=', o[i])
            else url.push('&', param, '=', o)
        }
    return url.join('')
}

/**
 * @param {string} name
 * @returns {string}
 */
const getURLParameterByName = function (name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

//flags
const flags = {
    b: 'break in time series',
    c: 'confidential',
    d: 'definition differs, see metadata',
    e: 'estimated',
    f: 'forecast',
    n: 'not significant',
    p: 'provisional',
    r: 'revised',
    s: 'Eurostat estimate',
    u: 'low reliability',
    z: 'not applicable',
}

/**
 * @description Executes a function for all inset maps. Some insets might be external SVGs which is why this function was created.
 * @param {*} insets map.insets
 * @param {*} mainSvgId the ID of the map's svg
 * @param {*} callback the function to execute for each inset
 * @param {*} [parameter=null] the parameter to pass to the callback
 * @param {*} [parameter2=null] the parameter to pass to the callback
 */
const executeForAllInsets = function (insets, mainSvgId, callback, parameter = null, parameter2 = null) {
    for (const geo in insets) {
        const insetGroup = insets[geo]

        if (Array.isArray(insetGroup)) {
            insetGroup.forEach((inset) => {
                // Handle nested arrays for multiple insets with the same geo
                if (Array.isArray(inset)) {
                    inset.forEach((nestedInset) => {
                        if (nestedInset.svgId_ !== mainSvgId) {
                            callback(nestedInset, parameter, parameter2)
                        }
                    })
                } else {
                    if (inset.svgId_ !== mainSvgId) {
                        callback(inset, parameter, parameter2)
                    }
                }
            })
        } else {
            // Apply callback to unique inset
            if (insetGroup.svgId_ !== mainSvgId) {
                callback(insetGroup, parameter, parameter2)
            }
        }
    }
}

const upperCaseFirstLetter = (string) => `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`

const lowerCaseAllWordsExceptFirstLetters = (string) =>
    string.replaceAll(/\S*/g, (word) => `${word.slice(0, 1)}${word.slice(1).toLowerCase()}`)

function getDownloadURL(svgNode) {
    // Create XML header to ensure the SVG is recognized properly
    const xmlHeader = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'

    // create blob
    const svgContent = xmlHeader + svgNode.outerHTML
    const svgBlob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' })
    const svgUrl = URL.createObjectURL(svgBlob)
    return svgUrl
}

// Rasterize function with additional error handling
function serialize(svg) {
    const xmlns = 'http://www.w3.org/2000/xmlns/'
    const xlinkns = 'http://www.w3.org/1999/xlink'
    const svgns = 'http://www.w3.org/2000/svg'
    const fragment = window.location.href + '#'
    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false)
    while (walker.nextNode()) {
        for (const attr of walker.currentNode.attributes) {
            if (attr.value.includes(fragment)) {
                attr.value = attr.value.replace(fragment, '#')
            }
        }
    }
    svg.setAttributeNS(xmlns, 'xmlns', svgns)
    svg.setAttributeNS(xmlns, 'xmlns:xlink', xlinkns)
    const serializer = new window.XMLSerializer()
    const string = serializer.serializeToString(svg)
    return new Blob([string], { type: 'image/svg+xml' })
}

// adapted from https://observablehq.com/@mbostock/saving-sv
//svg to canvas blob promise
function rasterize(svg) {
    let resolve, reject
    const promise = new Promise((y, n) => ((resolve = y), (reject = n)))
    const image = new Image()
    image.onerror = reject
    image.onload = () => {
        const rect = svg.getBoundingClientRect()
        const canvas = document.createElement('canvas')
        canvas.width = rect.width
        canvas.height = rect.height
        const context = canvas.getContext('2d')
        context.drawImage(image, 0, 0, rect.width, rect.height)
        context.canvas.toBlob(resolve)
    }
    image.src = URL.createObjectURL(serialize(svg))
    return promise
}

/**
 * Get a URL parameter by name.
 *
 * @param {string} name
 * @returns {string | null}
 */
function getParameterByName(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
    let regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
        results = regex.exec(location.search)
    return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
}

const hexToRgb = (hex) => {
    hex = hex.replace('#', '')
    if (hex.length === 3) {
        hex = hex
            .split('')
            .map((h) => h + h)
            .join('')
    }
    const int = parseInt(hex, 16)
    return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
}

//blends two colors using 'multiply' blending mode. Returns the blended color as an RGB string
const multiplyBlendMultipleHex = (colors) => {
    // Convert hex color to RGB
    const hexToRgb = (hex) => {
        hex = hex.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((h) => h + h)
                .join('')
        }
        const int = parseInt(hex, 16)
        return [(int >> 16) & 255, (int >> 8) & 255, int & 255]
    }

    // Convert RGB to hex
    const rgbToHex = ([r, g, b]) => `#${[r, g, b].map((c) => c.toString(16).padStart(2, '0')).join('')}`

    // Convert all hex colors to RGB arrays
    const rgbColors = colors.map(hexToRgb)

    // Initialize the result with the first color
    let blended = [...rgbColors[0]]

    // Sequentially multiply each color with the result
    for (let i = 1; i < rgbColors.length; i++) {
        blended = blended.map((v, idx) => Math.round((v / 255) * (rgbColors[i][idx] / 255) * 255))
    }

    // Return the blended color as a hex code
    return rgbToHex(blended)
}

// convert rect attributes into an SVG path string
// used for workaround whereby clipPaths which use rect elements do not work in adobe illustrator
const convertRectanglesToPaths = function (x, y, width, height) {
    var x = parseFloat(x, 10)
    var y = parseFloat(y, 10)
    var width = parseFloat(width, 10)
    var height = parseFloat(height, 10)

    if (x < 0 || y < 0 || width < 0 || height < 0) {
        return ''
    }

    return 'M' + x + ',' + y + 'L' + (x + width) + ',' + y + ' ' + (x + width) + ',' + (y + height) + ' ' + x + ',' + (y + height) + 'z'
}

const getTextColorForBackground = function (backgroundColor) {
    let r, g, b

    // Create a temporary element to handle named colors
    if (!backgroundColor.startsWith('rgb') && !backgroundColor.startsWith('#')) {
        const tempDiv = document.createElement('div')
        tempDiv.style.color = backgroundColor
        document.body.appendChild(tempDiv)
        const computedColor = window.getComputedStyle(tempDiv).color
        document.body.removeChild(tempDiv)
        backgroundColor = computedColor // Convert named color to RGB
    }

    // Handle hex colors like '#FFFFFF' or '#FFF'
    if (backgroundColor.startsWith('#')) {
        let hex = backgroundColor.replace('#', '')
        if (hex.length === 3) {
            hex = hex
                .split('')
                .map((c) => c + c)
                .join('')
        }
        r = parseInt(hex.substring(0, 2), 16)
        g = parseInt(hex.substring(2, 4), 16)
        b = parseInt(hex.substring(4, 6), 16)
    }
    // Handle RGB colors like 'rgb(255,255,255)'
    else {
        const rgb = backgroundColor.match(/\d+/g)
        r = parseInt(rgb[0])
        g = parseInt(rgb[1])
        b = parseInt(rgb[2])
    }

    // Calculate luminance
    const luminance = 0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255)

    // Return black for light backgrounds, white for dark backgrounds
    return luminance > 0.5 ? 'black' : 'white'
}

// get css selector. Different maps have different selectors for their regions.
const getRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions path'
    if (map.gridCartogram_) return '#em-grid-container .em-grid-cell'
    if (map.geo_ === 'WORLD') return '#em-worldrg path'
    return '#em-nutsrg path:not(#em-cntrg-RS):not(#em-cntrg-EL), #em-cntrg path:not(#em-cntrg-RS):not(#em-cntrg-EL)'
}

// get css selector for legend mouse hover. Different maps have different selectors for their regions
const getLegendRegionsSelector = (map) => {
    if (map.Geometries.userGeometries) return '#em-user-regions'
    if (map.gridCartogram_) return '#em-grid-container'
    if (map.geo_ === 'WORLD') return '#em-worldrg'
    return '#em-nutsrg, #em-cntrg'
}


/***/ }),

/***/ "./src/eurostat-map.js":
/*!*****************************!*\
  !*** ./src/eurostat-map.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* binding */ getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* binding */ getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maptypes/map-choropleth */ "./src/maptypes/map-choropleth.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maptypes/map-categorical */ "./src/maptypes/map-categorical.js");
/* harmony import */ var _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./maptypes/map-choropleth-bivariate */ "./src/maptypes/map-choropleth-bivariate.js");
/* harmony import */ var _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./maptypes/map-choropleth-trivariate */ "./src/maptypes/map-choropleth-trivariate.js");
/* harmony import */ var _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maptypes/map-stripe-composition */ "./src/maptypes/map-stripe-composition.js");
/* harmony import */ var _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./maptypes/map-piecharts */ "./src/maptypes/map-piecharts.js");
/* harmony import */ var _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./maptypes/map-sparklines */ "./src/maptypes/map-sparklines.js");
/* harmony import */ var _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./maptypes/map-flow */ "./src/maptypes/map-flow.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _core_labels__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/labels */ "./src/core/labels.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../package.json */ "./package.json");












/**
 * Function returning a eurostat-map object.
 *
 * @param {*} type The type of map ('ch' for choropleth, etc.)
 * @param {*} config The configuration object. Ex.: { title: "Map title", geoCenter: [233,654], ...}
 */
const map = function (type, config) {
    //choropleth map
    if (type == 'choropleth' || type == 'ch') return _maptypes_map_choropleth__WEBPACK_IMPORTED_MODULE_0__.map(config)
    //categorical map
    if (type == 'categorical' || type == 'ct') return _maptypes_map_categorical__WEBPACK_IMPORTED_MODULE_2__.map(config)
    //proportionnal symbols map
    if (type == 'proportionalSymbol' || type == 'ps') return _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.map(config)
    //bivariate choropleth
    if (type == 'bivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_3__.map(config)
    //trivariate choropleth
    if (type == 'trivariateChoropleth' || type == 'chbi') return _maptypes_map_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_4__.map(config)
    //stripes composition
    if (type == 'stripeComposition' || type == 'scomp') return _maptypes_map_stripe_composition__WEBPACK_IMPORTED_MODULE_5__.map(config)
    //proportional pie charts
    if (type == 'pieChart' || type == 'pie') return _maptypes_map_piecharts__WEBPACK_IMPORTED_MODULE_6__.map(config)
    //sparkline maps
    if (type == 'sparkline' || type == 'spark' || type == 'sparklines') return _maptypes_map_sparklines__WEBPACK_IMPORTED_MODULE_7__.map(config)
    //flow maps
    if (type == 'flow' || type == 'flowmap') return _maptypes_map_flow__WEBPACK_IMPORTED_MODULE_8__.map(config)

    //add new map types here
    //if(type == "XX") return mapXX.map(config);

    console.log('Unexpected map type: ' + type)
    return _core_stat_map__WEBPACK_IMPORTED_MODULE_9__.statMap(config, true, type)
}

/**
 * Return a function which builds fill patterns style.
 * The returned function has for arguments the SVG element where to use the fill pattern, and the number of classes.
 *
 * @param {*} opts Various parameters on the fill pattern.
 * @returns {function}
 */
const getFillPatternDefinitionFunction = function (opts) {
    opts = opts || {}
    opts.shape = opts.shape || 'circle'
    const ps = opts.patternSize || 5
    const smin = opts.minSize || 1
    const smax = opts.maxSize || 5.5
    opts.bckColor = opts.bckColor || 'white'
    opts.symbColor = opts.symbColor || 'black'
    return function (svg, numberOfClasses) {
        //clear previous
        svg.selectAll('.em-fill-pattern').remove()
        for (let i = 0; i < numberOfClasses; i++) {
            const si = smin + ((smax - smin) * i) / (numberOfClasses - 1)
            const patt = svg
                .append('pattern')
                .attr('class', 'em-fill-pattern')
                .attr('id', 'pattern_' + i)
                .attr('x', '0')
                .attr('y', '0')
                .attr('width', ps)
                .attr('height', ps)
                .attr('patternUnits', 'userSpaceOnUse')
            patt.append('rect').attr('x', 0).attr('y', 0).attr('width', ps).attr('height', ps).style('stroke', 'none').style('fill', opts.bckColor)
            if (opts.shape == 'square')
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', si)
                    .attr('height', si)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
            else
                patt.append('circle')
                    .attr('cx', ps * 0.5)
                    .attr('cy', ps * 0.5)
                    .attr('r', si * 0.5)
                    .style('stroke', 'none')
                    .style('fill', opts.symbColor)
        }
    }
}

const getDefaultLabels = function () {
    return _core_labels__WEBPACK_IMPORTED_MODULE_10__.DEFAULTLABELS
}

;
const version = _package_json__WEBPACK_IMPORTED_MODULE_11__.version


/***/ }),

/***/ "./src/legend/legend-categorical.js":
/*!******************************************!*\
  !*** ./src/legend/legend-categorical.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");





/**
 * A legend for categorical maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 13
    //the height of the legend box elements
    out.shapeHeight = 15
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'
    // allow the user to define the order of the legend elements manually as an array
    out.order = undefined

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node() && out.map.classifier_) {
            const map = out.map
            const container = out.lgg

            //draw legend background box
            out.makeBackgroundBox()

            //draw title
            if (out.title) {
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + out.titleFontSize)
                    .text(out.title)
            }

            //get category codes
            const domain = map.classToFillStyle() ? Object.keys(map.classToFillStyle()) : map.classifier_.domain()
            const ecls = out.order ? out.order : domain

            //draw legend elements for classes: rectangle + label
            for (let i = 0; i < ecls.length; i++) {
                //the class
                const ecl_ = ecls[i]
                const ecl = map.classifier_(ecl_)
                const fillColor = map.classToFillStyle_[ecl_]

                //the vertical position of the legend element
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', fillColor)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, ecl)
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, ecl)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, ecl)
                        }
                    })

                //label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(map.classToText() ? map.classToText()[ecl_] : ecl_)
            }

            //'no data' legend box
            if (out.noData) {
                const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + ecls.length * (out.shapeHeight + out.shapePadding)

                //rectangle
                container
                    .append('rect')
                    .attr('class', 'em-legend-rect')
                    .attr('x', out.boxPadding)
                    .attr('y', y)
                    .attr('width', out.shapeWidth)
                    .attr('height', out.shapeHeight)
                    .style('fill', map.noDataFillStyle_)
                    .on('mouseover', function () {
                        highlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, highlightRegions, 'nd')
                        }
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map, 'nd')
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.svgId_, unhighlightRegions, 'nd')
                        }
                    })

                //'no data' label
                container
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                    .attr('y', y + out.shapeHeight * 0.5)
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(out.noDataText)
            }

            // Append pattern fill legend items BELOW the main legend
            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_2__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-bivariate.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-choropleth-bivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth-bivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //size
    out.squareSize = 100

    //orientation
    out.rotation = 0

    //labels
    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'

    //get the font size of the texts
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')

    //breaks
    out.breaks1 = undefined
    out.breaks2 = undefined
    out.showBreaks = false // if set to true and breaks1 and breaks2 are undefined then breaks are automatically defined
    out.tickLength = 5 // length of the ticks

    //axis
    out.yAxisLabelsOffset = { x: 0, y: 0 }
    out.xAxisLabelsOffset = { x: 0, y: 0 }

    //axis titles
    out.yAxisTitleOffset = { x: 0, y: 0 }
    out.xAxisTitleOffset = { x: 0, y: 0 }

    //show no data
    out.noData = true
    //show no data
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25

    //no data text label
    out.noDataText = 'No data'

    //override padding
    out.boxPadding = out.labelFontSize

    //add extra distance between legend and no data item
    out.noDataYOffset = 30

    //arrows
    out.axisArrows = true // if set to true, arrows are drawn at the end of the axes
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10 // padding between arrow and axis label

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        // Horizontal shift to move everything right (adjust this value as needed)
        out._horizontalOffset = out.axisTitleFontSize + out.arrowPadding // Adjust this value to move the whole legend to the right

        // Remove previous content
        out.lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Draw title
        if (out.title) {
            out.lgg
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', xc + out._horizontalOffset)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        // The vertical position of the legend element
        out._y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0)

        // Square group with horizontal offset
        addSquares()

        // set breaks if user hasnt defined them but has enabled them
        if (!out.breaks1 && !out.breaks2 && out.showBreaks) {
            // Get quantiles for the first variable (X axis) and truncate to one decimal place
            out.breaks1 = map.classifier1_.quantiles().map((value) => parseFloat(value.toFixed(0)))

            // Get quantiles for the second variable (Y axis) and truncate to one decimal place
            out.breaks2 = map.classifier2_.quantiles().map((value) => parseFloat(value.toFixed(0)))
        }

        // Draw breaks labels 1 (X axis)
        addBreakLabels()

        out._xAxisArrowY = 0
        out._yAxisArrowX = 0
        if (out.axisArrows) {
            addAxisArrows()
        }

        addAxisTitles()

        // Arrow defs
        out.lgg
            .append('defs')
            .append('marker')
            .attr('viewBox', `0 0 ${out.arrowWidth} ${out.arrowHeight}`)
            .attr('id', 'arrowhead')
            .attr('refX', 0)
            .attr('refY', 5)
            .attr('markerWidth', out.arrowWidth)
            .attr('markerHeight', out.arrowHeight)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 5 5 L 0 10')
            .attr('marker-units', 'strokeWidth')

        // 'No data' legend box
        if (out.noData) {
            addNoDataElement()
        }

        // Set legend box dimensions
        out.setBoxDimension()
    }

    function addNoDataElement() {
        const noDataYOffset =
            out.rotation === 0 ? out.noDataYOffset + out.squareSize / out.map.numberOfClasses_ + out.arrowHeight / 2 : out.noDataYOffset

        let noDataY =
            out.rotation === 0 ? out._y + out.squareSize + noDataYOffset : out._y + 1.4142 * out.squareSize + out.boxPadding * 2 + noDataYOffset

        out.lgg
            .append('rect')
            .attr('class', 'em-bivariate-nodata')
            .attr('x', out.boxPadding + out.noDataShapeWidth / 2)
            .attr('y', noDataY + (out.rotation == 0 ? 0 : -10))
            .attr('width', out.noDataShapeWidth)
            .attr('height', out.noDataShapeHeight)
            .style('fill', out.map.noDataFillStyle())
            .on('mouseover', function () {
                const regions = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])('#em-nutsrg')
                const sel = regions.selectAll("[nd='nd']")
                sel.style('fill', 'red')
            })
            .on('mouseout', function () {
                const nRg = out.map.nutsLevel_ == 'mixed' ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])('#em-nutsrg') : (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])('#em-nutsrg')
                const sel = nRg.selectAll("[nd='nd']")
                sel.style('fill', function () {
                    return (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')
                })
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', out.map.noDataFillStyle())
            })
        out.lgg
            .append('text')
            .attr('class', 'em-bivariate-nodata-label')
            .attr('x', out.boxPadding + out.noDataShapeWidth + (out.noDataShapeWidth / 2 + 5))
            .attr('y', noDataY + out.noDataShapeHeight * 0.5 + 1 + (out.rotation == 0 ? 0 : -10))
            .text(out.noDataText)
    }

    function addSquares() {
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()
        const sz = out.squareSize / numberOfClasses
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        const square = lgg
            .append('g')
            .attr('class', 'bivariate-squares-chart')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // Draw rectangles
        for (let i = 0; i < numberOfClasses; i++) {
            for (let j = 0; j < numberOfClasses; j++) {
                const ecl1 = numberOfClasses - i - 1
                const ecl2 = numberOfClasses - j - 1
                const fill = out.map.classToFillStyle()(ecl1, ecl2)

                square
                    .append('rect')
                    .attr('class', 'em-bivariate-square')
                    .attr('x', initialX + (numberOfClasses - 1 - i) * sz)
                    .attr('y', j * sz)
                    .attr('width', sz)
                    .attr('height', sz)
                    .style('fill', fill)
                    .on('mouseover', function () {
                        highlightRegions(out.map, ecl1, ecl2)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl1, ecl2)
                        }
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).raise() // raise legend square to avoid stroke issue
                    })
                    .on('mouseout', function () {
                        unhighlightRegions(out.map)
                        if (out.map.insetTemplates_) {
                            (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl1, ecl2)
                        }
                    })
            }
        }

        // Frame
        square
            .append('rect')
            .attr('class', 'em-bivariate-frame')
            .attr('x', initialX)
            .attr('y', 0)
            .attr('width', out.squareSize)
            .attr('height', out.squareSize)
            .attr('stroke-width', 0.7)
    }

    function addBreakLabels() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0
        const numberOfClasses = out.map.numberOfClasses()
        const sz = out.squareSize / numberOfClasses

        // group with horizontal offset
        const breakLabels = out.lgg
            .append('g')
            .attr('class', 'bivariate-break-labels')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )
        if (out.breaks1) {
            for (let i = 0; i < out.breaks1.length; i++) {
                const x = initialX + sz * (i + 1)
                const y = out.squareSize + (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label')

                breakLabels
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.xAxisLabelsOffset.x )
                    .attr('y', y + out.xAxisLabelsOffset.y )
                    .text(out.breaks1[i])

                breakLabels
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x)
                    .attr('x2', x)
                    .attr('y1', out.squareSize)
                    .attr('y2', out.squareSize + out.tickLength)
            }
        }

        // Draw breaks labels 2 (Y axis)
        if (out.breaks2) {
            for (let i = 0; i < out.breaks2.length; i++) {
                const x = initialX
                const y = sz * (i + 2) - sz

                breakLabels
                    .append('text')
                    .attr('class', 'em-bivariate-tick-label')
                    .attr('x', x + out.yAxisLabelsOffset.x)
                    .attr('y', y - out.yAxisLabelsOffset.y - (out.tickLength + 2))
                    .text([...out.breaks2].reverse()[i])
                    .attr('text-anchor', 'middle')
                    .attr('transform', `rotate(-90, ${x}, ${y})`)

                breakLabels
                    .append('line')
                    .attr('class', 'em-bivariate-tick')
                    .attr('x1', x)
                    .attr('x2', x - out.tickLength)
                    .attr('y1', y)
                    .attr('y2', y)
            }
        }
    }

    function addAxisTitles() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        const axisTitles = out.lgg
            .append('g')
            .attr('class', 'bivariate-axis-titles')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // X axis title
        let xAxisTitleY = out.squareSize + out.xAxisLabelsOffset.y + (out.axisArrows ? out.arrowPadding + out.arrowHeight : 7)
        let xAxisTitleX = initialX
        if (out.showBreaks || (out.breaks1 && out.breaks2)) xAxisTitleY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') // move over for tick labels
        if (out.xAxisTitleOffset) xAxisTitleY += out.xAxisTitleOffset.y
        if (out.xAxisTitleOffset) xAxisTitleX += out.xAxisTitleOffset.x
        axisTitles
            .append('text')
            .attr('class', 'em-bivariate-axis-title em-bivariate-axis-title-x')
            .attr('x', xAxisTitleX)
            .attr('y', xAxisTitleY)
            .text(out.label1)
            .attr('dominant-baseline', 'hanging')
            .attr('alignment-baseline', 'hanging')

        // Y axis title
        let yAxisTitleY = (out.axisArrows ? out._yAxisArrowX - out.arrowPadding : 7) + (out.rotation == -45 ? -4 : -10) // adjust for rotation
        if (out.showBreaks || (out.breaks1 && out.breaks2)) xAxisTitleY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') // move over for tick labels
        let yAxisTitleX = -out.squareSize
        //manual offsets
        if (out.yAxisTitleOffset) yAxisTitleY += out.yAxisTitleOffset.y
        if (out.yAxisTitleOffset) yAxisTitleX += out.yAxisTitleOffset.x
        axisTitles
            .append('text')
            .attr('class', 'em-bivariate-axis-title em-bivariate-axis-title-y')
            .attr('x', yAxisTitleX)
            .attr('y', yAxisTitleY)
            .text(out.label2)
            .style('transform', out.rotation < 0 ? `translate(${out.axisArrows ? -51 : -15}px, 95px) rotate(90deg)` : 'rotate(-90deg)')
    }

    function addAxisArrows() {
        const xc = out.rotation === 0 ? 0 : 0.7071 * out.squareSize + out.boxPadding
        const initialX = 0

        // group with horizontal offset
        const axisArrows = out.lgg
            .append('g')
            .attr('class', 'bivariate-axis-arrows')
            .attr(
                'transform',
                `translate(${out.boxPadding + out._horizontalOffset},${xc + out._y}) rotate(${out.rotation}) translate(${out.boxPadding},0)`
            )

        // Append X axis arrow
        out._xAxisArrowY = out.squareSize + out.tickLength + out.arrowPadding
        if (out.showBreaks || (out.breaks1 && out.breaks2)) out._xAxisArrowY += (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-tick-label') / 1.5 // move over for tick labels

        axisArrows
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__["default"])()([
                    [initialX, out._xAxisArrowY],
                    [initialX + out.squareSize, out._xAxisArrowY],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')

        // Append Y axis arrow
        out._yAxisArrowX = -out.tickLength - out.arrowPadding
        if (out.showBreaks || (out.breaks1 && out.breaks2)) out._yAxisArrowX -= out.labelFontSize / 2 // move over for tick labels

        axisArrows
            .append('path')
            .attr('class', 'em-bivariate-axis-arrow')
            .attr(
                'd',
                (0,d3_shape__WEBPACK_IMPORTED_MODULE_4__["default"])()([
                    [out._yAxisArrowX, out.squareSize],
                    [out._yAxisArrowX, 0],
                ])
            )
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)')
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-choropleth-trivariate.js":
/*!****************************************************!*\
  !*** ./src/legend/legend-choropleth-trivariate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");




/**
 * A legend for choropleth-trivariate maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    // Default settings
    out.width = 230
    out.height = 230

    out.label1 = 'Variable 1'
    out.label2 = 'Variable 2'
    out.label3 = 'Variable 3' // Add a label for the third variable
    out.axisTitleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.getFontSizeFromClass)('em-bivariate-axis-title')
    out.showBreaks = false
    out.noData = true
    out.noDataShapeHeight = 20
    out.noDataShapeWidth = 25
    out.noDataText = 'No data'
    out.boxPadding = 60 // depends on variable 1 label length really
    out.noDataYOffset = 20
    out.arrowHeight = 15
    out.arrowWidth = 14
    out.arrowPadding = 10

    if (config) for (let key in config) out[key] = config[key]

    /**
     * Override the update method to handle trivariate legends
     */
    out.update = function () {
        out.updateConfig()
        out.updateContainer()
        const lgg = out.lgg
        const numberOfClasses = out.map.numberOfClasses()

        // Remove previous content
        lgg.selectAll('*').remove()

        // Draw background box
        out.makeBackgroundBox()

        // Apply padding to the main <g> group
        const paddedGroup = lgg.append('g').attr('transform', `translate(${out.boxPadding}, ${out.boxPadding})`)

        // Draw title
        if (out.title) {
            paddedGroup
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Start at 0 within the padded group
                .attr('y', out.titleFontSize) // Vertical positioning
                .text(out.title)
        }

        // Draw the trivariate Venn diagram
        const labels = [out.label1, out.label2, out.label3]
        const colors = [out.map.color1_, out.map.color2_, out.map.color3_]

        drawTrivariateVennDiagram(paddedGroup, colors, labels)

        // Handle trivariate (Venn Diagram) or bivariate (grid) legend
        // if (numberOfClasses === 7) {
        //     drawTrivariateVennDiagram(lgg, out)
        // } else {
        //     drawTrivariateTernaryPlot(lgg, out, numberOfClasses)
        // }
    }

    return out
}

function drawTrivariateVennDiagram(container, colors, labels) {
    //specs for Circle 1
    const xCenter1 = 50
    const yCenter1 = 50
    const circleRad = 30

    //draw Circle 1
    // const circle1 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter1 + ',' + yCenter1 + ')')

    //add'l specs for Circle 2
    const offsetFactor = 1.2
    const offset = offsetFactor * circleRad
    const xCenter2 = xCenter1 + offset
    const yCenter2 = yCenter1 //creating new var for clarity

    //draw Circle 2
    // const circle2 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter2 + ',' + yCenter2 + ')')

    //add'l specs for Circle 3
    const xCenter3 = xCenter1 + offset / 2
    const yCenter3 = yCenter1 + (Math.sqrt(3) * offset) / 2

    //draw Circle 3
    // const circle3 = container
    //     .append('circle')
    //     .attr('r', circleRad)
    //     .attr('transform', 'translate(' + xCenter3 + ',' + yCenter3 + ')')

    //compute first points of intersection
    const triHeight = Math.sqrt(circleRad ** 2 - (offset / 2) ** 2)
    //outer intersection of Circles 1 and 2
    const xIsect1 = xCenter3
    const yIsect1 = yCenter1 - triHeight
    //inner intersection of Circles 1 and 2
    const xIsect4 = xCenter3
    const yIsect4 = yCenter1 + triHeight

    //treat "triHeight" as the hypoteneuse of a 30.60.90 triangle.
    //this tells us the shift from the midpoint of a leg of the triangle
    //to the point of intersection
    const xDelta = (triHeight * Math.sqrt(3)) / 2
    const yDelta = triHeight / 2

    const xMidpointC1C3 = (xCenter1 + xCenter3) / 2
    const xMidpointC2C3 = (xCenter2 + xCenter3) / 2
    const yMidpointBoth = (yCenter1 + yCenter3) / 2

    //find the rest of the points of intersection
    const xIsect2 = xMidpointC1C3 - xDelta
    const yIsect2 = yMidpointBoth + yDelta
    const xIsect3 = xMidpointC2C3 + xDelta
    const yIsect3 = yMidpointBoth + yDelta

    const xIsect5 = xMidpointC1C3 + xDelta
    const yIsect5 = yMidpointBoth - yDelta
    const xIsect6 = xMidpointC2C3 - xDelta
    const yIsect6 = yMidpointBoth - yDelta

    const xPoints = [xIsect1, xIsect2, xIsect3, xIsect4, xIsect5, xIsect6]
    const yPoints = [yIsect1, yIsect2, yIsect3, yIsect4, yIsect5, yIsect6]

    const makeIronShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const makeSunShapes = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 0 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 0 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 1 1 ${x1} ${y1}`
        return path
    }

    const makeRoundedTri = ([x1, x2, x3, y1, y2, y3]) => {
        const path = `M ${x1} ${y1}
             A ${circleRad} ${circleRad} 0 0 1 ${x2} ${y2}
             A ${circleRad} ${circleRad} 0 0 1 ${x3} ${y3}
             A ${circleRad} ${circleRad} 0 0 1 ${x1} ${y1}`
        return path
    }

    const ironPoints = [
        [1, 5, 6],
        [3, 4, 5],
        [2, 6, 4],
    ]
    const sunPoints = [
        [3, 5, 1],
        [2, 4, 3],
        [1, 6, 2],
    ]
    const roundedTriPoints = [[5, 4, 6]]

    // main circles (raw colors)
    sunPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeSunShapes(ptCycle)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', colors[index]).attr('opacity', 1)
    })

    // first intersects (combination of 2 colors)
    ironPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeIronShapes(ptCycle)

        let color
        if (index == 0) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[2], colors[0]]) // pink + cyan
        } else if (index == 1) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[0]]) // cyan + yellow
        } else if (index == 2) {
            color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)([colors[1], colors[2]]) // pink + yellow
        }

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    // nucleus (combination of all 3 colors)
    roundedTriPoints.forEach((points, index) => {
        const ptCycle = points.map((i) => xPoints[i - 1]).concat(points.map((i) => yPoints[i - 1]))
        const shape = makeRoundedTri(ptCycle)
        const color = (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.multiplyBlendMultipleHex)(colors)

        container.append('path').attr('d', shape).attr('class', 'segment').attr('fill', color).attr('opacity', 1)
    })

    container
        .selectAll('path.segment')
        .on('mouseover', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 0.8).duration(500)
        })
        .on('mouseout', function () {
            (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).transition().attr('opacity', 1).duration(500)
        })

    // label intersects
    const yOffset = container
        .append('text')
        .text(labels[0])
        .attr('x', xCenter1 - circleRad - 3)
        .attr('y', xCenter1)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'end')
    container
        .append('text')
        .text(labels[1])
        .attr('x', xCenter2 + circleRad + 3)
        .attr('y', yCenter2)
        .attr('class', 'venn-label')
    container
        .append('text')
        .text(labels[2])
        .attr('x', xCenter3)
        .attr('y', yCenter3 + circleRad + 15)
        .attr('class', 'venn-label')
        .attr('text-anchor', 'middle')
}

/**
 * Draws a trivariate legend as a Venn Diagram
 */
function drawTrivariateVennDiagram2(svg, containerWidth, containerHeight, labels, colors) {
    const radius = containerWidth / 5 // Radius of each circle
    const centerX = containerWidth / 2
    const centerY = containerHeight / 2
    const offset = radius / 1.5

    // Define circle positions
    const circles = [
        { id: 'circle1', cx: centerX - offset, cy: centerY, label: labels[0], color: colors[0] },
        { id: 'circle2', cx: centerX + offset, cy: centerY, label: labels[1], color: colors[1] },
        { id: 'circle3', cx: centerX, cy: centerY + offset * 1.5, label: labels[2], color: colors[2] },
    ]

    // Draw circles
    circles.forEach(({ id, cx, cy, label, color }, index) => {
        svg.append('circle').attr('id', id).attr('cx', cx).attr('cy', cy).attr('r', radius).style('fill', color).style('opacity', 1)

        // Add labels with specific positioning
        const labelX =
            index === 0
                ? cx - radius - 10 // Left of the first circle
                : index === 1
                  ? cx + radius + 10 // Right of the second circle
                  : cx // Below the third circle

        const labelY = index < 2 ? cy : cy + radius + 20 // Same y for first two circles, below for the third

        svg.append('text')
            .attr('x', labelX)
            .attr('y', labelY)
            .attr('text-anchor', index < 2 ? (index === 0 ? 'end' : 'start') : 'middle') // Adjust alignment
            .attr('class', 'venn-label')
            .text(label)
            .style('font-size', '12px')
    })
}

/**
 * Draws a trivariate legend as a ternary plot
 */
function drawTrivariateTernaryPlot(lgg, out, numberOfClasses) {
    const size = out.squareSize // Size of the legend area
    const padding = 20 // Padding around the plot
    const radius = 5 // Radius of each class point
    const triangleHeight = (Math.sqrt(3) / 2) * size

    const ternaryGroup = lgg
        .append('g')
        .attr('class', 'trivariate-ternary-plot')
        .attr('transform', `translate(${out.boxPadding + size / 2}, ${out.boxPadding + triangleHeight / 2})`)

    // Draw the triangle
    const vertices = [
        { x: 0, y: -triangleHeight / 2 }, // Top vertex (Variable 1)
        { x: -size / 2, y: triangleHeight / 2 }, // Bottom-left vertex (Variable 2)
        { x: size / 2, y: triangleHeight / 2 }, // Bottom-right vertex (Variable 3)
    ]

    ternaryGroup
        .append('polygon')
        .attr('points', vertices.map((d) => `${d.x},${d.y}`).join(' '))
        .attr('fill', 'none')
        .attr('stroke', 'black')

    // Label the vertices
    const labels = [out.label1, out.label2, out.label3]
    vertices.forEach((vertex, i) => {
        ternaryGroup
            .append('text')
            .attr('x', vertex.x)
            .attr('y', vertex.y - (i === 0 ? 10 : -20)) // Offset labels
            .attr('class', 'ternary-label')
            .attr('text-anchor', 'middle')
            .text(labels[i])
    })

    // Plot the points inside the ternary plot
    for (let i = 0; i < numberOfClasses; i++) {
        for (let j = 0; j < numberOfClasses - i; j++) {
            const k = numberOfClasses - i - j - 1 // Ensure sum of i + j + k = numberOfClasses - 1
            const x = ((j - k) * size) / (2 * (numberOfClasses - 1)) // Horizontal position
            const y = (i * -triangleHeight) / (numberOfClasses - 1) // Vertical position

            const fill = out.map.classToFillStyle()(i, j, k)

            ternaryGroup
                .append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', radius)
                .attr('fill', fill)
                .on('mouseover', function () {
                    highlightRegions(out.map, i, j, k)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, i, j, k)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, i, j, k)
                    }
                })
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl1, ecl2) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter(`[ecl1='${ecl1}']`).filter(`[ecl2='${ecl2}']`)
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const allRegions = map.svg_.selectAll(selector).selectAll(`[ecl1]`)

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).attr('fill___'))
        })
    }
}


/***/ }),

/***/ "./src/legend/legend-choropleth.js":
/*!*****************************************!*\
  !*** ./src/legend/legend-choropleth.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/band.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");









/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object (inherit)
    const out = _legend__WEBPACK_IMPORTED_MODULE_1__.legend(map)

    out.labelType = 'thresholds' // thresholds || ranges
    //the order of the legend elements. Set to false to invert.
    out.ascending = true
    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the separation line length
    out.sepLineLength = out.shapeWidth
    //tick line length in pixels
    out.tickLength = 4
    //the number of decimal for the legend labels
    out.decimals = 0
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 3
    //labelFormatter function
    out.labelFormatter = null
    // manually define labels
    out.labels = null

    // Histogram config as nested object
    out.histogram = null

    //diverging line
    out.pointOfDivergenceLabel = undefined
    out.pointOfDivergence = undefined
    out.pointOfDivergencePadding = 7
    out.divergingLineLength = undefined
    out.divergingArrowLength = undefined

    //show no data
    out.noData = true
    //no data text label
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) {
        for (let key in config) {
            if (key === 'histogram' && typeof config[key] === 'object') {
                out.histogram = {
                    orientation: 'horizontal',
                    showCounts: false,
                    showPercentages: false,
                    labelRotation: 0,
                    labelFormat: undefined,
                    ...config.histogram,
                }
            } else {
                out[key] = config[key]
            }
        }
    }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const map = out.map
            const container = out.lgg

            // Draw legend background box and title if provided
            out.makeBackgroundBox()
            if (out.title) {
                let cssFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-title')
                container
                    .append('text')
                    .attr('class', 'em-legend-title')
                    .attr('x', out.boxPadding)
                    .attr('y', out.boxPadding + cssFontSize)
                    .text(out.title)
            }

            //exit early if no classifier
            if (!map.classToFillStyle()) return

            //set default point of divergence if applicable
            if (out.pointOfDivergenceLabel && !out.pointOfDivergence) out.pointOfDivergence = map.numberOfClasses_ / 2

            if (out.histogram) {
                createHistogramLegend()
            } else {
                if (out.labelType === 'ranges') createRangesLegend()
                else createThresholdsLegend()
            }

            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height

            // Append pattern fill legend items BELOW the main legend
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_3__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            // Set legend box dimensions
            out.setBoxDimension()
        }
    }

    function getThresholds() {
        const map = out.map
        const thresholds =
            map.thresholds_.length > 1
                ? map.thresholds_
                : Array.from({ length: map.numberOfClasses_ })
                      .map((_, index) => {
                          return map.classifier().invertExtent(index)[out.ascending ? 0 : 1]
                      })
                      .slice(1) // Remove the first entry and return the rest as an array
        return thresholds
    }

    function getColors() {
        const map = out.map
        return map.colors_
            ? map.colors_
            : Array.from({ length: map.numberOfClasses_ }).map((_, index) => {
                  return map.classToFillStyle()(index, map.numberOfClasses_)
              })
    }

    function getData() {
        const map = out.map
        return Object.values(map.statData()._data_).map((item) => item.value)
    }

    function createThresholdsLegend() {
        const m = out.map
        const lgg = out.lgg
        // Label formatter
        const formatLabel = out.labelFormatter || (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.format)(`.${out.decimals}f`)
        let baseY = out.boxPadding
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding
        for (let i = 0; i < m.numberOfClasses_; i++) {
            const y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? m.numberOfClasses() - i - 1 : i
            const fillColor = m.classToFillStyle()(ecl, m.numberOfClasses_)

            // Append rectangle for each class
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append tick line
            if (i > 0) {
                lgg.append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.boxPadding + out.sepLineLength)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength + out.tickLength)
                    .attr('y2', y)
            }

            // Append label
            if (i < m.numberOfClasses() - 1) {
                // mark label so we can move it in drawDivergingLine
                const label = lgg
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                    .attr('y', y + out.shapeHeight)
                    //.attr('dominant-baseline', 'middle')
                    .attr('dy', '0.35em') // ~vertical centering
                    .text(out.labels ? out.labels[i] : formatLabel(m.classifier().invertExtent(ecl)[out.ascending ? 0 : 1]))

                // mark label so we can move it in drawDivergingLine
                if (out.pointOfDivergenceLabel && i == out.pointOfDivergence - 1) label.attr('class', 'em-legend-label em-legend-label-divergence')
            }
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const y = baseY + m.numberOfClasses() * out.shapeHeight + out.boxPadding
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dy', '0.35em')
                .text(out.noDataText)
        }
    }

    function createRangesLegend() {
        const map = out.map
        const container = out.lgg
        const thresholds = getThresholds()
        const defaultLabeller = (label, i) => {
            if (i === 0) return `> ${thresholds[thresholds.length - 1]}` //top
            if (i === thresholds.length) return `< ${thresholds[0]}` //bottom
            return `${thresholds[thresholds.length - i - 1]} - < ${thresholds[thresholds.length - i]}  ` //in-between
        }
        const labelFormatter = out.labelFormatter || defaultLabeller

        let baseY = out.boxPadding
        if (out.title) baseY = baseY + (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-title') + 8 // title size + padding

        // for each class
        for (let i = 0; i < map.numberOfClasses_; i++) {
            let y = baseY + i * out.shapeHeight
            const x = out.boxPadding
            const ecl = out.ascending ? map.numberOfClasses() - i - 1 : i
            const fillColor = map.classToFillStyle()(ecl, map.numberOfClasses_)
            const itemContainer = container.append('g').attr('class', 'em-legend-item')

            // shift legend items down after point of divergence if applicable
            if (out.pointOfDivergenceLabel && i >= out.pointOfDivergence) y += out.pointOfDivergencePadding

            // Append rectangle
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', fillColor)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).raise()
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            // Append separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', out.boxPadding)
                    .attr('y1', y)
                    .attr('x2', out.boxPadding + out.sepLineLength)
                    .attr('y2', y)
            }

            // Append labels
            itemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + Math.max(out.shapeWidth, out.sepLineLength + out.tickLength) + out.labelOffset)
                .attr('y', y + out.shapeHeight / 2)
                .attr('dy', '0.35em')
                .text(out.labels ? out.labels[i] : labelFormatter(map.classifier().invertExtent(ecl)[out.ascending ? 0 : 1], i))
        }

        // Draw diverging line if applicable. We draw it afterwards so that we can calculate the max length of the legend labels so it doesnt cover them
        if (out.pointOfDivergenceLabel) {
            for (let i = 0; i < map.numberOfClasses_; i++) {
                let y = baseY + i * out.shapeHeight
                // point of divergence indicator
                if (i == out.pointOfDivergence) {
                    drawDivergingLine(y)
                }
            }
        }

        // 'No data' box and label if applicable
        if (out.noData) {
            const noDataItemContainer = container.append('g').attr('class', 'em-legend-item')
            let y = baseY + map.numberOfClasses() * out.shapeHeight + out.boxPadding
            //if (out.pointOfDivergence) y += out.pointOfDivergencePadding // shift legend items down after point of divergence
            noDataItemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', out.map.noDataFillStyle_)
                .on('mouseover', function () {
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).raise()
                    highlightRegions(map, 'nd')
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(map.insetTemplates_, map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(map)
                    if (map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(map.insetTemplates_, map.svgId, unhighlightRegions)
                    }
                })

            noDataItemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .attr('dy', '0.35em')
                .text(out.noDataText)
        }
    }

    function drawDivergingLine(y) {
        const container = out.lgg.append('g').attr('class', 'em-legend-divergence-container')
        const markerHeight = 6
        const x = out.boxPadding
        if (out.labelType == 'ranges') y = y + out.pointOfDivergencePadding / 2 // move to the middle of the space between legend item
        let maxLabelLength = out.lgg
            .selectAll('.em-legend-label')
            .nodes()
            .reduce((max, node) => Math.max(max, node.getBBox().width), 0)
        const lineLength = out.divergingLineLength || maxLabelLength + out.boxPadding + out.shapeWidth + 10 // + padding

        // Draw the horizontal divergence line
        container
            .append('line')
            .attr('x1', x)
            .attr('y1', y)
            .attr('x2', x + lineLength)
            .attr('y2', y)
            .attr('class', 'em-legend-diverging-line')

        // divergence line with up and down arrows
        const labels = out.pointOfDivergenceLabel.split('|')
        if (labels.length > 1) {
            const directionLineLength = out.divergingArrowLength || 30
            const directionLineX = x + lineLength
            // Add arrowhead marker definition
            const defs = container.append('defs')
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('markerWidth', markerHeight)
                .attr('markerHeight', markerHeight)
                .attr('refX', 0)
                .attr('refY', markerHeight / 2)
                .attr('orient', 'auto')
                .append('polygon')
                .attr('points', `0 0, ${markerHeight} ${markerHeight / 2}, 0 ${markerHeight}`)
                .attr('fill', 'black')

            // Upward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y - directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Downward line with arrowhead
            container
                .append('line')
                .attr('class', 'em-legend-diverging-line')
                .attr('x1', directionLineX)
                .attr('y1', y)
                .attr('x2', directionLineX)
                .attr('y2', y + directionLineLength)
                .attr('marker-end', 'url(#arrowhead)')

            // Labels for upward and downward lines
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y - directionLineLength + 10)
                .attr('dy', '0.35em')
                .text(labels[0])

            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', directionLineX + 10)
                .attr('y', y + directionLineLength - 10)
                .attr('dy', '0.35em')
                .text(labels[1])
        } else {
            // just the single label
            container
                .append('text')
                .attr('class', 'em-legend-diverging-label em-legend-label')
                .attr('x', x + lineLength + 5)
                .attr('y', y)
                .attr('dy', '0.35em')
                .text(out.pointOfDivergenceLabel)
        }

        //move threshold label out of the way of the line
        if (out.labelType == 'thresholds') {
            if (labels.length > 1) {
                // move it to end of line
                out.lgg.selectAll('.em-legend-label-divergence').attr('x', x + lineLength + 10)
                // Append tick line
                // container
                //     .append('line')
                //     .attr('class', 'em-legend-tick')
                //     .attr('x1', x + lineLength)
                //     .attr('y1', y)
                //     .attr('x2', x + lineLength + 5)
                //     .attr('y2', y)
            } else {
                //remove it so it doesnt clash with pointOfDivergenceLabel
                out.lgg.selectAll('.em-legend-label-divergence').remove()
            }
        }
    }

    function createHistogramLegend() {
        const thresholds = getThresholds()
        const colors = getColors()
        const data = getData()
        const orientation = out.histogram.orientation || 'horizontal'
        const showCounts = out.histogram.showCounts
        const showPercentages = out.histogram.showPercentages
        const labelRotation = out.histogram.labelRotation || 0
        const labelFormat = out.histogram.labelFormat
        const labelFormatter = out.histogram.labelFormatter

        let counts = new Array(map.numberOfClasses_).fill(0)
        data.forEach((value) => {
            const classIndex = map.classifier()(value)
            if (typeof classIndex === 'number' && classIndex >= 0 && classIndex < counts.length) {
                counts[classIndex]++
            }
        })

        const reversedCounts = counts.slice().reverse()
        const total = counts.reduce((sum, d) => sum + d, 0)
        const reversedPercentages = reversedCounts.map((d) => (total > 0 ? (d / total) * 100 : 0))

        const lgg = out.lgg
        const baseY = out.boxPadding + (out.title ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-title') + 38 : 30)
        const svgWidth = 300
        const svgHeight = 300
        const barGroup = lgg.append('g').attr('class', 'em-legend-histogram').attr('transform', `translate(0, ${baseY})`)

        if (orientation === 'vertical') {
            drawVerticalHistogram(barGroup)
        } else {
            drawHorizontalHistogram(barGroup)
        }

        function drawVerticalHistogram(barGroup) {
            const margin = { top: 20, right: 60, bottom: 40, left: 150 }
            const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])()
                .domain(reversedCounts.map((_, i) => i))
                .range([margin.top, svgHeight - margin.bottom])
                .padding(0.1)
            const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])()
                .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.max)(reversedCounts)])
                .nice()
                .range([margin.left, svgWidth - margin.right])

            // Bars
            barGroup
                .selectAll('rect')
                .data(reversedCounts)
                .join('rect')
                .attr('class', 'em-legend-histogram-bar')
                .attr('y', (_, i) => yScale(i))
                .attr('x', margin.left)
                .attr('height', yScale.bandwidth())
                .attr('width', (d) => xScale(d) - margin.left)
                .attr('fill', (_, i) => colors[colors.length - i - 1])
                .attr('ecl', (_, i) => i)
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)

            // Bar labels
            if (showCounts || showPercentages) {
                barGroup
                    .selectAll('text.em-histogram-label')
                    .data(reversedCounts)
                    .join('text')
                    .attr('class', 'em-legend-label em-histogram-label')
                    .attr('x', (d) => xScale(d) + 5)
                    .attr('y', (_, i) => yScale(i) + yScale.bandwidth() / 2)
                    .attr('alignment-baseline', 'middle')
                    .text((_, i) => {
                        if (typeof labelFormatter === 'function') {
                            return labelFormatter(reversedPercentages[i], reversedCounts[i], i)
                        }
                        return showPercentages ? `${reversedPercentages[i].toFixed(1)}%` : reversedCounts[i]
                    })
            }

            // Axis
            barGroup
                .append('g')
                .attr('id', 'em-legend-histogram-y-axis')
                .attr('transform', `translate(${margin.left}, 0)`)
                .call(
                    (0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisLeft)(yScale)
                        .tickSizeOuter(0)
                        .tickSize(0)
                        .tickFormat((_, i) => formatTickLabel(i))
                )
        }

        function drawHorizontalHistogram(barGroup) {
            const margin = { top: 20, right: 60, bottom: 40, left: 10 }
            const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"])()
                .domain(reversedCounts.map((_, i) => i))
                .range([margin.left, svgWidth - margin.right])
                .padding(0.1)

            const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])()
                .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.max)(reversedCounts)])
                .nice()
                .range([svgHeight - margin.bottom, margin.top])

            // Bars
            barGroup
                .selectAll('rect')
                .data(reversedCounts)
                .join('rect')
                .attr('class', 'em-legend-histogram-bar')
                .attr('x', (_, i) => xScale(i))
                .attr('y', (d) => yScale(d))
                .attr('width', xScale.bandwidth())
                .attr('height', (d) => svgHeight - margin.bottom - yScale(d))
                .attr('fill', (_, i) => colors[colors.length - i - 1])
                .attr('ecl', (_, i) => i)
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)

            // Bar labels (centered)
            if (showCounts || showPercentages) {
                barGroup
                    .selectAll('text.em-histogram-label')
                    .data(reversedCounts)
                    .join('text')
                    .attr('class', 'em-legend-label em-histogram-label')
                    .attr('x', (_, i) => xScale(i) + xScale.bandwidth() / 2)
                    .attr('y', (d) => yScale(d) - 5)
                    .attr('text-anchor', 'middle')
                    .text((_, i) => {
                        if (typeof labelFormatter === 'function') {
                            return labelFormatter(reversedPercentages[i], reversedCounts[i], i)
                        }
                        return showPercentages ? `${reversedPercentages[i].toFixed(1)}%` : reversedCounts[i]
                    })
            }

            // Axis (only for labelType === 'thresholds')
            const axisGroup = barGroup
                .append('g')
                .attr('id', 'em-legend-histogram-x-axis')
                .attr('transform', `translate(0, ${svgHeight - margin.bottom})`)

            if (out.labelType === 'thresholds') {
                const positions = []

                for (let i = 0; i < thresholds.length; i++) {
                    const bandIndex = thresholds.length - i - 1
                    const x = xScale(bandIndex)
                    if (x !== undefined) positions.push(x + xScale.bandwidth())
                }

                const boundaryScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])().domain([0, svgWidth]).range([0, svgWidth])

                axisGroup.call(
                    (0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisBottom)(boundaryScale)
                        .tickValues(positions)
                        .tickFormat((_, i) => (labelFormat ? labelFormat(thresholds[i], i) : thresholds[i]))
                        .tickSize(0)
                        .tickSizeOuter(0)
                )
            } else {
                axisGroup.call((0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisBottom)(xScale).tickSizeOuter(0).tickSize(0))
            }

            axisGroup
                .selectAll('text')
                .attr('class', 'em-legend-label em-tick-label')
                .attr('text-anchor', 'end')
                .attr('transform', `rotate(-${labelRotation})`)
        }

        function formatTickLabel(i) {
            if (out.labelType === 'thresholds') {
                const breakIndex = thresholds.length - i - 1
                return thresholds[breakIndex] ?? ''
            } else {
                if (i === 0) return `> ${thresholds[thresholds.length - 1]}`
                if (i === thresholds.length) return `< ${thresholds[0]}`
                return `${thresholds[thresholds.length - i - 1]} - < ${thresholds[thresholds.length - i]}`
            }
        }

        function handleMouseOver(_, i) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('stroke', 'black')
            const ecl = sel.attr('ecl')
            const reversedIndex = colors.length - 1 - parseInt(ecl, 10)
            highlightRegions(map, reversedIndex)
            if (map.insetTemplates_) {
                (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(map.insetTemplates_, map.svgId, highlightRegions, ecl)
            }
        }

        function handleMouseOut(_, i) {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('stroke', 'none')
            unhighlightRegions(map)
            if (map.insetTemplates_) {
                (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(map.insetTemplates_, map.svgId, unhighlightRegions)
            }
        }
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Set all regions to white
        allRegions.style('fill', 'white')

        // Highlight only the selected regions by restoring their original color
        const selectedRegions = allRegions.filter("[ecl='" + ecl + "']")
        selectedRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getLegendRegionsSelector)(map)
        const allRegions = map.svg_.selectAll(selector).selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allRegions.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_5__["default"])(this).attr('fill___'))
        })
    }

    //deprecated
    out.labelDecNb = (v) => (console.warn('labelDecNb is now DEPRECATED. Please use decimals instead.'), out)

    return out
}


/***/ }),

/***/ "./src/legend/legend-flow.js":
/*!***********************************!*\
  !*** ./src/legend/legend-flow.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");





//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', ''],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const lgg = out.lgg

        // update legend parameters if necessary
        if (m.legend_)
            for (let key in m.legend_) {
                if (key == 'colorLegend' || key == 'sizeLegend') {
                    for (let p in out[key]) {
                        //override each property in size and color legend m.legend_
                        if (m.legend_[key][p] !== undefined) {
                            out[key][p] = m.legend_[key][p]
                        }
                    }
                } else {
                    out[key] = m.legend_[key]
                }
            }

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        buildFlowLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different flow symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildFlowLegend(m) {}

    return out
}


/***/ }),

/***/ "./src/legend/legend-pattern-fill.js":
/*!*******************************************!*\
  !*** ./src/legend/legend-pattern-fill.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendPatternFillLegend: () => (/* binding */ appendPatternFillLegend)
/* harmony export */ });
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



function appendPatternFillLegend(map, container, options = {}) {
    const {
        shapeWidth = 25,
        shapeHeight = 20,
        labelOffset = 3,
        boxPadding = 5,
        offsetY = 0, // << new
    } = options

    if (!map.patternFill_) return

    map.patternFill_.forEach((cfg, index) => {
        if (!cfg.legendLabel) return // skip if no label

        const y = offsetY + index * (shapeHeight + boxPadding)

        const item = container.append('g').attr('class', 'em-legend-item pattern-fill-legend')

        const patternColor = cfg.color || '#000' // fallback to black if no color provided
        const isWhitePattern = patternColor.toLowerCase() === '#fff' || patternColor.toLowerCase() === 'white'

        // Add background if pattern is white
        if (isWhitePattern) {
            item.append('rect').attr('x', boxPadding).attr('y', y).attr('width', shapeWidth).attr('height', shapeHeight).attr('fill', '#ddd') // light gray background
        }

        // Add pattern overlay
        item.append('rect')
            .attr('x', boxPadding)
            .attr('y', y)
            .attr('width', shapeWidth)
            .attr('height', shapeHeight)
            .attr('fill', `url(#${cfg.patternId || cfg.pattern})`)

        // Add label
        item.append('text')
            .attr('class', 'em-legend-label')
            .attr('x', boxPadding + shapeWidth + labelOffset)
            .attr('y', y + shapeHeight / 2)
            .attr('dominant-baseline', 'middle')
            .attr('dy', '0.35em') // ~vertical centering
            .text(cfg.legendLabel)
    })
}


/***/ }),

/***/ "./src/legend/legend-piecharts.js":
/*!****************************************!*\
  !*** ./src/legend/legend-piecharts.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");






/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_1__.legend(map)

    //spacing between color & size legends (if applicable)
    out.legendSpacing = 15

    //size legend config (legend illustrating the values of different pie sizes)
    out.sizeLegend = {
        title: null,
        titlePadding: 30, //padding between title and body
        values: null,
    }

    //colour legend config (legend illustrating the values of different pie colours)
    out.colorLegend = {
        title: null,
        labelOffset: 5, //the distance between the legend box elements to the corresponding text label
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 5, //the distance between consecutive legend box elements
        noData: true, //show no data
        noDataText: 'No data', //no data label text
    }

    out._sizeLegendHeight = 0

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const map = out.map
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        // legend for sizes
        if (map.sizeClassifier_) {
            buildSizeLegend()
        }

        // legend for ps color values
        buildColorLegend()

        //set legend box dimensions
        out.setBoxDimension()
    }

    /**
     * Builds a legend which illustrates the statistical values of different pie chart sizes
     *
     * @param {*} m map
     * @param {*} lgg parent legend object from core/legend.js
     * @param {*} config size legend config object (sizeLegend object specified as property of legend() config object)
     */
    function buildSizeLegend() {
        const map = out.map
        const config = out.sizeLegend
        const container = out.lgg.append('g').attr('class', 'em-pie-size-legend')

        const domain = map.sizeClassifier_.domain()

        // Assign default circle radii if none specified by user
        if (!config.values) {
            config.values = [Math.floor(domain[1]), Math.floor(domain[0])]
        }

        // Calculate the maximum circle size to be displayed in the legend
        let maxSize = map.sizeClassifier_((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.max)(config.values))

        // Add the title to the container if available
        if (!config.title && out.title) config.title = out.title // Allow root legend title
        let titleHeight = 0 // This will be adjusted based on whether the title exists
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', 0) // Position the title at the left edge
                .attr('y', out.boxPadding + out.titleFontSize) // Title at top, within padding
                .text(config.title)

            // Adjust title height (using the title font size as a proxy)
            titleHeight = out.titleFontSize + out.boxPadding + config.titlePadding
        }

        // Now position the circles **below** the title
        let y = titleHeight + out.boxPadding + maxSize * 2 // Position circles after title height

        // Append the legend circles
        const legendItems = container
            .selectAll('g')
            .data(config.values)
            .join('g')
            .attr('class', 'em-pie-size-legend-item')
            .attr('transform', `translate(${maxSize + out.boxPadding}, ${y})`) // Dynamically move the circles down

        // Append circles to each group
        legendItems
            .append('circle')
            .attr('class', 'em-pie-size-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -map.sizeClassifier_(d)) // Position circles based on their size
            .attr('r', map.sizeClassifier_) // Radius is calculated from size classifier

        // Append labels to each group
        legendItems
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('y', (d) => -2 * map.sizeClassifier_(d) - out.labelFontSize - 2) // Position labels relative to circles
            .attr('x', 30) // Set the x-position for the labels
            .attr('dy', '1.2em')
            .attr('xml:space', 'preserve')
            .text((d) => d.toLocaleString('en').replace(/,/gi, ' ')) // Format the label text

        // Add lines pointing to the top of the corresponding circle
        legendItems
            .append('line')
            .attr('class', 'em-pie-size-legend-line')
            .attr('x1', 2)
            .attr('x2', 30)
            .attr('y1', (d) => -2 * map.sizeClassifier_(d)) // Position lines relative to circles
            .attr('y2', (d) => -2 * map.sizeClassifier_(d)) // Same position for the y2 to make a horizontal line

        // Save the height value for positioning the color legend (if needed)
        out._sizeLegendHeight = y
        return out
    }

    /**
     * Builds a legend illustrating the statistical values of the pie charts' different colours
     *
     */
    function buildColorLegend() {
        const map = out.map
        const config = out.colorLegend
        //container
        const container = out.lgg.append('g').attr('class', 'em-pie-color-legend')

        //draw title
        if (config.title) {
            container
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out._sizeLegendHeight + out.legendSpacing + out.boxPadding + out.titleFontSize)
                .text(config.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = map.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)
            //the color
            const col = map.catColors()[code] || 'lightgray'

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, code)
                    }
                })

            //label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .attr('dominant-baseline', 'middle')
                .text(map.catLabels()[code] || code)

            i++
        }

        //'no data' legend box
        if (config.noData) {
            const y =
                out._sizeLegendHeight +
                out.legendSpacing +
                out.boxPadding +
                (config.title ? out.titleFontSize + out.boxPadding : 0) +
                i * (config.shapeHeight + config.shapePadding)

            //rectangle
            container
                .append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', config.shapeWidth)
                .attr('height', config.shapeHeight)
                .style('fill', map.noDataFillStyle())
                .on('mouseover', function () {
                    highlightRegions(out.map, 'nd')
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                    }
                })

            //'no data' label
            container
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + config.shapeWidth + config.labelOffset)
                .attr('y', y + config.shapeHeight * 0.5)
                .text(config.noDataText)
        }
    }

    // Highlight selected segments on mouseover
    function highlightRegions(map, code) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Set all segments to white
        allSegments.style('fill', 'white')

        // Highlight only the selected segments by restoring their original color
        const selectedSegments = allSegments.filter("path[code='" + code + "']")
        selectedSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___')) // Restore original color for selected segments
        })
    }

    // Reset all segments to their original colors on mouseout
    function unhighlightRegions(map) {
        const allSegments = map.svg_.selectAll('.piechart').selectAll('path[code]')

        // Restore each segments's original color from the fill___ attribute
        allSegments.each(function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).style('fill', (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(this).attr('fill___'))
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-proportional-symbols.js":
/*!***************************************************!*\
  !*** ./src/legend/legend-proportional-symbols.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maptypes/map-proportional-symbols */ "./src/maptypes/map-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var _legend_pattern_fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./legend-pattern-fill */ "./src/legend/legend-pattern-fill.js");










//set legend labels locale
(0,d3_format__WEBPACK_IMPORTED_MODULE_5__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', ''],
})

/**
 * A legend for proportional symbol map
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    out.ascending = false //the order of the legend elements. Set to false to invert.
    out.legendSpacing = 35 //spacing between color & size legends (if applicable)
    out.labelFontSize = 12 //the font size of the legend labels

    out.noDataShapeWidth = 25
    out.noDataShapeHeight = 20

    //size legend config (legend illustrating the values of different symbol sizes)
    out.sizeLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 5, //padding between title and legend body
        values: undefined, //manually define raw data values
        cellNb: 3, //number of elements in the legend
        shapePadding: 5, //the y distance between consecutive legend shape elements
        shapeOffset: { x: 0, y: 0 },
        shapeFill: 'white',
        shapeStroke: null,
        labelOffset: { x: 10, y: 0 }, //the distance between the legend box elements to the corresponding text label
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined,
        _totalBarsHeight: 0,
        _totalD3SymbolsHeight: 0,
        noData: false, // show no data legend item
        noDataText: 'No data', //no data text label
    }

    // color legend config (legend illustrating the data-driven colour classes)
    out.colorLegend = {
        title: null,
        titleFontSize: 12,
        titlePadding: 10, //padding between title and legend body
        marginTop: 30, // margin top (distance between color and size legend)
        shapeWidth: 25, //the width of the legend box elements
        shapeHeight: 20, //the height of the legend box elements
        shapePadding: 1, //the distance between consecutive legend shape elements in the color legend
        labelOffset: { x: 5, y: 0 }, //distance (x) between label text and its corresponding shape element
        decimals: 0, //the number of decimal for the legend labels
        labelFormatter: undefined, // user-defined d3 format function
        labelType: 'thresholds', // type of labels to show: thresholds or ranges
        labels: null, // user-defined labels for each class
        noData: true, //show no data
        noDataText: 'No data', //no data text label
        sepLineLength: 24, // //the separation line length
        sepLineStroke: 'black', //the separation line color
        sepLineStrokeWidth: 1, //the separation line width
        tickLength: 5, // threshold ticks length in px
    }

    //override attribute values with config values
    if (config)
        for (let key in config) {
            if (key == 'colorLegend' || key == 'sizeLegend') {
                for (let p in out[key]) {
                    //override each property in size and color legend configs
                    if (config[key][p] !== undefined) {
                        out[key][p] = config[key][p]
                    }
                }
                if (config.colorLegend == false) out.colorLegend = false
            } else {
                out[key] = config[key]
            }
        }

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        if (out.lgg.node()) {
            const m = out.map
            const lgg = out.lgg

            //remove previous content
            lgg.selectAll('*').remove()

            //draw legend background box
            out.makeBackgroundBox()

            // reset height counters
            out.sizeLegend._totalBarsHeight = 0
            out.sizeLegend._totalD3SymbolsHeight = 0

            // legend for size
            out._sizeLegendNode = lgg.append('g').attr('class', 'size-legend-container')
            if (m.classifierSize_) {
                buildSizeLegend(m, out.sizeLegend)
            }
            // legend for ps color values
            out._colorLegendNode = lgg.append('g').attr('class', 'color-legend-container')

            // position it below size legend
            if (out._sizeLegendNode) {
                out._colorLegendNode.attr('transform', `translate(0,${out._sizeLegendNode.node().getBBox().height})`)
            }

            if (m.classifierColor_ && out.colorLegend) {
                buildColorLegend(m, out.colorLegend)
            }

            // Append pattern fill legend items BELOW the main legend
            // Get the total height of the choropleth legend box
            const legendHeight = out.lgg.node().getBBox().height
            ;(0,_legend_pattern_fill__WEBPACK_IMPORTED_MODULE_4__.appendPatternFillLegend)(map, out.lgg, {
                shapeWidth: out.shapeWidth,
                shapeHeight: out.shapeHeight,
                labelOffset: out.labelOffset,
                boxPadding: out.boxPadding,
                offsetY: legendHeight + out.boxPadding + 5, // << this shifts pattern legend down
            })

            //set legend box dimensions
            out.setBoxDimension()
        }
    }

    /**
     * Builds a legend which illustrates the statistical values of different symbol sizes
     *
     * @param {*} map map instance
     * @param {*} container parent legend object from core/legend.js
     */
    function buildSizeLegend(m) {
        if (!m.psCustomSVG_ && m.psShape_ == 'circle') {
            buildCircleLegend(m, out.sizeLegend)
            if (out.sizeLegend.noData) {
                let y = out._sizeLegendNode.node().getBBox().height + 25
                let x = out.boxPadding
                let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)
                buildNoDataLegend(container, out.sizeLegend.noDataText)
            }
            return
        } else if (m.psShape_ == 'spike') {
            buildSpikeLegend(m, out.sizeLegend)
            return
        }

        //define format for labels
        let labelFormatter = out.sizeLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        //draw title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let domain = m.classifierSize_.domain()
        let maxVal = domain[1] //maximum value of dataset (used for first or last symbol by default)

        // if user defines values for legend manually
        if (out.sizeLegend.values) {
            out.sizeLegend.cellNb = out.sizeLegend.values.length
        }

        //draw legend elements for classes: symbol + label

        // for custom paths
        m.customSymbols = { nodeHeights: 0 } // save some custom settings for buildCustomSVGItem

        for (let i = 1; i < out.sizeLegend.cellNb + 1; i++) {
            //define class number
            const c = out.ascending ? out.sizeLegend.cellNb - i + 1 : i
            //define raw value
            let val = out.sizeLegend.values ? out.sizeLegend.values[c - 1] : maxVal / c
            //calculate shape size
            let symbolSize = m.classifierSize_(val)

            if (m.psShape_ == 'bar') {
                buildBarsItem(map, val, symbolSize, i, labelFormatter)
            } else if (m.psShape_ == 'custom' || m.psCustomSVG_) {
                buildCustomSVGItem(map, val, symbolSize, i, labelFormatter)
            } else {
                buildD3SymbolItem(map, val, symbolSize, i, labelFormatter)
            }
        }

        if (out.sizeLegend.noData) {
            let y = out._sizeLegendNode.node().getBBox().height
            if (out.colorLegend) {
                y += out.colorLegend.shapeHeight + 5
            }
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    function buildSpikeLegend(map, sizeLegendConfig) {
        const spike = (length, width = map.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`

        let maxSize = map.classifierSize_(map.classifierSize_.domain()[1])

        // Determine values for the legend
        let legendValues = out.sizeLegend.values || map.classifierSize_.ticks(4).slice(1) // Use user-defined values or default ticks

        const fontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getFontSizeFromClass)('em-legend-label') // Adjust font size
        const labelSpacing = fontSize - 2 // Ensure labels are just below the spikes

        const legend = out._sizeLegendNode
            .append('g')
            .attr('id', 'em-spike-legend')
            .attr('transform', `translate(${out.boxPadding + 5},0)`)
            .attr('fill', 'black')
            .attr('text-anchor', 'middle')
            .style('font-size', `${fontSize}px`)
            .selectAll()
            .data(legendValues) // Now uses user-defined values if provided
            .join('g')
            .attr('transform', (d, i) => `translate(${40 * i + out.boxPadding},${maxSize + 5})`) // Increase spacing

        // Append spikes
        legend
            .append('path')
            .attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)
            .attr('d', (d) => spike(map.classifierSize_(d))) // Correctly maps values to spike size

        // Append labels directly below each spike
        legend
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', labelSpacing) // Ensure text is right below spikes
            .text((d) => map.classifierSize_.tickFormat(4, 's')(d))

        //  Add "No Data" item with more spacing
        if (out.sizeLegend.noData) {
            let lastLabelY = maxSize + labelSpacing + fontSize + 5 // Adjust position below the labels
            let x = out.boxPadding
            let container = out._sizeLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${lastLabelY})`)
            buildNoDataLegend(container, out.sizeLegend.noDataText)
        }
    }

    //'no data' legend box
    function buildNoDataLegend(container, noDataText) {
        let m = out.map

        //append symbol & style
        container
            .append('rect')
            .attr('class', 'em-legend-rect')
            .style('fill', m.noDataFillStyle())
            .attr('width', out.colorLegend ? out.colorLegend.shapeWidth : out.noDataShapeWidth)
            .attr('height', out.colorLegend ? out.colorLegend.shapeHeight : out.noDataShapeHeight)
            .on('mouseover', function () {
                highlightRegions(out.map, 'nd')
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, 'nd')
                }
            })
            .on('mouseout', function () {
                unhighlightRegions(out.map)
                if (out.map.insetTemplates_) {
                    (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, 'nd')
                }
            })

        //'no data' label
        container
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', out.colorLegend ? out.colorLegend.shapeWidth + out.colorLegend.labelOffset.x : out.noDataShapeWidth + 5)
            .attr('y', out.colorLegend ? out.colorLegend.shapeHeight / 2 : out.noDataShapeHeight / 2)
            .text(noDataText)
    }

    function highlightRegions(map, ecl) {
        // TODO: change this to estat logic of making all other classes transparent?
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', map.hoverColor())
        sel.attr('fill___', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).style('fill')
        })
    }

    function unhighlightRegions(map, ecl) {
        let selector = out.geo_ === 'WORLD' ? '#em-worldrg' : '#em-nutsrg'
        if (map.Geometries.userGeometries) selector = '#em-user-regions' // for user-defined geometries
        const sel = map.selectAll(selector).selectAll("[ecl='" + ecl + "']")
        sel.style('fill', function () {
            ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('fill___')
        })
    }

    /**
     * @description builds a size legend item for proportional D3 shapes (e.g. square, triangle, star)
     * @param {*} m map instance
     * @param {number} symbolSize the size of the symbol item
     */
    function buildD3SymbolItem(m, value, symbolSize, index, labelFormatter) {
        let symbolHeight = out.map.psShape_ == 'triangle' || out.map.psShape_ == 'diamond' ? symbolSize : symbolSize / 2
        if (out.sizeLegend._totalD3SymbolsHeight == 0) out.sizeLegend._totalD3SymbolsHeight += symbolHeight + out.boxPadding //add first item height to y
        let maxSize = m.classifierSize_(m.classifierSize_.domain()[1])
        // x and y position of item in legend
        let x = maxSize
        let y =
            (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) +
            out.sizeLegend._totalD3SymbolsHeight +
            (out.sizeLegend.shapePadding * index - 1)

        out.sizeLegend._totalD3SymbolsHeight += symbolSize

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw D3 symbol
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()
        itemContainer
            .append('g')
            // .attr('transform', `translate(${x},${y})`)
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = maxSize / 2 + out.sizeLegend.labelOffset.x + out.boxPadding

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', 0)
            .text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} value
     * @param {*} symbolSize
     * @param {*} index
     * @param {*} labelFormatter
     */
    function buildCustomSVGItem(m, value, symbolSize, index, labelFormatter) {
        let x = out.boxPadding //set X offset
        let y

        //first item
        if (!m.customSymbols.prevSymb) {
            y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20
            m.customSymbols.initialTranslateY = y
            m.customSymbols.prevScale = symbolSize
        }

        //following items
        if (m.customSymbols.prevSymb) {
            let prevNode = m.customSymbols.prevSymb.node()
            let bbox = prevNode.getBBox()
            m.customSymbols.nodeHeights = m.customSymbols.nodeHeights + bbox.height * m.customSymbols.prevScale
            y = m.customSymbols.initialTranslateY + m.customSymbols.nodeHeights + out.sizeLegend.shapePadding * (index - 1)
            m.customSymbols.prevScale = symbolSize
        }

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw standard symbol
        m.customSymbols.prevSymb = itemContainer
            .append('g')
            .attr('class', 'em-size-legend-symbol')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('g')
            .html(out.map.psCustomSVG_)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })

        //label position
        let labelX = x + m.classifierSize_(m.classifierSize_.domain()[0]) + out.sizeLegend.labelOffset.x
        let labelY = out.sizeLegend.shapeOffset.y / 2 + 1 //y + out.sizeLegend.labelOffset.y

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', labelY)
            .text(labelFormatter(value))
    }

    /**
     * @description
     * @param {*} m
     * @param {*} symbolSize
     */
    function buildBarsItem(m, value, symbolSize, index, labelFormatter) {
        // for vertical bars we dont use a dynamic X offset because all bars have the same width
        let x = out.boxPadding
        //we also dont need the y offset
        let y = out.boxPadding + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + out.sizeLegend._totalBarsHeight + 10

        out.sizeLegend._totalBarsHeight += symbolSize + 10

        //set shape size and define 'd' attribute
        let shape = getShape()
        let d = shape.size(symbolSize * symbolSize)()

        //container for symbol and label
        let itemContainer = out._sizeLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-size-legend-item')

        // draw bar symbol
        itemContainer
            .append('g')
            .style('fill', (d) => {
                // if secondary stat variable is used for symbol colouring, then dont colour the legend symbols using psFill()
                return m.classifierColor_ ? out.sizeLegend.shapeFill : m.psFill_
            })
            .style('fill-opacity', m.psFillOpacity())
            .style('stroke', out.sizeLegend.shapeStroke ? out.sizeLegend.shapeStroke : m.psStroke())
            .style('stroke-width', m.psStrokeWidth())
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .append('path')
            .attr('d', d)
            .attr('transform', () => {
                if (out.map.psCustomSVG_) return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y}) scale(${symbolSize})`
                else return `translate(${out.sizeLegend.shapeOffset.x},${out.sizeLegend.shapeOffset.y})`
            })
        //label position
        let labelX = x + out.map.psBarWidth_ + out.sizeLegend.labelOffset.x
        let labelY = symbolSize / 2 + out.sizeLegend.labelOffset.y

        //append label
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('x', labelX)
            .attr('y', labelY)
            .text(labelFormatter(value))
    }

    /**
     * @description builds a nested circle legend for proportional circles
     * @param {*} m map
     */
    function buildCircleLegend(m) {
        //assign default circle radiuses if none specified by user
        let domain = m.classifierSize_.domain()
        if (!out.sizeLegend.values) {
            // default legend values
            out._sizeLegendValues = [Math.floor(domain[1]), Math.floor(domain[1] / 2), Math.floor(domain[0])]
        } else {
            // user defined legend values
            out._sizeLegendValues = out.sizeLegend.values
        }

        //draw title
        if (!out.sizeLegend.title && out.title) out.sizeLegend.title = out.title //if unspecified, set size legend title as root legend title
        if (out.sizeLegend.title) {
            out._sizeLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.sizeLegend.title)
        }

        let maxRadius = m.classifierSize_((0,d3_array__WEBPACK_IMPORTED_MODULE_3__.max)(out._sizeLegendValues)) //maximum circle radius to be shown in legend
        let x = out.boxPadding + maxRadius
        let y = out.boxPadding + maxRadius * 2 + (out.sizeLegend.title ? out.titleFontSize + out.sizeLegend.titlePadding : 0) + 20

        let itemContainer = out._sizeLegendNode
            .append('g')
            .attr('transform', `translate(${x},${y})`)
            .attr('class', 'circle-legend')
            .attr('text-anchor', 'right')
            .style('fill', 'black')
            .selectAll('g')
            .data(out._sizeLegendValues.filter((d) => m.classifierSize_(d))) // Filter data before binding
            .join('g')
            .attr('class', 'em-legend-item')

        //circles
        itemContainer
            .append('circle')
            .attr('class', 'em-legend-circle')
            .style('fill', 'none')
            .attr('stroke', 'black')
            .attr('cy', (d) => -m.classifierSize_(d))
            .attr('r', m.classifierSize_)

        //labels
        itemContainer
            .append('text')
            .attr('class', 'em-legend-label')
            .attr('dy', '0.35em') // ~vertical centering
            .attr('y', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x', maxRadius + 5)
            .text((d) => {
                return d.toLocaleString('en').replace(/,/gi, ' ')
            })
        //line pointing to top of corresponding circle:
        itemContainer
            .append('line')
            .style('stroke-dasharray', 2)
            .style('stroke', 'grey')
            .attr('x1', 2)
            .attr('y1', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })
            .attr('x2', maxRadius + 5)
            .attr('y2', (d, i) => {
                let y = -1 - 2 * m.classifierSize_(d)
                return y
            })

        return out
    }

    /**
     * Builds a legend illustrating the statistical values of different symbol colours
     *
     * @param {*} m map
     */
    function buildColorLegend(m) {
        if (out.colorLegend.labelType === 'ranges') {
            buildColorRangesLegend(m)
        } else {
            buildColorThresholdsLegend(m)
        }
    }

    function getColorThresholds() {
        const map = out.map
        const thresholds =
            map.psThresholds_.length > 1
                ? map.psThresholds_
                : Array.from({ length: map.psClasses_ })
                      .map((_, index) => {
                          return map.classifierColor_.invertExtent(index)[out.ascending ? 0 : 1]
                      })
                      .slice(1) // Remove the first entry and return the rest as an array
        return thresholds
    }

    function buildColorRangesLegend(m) {
        const f = out.colorLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator
        const thresholds = getColorThresholds()
        const numberOfClasses = m.psClasses_

        //title
        if (out.colorLegend.title) {
            out._colorLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.titleFontSize + out.colorLegend.marginTop)
                .text(out.colorLegend.title)
        }

        const x = out.boxPadding

        for (let i = 0; i < numberOfClasses; i++) {
            let y =
                out.titleFontSize +
                out.colorLegend.titlePadding +
                out.colorLegend.marginTop +
                i * (out.colorLegend.shapeHeight + out.colorLegend.shapePadding)

            const ecl = out.ascending ? i : numberOfClasses - i - 1

            const itemContainer = out._colorLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-legend-item')

            // Rectangle
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .style('fill', m.psClassToFillStyle()(ecl, numberOfClasses))
                .attr('width', out.colorLegend.shapeWidth)
                .attr('height', out.colorLegend.shapeHeight)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            // Label
            itemContainer
                .append('text')
                .attr('class', 'em-legend-label')
                .attr('dy', '0.35em') // ~vertical centering
                .attr('x', out.colorLegend.shapeWidth + out.colorLegend.labelOffset.x)
                .attr('y', out.colorLegend.shapeHeight / 2)
                .text(() => {
                    if (out.colorLegend.labels) return out.colorLegend.labels[i] // user-defined labels
                    if (i === 0) return `> ${f(thresholds[thresholds.length - 1])}`
                    if (i === thresholds.length) return `< ${f(thresholds[0])}`
                    return `${f(thresholds[thresholds.length - i - 1])} - < ${f(thresholds[thresholds.length - i])}`
                })
        }

        // Optionally add no-data
        if (out.colorLegend.noData) {
            let y = out.titleFontSize + out.colorLegend.marginTop + numberOfClasses * out.colorLegend.shapeHeight + 20 // add 20 to separate it from the rest
            let container = out._colorLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.colorLegend.noDataText)
        }
    }

    function buildColorThresholdsLegend(m) {
        //define format for labels
        const labelFormatter = out.colorLegend.labelFormatter || _core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator

        //title
        if (out.colorLegend.title) {
            out._colorLegendNode
                .append('text')
                .attr('class', 'em-legend-title')
                .attr('x', out.boxPadding)
                .attr('y', out.titleFontSize + out.colorLegend.marginTop)
                .text(out.colorLegend.title)
        }

        // x position of color legend cells
        let x = out.boxPadding

        //draw legend elements for classes: rectangle + label
        let numberOfClasses = m.psClasses_

        for (let i = 0; i < numberOfClasses; i++) {
            //the vertical position of the legend element
            let y = out.titleFontSize + out.colorLegend.titlePadding + out.colorLegend.marginTop + i * out.colorLegend.shapeHeight // account for title + margin

            //the class number, depending on order
            const ecl = out.ascending ? i : numberOfClasses - i - 1

            let itemContainer = out._colorLegendNode.append('g').attr('transform', `translate(${x},${y})`).attr('class', 'em-legend-item')

            //append symbol & style
            itemContainer
                .append('rect')
                .attr('class', 'em-legend-rect')
                .style('fill', m.psClassToFillStyle()(ecl, numberOfClasses))
                .attr('width', out.colorLegend.shapeWidth)
                .attr('height', out.colorLegend.shapeHeight)
                .on('mouseover', function () {
                    highlightRegions(out.map, ecl)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, ecl)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions, ecl)
                    }
                })

            //separation line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-separator')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', 0 + out.colorLegend.sepLineLength)
                    .attr('y2', 0)
            }

            // Append tick line
            if (i > 0) {
                itemContainer
                    .append('line')
                    .attr('class', 'em-legend-tick')
                    .attr('x1', out.colorLegend.shapeWidth)
                    .attr('y1', 0)
                    .attr('x2', out.colorLegend.sepLineLength + out.colorLegend.tickLength)
                    .attr('y2', 0)
            }

            //label
            if (i < numberOfClasses - 1) {
                itemContainer
                    .append('text')
                    .attr('class', 'em-legend-label')
                    .attr('dy', '0.35em') // ~vertical centering
                    .attr('x', out.colorLegend.sepLineLength + out.colorLegend.tickLength + out.colorLegend.labelOffset.x)
                    .attr('y', out.colorLegend.shapeHeight)
                    .text(
                        out.colorLegend.labels
                            ? out.colorLegend.labels[i]
                            : labelFormatter(m.classifierColor_.invertExtent(out.ascending ? ecl + 1 : ecl - 1)[out.ascending ? 0 : 1])
                    )
            }
        }

        //'no data' legend box
        if (out.colorLegend.noData) {
            let y = out.titleFontSize + out.colorLegend.marginTop + numberOfClasses * out.colorLegend.shapeHeight + 20 // add 20 to separate it from the rest
            let container = out._colorLegendNode.append('g').attr('class', 'em-no-data-legend').attr('transform', `translate(${x},${y})`)

            buildNoDataLegend(container, out.colorLegend.noDataText)
        }
    }

    /**
     * @description returns the d3.symbol object chosen by the user
     * @return {d3.shape || SVG}
     */
    function getShape() {
        let shape
        if (out.map.psCustomSVG_) {
            shape = out.map.psCustomSVG_
        } else if (out.map.psCustomShape_) {
            shape = out.map.psCustomShape_
        } else if (out.map.psShape_ == 'bar') {
            //for rectangles, we use a custom d3 symbol
            let drawRectangle = (context, size) => {
                let height = Math.sqrt(size)
                context.moveTo(0, 0)
                context.lineTo(0, height)
                context.lineTo(out.map.psBarWidth_, height)
                context.lineTo(out.map.psBarWidth_, 0)
                context.lineTo(0, 0)
                context.closePath()
            }
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])().type({ draw: drawRectangle })
        } else {
            let symbolType = _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary[out.map.psShape_] || _maptypes_map_proportional_symbols__WEBPACK_IMPORTED_MODULE_1__.symbolsLibrary['circle']
            shape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])().type(symbolType)
        }
        return shape
    }

    // Highlight selected regions on mouseover
    function highlightRegions(map, ecl) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Set all symbols to white
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this.childNodes[0])
            symbol.style('fill', 'white')
        })

        // Highlight only the selected regions by restoring their original color
        const selectedSymbols = allSymbols.filter("[ecl='" + ecl + "']")
        selectedSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    // Reset all regions to their original colors on mouseout
    function unhighlightRegions(map) {
        //for ps, the symbols are the children of each em-prop-symbols element
        const allSymbols = map.svg_.selectAll('#em-prop-symbols').selectAll('[ecl]')

        // Restore each region's original color from the fill___ attribute
        allSymbols.each(function (d, i) {
            let symbol = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this.childNodes[0])
            symbol.style('fill', symbol.attr('fill___')) // Restore original color for selected regions
        })
    }

    return out
}


/***/ }),

/***/ "./src/legend/legend-stripe-composition.js":
/*!*************************************************!*\
  !*** ./src/legend/legend-stripe-composition.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legend */ "./src/legend/legend.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");





/**
 * A legend for choropleth maps
 *
 * @param {*} map
 */
const legend = function (map, config) {
    //build generic legend object for the map
    const out = _legend__WEBPACK_IMPORTED_MODULE_0__.legend(map)

    //the width of the legend box elements
    out.shapeWidth = 25
    //the height of the legend box elements
    out.shapeHeight = 20
    //the distance between consecutive legend box elements
    out.shapePadding = 5
    //the font size of the legend label
    out.labelFontSize = 12
    //the distance between the legend box elements to the corresponding text label
    out.labelOffset = 5
    //show no data
    out.noData = true
    //no data label text
    out.noDataText = 'No data'

    //override attribute values with config values
    if (config) for (let key in config) out[key] = config[key]

    //@override
    out.update = function () {
        out.updateConfig()
        out.updateContainer()

        const m = out.map
        const svgMap = m.svg()
        const lgg = out.lgg

        //remove previous content
        lgg.selectAll('*').remove()

        //draw legend background box
        out.makeBackgroundBox()

        //draw title
        if (out.title) {
            lgg.append('text')
                .attr('class', 'em-legnd-title')
                .attr('x', out.boxPadding)
                .attr('y', out.boxPadding + out.titleFontSize)
                .text(out.title)
        }

        //draw legend elements for classes: rectangle + label
        let i = 0
        const scs = m.catColors()
        for (let code in scs) {
            //the vertical position of the legend element
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //the color
            const col = m.catColors()[code] || 'lightgray'

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', scs[code])
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .on('mouseover', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this)
                    sel.raise()
                    highlightRegions(out.map, code)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, highlightRegions, code)
                    }
                })
                .on('mouseout', function () {
                    unhighlightRegions(out.map)
                    if (out.map.insetTemplates_) {
                        (0,_core_utils__WEBPACK_IMPORTED_MODULE_1__.executeForAllInsets)(out.map.insetTemplates_, out.map.svgId, unhighlightRegions)
                    }
                })

            //label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(m.catLabels()[code] || code)
                .on('mouseover', function () {
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const col = m.catColors()[code] || 'lightgray'
                    svgMap
                        .selectAll('pattern')
                        .selectAll("rect[code='" + code + "']")
                        .style('fill', col)
                })

            i++
        }

        //'no data' legend box
        if (out.noData) {
            const y = out.boxPadding + (out.title ? out.titleFontSize + out.boxPadding : 0) + i * (out.shapeHeight + out.shapePadding)

            //rectangle
            lgg.append('rect')
                .attr('class', 'em-legend-rect')
                .attr('x', out.boxPadding)
                .attr('y', y)
                .attr('width', out.shapeWidth)
                .attr('height', out.shapeHeight)
                .style('fill', m.noDataFillStyle())
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this).style('fill', m.noDataFillStyle())
                })

            //'no data' label
            lgg.append('text')
                .attr('class', 'em-legend-label')
                .attr('x', out.boxPadding + out.shapeWidth + out.labelOffset)
                .attr('y', y + out.shapeHeight * 0.5)
                .text(out.noDataText)
                .on('mouseover', function () {
                    svgMap.select('#em-nutsrg').selectAll("[nd='nd']").style('fill', m.hoverColor())
                })
                .on('mouseout', function () {
                    const sel = svgMap
                        .select('#em-nutsrg')
                        .selectAll("[nd='nd']")
                        .style('fill', function (d) {
                            m.noDataFillStyle()
                        })
                })
        }

        //set legend box dimensions
        out.setBoxDimension()
    }

    function highlightRegions(map, code) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Save original colors if not already stored
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            if (!el.attr('data-original-fill')) {
                el.attr('data-original-fill', el.style('fill'));
            }
            el.style('fill', 'white'); // Set all regions to white
        });
    
        // Highlight only the selected regions by restoring their original color
        const selectedRegions = map.svg_.selectAll("pattern").selectAll("rect[code='" + code + "']");
        selectedRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            el.style('fill', el.attr('data-original-fill')); // Restore original fill
        });
    }
    
    function unhighlightRegions(map) {
        const allRegions = map.svg_.selectAll('pattern').selectAll('rect');
    
        // Restore each region's original color from the stored attribute
        allRegions.each(function () {
            const el = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(this);
            const originalFill = el.attr('data-original-fill');
            if (originalFill) {
                el.style('fill', originalFill);
            }
        });
    }
    
    return out
}


/***/ }),

/***/ "./src/legend/legend.js":
/*!******************************!*\
  !*** ./src/legend/legend.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legend: () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



/**
 * A eurostat-map legend. This is an abstract method.
 */
const legend = function (map) {
    //build legend object
    const out = {}

    //link map to legend
    out.map = map

    //the SVG where to make the legend
    out.svgId = 'legend_' + Math.round(10e15 * Math.random())
    out.svg = undefined
    out.lgg = undefined

    //the legend element position, in case it is embeded within the map SVG
    out.x = undefined
    out.y = undefined

    //the legend box
    out.boxPadding = 7
    out.boxOpacity = 0.7

    //legend title
    out.title = ''
    // we now use CSS instead of inline styles
    out.titleFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-title')
    // we now use CSS instead of inline styles
    out.labelFontSize = (0,_core_utils__WEBPACK_IMPORTED_MODULE_0__.getFontSizeFromClass)('em-legend-label')

    /** Build legend. */
    out.build = function () {
        //set SVG element and add main drawing group
        out.svg = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + out.svgId)
        // clear previous legend(s)
        out.svg.selectAll('#em-legend-' + out.svgId).remove()
        // append new legend group
        out.lgg = out.svg
            .append('g')
            .attr('id', 'em-legend-' + out.svgId)
            .attr('class', 'em-legend')
    }

    /**
     * Update the legend element.
     * This is an abstract method to be defined for each specific legend.
     */
    out.update = function () {
        console.log('Legend update function not implemented')
        return out
    }

    out.updateContainer = function () {
        const map = out.map
        const container = out.lgg
        // Remove previous content
        container.selectAll('*').remove()

        //check if provided external svgId has changed
        const legendSVG = out.svg
        if (legendSVG.attr('id') !== map.legend_.svgId) {
            out.build() // sets new svg and lgg
        }
    }

    out.updateConfig = function () {
        const map = out.map
        // Update legend parameters if necessary
        if (map.legend_) {
            deepMergeExistingKeys(out, map.legend_)
        }

        //ps
        // // update legend parameters if necessary
        // if (m.legend_)
        //     for (let key in m.legend_) {
        //         if (key == 'colorLegend' || key == 'sizeLegend') {
        //             for (let p in out[key]) {
        //                 //override each property in size and color legend m.legend_
        //                 if (m.legend_[key][p] !== undefined) {
        //                     out[key][p] = m.legend_[key][p]
        //                 }
        //             }
        //         } else {
        //             out[key] = m.legend_[key]
        //         }
        //     }
    }

    //It performs a shallow copy  nested objects will be copied by reference, not duplicated.
    //It modifies the target object (out) in place.
    //Useful for merging objects or extending existing ones.
    function deepMergeExistingKeys(target, source, options = {}, seen = new WeakSet(), depth = 0) {
        const MAX_DEPTH = options.maxDepth || 100

        if (seen.has(target)) return target
        seen.add(target)

        if (depth > MAX_DEPTH) {
            console.warn(`Max recursion depth (${MAX_DEPTH}) reached.`)
            return target
        }

        for (const key in source) {
            if (source.hasOwnProperty(key) && target.hasOwnProperty(key)) {
                const sourceVal = source[key]
                const targetVal = target[key]

                // Handle functions: overwrite directly
                if (typeof sourceVal === 'function') {
                    target[key] = sourceVal

                    // Handle nested plain objects
                } else if (isPlainObject(sourceVal) && isPlainObject(targetVal)) {
                    deepMergeExistingKeys(targetVal, sourceVal, options, seen, depth + 1)

                    // Handle arrays: overwrite (or merge if option set)
                } else if (Array.isArray(sourceVal) && Array.isArray(targetVal)) {
                    target[key] = options.mergeArrays ? [...new Set([...targetVal, ...sourceVal])] : [...sourceVal]

                    // Handle Dates
                } else if (sourceVal instanceof Date) {
                    target[key] = new Date(sourceVal.getTime())

                    // Handle RegExp
                } else if (sourceVal instanceof RegExp) {
                    target[key] = new RegExp(sourceVal)

                    // Handle Map and Set
                } else if (sourceVal instanceof Map) {
                    target[key] = new Map(sourceVal)
                } else if (sourceVal instanceof Set) {
                    target[key] = new Set(sourceVal)

                    // Overwrite primitives and other types
                } else {
                    target[key] = sourceVal
                }
            }
        }

        return target
    }

    // Helper to check for plain objects
    function isPlainObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]'
    }

    /** Draw legend background box */
    out.makeBackgroundBox = function () {
        out.lgg.append('rect').attr('id', 'legendBR').attr('class', 'em-legend-background').style('opacity', out.boxOpacity)
    }

    /** Set legend box dimensions, ensuring it has suitable dimensions to fit to all legend graphic elements */
    out.setBoxDimension = function () {
        if (out.lgg.node()) {
            //get legend elements bounding box
            const bb = out.lgg.node().getBBox({ stroke: true })
            //apply to legend box dimensions
            const p = out.boxPadding
            out.svg
                .select('#legendBR')
                .attr('x', bb.x - p)
                .attr('y', bb.y - p)
                .attr('width', bb.width + 2 * p)
                .attr('height', bb.height + 2 * p)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-categorical.js":
/*!*****************************************!*\
  !*** ./src/maptypes/map-categorical.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-categorical */ "./src/legend/legend-categorical.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");








/**
 * Returns a categorical map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'ct')

    /** Fill style for each category/class. Ex.: { urb: "#fdb462", int: "#ffffb3", rur: "#ccebc5" } */
    out.classToFillStyle_ = undefined
    /** Text label for each category/class. Ex.: { "urb": "Urban", "int": "Intermediate", "rur": "Rural" } */
    out.classToText_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunCat

    //the classifier: a function which returns a class number from a stat value.
    out.classifier_ = undefined

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;['classToFillStyle_', 'classToText_', 'noDataFillStyle_', 'tooltipText_', 'classifier_'].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['classToFillStyle', 'classToText', 'noDataFillStyle', 'tooltipText', 'classifier'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //get domain (unique values)
        const domain = out.statData().getUniqueValues()

        //get range [0,1,2,3,...,domain.length-1]
        const range = [...Array(domain.length).keys()]

        //make classifier
        //only use user-define classes
        const ctfs = out.classToFillStyle_ ? out.classToFillStyle() : undefined
        if (ctfs) {
            const categories = Object.keys(ctfs)
            out.classifier(
                (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])()
                    .domain(categories) // Only classify known categories
                    .range(categories.map((_, i) => i)) // Assign numerical classes
            )
        } else {
            // Use all unique values if no user-defined classes exist
            out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])().domain(domain).range(range))
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const sv = out.statData().get(rg.properties.id)
                if (!sv) return

                const v = sv.value
                if (v === ':') return 'nd' // No data

                const value = isNaN(v) ? v : +v // Convert numbers, keep strings as is

                //  Ensure only known values are classified
                const classifierDomain = out.classifier().domain()
                if (!classifierDomain.includes(value)) return // Skip unknown values

                return out.classifier()(value)
            })
        }

        let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        classifyRegions(map.svg().selectAll(selector))

        // Handle mixed NUTS level, separating NUTS level 0
        if (map.nutsLevel_ === 'mixed') {
            const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
            classifyRegions(nuts0Regions)
        }
    }

    //@override
    out.updateStyle = function () {
        //if no color specified, use some default colors
        if (!out.classToFillStyle()) {
            const ctfs = {}
            const dom = out.classifier().domain()
            for (let i = 0; i < dom.length; i++) ctfs[dom[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__["default"][i % 12]
            out.classToFillStyle(ctfs)
        }

        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)
        return out
    }

    function applyStyleToMap(map) {
        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_3__.applyPatternFill)(map, out.patternFill_)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .style('display', function (rg) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')
                return ecl || lvl === '0' ? 'block' : 'none'
            })
            .style('stroke', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const stroke = sel.style('stroke')
                return ecl && lvl !== '0' ? stroke || '#777' : null
            })
            .style('stroke-width', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                const lvl = sel.attr('lvl')
                const ecl = sel.attr('ecl')
                const strokeWidth = sel.style('stroke-width')
                return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle_[out.classifier().domain()[ecl]]
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_[out.classifier().domain()[ecl]]
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle_[out.classifier().domain()[ecl]]
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        // Set up mouse events
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_categorical__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunCat = function (rg, map) {
    const buf = []
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar">' + rg.properties.na + '</div>')
    }
    //get stat value
    const sv = map.statData().get(rg.properties.id)
    //case when no data available
    if (!sv || (sv.value != 0 && !sv.value)) {
        buf.push(map.noDataText_)
        return buf.join('')
    }
    const val = sv.value
    if (map.classToText_) {
        const lbl = map.classToText_[val]
        //display label and value
        buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${lbl ? lbl : val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
        return buf.join('')
    }
    //display just value
    buf.push(`
    <div class="estat-vis-tooltip-text">
    <table class="nuts-table">
    <tbody>
    <tr>
    <td>
    ${val}
    </td>
    </tr>
    </tbody>
    </table>
    </div>
`)
    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-bivariate.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-choropleth-bivariate.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-bivariate */ "./src/legend/legend-choropleth-bivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a bivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chbi')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#73ae80'
    out.color2_ = '#6c83b5'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined

    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunBiv

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        const setupClassifiers = () => {
            let stat1 = out.statData('v1').getArray()
            let stat2 = out.statData('v2').getArray()

            const range = [...Array(out.numberOfClasses()).keys()]
            if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
            if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))

            //define bivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleBivariate(out.numberOfClasses(), out.startColor(), out.color1(), out.color2(), out.endColor())
                out.classToFillStyle(scale)
            }
        }

        const classifyRegions = (regions) => {
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    if (rg.properties.id.length == 4) console.log(rg)
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('nd', function (rg) {
                    const sv1 = out.statData('v1').get(rg.properties.id)
                    const sv2 = out.statData('v2').get(rg.properties.id)
                    if (!sv1 || !sv2) return
                    let v = sv1.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    v = sv2.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return ''
                })
        }

        // Initialize classifier
        setupClassifiers()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    if (!ecl1 && !ecl2) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    let color = out.classToFillStyle()(+ecl1, +ecl2)
                    return color
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        // Set up mouse events
                        addMouseEventsToRegions(map, regions)

                        // update font color for grid cartograms (contrast)
                        if (out.gridCartogram_) {
                            map.svg()
                                .selectAll('.em-grid-text')
                                .each(function () {
                                    const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.parentNode).style('fill')
                                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getTextColorForBackground)(cellColor))
                                })
                        }
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                const ecl1 = sel.attr('ecl1')
                const ecl2 = sel.attr('ecl2')
                const lvl = sel.attr('lvl')

                // Determine display visibilitys
                const isVisible = ecl1 || ecl2 || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if ((ecl1 || ecl2) && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.style('fill', map.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_bivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const scaleBivariate = function (numberOfClasses, startColor, color1, color2, endColor) {
    //color ramps, by row
    const cs = []
    //interpolate from first and last columns
    const rampS1 = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(startColor, color1)
    const ramp2E = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(color2, endColor)
    for (let i = 0; i < numberOfClasses; i++) {
        const t = i / (numberOfClasses - 1)
        const colFun = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"])(rampS1(t), ramp2E(t))
        const row = []
        for (let j = 0; j < numberOfClasses; j++) row.push(colFun(j / (numberOfClasses - 1)))
        cs.push(row)
    }
    //TODO compute other matrix based on rows, and average both?

    return function (ecl1, ecl2) {
        return cs[ecl1][ecl2]
    }
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunBiv = function (rg, map) {
    const buf = []
    //region name
    const regionName = rg.properties.na || rg.properties.name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + regionName + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
        ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth-trivariate.js":
/*!***************************************************!*\
  !*** ./src/maptypes/map-choropleth-trivariate.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-choropleth-trivariate */ "./src/legend/legend-choropleth-trivariate.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");







/**
 * Return a trivariate choropleth map.
 * See: https://gistbok.ucgis.org/bok-topics/multivariate-mapping
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'chtri')

    //number of classes for the classification. Same for both variables.
    out.numberOfClasses_ = 3
    //stevens.greenblue
    //TODO make it possible to use diverging color ramps ?
    out.startColor_ = '#e8e8e8'
    out.color1_ = '#09F8FF'
    out.color2_ = '#F5D300'
    out.color3_ = '#FF1493'
    out.endColor_ = '#2a5a5b'
    //a function returning the colors for the classes i,j
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier1_ = undefined
    out.classifier2_ = undefined
    out.classifier3_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunctionTrivariate

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'startColor_',
        'color1_',
        'color2_',
        'color3_',
        'endColor_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier1_',
        'classifier2_',
        'classifier3_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        ['numberOfClasses', 'startColor', 'color1', 'color2', 'color3', 'endColor', 'classToFillStyle', 'noDataFillStyle'].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        //set classifiers
        let stat1 = out.statData('v1').getArray()
        let stat2 = out.statData('v2').getArray()
        let stat3 = out.statData('v3').getArray()

        const range = [...Array(7).keys()]
        if (!out.classifier1_) out.classifier1((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat1).range(range))
        if (!out.classifier2_) out.classifier2((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat2).range(range))
        if (!out.classifier3_) out.classifier3((0,d3_scale__WEBPACK_IMPORTED_MODULE_3__["default"])().domain(stat3).range(range))

        //assign class to nuts regions, based on their value
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
        if (map.svg_) {
            let regions = map.svg().selectAll(selector)
            regions
                .attr('ecl1', function (rg) {
                    const sv = out.statData('v1').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier1_(+v)
                })
                .attr('ecl2', function (rg) {
                    const sv = out.statData('v2').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier2_(+v)
                })
                .attr('ecl3', function (rg) {
                    const sv = out.statData('v3').get(rg.properties.id)
                    if (!sv) return
                    const v = sv.value
                    if ((v != 0 && !v) || v == ':') return 'nd'
                    return +out.classifier3_(+v)
                })
                .attr('regionClass', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')

                    if (ecl1 === 'nd' || ecl2 === 'nd' || ecl3 === 'nd') return 'nd' // Handle 'no data'

                    // Combine the classifier results into a single class (1-7)
                    if (ecl1 && !ecl2 && !ecl3) return 1 // only variable 1 present
                    if (!ecl1 && ecl2 && !ecl3) return 2 // only variable 2 present
                    if (!ecl1 && !ecl2 && ecl3) return 3 // only variable 3 present
                    if (ecl1 && ecl2 && !ecl3) return 4 // variables 1 & 2 present
                    if (ecl1 && !ecl2 && ecl3) return 5 // variables 1 & 3 present
                    if (!ecl1 && ecl2 && ecl3) return 6 // variables 2 & 3 present
                    if (ecl1 && ecl2 && ecl3) return 7 // all present
                })
            // .attr('nd', function (rg) {
            //     const sv1 = out.statData('v1').get(rg.properties.id) || out.statData().get(rg.properties.id)
            //     const sv2 = out.statData('v2').get(rg.properties.id)
            //     if (!sv1 || !sv2) return
            //     let v = sv1.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     v = sv2.value
            //     if ((v != 0 && !v) || v == ':') return 'nd'
            //     return ''
            // })

            //when mixing NUTS, level 0 is separated from the rest (class nutsrg0)
            if (map.nutsLevel_ == 'mixed') {
                map.svg()
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v1').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }

            //define trivariate scale
            if (!out.classToFillStyle()) {
                const scale = scaleTrivariate(out.color1(), out.color2(), out.color3())
                out.classToFillStyle(scale)
            }

            //when mixing NUTS, level 0 is separated from the rest (using class nutsrg0)
            if (out.nutsLevel_ == 'mixed') {
                map.svg_
                    .selectAll('path.em-nutsrg0')
                    .attr('ecl1', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier1_(+v)
                    })
                    .attr('ecl2', function (rg) {
                        const sv = out.statData('v2').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier2_(+v)
                    })
                    .attr('ecl3', function (rg) {
                        const sv = out.statData('v3').get(rg.properties.id)
                        if (!sv) return
                        const v = sv.value
                        if ((v != 0 && !v) || v == ':') return 'nd'
                        return +out.classifier3_(+v)
                    })
            }
        }
    }

    const scaleTrivariate = function (color1, color2, color3) {
        // Blending primary colors and their overlaps
        const overlapColors = [
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2]), // Class 4 (Overlap of color1 and color2)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color2, color3]), // Class 5 (Overlap of color2 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color3]), // Class 6 (Overlap of color1 and color3)
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.multiplyBlendMultipleHex)([color1, color2, color3]), // Class 7 (Overlap of all three)
        ]

        // Class-to-color mapping
        const classColors = [
            color1, // Class 1 (First color)
            color2, // Class 2 (Second color)
            color3, // Class 3 (Third color)
            overlapColors[0], // Class 4 (Overlap of color1 and color2)
            overlapColors[1], // Class 5 (Overlap of color2 and color3)
            overlapColors[2], // Class 6 (Overlap of color1 and color3)
            overlapColors[3], // Class 7 (Overlap of all three)
        ]

        // Return function to get color based on region's class (1 to 7)
        return function (classIndex) {
            if (classIndex >= 1 && classIndex <= 7) {
                return classColors[classIndex - 1]
            } else {
                return null // Return null or a default color if the classIndex is out of range
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        //apply style to nuts regions

        // set colour of regions
        if (map.svg()) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', function (rg) {
                    const ecl1 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl1')
                    const ecl2 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl2')
                    const ecl3 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('ecl3')
                    if (ecl1 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl2 === 'nd') return out.noDataFillStyle() || 'gray'
                    if (ecl3 === 'nd') return out.noDataFillStyle() || 'gray'

                    if (!ecl1 && !ecl2 && !ecl3) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getCSSPropertyFromClass)('em-nutsrg', 'fill') // GISCO-2678 - lack of data no longer means no data, instead it is explicitly set using ':'.

                    let regionClass = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).attr('regionClass')
                    let color = out.classToFillStyle_(regionClass)
                    return color

                    //return getCSSPropertyFromClass('em-nutsrg', 'fill')
                })
                .end()
                .then(
                    () => {
                        // Store the original color for each region
                        regions.each(function () {
                            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                            sel.attr('fill___', sel.style('fill'))
                        })

                        regions
                            .on('mouseover', function (e, rg) {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                sel.style('fill', map.hoverColor_)
                                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                            })
                            .on('mousemove', function (e, rg) {
                                if (out._tooltip) out._tooltip.mousemove(e)
                            })
                            .on('mouseout', function () {
                                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                                let newFill = sel.attr('fill___')
                                if (newFill) {
                                    sel.style('fill', sel.attr('fill___'))
                                    if (out._tooltip) out._tooltip.mouseout()
                                }
                            })
                    },
                    (err) => {
                        // rejection
                    }
                )

            if (out.nutsLevel_ == 'mixed') {
                styleMixedNUTS(map)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth_trivariate__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    return out
}

const styleMixedNUTS = function (map) {
    map.svg()
        .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(map))
        .style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const ecl = sel.attr('ecl')
            const lvl = sel.attr('lvl')
            const countryId = rg.properties.id.slice(0, 2)
            return ecl || lvl === '0' ? 'block' : 'none'
        })
        .style('stroke', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const stroke = sel.style('stroke')
            return ecl && lvl !== '0' ? stroke || '#777' : null
        })
        .style('stroke-width', function () {
            const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
            const lvl = sel.attr('lvl')
            const ecl = sel.attr('ecl')
            const strokeWidth = sel.style('stroke-width')
            return ecl && lvl !== '0' ? strokeWidth || 0.2 : null
        })
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunctionTrivariate = function (rg, map) {
    const buf = []
    //region name
    if (rg.properties.id) {
        //name and code
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + ' (' + rg.properties.id + ') </div>')
    } else {
        //region name
        buf.push('<div class="estat-vis-tooltip-bar" >' + rg.properties.na + '</div>')
    }

    //stat 1 value
    const sv1 = map.statData('v1').get(rg.properties.id)
    const unit1 = map.statData('v1').unitText()
    //stat 2 value
    const sv2 = map.statData('v2').get(rg.properties.id)
    const unit2 = map.statData('v2').unitText()
    //stat 3 value
    const sv3 = map.statData('v3').get(rg.properties.id)
    const unit3 = map.statData('v2').unitText()

    buf.push(`
        <div class="estat-vis-tooltip-text" style="background: #ffffff;color: #171a22;padding: 4px;font-size:15px;">
        <table class="nuts-table">
        <tbody>
        <tr>
        <td>
        Variable 1: ${sv1 && sv1.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv1.value) : ''} ${unit1 && sv1 && sv1.value ? unit1 : ''}
        ${!sv1 || (sv1.value != 0 && !sv1.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 2: ${sv2 && sv2.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv2.value) : ''} ${unit2 && sv2 && sv2.value ? unit2 : ''}
        ${!sv2 || (sv2.value != 0 && !sv2.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        <tr>
        <td>
         Variable 3: ${sv3 && sv3.value ? (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.spaceAsThousandSeparator)(sv3.value) : ''} ${unit3 && sv3 && sv3.value ? unit3 : ''}
        ${!sv3 || (sv3.value != 0 && !sv3.value) ? map.noDataText_ : ''}
        </td>
        </tr>
        </tbody>
        </table>
        </div>
    `)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-choropleth.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-choropleth.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   getFillPatternLegend: () => (/* binding */ getFillPatternLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var simple_statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! simple-statistics */ "./node_modules/simple-statistics/dist/simple-statistics.mjs");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");












/**
 * Returns a chroropleth map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_1__.statMap(config, false, 'ch')

    //the number of classes
    out.numberOfClasses_ = 7
    //the classification method
    out.classificationMethod_ = 'quantile' // or: equinter, threshold
    //the threshold, when the classification method is 'threshold'
    out.thresholds_ = [0]
    //colors to use for classes
    out.colors_ = null
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //the color function [0,1] -> color
    let eurostatMultihue = ['#FFEB99', '#D1E9B0', '#8DD6B9', '#58C1C0', '#3792B6', '#134891', '#1d2b6f']
    out.colorFunction_ = (t) => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["default"])(d3_interpolate__WEBPACK_IMPORTED_MODULE_7__["default"], eurostatMultihue)(Math.min(Math.max(0, t), 1)) // default
    //a function returning the color from the class i
    out.classToFillStyle_ = undefined
    //the classifier: a function which return a class number from a stat value.
    out.classifier_ = undefined
    // set tooltip function
    out.tooltip_.textFunction = choroplethTooltipFunction

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'numberOfClasses_',
        'classificationMethod_',
        'thresholds_',
        'makeClassifNice_',
        'colorFunction_',
        'classToFillStyle_',
        'noDataFillStyle_',
        'classifier_',
        'colors_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override of some special getters/setters
    out.colorFunction = function (v) {
        if (!arguments.length) {
            return out.colorFunction_
        }
        out.colorFunction_ = v
        // update class style function
        if (out.filtersDefinitionFunction_) {
            // if dot density
            out.classToFillStyle(getFillPatternLegend())
        } else {
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }
        return out
    }
    out.threshold = function (v) {
        if (!arguments.length) return out.thresholds_
        out.thresholds_ = v
        out.numberOfClasses(v.length + 1)
        return out
    }
    out.filtersDefinitionFunction = function (v) {
        if (!arguments.length) return out.filtersDefinitionFunction_
        out.filtersDefinitionFunction_ = v
        if (out.svg()) out.filtersDefinitionFunction_(out.svg(), out.numberOfClasses_)
        return out
    }

    //override attribute values with config values
    if (config)
        [
            'numberOfClasses',
            'classificationMethod',
            'threshold',
            'makeClassifNice',
            'colorFunction',
            'classToFillStyle',
            'noDataFillStyle',
            'colors_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    function applyClassificationToMap(map) {
        // Helper function to generate a range [0, 1, 2, ..., nb-1]
        const generateRange = (nb) => [...Array(nb).keys()]

        // Configure classifier based on the selected classification method
        const setupClassifier = () => {
            const dataArray = out.statData().getArray()
            const range = generateRange(out.numberOfClasses_)

            switch (out.classificationMethod_) {
                case 'quantile': {
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])().domain(dataArray).range(range))
                    break
                }
                case 'equal-interval':
                case 'equinter': {
                    out.classifier(
                        (0,d3_scale__WEBPACK_IMPORTED_MODULE_9__["default"])()
                            .domain([(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.min)(dataArray), (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.max)(dataArray)])
                            .range(range)
                    )
                    if (out.makeClassifNice_) out.classifier().nice()
                    break
                }
                case 'threshold': {
                    out.numberOfClasses(out.thresholds_.length + 1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(out.thresholds_).range(generateRange(out.numberOfClasses_)))
                    break
                }
                case 'jenks': {
                    const jenksBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_4__.jenks)(dataArray, out.numberOfClasses_) // Calculate breaks for Jenks
                    const domain = jenksBreaks.slice(1, -1)
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(domain).range(range)) // Use Jenks breaks in scale
                    break
                }
                case 'ckmeans': {
                    // Calculate ckmeans breaks, extracting the maximum value from each cluster
                    const ckmeansBreaks = (0,simple_statistics__WEBPACK_IMPORTED_MODULE_4__.ckmeans)(dataArray, out.numberOfClasses_).map((cluster) => cluster.pop())

                    // Set the domain for scaleThreshold excluding the last value, as it serves as the upper bound
                    const domain = ckmeansBreaks.slice(0, -1)

                    // Use the ckmeans breaks in the scaleThreshold and set the classifier
                    out.classifier((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(domain).range(range))
                    break
                }
            }
        }

        // Apply classifier and set 'ecl' attribute to regions based on value
        const classifyRegions = (regions) => {
            regions.attr('ecl', (rg) => {
                const regionData = out.statData().get(rg.properties.id)
                if (!regionData) return // Lack of data is handled explicitly
                const value = regionData.value
                if (value === ':' || value === null) return 'nd'
                return value != null ? +out.classifier_(value) : undefined
            })
        }

        // Initialize classifier
        setupClassifier()

        // Apply classification and assign 'ecl' attribute based on map type
        if (map.svg_) {
            let selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getRegionsSelector)(map)
            classifyRegions(map.svg().selectAll(selector))

            // Handle mixed NUTS level, separating NUTS level 0
            if (map.nutsLevel_ === 'mixed') {
                const nuts0Regions = map.svg().selectAll('path.em-nutsrg0')
                classifyRegions(nuts0Regions)
            }
        }
    }

    //@override
    out.updateStyle = function () {
        // apply style to insets
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyStyleToMap)
        }

        // apply to main map
        applyStyleToMap(out)

        return out
    }

    function applyStyleToMap(map) {
        // Define function to get a class' color
        if (out.filtersDefinitionFunction_) {
            // Dot density style
            out.classToFillStyle(getFillPatternLegend())
        } else {
            // Color legend style
            out.classToFillStyle(getColorLegend(out.colorFunction(), out.colors_))
        }

        // Apply color and events to regions if SVG exists
        if (map.svg_) {
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getRegionsSelector)(map)
            const regions = map.svg().selectAll(selector)

            // Apply transition and set initial fill colors with data-driven logic
            regions
                .transition()
                .duration(out.transitionDuration())
                .style('fill', regionsFillFunction)
                .end()
                .then(() => {
                    // Store the original color for each region
                    regions.each(function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                    })
                    // Set up mouse events
                    addMouseEventsToRegions(map, regions)

                    // update font color for grid cartograms (contrast)
                    if (out.gridCartogram_) {
                        map.svg()
                            .selectAll('.em-grid-text')
                            .each(function () {
                                const cellColor = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.parentNode).style('fill')
                                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this).attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getTextColorForBackground)(cellColor))
                            })
                    }
                })
                .catch((err) => {
                    //console.error('Error applying transition to regions:', err)
                })

            // Apply additional settings for mixed NUTS level view
            if (out.nutsLevel_ === 'mixed') {
                styleMixedNUTS(map)
            }

            // Update labels for statistical values if required
            if (out.labels_) {
                if (out.labels_.values) out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_5__.applyPatternFill)(map, out.patternFill_)
            }
        }
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_2__.legend
    }

    // when mixing different NUTS levels (e.g. showing NUTS 1 and NUTS 2 data simultaneously)
    const styleMixedNUTS = function (map) {
        map.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getRegionsSelector)(map))
            .each(function () {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                const ecl = sel.attr('ecl')
                const lvl = sel.attr('lvl')

                // Determine display visibility
                const isVisible = ecl || lvl === '0'

                // Apply styles efficiently
                sel.style('display', isVisible ? 'block' : 'none')

                if (ecl && lvl !== '0') {
                    const stroke = sel.style('stroke') || '#777'
                    const strokeWidth = sel.style('stroke-width') || 0.2
                    sel.style('stroke', stroke).style('stroke-width', strokeWidth)
                }
            })
    }

    const regionsFillFunction = function (rg) {
        const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this).attr('ecl') // 'this' refers to the current DOM element
        if (out.Geometries.userGeometries) {
            if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
            if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
            return out.classToFillStyle()(ecl, out.numberOfClasses_)
        } else {
            if (out.geo_ === 'WORLD') {
                // World template logic
                if (!ecl) return out.cntrgFillStyle_
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                const fillStyle = out.classToFillStyle_(ecl, out.numberOfClasses_)
                return fillStyle || out.cntrgFillStyle_
            } else {
                // NUTS template logic
                const countryId = rg.properties.id.slice(0, 2)
                if (!ecl) return (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getCSSPropertyFromClass)('em-nutsrg', 'fill')
                if (ecl === 'nd') return out.noDataFillStyle() || 'gray'
                return out.classToFillStyle()(ecl, out.numberOfClasses_)
            }
        }
    }

    const addMouseEventsToRegions = function (map, regions) {
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                sel.style('fill', map.hoverColor_) // Apply highlight color
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                sel.style('fill', sel.attr('fill___')) // Revert to original color
                if (out._tooltip) out._tooltip.mouseout()
            })
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFunction, colorArray) {
    colorFunction = colorFunction || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_12__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFunction(ecl / (numberOfClasses - 1))
    }
}

/**
 * Build a fill pattern legend object { nd:"white", 0:"url(#pattern_0)", 1:"url(#pattern_1)", ... }
 */
const getFillPatternLegend = function () {
    return function (ecl) {
        return 'url(#pattern_' + ecl + ')'
    }
}

const choroplethTooltipFunction = function (region, map) {
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na || region.properties.name
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    // Retrieve region's data value and unit
    const statData = map.statData()
    const sv = statData.get(regionId)
    const unit = statData.unitText() || ''

    // No data case
    if (!sv || (sv.value !== 0 && !sv.value) || sv.value === ':') {
        buf.push(`
            <div class="estat-vis-tooltip-text no-data">
                <table class="nuts-table">
                    <tbody>
                        <tr><td>${map.noDataText_}</td></tr>
                    </tbody>
                </table>
            </div>
        `)
        return buf.join('')
    }

    // Data display
    buf.push(`
        <div class="estat-vis-tooltip-text">
            <table class="nuts-table">
                <tbody>
                    <tr><td>${(0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.spaceAsThousandSeparator)(sv.value)} ${unit}</td></tr>
                </tbody>
            </table>
        </div>
    `)

    // Optional status flag
    const statusFlag = sv.status
    if (statusFlag && map.tooltip_.showFlags) {
        const flagText = map.tooltip_.showFlags === 'short' ? statusFlag : flags[statusFlag] || statusFlag
        buf.push(` <span class="status-flag">${flagText}</span>`)
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-flow.js":
/*!**********************************!*\
  !*** ./src/maptypes/map-flow.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/link.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../legend/legend-flow */ "./src/legend/legend-flow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
// Import required D3 modules
// import { sankey, sankeyLinkHorizontal } from 'd3-sankey'









/**
 * Returns a flow map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_1__.statMap(config, true, 'flow')
    out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])()
    out.labelOffsetX = 15
    out.labelOffsetY = 5
    out.labelFormatter = (d) => (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.format)('.2s')(d)
    out.tooltip_.textFunction = flowMapTooltipFunction
    out.flowColor_ = '#72bb6f'
    out.flowOverlayColors_ = ['#bbd7ee', '#c7e3c6'] // exporter, importers
    out.flowMaxWidth_ = 30
    out.flowMinWidth_ = 1
    out.flowArrows_ = true
    out.flowOutlines_ = true
    out.flowTargetOffset_ = 1 // Default to normal offset behavior
    out.flowGradient_ = true

    /**
     * flowmap-specific setters/getters
     */
    ;[
        'flowGraph_',
        'flowColor_',
        'flowOverlayColors_',
        'flowArrows_',
        'flowTargetOffset_',
        'flowMaxWidth_',
        'flowMinWidth_',
        'flowOutlines_',
        'flowGradient_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //@override
    out.updateStyle = function () {
        // type: "Feature"
        // properties: Object {id: "ES", na: "Espaa"}
        // geometry: Object {type: "MultiPolygon", coordinates: Array(7)}
        // source: "FR"
        // target: "ES"
        // value: 45422327.56

        // update stroke width function
        const data = out.flowGraph_.links
        out.strokeWidthScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__["default"])()
            .domain([0, (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.max)(data, (d) => d.value)])
            .range([out.flowMinWidth_, out.flowMaxWidth_])

        createFlowMapSVG(out.flowGraph_)
    }

    //@override
    out.updateClassification = function () {}

    //@override
    out.getLegendConstructor = function () {
        //TODO: define legend
        return _legend_legend_flow__WEBPACK_IMPORTED_MODULE_2__.legend
    }
    /**
     * Function to create a map with Sankey diagram and other elements
     * @param {Object} graph - Configuration options and data for the map
     * exampleGraph = {
                nodes: [
                    { id: 'FR', x: 681.1851800759263, y: 230.31124763648583 },
                    { id: 'DE', x: 824.5437782154489, y: 123.70302649032199 },
                ],
                links: [
                    { source: 'FR', target: 'DE', value: 82018369.72 },
                ],
            }
     */
    function createFlowMapSVG(graph) {
        const svg = out.svg_

        // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
        addCoordinatesToGraph(graph)

        var { nodes, links } = sankey(graph)

        // Define marker and gradient IDs
        const defs = svg.append('defs')
        const arrowId = generateUniqueId('arrow')
        const arrowOutlineId = generateUniqueId('arrow-outline')
        const gradientIds = links.map(() => generateUniqueId('gradient'))

        // Add arrow markers
        if (out.flowArrows_) {
            addArrowMarker(defs, arrowId, out.flowColor_)
            addArrowMarker(defs, arrowOutlineId, '#ffffff')
        }

        // Add flow gradients
        if (out.flowGradient_) {
            addFlowGradients(defs, gradientIds, links)
        }

        // Define our container SVG
        const zoomGroup = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])('#em-zoom-group-' + out.svgId_)
        const sankeyContainer = zoomGroup.append('g').attr('class', 'em-flow-container')

        // Add geographical layers
        addOverlayPolygons(sankeyContainer, graph)

        // Add Sankey flows
        addSankeyFlows(sankeyContainer, links, arrowId, arrowOutlineId, gradientIds)

        // Add additional nodes (fill gaps)
        addFillGaps(sankeyContainer, nodes)

        // Add labels to nodes
        if (out.labels_) addLabels(sankeyContainer, nodes)

        return svg.node()
    }

    /**
     * Adds geographical layers (regions, POI overlay, borders)
     * @param {Object} svg - D3 selection of SVG container
     */
    function addOverlayPolygons(svg, graph) {
        const importerIds = []
        const exporterIds = []
        const features = out.Geometries.getRegionFeatures()
        if (features) {
            graph.nodes.forEach((node) => {
                const overlay = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (overlay) {
                    let isImporter = graph.links.some((link) => link.source == node.id)
                    if (isImporter) {
                        importerIds.push(node.id)
                    } else {
                        exporterIds.push(node.id)
                    }
                } else {
                    console.error('could not find geometry for', node.id)
                }
            })

            //update existing region fills
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getRegionsSelector)(out)
            const allRegions = out.svg_.selectAll(selector)

            allRegions.each(function () {
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).style('fill', (region) => {
                    if (importerIds.includes(region.properties.id)) return out.flowOverlayColors_[0]
                    if (exporterIds.includes(region.properties.id)) return out.flowOverlayColors_[1]
                })
            })
        }
    }

    // if nodes in the graph dont have coordinates specified by the user then use nuts2json centroids instead
    function addCoordinatesToGraph(graph) {
        graph.nodes.forEach((node) => {
            if (!node.x && !node.y && out.Geometries.centroidFeatures) {
                const centroid = out.Geometries.centroidFeatures.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })

                if (centroid) {
                    const screenCoords = out._projection([centroid.geometry.coordinates[0], centroid.geometry.coordinates[1]])
                    node.x = screenCoords[0]
                    node.y = screenCoords[1]
                } else {
                    console.error('could not find coordinates for', node.id)
                }
            } else {
                // no centroids data, calculate on the fly
                const features = out.Geometries.getRegionFeatures()
                const feature = features.find((feature) => {
                    if (node.id == feature.properties.id) return feature
                })
                const centroid = feature.properties.centroid || out._pathFunction.centroid(feature)
                const screenCoords = out._projection([centroid[0], centroid[1]])
                node.x = screenCoords[0]
                node.y = screenCoords[1]
            }
        })
        console.log(graph)
    }

    /**
     * Generates a unique DOM ID
     * @param {string} prefix - Prefix for the ID
     * @returns {string} Unique ID
     */
    function generateUniqueId(prefix) {
        return `${prefix}-${Math.random().toString(36).substr(2, 9)}`
    }

    /**
     * Adds an arrow marker to the defs section
     * @param {Object} defs - D3 selection of defs
     * @param {string} id - Marker ID
     * @param {string} color - Fill color of the marker
     */
    function addArrowMarker(defs, id, color) {
        defs.append('marker')
            .attr('id', id)
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', color)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')

        // add a copy for mouseover with hovered color
        defs.append('marker')
            .attr('id', id + 'mouseover')
            .attr('markerHeight', 7)
            .attr('markerWidth', 7)
            .attr('refX', 1)
            .attr('refY', 1.5)
            .attr('orient', 'auto')
            .append('path')
            .attr('fill', out.hoverColor_)
            .attr('d', 'M0,0 q0,1,0.5,1.5 q-0.5,0.5,-0.5,1.5 q0.75,-0.75,2,-1.5 q-1.25,-0.75,-2,-1.5Z')
    }

    /**
     * Adds linear gradient definitions for flow links
     * @param {Object} defs - D3 selection of defs
     * @param {Array} gradientIds - Array of gradient IDs
     * @param {Array} links - Sankey links data
     */
    function addFlowGradients(defs, gradientIds, links) {
        defs.selectAll('linearGradient')
            .data(links)
            .join('linearGradient')
            .attr('id', (_, i) => gradientIds[i])
            .attr('gradientUnits', 'userSpaceOnUse')
            .attr('x1', (d) => d.source.x1)
            .attr('x2', (d) => d.target.x0)
            .attr('y1', (d) => d.y0)
            .attr('y2', (d) => d.y1)
            .call((g) => g.append('stop').attr('offset', '5%').attr('stop-color', out.flowOverlayColors_[0]))
            .call((g) => g.append('stop').attr('offset', '50%').attr('stop-color', out.flowColor_))
    }

    /**
     * Adds Sankey flows (links with markers and gradients)
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} links - Sankey links data
     * @param {string} arrowId - Arrow marker ID
     * @param {string} arrowOutlineId - Arrow outline marker ID
     * @param {Array} gradientIds - Gradient IDs
     */
    function addSankeyFlows(svg, links, arrowId, arrowOutlineId, gradientIds) {
        const flowsGroup = svg.append('g').attr('class', 'em-flows-group')
        const flows = flowsGroup.append('g').attr('class', 'em-flow-flows')
        const outlines = flowsGroup.append('g').attr('class', 'em-flow-outlines')

        links.forEach((link, i) => {
            // Outline path
            if (out.flowOutlines_) {
                outlines
                    .append('path')
                    .attr('d', sankeyLinkHorizontal()(link))
                    .attr('fill', 'none')
                    .attr('stroke', '#ffffff')
                    .attr('class', 'em-flow-link-outline')
                    // .attr('stroke-width', link.width + 1.5)
                    .attr('marker-end', `url(#${arrowOutlineId})`)
            }

            // Main path
            flows
                .append('path')
                .attr('d', sankeyLinkHorizontal()(link))
                .attr('fill', 'none')
                .attr('class', 'em-flow-link')
                .attr('stroke', out.flowGradient_ ? `url(#${gradientIds[i]})` : out.flowColor_)
                .attr('stroke-width', link.width)
                .attr('marker-end', out.flowArrows_ ? `url(#${arrowId})` : '')
                // add hover effect
                .on('mouseover', function (e) {
                    const hoveredColor = out.hoverColor_

                    // Change the stroke color
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', hoveredColor)

                    // Update the marker-end dynamically
                    if (out.flowArrows_) (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId + 'mouseover'})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(link, out))
                })
                .on('mousemove', function (e) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    // Revert the stroke color
                    if (out.flowGradient_) {
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', `url(#${gradientIds[i]})`)
                    } else {
                        (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('stroke', out.flowColor_)
                    }

                    // Revert the marker-end to the original
                    if (out.flowArrows_) (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).attr('marker-end', `url(#${arrowId})`)

                    // Tooltip handling
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    /**
     * Adds rectangles to fill gaps left by Sankey links
     * @param {Object} svg - D3 selection of SVG
     * @param {Array} nodes - Sankey nodes data
     */
    function addFillGaps(svg, nodes) {
        svg.append('g')
            .attr('class', 'em-flow-fill-in-gaps')
            .selectAll('rect')
            .data(nodes)
            .join('rect')
            .filter((d) => d.depth && d.height)
            .attr('x', (d) => d.x0 - 0.5)
            .attr('y', (d) => d.y0)
            .attr('width', 1)
            .attr('height', (d) => d.y1 - d.y0)
            .attr('fill', out.flowColor_)
    }

    /**
     * Add labels for data points.
     * @param {Object} svg - D3 selection of the SVG element.
     */
    function addLabels(svg, nodes) {
        // Filter the nodes
        const filteredNodes = nodes.filter((node) => node.targetLinks && node.sourceLinks.length === 0)
        const container = svg.append('g').attr('class', 'em-flow-labels')

        // Add halo effect
        if (out.labels_?.shadows) {
            const labelsShadowGroup = container.append('g').attr('class', 'em-flow-label-shadow')
            labelsShadowGroup
                .selectAll('text')
                .data(filteredNodes)
                .join('text')
                .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
                .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? d.x + out.labelOffsetX : d.x - out.labelOffsetX))
                .attr('y', (d) => d.y + out.labelOffsetY)
                .text((d) => out.labelFormatter(d.value))
        }

        // Add labels
        const labelsGroup = container.append('g').attr('class', 'em-flow-label')
        //add background
        // Add background rectangles and text
        const labelElements = labelsGroup
            .selectAll('g') // Use a group for each label to combine rect and text
            .data(filteredNodes)
            .join('g') // Append a group for each label
            .attr('transform', (d) => `translate(${d.x}, ${d.y})`) // Position group at the node

        // Add text first to calculate its size
        labelElements
            .append('text')
            .attr('class', 'em-label-text')
            .attr('text-anchor', (d) => (d.x > d.targetLinks[0].source.x ? 'start' : 'end'))
            .attr('x', (d) => (d.x > d.targetLinks[0].source.x ? out.labelOffsetX : -out.labelOffsetX))
            .attr('y', out.labelOffsetY)
            .text((d) => out.labelFormatter(d.value))

        // Add background rectangles after text is rendered

        if (out.labels_.backgrounds) {
            labelElements.each(function () {
                const textElement = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this).select('text')
                const bbox = textElement.node().getBBox() // Get bounding box of the text

                const paddingX = 5 // Horizontal padding
                const paddingY = 2 // Vertical padding

                // Add rectangle centered behind the text
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                    .insert('rect', 'text') // Insert rect before text in DOM
                    .attr('class', 'em-label-background')
                    .attr('x', bbox.x - paddingX)
                    .attr('y', bbox.y - paddingY)
                    .attr('width', bbox.width + 2 * paddingX)
                    .attr('height', bbox.height + 2 * paddingY)
            })
        }
    }

    // Function to append a rectangle behind the label
    function appendLabelRect(labelText, container) {
        const paddingX = 5 // Add some padding around the text
        const paddingY = 2 // Add some padding around the text

        // Create a temporary text element to get the size
        const bbox = container
            .append('text')
            .attr('visibility', 'hidden') // Make the temporary text invisible
            .text(labelText) // Set the label text to get its bounding box
            .node()
            .getBBox() // Get the bounding box of the text

        const labelWidth = bbox.width
        const labelHeight = bbox.height

        // Remove the temporary text element after getting the bounding box
        container.select('text[visibility="hidden"]').remove()

        // Calculate the position of the rectangle to be centered on the text
        const x = -labelWidth / 2 - paddingX // Center the rect horizontally
        const y = -labelHeight / 2 - paddingY // Center the rect vertically

        // Append rectangle with padding
        container
            .append('rect')
            .attr('x', x) // Position rect horizontally
            .attr('y', y) // Position rect vertically
            .attr('width', labelWidth + 2 * paddingX) // Width of the rect with padding
            .attr('height', labelHeight + 2 * paddingY) // Height of the rect with padding
            .attr('class', 'em-label-background')
    }

    // From this point on all code is related with spatial sankey. Adopted from this notebook: https://observablehq.com/@bayre/deconstructed-sankey-diagram
    // See https://observablehq.com/@joewdavies/flow-map-of-europe
    function clone({ nodes, links }) {
        return { nodes: nodes.map((d) => Object.assign({}, d)), links: links.map((d) => Object.assign({}, d)) }
    }

    function sankey({ nodes, links }) {
        const graph = clone({ nodes, links })
        computeNodeLinks(graph)
        computeNodeValues(graph)
        computeNodeDepths(graph)
        computeNodeHeights(graph)
        computeNodeBreadths(graph)
        computeLinkBreadths(graph)
        return graph
    }

    function computeNodeLinks({ nodes, links }) {
        for (const [i, node] of nodes.entries()) {
            node.index = i
            node.sourceLinks = []
            node.targetLinks = []
        }
        const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]))
        for (const [i, link] of links.entries()) {
            link.index = i
            let { source, target } = link
            if (typeof source !== 'object') source = link.source = find(nodeById, source)
            if (typeof target !== 'object') target = link.target = find(nodeById, target)
            source.sourceLinks.push(link)
            target.targetLinks.push(link)
        }
        // if (linkSort != null) {
        //     for (const { sourceLinks, targetLinks } of nodes) {
        //         sourceLinks.sort(linkSort)
        //         targetLinks.sort(linkSort)
        //     }
        // }
    }

    function find(nodeById, id) {
        const node = nodeById.get(id)
        if (!node) throw new Error('missing: ' + id)
        return node
    }

    function computeNodeDepths({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.depth = x
                for (const { target } of node.sourceLinks) {
                    next.add(target)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    function computeNodeHeights({ nodes }) {
        const n = nodes.length
        let current = new Set(nodes)
        let next = new Set()
        let x = 0
        while (current.size) {
            for (const node of current) {
                node.height = x
                for (const { source } of node.targetLinks) {
                    next.add(source)
                }
            }
            if (++x > n) throw new Error('circular link')
            current = next
            next = new Set()
        }
    }

    function computeNodeBreadths({ nodes }) {
        for (const node of nodes) {
            // Compute link widths
            node.sourceLinks.forEach((link) => (link.width = out.strokeWidthScale(link.value)))
            node.targetLinks.forEach((link) => (link.width = out.strokeWidthScale(link.value)))

            // Use total space needed by links
            const totalLinkWidth = Math.max(
                (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.sum)(node.sourceLinks, (d) => d.width),
                (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.sum)(node.targetLinks, (d) => d.width)
            )

            node.x0 = node.x1 = node.x
            node.y0 = node.y - totalLinkWidth / 2
            node.y1 = node.y + totalLinkWidth / 2
        }

        reorderLinks(nodes)
    }

    function computeLinkBreadths({ nodes }) {
        for (const node of nodes) {
            let y0 = node.y0
            for (const link of node.sourceLinks) {
                link.y0 = y0 + link.width / 2
                y0 += link.width
            }

            let y1 = node.y0
            for (const link of node.targetLinks) {
                link.y1 = y1 + link.width / 2
                y1 += link.width
            }
        }
    }

    // Group nodes by depth and stack vertically
    function stackNodeYs(nodes) {
        const byDepth = new Map()
        for (const node of nodes) {
            if (!byDepth.has(node.depth)) byDepth.set(node.depth, [])
            byDepth.get(node.depth).push(node)
        }

        for (const [depth, group] of byDepth.entries()) {
            // Sort by value or id to ensure consistency
            group.sort((a, b) => b.value - a.value)

            let y = 100 // starting y position
            const padding = 5
            for (const node of group) {
                const nodeHeight = Math.max(
                    (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.sum)(node.sourceLinks, (d) => d.width),
                    (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.sum)(node.targetLinks, (d) => d.width)
                )
                node.y = y + nodeHeight / 2
                y += nodeHeight + padding
            }
        }
    }

    function horizontalSource(d) {
        return [d.source.x1, d.y0]
    }

    function horizontalTarget(d) {
        return [d.target.x0, d.y1]
    }

    function computeNodeValues({ nodes }) {
        for (const node of nodes) {
            node.value = Math.max(
                (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.sum)(node.sourceLinks, (d) => d.value),
                (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.sum)(node.targetLinks, (d) => d.value)
            )
        }
    }

    function reorderLinks(nodes) {
        for (const { sourceLinks, targetLinks } of nodes) {
            sourceLinks.sort(ascendingTargetY)
            targetLinks.sort(ascendingSourceY)
        }
    }

    const ascendingTargetY = (a, b) => a.target.y - b.target.y
    const ascendingSourceY = (a, b) => a.source.y - b.source.y

    const id = (d) => d.id // used in sankey import

    const sankeyLinkHorizontal = function () {
        return (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__.linkHorizontal)().source(horizontalSource).target(horizontalTarget)
    }

    return out
}

const flowMapTooltipFunction = function (link, map) {
    const buf = []

    // Header with region name and ID
    const title = `${link.source.name || link.source.id} to ${link.target.name || link.target.id}`
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${title}</b>
        </div>
    `)

    // Value
    buf.push(`<div class='estat-vis-tooltip-text'>
        ${link.value}
        </div>`)

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-piecharts.js":
/*!***************************************!*\
  !*** ./src/maptypes/map-piecharts.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../legend/legend-piecharts */ "./src/legend/legend-piecharts.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");









/**
 * Returns a proportional pie chart map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_1__.statMap(config, true, 'pie')

    // pie charts
    out.pieMinRadius_ = 5
    out.pieMaxRadius_ = 15
    out.pieChartInnerRadius_ = 0
    out.pieStrokeFill_ = 'white'
    out.pieStrokeWidth_ = 0.3

    //tooltip pie chart
    out.tooltipPieRadius_ = 40
    out.tooltipPieInnerRadius_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    // 'other' section of the pie chart for when 'out.totalCode_' is defined with statPie()
    out.pieOtherColor_ = '#FFCC80'
    out.pieOtherText_ = 'Other'

    //show piecharts only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    out.sizeClassifier_ = null //d3 scale for scaling pie sizes
    out.statPie_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieMaxRadius_',
        'pieMinRadius_',
        'pieChartInnerRadius_',
        'pieOtherColor_',
        'pieOtherText_',
        'pieStrokeFill_',
        'pieStrokeWidth_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieMaxRadius',
            'pieMinRadius',
            'pieChartInnerRadius',
            'pieOtherColor',
            'pieOtherText',
            'pieStrokeFill',
            'pieStrokeWidth',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /** The codes of the categories to consider for the composition. */
    out.statCodes_ = undefined
    /** The code of the "total" category in the eurostat database */
    out.totalCode__ = undefined

    /**
     * A function to define a pie chart map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension (defined in eurostat REST API) of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     * @param {string} tCode Optional: The category code of the total (used to calculate total & "other" values if codes array dont represent all possible categories)
     */
    out.statPie = function (stat, dim, codes, labels, colors, tCode) {
        //add one dataset (stat) config for each category (code)
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) {
                sc_[key] = stat[key]
            }
            sc_.filters = {}
            for (let key in stat.filters) {
                sc_.filters[key] = stat.filters[key]
            }
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set out.statCodes_
        out.statCodes_ = codes

        //set out.totalCode_
        if (tCode) {
            out.totalCode_ = tCode
            stat.filters[dim] = tCode
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(tCode, sc_)

            //when total code is used, an 'other' section is added to the pie
            out.catColors_['other'] = out.pieOtherColor_
            out.catLabels_['other'] = out.pieOtherText_
        }

        return out
    }

    //@override
    out.updateClassification = function () {
        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    const applyClassificationToMap = function (map) {
        //if not provided, get list of stat codes from the map stat data
        if (!out.statCodes_) {
            //get list of stat codes.
            out.statCodes_ = Object.keys(out.statData_)
            //remove "default", if present
            const index = out.statCodes_.indexOf('default')
            if (index > -1) out.statCodes_.splice(index, 1)
        }

        //define size scaling function
        let domain = getDatasetMaxMin()
        if (!isNaN(domain[0])) {
            out.sizeClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__.sqrt)().domain(domain).range([out.pieMinRadius_, out.pieMaxRadius_])
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors_) {
            out.catColors({})
            for (let i = 0; i < out.statCodes_.length; i++) out.catColors_[out.statCodes_[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of sharing regions with pies
        let regionFeatures = []
        if (out.svg_) {
            let s = out.svg_.selectAll('#em-prop-symbols')
            if (s) {
                let sym = s.selectAll('g.em-centroid')
                sym.append('g')
                    .attr('class', 'em-pie')
                    .attr('id', (rg) => {
                        regionFeatures.push(rg)
                        return 'pie_' + rg.properties.id
                    })

                // set region hover function
                const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getRegionsSelector)(out)
                let regions = out.svg().selectAll(selector)
                regions
                    .on('mouseover', function (e, rg) {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                        sel.attr('fill___', sel.style('fill'))
                        sel.style('fill', out.hoverColor_)
                        if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                    })
                    .on('mousemove', function (e, rg) {
                        if (out._tooltip) out._tooltip.mousemove(e)
                    })
                    .on('mouseout', function () {
                        const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                        let newFill = sel.attr('fill___')
                        if (newFill) {
                            sel.style('fill', sel.attr('fill___'))
                            if (out._tooltip) out._tooltip.mouseout()
                        }
                    })

                addPieChartsToMap(regionFeatures)
            }
        }
        return out
    }

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < out.statCodes_.length; i++) {
            //retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        // when out.totalCode_ is specified, use it as the sum instead of the sum of the specified categories.
        if (out.totalCode_) {
            let s = out.statData(out.totalCode_).get(id)
            if (s) {
                sum = s.value
            } else {
                sum == 0
            }
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < out.statCodes_.length; i++) {
            comp[out.statCodes_[i]] /= sum
        }

        //add "other" category when out.totalCode_ is used
        if (out.totalCode_) {
            let totalPerc = 0
            for (let key in comp) {
                totalPerc = totalPerc + comp[key]
            }
            comp['other'] = 1 - totalPerc
        }

        return comp
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum total of all dimensions combined for each region. Used to define the domain of the pie size scaling function.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        let totals = []
        let sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            let id = rg.properties.id
            let total = getRegionTotal(id)
            if (total) {
                totals.push(total)
            }
        })

        let minmax = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.extent)(totals)
        return minmax
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionTotal = function (id) {
        let sum = 0
        let s
        if (out.totalCode_) {
            //when total is a stat code
            s = out.statData(out.totalCode_).get(id)
            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) {
                    sum = undefined
                }
            } else {
                sum = s.value
            }
        } else {
            //get stat value for each category. Compute the sum.
            for (let i = 0; i < out.statCodes_.length; i++) {
                //retrieve code and stat value
                const sc = out.statCodes_[i]
                s = out.statData(sc).get(id)
                //case when some data is missing
                if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                    if (out.showOnlyWhenComplete()) return undefined
                    else continue
                }
                sum += s.value
            }
        }

        //case when no data
        if (sum == 0) return undefined
        return sum
    }

    function addPieChartsToMap(regionFeatures) {
        regionFeatures.forEach((region) => {
            const regionId = region.properties.id
            //prepare data for pie chart
            const data = []
            const comp = getComposition(regionId)
            for (const key in comp) data.push({ code: key, value: comp[key] })

            //case of regions with no data
            if (!data || data.length == 0) {
                return
            }

            //create svg for pie chart
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let nodes = out.svg().selectAll('#pie_' + regionId)

            // define radius
            const r = out.sizeClassifier_(getRegionTotal(regionId))
            const ir = out.pieChartInnerRadius_

            //make pie chart. See https://observablehq.com/@d3/pie-chart
            const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
                .sort(null)
                .value((d) => d.value)
            nodes
                .append('g')
                .attr('stroke', out.pieStrokeFill_)
                .attr('stroke-width', out.pieStrokeWidth_ + 'px')
                .attr('class', 'piechart')
                .selectAll('path')
                .data(pie_(data))
                .join('path')
                .style('fill', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('fill___', (d) => {
                    return out.catColors_[d.data.code] || 'lightgray'
                })
                .attr('code', (d) => d.data.code) //for mouseover legend highlighting function
                .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])().innerRadius(ir).outerRadius(r))
                .on('mouseover', function (e, rg) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                    // Apply a thick stroke width to the parent element
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', '1px').style('stroke', 'black') // Set stroke
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(region, out))
                })
                .on('mousemove', function (e, rg) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                })
                .on('mouseout', function () {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                    // Reset stroke
                    const parent = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(sel.node().parentNode)
                    parent.style('stroke-width', out.pieStrokeWidth_).style('stroke', out.pieStrokeFill_) // Set stroke
                    if (out._tooltip) out._tooltip.mouseout()
                })
        })
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_piecharts__WEBPACK_IMPORTED_MODULE_2__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        if (rg.properties.id) {
            //name and code
            tp.append('div')
                .attr('class', 'estat-vis-tooltip-bar')
                .html(rg.properties.na + ' (' + rg.properties.id + ')')
        } else {
            //region name
            tp.append('div').attr('class', 'estat-vis-tooltip-bar').html(rg.properties.na)
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        // set the dimensions and margins of the graph
        let width = 150
        let height = 150
        let margin = 25

        // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
        const radius = Math.min(width, height) / 2 - margin

        //width = tp.node().getBoundingClientRect().width
        const container = tp.append('div').attr('class', 'em-tooltip-piechart-container')
        const svg = container
            .append('svg')
            .attr('class', 'em-tooltip-piechart-svg')
            .attr('viewbox', `0, 0, ${width}, ${height}`)
            .attr('width', width)
            .attr('height', height - margin / 2)
            .append('g')
            .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"])()
            .sort(null)
            .value((d) => d.value)

        const innerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(0) // This is the size of the donut hole
            .outerRadius(radius * 0.8)

        // Another arc that won't be drawn. Just for labels positioning
        const outerArc = (0,d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"])()
            .innerRadius(radius * 0.9)
            .outerRadius(radius * 0.9)

        const pieData = pie_(data)
        svg.selectAll('allSlices')
            .data(pieData)
            .enter()
            .append('path')
            .attr('d', innerArc)
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('stroke', 'white')
            .style('stroke-width', '1px')
            .style('opacity', 0.7)

        // Add the polylines between chart and labels:
        svg.selectAll('allPolylines')
            .data(pieData)
            .enter()
            .append('polyline')
            .attr('stroke', 'black')
            .style('fill', 'none')
            .attr('stroke-width', 1)
            .attr('points', function (d) {
                if (d.data.value > 0.02) {
                    const posA = innerArc.centroid(d) // line insertion in the slice
                    const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                    const posC = outerArc.centroid(d) // Label position = almost the same as posB
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                    posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1) // multiply by 1 or -1 to put it on the right or on the left
                    return [posA, posB, posC]
                }
            })

        // Add the labels:
        svg.selectAll('allLabels')
            .data(pieData)
            .enter()
            .append('text')
            .text(function (d) {
                if (d.data.value > 0.02) {
                    let n = (d.data.value * 100).toFixed()
                    if (!isNaN(n)) return n + '%'
                }
            })
            .attr('transform', function (d) {
                var pos = outerArc.centroid(d)
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1)
                return 'translate(' + pos + ')'
            })
            .style('text-anchor', function (d) {
                var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                return midangle < Math.PI ? 'start' : 'end'
            })
            .style('font-size', '12px')

        // add region values to tooltip
        let breakdownDiv = tp.append('div').attr('class', 'em-tooltip-piechart-breakdown')

        // show value for each category
        for (let i = 0; i < out.statCodes_.length; i++) {
            // retrieve code and stat value
            const sc = out.statCodes_[i]
            const s = out.statData(sc).get(rg.properties.id)

            // check if s and s.value are valid (handle null, undefined, or 0)
            if (s && s.value !== undefined && s.value !== null) {
                let string = `<strong>${out.catLabels_[sc]}</strong>: ${s.value.toFixed()}<br>`
                breakdownDiv.html(breakdownDiv.html() + string) // safely update the HTML
            }
        }

        // write total (handle null, undefined, or 0 values for total)
        let total = getRegionTotal(rg.properties.id)
        if (total !== undefined && total !== null) {
            breakdownDiv.html(breakdownDiv.html() + `<strong>Total</strong>: ${total.toFixed()}<br>`)
        }
    }

    return out
}


/***/ }),

/***/ "./src/maptypes/map-proportional-symbols.js":
/*!**************************************************!*\
  !*** ./src/maptypes/map-proportional-symbols.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   symbolsLibrary: () => (/* binding */ symbolsLibrary)
/* harmony export */ });
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../legend/legend-proportional-symbols */ "./src/legend/legend-proportional-symbols.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_pattern_fill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/pattern-fill */ "./src/core/pattern-fill.js");











/**
 * Returns a proportional symbol map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_1__.statMap(config, true, 'ps')

    //shape
    out.psShape_ = 'circle' // accepted values: circle, bar, square, star, diamond, wye, cross
    out.psCustomShape_ // see http://using-d3js.com/05_10_symbols.html#h_66iIQ5sJIT
    out.psCustomSVG_ // see http://bl.ocks.org/jessihamel/9648495
    out.psSpikeWidth_ = 7 // 'spike' shape widths
    out.psOffset_ = { x: 0, y: 0 }

    //size
    out.psMaxSize_ = 30 // max symbol size
    out.psMinSize_ = 5 // min symbol size
    out.psBarWidth_ = 10 //for vertical bars
    out.psMaxValue_ = undefined // allow the user to manually define the domain of the sizing scale. E.g. if the user wants to use the same scale across different maps.
    out.psMinValue_ = undefined
    out.psSizeScale_ = undefined // 'sqrt' or 'linear'

    //colour
    out.psFill_ = '#2d50a0' //same fill for all symbols when no visual variable (setData()) for 'color' is specified
    out.psFillOpacity_ = 1
    out.psStroke_ = '#ffffff'
    out.psStrokeWidth_ = 0.2
    out.psClasses_ = 5 // number of classes to use for colouring
    out.psColors_ = null //colours to use for threshold colouring
    out.psColorFun_ = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__["default"]
    out.psClassToFillStyle_ = undefined //a function returning the color from the class i

    //the threshold, when the classification method is 'threshold'
    out.psThresholds_ = [0]
    //the classification method
    out.psClassificationMethod_ = 'quantile' // or: equinter, threshold
    //when computed automatically, ensure the threshold are nice rounded values
    out.makeClassifNice_ = true
    //
    //the classifier: a function which return the symbol size/color from the stat value.
    out.classifierSize_ = undefined
    out.classifierColor_ = undefined
    //specific tooltip text function
    out.tooltip_.textFunction = tooltipTextFunPs

    //dorling cartogram
    out.dorling_ = false
    out.dorlingStrength_ = { x: 1, y: 1 }
    out.dorlingIterations_ = 1
    out.psCodeLabels_ = false // show country codes in symbols

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'psMaxSize_',
        'psMinSize_',
        'psMaxValue_',
        'psMinValue_',
        'psFill_',
        'psFillOpacity_',
        'psStroke_',
        'psStrokeWidth_',
        'classifierSize_',
        'classifierColor_',
        'psShape_',
        'psCustomShape_',
        'psBarWidth_',
        'psClassToFillStyle_',
        'psColorFun_',
        'psSizeScale_',
        'noDataFillStyle_',
        'psThresholds_',
        'psColors_',
        'psCustomSVG_',
        'psOffset_',
        'psClassificationMethod_',
        'psClasses_',
        'dorling_',
        'dorlingStrength_',
        'psSpikeWidth_',
        'psCodeLabels_',
        'dorlingIterations_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'psMaxSize',
            'psMinSize',
            'psFill',
            'psFillOpacity',
            'psStroke',
            'psStrokeWidth',
            'classifierSize',
            'classifierColor',
            'psShape',
            'psCustomShape',
            'psBarWidth',
            'psClassToFillStyle',
            'psColorFun',
            'noDataFillStyle',
            'psThreshold',
            'psColors',
            'psCustomSVG',
            'psOffset',
            'psClassificationMethod',
            'psClasses',
            'dorlingIterations_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    //override of some special getters/setters
    out.psColorFun = function (v) {
        if (!arguments.length) return out.psColorFun_
        out.psColorFun_ = v
        out.psClassToFillStyle_ = getColorLegend(out.psColorFun_, out.psColors_)
        return out
    }
    out.psThresholds = function (v) {
        if (!arguments.length) return out.psThresholds_
        out.psThresholds_ = v
        out.psClasses(v.length + 1)
        return out
    }

    //@override
    out.updateClassification = function () {
        //define classifiers for sizing and colouring (out.classifierSize_ & out.classifierColor_)
        defineClassifiers()

        // apply classification to all insets that are outside of the main map's SVG
        if (out.insetTemplates_) {
            (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.executeForAllInsets)(out.insetTemplates_, out.svgId_, applyClassificationToMap)
        }

        // apply to main map
        applyClassificationToMap(out)

        return out
    }

    /**
     * @description assigns a color to each symbol, based on their statistical value
     * @param {*} map
     */
    function applyClassificationToMap(map) {
        if (map.svg_) {
            if (out.classifierColor_) {
                //assign color class to each symbol, based on their value
                // at this point, the symbol path hasnt been appended. Only the parent g element (.em-centroid)
                const colorData = map.statData('color')
                map.svg_.selectAll('.em-centroid').attr('ecl', function (rg) {
                    const sv = colorData.get(rg.properties.id)
                    if (!sv) {
                        return 'nd'
                    }
                    const v = sv.value
                    if ((v !== 0 && !v) || v == ':') {
                        return 'nd'
                    }
                    let c = +out.classifierColor_(+v)
                    return c
                })
            }
        }
    }

    /**
     * @description defines classifier functions (out.classifierColor and out.classifierSize) for both symbol size and color
     */
    function defineClassifiers() {
        // set default scale
        if (!out.psSizeScale_) {
            if (out.psShape_ == 'spike') {
                out.psSizeScale_ = 'linear'
            } else {
                out.psSizeScale_ = 'sqrt'
            }
        }

        //simply return the array [0,1,2,3,...,nb-1]
        const getA = function (nb) {
            return [...Array(nb).keys()]
        }

        // use size dataset
        let rawData = out.statData('size').getArray() || out.statData().getArray()
        let data = rawData.filter((d) => typeof d === 'number' && !isNaN(d) && isFinite(d))
        let [minVal, maxVal] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.extent)(data)
        let min = out.psMinValue_ ?? minVal
        let max = out.psMaxValue_ ?? maxVal
        let sizeDomain = data ? [min, max] : [out.statData().getMin(), out.statData().getMax()]

        let scale = out.psSizeScale_ == 'sqrt' ? d3_scale__WEBPACK_IMPORTED_MODULE_6__.sqrt : d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"]
        out.classifierSize(scale().domain(sizeDomain).range([out.psMinSize_, out.psMaxSize_]))

        // colour
        if (out.statData('color').getArray()) {
            //use suitable classification type for colouring
            if (out.psClassificationMethod_ === 'quantile') {
                //https://github.com/d3/d3-scale#quantile-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"])().domain(domain).range(range))
            } else if (out.psClassificationMethod_ === 'equinter') {
                //https://github.com/d3/d3-scale#quantize-scales
                const domain = out.statData('color').getArray()
                const range = getA(out.psClasses_)
                out.classifierColor(
                    (0,d3_scale__WEBPACK_IMPORTED_MODULE_9__["default"])()
                        .domain([min(domain), max(domain)])
                        .range(range)
                )
                if (out.makeClassifNice_) out.classifierColor().nice()
            } else if (out.psClassificationMethod_ === 'threshold') {
                //https://github.com/d3/d3-scale#threshold-scales
                out.psClasses(out.psThresholds().length + 1)
                const range = getA(out.psClasses_)
                out.classifierColor((0,d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"])().domain(out.psThresholds()).range(range))
            }
        }
    }

    /**
     * Applies proportional symbol styling to a map object
     *
     * @param {*} map
     * @returns
     */
    function applyStyleToMap(map) {
        //see https://bl.ocks.org/mbostock/4342045 and https://bost.ocks.org/mike/bubble-map/
        //define style per class
        if (!out.psClassToFillStyle()) out.psClassToFillStyle(getColorLegend(out.psColorFun_, out.psColors_))

        // if size dataset not defined then use default
        let sizeData = map.statData('size').getArray() ? map.statData('size') : map.statData()

        if (map.svg_) {
            //clear previous centroids
            let prevSymbols = map.svg_.selectAll(':not(#em-insets-group) g.em-centroid > *')
            prevSymbols.remove()

            // 'small' centroids on top of big ones
            updateSymbolsDrawOrder(map)

            // append symbols to centroids
            let symb
            if (out.psCustomSVG_) {
                symb = appendCustomSymbolsToMap(map, sizeData)
            } else if (out.psShape_ == 'bar') {
                symb = appendBarsToMap(map, sizeData)
            } else if (out.psShape_ == 'circle') {
                symb = appendCirclesToMap(map, sizeData)
            } else if (out.psShape_ == 'spike') {
                symb = appendSpikesToMap(map, sizeData)
            } else {
                // circle, cross, star, triangle, diamond, square, wye or custom
                symb = appendD3SymbolsToMap(map, sizeData)
            }

            // dorling cartogram
            if (out.dorling_) {
                applyDorlingForce(map, sizeData)
            } else {
                if (out.simulation) stopSimulation()
            }

            appendLabelsToSymbols(map, sizeData)

            // set style of symbols
            const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getRegionsSelector)(map)
            let regions = map.svg().selectAll(selector)

            if (map.geo_ !== 'WORLD') {
                if (map.nutsLevel_ == 'mixed') {
                    addSymbolsToMixedNUTS(map, sizeData, regions)
                }

                // apply 'nd' class to no data regions for legend item hover
                regions.attr('ecl', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                        // NO INPUT
                        return 'ni'
                    } else if (sv && sv.value) {
                        if (sv.value == ':') {
                            // DATA NOT AVAILABLE (no data)
                            return 'nd'
                        }
                    }
                })
            }

            setSymbolStyles(symb)

            addMouseEvents(map)

            // Update labels for statistical values if required
            if (out.labels_?.values) {
                out.updateValuesLabels(map)
            }

            //add hatching if needed
            if (out.patternFill_) {
                (0,_core_pattern_fill__WEBPACK_IMPORTED_MODULE_4__.applyPatternFill)(map, out.patternFill_)
            }
        }
        return map
    }

    const appendLabelsToSymbols = function (map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')
        //country code labels
        if (out.psCodeLabels_) {
            const countryCodeLabel = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-code-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value === ':' ? '' : d.properties.id // Hide text if value is ':'
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    // size adjustment factor depends on symbol type, and whether stat values are also added to the circles
                    let factor = out.labels_?.values && sizeData.get(d.properties.id)?.value ? 0.8 : 0.9
                    if (out.psShape_ === 'square') factor = factor - 0.4
                    return `${radius * factor}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.labels_?.values && sizeData.get(d.properties.id)?.value ? '-0.3em' : '0'))
        }

        //stat labels
        if (out.labels_?.values) {
            const statLabels = symbolContainers
                .filter((d) => {
                    const datum = sizeData.get(d.properties.id)
                    return datum?.value !== ':' && datum?.value != null // Ignore `':'`, `null`, and `undefined`
                })
                .append('text')
                .attr('class', 'em-circle-stat-label')
                .text((d) => {
                    const datum = sizeData.get(d.properties.id)
                    if (datum?.value) return datum.value
                })
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-family', 'sans-serif')
                .style('font-size', (d) => {
                    // calculate radius
                    const datum = sizeData.get(d.properties.id)
                    const radius = datum ? out.classifierSize_(datum.value) : 0
                    return `${radius * 0.4}px`
                })
                .attr('fill', (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getTextColorForBackground)(out.psFill_))
                .attr('dy', (d) => (out.psCodeLabels_ ? '0.6em' : '0'))
        }
    }

    const addMouseEvents = function (map) {
        let symbols = map.svg().selectAll('g.em-centroid')
        symbols
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.childNodes[0])
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function (e) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.childNodes[0])
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', newFill)
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })
    }

    /**
     * @description sets color/stroke/opacity styles of all symbols
     * @param {d3.selection} symb symbols d3 selection
     */
    function setSymbolStyles(symb) {
        symb.style('fill-opacity', out.psFillOpacity())
            .style('stroke', out.psStroke())
            .style('stroke-width', out.psStrokeWidth())
            .style('fill', function () {
                if (out.classifierColor_) {
                    //for ps, ecl attribute belongs to the parent g.em-centroid node created in map-template
                    const ecl = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this.parentNode).attr('ecl')
                    if (!ecl || ecl === 'nd') return out.noDataFillStyle_ || 'gray'
                    let color = out.psClassToFillStyle_(ecl, out.psClasses_)
                    return color
                } else {
                    return out.psFill_
                }
            })
            .attr('fill___', function () {
                let fill = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this).style('fill')
                return fill // save for legend mouseover
            })
    }

    /**
     * @description Updates the draw order of the symbols according to their data values
     * @param {*} map map instance
     */
    function updateSymbolsDrawOrder(map) {
        const gcp = map.svg_.select('#em-prop-symbols')
        const sizeData = map.statData('size')?.getArray?.() ? map.statData('size') : map.statData()

        // 1. Filter and sort features with data
        if (map.Geometries.centroidFeatures) {
            const sorted = map.Geometries.centroidFeatures
                .filter((f) => {
                    const v = sizeData.get?.(f.properties.id)?.value
                    return v != null && v !== ':'
                })
                .sort((a, b) => {
                    return sizeData.get(b.properties.id).value - sizeData.get(a.properties.id).value
                })

            // 2. Clear and rebind
            gcp.selectAll('g.em-centroid').remove()

            gcp.selectAll('g.em-centroid')
                .data(sorted, (d) => d.properties.id)
                .enter()
                .append('g')
                .attr('class', 'em-centroid')
                .attr('id', (d) => 'ps' + d.properties.id)
                .attr('transform', (d) => `translate(${d.properties.centroid[0].toFixed(3)},${d.properties.centroid[1].toFixed(3)})`)

            // 3. add the ecl attribute back to the newly created g elements
            applyClassificationToMap(map) //
        }
    }

    function appendSpikesToMap(map, sizeData) {
        //The spike function creates a triangular path of the given length (height) with a base width of 7 pixels.
        const spike = (length, width = out.psSpikeWidth_) => `M${-width / 2},0L0,${-length}L${width / 2},0`
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        // Append circles to each symbol container
        const spikes = symbolContainers
            .append('path')
            .attr('d', (d) => {
                const datum = sizeData.get(d.properties.id)
                const value = datum ? out.classifierSize_(datum.value) : 0
                let path = spike(value)
                return path
            })
            .style('fill', (d) => d.color || 'steelblue') // Adjust color as needed
            //.attr('fill', map.psFill_)
            .attr('fill-opacity', map.psFillOpacity_)
            .attr('stroke', map.psStroke_)
            .attr('stroke-width', map.psStrokeWidth_)

        return spikes
    }

    /**
     * @description Appends <circle> elements for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData statistical data for size e.g. map.statData('size')
     * @return {void}
     */
    function appendCirclesToMap(map, sizeData) {
        // Append circles to each symbol container
        const circles = map
            .svg()
            .selectAll('g.em-centroid')
            .filter((d) => {
                const datum = sizeData.get(d.properties.id)
                if (d.properties.id == 'DE') console.log(datum)
                return datum && datum.value !== ':' && datum.value
            })
            .append('circle')
            .attr('r', function (d) {
                const datum = sizeData.get(d.properties.id)
                const radius = out.classifierSize_(datum.value)
                if (radius < 0) console.error('Negative radius for circle:', d.properties.id)
                if (isNaN(radius)) console.error('NaN radius for circle:', d.properties.id)
                return radius
            })

        return circles
    }

    function applyDorlingForce(map, sizeData) {
        let symbolContainers = map.svg().selectAll('g.em-centroid')

        if (out.simulation) {
            stopSimulation()
        }

        // Initialize the force simulation
        console.log('new dorling simulation')
        out.simulation = (0,d3_force__WEBPACK_IMPORTED_MODULE_12__["default"])(map.Geometries.centroidFeatures)
            .force(
                'x',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_13__["default"])((d) => d.properties.centroid[0]).strength(out.dorlingStrength_.x) // Stronger pull to original x
            )
            .force(
                'y',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_14__["default"])((d) => d.properties.centroid[1]).strength(out.dorlingStrength_.y) // Stronger pull to original y
            )
            .force(
                'collide',
                (0,d3_force__WEBPACK_IMPORTED_MODULE_15__["default"])((d) => {
                    const datum = sizeData.get(d.properties.id)
                    let size = datum ? out.classifierSize_(datum.value) : 0

                    if (out.psShape_ === 'square') {
                        return (size / 2) * Math.SQRT2 // Adjust for diagonal size
                    }

                    return size // Default for circles
                }).iterations(out.dorlingIterations_) // More iterations to improve collision handling
            )
            //.alphaTarget(0.3) // Helps keep centroids anchored
            .on('tick', () => {
                // Update elements with the new positions and radii
                symbolContainers.attr('transform', (d) => 'translate(' + d.x + ',' + d.y + ')')
            })

        //out.simulation.alpha(1).restart() // Ensures simulation starts with full strength
    }

    function stopSimulation() {
        out.simulation.stop() // Stops the internal tick loop
        out.simulation.on('tick', null) // Remove tick event listener
        out.simulation.on('end', null) // Remove end event listener
        out.simulation = null // Remove reference
    }

    /**
     * @description Appends <path> elements containing symbols for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendD3SymbolsToMap(map, sizeData) {
        return map
            .svg()
            .selectAll('g.em-centroid')
            .append('path')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .attr('d', (rg) => {
                //calculate size
                if (!sizeData) return
                const sv = sizeData.get(rg.properties.id)
                if (sv != 0 && !sv) return
                let size = out.classifierSize_(+sv.value) || 0

                //apply size to shape
                if (out.psCustomShape_) {
                    return out.psCustomShape_.size(size * size)()
                } else {
                    const symbolType = symbolsLibrary[out.psShape_] || symbolsLibrary['circle']
                    return (0,d3_shape__WEBPACK_IMPORTED_MODULE_16__["default"])()
                        .type(symbolType)
                        .size(size * size)()
                }
            })
    }

    /**
     * @description Appends <rect> elements containing bars for each region in the map SVG
     * @param {*} map map instance
     * @param {*} sizeData e.g. map.statData('size')
     * @return {*}
     */
    function appendBarsToMap(map, sizeData) {
        return (
            map
                .svg()
                .select('#em-prop-symbols')
                .selectAll('g.em-centroid')
                .append('rect')
                .filter((rg) => {
                    const sv = sizeData.get(rg.properties.id)
                    if (sv && sv.value !== ':') return rg
                })
                .attr('width', out.psBarWidth_)
                //for vertical bars we scale the height attribute using the classifier
                .attr('height', function (rg) {
                    const sv = sizeData.get(rg.properties.id)
                    if (!sv || !sv.value) {
                        return 0
                    }
                    let v = out.classifierSize_(+sv.value)
                    return v
                })
                .attr('transform', function () {
                    let bRect = this.getBoundingClientRect()
                    return `translate(${-this.getAttribute('width') / 2}` + `, -${this.getAttribute('height')})`
                })
            // to use transitions we need to refactor the drawing functions to promises e.g. appendBarsToMap().then(()=>{})
            //this is because .attr('fill___', function () {select(this).style('fill')}) doesnt work unless you execute it after the transition ends.
            // e.g.
            // .transition()
            // .duration(out.transitionDuration())
            // .style('fill', function (rg) {})
            // .end()
            // .then()
        )
    }

    /**
     * @description Appends custom SVG symbols for each region in the map
     * @param {*} map
     * @param {*} sizeData
     * @return {*}
     */
    function appendCustomSymbolsToMap(map, sizeData) {
        return map
            .svg()
            .select('#em-prop-symbols')
            .selectAll('g.em-centroid')
            .append('g')
            .filter((rg) => {
                const sv = sizeData.get(rg.properties.id)
                if (sv && sv.value !== ':') return rg
            })
            .attr('class', 'ps')
            .html(out.psCustomSVG_)
            .attr('transform', (rg) => {
                //calculate size
                const sv = sizeData.get(rg.properties.id)
                let size = out.classifierSize_(+sv.value)
                if (size) {
                    return `translate(${out.psOffset_.x * size},${out.psOffset_.y * size}) scale(${size})`
                }
            })
    }

    /**
     * @description adds proportional symbols to each regions in a map with mixed NUTS levels (IMAGE)
     * @param {*} map
     * @param {*} sizeData
     * @param {*} regions
     * @return {*}
     */
    function addSymbolsToMixedNUTS(map, sizeData, regions) {
        // toggle display of mixed NUTS levels
        regions.style('display', function (rg) {
            if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
            const sv = sizeData.get(rg.properties.id)
            if (!sv || (!sv.value && sv !== 0 && sv.value !== 0)) {
                // no symbol for no data
                return 'none'
            } else if (map.geo_ == 'WORLD') {
                return 'block'
            }
        })

        // nuts border stroke
        regions
            .style('stroke', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                const lvl = sel.attr('lvl')
                const stroke = sel.style('stroke')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else {
                    if (lvl !== '0') {
                        return stroke || '#777'
                    }
                }
            })

            // nuts border stroke width
            .style('stroke-width', function (rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])(this)
                const lvl = sel.attr('lvl')
                const strokeWidth = sel.style('stroke-width')
                const sv = sizeData.get(rg.properties.id)
                if (!sv || !sv.value) {
                    return
                } else if (out.geo_ == 'WORLD') {
                    if (lvl !== '0') {
                        return strokeWidth || '#777'
                    }
                }
            })
    }

    //@override
    out.updateStyle = function () {
        // apply to main map
        applyStyleToMap(out)

        // apply style to insets
        // apply classification to all insets
        if (out.insetTemplates_) {
            for (const geo in out.insetTemplates_) {
                if (Array.isArray(out.insetTemplates_[geo])) {
                    for (var i = 0; i < out.insetTemplates_[geo].length; i++) {
                        // insets with same geo that do not share the same parent inset
                        if (Array.isArray(out.insetTemplates_[geo][i])) {
                            // this is the case when there are more than 2 different insets with the same geo. E.g. 3 insets for PT20
                            for (var c = 0; c < out.insetTemplates_[geo][i].length; c++) {
                                if (out.insetTemplates_[geo][i][c].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i][c])
                            }
                        } else {
                            if (out.insetTemplates_[geo][i].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo][i])
                        }
                    }
                } else {
                    // unique inset geo_
                    if (out.insetTemplates_[geo].svgId_ !== out.svgId_) applyStyleToMap(out.insetTemplates_[geo])
                }
            }
        }

        return out
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_proportional_symbols__WEBPACK_IMPORTED_MODULE_2__.legend
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun, colorArray) {
    colorFun = colorFun || d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__["default"]
    if (colorArray) {
        return function (ecl, numberOfClasses) {
            return colorArray[ecl]
        }
    }
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}

/**
 * @description give a d3 symbol from a shape name
 */
const symbolsLibrary = {
    cross: d3_shape__WEBPACK_IMPORTED_MODULE_17__["default"],
    square: d3_shape__WEBPACK_IMPORTED_MODULE_18__["default"],
    diamond: d3_shape__WEBPACK_IMPORTED_MODULE_19__["default"],
    triangle: d3_shape__WEBPACK_IMPORTED_MODULE_20__["default"],
    star: d3_shape__WEBPACK_IMPORTED_MODULE_21__["default"],
    wye: d3_shape__WEBPACK_IMPORTED_MODULE_22__["default"],
    circle: d3_shape__WEBPACK_IMPORTED_MODULE_23__["default"],
}

/**
 * Specific function for tooltip text.
 *
 * @param {*} rg The region to show information on.
 * @param {*} map The map element
 */
const tooltipTextFunPs = function (region, map) {
    const buf = []

    // Header with region name and ID
    const regionName = region.properties.na
    const regionId = region.properties.id
    buf.push(`
        <div class="estat-vis-tooltip-bar">
            <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
        </div>
    `)

    //stat 1 value
    const v1 = map.statData('size').getArray() ? map.statData('size') : map.statData()
    const sv1 = v1.get(region.properties.id)
    if (!sv1 || (sv1.value != 0 && !sv1.value)) {
        buf.push(map.noDataText_)
    } else {
        //unit 1
        const unit1 = v1.unitText()
        buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.spaceAsThousandSeparator)(sv1.value)} ${unit1 ? unit1 : ' '}</div>`)
    }

    //stat 2 value
    if (map.statData('color').getArray()) {
        const sv2 = map.statData('color').get(region.properties.id)
        if (!sv2 || (sv2.value != 0 && !sv2.value)) buf.push(map.noDataText_)
        else {
            //stat 2
            const unit2 = map.statData('color').unitText()
            buf.push(`<div class="estat-vis-tooltip-text">${(0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.spaceAsThousandSeparator)(sv2.value)} ${unit2 ? unit2 : ' '}</div>`)
        }
    }

    return buf.join('')
}


/***/ }),

/***/ "./src/maptypes/map-sparklines.js":
/*!****************************************!*\
  !*** ./src/maptypes/map-sparklines.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getColorLegend: () => (/* binding */ getColorLegend),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/create.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js");
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-axis */ "./node_modules/d3-axis/src/axis.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../legend/legend-choropleth */ "./src/legend/legend-choropleth.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");
/* harmony import */ var _core_stat_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/stat-data */ "./src/core/stat-data.js");









/**
 * Returns a sparkline map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_1__.statMap(config, true, 'spark')

    out.sparkLineColor_ = 'black'
    out.sparkAreaColor_ = '#41afaa'
    out.sparkLineWidth_ = 30
    out.sparkLineHeight_ = 20
    out.sparkLineStrokeWidth_ = 0.4
    out.sparkLineOpacity_ = 0.6
    out.sparkType_ = 'line'
    out.sparkLineCircleRadius_ = 0
    out.sparkTooltipChart_ = {
        width: 100,
        height: 50,
        margin: { left: 60, right: 40, top: 40, bottom: 40 },
        circleRadius: 1.5,
    }

    //show sparklines only when data for all dates is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false
    out.sparkLineChartFunction_ = undefined

    out.statSpark_ = null
    out.sparkHeightClassifier_ = null

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'sparkLineColor_',
        'showOnlyWhenComplete_',
        'sparkType_',
        'sparkLineWidth_',
        'sparkLineHeight_',
        'sparkLineStrokeWidth_',
        'sparkLineOpacity_',
        'sparkLineCircleRadius_',
        'sparkLineAreaColor_',
        'sparkTooltipChart_',
        'sparkLineChartFunction_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'sparkLineColor',
            'showOnlyWhenComplete',
            'sparkType',
            'sparkLineWidth',
            'sparkLineHeight',
            'sparkLineStrokeWidth',
            'sparkLineOpacity',
            'sparkLineCircleRadius_',
            'sparkLineAreaColor',
            'sparkTooltipChart_',
            'sparkLineChartFunction_',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    // Allow users manually add sparkline data
    out.sparklineData_ = undefined
    out.sparklineData = function (dataObject) {
        const dates = Object.keys(dataObject[Object.keys(dataObject)[0]])
        out._statDates = dates

        dates.forEach((date) => {
            const statData = _core_stat_data__WEBPACK_IMPORTED_MODULE_4__.statData()
            const perDateValues = {}

            for (const regionId in dataObject) {
                const regionValues = dataObject[regionId]
                perDateValues[regionId] = regionValues[date]
            }

            statData.setData(perDateValues)
            out.statData(date, statData)
        })

        return out
    }

    /**
     * A function to define a sparkline map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {Array} dates The dates of the composition (time parameter)
     * @param {Array} labels Optional: The labels for the dates
     */
    out.statSpark = function (stat, dates, labels) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < dates.length; i++) {
            //category code
            const date = dates[i]
            stat.filters.time = date
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(date, sc_)

            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[date] = labels[i]
            }
        }

        //set statCodes
        out._statDates = dates

        return out
    }

    /** The codes of the categories to consider for the composition. */
    out._statDates = undefined

    /**
     * Function to compute composition for region id, for each date.
     * Return an object with, for each date, its statistical value for the region
     * @param {*} id
     * @returns [{date,value}]
     */
    const getComposition = function (id) {
        let comp = [],
            sum = 0

        // Get stat value for each category and compute the sum.
        for (let i = 0; i < out._statDates.length; i++) {
            // Retrieve code and stat value
            const date = out._statDates[i]
            const s = out.statData(date).get(id)

            // Case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp.push({ date: date, value: s.value })
            sum += s.value
        }

        // Case when no data
        if (sum == 0) return undefined

        // Calculate year-on-year percentage change
        for (let i = 1; i < comp.length; i++) {
            const previousValue = comp[i - 1].value
            const currentValue = comp[i].value

            // Calculate percentage change from previous value
            comp[i].percentageChange = previousValue === 0 ? 0.001 : ((currentValue - previousValue) / previousValue) * 100
        }

        // The first data point doesn't have a previous value to compare with
        //comp[0].percentageChange = 0.001 // or you can leave it undefined or null, depending on how you want to handle it

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!out._statDates) {
            //get list of stat codes.
            out._statDates = Object.keys(out.statData_)
            //remove "default", if present
            const index = out._statDates.indexOf('default')
            if (index > -1) out._statDates.splice(index, 1)
        }

        // define size scaling function
        // Define the domain correctly for the log scale
        out.domain = getDatasetMaxMin() // Avoid 0 for log scale

        // for area charts
        out.widthClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__.sqrt)().domain(out.domain).range([0, out.sparkLineWidth_])
        out.heightClassifier_ = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__.sqrt)().domain(out.domain).range([0, out.sparkLineHeight_])

        return out
    }

    //@override
    out.updateStyle = function () {
        //build and assign pie charts to the regions
        //collect nuts ids from g elements. TODO: find better way of getting IDs
        let nutsIds = []
        let s = out.svg().selectAll('#em-prop-symbols')
        let sym = s.selectAll('g.em-centroid').attr('id', (rg) => {
            nutsIds.push(rg.properties.id)
            return 'spark_' + rg.properties.id
        })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_3__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                    sel.attr('fill___', sel.style('fill'))
                    sel.style('fill', out.hoverColor_)
                    if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
                }
            })
            .on('mousemove', function (e, rg) {
                const data = getComposition(rg.properties.id)
                if (data) {
                    if (out._tooltip) out._tooltip.mousemove(e)
                }
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_6__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        addSparkLinesToMap(nutsIds)
        return out
    }

    function addSparkLinesToMap(ids) {
        ids.forEach((nutsid) => {
            //create svg for sparkline
            // can be more than one center point for each nuts ID (e.g. Malta when included in insets)
            let node = out.svg().select('#spark_' + nutsid)
            let data = getComposition(nutsid)

            if (data) {
                createSparkLineChart(node, data, out.sparkLineWidth_, out.sparkLineHeight_)
            }
        })
    }

    function createSparkLineChart(node, data, width, height, isForTooltip = false) {
        // call custom user function to draw the sparkline
        if (out.sparkLineChartFunction_ && out.sparkLineChartFunction_ !== createSparkLineChart) {
            return out.sparkLineChartFunction_(node, data, width, height, isForTooltip)
        }

        const xScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])()
            .domain([0, out._statDates.length - 1])
            .range([0.5, width - 0.5])

        const minValue = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.min)(data.map((d) => d.value)) || 0
        const maxValue = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.max)(data.map((d) => d.value)) || 1

        const yScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"])().domain([minValue, maxValue]).range([height, 0])

        const scaledData = data.map((d, i) => ({
            ...d,
            scaledXValue: xScale(i),
            scaledYValue: yScale(d.value),
        }))

        const zeroY = yScale(0)

        if (isForTooltip) {
            // X-axis at bottom
            node.append('g')
                .attr('class', 'axis-x')
                .attr('transform', `translate(0, ${height})`)
                .call(
                    (0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisBottom)(xScale)
                        .ticks(out._statDates.length)
                        .tickFormat((d, i) => out._statDates[i])
                )
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-65)')

            // Y-axis with raw value labels
            node.append('g').attr('class', 'axis-y').call((0,d3_axis__WEBPACK_IMPORTED_MODULE_8__.axisLeft)(yScale).ticks(5))

            // Horizontal zero reference line  only if min < 0 and max > 0
            if (minValue < 0 && maxValue > 0) {
                node.append('line')
                    .attr('x1', 0)
                    .attr('x2', width)
                    .attr('y1', zeroY)
                    .attr('y2', zeroY)
                    .attr('stroke', 'gray')
                    .attr('stroke-dasharray', '2,2')
                    .attr('stroke-width', 1)
            }
        }

        const lineGenerator = (0,d3_shape__WEBPACK_IMPORTED_MODULE_9__["default"])()
            .x((d) => d.scaledXValue)
            .y((d) => d.scaledYValue)

        if (out.sparkType_ === 'area') {
            node.append('path')
                .datum(scaledData)
                .attr('fill', typeof out.sparkAreaColor_ === 'function' ? (d, i) => out.sparkAreaColor_(d, i) : out.sparkAreaColor_)
                .attr('stroke', 'none')
                .attr('opacity', out.sparkLineOpacity_)
                .attr('fill-opacity', 0.3)
                .attr(
                    'd',
                    (0,d3_shape__WEBPACK_IMPORTED_MODULE_10__["default"])()
                        .x((d) => d.scaledXValue)
                        .y0(zeroY)
                        .y1((d) => d.scaledYValue)
                )
        }

        node.append('path')
            .datum(scaledData)
            .attr('fill', 'none')
            .attr('opacity', out.sparkLineOpacity_)
            .attr('stroke', typeof out.sparkLineColor_ === 'function' ? (d, i) => out.sparkLineColor_(d, i) : out.sparkLineColor_)
            .attr(
                'stroke-width',
                typeof out.sparkLineStrokeWidth_ === 'function' ? (d, i) => out.sparkLineStrokeWidth_(d, i) : out.sparkLineStrokeWidth_ + 'px'
            )
            .attr('d', lineGenerator)

        node.selectAll('circle')
            .data(scaledData)
            .enter()
            .append('circle')
            .attr('cx', (d) => d.scaledXValue)
            .attr('cy', (d) => d.scaledYValue)
            .attr('r', out.sparkLineCircleRadius_)
            .attr('fill', 'red')
            .attr('stroke', 'none')
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (region, map) {
        const buf = []

        const regionName = region.properties.na
        const regionId = region.properties.id
        buf.push(`
                <div class="estat-vis-tooltip-bar">
                    <b>${regionName}</b>${regionId ? ` (${regionId})` : ''}
                </div>
            `)

        const chartHeight = out.sparkTooltipChart_.height
        const chartWidth = out.sparkTooltipChart_.width
        const margin = out.sparkTooltipChart_.margin
        const data = getComposition(region.properties.id)

        if (data) {
            // Total SVG size (including margins)
            const totalWidth = chartWidth + margin.left + margin.right
            const totalHeight = chartHeight + margin.top + margin.bottom

            // Create detached div
            const container = (0,d3_selection__WEBPACK_IMPORTED_MODULE_11__["default"])('div').attr('class', 'em-tooltip-chart-container')

            // Create SVG with full size
            const svg = container.append('svg').attr('class', 'em-tooltip-chart-svg').attr('width', totalWidth).attr('height', totalHeight)

            // Inner group where chart is drawn
            const g = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`)

            // Call sparkline drawing on the inner area only
            createSparkLineChart(g, data, chartWidth, chartHeight, true)

            // Add result to tooltip buffer
            buf.push(container.node().outerHTML)
        }

        return buf.join('')
    }

    /**
     * @function getDatasetMaxMin
     * @description gets the maximum and minimum values of all dates for each region. Used to define the domain of the sparkline Y axis.
     * @returns [min,max]
     */
    function getDatasetMaxMin() {
        const maxs = []
        const sel = out.svg().selectAll('#em-prop-symbols').selectAll('g.em-centroid').data()

        sel.forEach((rg) => {
            const id = rg.properties.id
            const regionMax = getRegionMax(id)
            if (regionMax !== undefined) {
                maxs.push(regionMax)
            }
        })

        if (maxs.length === 0) {
            return [0, 1] // fallback if no data found
        }

        return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.extent)(maxs)
    }

    /**
     * Get absolute total value of combined statistical values for a specific region. E.g total livestock
     * @param {*} id nuts region id
     */
    const getRegionMax = function (id) {
        let max = 0

        // get stat value for each date and find the max
        for (let i = 0; i < out._statDates.length; i++) {
            const date = out._statDates[i]
            const statData = out.statData(date)

            if (!statData || typeof statData.get !== 'function') continue

            const s = statData.get(id)
            if (!s || (s.value !== 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                continue
            }

            if (s.value > max) max = s.value
        }

        if (max === 0) return undefined
        return max
    }

    //@override
    out.getLegendConstructor = function () {
        //TODO define legend
        return _legend_legend_choropleth__WEBPACK_IMPORTED_MODULE_2__.legend
    }

    return out
}

//build a color legend object
const getColorLegend = function (colorFun) {
    colorFun = colorFun || interpolateYlOrRd
    return function (ecl, numberOfClasses) {
        return colorFun(ecl / (numberOfClasses - 1))
    }
}


/***/ }),

/***/ "./src/maptypes/map-stripe-composition.js":
/*!************************************************!*\
  !*** ./src/maptypes/map-stripe-composition.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/pie.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var _core_stat_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/stat-map */ "./src/core/stat-map.js");
/* harmony import */ var _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../legend/legend-stripe-composition */ "./src/legend/legend-stripe-composition.js");
/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ "./src/core/utils.js");



//schemeSet3 schemeDark2 schemePastel1 schemeTableau10



/**
 * Return a stripe composition map.
 *
 * @param {*} config
 */
const map = function (config) {
    //create map object to return, using the template
    const out = _core_stat_map__WEBPACK_IMPORTED_MODULE_0__.statMap(config, false, 'scomp')

    //width of the stripes serie
    out.stripeWidth_ = 50
    //orientation - vertical by default
    out.stripeOrientation_ = 0

    //colors - indexed by category code
    out.catColors_ = undefined
    //labels - indexed by category code
    out.catLabels_ = undefined

    //show stripes only when data for all categories is complete.
    //Otherwise, consider the regions as being with no data at all.
    out.showOnlyWhenComplete_ = false

    //tooltip pie chart
    out.pieChartRadius_ = 40
    out.pieChartInnerRadius_ = 15

    /**
     * Definition of getters/setters for all previously defined attributes.
     * Each method follow the same pattern:
     *  - There is a single method as getter/setter of each attribute. The name of this method is the attribute name, without the trailing "_" character.
     *  - To get the attribute value, call the method without argument.
     *  - To set the attribute value, call the same method with the new value as single argument.
     */
    ;[
        'stripeWidth_',
        'stripeOrientation_',
        'catColors_',
        'catLabels_',
        'showOnlyWhenComplete_',
        'noDataFillStyle_',
        'pieChartRadius_',
        'pieChartInnerRadius_',
    ].forEach(function (att) {
        out[att.substring(0, att.length - 1)] = function (v) {
            if (!arguments.length) return out[att]
            out[att] = v
            return out
        }
    })

    //override attribute values with config values
    if (config)
        [
            'stripeWidth',
            'stripeOrientation',
            'catColors',
            'catLabels',
            'showOnlyWhenComplete',
            'noDataFillStyle',
            'pieChartRadius',
            'pieChartInnerRadius',
        ].forEach(function (key) {
            if (config[key] != undefined) out[key](config[key])
        })

    /**
     * A function to define a stripe map easily, without repetition of information.
     * Only for eurobase data sources.
     *
     * @param {*} stat A pattern for the stat data source
     * @param {String} dim The dimension of the composition.
     * @param {Array} codes The category codes of the composition
     * @param {Array} labels Optional: The labels for the category codes
     * @param {Array} colors Optional: The colors for the category
     */
    out.statComp = function (stat, dim, codes, labels, colors) {
        //add one dataset config for each category
        stat.filters = stat.filters || {}
        for (let i = 0; i < codes.length; i++) {
            //category code
            const code = codes[i]
            stat.filters[dim] = code
            const sc_ = {}
            for (let key in stat) sc_[key] = stat[key]
            sc_.filters = {}
            for (let key in stat.filters) sc_.filters[key] = stat.filters[key]
            out.stat(code, sc_)

            //if specified, retrieve and assign color
            if (colors) {
                out.catColors_ = out.catColors_ || {}
                out.catColors_[code] = colors[i]
            }
            //if specified, retrieve and assign label
            if (labels) {
                out.catLabels_ = out.catLabels_ || {}
                out.catLabels_[code] = labels[i]
            }
        }

        //set statCodes
        statCodes = codes

        return out
    }

    /** The codes of the categories to consider for the composition. */
    let statCodes = undefined

    /**
     * Function to compute composition for region id, for each category.
     * Return an object with, for each category, the share [0,1] of the category.
     * @param {*} id
     */
    const getComposition = function (id) {
        let comp = {},
            sum = 0
        //get stat value for each category. Compute the sum.
        for (let i = 0; i < statCodes.length; i++) {
            //retrieve code and stat value
            const sc = statCodes[i]
            const s = out.statData(sc).get(id)

            //case when some data is missing
            if (!s || (s.value != 0 && !s.value) || isNaN(s.value)) {
                if (out.showOnlyWhenComplete()) return undefined
                else continue
            }

            comp[sc] = s.value
            sum += s.value
        }

        //case when no data
        if (sum == 0) return undefined

        //compute ratios
        for (let i = 0; i < statCodes.length; i++) comp[statCodes[i]] /= sum

        return comp
    }

    //@override
    out.updateClassification = function () {
        //if not provided, get list of stat codes from the map stat data
        if (!statCodes) {
            //get list of stat codes.
            statCodes = Object.keys(out.statData_)
            //remove "default", if present
            const index = statCodes.indexOf('default')
            if (index > -1) statCodes.splice(index, 1)
        }

        return out
    }

    //@override
    out.updateStyle = function () {
        //if not specified, build default color ramp
        if (!out.catColors()) {
            out.catColors({})
            for (let i = 0; i < statCodes.length; i++) out.catColors()[statCodes[i]] = d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_3__["default"][i % 10]
        }

        //if not specified, initialise category labels
        out.catLabels_ = out.catLabels_ || {}

        //build and assign texture to the regions
        out.svg()
            .selectAll((0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out))
            .style('fill', function (d) {
                if (this.parentNode.classList.contains('em-cntrg')) return // Skip country regions
                const id = d.properties.id

                //compute composition
                const composition = getComposition(id)

                //case when no or missing data
                if (!composition) return out.noDataFillStyle() || 'gray'

                //make stripe pattern
                const patt = out
                    .svg()
                    .append('pattern')
                    .attr('id', 'pattern_' + id)
                    .attr('x', '0')
                    .attr('y', '0')
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .attr('patternUnits', 'userSpaceOnUse')
                //use orientation, if specified
                if (out.stripeOrientation()) patt.attr('patternTransform', 'rotate(' + out.stripeOrientation() + ')')

                //background
                patt.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', out.stripeWidth())
                    .attr('height', 1)
                    .style('stroke', 'none')
                    .style('fill', 'lightgray')

                //make stripes, one per category
                let x = 0
                for (let code in composition) {
                    //get stripe size
                    let dx = composition[code]
                    if (!dx) continue
                    dx *= out.stripeWidth()

                    //get stripe color
                    const col = out.catColors()[code] || 'lightgray'

                    //add stripe to pattern: a thin rectangle
                    patt.append('rect')
                        .attr('x', x)
                        .attr('y', 0)
                        .attr('height', 1)
                        .style('stroke', 'none')
                        .attr('code', code)
                        .style('fill', col)
                        //transition along x
                        .transition()
                        .duration(out.transitionDuration())
                        .attr('width', dx)
                    x += dx
                }

                //return pattern reference
                return 'url(#pattern_' + id + ')'
            })
            .attr('nd', function (d) {
                return !getComposition(d.properties.id) ? 'nd' : ''
            })

        // set region hover function
        const selector = (0,_core_utils__WEBPACK_IMPORTED_MODULE_2__.getRegionsSelector)(out)
        let regions = out.svg().selectAll(selector)
        regions
            .on('mouseover', function (e, rg) {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                sel.attr('fill___', sel.style('fill'))
                sel.style('fill', out.hoverColor_)
                if (out._tooltip) out._tooltip.mouseover(out.tooltip_.textFunction(rg, out))
            })
            .on('mousemove', function (e, rg) {
                if (out._tooltip) out._tooltip.mousemove(e)
            })
            .on('mouseout', function () {
                const sel = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this)
                let currentFill = sel.style('fill')
                let newFill = sel.attr('fill___')
                if (newFill) {
                    sel.style('fill', sel.attr('fill___'))
                    if (out._tooltip) out._tooltip.mouseout()
                }
            })

        return out
    }

    //@override
    out.getLegendConstructor = function () {
        return _legend_legend_stripe_composition__WEBPACK_IMPORTED_MODULE_1__.legend
    }

    //specific tooltip text function
    out.tooltip_.textFunction = function (rg, map) {
        //get tooltip
        const tp = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])('#tooltip_eurostat')

        //clear
        tp.html('')
        tp.selectAll('*').remove()

        //write region name
        const regionName = rg.properties.na || rg.properties.name
        if (rg.properties.id) {
            //name and code
            tp.append('div').html('<b>' + regionName + '</b> (' + rg.properties.id + ') <br>')
        } else {
            //region name
            tp.append('div').html('<b>' + regionName + '</b><br>')
        }

        //prepare data for pie chart
        const data = []
        const comp = getComposition(rg.properties.id)
        for (const key in comp) data.push({ code: key, value: comp[key] })

        //case of regions with no data
        if (!data || data.length == 0) {
            tp.append('div').html(out.noDataText())
            return
        }

        //create svg for pie chart
        const r = out.pieChartRadius(),
            ir = out.pieChartInnerRadius()
        const svg = tp
            .append('svg')
            .attr('viewBox', [-r, -r, 2 * r, 2 * r])
            .attr('width', 2 * r)

        //make pie chart. See https://observablehq.com/@d3/pie-chart
        const pie_ = (0,d3_shape__WEBPACK_IMPORTED_MODULE_5__["default"])()
            .sort(null)
            .value((d) => d.value)
        svg.append('g')
            .attr('stroke', 'darkgray')
            .selectAll('path')
            .data(pie_(data))
            .join('path')
            .style('fill', (d) => {
                return out.catColors()[d.data.code] || 'lightgray'
            })
            .attr('d', (0,d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"])().innerRadius(ir).outerRadius(r))
    }

    return out
}


/***/ }),

/***/ "./src/tooltip/tooltip.js":
/*!********************************!*\
  !*** ./src/tooltip/tooltip.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tooltip: () => (/* binding */ tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * @param {*} config
 * @returns
 */
const tooltip = function (config) {
    config = config || {}
    config.containerId = config.containerId || 'map'
    config.div = config.div || 'tooltip_eurostat'
    config.maxWidth = config.maxWidth || '200px'
    config.fontSize = config.fontSize || '14px'
    config.background = config.background || 'white'
    config.padding = config.padding || '0px'
    config.border = config.border || '0px'
    config.borderRadius = config.borderRadius || '0px'
    config.boxShadow = config.boxShadow || '0px 0px 0px grey'

    config.transitionDuration = config.transitionDuration || 0
    config.xOffset = config.xOffset || 30
    config.yOffset = config.yOffset || 20

    let tooltip

    function my() {
        tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + config.div)
        if (tooltip.empty()) tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('body').append('div').attr('id', config.div)

        tooltip.attr('class', 'tooltip-eurostat')
    }

    my.mouseover = function (html) {
        if (html) tooltip.html(html)
        let x = event.pageX
        let y = event.pageY
        my.ensureTooltipOnScreen(x, y)
    }

    my.mousemove = function (event) {
        let x = event.pageX
        let y = event.pageY
        this.ensureTooltipOnScreen(x, y)
    }

    my.mouseout = function () {
        tooltip.style('opacity', 0)
    }

    my.style = function (k, v) {
        if (arguments.length == 1) return tooltip.style(k)
        tooltip.style(k, v)
        return my
    }

    my.attr = function (k, v) {
        if (arguments.length == 1) return tooltip.attr(k)
        tooltip.attr(k, v)
        return my
    }

    /**
     * @function ensureTooltipOnScreen
     * @description Prevents the tooltip from overflowing off screen
     */
    my.ensureTooltipOnScreen = function (eventX, eventY) {
        tooltip.style('opacity', 1)
        let node = tooltip.node()

        node.style.left = eventX + config.xOffset + 'px'
        node.style.top = eventY - config.yOffset + 'px'

        let parent = document.getElementById(config.containerId)
        let rect = parent.getBoundingClientRect() // get the bounding rectangle
        let parentWidth = rect.width
        let parentHeight = rect.height

        //too far right
        //taking into account off screen space but shouldnt be
        if (node.offsetLeft > rect.left + parentWidth - node.clientWidth) {
            let left = eventX - node.clientWidth - config.xOffset
            node.style.left = left + 'px'
            // check if mouse covers tooltip
            if (node.offsetLeft + node.clientWidth > eventX) {
                //move tooltip left so it doesnt cover mouse
                let left2 = eventX - node.clientWidth - config.xOffset
                node.style.left = left2 + 'px'
            }
            // node.style.top = node.offsetTop + config.yOffset + "px";
        }

        //too far down
        if (node.offsetTop + node.clientHeight > rect.top + parentHeight) {
            node.style.top = node.offsetTop - node.clientHeight + 'px'
        }
    }

    my()
    return my
}


/***/ }),

/***/ "./node_modules/d3-axis/src/axis.js":
/*!******************************************!*\
  !*** ./node_modules/d3-axis/src/axis.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   axisBottom: () => (/* binding */ axisBottom),
/* harmony export */   axisLeft: () => (/* binding */ axisLeft),
/* harmony export */   axisRight: () => (/* binding */ axisRight),
/* harmony export */   axisTop: () => (/* binding */ axisTop)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-axis/src/identity.js");


var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + x + ",0)";
}

function translateY(y) {
  return "translate(0," + y + ")";
}

function number(scale) {
  return d => +scale(d);
}

function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return d => +scale(d) + offset;
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + offset,
        range1 = +range[range.length - 1] + offset,
        position = (scale.bandwidth ? center : number)(scale.copy(), offset),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient === right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d) + offset); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = Array.from(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  axis.offset = function(_) {
    return arguments.length ? (offset = +_, axis) : offset;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),

/***/ "./node_modules/d3-axis/src/identity.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-axis/src/identity.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ brighter),
/* harmony export */   darker: () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hcl: () => (/* binding */ Hcl),
/* harmony export */   Lab: () => (/* binding */ Lab),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   gray: () => (/* binding */ gray),
/* harmony export */   hcl: () => (/* binding */ hcl),
/* harmony export */   lch: () => (/* binding */ lch)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   radians: () => (/* binding */ radians)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csvFormat: () => (/* binding */ csvFormat),
/* harmony export */   csvFormatBody: () => (/* binding */ csvFormatBody),
/* harmony export */   csvFormatRow: () => (/* binding */ csvFormatRow),
/* harmony export */   csvFormatRows: () => (/* binding */ csvFormatRows),
/* harmony export */   csvFormatValue: () => (/* binding */ csvFormatValue),
/* harmony export */   csvParse: () => (/* binding */ csvParse),
/* harmony export */   csvParseRows: () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tsvFormat: () => (/* binding */ tsvFormat),
/* harmony export */   tsvFormatBody: () => (/* binding */ tsvFormatBody),
/* harmony export */   tsvFormatRow: () => (/* binding */ tsvFormatRow),
/* harmony export */   tsvFormatRows: () => (/* binding */ tsvFormatRows),
/* harmony export */   tsvFormatValue: () => (/* binding */ tsvFormatValue),
/* harmony export */   tsvParse: () => (/* binding */ tsvParse),
/* harmony export */   tsvParseRows: () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csv: () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   tsv: () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_3__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-force/src/collide.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/jiggle.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force/src/lcg.js":
/*!******************************************!*\
  !*** ./node_modules/d3-force/src/lcg.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force/src/simulation.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["default"])("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/x.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/y.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatPrefix: () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatDecimalParts: () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   prefixExponent: () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatSpecifier: () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionFixed.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionFixed.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionPrefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionPrefix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionRound.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionRound.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(step)) + 1;
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   genericArray: () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return ((0,_numberArray_js__WEBPACK_IMPORTED_MODULE_0__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ piecewise)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_1__["default"]
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_2__["default"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]) : _string_js__WEBPACK_IMPORTED_MODULE_4__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_2__["default"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_3__["default"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_5__["default"]
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_6__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_6__["default"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_7__.genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_8__["default"]
      : _number_js__WEBPACK_IMPORTED_MODULE_1__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathRound: () => (/* binding */ pathRound)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}

class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x, y) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y) {
    this._append`L${this._x1 = +x},${this._y1 = +y}`;
  }
  quadraticCurveTo(x1, y1, x, y) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    }

    // Otherwise, draw an arc!
    else {
      let x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }

      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
    }
  }
  rect(x, y, w, h) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}

function path() {
  return new Path;
}

// Allow instanceof d3.path
path.prototype = Path.prototype;

function pathRound(digits = 3) {
  return new Path(+digits);
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnt necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set3.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/categorical/category10.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/category10.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/colors.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/colors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/ramp.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/ramp.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scheme => (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.rgbBasis)(scheme[scheme.length - 1]));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   scheme: () => (/* binding */ scheme)
/* harmony export */ });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "./node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "./node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/ascending.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/ascending.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/bisect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/bisect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bisectCenter: () => (/* binding */ bisectCenter),
/* harmony export */   bisectLeft: () => (/* binding */ bisectLeft),
/* harmony export */   bisectRight: () => (/* binding */ bisectRight),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-scale/node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "./node_modules/d3-scale/node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_number_js__WEBPACK_IMPORTED_MODULE_2__["default"]).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/bisector.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/bisector.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-scale/node_modules/d3-array/src/ascending.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-scale/node_modules/d3-array/src/descending.js");



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We cant do this
  // for a comparator (except for specific, known comparators) because we cant
  // tell if the comparator is symmetric, and an asymmetric comparator cant be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"] || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/descending.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/descending.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/greatest.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/greatest.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ greatest)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-scale/node_modules/d3-array/src/ascending.js");


function greatest(values, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, maxValue) > 0
          : (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/max.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/max.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/maxIndex.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/maxIndex.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxIndex)
/* harmony export */ });
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/min.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/min.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/minIndex.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/minIndex.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minIndex)
/* harmony export */ });
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/number.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/number.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number),
/* harmony export */   numbers: () => (/* binding */ numbers)
/* harmony export */ });
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/permute.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/permute.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ permute)
/* harmony export */ });
function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/quantile.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/quantile.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   quantileIndex: () => (/* binding */ quantileIndex),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "./node_modules/d3-scale/node_modules/d3-array/src/max.js");
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./maxIndex.js */ "./node_modules/d3-scale/node_modules/d3-array/src/maxIndex.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "./node_modules/d3-scale/node_modules/d3-array/src/min.js");
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./minIndex.js */ "./node_modules/d3-scale/node_modules/d3-array/src/minIndex.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "./node_modules/d3-scale/node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/node_modules/d3-array/src/number.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-scale/node_modules/d3-array/src/sort.js");
/* harmony import */ var _greatest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./greatest.js */ "./node_modules/d3-scale/node_modules/d3-array/src/greatest.js");









function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantileIndex(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)));
  if (p <= 0) return (0,_minIndex_js__WEBPACK_IMPORTED_MODULE_4__["default"])(numbers);
  if (p >= 1) return (0,_maxIndex_js__WEBPACK_IMPORTED_MODULE_5__["default"])(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  (0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(index, i, 0, j, (i, j) => (0,_sort_js__WEBPACK_IMPORTED_MODULE_6__.ascendingDefined)(numbers[i], numbers[j]));
  i = (0,_greatest_js__WEBPACK_IMPORTED_MODULE_7__["default"])(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/quickselect.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/quickselect.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-scale/node_modules/d3-array/src/sort.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? _sort_js__WEBPACK_IMPORTED_MODULE_0__.ascendingDefined : (0,_sort_js__WEBPACK_IMPORTED_MODULE_0__.compareDefined)(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/range.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/range.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ range)
/* harmony export */ });
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/sort.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/sort.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascendingDefined: () => (/* binding */ ascendingDefined),
/* harmony export */   compareDefined: () => (/* binding */ compareDefined),
/* harmony export */   "default": () => (/* binding */ sort)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-scale/node_modules/d3-array/src/ascending.js");
/* harmony import */ var _permute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./permute.js */ "./node_modules/d3-scale/node_modules/d3-array/src/permute.js");



function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return (0,_permute_js__WEBPACK_IMPORTED_MODULE_0__["default"])(values, index);
  }
  return values.sort(compareDefined(f));
}

function compareDefined(compare = _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
  if (compare === _ascending_js__WEBPACK_IMPORTED_MODULE_1__["default"]) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}


/***/ }),

/***/ "./node_modules/d3-scale/node_modules/d3-array/src/ticks.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-scale/node_modules/d3-array/src/ticks.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ticks),
/* harmony export */   tickIncrement: () => (/* binding */ tickIncrement),
/* harmony export */   tickStep: () => (/* binding */ tickStep)
/* harmony export */ });
const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log10(step)),
      error = step / Math.pow(10, power),
      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}

function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
  }
  return ticks;
}

function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}

function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/band.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/band.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ band),
/* harmony export */   point: () => (/* binding */ point)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/range.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _ordinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ordinal.js */ "./node_modules/d3-scale/src/ordinal.js");




function band() {
  var scale = (0,_ordinal_js__WEBPACK_IMPORTED_MODULE_0__["default"])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}


/***/ }),

/***/ "./node_modules/d3-scale/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constants)
/* harmony export */ });
function constants(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-scale/src/continuous.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/continuous.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (/* binding */ continuous),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   transformer: () => (/* binding */ transformer)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/src/number.js");





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"],
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_4__["default"]), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initInterpolator: () => (/* binding */ initInterpolator),
/* harmony export */   initRange: () => (/* binding */ initRange)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/linear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/linear.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ linear),
/* harmony export */   linearish: () => (/* binding */ linearish)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/ticks.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickFormat.js */ "./node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat_js__WEBPACK_IMPORTED_MODULE_1__["default"])(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, linear());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number)
/* harmony export */ });
function number(x) {
  return +x;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/ordinal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/ordinal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ordinal),
/* harmony export */   implicit: () => (/* binding */ implicit)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/internmap/src/index.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



const implicit = Symbol("implicit");

function ordinal() {
  var index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    let i = index.get(d);
    if (i === undefined) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new d3_array__WEBPACK_IMPORTED_MODULE_0__.InternMap();
    for (const value of _) {
      if (index.has(value)) continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/pow.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/pow.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pow),
/* harmony export */   powish: () => (/* binding */ powish),
/* harmony export */   sqrt: () => (/* binding */ sqrt)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__["default"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantize.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantize.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantize)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/bisect.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_linear_js__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/threshold.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/threshold.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ threshold)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/bisect.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/tickFormat.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/tickFormat.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tickFormat)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-scale/node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");



function tickFormat(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__["default"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__["default"])(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__["default"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__["default"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we dont ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/create.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/create.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/select.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return (0,_select_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_creator_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name).call(document.documentElement));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([(0,_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(selector)], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isnt worried about live collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// dont; wed rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(arc);

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle. If this
        // intersection fails, its probably because the arc is too small, so
        // disable the corner radius entirely.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
                lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
            rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(area);

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bump.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bump.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bumpRadial: () => (/* binding */ bumpRadial),
/* harmony export */   bumpX: () => (/* binding */ bumpX),
/* harmony export */   bumpY: () => (/* binding */ bumpY)
/* harmony export */ });
/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");


class Bump {
  constructor(context, x) {
    this._context = context;
    this._x = x;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x, y);
        else this._context.moveTo(x, y);
        break;
      }
      case 1: this._point = 2; // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
        break;
      }
    }
    this._x0 = x, this._y0 = y;
  }
}

class BumpRadial {
  constructor(context) {
    this._context = context;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {}
  point(x, y) {
    x = +x, y = +y;
    if (this._point === 0) {
      this._point = 1;
    } else {
      const p0 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0);
      const p1 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0 = (this._y0 + y) / 2);
      const p2 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, this._y0);
      const p3 = (0,_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, y);
      this._context.moveTo(...p0);
      this._context.bezierCurveTo(...p1, ...p2, ...p3);
    }
    this._x0 = x, this._y0 = y;
  }
}

function bumpX(context) {
  return new Bump(context, true);
}

function bumpY(context) {
  return new Bump(context, false);
}

function bumpRadial(context) {
  return new BumpRadial(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/identity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  return d;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(line);

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/link.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   link: () => (/* binding */ link),
/* harmony export */   linkHorizontal: () => (/* binding */ linkHorizontal),
/* harmony export */   linkRadial: () => (/* binding */ linkRadial),
/* harmony export */   linkVertical: () => (/* binding */ linkVertical)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_bump_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curve/bump.js */ "./node_modules/d3-shape/src/curve/bump.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  let source = linkSource,
      target = linkTarget,
      x = _point_js__WEBPACK_IMPORTED_MODULE_0__.x,
      y = _point_js__WEBPACK_IMPORTED_MODULE_0__.y,
      context = null,
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.withPath)(link);

  function link() {
    let buffer;
    const argv = _array_js__WEBPACK_IMPORTED_MODULE_2__.slice.call(arguments);
    const s = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null) output = curve(buffer = path());
    output.lineStart();
    argv[0] = s, output.point(+x.apply(this, argv), +y.apply(this, argv));
    argv[0] = t, output.point(+x.apply(this, argv), +y.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
  };

  return link;
}

function linkHorizontal() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpX);
}

function linkVertical() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpY);
}

function linkRadial() {
  const l = link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_4__.bumpRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/path.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   withPath: () => (/* binding */ withPath)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");


function withPath(shape) {
  let digits = 3;

  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };

  return () => new d3_path__WEBPACK_IMPORTED_MODULE_0__.Path(digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pie.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/pie.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var value = _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      sortValues = _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0),
      endAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau),
      padAngle = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(0);

  function pie(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, Math.max(-_math_js__WEBPACK_IMPORTED_MODULE_3__.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), pie) : padAngle;
  };

  return pie;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pointRadial.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/pointRadial.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-shape/src/symbol.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Symbol),
/* harmony export */   symbolsFill: () => (/* binding */ symbolsFill),
/* harmony export */   symbolsStroke: () => (/* binding */ symbolsStroke)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/asterisk.js */ "./node_modules/d3-shape/src/symbol/asterisk.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/diamond2.js */ "./node_modules/d3-shape/src/symbol/diamond2.js");
/* harmony import */ var _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbol/plus.js */ "./node_modules/d3-shape/src/symbol/plus.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/square2.js */ "./node_modules/d3-shape/src/symbol/square2.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/triangle2.js */ "./node_modules/d3-shape/src/symbol/triangle2.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol/times.js */ "./node_modules/d3-shape/src/symbol/times.js");
















// These symbols are designed to be filled.
const symbolsFill = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__["default"]
];

// These symbols are designed to be stroked (with a width of 1.5px and round caps).
const symbolsStroke = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  _symbol_times_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  _symbol_square2_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_12__["default"]
];

function Symbol(type, size) {
  let context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_13__.withPath)(symbol);

  type = typeof type === "function" ? type : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  size = typeof size === "function" ? size : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(size === undefined ? 64 : +size);

  function symbol() {
    let buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_14__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/asterisk.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/asterisk.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u = t * sqrt3;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u, -t);
    context.lineTo(u, t);
    context.moveTo(-u, t);
    context.lineTo(u, -t);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/circle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/cross.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/cross.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const tan30 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(1 / 3);
const tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / tan30_2);
    const x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond2.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond2.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/plus.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/plus.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const w = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size);
    const x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square2.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square2.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/star.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/star.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const ka = 0.89081309152928522810;
const kr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10);
const kx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;
const ky = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size * ka);
    const x = kx * r;
    const y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (let i = 1; i < 5; ++i) {
      const a = _math_js__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5;
      const c = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a);
      const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/times.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/times.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const y = -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle2.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle2.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size) * 0.6824;
    const t = s  / 2;
    const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
    context.moveTo(0, -s);
    context.lineTo(u, t);
    context.lineTo(-u, t);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/wye.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/wye.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const c = -0.5;
const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3) / 2;
const k = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(12);
const a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw(context, size) {
    const r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(size / a);
    const x0 = r / 2, y0 = r * k;
    const x1 = x0, y1 = r * k + r;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./node_modules/internmap/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/internmap/src/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternMap: () => (/* binding */ InternMap),
/* harmony export */   InternSet: () => (/* binding */ InternSet)
/* harmony export */ });
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (entries != null) for (const [key, value] of entries) this.set(key, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}

class InternSet extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (values != null) for (const value of values) this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
}

function intern_get({_intern, _key}, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}

function intern_delete({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}

function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}


/***/ }),

/***/ "./node_modules/jsonstat-toolkit/import.mjs":
/*!**************************************************!*\
  !*** ./node_modules/jsonstat-toolkit/import.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// jsonstat-toolkit v1.3.1 Copyright 2021 Xavier Badosa https://jsonstat.com
function t(e){var n,i,r,l,s=function(t,e){var n,i=[];if("string"==typeof t&&(t=[t]),Array.isArray(t)){if(t.length===e)return t;if(1===t.length){for(n=0;n<e;n++)i.push(t[0]);return i}}for(n=0;n<e;n++){var r=void 0===t[n]?null:t[n];i.push(r)}return i};if(this.length=0,this.id=[],null!=e)switch(this.class=e.class||"bundle",this.class){case"bundle":var a=[],o=0;if(this.error=null,this.length=0,null===e||"object"!=typeof e)return void(this.class=null);if(e.hasOwnProperty("error"))return void(this.error=e.error);if("dataset"===e.class||"collection"===e.class||"dimension"===e.class)return new t(e);for(i in e)o++,a.push(i);this.__tree__=e,this.length=o,this.id=a;break;case"dataset":e.hasOwnProperty("__tree__")?this.__tree__=n=e.__tree__:this.__tree__=n=e,this.label=n.label||null,this.note=n.note||null,this.link=n.link||null,this.href=n.href||null,this.updated=n.updated||null,this.source=n.source||null,this.extension=n.extension||null;var u,h=0,f=n.size||n.dimension&&n.dimension.size;if(this.size=f,this.value=n.hasOwnProperty("value")&&null!==n.value&&0!==n.value.length?n.value:{},Array.isArray(this.value))h=this.value.length;else{var c=1;for(u=f.length;u--;)c*=f[u];h=c}if(this.value=s(this.value,h),this.status=n.hasOwnProperty("status")?s(n.status,h):null,n.hasOwnProperty("dimension")){var d=n.dimension,v=n.role||!n.version&&d.role||null,p=n.id||d.id,y=f.length,g=function(t){v.hasOwnProperty(t)||(v[t]=null)};if(!Array.isArray(p)||!Array.isArray(f)||p.length!=y)return;if(this.length=y,this.id=p,v&&(g("time"),g("geo"),g("metric"),g("classification")),v&&null===v.classification){var b=[],_=["time","geo","metric"],m=function(t,e){for(var n=e.length;n--;)if(t===e[n])return!0;return!1};for(u=0;u<3;u++){var x=v[_[u]];null!==x&&(b=b.concat(x))}for(v.classification=[],u=0;u<y;u++)m(p[u],b)||v.classification.push(p[u]);0===v.classification.length&&(v.classification=null)}this.role=v,this.n=h;for(var w=0,O=this.length;w<O;w++)if(d[p[w]].category.hasOwnProperty("index")){if(Array.isArray(d[p[w]].category.index)){var A={},k=d[p[w]].category.index;for(r=k.length,l=0;l<r;l++)A[k[l]]=l;d[p[w]].category.index=A}}else{var D=0;for(i in d[p[w]].category.index={},d[p[w]].category.label)d[p[w]].category.index[i]=D++}}else this.length=0;break;case"dimension":if(!e.hasOwnProperty("__tree__"))return new t({version:"2.0",class:"dataset",dimension:{d:e},id:["d"],size:[function(t){var e=void 0===t.index?t.label:t.index;return Array.isArray(e)?e.length:Object.keys(e).length}(e.category)],value:[null]}).Dimension(0);var j=[],P=(n=e.__tree__).category;if(!n.hasOwnProperty("category"))return;if(!P.hasOwnProperty("label"))for(i in P.label={},P.index)P.label[i]=i;for(i in P.index)j[P.index[i]]=i;this.__tree__=n,this.label=n.label||null,this.note=n.note||null,this.link=n.link||null,this.href=n.href||null,this.id=j,this.length=j.length,this.role=e.role,this.hierarchy=P.hasOwnProperty("child"),this.extension=n.extension||null;break;case"category":var E=e.child;this.id=E,this.length=null===E?0:E.length,this.index=e.index,this.label=e.label,this.note=e.note||null,this.unit=e.unit,this.coordinates=e.coord;break;case"collection":if(this.length=0,this.label=e.label||null,this.note=e.note||null,this.link=e.link||null,this.href=e.href||null,this.updated=e.updated||null,this.source=e.source||null,this.extension=e.extension||null,null!==this.link&&e.link.item){var z=e.link.item;if(this.length=Array.isArray(z)?z.length:0,this.length)for(l=0;l<this.length;l++)this.id[l]=z[l].href}}}function e(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.json()}t.prototype.Item=function(t){if(null===this||"collection"!==this.class||!this.length)return null;if("number"==typeof t)return t>this.length||t<0?null:this.link.item[t];var e,n=[];if("object"==typeof t){if(!t.class&&!t.follow)return null;t.class&&(e="dataset"===t.class&&"boolean"==typeof t.embedded?!0===t.embedded?function(t,e,i){var r=t.link.item[e];i.class===r.class&&r.id&&r.size&&r.dimension&&n.push(r)}:function(t,e,i){var r=t.link.item[e];i.class!==r.class||r.id&&r.size&&r.dimension||n.push(r)}:function(t,e,i){i.class===t.link.item[e].class&&n.push(t.link.item[e])})}else e=function(t,e){n.push(t.link.item[e])};for(var i=0;i<this.length;i++)e(this,i,t);return n},t.prototype.Dataset=function(e){if(null===this)return null;if("dataset"===this.class)return void 0!==e?this:[this];var n,i=[],r=0;if("collection"===this.class){var l=this.Item({class:"dataset",embedded:!0});if(void 0===e){for(n=l.length;r<n;r++)i.push(new t(l[r]));return i}if("number"==typeof e&&e>=0&&e<l.length)return new t(l[e]);if("string"==typeof e)for(n=l.length;r<n;r++)if(l[r].href===e)return new t(l[r]);return null}if("bundle"!==this.class)return null;if(void 0===e){for(n=this.id.length;r<n;r++)i.push(this.Dataset(this.id[r]));return i}if("number"==typeof e){var s=this.id[e];return void 0!==s?this.Dataset(s):null}var a=this.__tree__[e];return void 0===a?null:new t({class:"dataset",__tree__:a})},t.prototype.Dimension=function(e,n){n="boolean"!=typeof n||n;var i,r=[],l=this.id.length,s=function(t,e){if(null!==t)for(var n in t)for(var i=null!==t[n]?t[n].length:0;i--;)if(t[n][i]===e)return n;return null};if(null===this||"dataset"!==this.class)return null;if(void 0===e){for(i=0;i<l;i++)r.push(this.Dimension(this.id[i]));return r}if("number"==typeof e){var a=this.id[e];return void 0!==a?this.Dimension(a,n):null}var o=this.role;if("object"==typeof e){if(e.hasOwnProperty("role")){for(i=0;i<l;i++){var u=this.id[i];s(o,u)===e.role&&r.push(this.Dimension(u,n))}return void 0===r[0]?null:r}return null}var h=this.__tree__.dimension;if(void 0===h)return null;var f=h[e];return void 0===f?null:n?new t({class:"dimension",__tree__:f,role:s(o,e)}):function(t,e){var n=[];for(var i in t)n[t[i]]=e[i];return n}(f.category.index,f.category.label)},t.prototype.Category=function(e){if(null===this||"dimension"!==this.class)return null;if(void 0===e){for(var n=[],i=0,r=this.id.length;i<r;i++)n.push(this.Category(this.id[i]));return n}if("number"==typeof e){var l=this.id[e];return void 0!==l?this.Category(l):null}var s=this.__tree__.category;if(void 0===s)return null;var a=s.index[e];if(void 0===a)return null;var o=s.unit&&s.unit[e]||null,u=s.coordinates&&s.coordinates[e]||null,h=s.child&&s.child[e]||null,f=s.note&&s.note[e]||null;return new t({class:"category",index:a,label:s.label[e],note:f,child:h,unit:o,coord:u})},t.prototype.Dice=function(e,n,i){var r,l,s,a,o=function(t,e){return t.hasOwnProperty(e)&&!!t[e]};if(null===this||"dataset"!==this.class)return null;if("object"!=typeof e)return this;"object"!=typeof n?("boolean"==typeof n&&!0===n&&(r=!0),"boolean"==typeof i&&!0===i||(i=!1)):(r=o(n,"clone"),i=o(n,"drop"),l=o(n,"stringify"),s=o(n,"ovalue"),a=o(n,"ostatus"));var u,h=r?new t(JSON.parse(JSON.stringify(this))):this,f=h.status,c=[],d=[],v=function(t,e){var n,i,r,l=(n=t,i=e,r={},"[object Array]"===Object.prototype.toString.call(n[i])?(n[i].forEach((function(t,e){null!==t&&(r[String(e)]=t)})),r):n[i]);delete t[e],t[e]=l};Array.isArray(e)&&(e=function(t){var e={};return t.forEach((function(t){e[t[0]]=t[1]})),e}(e)),null===e&&(e={});var p=Object.keys(e);return p.length>0&&(p.forEach((function(t){var n=e[t];Array.isArray(n)||(e[t]=[n]),0===e[t].length&&delete e[t]})),i&&(e=function(t){var e={};return Object.keys(t).forEach(n=>e[n]=h.Dimension(n).id.filter(e=>-1===t[n].indexOf(e))),e}(e)),h.toTable({type:"arrobj",content:"id",status:!0}).forEach((function(t,n){var i=[];p.forEach((function(n){var r=e[n],l=[];r.forEach((function(e){l.push(t[n]===e)})),i.push(-1!==l.indexOf(!0))})),-1===i.indexOf(!1)&&(c.push(t.value),d.push(t.status))})),p.forEach((function(t){var n=h.Dimension(t).id,i=0,r={};h.size[h.id.indexOf(t)]=e[t].length,n.forEach((function(n){-1!==e[t].indexOf(n)&&(r[n]=i,i++)})),h.__tree__.dimension[t].category.index=r})),h.n=c.length,h.value=h.__tree__.value=c,h.status=h.__tree__.status=null!==f?d:null),l?((u=h.__tree__).hasOwnProperty("id")||(u.version="2.0",u.hasOwnProperty("class")||(u.class="dataset"),u.id=u.dimension.id,u.size=u.dimension.size,delete u.dimension.id,delete u.dimension.size,u.dimension.hasOwnProperty("role")&&(u.role=u.dimension.role,delete u.dimension.role)),u.hasOwnProperty("status")&&-1!==["null","{}","[]"].indexOf(JSON.stringify(u.status))&&delete u.status,u.hasOwnProperty("role")&&(delete u.role.classification,["geo","time","metric"].forEach((function(t){null===u.role[t]&&delete u.role[t]}))),s&&v(u,"value"),a&&u.hasOwnProperty("status")&&v(u,"status"),JSON.stringify(u)):h},t.prototype.Slice=function(t){if(null===this||"dataset"!==this.class)return null;if(void 0===t)return this;if(!Array.isArray(t)){var e,n=[];for(e in t)n.push([e,t[e]]);t=n}return this.Dice(t.map((function(t){return[t[0],[t[1]]]})))},t.prototype.Data=function(t,e){var n,i,r=[],l=function(t){for(var e in t)if(t.hasOwnProperty(e))return e};if(null===this||"dataset"!==this.class)return null;if(void 0===t){for(i=this.value.length,n=0;n<i;n++)r.push(this.Data(n));return r}if("boolean"!=typeof e&&(e=!0),"number"==typeof t){var s=this.value[t];return void 0===s?null:e?{value:s,status:this.status?this.status[t]:null}:s}var a="object",o=this.__tree__,u=o.size||o.dimension&&o.dimension.size,h=u.length;if(Array.isArray(t)){if(!Array.isArray(t[0])){if(this.length!==t.length)return null;var f=1,c=0,d=[],v=[];for(n=0;n<h;n++)if(void 0!==t[n]){if("number"!=typeof t[n]||t[n]>=u[n])return null;c+=(f*=n>0?u[h-n]:1)*t[h-n-1]}else d.push(n),v.push(u[n]);if(d.length>1)return null;if(1===d.length){for(var p=0,y=v[0];p<y;p++){var g=[];for(n=0;n<h;n++)n!==d[0]?g.push(t[n]):g.push(p);r.push(this.Data(g,e))}return r}return e?{value:this.value[c],status:this.status?this.status[c]:null}:this.value[c]}a="array"}var b=function(t,e,n){var i,r=[],s={},a=t.dimension,o=t.id||a.id,u=t.size||a&&a.size;if("array"===n){for(i=e.length;i--;)s[e[i][0]]=e[i][1];e=s}for(var h=0,f=o.length;h<f;h++){var c=o[h],d=e[c];r.push("string"==typeof d?d:1===u[h]?l(a[c].category.index):null)}return r}(o,t,a),_=[],m=o.dimension,x=o.id||m.id;for(n=0,i=b.length;n<i;n++)_.push(m[x[n]].category.index[b[n]]);return this.Data(_,e)},t.prototype.toTable=function(t,e){if(null===this||"dataset"!==this.class)return null;1==arguments.length&&"function"==typeof t&&(e=t,t=null),"arrobj"===(t=t||{field:"label",content:"label",vlabel:"Value",slabel:"Status",type:"array",status:!1,unit:!1,by:null,prefix:"",drop:[],meta:!1,comma:!1,bylabel:!1}).type&&void 0===t.field&&(t.field="id");var n,i,r,l,s,a=this.__tree__,o=!0===t.status;if("function"==typeof e){n=this.toTable(t);var u=[],h="array"!==t.type?0:1;for(s=(S="object"!==t.type?n.slice(h):n.rows.slice(0)).length,i=0;i<s;i++){var f=e.call(this,S[i],i);void 0!==f&&u.push(f)}return"object"===t.type?{cols:n.cols,rows:u}:("array"===t.type&&u.unshift(n[0]),u)}if("arrobj"===t.type){var c=[],d=a.role&&a.role.metric,v=function(){},p={},y=this,g=y.id,b=t.by&&-1!==g.indexOf(t.by)?t.by:null,_=!0===t.meta,m=void 0!==t.drop&&Array.isArray(t.drop)?t.drop:[],x=!0===t.comma,w=!0===t.bylabel,O=function(e){if(_){var n={};return g.forEach((function(t){var e=y.Dimension(t);n[t]={label:e.label,role:e.role,categories:{id:e.id,label:y.Dimension(t,!1)}}})),{meta:{label:y.label,source:y.source,updated:y.updated,id:g,status:o,unit:t.unit,by:b,bylabel:w,drop:null!==b&&m.length>0?m:null,prefix:null!==b?T||"":null,comma:x,dimensions:n},data:e}}return e};b&&(t.field="id");var A=(n=this.toTable({field:t.field,vlabel:t.vlabel,slabel:t.slabel,content:t.content,status:o})).shift();if(null===b&&t.unit&&d){if("id"!==t.content)for(var k=d.length;k--;){var D=this.Dimension(d[k]);p[d[k]]={};for(var j=D.length;j--;)p[d[k]][D.Category(j).label]=D.id[j]}v=function(e,n){if(-1!==d.indexOf(e)){var i=a.dimension[e].category;i.unit?P.unit=i.unit["id"!==t.content?p[e][n]:n]:P.unit=null}},t.unit=!0}else t.unit=!1;for(s=n.length,i=0;i<s;i++){var P={};for(r=n[i].length;r--;)P[A[r]]=n[i][r],v(A[r],n[i][r]);c.push(P)}if(x&&c.forEach((function(t){null!==t.value&&(t.value=(""+t.value).replace(".",","))})),null!==b){var E,z={},S=[],C={},T=void 0!==t.prefix?t.prefix:"";m.forEach((function(t,e){(!y.Dimension(t)||y.Dimension(t).length>1)&&(m[e]="")}));var J=g.filter((function(t){return t!==b&&-1===m.indexOf(t)})),N=y.Dimension(b),V=function(t,e){var n=[];return e.forEach((function(e){n.push(t[e])})),n.join("\t")},I=function(t,e){var n={};return e.forEach((function(e){n[e]=t[e]})),n};for(var q in"id"!==t.content?w?E=function(t,e,n){t[e][T+n[b]]=n.value}:(N.Category().forEach((function(t,e){C[t.label]=N.id[e]})),E=function(t,e,n){t[e][T+C[n[b]]]=n.value}):E=function(t,e,n){t[e][T+n[b]]=n.value},c.forEach((function(t){var e=V(t,J);void 0===z[e]&&(z[e]=I(t,J)),E(z,e,t,b)})),z)S.push(z[q]);return o=!1,O(S)}return O(c)}var B,F,G,H,K="id"===t.field;if("object"===t.type){var L="number"==typeof this.value[0]||null===this.value[0]?"number":"string";B=function(t,e){var n=K&&t||e||t;et.push({id:t,label:n,type:"string"})},F=function(t,e,n){var i=(K?"value":t)||"Value",r=(K?"status":e)||"Status";n&&et.push({id:"status",label:r,type:"string"}),et.push({id:"value",label:i,type:L})},G=function(t){vt.push({v:t})},H=function(t){vt.push({v:t}),nt.push({c:vt})}}else B=function(t,e){var n=K&&t||e||t;et.push(n)},F=function(t,e,n){var i=(K?"value":t)||"Value",r=(K?"status":e)||"Status";n&&et.push(r),et.push(i),tt.push(et)},G=function(t){vt.push(t)},H=function(t){vt.push(t),tt.push(vt)};var M=a.dimension,Q=a.id||M.id,R=a.size||M.size,U=Q.length;if(U!=R.length)return!1;var W=[],X=1,Y=(k=1,[]),Z=[],$=[],tt=[],et=[],nt=[];for(i=0;i<U;i++){var it=Q[i],rt=M[it].label;B(it,rt),X*=R[i],k*=R[i];var lt=[];for(r=0;r<R[i];r++)for(var st in M[Q[i]].category.index)if(M[Q[i]].category.index[st]===r){var at="id"!==t.content&&M[Q[i]].category.label?M[Q[i]].category.label[st]:st;lt.push(at)}W.push(lt),Y.push(k)}for(F(t.vlabel,t.slabel,o),s=W.length,i=0;i<s;i++){for(var ot=[],ut=0,ht=W[i].length;ut<ht;ut++)for(var ft=0;ft<X/Y[i];ft++)ot.push(W[i][ut]);Z.push(ot)}for(s=Z.length,i=0;i<s;i++){var ct=[],dt=0;for(l=0;l<X;l++)ct.push(Z[i][dt]),++dt===Z[i].length&&(dt=0);$.push(ct)}for(l=0;l<X;l++){var vt=[];s=Z.length;for(var pt=0;pt<s;pt++)G($[pt][l]);o&&G(this.status?this.status[l]:null),H(this.value[l])}return"object"===t.type?{cols:et,rows:nt}:tt},t.prototype.node=function(){return this.__tree__},t.prototype.toString=function(){return this.class};/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n,i){return"object"==typeof n?new t(n):"version"===n?"1.3.1":fetch?fetch(n,i).then(e).then((function(e){return new t(e)})):void 0}


/***/ }),

/***/ "./node_modules/simple-statistics/dist/simple-statistics.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/simple-statistics/dist/simple-statistics.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BayesianClassifier: () => (/* binding */ BayesianClassifier),
/* harmony export */   PerceptronModel: () => (/* binding */ PerceptronModel),
/* harmony export */   addToMean: () => (/* binding */ addToMean),
/* harmony export */   approxEqual: () => (/* binding */ approxEqual),
/* harmony export */   average: () => (/* binding */ mean),
/* harmony export */   averageSimple: () => (/* binding */ meanSimple),
/* harmony export */   bayesian: () => (/* binding */ BayesianClassifier),
/* harmony export */   bernoulliDistribution: () => (/* binding */ bernoulliDistribution),
/* harmony export */   binomialDistribution: () => (/* binding */ binomialDistribution),
/* harmony export */   bisect: () => (/* binding */ bisect),
/* harmony export */   chiSquaredDistributionTable: () => (/* binding */ chiSquaredDistributionTable),
/* harmony export */   chiSquaredGoodnessOfFit: () => (/* binding */ chiSquaredGoodnessOfFit),
/* harmony export */   chunk: () => (/* binding */ chunk),
/* harmony export */   ckmeans: () => (/* binding */ ckmeans),
/* harmony export */   coefficientOfVariation: () => (/* binding */ coefficientOfVariation),
/* harmony export */   combinations: () => (/* binding */ combinations),
/* harmony export */   combinationsReplacement: () => (/* binding */ combinationsReplacement),
/* harmony export */   combineMeans: () => (/* binding */ combineMeans),
/* harmony export */   combineVariances: () => (/* binding */ combineVariances),
/* harmony export */   cumulativeStdLogisticProbability: () => (/* binding */ cumulativeStdLogisticProbability),
/* harmony export */   cumulativeStdNormalProbability: () => (/* binding */ cumulativeStdNormalProbability),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   equalIntervalBreaks: () => (/* binding */ equalIntervalBreaks),
/* harmony export */   erf: () => (/* binding */ errorFunction),
/* harmony export */   errorFunction: () => (/* binding */ errorFunction),
/* harmony export */   extent: () => (/* binding */ extent),
/* harmony export */   extentSorted: () => (/* binding */ extentSorted),
/* harmony export */   factorial: () => (/* binding */ factorial),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   gammaln: () => (/* binding */ gammaln),
/* harmony export */   geometricMean: () => (/* binding */ geometricMean),
/* harmony export */   harmonicMean: () => (/* binding */ harmonicMean),
/* harmony export */   interquartileRange: () => (/* binding */ interquartileRange),
/* harmony export */   inverseErrorFunction: () => (/* binding */ inverseErrorFunction),
/* harmony export */   iqr: () => (/* binding */ interquartileRange),
/* harmony export */   jenks: () => (/* binding */ jenks),
/* harmony export */   kMeansCluster: () => (/* binding */ kMeansCluster),
/* harmony export */   kde: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   kernelDensityEstimation: () => (/* binding */ kernelDensityEstimation),
/* harmony export */   linearRegression: () => (/* binding */ linearRegression),
/* harmony export */   linearRegressionLine: () => (/* binding */ linearRegressionLine),
/* harmony export */   logAverage: () => (/* binding */ logAverage),
/* harmony export */   logit: () => (/* binding */ logit),
/* harmony export */   mad: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   maxSorted: () => (/* binding */ maxSorted),
/* harmony export */   mean: () => (/* binding */ mean),
/* harmony export */   meanSimple: () => (/* binding */ meanSimple),
/* harmony export */   median: () => (/* binding */ median),
/* harmony export */   medianAbsoluteDeviation: () => (/* binding */ medianAbsoluteDeviation),
/* harmony export */   medianSorted: () => (/* binding */ medianSorted),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   minSorted: () => (/* binding */ minSorted),
/* harmony export */   mode: () => (/* binding */ mode),
/* harmony export */   modeFast: () => (/* binding */ modeFast),
/* harmony export */   modeSorted: () => (/* binding */ modeSorted),
/* harmony export */   numericSort: () => (/* binding */ numericSort),
/* harmony export */   perceptron: () => (/* binding */ PerceptronModel),
/* harmony export */   permutationTest: () => (/* binding */ permutationTest),
/* harmony export */   permutationsHeap: () => (/* binding */ permutationsHeap),
/* harmony export */   poissonDistribution: () => (/* binding */ poissonDistribution),
/* harmony export */   probit: () => (/* binding */ probit),
/* harmony export */   product: () => (/* binding */ product),
/* harmony export */   quantile: () => (/* binding */ quantile),
/* harmony export */   quantileRank: () => (/* binding */ quantileRank),
/* harmony export */   quantileRankSorted: () => (/* binding */ quantileRankSorted),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted),
/* harmony export */   quickselect: () => (/* binding */ quickselect),
/* harmony export */   rSquared: () => (/* binding */ rSquared),
/* harmony export */   relativeError: () => (/* binding */ relativeError),
/* harmony export */   rms: () => (/* binding */ rootMeanSquare),
/* harmony export */   rootMeanSquare: () => (/* binding */ rootMeanSquare),
/* harmony export */   sample: () => (/* binding */ sample),
/* harmony export */   sampleCorrelation: () => (/* binding */ sampleCorrelation),
/* harmony export */   sampleCovariance: () => (/* binding */ sampleCovariance),
/* harmony export */   sampleKurtosis: () => (/* binding */ sampleKurtosis),
/* harmony export */   sampleRankCorrelation: () => (/* binding */ sampleRankCorrelation),
/* harmony export */   sampleSkewness: () => (/* binding */ sampleSkewness),
/* harmony export */   sampleStandardDeviation: () => (/* binding */ sampleStandardDeviation),
/* harmony export */   sampleVariance: () => (/* binding */ sampleVariance),
/* harmony export */   sampleWithReplacement: () => (/* binding */ sampleWithReplacement),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   shuffleInPlace: () => (/* binding */ shuffleInPlace),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   silhouette: () => (/* binding */ silhouette),
/* harmony export */   silhouetteMetric: () => (/* binding */ silhouetteMetric),
/* harmony export */   standardDeviation: () => (/* binding */ standardDeviation),
/* harmony export */   standardNormalTable: () => (/* binding */ standardNormalTable),
/* harmony export */   subtractFromMean: () => (/* binding */ subtractFromMean),
/* harmony export */   sum: () => (/* binding */ sum),
/* harmony export */   sumNthPowerDeviations: () => (/* binding */ sumNthPowerDeviations),
/* harmony export */   sumSimple: () => (/* binding */ sumSimple),
/* harmony export */   tTest: () => (/* binding */ tTest),
/* harmony export */   tTestTwoSample: () => (/* binding */ tTestTwoSample),
/* harmony export */   uniqueCountSorted: () => (/* binding */ uniqueCountSorted),
/* harmony export */   variance: () => (/* binding */ variance),
/* harmony export */   wilcoxonRankSum: () => (/* binding */ wilcoxonRankSum),
/* harmony export */   zScore: () => (/* binding */ zScore)
/* harmony export */ });
/**
 * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
 * is a simple way to find a fitted line
 * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
 * using the least sum of squares.
 *
 * @param {Array<Array<number>>} data an array of two-element of arrays,
 * like `[[0, 1], [2, 3]]`
 * @returns {Object} object containing slope and intersect of regression line
 * @example
 * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
 */
function linearRegression(data) {
    var m;
    var b;

    // Store data length in a local variable to reduce
    // repeated object property lookups
    var dataLength = data.length;

    //if there's only one point, arbitrarily choose a slope of 0
    //and a y-intercept of whatever the y of the initial point is
    if (dataLength === 1) {
        m = 0;
        b = data[0][1];
    } else {
        // Initialize our sums and scope the `m` and `b`
        // variables that define the line.
        var sumX = 0;
        var sumY = 0;
        var sumXX = 0;
        var sumXY = 0;

        // Use local variables to grab point values
        // with minimal object property lookups
        var point;
        var x;
        var y;

        // Gather the sum of all x values, the sum of all
        // y values, and the sum of x^2 and (x*y) for each
        // value.
        //
        // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
        for (var i = 0; i < dataLength; i++) {
            point = data[i];
            x = point[0];
            y = point[1];

            sumX += x;
            sumY += y;

            sumXX += x * x;
            sumXY += x * y;
        }

        // `m` is the slope of the regression line
        m =
            (dataLength * sumXY - sumX * sumY) /
            (dataLength * sumXX - sumX * sumX);

        // `b` is the y-intercept of the line.
        b = sumY / dataLength - (m * sumX) / dataLength;
    }

    // Return both values as an object.
    return {
        m: m,
        b: b
    };
}

/**
 * Given the output of `linearRegression`: an object
 * with `m` and `b` values indicating slope and intercept,
 * respectively, generate a line function that translates
 * x values into y values.
 *
 * @param {Object} mb object with `m` and `b` members, representing
 * slope and intersect of desired line
 * @returns {Function} method that computes y-value at any given
 * x-value on the line.
 * @example
 * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
 * l(0) // = 0
 * l(2) // = 2
 * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
 * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
 */
function linearRegressionLine(mb /*: { b: number, m: number }*/) {
    // Return a function that computes a `y` value for each
    // x value it is given, based on the values of `b` and `a`
    // that we just computed.
    return function (x) {
        return mb.b + mb.m * x;
    };
}

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sum(x) {
    // If the array is empty, we needn't bother computing its sum
    if (x.length === 0) {
        return 0;
    }

    // Initializing the sum as the first number in the array
    var sum = x[0];

    // Keeping track of the floating-point error correction
    var correction = 0;

    var transition;

    if (typeof sum !== "number") {
        return Number.NaN;
    }

    for (var i = 1; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        transition = sum + x[i];

        // Here we need to update the correction in a different fashion
        // if the new absolute value is greater than the absolute sum
        if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i];
        } else {
            correction += x[i] - transition + sum;
        }

        sum = transition;
    }

    // Returning the corrected sum
    return sum + correction;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function mean(x) {
    if (x.length === 0) {
        throw new Error("mean requires at least one data point");
    }

    return sum(x) / x.length;
}

/**
 * The sum of deviations to the Nth power.
 * When n=2 it's the sum of squared deviations.
 * When n=3 it's the sum of cubed deviations.
 *
 * @param {Array<number>} x
 * @param {number} n power
 * @returns {number} sum of nth power deviations
 *
 * @example
 * var input = [1, 2, 3];
 * // since the variance of a set is the mean squared
 * // deviations, we can calculate that with sumNthPowerDeviations:
 * sumNthPowerDeviations(input, 2) / input.length;
 */
function sumNthPowerDeviations(x, n) {
    var meanValue = mean(x);
    var sum = 0;
    var tempValue;
    var i;

    // This is an optimization: when n is 2 (we're computing a number squared),
    // multiplying the number by itself is significantly faster than using
    // the Math.pow method.
    if (n === 2) {
        for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue;
            sum += tempValue * tempValue;
        }
    } else {
        for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n);
        }
    }

    return sum;
}

/**
 * The [variance](http://en.wikipedia.org/wiki/Variance)
 * is the sum of squared deviations from the mean.
 *
 * This is an implementation of variance, not sample variance:
 * see the `sampleVariance` method if you want a sample measure.
 *
 * @param {Array<number>} x a population of one or more data points
 * @returns {number} variance: a value greater than or equal to zero.
 * zero indicates that all values are identical.
 * @throws {Error} if x's length is 0
 * @example
 * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
 */
function variance(x) {
    if (x.length === 0) {
        throw new Error("variance requires at least one data point");
    }

    // Find the mean of squared deviations between the
    // mean value and each value.
    return sumNthPowerDeviations(x, 2) / x.length;
}

/**
 * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
 * is the square root of the variance. This is also known as the population
 * standard deviation. It's useful for measuring the amount
 * of variation or dispersion in a set of values.
 *
 * Standard deviation is only appropriate for full-population knowledge: for
 * samples of a population, {@link sampleStandardDeviation} is
 * more appropriate.
 *
 * @param {Array<number>} x input
 * @returns {number} standard deviation
 * @example
 * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
 * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
 */
function standardDeviation(x) {
    if (x.length === 1) {
        return 0;
    }
    var v = variance(x);
    return Math.sqrt(v);
}

/**
 * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
 * value of data compared with a function `f`
 * is the sum of the squared differences between the prediction
 * and the actual value.
 *
 * @param {Array<Array<number>>} x input data: this should be doubly-nested
 * @param {Function} func function called on `[i][0]` values within the dataset
 * @returns {number} r-squared value
 * @example
 * var samples = [[0, 0], [1, 1]];
 * var regressionLine = linearRegressionLine(linearRegression(samples));
 * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
 */
function rSquared(x, func) {
    if (x.length < 2) {
        return 1;
    }

    // Compute the average y value for the actual
    // data set in order to compute the
    // _total sum of squares_
    var sum = 0;
    for (var i = 0; i < x.length; i++) {
        sum += x[i][1];
    }
    var average = sum / x.length;

    // Compute the total sum of squares - the
    // squared difference between each point
    // and the average of all points.
    var sumOfSquares = 0;
    for (var j = 0; j < x.length; j++) {
        sumOfSquares += Math.pow(average - x[j][1], 2);
    }

    // Finally estimate the error: the squared
    // difference between the estimate and the actual data
    // value at each point.
    var err = 0;
    for (var k = 0; k < x.length; k++) {
        err += Math.pow(x[k][1] - func(x[k][0]), 2);
    }

    // As the error grows larger, its ratio to the
    // sum of squares increases and the r squared
    // value grows lower.
    return 1 - err / sumOfSquares;
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)` because the input is sorted.
 *
 * @param {Array<number>} sorted a sample of one or more data points
 * @returns {number} mode
 * @throws {Error} if sorted is empty
 * @example
 * modeSorted([0, 0, 1]); // => 0
 */
function modeSorted(sorted) {
    // Handle edge cases:
    // The mode of an empty list is undefined
    if (sorted.length === 0) {
        throw new Error("mode requires at least one data point");
    }
    if (sorted.length === 1) {
        return sorted[0];
    }

    // This assumes it is dealing with an array of size > 1, since size
    // 0 and 1 are handled immediately. Hence it starts at index 1 in the
    // array.
    var last = sorted[0];
    // store the mode as we find new modes
    var value = Number.NaN;
    // store how many times we've seen the mode
    var maxSeen = 0;
    // how many times the current candidate for the mode
    // has been seen
    var seenThis = 1;

    // end at sorted.length + 1 to fix the case in which the mode is
    // the highest number that occurs in the sequence. the last iteration
    // compares sorted[i], which is undefined, to the highest number
    // in the series
    for (var i = 1; i < sorted.length + 1; i++) {
        // we're seeing a new number pass by
        if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
                maxSeen = seenThis;
                value = last;
            }
            seenThis = 1;
            last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
        } else {
            seenThis++;
        }
    }
    return value;
}

/**
 * Sort an array of numbers by their numeric value, ensuring that the
 * array is not changed in place.
 *
 * This is necessary because the default behavior of .sort
 * in JavaScript is to sort arrays as string values
 *
 *     [1, 10, 12, 102, 20].sort()
 *     // output
 *     [1, 10, 102, 12, 20]
 *
 * @param {Array<number>} x input array
 * @return {Array<number>} sorted array
 * @private
 * @example
 * numericSort([3, 2, 1]) // => [1, 2, 3]
 */
function numericSort(x) {
    return (
        x
            // ensure the array is not changed in-place
            .slice()
            // comparator function that treats input as numeric
            .sort(function (a, b) {
                return a - b;
            })
    );
}

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n log(n))` because it needs to sort the array internally
 * before running an `O(n)` search to find the mode.
 *
 * @param {Array<number>} x input
 * @returns {number} mode
 * @example
 * mode([0, 0, 1]); // => 0
 */
function mode(x) {
    // Sorting the array lets us iterate through it below and be sure
    // that every time we see a new number it's new and we'll never
    // see the same number twice
    return modeSorted(numericSort(x));
}

/* globals Map: false */

/**
 * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number
 * that appears in a list the highest number of times.
 * There can be multiple modes in a list: in the event of a tie, this
 * algorithm will return the most recently seen mode.
 *
 * modeFast uses a Map object to keep track of the mode, instead of the approach
 * used with `mode`, a sorted array. As a result, it is faster
 * than `mode` and supports any data type that can be compared with `==`.
 * It also requires a
 * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
 * and will throw an error if Map is not available.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * @param {Array<*>} x a sample of one or more data points
 * @returns {?*} mode
 * @throws {ReferenceError} if the JavaScript environment doesn't support Map
 * @throws {Error} if x is empty
 * @example
 * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
 */
function modeFast(x) {
    // This index will reflect the incidence of different values, indexing
    // them like
    // { value: count }
    var index = new Map();

    // A running `mode` and the number of times it has been encountered.
    var mode;
    var modeCount = 0;

    for (var i = 0; i < x.length; i++) {
        var newCount = index.get(x[i]);
        if (newCount === undefined) {
            newCount = 1;
        } else {
            newCount++;
        }
        if (newCount > modeCount) {
            mode = x[i];
            modeCount = newCount;
        }
        index.set(x[i], newCount);
    }

    if (modeCount === 0) {
        throw new Error("mode requires at last one data point");
    }

    return mode;
}

/**
 * The min is the lowest number in the array.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} minimum value
 * @example
 * min([1, 5, -10, 100, 2]); // => -10
 */
function min(x) {
    if (x.length === 0) {
        throw new Error("min requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] < value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * max([1, 2, 3, 4]);
 * // => 4
 */
function max(x) {
    if (x.length === 0) {
        throw new Error("max requires at least one data point");
    }

    var value = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > value) {
            value = x[i];
        }
    }
    return value;
}

/**
 * This computes the minimum & maximum number in an array.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {Array<number>} minimum & maximum value
 * @throws {Error} if the length of x is less than one
 * @example
 * extent([1, 2, 3, 4]);
 * // => [1, 4]
 */
function extent(x) {
    if (x.length === 0) {
        throw new Error("extent requires at least one data point");
    }

    var min = x[0];
    var max = x[0];
    for (var i = 1; i < x.length; i++) {
        if (x[i] > max) {
            max = x[i];
        }
        if (x[i] < min) {
            min = x[i];
        }
    }
    return [min, max];
}

/**
 * The minimum is the lowest number in the array. With a sorted array,
 * the first element in the array is always the smallest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} minimum value
 * @example
 * minSorted([-100, -10, 1, 2, 5]); // => -100
 */
function minSorted(x) {
    return x[0];
}

/**
 * The maximum is the highest number in the array. With a sorted array,
 * the last element in the array is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {number} maximum value
 * @example
 * maxSorted([-100, -10, 1, 2, 5]); // => 5
 */
function maxSorted(x) {
    return x[x.length - 1];
}

/**
 * The extent is the lowest & highest number in the array. With a sorted array,
 * the first element in the array is always the lowest while the last element is always the largest, so this calculation
 * can be done in one step, or constant time.
 *
 * @param {Array<number>} x input
 * @returns {Array<number>} minimum & maximum value
 * @example
 * extentSorted([-100, -10, 1, 2, 5]); // => [-100, 5]
 */
function extentSorted(x) {
    return [x[0], x[x.length - 1]];
}

/**
 * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
 * is the result of adding all numbers together, starting from zero.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sumSimple([1, 2, 3]); // => 6
 */
function sumSimple(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (typeof x[i] !== "number") {
            return Number.NaN;
        }
        value += x[i];
    }
    return value;
}

/**
 * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
 * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x input
 * @return {number} product of all input numbers
 * @example
 * product([1, 2, 3, 4]); // => 24
 */
function product(x) {
    var value = 1;
    for (var i = 0; i < x.length; i++) {
        value *= x[i];
    }
    return value;
}

/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error("quantile requires at least one data point.");
    } else if (p < 0 || p > 1) {
        throw new Error("quantiles must be between 0 and 1");
    } else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    } else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    } else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    } else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}

/**
 * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
 * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;

    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0) { sd *= -1; }
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(
                right,
                Math.floor(k + ((n - m) * s) / n + sd)
            );
            quickselect(arr, k, newLeft, newRight);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (arr[right] > t) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t) { i++; }
            while (arr[j] > t) { j--; }
        }

        if (arr[left] === t) { swap(arr, left, j); }
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * The [quantile](https://en.wikipedia.org/wiki/Quantile):
 * this is a population quantile, since we assume to know the entire
 * dataset in this library. This is an implementation of the
 * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
 * algorithm from wikipedia.
 *
 * Sample is a one-dimensional array of numbers,
 * and p is either a decimal number from 0 to 1 or an array of decimal
 * numbers from 0 to 1.
 * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
 * with decimal values.
 * When p is an array, the result of the function is also an array containing the appropriate
 * quantiles in input order
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1
 * @returns {number} quantile
 * @example
 * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile(x, p) {
    var copy = x.slice();

    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i]);
        }
        return results;
    } else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantileSorted(copy, p);
    }
}

function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    } else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}

function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);

    var stack = [0, indices.length - 1];

    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1) { continue; }

        var m = Math.floor((l + r) / 2);
        quantileSelect(
            arr,
            indices[m],
            Math.floor(indices[l]),
            Math.ceil(indices[r])
        );

        stack.push(l, m, m, r);
    }
}

function compare(a, b) {
    return a - b;
}

function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    } else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    } else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    } else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    } else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

/* eslint no-bitwise: 0 */

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. With a sorted array, leveraging binary search, we can find
 * this information in logarithmic time.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75
 * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7
 * quantileRankSorted([1, 2, 3, 4], 6); // => 1
 * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8
 */
function quantileRankSorted(x, value) {
    // Value is lesser than any value in the array
    if (value < x[0]) {
        return 0;
    }

    // Value is greater than any value in the array
    if (value > x[x.length - 1]) {
        return 1;
    }

    var l = lowerBound(x, value);

    // Value is not in the array
    if (x[l] !== value) {
        return l / x.length;
    }

    l++;

    var u = upperBound(x, value);

    // The value exists only once in the array
    if (u === l) {
        return l / x.length;
    }

    // Here, we are basically computing the mean of the range of indices
    // containing our searched value. But, instead, of initializing an
    // array and looping over it, there is a dedicated math formula that
    // we apply below to get the result.
    var r = u - l + 1;
    var sum = (r * (u + l)) / 2;
    var mean = sum / r;

    return mean / x.length;
}

function lowerBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value <= x[mid]) {
            hi = mid;
        } else {
            lo = -~mid;
        }
    }

    return lo;
}

function upperBound(x, value) {
    var mid = 0;
    var lo = 0;
    var hi = x.length;

    while (lo < hi) {
        mid = (lo + hi) >>> 1;

        if (value >= x[mid]) {
            lo = -~mid;
        } else {
            hi = mid;
        }
    }

    return lo;
}

/**
 * This function returns the quantile in which one would find the given value in
 * the given array. It will copy and sort your array before each run, so
 * if you know your array is already sorted, you should use `quantileRankSorted`
 * instead.
 *
 * @param {Array<number>} x input
 * @returns {number} value value
 * @example
 * quantileRank([4, 3, 1, 2], 3); // => 0.75
 * quantileRank([4, 3, 2, 3, 1], 3); // => 0.7
 * quantileRank([2, 4, 1, 3], 6); // => 1
 * quantileRank([5, 3, 1, 2, 3], 4); // => 0.8
 */
function quantileRank(x, value) {
    // Cloning and sorting the array
    var sortedCopy = numericSort(x);

    return quantileRankSorted(sortedCopy, value);
}

/**
 * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
 * a measure of statistical dispersion, or how scattered, spread, or
 * concentrated a distribution is. It's computed as the difference between
 * the third quartile and first quartile.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @returns {number} interquartile range: the span between lower and upper quartile,
 * 0.25 and 0.75
 * @example
 * interquartileRange([0, 1, 2, 3]); // => 2
 */
function interquartileRange(x) {
    // Interquartile range is the span between the upper quartile,
    // at `0.75`, and lower quartile, `0.25`
    var q1 = quantile(x, 0.75);
    var q2 = quantile(x, 0.25);

    if (typeof q1 === "number" && typeof q2 === "number") {
        return q1 - q2;
    }
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} x input
 * @returns {number} median value
 * @example
 * median([10, 2, 5, 100, 2, 1]); // => 3.5
 */
function median(x) {
    return +quantile(x, 0.5);
}

/**
 * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
 * a robust measure of statistical
 * dispersion. It is more resilient to outliers than the standard deviation.
 *
 * @param {Array<number>} x input array
 * @returns {number} median absolute deviation
 * @example
 * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
 */
function medianAbsoluteDeviation(x) {
    var medianValue = median(x);
    var medianAbsoluteDeviations = [];

    // Make a list of absolute deviations from the median
    for (var i = 0; i < x.length; i++) {
        medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue));
    }

    // Find the median value of that list
    return median(medianAbsoluteDeviations);
}

/**
 * Split an array into chunks of a specified size. This function
 * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
 * function, and thus will insert smaller-sized chunks at the end if
 * the input size is not divisible by the chunk size.
 *
 * `x` is expected to be an array, and `chunkSize` a number.
 * The `x` array can contain any kind of data.
 *
 * @param {Array} x a sample
 * @param {number} chunkSize size of each output array. must be a positive integer
 * @returns {Array<Array>} a chunked array
 * @throws {Error} if chunk size is less than 1 or not an integer
 * @example
 * chunk([1, 2, 3, 4, 5, 6], 2);
 * // => [[1, 2], [3, 4], [5, 6]]
 */
function chunk(x, chunkSize) {
    // a list of result chunks, as arrays in an array
    var output = [];

    // `chunkSize` must be zero or higher - otherwise the loop below,
    // in which we call `start += chunkSize`, will loop infinitely.
    // So, we'll detect and throw in that case to indicate
    // invalid input.
    if (chunkSize < 1) {
        throw new Error("chunk size must be a positive number");
    }

    if (Math.floor(chunkSize) !== chunkSize) {
        throw new Error("chunk size must be an integer");
    }

    // `start` is the index at which `.slice` will start selecting
    // new array elements
    for (var start = 0; start < x.length; start += chunkSize) {
        // for each chunk, slice that part of the array and add it
        // to the output. The `.slice` function does not change
        // the original array.
        output.push(x.slice(start, start + chunkSize));
    }
    return output;
}

/**
 * Sampling with replacement is a type of sampling that allows the same
 * item to be picked out of a population more than once.
 *
 * @param {Array<*>} x an array of any kind of value
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} n sampled items from the population
 * @example
 * var values = [1, 2, 3, 4];
 * sampleWithReplacement(values, 2); // returns 2 random values, like [2, 4];
 */
function sampleWithReplacement(x, n, randomSource) {
    if (x.length === 0) {
        return [];
    }

    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    var length = x.length;
    var sample = [];

    for (var i = 0; i < n; i++) {
        var index = Math.floor(randomSource() * length);

        sample.push(x[index]);
    }

    return sample;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * in-place - which means that it **will change the order of the original
 * array by reference**.
 *
 * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
 * of a set.
 *
 * @param {Array} x sample of one or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @returns {Array} x
 * @example
 * var x = [1, 2, 3, 4];
 * shuffleInPlace(x);
 * // x is shuffled to a value like [2, 1, 4, 3]
 */
function shuffleInPlace(x, randomSource) {
    // a custom random number source can be provided if you want to use
    // a fixed seed or another random number generator, like
    // [random-js](https://www.npmjs.org/package/random-js)
    randomSource = randomSource || Math.random;

    // store the current length of the x to determine
    // when no elements remain to shuffle.
    var length = x.length;

    // temporary is used to hold an item when it is being
    // swapped between indices.
    var temporary;

    // The index to swap at each stage.
    var index;

    // While there are still items to shuffle
    while (length > 0) {
        // choose a random index within the subset of the array
        // that is not yet shuffled
        index = Math.floor(randomSource() * length--);

        // store the value that we'll move temporarily
        temporary = x[length];

        // swap the value at `x[length]` with `x[index]`
        x[length] = x[index];
        x[index] = temporary;
    }

    return x;
}

/**
 * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
 * is a fast way to create a random permutation of a finite set. This is
 * a function around `shuffle_in_place` that adds the guarantee that
 * it will not modify its input.
 *
 * @param {Array} x sample of 0 or more numbers
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} shuffled version of input
 * @example
 * var shuffled = shuffle([1, 2, 3, 4]);
 * shuffled; // = [2, 3, 1, 4] or any other random permutation
 */
function shuffle(x, randomSource) {
    // slice the original array so that it is not modified
    var sample = x.slice();

    // and then shuffle that shallow-copied array, in place
    return shuffleInPlace(sample, randomSource);
}

/**
 * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
 * from a given array of `n` elements.
 *
 * The sampled values will be in any order, not necessarily the order
 * they appear in the input.
 *
 * @param {Array<any>} x input array. can contain any type
 * @param {number} n count of how many elements to take
 * @param {Function} [randomSource=Math.random] an optional entropy source that
 * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
 * @return {Array} subset of n elements in original array
 *
 * @example
 * var values = [1, 2, 4, 5, 6, 7, 8, 9];
 * sample(values, 3); // returns 3 random values, like [2, 5, 8];
 */
function sample(x, n, randomSource) {
    // shuffle the original array using a fisher-yates shuffle
    var shuffled = shuffle(x, randomSource);

    // and then return a subset of it - the first `n` elements.
    return shuffled.slice(0, n);
}

/**
 * Create a new column x row matrix.
 *
 * @private
 * @param {number} columns
 * @param {number} rows
 * @return {Array<Array<number>>} matrix
 * @example
 * makeMatrix(10, 10);
 */
function makeMatrix(columns, rows) {
    var matrix = [];
    for (var i = 0; i < columns; i++) {
        var column = [];
        for (var j = 0; j < rows; j++) {
            column.push(0);
        }
        matrix.push(column);
    }
    return matrix;
}

/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 *
 * @param {Array<*>} x an array of any kind of value
 * @returns {number} count of unique values
 * @example
 * uniqueCountSorted([1, 2, 3]); // => 3
 * uniqueCountSorted([1, 1, 1]); // => 1
 */
function uniqueCountSorted(x) {
    var uniqueValueCount = 0;
    var lastSeenValue;
    for (var i = 0; i < x.length; i++) {
        if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i];
            uniqueValueCount++;
        }
    }
    return uniqueValueCount;
}

/**
 * Generates incrementally computed values based on the sums and sums of
 * squares for the data array
 *
 * @private
 * @param {number} j
 * @param {number} i
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 * @return {number}
 * @example
 * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
 */
function ssq(j, i, sums, sumsOfSquares) {
    var sji; // s(j, i)
    if (j > 0) {
        var muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)
        sji =
            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;
    } else {
        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);
    }
    if (sji < 0) {
        return 0;
    }
    return sji;
}

/**
 * Function that recursively divides and conquers computations
 * for cluster j
 *
 * @private
 * @param {number} iMin Minimum index in cluster to be computed
 * @param {number} iMax Maximum index in cluster to be computed
 * @param {number} cluster Index of the cluster currently being computed
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 * @param {Array<number>} sums
 * @param {Array<number>} sumsOfSquares
 */
function fillMatrixColumn(
    iMin,
    iMax,
    cluster,
    matrix,
    backtrackMatrix,
    sums,
    sumsOfSquares
) {
    if (iMin > iMax) {
        return;
    }

    // Start at midpoint between iMin and iMax
    var i = Math.floor((iMin + iMax) / 2);

    matrix[cluster][i] = matrix[cluster - 1][i - 1];
    backtrackMatrix[cluster][i] = i;

    var jlow = cluster; // the lower end for j

    if (iMin > cluster) {
        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);
    }
    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);

    var jhigh = i - 1; // the upper end for j
    if (iMax < matrix[0].length - 1) {
        /* c8 ignore start */
        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);
        /* c8 ignore end */
    }

    var sji;
    var sjlowi;
    var ssqjlow;
    var ssqj;
    for (var j = jhigh; j >= jlow; --j) {
        sji = ssq(j, i, sums, sumsOfSquares);

        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break;
        }

        // Examine the lower bound of the cluster border
        sjlowi = ssq(jlow, i, sums, sumsOfSquares);

        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];

        if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow;
            backtrackMatrix[cluster][i] = jlow;
        }
        jlow++;

        ssqj = sji + matrix[cluster - 1][j - 1];
        if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj;
            backtrackMatrix[cluster][i] = j;
        }
    }

    fillMatrixColumn(
        iMin,
        i - 1,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
    fillMatrixColumn(
        i + 1,
        iMax,
        cluster,
        matrix,
        backtrackMatrix,
        sums,
        sumsOfSquares
    );
}

/**
 * Initializes the main matrices used in Ckmeans and kicks
 * off the divide and conquer cluster computation strategy
 *
 * @private
 * @param {Array<number>} data sorted array of values
 * @param {Array<Array<number>>} matrix
 * @param {Array<Array<number>>} backtrackMatrix
 */
function fillMatrices(data, matrix, backtrackMatrix) {
    var nValues = matrix[0].length;

    // Shift values by the median to improve numeric stability
    var shift = data[Math.floor(nValues / 2)];

    // Cumulative sum and cumulative sum of squares for all values in data array
    var sums = [];
    var sumsOfSquares = [];

    // Initialize first column in matrix & backtrackMatrix
    for (var i = 0, shiftedValue = (void 0); i < nValues; ++i) {
        shiftedValue = data[i] - shift;
        if (i === 0) {
            sums.push(shiftedValue);
            sumsOfSquares.push(shiftedValue * shiftedValue);
        } else {
            sums.push(sums[i - 1] + shiftedValue);
            sumsOfSquares.push(
                sumsOfSquares[i - 1] + shiftedValue * shiftedValue
            );
        }

        // Initialize for cluster = 0
        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);
        backtrackMatrix[0][i] = 0;
    }

    // Initialize the rest of the columns
    var iMin;
    for (var cluster = 1; cluster < matrix.length; ++cluster) {
        if (cluster < matrix.length - 1) {
            iMin = cluster;
        } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1;
        }

        fillMatrixColumn(
            iMin,
            nValues - 1,
            cluster,
            matrix,
            backtrackMatrix,
            sums,
            sumsOfSquares
        );
    }
}

/**
 * Ckmeans clustering is an improvement on heuristic-based clustering
 * approaches like Jenks. The algorithm was developed in
 * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
 * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
 * to the problem of clustering numeric data into groups with the least
 * within-group sum-of-squared-deviations.
 *
 * Minimizing the difference within groups - what Wang & Song refer to as
 * `withinss`, or within sum-of-squares, means that groups are optimally
 * homogenous within and the data is split into representative groups.
 * This is very useful for visualization, where you may want to represent
 * a continuous variable in discrete color or style groups. This function
 * can provide groups that emphasize differences between data.
 *
 * Being a dynamic approach, this algorithm is based on two matrices that
 * store incrementally-computed values for squared deviations and backtracking
 * indexes.
 *
 * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
 * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
 *
 * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
 * this implementation does not include any code to automatically determine
 * the optimal number of clusters: this information needs to be explicitly
 * provided.
 *
 * ### References
 * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
 * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
 *
 * from The R Journal Vol. 3/2, December 2011
 * @param {Array<number>} x input data, as an array of number values
 * @param {number} nClusters number of desired classes. This cannot be
 * greater than the number of values in the data array.
 * @returns {Array<Array<number>>} clustered input
 * @throws {Error} if the number of requested clusters is higher than the size of the data
 * @example
 * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
 * // The input, clustered into groups of similar numbers.
 * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
 */
function ckmeans(x, nClusters) {
    if (nClusters > x.length) {
        throw new Error(
            "cannot generate more classes than there are data values"
        );
    }

    var sorted = numericSort(x);
    // we'll use this as the maximum number of clusters
    var uniqueCount = uniqueCountSorted(sorted);

    // if all of the input values are identical, there's one cluster
    // with all of the input in it.
    if (uniqueCount === 1) {
        return [sorted];
    }

    // named 'S' originally
    var matrix = makeMatrix(nClusters, sorted.length);
    // named 'J' originally
    var backtrackMatrix = makeMatrix(nClusters, sorted.length);

    // This is a dynamic programming way to solve the problem of minimizing
    // within-cluster sum of squares. It's similar to linear regression
    // in this way, and this calculation incrementally computes the
    // sum of squares that are later read.
    fillMatrices(sorted, matrix, backtrackMatrix);

    // The real work of Ckmeans clustering happens in the matrix generation:
    // the generated matrices encode all possible clustering combinations, and
    // once they're generated we can solve for the best clustering groups
    // very quickly.
    var clusters = [];
    var clusterRight = backtrackMatrix[0].length - 1;

    // Backtrack the clusters from the dynamic programming matrix. This
    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
    // and moves the cluster target with the loop.
    for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
        var clusterLeft = backtrackMatrix[cluster][clusterRight];

        // fill the cluster from the sorted input by taking a slice of the
        // array. the backtrack matrix makes this easy - it stores the
        // indexes where the cluster should start and end.
        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);

        if (cluster > 0) {
            clusterRight = clusterLeft - 1;
        }
    }

    return clusters;
}

/*
 * Pull Breaks Values for Jenks
 *
 * the second part of the jenks recipe: take the calculated matrices
 * and derive an array of n breaks.
 *
 * @private
 */
function jenksBreaks(data, lowerClassLimits, nClasses) {
    var k = data.length;
    var kclass = [];
    var countNum = nClasses;

    // the calculation of classes will never include the upper
    // bound, so we need to explicitly set it
    kclass[nClasses] = data[data.length - 1];

    // the lowerClassLimits matrix is used as indices into itself
    // here: the `k` variable is reused in each iteration.
    while (countNum > 0) {
        kclass[countNum - 1] = data[lowerClassLimits[k][countNum] - 1];
        k = lowerClassLimits[k][countNum] - 1;
        countNum--;
    }

    return kclass;
}

/*
 * Compute Matrices for Jenks
 *
 * Compute the matrices required for Jenks breaks. These matrices
 * can be used for any classing of data with `classes <= nClasses`
 *
 * @private
 */
function jenksMatrices(data, nClasses) {
    // in the original implementation, these matrices are referred to
    // as `LC` and `OP`
    //
    // * lowerClassLimits (LC): optimal lower class limits
    // * varianceCombinations (OP): optimal variance combinations for all classes
    var lowerClassLimits = [];
    var varianceCombinations = [];
    // loop counters
    var i;
    var j;
    // the variance, as computed at each step in the calculation
    var variance = 0;

    // Initialize and fill each matrix with zeroes
    for (i = 0; i < data.length + 1; i++) {
        var tmp1 = [];
        var tmp2 = [];
        // despite these arrays having the same values, we need
        // to keep them separate so that changing one does not change
        // the other
        for (j = 0; j < nClasses + 1; j++) {
            tmp1.push(0);
            tmp2.push(0);
        }
        lowerClassLimits.push(tmp1);
        varianceCombinations.push(tmp2);
    }

    for (i = 1; i < nClasses + 1; i++) {
        lowerClassLimits[1][i] = 1;
        varianceCombinations[1][i] = 0;
        // in the original implementation, 9999999 is used but
        // since Javascript has `Infinity`, we use that.
        for (j = 2; j < data.length + 1; j++) {
            varianceCombinations[j][i] = Number.POSITIVE_INFINITY;
        }
    }

    for (var l = 2; l < data.length + 1; l++) {
        // `SZ` originally. this is the sum of the values seen thus
        // far when calculating variance.
        var sum = 0;
        // `ZSQ` originally. the sum of squares of values seen
        // thus far
        var sumSquares = 0;
        // `WT` originally. This is the number of
        var w = 0;
        // `IV` originally
        var i4 = 0;

        // in several instances, you could say `Math.pow(x, 2)`
        // instead of `x * x`, but this is slower in some browsers
        // introduces an unnecessary concept.
        for (var m = 1; m < l + 1; m++) {
            // `III` originally
            var lowerClassLimit = l - m + 1;
            var val = data[lowerClassLimit - 1];

            // here we're estimating variance for each potential classing
            // of the data, for each potential number of classes. `w`
            // is the number of data points considered so far.
            w++;

            // increase the current sum and sum-of-squares
            sum += val;
            sumSquares += val * val;

            // the variance at this point in the sequence is the difference
            // between the sum of squares and the total x 2, over the number
            // of samples.
            variance = sumSquares - (sum * sum) / w;

            i4 = lowerClassLimit - 1;

            if (i4 !== 0) {
                for (j = 2; j < nClasses + 1; j++) {
                    // if adding this element to an existing class
                    // will increase its variance beyond the limit, break
                    // the class at this point, setting the `lowerClassLimit`
                    // at this point.
                    if (
                        varianceCombinations[l][j] >=
                        variance + varianceCombinations[i4][j - 1]
                    ) {
                        lowerClassLimits[l][j] = lowerClassLimit;
                        varianceCombinations[l][j] =
                            variance + varianceCombinations[i4][j - 1];
                    }
                }
            }
        }

        lowerClassLimits[l][1] = 1;
        varianceCombinations[l][1] = variance;
    }

    // return the two matrices. for just providing breaks, only
    // `lowerClassLimits` is needed, but variances can be useful to
    // evaluate goodness of fit.
    return {
        lowerClassLimits: lowerClassLimits,
        varianceCombinations: varianceCombinations
    };
}

/**
 * The **[jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)**
 * is an algorithm commonly used in cartography and visualization to decide
 * upon groupings of data values that minimize variance within themselves
 * and maximize variation between themselves.
 *
 * For instance, cartographers often use jenks in order to choose which
 * values are assigned to which colors in a [choropleth](https://en.wikipedia.org/wiki/Choropleth_map)
 * map.
 *
 * @param {Array<number>} data input data, as an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * // split data into 3 break points
 * jenks([1, 2, 4, 5, 7, 9, 10, 20], 3) // = [1, 7, 20, 20]
 */
function jenks(data, nClasses) {
    if (nClasses > data.length) {
        return null;
    }

    // sort data in numerical order, since this is expected
    // by the matrices function
    data = data.slice().sort(function (a, b) {
        return a - b;
    });

    // get our basic matrices
    var matrices = jenksMatrices(data, nClasses);
    // we only need lower class limits here
    var lowerClassLimits = matrices.lowerClassLimits;

    // extract nClasses out of the computed matrices
    return jenksBreaks(data, lowerClassLimits, nClasses);
}

/**
 * Given an array of x, this will find the extent of the
 * x and return an array of breaks that can be used
 * to categorize the x into a number of classes. The
 * returned array will always be 1 longer than the number of
 * classes because it includes the minimum value.
 *
 * @param {Array<number>} x an array of number values
 * @param {number} nClasses number of desired classes
 * @returns {Array<number>} array of class break positions
 * @example
 * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]
 */
function equalIntervalBreaks(x, nClasses) {
    if (x.length < 2) {
        return x;
    }

    var theMin = min(x);
    var theMax = max(x);

    // the first break will always be the minimum value
    // in the xset
    var breaks = [theMin];

    // The size of each break is the full range of the x
    // divided by the number of classes requested
    var breakSize = (theMax - theMin) / nClasses;

    // In the case of nClasses = 1, this loop won't run
    // and the returned breaks will be [min, max]
    for (var i = 1; i < nClasses; i++) {
        breaks.push(breaks[0] + breakSize * i);
    }

    // the last break will always be the
    // maximum.
    breaks.push(theMax);

    return breaks;
}

/**
 * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_covariance) of two datasets:
 * how much do the two datasets move together?
 * x and y are two datasets, represented as arrays of numbers.
 *
 * @param {Array<number>} x a sample of two or more data points
 * @param {Array<number>} y a sample of two or more data points
 * @throws {Error} if x and y do not have equal lengths
 * @throws {Error} if x or y have length of one or less
 * @returns {number} sample covariance
 * @example
 * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
 */
function sampleCovariance(x, y) {
    // The two datasets must have the same length which must be more than 1
    if (x.length !== y.length) {
        throw new Error("sampleCovariance requires samples with equal lengths");
    }

    if (x.length < 2) {
        throw new Error(
            "sampleCovariance requires at least two data points in each sample"
        );
    }

    // determine the mean of each dataset so that we can judge each
    // value of the dataset fairly as the difference from the mean. this
    // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
    // does not suffer because of the difference in absolute values
    var xmean = mean(x);
    var ymean = mean(y);
    var sum = 0;

    // for each pair of values, the covariance increases when their
    // difference from the mean is associated - if both are well above
    // or if both are well below
    // the mean, the covariance increases significantly.
    for (var i = 0; i < x.length; i++) {
        sum += (x[i] - xmean) * (y[i] - ymean);
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // the covariance is weighted by the length of the datasets.
    return sum / besselsCorrection;
}

/**
 * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
 * is the sum of squared deviations from the mean. The sample variance
 * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
 * instead of dividing the sum of squared deviations by the length of the input,
 * it is divided by the length minus one. This corrects the bias in estimating
 * a value from a set that you don't know if full.
 *
 * References:
 * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
 *
 * @param {Array<number>} x a sample of two or more data points
 * @throws {Error} if the length of x is less than 2
 * @return {number} sample variance
 * @example
 * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
 */
function sampleVariance(x) {
    if (x.length < 2) {
        throw new Error("sampleVariance requires at least two data points");
    }

    var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2);

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    return sumSquaredDeviationsValue / besselsCorrection;
}

/**
 * The [sample standard deviation](http://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation)
 * is the square root of the sample variance.
 *
 * @param {Array<number>} x input array
 * @returns {number} sample standard deviation
 * @example
 * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
 * // => '2.14'
 */
function sampleStandardDeviation(x) {
    var sampleVarianceX = sampleVariance(x);
    return Math.sqrt(sampleVarianceX);
}

/**
 * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
 * a measure of how correlated two datasets are, between -1 and 1
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample correlation
 * @example
 * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
 * // => '0.69'
 */
function sampleCorrelation(x, y) {
    var cov = sampleCovariance(x, y);
    var xstd = sampleStandardDeviation(x);
    var ystd = sampleStandardDeviation(y);

    return cov / xstd / ystd;
}

/**
 * The [rank correlation](https://en.wikipedia.org/wiki/Rank_correlation) is
 * a measure of the strength of monotonic relationship between two arrays
 *
 * @param {Array<number>} x first input
 * @param {Array<number>} y second input
 * @returns {number} sample rank correlation
 */
function sampleRankCorrelation(x, y) {
    var xIndexes = x
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });
    var yIndexes = y
        .map(function (value, index) { return [value, index]; })
        .sort(function (a, b) { return a[0] - b[0]; })
        .map(function (pair) { return pair[1]; });

    // At this step, we have an array of indexes
    // that map from sorted numbers to their original indexes. We reverse
    // that so that it is an array of the sorted destination index.
    var xRanks = Array(xIndexes.length);
    var yRanks = Array(xIndexes.length);
    for (var i = 0; i < xIndexes.length; i++) {
        xRanks[xIndexes[i]] = i;
        yRanks[yIndexes[i]] = i;
    }

    return sampleCorrelation(xRanks, yRanks);
}

/**
 * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
 * a measure of the extent to which a probability distribution of a
 * real-valued random variable "leans" to one side of the mean.
 * The skewness value can be positive or negative, or even undefined.
 *
 * Implementation is based on the adjusted Fisher-Pearson standardized
 * moment coefficient, which is the version found in Excel and several
 * statistical packages including Minitab, SAS and SPSS.
 *
 * @since 4.1.0
 * @param {Array<number>} x a sample of 3 or more data points
 * @returns {number} sample skewness
 * @throws {Error} if x has length less than 3
 * @example
 * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
 */
function sampleSkewness(x) {
    if (x.length < 3) {
        throw new Error("sampleSkewness requires at least three data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var sumSquaredDeviations = 0;
    var sumCubedDeviations = 0;

    for (var i = 0; i < x.length; i++) {
        tempValue = x[i] - meanValue;
        sumSquaredDeviations += tempValue * tempValue;
        sumCubedDeviations += tempValue * tempValue * tempValue;
    }

    // this is Bessels' Correction: an adjustment made to sample statistics
    // that allows for the reduced degree of freedom entailed in calculating
    // values from samples rather than complete populations.
    var besselsCorrection = x.length - 1;

    // Find the mean value of that list
    var theSampleStandardDeviation = Math.sqrt(
        sumSquaredDeviations / besselsCorrection
    );

    var n = x.length;
    var cubedS = Math.pow(theSampleStandardDeviation, 3);

    return (n * sumCubedDeviations) / ((n - 1) * (n - 2) * cubedS);
}

/**
 * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
 * a measure of the heaviness of a distribution's tails relative to its
 * variance. The kurtosis value can be positive or negative, or even undefined.
 *
 * Implementation is based on Fisher's excess kurtosis definition and uses
 * unbiased moment estimators. This is the version found in Excel and available
 * in several statistical packages, including SAS and SciPy.
 *
 * @param {Array<number>} x a sample of 4 or more data points
 * @returns {number} sample kurtosis
 * @throws {Error} if x has length less than 4
 * @example
 * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
 */
function sampleKurtosis(x) {
    var n = x.length;

    if (n < 4) {
        throw new Error("sampleKurtosis requires at least four data points");
    }

    var meanValue = mean(x);
    var tempValue;
    var secondCentralMoment = 0;
    var fourthCentralMoment = 0;

    for (var i = 0; i < n; i++) {
        tempValue = x[i] - meanValue;
        secondCentralMoment += tempValue * tempValue;
        fourthCentralMoment += tempValue * tempValue * tempValue * tempValue;
    }

    return (
        ((n - 1) / ((n - 2) * (n - 3))) *
        ((n * (n + 1) * fourthCentralMoment) /
            (secondCentralMoment * secondCentralMoment) -
            3 * (n - 1))
    );
}

/**
 * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
 * for generating permutations.
 *
 * @param {Array} elements any type of data
 * @returns {Array<Array>} array of permutations
 */
function permutationsHeap(elements) {
    var indexes = new Array(elements.length);
    var permutations = [elements.slice()];

    for (var i = 0; i < elements.length; i++) {
        indexes[i] = 0;
    }

    for (var i$1 = 0; i$1 < elements.length; ) {
        if (indexes[i$1] < i$1) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0;
            if (i$1 % 2 !== 0) {
                swapFrom = indexes[i$1];
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom];
            elements[swapFrom] = elements[i$1];
            elements[i$1] = temp;

            permutations.push(elements.slice());
            indexes[i$1]++;
            i$1 = 0;
        } else {
            indexes[i$1] = 0;
            i$1++;
        }
    }

    return permutations;
}

/**
 * Implementation of Combinations
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * https://en.wikipedia.org/wiki/Combination
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
 */

function combinations(x, k) {
    var i;
    var subI;
    var combinationList = [];
    var subsetCombinations;
    var next;

    for (i = 0; i < x.length; i++) {
        if (k === 1) {
            combinationList.push([x[i]]);
        } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1);
            for (subI = 0; subI < subsetCombinations.length; subI++) {
                next = subsetCombinations[subI];
                next.unshift(x[i]);
                combinationList.push(next);
            }
        }
    }
    return combinationList;
}

/**
 * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
 * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
 * 'With replacement' means that a given element can be chosen multiple times.
 * Unlike permutation, order doesn't matter for combinations.
 *
 * @param {Array} x any type of data
 * @param {int} k the number of objects in each group (without replacement)
 * @returns {Array<Array>} array of permutations
 * @example
 * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
 */
function combinationsReplacement(x, k) {
    var combinationList = [];

    for (var i = 0; i < x.length; i++) {
        if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]]);
        } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(
                x.slice(i, x.length),
                k - 1
            );

            for (var j = 0; j < subsetCombinations.length; j++) {
                combinationList.push([x[i]].concat(subsetCombinations[j]));
            }
        }
    }

    return combinationList;
}

/**
 * When adding a new value to a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the new
 * value to add.
 *
 * @since 2.5.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} newValue the added value
 * @returns {number} the new mean
 *
 * @example
 * addToMean(14, 5, 53); // => 20.5
 */
function addToMean(mean, n, newValue) {
    return mean + (newValue - mean) / (n + 1);
}

/**
 * When combining two lists of values for which one already knows the means,
 * one does not have to necessary recompute the mean of the combined lists in
 * linear time. They can instead use this function to compute the combined
 * mean by providing the mean & number of values of the first list and the mean
 * & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineMeans(5, 3, 4, 3); // => 4.5
 */
function combineMeans(mean1, n1, mean2, n2) {
    return (mean1 * n1 + mean2 * n2) / (n1 + n2);
}

/**
 * When combining two lists of values for which one already knows the variances,
 * one does not have to necessary recompute the variance of the combined lists
 * in linear time. They can instead use this function to compute the combined
 * variance by providing the variance, mean & number of values of the first list
 * and the variance, mean & number of values of the second list.
 *
 * @since 3.0.0
 * @param {number} variance1 variance of the first list
 * @param {number} mean1 mean of the first list
 * @param {number} n1 number of items in the first list
 * @param {number} variance2 variance of the second list
 * @param {number} mean2 mean of the second list
 * @param {number} n2 number of items in the second list
 * @returns {number} the combined mean
 *
 * @example
 * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
 */
function combineVariances(variance1, mean1, n1, variance2, mean2, n2) {
    var newMean = combineMeans(mean1, n1, mean2, n2);

    return (
        (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) +
            n2 * (variance2 + Math.pow(mean2 - newMean, 2))) /
        (n1 + n2)
    );
}

/**
 * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
 * a mean function that is more useful for numbers in different
 * ranges.
 *
 * This is the nth root of the input numbers multiplied by each other.
 *
 * The geometric mean is often useful for
 * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
 * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
 * mean will incorrectly estimate an average growth rate, whereas a geometric
 * mean will correctly estimate a growth rate that, over those years,
 * will yield the same end value.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * var growthRates = [1.80, 1.166666, 1.428571];
 * var averageGrowth = ss.geometricMean(growthRates);
 * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
 * var startingValue = 10;
 * var startingValueMean = 10;
 * growthRates.forEach(function(rate) {
 *   startingValue *= rate;
 * });
 * averageGrowthRates.forEach(function(rate) {
 *   startingValueMean *= rate;
 * });
 * startingValueMean === startingValue;
 */
function geometricMean(x) {
    if (x.length === 0) {
        throw new Error("geometricMean requires at least one data point");
    }

    // the starting value.
    var value = 1;

    for (var i = 0; i < x.length; i++) {
        // the geometric mean is only valid for positive numbers
        if (x[i] < 0) {
            throw new Error(
                "geometricMean requires only non-negative numbers as input"
            );
        }

        // repeatedly multiply the value by each number
        value *= x[i];
    }

    return Math.pow(value, 1 / x.length);
}

/**
 * The [log average](https://en.wikipedia.org/wiki/https://en.wikipedia.org/wiki/Geometric_mean#Relationship_with_logarithms)
 * is an equivalent way of computing the geometric mean of an array suitable for large or small products.
 *
 * It's found by calculating the average logarithm of the elements and exponentiating.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} geometric mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 */
function logAverage(x) {
    if (x.length === 0) {
        throw new Error("logAverage requires at least one data point");
    }

    var value = 0;
    for (var i = 0; i < x.length; i++) {
        if (x[i] < 0) {
            throw new Error(
                "logAverage requires only non-negative numbers as input"
            );
        }
        value += Math.log(x[i]);
    }

    return Math.exp(value / x.length);
}

/**
 * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
 * a mean function typically used to find the average of rates.
 * This mean is calculated by taking the reciprocal of the arithmetic mean
 * of the reciprocals of the input numbers.
 *
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x sample of one or more data points
 * @returns {number} harmonic mean
 * @throws {Error} if x is empty
 * @throws {Error} if x contains a negative number
 * @example
 * harmonicMean([2, 3]).toFixed(2) // => '2.40'
 */
function harmonicMean(x) {
    if (x.length === 0) {
        throw new Error("harmonicMean requires at least one data point");
    }

    var reciprocalSum = 0;

    for (var i = 0; i < x.length; i++) {
        // the harmonic mean is only valid for positive numbers
        if (x[i] <= 0) {
            throw new Error(
                "harmonicMean requires only positive numbers as input"
            );
        }

        reciprocalSum += 1 / x[i];
    }

    // divide n by the reciprocal sum
    return x.length / reciprocalSum;
}

/**
 * The mean, _also known as average_,
 * is the sum of all values over the number of values.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The simple mean uses the successive addition method internally
 * to calculate it's result. Errors in floating-point addition are
 * not accounted for, so if precision is required, the standard {@link mean}
 * method should be used instead.
 *
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 *
 * @param {Array<number>} x sample of one or more data points
 * @throws {Error} if the length of x is less than one
 * @returns {number} mean
 * @example
 * mean([0, 10]); // => 5
 */
function meanSimple(x) {
    if (x.length === 0) {
        throw new Error("meanSimple requires at least one data point");
    }

    return sumSimple(x) / x.length;
}

/**
 * The [median](http://en.wikipedia.org/wiki/Median) is
 * the middle number of a list. This is often a good indicator of 'the middle'
 * when there are outliers that skew the `mean()` value.
 * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
 * a method of finding a typical or central value of a set of numbers.
 *
 * The median isn't necessarily one of the elements in the list: the value
 * can be the average of two elements if the list has an even length
 * and the two central values are different.
 *
 * @param {Array<number>} sorted input
 * @returns {number} median value
 * @example
 * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
 */
function medianSorted(sorted) {
    return quantileSorted(sorted, 0.5);
}

/**
 * When removing a value from a list, one does not have to necessary
 * recompute the mean of the list in linear time. They can instead use
 * this function to compute the new mean by providing the current mean,
 * the number of elements in the list that produced it and the value to remove.
 *
 * @since 3.0.0
 * @param {number} mean current mean
 * @param {number} n number of items in the list
 * @param {number} value the value to remove
 * @returns {number} the new mean
 *
 * @example
 * subtractFromMean(20.5, 6, 53); // => 14
 */
function subtractFromMean(mean, n, value) {
    return (mean * n - value) / (n - 1);
}

/**
 * The Root Mean Square (RMS) is
 * a mean function used as a measure of the magnitude of a set
 * of numbers, regardless of their sign.
 * This is the square root of the mean of the squares of the
 * input numbers.
 * This runs in `O(n)`, linear time, with respect to the length of the array.
 *
 * @param {Array<number>} x a sample of one or more data points
 * @returns {number} root mean square
 * @throws {Error} if x is empty
 * @example
 * rootMeanSquare([-1, 1, -1, 1]); // => 1
 */
function rootMeanSquare(x) {
    if (x.length === 0) {
        throw new Error("rootMeanSquare requires at least one data point");
    }

    var sumOfSquares = 0;
    for (var i = 0; i < x.length; i++) {
        sumOfSquares += Math.pow(x[i], 2);
    }

    return Math.sqrt(sumOfSquares / x.length);
}

/**
 * The`coefficient of variation`_ is the ratio of the standard deviation to the mean.
 * .._`coefficient of variation`: https://en.wikipedia.org/wiki/Coefficient_of_variation
 *
 *
 * @param {Array} x input
 * @returns {number} coefficient of variation
 * @example
 * coefficientOfVariation([1, 2, 3, 4]).toFixed(3); // => 0.516
 * coefficientOfVariation([1, 2, 3, 4, 5]).toFixed(3); // => 0.527
 * coefficientOfVariation([-1, 0, 1, 2, 3, 4]).toFixed(3); // => 1.247
 */
function coefficientOfVariation(x) {
    return sampleStandardDeviation(x) / mean(x);
}

/**
 * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
 * of a sample to a known value, x.
 *
 * in this case, we're trying to determine whether the
 * population mean is equal to the value that we know, which is `x`
 * here. Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * @param {Array<number>} x sample of one or more numbers
 * @param {number} expectedValue expected value of the population mean
 * @returns {number} value
 * @example
 * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
 */
function tTest(x, expectedValue) {
    // The mean of the sample
    var sampleMean = mean(x);

    // The standard deviation of the sample
    var sd = standardDeviation(x);

    // Square root the length of the sample
    var rootN = Math.sqrt(x.length);

    // returning the t value
    return (sampleMean - expectedValue) / (sd / rootN);
}

/**
 * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
 * Tests whether "mean(X)-mean(Y) = difference", (
 * in the most common case, we often have `difference == 0` to test if two samples
 * are likely to be taken from populations with the same mean value) with
 * no prior knowledge on standard deviations of both samples
 * other than the fact that they have the same standard deviation.
 *
 * Usually the results here are used to look up a
 * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
 * a certain level of significance, will let you determine that the
 * null hypothesis can or cannot be rejected.
 *
 * `diff` can be omitted if it equals 0.
 *
 * [This is used to reject](https://en.wikipedia.org/wiki/Exclusion_of_the_null_hypothesis)
 * a null hypothesis that the two populations that have been sampled into
 * `sampleX` and `sampleY` are equal to each other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @param {number} [difference=0]
 * @returns {number|null} test result
 *
 * @example
 * tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); // => -2.1908902300206643
 */
function tTestTwoSample(sampleX, sampleY, difference) {
    var n = sampleX.length;
    var m = sampleY.length;

    // If either sample doesn't actually have any values, we can't
    // compute this at all, so we return `null`.
    if (!n || !m) {
        return null;
    }

    // default difference (mu) is zero
    if (!difference) {
        difference = 0;
    }

    var meanX = mean(sampleX);
    var meanY = mean(sampleY);
    var sampleVarianceX = sampleVariance(sampleX);
    var sampleVarianceY = sampleVariance(sampleY);

    if (
        typeof meanX === "number" &&
        typeof meanY === "number" &&
        typeof sampleVarianceX === "number" &&
        typeof sampleVarianceY === "number"
    ) {
        var weightedVariance =
            ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) /
            (n + m - 2);

        return (
            (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m))
        );
    }
}

/**
 * This function calculates the Wilcoxon rank sum statistic for the first sample
 * with respect to the second. The Wilcoxon rank sum test is a non-parametric
 * alternative to the t-test which is equivalent to the
 * [Mann-Whitney U test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).
 * The statistic is calculated by pooling all the observations together, ranking them,
 * and then summing the ranks associated with one of the samples. If this rank sum is
 * sufficiently large or small we reject the hypothesis that the two samples come
 * from the same distribution in favor of the alternative that one is shifted with
 * respect to the other.
 *
 * @param {Array<number>} sampleX a sample as an array of numbers
 * @param {Array<number>} sampleY a sample as an array of numbers
 * @returns {number} rank sum for sampleX
 *
 * @example
 * wilcoxonRankSum([1, 4, 8], [9, 12, 15]); // => 6
 */
function wilcoxonRankSum(sampleX, sampleY) {
    if (!sampleX.length || !sampleY.length) {
        throw new Error("Neither sample can be empty");
    }

    var pooledSamples = sampleX
        .map(function (x) { return ({ label: "x", value: x }); })
        .concat(sampleY.map(function (y) { return ({ label: "y", value: y }); }))
        .sort(function (a, b) { return a.value - b.value; });

    for (var rank = 0; rank < pooledSamples.length; rank++) {
        pooledSamples[rank].rank = rank;
    }

    var tiedRanks = [pooledSamples[0].rank];
    for (var i = 1; i < pooledSamples.length; i++) {
        if (pooledSamples[i].value === pooledSamples[i - 1].value) {
            tiedRanks.push(pooledSamples[i].rank);
            if (i === pooledSamples.length - 1) {
                replaceRanksInPlace(pooledSamples, tiedRanks);
            }
        } else if (tiedRanks.length > 1) {
            replaceRanksInPlace(pooledSamples, tiedRanks);
        } else {
            tiedRanks = [pooledSamples[i].rank];
        }
    }

    function replaceRanksInPlace(pooledSamples, tiedRanks) {
        var average = (tiedRanks[0] + tiedRanks[tiedRanks.length - 1]) / 2;
        for (var i = 0; i < tiedRanks.length; i++) {
            pooledSamples[tiedRanks[i]].rank = average;
        }
    }

    var rankSum = 0;

    for (var i$1 = 0; i$1 < pooledSamples.length; i$1++) {
        var sample = pooledSamples[i$1];
        if (sample.label === "x") {
            rankSum += sample.rank + 1;
        }
    }

    return rankSum;
}

/**
 * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
 *
 * This is a nave bayesian classifier that takes
 * singly-nested objects.
 *
 * @class
 * @example
 * var bayes = new BayesianClassifier();
 * bayes.train({
 *   species: 'Cat'
 * }, 'animal');
 * var result = bayes.score({
 *   species: 'Cat'
 * })
 * // result
 * // {
 * //   animal: 1
 * // }
 */
var BayesianClassifier = function BayesianClassifier() {
    // The number of items that are currently
    // classified in the model
    this.totalCount = 0;
    // Every item classified in the model
    this.data = {};
};

/**
 * Train the classifier with a new item, which has a single
 * dimension of Javascript literal keys and values.
 *
 * @param {Object} item an object with singly-deep properties
 * @param {string} category the category this item belongs to
 * @return {undefined} adds the item to the classifier
 */
BayesianClassifier.prototype.train = function train (item, category) {
    // If the data object doesn't have any values
    // for this category, create a new object for it.
    if (!this.data[category]) {
        this.data[category] = {};
    }

    // Iterate through each key in the item.
    for (var k in item) {
        var v = item[k];
        // Initialize the nested object `data[category][k][item[k]]`
        // with an object of keys that equal 0.
        if (this.data[category][k] === undefined) {
            this.data[category][k] = {};
        }
        if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0;
        }

        // And increment the key for this key/value combination.
        this.data[category][k][v]++;
    }

    // Increment the number of items classified
    this.totalCount++;
};

/**
 * Generate a score of how well this item matches all
 * possible categories based on its attributes
 *
 * @param {Object} item an item in the same format as with train
 * @returns {Object} of probabilities that this item belongs to a
 * given category.
 */
BayesianClassifier.prototype.score = function score (item) {
    // Initialize an empty array of odds per category.
    var odds = {};
    var category;
    // Iterate through each key in the item,
    // then iterate through each category that has been used
    // in previous calls to `.train()`
    for (var k in item) {
        var v = item[k];
        for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {};

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
                odds[category][k + "_" + v] =
                    (this.data[category][k][v] || 0) / this.totalCount;
            } else {
                odds[category][k + "_" + v] = 0;
            }
        }
    }

    // Set up a new object that will contain sums of these odds by category
    var oddsSums = {};

    for (category in odds) {
        // Tally all of the odds for each category-combination pair -
        // the non-existence of a category does not add anything to the
        // score.
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination];
        }
    }

    return oddsSums;
};

/**
 * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
 * arrays of numbers and predicts whether they should be classified
 * as either 0 or 1 (negative or positive examples).
 * @class
 * @example
 * // Create the model
 * var p = new PerceptronModel();
 * // Train the model with input with a diagonal boundary.
 * for (var i = 0; i < 5; i++) {
 *     p.train([1, 1], 1);
 *     p.train([0, 1], 0);
 *     p.train([1, 0], 0);
 *     p.train([0, 0], 0);
 * }
 * p.predict([0, 0]); // 0
 * p.predict([0, 1]); // 0
 * p.predict([1, 0]); // 0
 * p.predict([1, 1]); // 1
 */
var PerceptronModel = function PerceptronModel() {
    // The weights, or coefficients of the model;
    // weights are only populated when training with data.
    this.weights = [];
    // The bias term, or intercept; it is also a weight but
    // it's stored separately for convenience as it is always
    // multiplied by one.
    this.bias = 0;
};
/**
 * **Predict**: Use an array of features with the weight array and bias
 * to predict whether an example is labeled 0 or 1.
 *
 * @param {Array<number>} features an array of features as numbers
 * @returns {number} 1 if the score is over 0, otherwise 0
 */
PerceptronModel.prototype.predict = function predict (features) {
    // Only predict if previously trained
    // on the same size feature array(s).
    if (features.length !== this.weights.length) {
        return null;
    }

    // Calculate the sum of features times weights,
    // with the bias added (implicitly times one).
    var score = 0;
    for (var i = 0; i < this.weights.length; i++) {
        score += this.weights[i] * features[i];
    }
    score += this.bias;

    // Classify as 1 if the score is over 0, otherwise 0.
    if (score > 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * **Train** the classifier with a new example, which is
 * a numeric array of features and a 0 or 1 label.
 *
 * @param {Array<number>} features an array of features as numbers
 * @param {number} label either 0 or 1
 * @returns {PerceptronModel} this
 */
PerceptronModel.prototype.train = function train (features, label) {
    // Require that only labels of 0 or 1 are considered.
    if (label !== 0 && label !== 1) {
        return null;
    }
    // The length of the feature array determines
    // the length of the weight array.
    // The perceptron will continue learning as long as
    // it keeps seeing feature arrays of the same length.
    // When it sees a new data shape, it initializes.
    if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
    }
    // Make a prediction based on current weights.
    var prediction = this.predict(features);
    // Update the weights if the prediction is wrong.
    if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i];
        }
        this.bias += gradient;
    }
    return this;
};

/**
 * We use ``, epsilon, as a stopping criterion when we want to iterate
 * until we're "close enough". Epsilon is a very small number: for
 * simple statistics, that number is **0.0001**
 *
 * This is used in calculations like the binomialDistribution, in which
 * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
 * it progresses until it is close enough.
 *
 * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
 * where we're trying to find a local minimum of a function's derivative,
 * given by the `fDerivative` method.
 *
 * @example
 * // From calculation, we expect that the local minimum occurs at x=9/4
 * var x_old = 0;
 * // The algorithm starts at x=6
 * var x_new = 6;
 * var stepSize = 0.01;
 *
 * function fDerivative(x) {
 *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
 * }
 *
 * // The loop runs until the difference between the previous
 * // value and the current value is smaller than epsilon - a rough
 * // meaure of 'close enough'
 * while (Math.abs(x_new - x_old) > ss.epsilon) {
 *   x_old = x_new;
 *   x_new = x_old - stepSize * fDerivative(x_old);
 * }
 *
 * console.log('Local minimum occurs at', x_new);
 */
var epsilon = 0.0001;

/**
 * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
 * integers less than or equal to n. Often factorial is implemented
 * recursively, but this iterative approach is significantly faster
 * and simpler.
 *
 * @param {number} n input, must be an integer number 1 or greater
 * @returns {number} factorial: n!
 * @throws {Error} if n is less than 0 or not an integer
 * @example
 * factorial(5); // => 120
 */
function factorial(n) {
    // factorial is mathematically undefined for negative numbers
    if (n < 0) {
        throw new Error("factorial requires a non-negative value");
    }

    if (Math.floor(n) !== n) {
        throw new Error("factorial requires an integer input");
    }

    // typically you'll expand the factorial function going down, like
    // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
    // counting from 2 up to the number in question, and since anything
    // multiplied by 1 is itself, the loop only needs to start at 2.
    var accumulator = 1;
    for (var i = 2; i <= n; i++) {
        // for each number up to and including the number `n`, multiply
        // the accumulator my that number.
        accumulator *= i;
    }
    return accumulator;
}

/**
 * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.
 * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero
 * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,
 * though this implementation currently does not handle complex numbers as input values.
 * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.
 * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.
 *
 * @param {number} n Any real number except for zero and negative integers.
 * @returns {number} The gamma of the input value.
 *
 * @example
 * gamma(11.5); // 11899423.084037038
 * gamma(-11.5); // 2.29575810481609e-8
 * gamma(5); // 24
 */
function gamma(n) {
    if (Number.isInteger(n)) {
        if (n <= 0) {
            // gamma not defined for zero or negative integers
            return Number.NaN;
        } else {
            // use factorial for integer inputs
            return factorial(n - 1);
        }
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    if (n < 0) {
        // Use Euler's reflection formula for negative inputs
        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties
        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));
    } else {
        // Nemes' expansion approximation
        var seriesCoefficient =
            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));

        var seriesDenom = n + 1 / 4;

        var seriesExpansion =
            1 +
            1 / 144 / Math.pow(seriesDenom, 2) -
            1 / 12960 / Math.pow(seriesDenom, 3) -
            257 / 207360 / Math.pow(seriesDenom, 4) -
            52 / 2612736 / Math.pow(seriesDenom, 5) +
            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +
            37529 / 18811699200 / Math.pow(seriesDenom, 7);

        return seriesCoefficient * seriesExpansion;
    }
}

// Define series coefficients
var COEFFICIENTS = [
    0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
    14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
    0.46523628927048575665e-4, -0.98374475304879564677e-4,
    0.15808870322491248884e-3, -0.21026444172410488319e-3,
    0.2174396181152126432e-3, -0.16431810653676389022e-3,
    0.84418223983852743293e-4, -0.2619083840158140867e-4,
    0.36899182659531622704e-5
];

var g = 607 / 128;
var LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));

/**
 * Compute the logarithm of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Lanczos' approximation.
 * This function takes as input any real-value n greater than 0.
 * This function is useful for values of n too large for the normal gamma function (n > 165).
 * The code is based on Lanczo's Gamma approximation, defined [here](http://my.fit.edu/~gabdo/gamma.txt).
 *
 * @param {number} n Any real number greater than zero.
 * @returns {number} The logarithm of gamma of the input value.
 *
 * @example
 * gammaln(500); // 2605.1158503617335
 * gammaln(2.4); // 0.21685932244884043
 */
function gammaln(n) {
    // Return infinity if value not in domain
    if (n <= 0) {
        return Number.POSITIVE_INFINITY;
    }

    // Decrement n, because approximation is defined for n - 1
    n--;

    // Create series approximation
    var a = COEFFICIENTS[0];

    for (var i = 1; i < 15; i++) {
        a += COEFFICIENTS[i] / (n + i);
    }

    var tmp = g + 0.5 + n;

    // Return natural logarithm of gamma(n)
    return LOGSQRT2PI + Math.log(a) - tmp + (n + 0.5) * Math.log(tmp);
}

/**
 * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
 * is the probability discrete
 * distribution of a random variable which takes value 1 with success
 * probability `p` and value 0 with failure
 * probability `q` = 1 - `p`. It can be used, for example, to represent the
 * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
 * to mean "tails" (or vice versa). It is
 * a special case of a Binomial Distribution
 * where `n` = 1.
 *
 * @param {number} p input value, between 0 and 1 inclusive
 * @returns {number[]} values of bernoulli distribution at this point
 * @throws {Error} if p is outside 0 and 1
 * @example
 * bernoulliDistribution(0.3); // => [0.7, 0.3]
 */
function bernoulliDistribution(p) /*: number[] */ {
    // Check that `p` is a valid probability (0  p  1)
    if (p < 0 || p > 1) {
        throw new Error(
            "bernoulliDistribution requires probability to be between 0 and 1 inclusive"
        );
    }

    return [1 - p, p];
}

/**
 * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
 * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
 * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
 * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
 *
 * @param {number} trials number of trials to simulate
 * @param {number} probability
 * @returns {number[]} output
 */
function binomialDistribution(trials, probability) /*: ?number[] */ {
    // Check that `p` is a valid probability (0  p  1),
    // that `n` is an integer, strictly positive.
    if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
        return undefined;
    }

    // We initialize `x`, the random variable, and `accumulator`, an accumulator
    // for the cumulative distribution function to 0. `distribution_functions`
    // is the object we'll return with the `probability_of_x` and the
    // `cumulativeProbability_of_x`, as well as the calculated mean &
    // variance. We iterate until the `cumulativeProbability_of_x` is
    // within `epsilon` of 1.0.
    var x = 0;
    var cumulativeProbability = 0;
    var cells = [];
    var binomialCoefficient = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] =
            binomialCoefficient *
            Math.pow(probability, x) *
            Math.pow(1 - probability, trials - x);
        cumulativeProbability += cells[x];
        x++;
        binomialCoefficient = (binomialCoefficient * (trials - x + 1)) / x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
 * is a discrete probability distribution that expresses the probability
 * of a given number of events occurring in a fixed interval of time
 * and/or space if these events occur with a known average rate and
 * independently of the time since the last event.
 *
 * The Poisson Distribution is characterized by the strictly positive
 * mean arrival or occurrence rate, ``.
 *
 * @param {number} lambda location poisson distribution
 * @returns {number[]} values of poisson distribution at that point
 */
function poissonDistribution(lambda) /*: ?number[] */ {
    // Check that lambda is strictly positive
    if (lambda <= 0) {
        return undefined;
    }

    // our current place in the distribution
    var x = 0;
    // and we keep track of the current cumulative probability, in
    // order to know when to stop calculating chances.
    var cumulativeProbability = 0;
    // the calculated cells to be returned
    var cells = [];
    var factorialX = 1;

    // This algorithm iterates through each potential outcome,
    // until the `cumulativeProbability` is very close to 1, at
    // which point we've defined the vast majority of outcomes
    do {
        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        cells[x] = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorialX;
        cumulativeProbability += cells[x];
        x++;
        factorialX *= x;
        // when the cumulativeProbability is nearly 1, we've calculated
        // the useful range of this distribution
    } while (cumulativeProbability < 1 - epsilon);

    return cells;
}

/**
 * **Percentage Points of the 2 (Chi-Squared) Distribution**
 *
 * The [2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
 * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
 * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
 * deviation of a normal distribution from a sample standard deviation.
 *
 * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
 * Engineering and Management Science", Wiley (1980).
 */
var chiSquaredDistributionTable = {
    1: {
        0.995: 0,
        0.99: 0,
        0.975: 0,
        0.95: 0,
        0.9: 0.02,
        0.5: 0.45,
        0.1: 2.71,
        0.05: 3.84,
        0.025: 5.02,
        0.01: 6.63,
        0.005: 7.88
    },
    2: {
        0.995: 0.01,
        0.99: 0.02,
        0.975: 0.05,
        0.95: 0.1,
        0.9: 0.21,
        0.5: 1.39,
        0.1: 4.61,
        0.05: 5.99,
        0.025: 7.38,
        0.01: 9.21,
        0.005: 10.6
    },
    3: {
        0.995: 0.07,
        0.99: 0.11,
        0.975: 0.22,
        0.95: 0.35,
        0.9: 0.58,
        0.5: 2.37,
        0.1: 6.25,
        0.05: 7.81,
        0.025: 9.35,
        0.01: 11.34,
        0.005: 12.84
    },
    4: {
        0.995: 0.21,
        0.99: 0.3,
        0.975: 0.48,
        0.95: 0.71,
        0.9: 1.06,
        0.5: 3.36,
        0.1: 7.78,
        0.05: 9.49,
        0.025: 11.14,
        0.01: 13.28,
        0.005: 14.86
    },
    5: {
        0.995: 0.41,
        0.99: 0.55,
        0.975: 0.83,
        0.95: 1.15,
        0.9: 1.61,
        0.5: 4.35,
        0.1: 9.24,
        0.05: 11.07,
        0.025: 12.83,
        0.01: 15.09,
        0.005: 16.75
    },
    6: {
        0.995: 0.68,
        0.99: 0.87,
        0.975: 1.24,
        0.95: 1.64,
        0.9: 2.2,
        0.5: 5.35,
        0.1: 10.65,
        0.05: 12.59,
        0.025: 14.45,
        0.01: 16.81,
        0.005: 18.55
    },
    7: {
        0.995: 0.99,
        0.99: 1.25,
        0.975: 1.69,
        0.95: 2.17,
        0.9: 2.83,
        0.5: 6.35,
        0.1: 12.02,
        0.05: 14.07,
        0.025: 16.01,
        0.01: 18.48,
        0.005: 20.28
    },
    8: {
        0.995: 1.34,
        0.99: 1.65,
        0.975: 2.18,
        0.95: 2.73,
        0.9: 3.49,
        0.5: 7.34,
        0.1: 13.36,
        0.05: 15.51,
        0.025: 17.53,
        0.01: 20.09,
        0.005: 21.96
    },
    9: {
        0.995: 1.73,
        0.99: 2.09,
        0.975: 2.7,
        0.95: 3.33,
        0.9: 4.17,
        0.5: 8.34,
        0.1: 14.68,
        0.05: 16.92,
        0.025: 19.02,
        0.01: 21.67,
        0.005: 23.59
    },
    10: {
        0.995: 2.16,
        0.99: 2.56,
        0.975: 3.25,
        0.95: 3.94,
        0.9: 4.87,
        0.5: 9.34,
        0.1: 15.99,
        0.05: 18.31,
        0.025: 20.48,
        0.01: 23.21,
        0.005: 25.19
    },
    11: {
        0.995: 2.6,
        0.99: 3.05,
        0.975: 3.82,
        0.95: 4.57,
        0.9: 5.58,
        0.5: 10.34,
        0.1: 17.28,
        0.05: 19.68,
        0.025: 21.92,
        0.01: 24.72,
        0.005: 26.76
    },
    12: {
        0.995: 3.07,
        0.99: 3.57,
        0.975: 4.4,
        0.95: 5.23,
        0.9: 6.3,
        0.5: 11.34,
        0.1: 18.55,
        0.05: 21.03,
        0.025: 23.34,
        0.01: 26.22,
        0.005: 28.3
    },
    13: {
        0.995: 3.57,
        0.99: 4.11,
        0.975: 5.01,
        0.95: 5.89,
        0.9: 7.04,
        0.5: 12.34,
        0.1: 19.81,
        0.05: 22.36,
        0.025: 24.74,
        0.01: 27.69,
        0.005: 29.82
    },
    14: {
        0.995: 4.07,
        0.99: 4.66,
        0.975: 5.63,
        0.95: 6.57,
        0.9: 7.79,
        0.5: 13.34,
        0.1: 21.06,
        0.05: 23.68,
        0.025: 26.12,
        0.01: 29.14,
        0.005: 31.32
    },
    15: {
        0.995: 4.6,
        0.99: 5.23,
        0.975: 6.27,
        0.95: 7.26,
        0.9: 8.55,
        0.5: 14.34,
        0.1: 22.31,
        0.05: 25,
        0.025: 27.49,
        0.01: 30.58,
        0.005: 32.8
    },
    16: {
        0.995: 5.14,
        0.99: 5.81,
        0.975: 6.91,
        0.95: 7.96,
        0.9: 9.31,
        0.5: 15.34,
        0.1: 23.54,
        0.05: 26.3,
        0.025: 28.85,
        0.01: 32,
        0.005: 34.27
    },
    17: {
        0.995: 5.7,
        0.99: 6.41,
        0.975: 7.56,
        0.95: 8.67,
        0.9: 10.09,
        0.5: 16.34,
        0.1: 24.77,
        0.05: 27.59,
        0.025: 30.19,
        0.01: 33.41,
        0.005: 35.72
    },
    18: {
        0.995: 6.26,
        0.99: 7.01,
        0.975: 8.23,
        0.95: 9.39,
        0.9: 10.87,
        0.5: 17.34,
        0.1: 25.99,
        0.05: 28.87,
        0.025: 31.53,
        0.01: 34.81,
        0.005: 37.16
    },
    19: {
        0.995: 6.84,
        0.99: 7.63,
        0.975: 8.91,
        0.95: 10.12,
        0.9: 11.65,
        0.5: 18.34,
        0.1: 27.2,
        0.05: 30.14,
        0.025: 32.85,
        0.01: 36.19,
        0.005: 38.58
    },
    20: {
        0.995: 7.43,
        0.99: 8.26,
        0.975: 9.59,
        0.95: 10.85,
        0.9: 12.44,
        0.5: 19.34,
        0.1: 28.41,
        0.05: 31.41,
        0.025: 34.17,
        0.01: 37.57,
        0.005: 40
    },
    21: {
        0.995: 8.03,
        0.99: 8.9,
        0.975: 10.28,
        0.95: 11.59,
        0.9: 13.24,
        0.5: 20.34,
        0.1: 29.62,
        0.05: 32.67,
        0.025: 35.48,
        0.01: 38.93,
        0.005: 41.4
    },
    22: {
        0.995: 8.64,
        0.99: 9.54,
        0.975: 10.98,
        0.95: 12.34,
        0.9: 14.04,
        0.5: 21.34,
        0.1: 30.81,
        0.05: 33.92,
        0.025: 36.78,
        0.01: 40.29,
        0.005: 42.8
    },
    23: {
        0.995: 9.26,
        0.99: 10.2,
        0.975: 11.69,
        0.95: 13.09,
        0.9: 14.85,
        0.5: 22.34,
        0.1: 32.01,
        0.05: 35.17,
        0.025: 38.08,
        0.01: 41.64,
        0.005: 44.18
    },
    24: {
        0.995: 9.89,
        0.99: 10.86,
        0.975: 12.4,
        0.95: 13.85,
        0.9: 15.66,
        0.5: 23.34,
        0.1: 33.2,
        0.05: 36.42,
        0.025: 39.36,
        0.01: 42.98,
        0.005: 45.56
    },
    25: {
        0.995: 10.52,
        0.99: 11.52,
        0.975: 13.12,
        0.95: 14.61,
        0.9: 16.47,
        0.5: 24.34,
        0.1: 34.28,
        0.05: 37.65,
        0.025: 40.65,
        0.01: 44.31,
        0.005: 46.93
    },
    26: {
        0.995: 11.16,
        0.99: 12.2,
        0.975: 13.84,
        0.95: 15.38,
        0.9: 17.29,
        0.5: 25.34,
        0.1: 35.56,
        0.05: 38.89,
        0.025: 41.92,
        0.01: 45.64,
        0.005: 48.29
    },
    27: {
        0.995: 11.81,
        0.99: 12.88,
        0.975: 14.57,
        0.95: 16.15,
        0.9: 18.11,
        0.5: 26.34,
        0.1: 36.74,
        0.05: 40.11,
        0.025: 43.19,
        0.01: 46.96,
        0.005: 49.65
    },
    28: {
        0.995: 12.46,
        0.99: 13.57,
        0.975: 15.31,
        0.95: 16.93,
        0.9: 18.94,
        0.5: 27.34,
        0.1: 37.92,
        0.05: 41.34,
        0.025: 44.46,
        0.01: 48.28,
        0.005: 50.99
    },
    29: {
        0.995: 13.12,
        0.99: 14.26,
        0.975: 16.05,
        0.95: 17.71,
        0.9: 19.77,
        0.5: 28.34,
        0.1: 39.09,
        0.05: 42.56,
        0.025: 45.72,
        0.01: 49.59,
        0.005: 52.34
    },
    30: {
        0.995: 13.79,
        0.99: 14.95,
        0.975: 16.79,
        0.95: 18.49,
        0.9: 20.6,
        0.5: 29.34,
        0.1: 40.26,
        0.05: 43.77,
        0.025: 46.98,
        0.01: 50.89,
        0.005: 53.67
    },
    40: {
        0.995: 20.71,
        0.99: 22.16,
        0.975: 24.43,
        0.95: 26.51,
        0.9: 29.05,
        0.5: 39.34,
        0.1: 51.81,
        0.05: 55.76,
        0.025: 59.34,
        0.01: 63.69,
        0.005: 66.77
    },
    50: {
        0.995: 27.99,
        0.99: 29.71,
        0.975: 32.36,
        0.95: 34.76,
        0.9: 37.69,
        0.5: 49.33,
        0.1: 63.17,
        0.05: 67.5,
        0.025: 71.42,
        0.01: 76.15,
        0.005: 79.49
    },
    60: {
        0.995: 35.53,
        0.99: 37.48,
        0.975: 40.48,
        0.95: 43.19,
        0.9: 46.46,
        0.5: 59.33,
        0.1: 74.4,
        0.05: 79.08,
        0.025: 83.3,
        0.01: 88.38,
        0.005: 91.95
    },
    70: {
        0.995: 43.28,
        0.99: 45.44,
        0.975: 48.76,
        0.95: 51.74,
        0.9: 55.33,
        0.5: 69.33,
        0.1: 85.53,
        0.05: 90.53,
        0.025: 95.02,
        0.01: 100.42,
        0.005: 104.22
    },
    80: {
        0.995: 51.17,
        0.99: 53.54,
        0.975: 57.15,
        0.95: 60.39,
        0.9: 64.28,
        0.5: 79.33,
        0.1: 96.58,
        0.05: 101.88,
        0.025: 106.63,
        0.01: 112.33,
        0.005: 116.32
    },
    90: {
        0.995: 59.2,
        0.99: 61.75,
        0.975: 65.65,
        0.95: 69.13,
        0.9: 73.29,
        0.5: 89.33,
        0.1: 107.57,
        0.05: 113.14,
        0.025: 118.14,
        0.01: 124.12,
        0.005: 128.3
    },
    100: {
        0.995: 67.33,
        0.99: 70.06,
        0.975: 74.22,
        0.95: 77.93,
        0.9: 82.36,
        0.5: 99.33,
        0.1: 118.5,
        0.05: 124.34,
        0.025: 129.56,
        0.01: 135.81,
        0.005: 140.17
    }
};

/**
 * The [2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
 * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
 * (that is, counts of observations), each squared and divided by the number of observations expected given the
 * hypothesized distribution. The resulting 2 statistic, `chiSquared`, can be compared to the chi-squared distribution
 * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
 * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
 * follows, approximately, a chi-square distribution with (k  c) degrees of freedom where `k` is the number of non-empty
 * cells and `c` is the number of estimated parameters for the distribution.
 *
 * @param {Array<number>} data
 * @param {Function} distributionType a function that returns a point in a distribution:
 * for instance, binomial, bernoulli, or poisson
 * @param {number} significance
 * @returns {number} chi squared goodness of fit
 * @example
 * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
 * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
 * var data1019 = [
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 *     2, 2, 2, 2, 2, 2, 2, 2, 2,
 *     3, 3, 3, 3
 * ];
 * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05); //= false
 */
function chiSquaredGoodnessOfFit(data, distributionType, significance) {
    // Estimate from the sample data, a weighted mean.
    var inputMean = mean(data);
    // Calculated value of the 2 statistic.
    var chiSquared = 0;
    // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
    // Lose one degree of freedom for estimating `lambda` from the sample data.
    var c = 1;
    // The hypothesized distribution.
    // Generate the hypothesized distribution.
    var hypothesizedDistribution = distributionType(inputMean);
    var observedFrequencies = [];
    var expectedFrequencies = [];

    // Create an array holding a histogram from the sample data, of
    // the form `{ value: numberOfOcurrences }`
    for (var i = 0; i < data.length; i++) {
        if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0;
        }
        observedFrequencies[data[i]]++;
    }

    // The histogram we created might be sparse - there might be gaps
    // between values. So we iterate through the histogram, making
    // sure that instead of undefined, gaps have 0 values.
    for (var i$1 = 0; i$1 < observedFrequencies.length; i$1++) {
        if (observedFrequencies[i$1] === undefined) {
            observedFrequencies[i$1] = 0;
        }
    }

    // Create an array holding a histogram of expected data given the
    // sample size and hypothesized distribution.
    for (var k in hypothesizedDistribution) {
        if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length;
        }
    }

    // Working backward through the expected frequencies, collapse classes
    // if less than three observations are expected for a class.
    // This transformation is applied to the observed frequencies as well.
    for (var k$1 = expectedFrequencies.length - 1; k$1 >= 0; k$1--) {
        if (expectedFrequencies[k$1] < 3) {
            expectedFrequencies[k$1 - 1] += expectedFrequencies[k$1];
            expectedFrequencies.pop();

            observedFrequencies[k$1 - 1] += observedFrequencies[k$1];
            observedFrequencies.pop();
        }
    }

    // Iterate through the squared differences between observed & expected
    // frequencies, accumulating the `chiSquared` statistic.
    for (var k$2 = 0; k$2 < observedFrequencies.length; k$2++) {
        chiSquared +=
            Math.pow(observedFrequencies[k$2] - expectedFrequencies[k$2], 2) /
            expectedFrequencies[k$2];
    }

    // Calculate degrees of freedom for this test and look it up in the
    // `chiSquaredDistributionTable` in order to
    // accept or reject the goodness-of-fit of the hypothesized distribution.
    // Degrees of freedom, calculated as (number of class intervals -
    // number of hypothesized distribution parameters estimated - 1)
    var degreesOfFreedom = observedFrequencies.length - c - 1;
    return (
        chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
    );
}

var SQRT_2PI$1 = Math.sqrt(2 * Math.PI);

/**
 * [Well-known kernels](https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use)
 * @private
 */
var kernels = {
    /**
     * The gaussian kernel.
     * @private
     */
    gaussian: function (u) {
        return Math.exp(-0.5 * u * u) / SQRT_2PI$1;
    }
};

/**
 * Well known bandwidth selection methods
 * @private
 */
var bandwidthMethods = {
    /**
     * The ["normal reference distribution"
     * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),
     * a commonly used version of [Silverman's
     * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).
     * @private
     */
    nrd: function (x) {
        var s = sampleStandardDeviation(x);
        var iqr = interquartileRange(x);
        if (typeof iqr === "number") {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(x.length, -0.2);
    }
};

/**
 * [Kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)
 * is a useful tool for, among other things, estimating the shape of the
 * underlying probability distribution from a sample.
 *
 * @name kernelDensityEstimation
 * @param X sample values
 * @param kernel The kernel function to use. If a function is provided, it should return non-negative values and integrate to 1. Defaults to 'gaussian'.
 * @param bandwidthMethod The "bandwidth selection" method to use, or a fixed bandwidth value. Defaults to "nrd", the commonly-used ["normal reference distribution" rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html).
 * @returns {Function} An estimated [probability density function](https://en.wikipedia.org/wiki/Probability_density_function) for the given sample. The returned function runs in `O(X.length)`.
 */
function kernelDensityEstimation(X, kernel, bandwidthMethod) {
    var kernelFn;
    if (kernel === undefined) {
        kernelFn = kernels.gaussian;
    } else if (typeof kernel === "string") {
        if (!kernels[kernel]) {
            throw new Error('Unknown kernel "' + kernel + '"');
        }
        kernelFn = kernels[kernel];
    } else {
        kernelFn = kernel;
    }

    var bandwidth;
    if (typeof bandwidthMethod === "undefined") {
        bandwidth = bandwidthMethods.nrd(X);
    } else if (typeof bandwidthMethod === "string") {
        if (!bandwidthMethods[bandwidthMethod]) {
            throw new Error(
                'Unknown bandwidth method "' + bandwidthMethod + '"'
            );
        }
        bandwidth = bandwidthMethods[bandwidthMethod](X);
    } else {
        bandwidth = bandwidthMethod;
    }

    return function (x) {
        var i = 0;
        var sum = 0;
        for (i = 0; i < X.length; i++) {
            sum += kernelFn((x - X[i]) / bandwidth);
        }
        return sum / bandwidth / X.length;
    };
}

/**
 * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
 *
 * The standard score is the number of standard deviations an observation
 * or datum is above or below the mean. Thus, a positive standard score
 * represents a datum above the mean, while a negative standard score
 * represents a datum below the mean. It is a dimensionless quantity
 * obtained by subtracting the population mean from an individual raw
 * score and then dividing the difference by the population standard
 * deviation.
 *
 * The z-score is only defined if one knows the population parameters;
 * if one only has a sample set, then the analogous computation with
 * sample mean and sample standard deviation yields the
 * Student's t-statistic.
 *
 * @param {number} x
 * @param {number} mean
 * @param {number} standardDeviation
 * @return {number} z score
 * @example
 * zScore(78, 80, 5); // => -0.4
 */
function zScore(x, mean, standardDeviation) {
    return (x - mean) / standardDeviation;
}

var SQRT_2PI = Math.sqrt(2 * Math.PI);

function cumulativeDistribution(z) {
    var sum = z;
    var tmp = z;

    // 15 iterations are enough for 4-digit precision
    for (var i = 1; i < 15; i++) {
        tmp *= (z * z) / (2 * i + 1);
        sum += tmp;
    }
    return (
        Math.round((0.5 + (sum / SQRT_2PI) * Math.exp((-z * z) / 2)) * 1e4) /
        1e4
    );
}

/**
 * A standard normal table, also called the unit normal table or Z table,
 * is a mathematical table for the values of  (phi), which are the values of
 * the [cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function)
 * of the normal distribution. It is used to find the probability that a
 * statistic is observed below, above, or between values on the standard
 * normal distribution, and by extension, any normal distribution.
 */
var standardNormalTable = [];

for (var z = 0; z <= 3.09; z += 0.01) {
    standardNormalTable.push(cumulativeDistribution(z));
}

/**
 * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
 *
 * Since probability tables cannot be
 * printed for every normal distribution, as there are an infinite variety
 * of normal distributions, it is common practice to convert a normal to a
 * standard normal and then use the standard normal table to find probabilities.
 *
 * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
 * instead of looking it up in a table.
 *
 * @param {number} z
 * @returns {number} cumulative standard normal probability
 */
function cumulativeStdNormalProbability(z) {
    // Calculate the position of this value.
    var absZ = Math.abs(z);
    // Each row begins with a different
    // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
    // corresponds to a range of 0.01 in the input values, so the value is
    // multiplied by 100.
    var index = Math.min(
        Math.round(absZ * 100),
        standardNormalTable.length - 1
    );

    // The index we calculate must be in the table as a positive value,
    // but we still pay attention to whether the input is positive
    // or negative, and flip the output value as a last step.
    if (z >= 0) {
        return standardNormalTable[index];
    } else {
        // due to floating-point arithmetic, values in the table with
        // 4 significant figures can nevertheless end up as repeating
        // fractions when they're computed here.
        return Math.round((1 - standardNormalTable[index]) * 1e4) / 1e4;
    }
}

/**
 * **[Logistic Cumulative Distribution Function](https://en.wikipedia.org/wiki/Logistic_distribution)**
 *
 * @param {number} x
 * @returns {number} cumulative standard logistic probability
 */
function cumulativeStdLogisticProbability(x) {
    return 1 / (Math.exp(-x) + 1);
}

/**
 * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
 *
 * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
 * normal distribution with standard deviation sd is within x of the mean.
 *
 * This function returns a numerical approximation to the exact value.
 * It uses Horner's method to evaluate the polynomial of  (tau).
 *
 * @param {number} x input
 * @return {number} error estimation
 * @example
 * errorFunction(1).toFixed(2); // => '0.84'
 */
function errorFunction(x) {
    var t = 1 / (1 + 0.5 * Math.abs(x));
    var tau =
        t *
        Math.exp(
            -x * x +
                ((((((((0.17087277 * t - 0.82215223) * t + 1.48851587) * t -
                    1.13520398) *
                    t +
                    0.27886807) *
                    t -
                    0.18628806) *
                    t +
                    0.09678418) *
                    t +
                    0.37409196) *
                    t +
                    1.00002368) *
                    t -
                1.26551223
        );
    if (x >= 0) {
        return 1 - tau;
    } else {
        return tau - 1;
    }
}

/**
 * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
 * returns a numerical approximation to the value that would have caused
 * `errorFunction()` to return x.
 *
 * @param {number} x value of error function
 * @returns {number} estimated inverted value
 */
function inverseErrorFunction(x) {
    var a = (8 * (Math.PI - 3)) / (3 * Math.PI * (4 - Math.PI));

    var inv = Math.sqrt(
        Math.sqrt(
            Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) -
                Math.log(1 - x * x) / a
        ) -
            (2 / (Math.PI * a) + Math.log(1 - x * x) / 2)
    );

    if (x >= 0) {
        return inv;
    } else {
        return -inv;
    }
}

/**
 * The [Probit](http://en.wikipedia.org/wiki/Probit)
 * is the inverse of cumulativeStdNormalProbability(),
 * and is also known as the normal quantile function.
 *
 * It returns the number of standard deviations from the mean
 * where the p'th quantile of values can be found in a normal distribution.
 * So, for example, probit(0.5 + 0.6827/2)  1 because 68.27% of values are
 * normally found within 1 standard deviation above or below the mean.
 *
 * @param {number} p
 * @returns {number} probit
 */
function probit(p) {
    if (p === 0) {
        p = epsilon;
    } else if (p >= 1) {
        p = 1 - epsilon;
    }
    return Math.sqrt(2) * inverseErrorFunction(2 * p - 1);
}

/**
 * The [Logit](https://en.wikipedia.org/wiki/Logit)
 * is the inverse of cumulativeStdLogisticProbability,
 * and is also known as the logistic quantile function.
 *
 * @param {number} p
 * @returns {number} logit
 */
function logit(p) {
    if (p <= 0 || p >= 1) {
        throw new Error("p must be strictly between zero and one");
    }
    return Math.log(p / (1 - p));
}

/**
 * Conducts a [permutation test](https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests)
 * to determine if two data sets are *significantly* different from each other, using
 * the difference of means between the groups as the test statistic.
 * The function allows for the following hypotheses:
 * - two_tail = Null hypothesis: the two distributions are equal.
 * - greater = Null hypothesis: observations from sampleX tend to be smaller than those from sampleY.
 * - less = Null hypothesis: observations from sampleX tend to be greater than those from sampleY.
 * [Learn more about one-tail vs two-tail tests.](https://en.wikipedia.org/wiki/One-_and_two-tailed_tests)
 *
 * @param {Array<number>} sampleX first dataset (e.g. treatment data)
 * @param {Array<number>} sampleY second dataset (e.g. control data)
 * @param {string} alternative alternative hypothesis, either 'two_sided' (default), 'greater', or 'less'
 * @param {number} k number of values in permutation distribution.
 * @param {Function} [randomSource=Math.random] an optional entropy source
 * @returns {number} p-value The probability of observing the difference between groups (as or more extreme than what we did), assuming the null hypothesis.
 *
 * @example
 * var control = [2, 5, 3, 6, 7, 2, 5];
 * var treatment = [20, 5, 13, 12, 7, 2, 2];
 * permutationTest(control, treatment); // ~0.1324
 */
function permutationTest(sampleX, sampleY, alternative, k, randomSource) {
    // Set default arguments
    if (k === undefined) {
        k = 10000;
    }
    if (alternative === undefined) {
        alternative = "two_side";
    }
    if (
        alternative !== "two_side" &&
        alternative !== "greater" &&
        alternative !== "less"
    ) {
        throw new Error(
            "`alternative` must be either 'two_side', 'greater', or 'less'."
        );
    }

    // get means for each sample
    var meanX = mean(sampleX);
    var meanY = mean(sampleY);

    // calculate initial test statistic. This will be our point of comparison with
    // the generated test statistics.
    var testStatistic = meanX - meanY;

    // create test-statistic distribution
    var testStatDsn = new Array(k);

    // combine datsets so we can easily shuffle later
    var allData = sampleX.concat(sampleY);
    var midIndex = Math.floor(allData.length / 2);

    for (var i = 0; i < k; i++) {
        // 1. shuffle data assignments
        shuffleInPlace(allData, randomSource);
        var permLeft = allData.slice(0, midIndex);
        var permRight = allData.slice(midIndex, allData.length);

        // 2.re-calculate test statistic
        var permTestStatistic = mean(permLeft) - mean(permRight);

        // 3. store test statistic to build test statistic distribution
        testStatDsn[i] = permTestStatistic;
    }

    // Calculate p-value depending on alternative
    // For this test, we calculate the percentage of 'extreme' test statistics (subject to our hypothesis)
    // more info on permutation test p-value calculations: https://onlinecourses.science.psu.edu/stat464/node/35
    var numExtremeTStats = 0;
    if (alternative === "two_side") {
        for (var i$1 = 0; i$1 <= k; i$1++) {
            if (Math.abs(testStatDsn[i$1]) >= Math.abs(testStatistic)) {
                numExtremeTStats += 1;
            }
        }
    } else if (alternative === "greater") {
        for (var i$2 = 0; i$2 <= k; i$2++) {
            if (testStatDsn[i$2] >= testStatistic) {
                numExtremeTStats += 1;
            }
        }
    } else {
        // alternative === 'less'
        for (var i$3 = 0; i$3 <= k; i$3++) {
            /* c8 ignore start */
            if (testStatDsn[i$3] <= testStatistic) {
                numExtremeTStats += 1;
            }
            /* c8 ignore end */
        }
    }

    return numExtremeTStats / k;
}

/**
 * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
 * that extracts the sign of a real number
 *
 * @param {number} x input value
 * @returns {number} sign value either 1, 0 or -1
 * @throws {TypeError} if the input argument x is not a number
 * @private
 *
 * @example
 * sign(2); // => 1
 */
function sign(x) {
    if (typeof x === "number") {
        if (x < 0) {
            return -1;
        } else if (x === 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        throw new TypeError("not a number");
    }
}

/**
 * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
 * method that repeatedly bisects an interval to find the root.
 *
 * This function returns a numerical approximation to the exact value.
 *
 * @param {Function} func input function
 * @param {number} start - start of interval
 * @param {number} end - end of interval
 * @param {number} maxIterations - the maximum number of iterations
 * @param {number} errorTolerance - the error tolerance
 * @returns {number} estimated root value
 * @throws {TypeError} Argument func must be a function
 *
 * @example
 * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
 */
function bisect(func, start, end, maxIterations, errorTolerance) {
    if (typeof func !== "function")
        { throw new TypeError("func must be a function"); }

    for (var i = 0; i < maxIterations; i++) {
        var output = (start + end) / 2;

        if (
            func(output) === 0 ||
            Math.abs((end - start) / 2) < errorTolerance
        ) {
            return output;
        }

        if (sign(func(output)) === sign(func(start))) {
            start = output;
        } else {
            end = output;
        }
    }

    throw new Error("maximum number of iterations exceeded");
}

/**
 * Calculate Euclidean distance between two points.
 * @param {Array<number>} left First N-dimensional point.
 * @param {Array<number>} right Second N-dimensional point.
 * @returns {number} Distance.
 */
function euclideanDistance(left, right) {
    var sum = 0;
    for (var i = 0; i < left.length; i++) {
        var diff = left[i] - right[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

/**
 * @typedef {Object} kMeansReturn
 * @property {Array<number>} labels The labels.
 * @property {Array<Array<number>>} centroids The cluster centroids.
 */

/**
 * Perform k-means clustering.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points to be clustered.
 * @param {number} numCluster How many clusters to create.
 * @param {Function} randomSource An optional entropy source that generates uniform values in [0, 1).
 * @return {kMeansReturn} Labels (same length as data) and centroids (same length as numCluster).
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 *
 * @example
 * kMeansCluster([[0.0, 0.5], [1.0, 0.5]], 2); // => {labels: [0, 1], centroids: [[0.0, 0.5], [1.0 0.5]]}
 */
function kMeansCluster(points, numCluster, randomSource) {
    if ( randomSource === void 0 ) randomSource = Math.random;

    var oldCentroids = null;
    var newCentroids = sample(points, numCluster, randomSource);
    var labels = null;
    var change = Number.MAX_VALUE;
    while (change !== 0) {
        labels = labelPoints(points, newCentroids);
        oldCentroids = newCentroids;
        newCentroids = calculateCentroids(points, labels, numCluster);
        change = calculateChange(newCentroids, oldCentroids);
    }
    return {
        labels: labels,
        centroids: newCentroids
    };
}

/**
 * Label each point according to which centroid it is closest to.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<Array<number>>} centroids Current centroids.
 * @return {Array<number>} Group labels.
 */
function labelPoints(points, centroids) {
    return points.map(function (p) {
        var minDist = Number.MAX_VALUE;
        var label = -1;
        for (var i = 0; i < centroids.length; i++) {
            var dist = euclideanDistance(p, centroids[i]);
            if (dist < minDist) {
                minDist = dist;
                label = i;
            }
        }
        return label;
    });
}

/**
 * Calculate centroids for points given labels.
 *
 * @private
 * @param {Array<Array<number>>} points Array of XY coordinates.
 * @param {Array<number>} labels Which groups points belong to.
 * @param {number} numCluster Number of clusters being created.
 * @return {Array<Array<number>>} Centroid for each group.
 * @throws {Error} If any centroids wind up friendless (i.e., without associated points).
 */
function calculateCentroids(points, labels, numCluster) {
    // Initialize accumulators.
    var dimension = points[0].length;
    var centroids = makeMatrix(numCluster, dimension);
    var counts = Array(numCluster).fill(0);

    // Add points to centroids' accumulators and count points per centroid.
    var numPoints = points.length;
    for (var i = 0; i < numPoints; i++) {
        var point = points[i];
        var label = labels[i];
        var current = centroids[label];
        for (var j = 0; j < dimension; j++) {
            current[j] += point[j];
        }
        counts[label] += 1;
    }

    // Rescale centroids, checking for any that have no points.
    for (var i$1 = 0; i$1 < numCluster; i$1++) {
        if (counts[i$1] === 0) {
            throw new Error(("Centroid " + i$1 + " has no friends"));
        }
        var centroid = centroids[i$1];
        for (var j$1 = 0; j$1 < dimension; j$1++) {
            centroid[j$1] /= counts[i$1];
        }
    }

    return centroids;
}

/**
 * Calculate the difference between old centroids and new centroids.
 *
 * @private
 * @param {Array<Array<number>>} left One list of centroids.
 * @param {Array<Array<number>>} right Another list of centroids.
 * @return {number} Distance between centroids.
 */
function calculateChange(left, right) {
    var total = 0;
    for (var i = 0; i < left.length; i++) {
        total += euclideanDistance(left[i], right[i]);
    }
    return total;
}

/**
 * Calculate the [silhouette values](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for clustered data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<number>} The silhouette value for each point.
 *
 * @example
 * silhouette([[0.25], [0.75]], [0, 0]); // => [1.0, 1.0]
 */
function silhouette(points, labels) {
    if (points.length !== labels.length) {
        throw new Error("must have exactly as many labels as points");
    }
    var groupings = createGroups(labels);
    var distances = calculateAllDistances(points);
    var result = [];
    for (var i = 0; i < points.length; i++) {
        var s = 0;
        if (groupings[labels[i]].length > 1) {
            var a = meanDistanceFromPointToGroup(
                i,
                groupings[labels[i]],
                distances
            );
            var b = meanDistanceToNearestGroup(
                i,
                labels,
                groupings,
                distances
            );
            s = (b - a) / Math.max(a, b);
        }
        result.push(s);
    }
    return result;
}

/**
 * Create a lookup table mapping group IDs to point IDs.
 *
 * @private
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {Array<Array<number>>} An array of length G, each of whose entries is an array
 * containing the indices of the points in that group.
 */
function createGroups(labels) {
    var numGroups = 1 + max(labels);
    var result = Array(numGroups);
    for (var i = 0; i < labels.length; i++) {
        var label = labels[i];
        if (result[label] === undefined) {
            result[label] = [];
        }
        result[label].push(i);
    }
    return result;
}

/**
 * Create a lookup table of all inter-point distances.
 *
 * @private
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @return {Array<Array<number>>} A symmetric square array of inter-point distances
 * (zero on the diagonal).
 */
function calculateAllDistances(points) {
    var numPoints = points.length;
    var result = makeMatrix(numPoints, numPoints);
    for (var i = 0; i < numPoints; i++) {
        for (var j = 0; j < i; j++) {
            result[i][j] = euclideanDistance(points[i], points[j]);
            result[j][i] = result[i][j];
        }
    }
    return result;
}

/**
 * Calculate the mean distance between this point and all the points in the
 * nearest group (as determined by which point in another group is closest).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} labels Labels of points.
 * @param {Array<Array<number>>} groupings An array whose entries are arrays
 * containing the indices of the points in that group.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the nearest
 * group.
 */
function meanDistanceToNearestGroup(which, labels, groupings, distances) {
    var label = labels[which];
    var result = Number.MAX_VALUE;
    for (var i = 0; i < groupings.length; i++) {
        if (i !== label) {
            var d = meanDistanceFromPointToGroup(
                which,
                groupings[i],
                distances
            );
            if (d < result) {
                result = d;
            }
        }
    }
    return result;
}

/**
 * Calculate the mean distance between a point and all the points in a group
 * (possibly its own).
 *
 * @private
 * @param {number} which The index of this point.
 * @param {Array<number>} group The indices of all the points in the group in
 * question.
 * @param {Array<Array<number>>} distances A symmetric square array of inter-point
 * distances.
 * @return {number} The mean distance from this point to others in the
 * specified group.
 */
function meanDistanceFromPointToGroup(which, group, distances) {
    var total = 0;
    for (var i = 0; i < group.length; i++) {
        total += distances[which][group[i]];
    }
    return total / group.length;
}

/**
 * Calculate the [silhouette metric](https://en.wikipedia.org/wiki/Silhouette_(clustering))
 * for a set of N-dimensional points arranged in groups. The metric is the largest
 * individual silhouette value for the data.
 *
 * @param {Array<Array<number>>} points N-dimensional coordinates of points.
 * @param {Array<number>} labels Labels of points. This must be the same length as `points`,
 * and values must lie in [0..G-1], where G is the number of groups.
 * @return {number} The silhouette metric for the groupings.
 *
 * @example
 * silhouetteMetric([[0.25], [0.75]], [0, 0]); // => 1.0
 */
function silhouetteMetric(points, labels) {
    var values = silhouette(points, labels);
    return max(values);
}

/**
 * Relative error.
 *
 * This is more difficult to calculate than it first appears [1,2].  The usual
 * formula for the relative error between an actual value A and an expected
 * value E is `|(A-E)/E|`, but:
 *
 * 1. If the expected value is 0, any other value has infinite relative error,
 *    which is counter-intuitive: if the expected voltage is 0, getting 1/10th
 *    of a volt doesn't feel like an infinitely large error.
 *
 * 2. This formula does not satisfy the mathematical definition of a metric [3].
 *    [4] solved this problem by defining the relative error as `|ln(|A/E|)|`,
 *    but that formula only works if all values are positive: for example, it
 *    reports the relative error of -10 and 10 as 0.
 *
 * Our implementation sticks with convention and returns:
 *
 * - 0 if the actual and expected values are both zero
 * - Infinity if the actual value is non-zero and the expected value is zero
 * - `|(A-E)/E|` in all other cases
 *
 * [1] https://math.stackexchange.com/questions/677852/how-to-calculate-relative-error-when-true-value-is-zero
 * [2] https://en.wikipedia.org/wiki/Relative_change_and_difference
 * [3] https://en.wikipedia.org/wiki/Metric_(mathematics)#Definition
 * [4] F.W.J. Olver: "A New Approach to Error Arithmetic." SIAM Journal on
 *     Numerical Analysis, 15(2), 1978, 10.1137/0715024.
 *
 * @param {number} actual The actual value.
 * @param {number} expected The expected value.
 * @return {number} The relative error.
 */
function relativeError(actual, expected) {
    // These lines are actually covered by tests, but it seems
    // like c8 has a bug that marks them as not covered.
    /* c8 ignore start */
    if (actual === 0 && expected === 0) {
        return 0;
    }
    /* c8 ignore end */
    return Math.abs((actual - expected) / expected);
}

/**
 * Approximate equality.
 *
 * @param {number} actual The value to be tested.
 * @param {number} expected The reference value.
 * @param {number} tolerance The acceptable relative difference.
 * @return {boolean} Whether numbers are within tolerance.
 */
function approxEqual(actual, expected, tolerance) {
    if ( tolerance === void 0 ) tolerance = epsilon;

    return relativeError(actual, expected) <= tolerance;
}


//# sourceMappingURL=simple-statistics.mjs.map


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"eurostat-map","version":"4.1.64","description":"Reusable library to quickly create and customise web maps showing Eurostat data directly retrieved from Eurostat database.","keywords":["eurostat","statistics","europe","SVG","NUTS","map","D3","cartography","thematic","mapping","eurostat-map","dataviz","data visualization"],"homepage":"https://github.com/eurostat/eurostat-map","author":"","license":"EUPL-1.2","repository":{"type":"git","url":"https://github.com/eurostat/eurostat-map.git"},"main":"build/eurostatmap.min.js","unpkg":"build/eurostatmap.min.js","files":["build"],"scripts":{"start":"webpack --config webpack/webpack.config.dev.js","server":"webpack-dev-server --open --watch","build-prod":"webpack --config webpack/webpack.config.prod.js","build-prod-debug":"webpack --config webpack/webpack.config.debug-size.js","format":"prettier --write .","test":"jest"},"dependencies":{"colorbrewer":"^1.3.0","d3":"^7.8.5","d3-geo-projection":"^3.0.0","d3-sankey":"^0.12.3","d3-svg-annotation":"^2.5.1","jsonstat-toolkit":"^1.0.8","simple-statistics":"^7.8.7","topojson-client":"^3.1.0"},"overrides":{"d3-color":"3.1.0"},"devDependencies":{"@babel/core":"^7.22.6","@babel/plugin-transform-runtime":"^7.22.6","@babel/preset-env":"^7.22.6","@babel/runtime":"^7.12.1","babel-loader":"^9.1.2","css-loader":"^7.1.2","prettier":"^3.4.1","style-loader":"^4.0.0","webpack":"^5.88.1","webpack-bundle-analyzer":"^4.10.2","webpack-cli":"^5.0.0","webpack-dev-server":"^4.15.1","webpack-livereload-plugin":"^3.0.2"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultLabels: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getDefaultLabels),
/* harmony export */   getFillPatternDefinitionFunction: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.getFillPatternDefinitionFunction),
/* harmony export */   map: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.map),
/* harmony export */   version: () => (/* reexport safe */ _eurostat_map__WEBPACK_IMPORTED_MODULE_1__.version)
/* harmony export */ });
/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/index.css */ "./src/css/index.css");
/* harmony import */ var _eurostat_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eurostat-map */ "./src/eurostat-map.js");


//export { statData } from "./core/stat-data.js";

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlGQUF5RixNQUFNLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxVQUFVLE1BQU0sWUFBWSxPQUFPLFlBQVksTUFBTSxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxPQUFPLFlBQVksT0FBTyxVQUFVLFVBQVUsT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssVUFBVSxPQUFPLE1BQU0sVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QTtBQUNBLDZCQUE2QixxREFBUTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxvREFBTTs7QUFFcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdC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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUksRUFBRTtBQUNoQyxpQkFBaUIsV0FBVyxFQUFFLFdBQVcsUUFBUSxJQUFJLEVBQUU7QUFDdkQsaUJBQWlCLFdBQVcsRUFBRSxXQUFXLFFBQVEsSUFBSSxFQUFFO0FBQ3ZELGlCQUFpQixXQUFXLEVBQUUsV0FBVyxRQUFRLElBQUksRUFBRSxHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUksRUFBRTtBQUNoQyxpQkFBaUIsV0FBVyxFQUFFLFdBQVcsUUFBUSxJQUFJLEVBQUU7QUFDdkQsaUJBQWlCLFdBQVcsRUFBRSxXQUFXLFFBQVEsSUFBSSxFQUFFO0FBQ3ZELGlCQUFpQixXQUFXLEVBQUUsV0FBVyxRQUFRLElBQUksRUFBRSxHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUksRUFBRTtBQUNoQyxpQkFBaUIsV0FBVyxFQUFFLFdBQVcsUUFBUSxJQUFJLEVBQUU7QUFDdkQsaUJBQWlCLFdBQVcsRUFBRSxXQUFXLFFBQVEsSUFBSSxFQUFFO0FBQ3ZELGlCQUFpQixXQUFXLEVBQUUsV0FBVyxRQUFRLElBQUksRUFBRSxHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBTSxXQUFXLGtEQUFNO0FBQ3ZCO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsb0JBQW9CLGlCQUFpQjtB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Q25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRTJqRDtBQUMzakQ7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDcDRJQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0F3QjtBQUNNO0FBQzlCLFdBQVcsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvTlVUUy5jc3MiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY3NzL2Fubm90YXRpb25zLmNzcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3MvaW5kZXguY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9sYWJlbHMuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9sZWdlbmQuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9tYXAuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy90b29sdGlwLmNzcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jc3Mvd29ybGQuY3NzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvY3Jvc3MuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Rlc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2RldmlhdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9oaXN0b2dyYW0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWFuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWRpYW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lcmdlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcGFpcnMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3Blcm11dGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1YW50aWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9yYW5nZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc2Nhbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc2h1ZmZsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc3VtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvZnJlZWRtYW5EaWFjb25pcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGhyZXNob2xkL3Njb3R0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvc3R1cmdlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGlja3MuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdmFyaWFuY2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3ppcC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvcm9iaW5zb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9hZGRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NhcnRlc2lhbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NlbnRyb2lkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2lyY2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9hbnRpbWVyaWRpYW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvY2lyY2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvbGluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvcmVjdGFuZ2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9yZWpvaW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jb21wb3NlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9ncmF0aWN1bGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9ub29wLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9hcmVhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9ib3VuZHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2NlbnRyb2lkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9jb250ZXh0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvbWVhc3VyZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvc3RyaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcG9pbnRFcXVhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BvbHlnb25Db250YWlucy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vZml0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL3Jlc2FtcGxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vaW5kZXhSb2xsdXBOZXh0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvc3JjL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvZHJhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2RyYWcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLWRyYWcvc3JjL25vZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY3JlYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbG9jYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tb3VzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NhbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NsYXNzZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Nsb25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXRhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXR1bS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VhY2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VtcHR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbnRlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZXhpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9odG1sLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5zZXJ0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9qb2luLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9sb3dlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb3JkZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3Byb3BlcnR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yYWlzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmVtb3ZlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2l6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc29ydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3BhcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3RvckFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zb3VyY2VFdmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy90b3VjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy90b3VjaGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmVhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2Jhc2lzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpc09wZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9idW5kbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2FyZGluYWxPcGVuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tT3Blbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhckNsb3NlZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL21vbm90b25lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbmF0dXJhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL3JhZGlhbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL3N0ZXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvZXhwYW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb2Zmc2V0L25vbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvc2lsaG91ZXR0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC93aWdnbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9hc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvaW5zaWRlT3V0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvbm9uZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9waWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zdmctYW5ub3RhdGlvbi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3JhZGlhbEFyZWEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9yYWRpYWxMaW5lLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3RhY2suanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2Nyb3NzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXN2Zy1hbm5vdGF0aW9uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3N0YXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc3ZnLWFubm90YXRpb24vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2Nzcy9pbmRleC5jc3M/ZjdlYSIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmJveC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2ZlYXR1cmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9tZXNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbmVpZ2hib3JzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9yZXZlcnNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvc3RpdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdW50cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS9hbm5vdGF0aW9ucy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2NhcnRvZ3JhbXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvY29yZS9kZXByZWNhdGVkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvZ2VvbWV0cmllcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2luc2V0cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2tvc292by5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL2xhYmVscy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL21hcC10ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3BhdHRlcm4tZmlsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3N0YW1wcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3N0YXQtZGF0YS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9jb3JlL3N0YXQtbWFwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2NvcmUvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvZXVyb3N0YXQtbWFwLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtY2F0ZWdvcmljYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLWJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGgtdHJpdmFyaWF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1mbG93LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcGF0dGVybi1maWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcGllY2hhcnRzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL2xlZ2VuZC9sZWdlbmQtcHJvcG9ydGlvbmFsLXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC1zdHJpcGUtY29tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbGVnZW5kL2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9tYXB0eXBlcy9tYXAtY2F0ZWdvcmljYWwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWNob3JvcGxldGgtYml2YXJpYXRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vc3JjL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLXRyaXZhcmlhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWNob3JvcGxldGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLWZsb3cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXBpZWNoYXJ0cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXNwYXJrbGluZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9zcmMvbWFwdHlwZXMvbWFwLXN0cmlwZS1jb21wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy90b29sdGlwL3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtYXhpcy9zcmMvYXhpcy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1heGlzL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2RlZmluZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvbGFiLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2RyYWcuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Nzdi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL3Rzdi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1lYXNlL3NyYy9jdWJpYy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvZHN2LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZldGNoL3NyYy9qc29uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZldGNoL3NyYy90ZXh0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb2xsaWRlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvamlnZ2xlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9sY2cuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3NpbXVsYXRpb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9kZWZhdWx0TG9jYWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZXhwb25lbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXREZWNpbWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0R3JvdXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXROdW1lcmFscy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFByZWZpeEF1dG8uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRSb3VuZGVkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0U3BlY2lmaWVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHJpbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFR5cGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9wcmVjaXNpb25GaXhlZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvblByZWZpeC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvblJvdW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2RhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2xhYi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvb2JqZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JnYi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2RlY29tcG9zZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3ZhbHVlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy96b29tLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2FkZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvY292ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2RhdGEuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZmluZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZHRyZWUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcm9vdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvc2l6ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvdmlzaXQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0QWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9jYXRlZ29yaWNhbC9TZXQzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlLWNocm9tYXRpYy9zcmMvY2F0ZWdvcmljYWwvY2F0ZWdvcnkxMC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL2NvbG9ycy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS1jaHJvbWF0aWMvc3JjL3JhbXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9zZXF1ZW50aWFsLW11bHRpL09yUmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL3NyYy9zZXF1ZW50aWFsLW11bHRpL1lsR25CdS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2dyZWF0ZXN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4SW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW5JbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3Blcm11dGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1aWNrc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9zb3J0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGlja3MuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2JhbmQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb250aW51b3VzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pbml0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9saW5lYXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvb3JkaW5hbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcG93LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RocmVzaG9sZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGlja0Zvcm1hdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2FycmF5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9wb2ludGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2FwcGVuZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9hdHRyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NhbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xhc3NlZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbG9uZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXRhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2RhdHVtLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VhY2guanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW1wdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW50ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZXhpdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaHRtbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vam9pbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9sb3dlci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2RlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGVzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29yZGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3Byb3BlcnR5LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JhaXNlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkcmVuLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NpemUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc29ydC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3JBbGwuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zb3VyY2VFdmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJjLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmVhLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2J1bXAuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2xpbmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2xpbmsuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3BpZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3BvaW50UmFkaWFsLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9hc3Rlcmlzay5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2Nyb3NzLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvZGlhbW9uZC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvcGx1cy5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3NxdWFyZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3NxdWFyZTIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zdGFyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdGltZXMuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC90cmlhbmdsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3RyaWFuZ2xlMi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3d5ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZW91dC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZXIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvc2VsZWN0aW9uL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9hdHRyVHdlZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9kZWxheS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZWFzZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2VWYXJ5aW5nLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZmlsdGVyLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL21lcmdlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vb24uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zY2hlZHVsZS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0VHdlZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdHdlZW4uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9pbnRlcm5tYXAvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2V1cm9zdGF0bWFwLy4vbm9kZV9tb2R1bGVzL2pzb25zdGF0LXRvb2xraXQvaW1wb3J0Lm1qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL25vZGVfbW9kdWxlcy9zaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1qcyIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZXVyb3N0YXRtYXAvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2V1cm9zdGF0bWFwL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9ldXJvc3RhdG1hcC8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJldXJvc3RhdG1hcFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJldXJvc3RhdG1hcFwiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAiLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLyogU1RZTElORyBPRiBOVVRTIFJFR0lPTlMgQU5EIEJPVU5EQVJJRVMgKi9cclxuLyogRGVmYXVsdCByZWdpb24gZmlsbCAqL1xyXG4uZW0tY250cmcsXHJcbi5lbS1udXRzcmcsXHJcbi5lbS1ncmlkLWNlbGwge1xyXG4gICAgZmlsbDogI2UxZTFlMTtcclxufVxyXG5cclxuLmVtLW51dHNyZyxcclxuLmVtLWNudHJnLFxyXG4uZW0tZ3JpZC1jZWxsLFxyXG4jZW0tdXNlci1yZWdpb25zIHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5cclxuLyogIGJvdW5kYXJpZXMgc3Ryb2tlLXdpZHRoICovXHJcbi5lbS1ibi0wIHtcclxuICAgIHN0cm9rZTogbm9uZTtcclxufVxyXG4uZW0tYm4tMSxcclxuLmVtLWJuLTIsXHJcbi5lbS1ibi0zLFxyXG4vKiB3aGVuIHVzaW5nIE1JWEVEIE5VVFMgbGV2ZWxzLCB3ZSBhZGQgc3Ryb2tlIHRvIHRoZSByZWdpb25zLCB0aGVuIHNob3cvaGlkZSB0aG9zZSB0aGF0IGhhdmUvZG9udCBoYXZlIGRhdGEgKi9cclxuLmVtLW51dHNyZyBbbHZsPSczJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMiddLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzEnXSxcclxuLmVtLWJuLWNvIHtcclxuICAgIHN0cm9rZS13aWR0aDogMC4yO1xyXG59XHJcblxyXG4vKiBhbGwgYm91ZG5hcmllcyBhbmQgcmVnaW9ucyBsaW5lY2FwL2xpbmVqb2luICovXHJcbiNlbS1udXRzYm4sXHJcbi5lbS1jbnRibixcclxuLmVtLWJuLTAsXHJcbi5lbS1ibi0xLFxyXG4uZW0tYm4tMixcclxuLmVtLWJuLTMsXHJcbi5lbS1rb3Nvdm8tYm4sXHJcbi5lbS1ibi1jbyxcclxuLmVtLW51dHNyZyBbbHZsPSczJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMiddLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzEnXSxcclxuLmVtLWNudHJnLFxyXG4uZW0tbnV0c3JnLFxyXG4uZW0tZ3JpZC1jZWxsIHtcclxuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbn1cclxuXHJcbi8qIG5hdGlvbmFsIGJvdW5kYXJpZXMgKi9cclxuLmVtLWNudGJuIHtcclxuICAgIHN0cm9rZTogIzAwMDtcclxuICAgIHN0cm9rZS13aWR0aDogMC42cHg7XHJcbn1cclxuXHJcbi8qIE5VVFMgYm91bmRhcmllcyBzdHJva2UgY29sb3IgKi9cclxuLmVtLWJuLTEsXHJcbi5lbS1ibi0yLFxyXG4uZW0tYm4tMyxcclxuLmVtLW51dHNyZyBbbHZsPSczJ10sXHJcbi5lbS1udXRzcmcgW2x2bD0nMiddLFxyXG4uZW0tbnV0c3JnIFtsdmw9JzEnXSB7XHJcbiAgICBzdHJva2U6ICM2OTY5Njk7XHJcbn1cclxuXHJcbi8qIGNvYXN0YWwgYm91bmRhcmllcyAqL1xyXG4uZW0tYm4tY28ge1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxufVxyXG5cclxuLyoga29zb3ZvICovXHJcbi5lbS1rb3Nvdm8tYm4ge1xyXG4gICAgc3Ryb2tlOiAjMDAwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjE1O1xyXG59XHJcblxyXG5cclxuXHJcbi8qIGRvbnQgZmlsbCBjZXJ0YWluIGVsZW1lbnRzICovXHJcbi5lbS1mcmFtZSxcclxuLmVtLWdyYXRpY3VsZSxcclxuLmVtLWNudGJuLFxyXG4uZW0tYm4tMCxcclxuLmVtLWJuLTEsXHJcbi5lbS1ibi0yLFxyXG4uZW0tYm4tMyxcclxuLmVtLWtvc292by1ibixcclxuLmVtLWJuLWNvIHtcclxuICAgIGZpbGw6IG5vbmU7XHJcbn1cclxuXHJcbi8qIHRhcmdldCBub24gY2MvZXUvZWZ0YSBib3JkZXJzICovXHJcbi8qIC5lbS1ibi1vdGg6bm90KC5lbS1ibi1jbyk6bm90KC5lbS1ibi1jYyk6bm90KC5lbS1ibi1ldSk6bm90KC5lbS1ibi1lZnRhKSB7XHJcbiAgICBzdHJva2Utd2lkdGg6IDA7XHJcbn0gKi9cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL05VVFMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLDJDQUEyQztBQUMzQyx3QkFBd0I7QUFDeEI7OztJQUdJLGFBQWE7QUFDakI7O0FBRUE7Ozs7SUFJSSxlQUFlO0FBQ25COztBQUVBLDZCQUE2QjtBQUM3QjtJQUNJLFlBQVk7QUFDaEI7QUFDQTs7Ozs7Ozs7SUFRSSxpQkFBaUI7QUFDckI7O0FBRUEsZ0RBQWdEO0FBQ2hEOzs7Ozs7Ozs7Ozs7OztJQWNJLHFCQUFxQjtJQUNyQixzQkFBc0I7QUFDMUI7O0FBRUEsd0JBQXdCO0FBQ3hCO0lBQ0ksWUFBWTtJQUNaLG1CQUFtQjtBQUN2Qjs7QUFFQSxpQ0FBaUM7QUFDakM7Ozs7OztJQU1JLGVBQWU7QUFDbkI7O0FBRUEsdUJBQXVCO0FBQ3ZCO0lBQ0ksYUFBYTtBQUNqQjs7QUFFQSxXQUFXO0FBQ1g7SUFDSSxZQUFZO0lBQ1osa0JBQWtCO0FBQ3RCOzs7O0FBSUEsK0JBQStCO0FBQy9COzs7Ozs7Ozs7SUFTSSxVQUFVO0FBQ2Q7O0FBRUEsa0NBQWtDO0FBQ2xDOztHQUVHXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qIFNUWUxJTkcgT0YgTlVUUyBSRUdJT05TIEFORCBCT1VOREFSSUVTICovXFxyXFxuLyogRGVmYXVsdCByZWdpb24gZmlsbCAqL1xcclxcbi5lbS1jbnRyZyxcXHJcXG4uZW0tbnV0c3JnLFxcclxcbi5lbS1ncmlkLWNlbGwge1xcclxcbiAgICBmaWxsOiAjZTFlMWUxO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tbnV0c3JnLFxcclxcbi5lbS1jbnRyZyxcXHJcXG4uZW0tZ3JpZC1jZWxsLFxcclxcbiNlbS11c2VyLXJlZ2lvbnMge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi8qICBib3VuZGFyaWVzIHN0cm9rZS13aWR0aCAqL1xcclxcbi5lbS1ibi0wIHtcXHJcXG4gICAgc3Ryb2tlOiBub25lO1xcclxcbn1cXHJcXG4uZW0tYm4tMSxcXHJcXG4uZW0tYm4tMixcXHJcXG4uZW0tYm4tMyxcXHJcXG4vKiB3aGVuIHVzaW5nIE1JWEVEIE5VVFMgbGV2ZWxzLCB3ZSBhZGQgc3Ryb2tlIHRvIHRoZSByZWdpb25zLCB0aGVuIHNob3cvaGlkZSB0aG9zZSB0aGF0IGhhdmUvZG9udCBoYXZlIGRhdGEgKi9cXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzEnXSxcXHJcXG4uZW0tYm4tY28ge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuMjtcXHJcXG59XFxyXFxuXFxyXFxuLyogYWxsIGJvdWRuYXJpZXMgYW5kIHJlZ2lvbnMgbGluZWNhcC9saW5lam9pbiAqL1xcclxcbiNlbS1udXRzYm4sXFxyXFxuLmVtLWNudGJuLFxcclxcbi5lbS1ibi0wLFxcclxcbi5lbS1ibi0xLFxcclxcbi5lbS1ibi0yLFxcclxcbi5lbS1ibi0zLFxcclxcbi5lbS1rb3Nvdm8tYm4sXFxyXFxuLmVtLWJuLWNvLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMyddLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMiddLFxcclxcbi5lbS1udXRzcmcgW2x2bD0nMSddLFxcclxcbi5lbS1jbnRyZyxcXHJcXG4uZW0tbnV0c3JnLFxcclxcbi5lbS1ncmlkLWNlbGwge1xcclxcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxufVxcclxcblxcclxcbi8qIG5hdGlvbmFsIGJvdW5kYXJpZXMgKi9cXHJcXG4uZW0tY250Ym4ge1xcclxcbiAgICBzdHJva2U6ICMwMDA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC42cHg7XFxyXFxufVxcclxcblxcclxcbi8qIE5VVFMgYm91bmRhcmllcyBzdHJva2UgY29sb3IgKi9cXHJcXG4uZW0tYm4tMSxcXHJcXG4uZW0tYm4tMixcXHJcXG4uZW0tYm4tMyxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzMnXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzInXSxcXHJcXG4uZW0tbnV0c3JnIFtsdmw9JzEnXSB7XFxyXFxuICAgIHN0cm9rZTogIzY5Njk2OTtcXHJcXG59XFxyXFxuXFxyXFxuLyogY29hc3RhbCBib3VuZGFyaWVzICovXFxyXFxuLmVtLWJuLWNvIHtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLyoga29zb3ZvICovXFxyXFxuLmVtLWtvc292by1ibiB7XFxyXFxuICAgIHN0cm9rZTogIzAwMDtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjE1O1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4vKiBkb250IGZpbGwgY2VydGFpbiBlbGVtZW50cyAqL1xcclxcbi5lbS1mcmFtZSxcXHJcXG4uZW0tZ3JhdGljdWxlLFxcclxcbi5lbS1jbnRibixcXHJcXG4uZW0tYm4tMCxcXHJcXG4uZW0tYm4tMSxcXHJcXG4uZW0tYm4tMixcXHJcXG4uZW0tYm4tMyxcXHJcXG4uZW0ta29zb3ZvLWJuLFxcclxcbi5lbS1ibi1jbyB7XFxyXFxuICAgIGZpbGw6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi8qIHRhcmdldCBub24gY2MvZXUvZWZ0YSBib3JkZXJzICovXFxyXFxuLyogLmVtLWJuLW90aDpub3QoLmVtLWJuLWNvKTpub3QoLmVtLWJuLWNjKTpub3QoLmVtLWJuLWV1KTpub3QoLmVtLWJuLWVmdGEpIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xcclxcbn0gKi9cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC5lbS1hbm5vdGF0aW9uLWdyb3VwIHtcclxuICAgIC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy9hbm5vdGF0aW9ucy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSwwQkFBMEI7QUFDOUJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmVtLWFubm90YXRpb24tZ3JvdXAge1xcclxcbiAgICAvKiBwb2ludGVyLWV2ZW50czogbm9uZTsgKi9cXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMF9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL21hcC5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzFfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi90b29sdGlwLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMl9fXyBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xlZ2VuZC5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzNfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sYWJlbHMuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF80X19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYW5ub3RhdGlvbnMuY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF81X19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vTlVUUy5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzZfX18gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi93b3JsZC5jc3NcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8yX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8zX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF80X19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF81X19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF82X19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgXHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W10sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIlwiLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAjZW0tbGFiZWxzIHtcclxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XHJcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xyXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XHJcbiAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDtcclxufVxyXG5cclxuLmVtLWxhYmVsIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxufVxyXG4uZW0tbGFiZWwtYmFja2dyb3VuZCB7XHJcbiAgICBmaWxsOiAjZmZmZmZmO1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuLmVtLWxhYmVsLXNoYWRvdyB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDJweDtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbn1cclxuLmVtLXN0YXQtbGFiZWwge1xyXG4gICAgb3BhY2l0eTogMTtcclxuICAgIGZvbnQtc2l6ZTogMTNweDtcclxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xyXG4gICAgZmlsbDogIzMxMzEzMTtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG59XHJcbi5lbS1zdGF0LWxhYmVsLXNoYWRvdyB7XHJcbiAgICBvcGFjaXR5OiAxO1xyXG4gICAgZm9udC1zaXplOiAxM3B4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiA0cHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcbi5lbS1sYWJlbC1jYyB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICBzdHJva2U6ICM1MDUwNTA7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuNXB4O1xyXG59XHJcbi5lbS1sYWJlbC1zaGFkb3ctY2Mge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgc3Ryb2tlOiB3aGl0ZTtcclxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xyXG59XHJcbi5lbS1sYWJlbC1jb3VudHJpZXMge1xyXG4gICAgZm9udC1zaXplOiAxMnB4O1xyXG4gICAgc3Ryb2tlOiAjNTA1MDUwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjVweDtcclxufVxyXG4uZW0tbGFiZWwtc2hhZG93LWNvdW50cmllcyB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XHJcbn1cclxuLmVtLWxhYmVsLXNlYXMge1xyXG4gICAgZm9udC1zaXplOiA5cHg7XHJcbiAgICBmaWxsOiAjMDAzMzk5O1xyXG4gICAgc3Ryb2tlOiAjMDAzMzk5O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjJweDtcclxuICAgIGxldHRlci1zcGFjaW5nOiAzcHg7XHJcbn1cclxuLmVtLWxhYmVsLXNoYWRvdy1zZWFzIHtcclxuICAgIGZvbnQtc2l6ZTogOXB4O1xyXG4gICAgbGV0dGVyLXNwYWNpbmc6IDNweDtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcclxufVxyXG5cclxuLmVtLWZsb3ctbGFiZWxzIHtcclxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XHJcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xyXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XHJcbiAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDtcclxufVxyXG4uZW0tZmxvdy1sYWJlbCB7XHJcbiAgICBmb250LXNpemU6IDEzcHg7XHJcbiAgICBmaWxsOiBibGFjaztcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG59XHJcbi5lbS1mbG93LWxhYmVsLXNoYWRvdyB7XHJcbiAgICBmb250LXNpemU6IDEzcHg7XHJcbiAgICBzdHJva2Utd2lkdGg6IDRweDtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL2xhYmVscy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxtQkFBbUI7SUFDbkIsc0JBQXNCO0lBQ3RCLHlDQUF5QztJQUN6QywwQkFBMEI7QUFDOUI7O0FBRUE7SUFDSSxlQUFlO0FBQ25CO0FBQ0E7SUFDSSxhQUFhO0lBQ2Isb0JBQW9CO0FBQ3hCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLGFBQWE7QUFDakI7QUFDQTtJQUNJLFVBQVU7SUFDVixlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLGFBQWE7SUFDYixpQkFBaUI7QUFDckI7QUFDQTtJQUNJLFVBQVU7SUFDVixlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLGFBQWE7QUFDakI7QUFDQTtJQUNJLGVBQWU7SUFDZixlQUFlO0lBQ2YsbUJBQW1CO0FBQ3ZCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsYUFBYTtJQUNiLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGVBQWU7SUFDZixtQkFBbUI7QUFDdkI7QUFDQTtJQUNJLGVBQWU7SUFDZixhQUFhO0lBQ2IsaUJBQWlCO0FBQ3JCO0FBQ0E7SUFDSSxjQUFjO0lBQ2QsYUFBYTtJQUNiLGVBQWU7SUFDZixtQkFBbUI7SUFDbkIsbUJBQW1CO0FBQ3ZCO0FBQ0E7SUFDSSxjQUFjO0lBQ2QsbUJBQW1CO0lBQ25CLGFBQWE7SUFDYixpQkFBaUI7QUFDckI7O0FBRUE7SUFDSSxtQkFBbUI7SUFDbkIsc0JBQXNCO0lBQ3RCLHlDQUF5QztJQUN6QywwQkFBMEI7QUFDOUI7QUFDQTtJQUNJLGVBQWU7SUFDZixXQUFXO0lBQ1gsaUJBQWlCO0FBQ3JCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLGFBQWE7QUFDakJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiI2VtLWxhYmVscyB7XFxyXFxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcbiAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWxhYmVsIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtYmFja2dyb3VuZCB7XFxyXFxuICAgIGZpbGw6ICNmZmZmZmY7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtc2hhZG93IHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDJweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuLmVtLXN0YXQtbGFiZWwge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgICBmb250LXNpemU6IDEzcHg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xcclxcbiAgICBmaWxsOiAjMzEzMTMxO1xcclxcbiAgICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuLmVtLXN0YXQtbGFiZWwtc2hhZG93IHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDRweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLWNjIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2U6ICM1MDUwNTA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC41cHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zaGFkb3ctY2Mge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxuICAgIHN0cm9rZTogd2hpdGU7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogM3B4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtY291bnRyaWVzIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2U6ICM1MDUwNTA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC41cHg7XFxyXFxufVxcclxcbi5lbS1sYWJlbC1zaGFkb3ctY291bnRyaWVzIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDNweDtcXHJcXG59XFxyXFxuLmVtLWxhYmVsLXNlYXMge1xcclxcbiAgICBmb250LXNpemU6IDlweDtcXHJcXG4gICAgZmlsbDogIzAwMzM5OTtcXHJcXG4gICAgc3Ryb2tlOiAjMDAzMzk5O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuMnB4O1xcclxcbiAgICBsZXR0ZXItc3BhY2luZzogM3B4O1xcclxcbn1cXHJcXG4uZW0tbGFiZWwtc2hhZG93LXNlYXMge1xcclxcbiAgICBmb250LXNpemU6IDlweDtcXHJcXG4gICAgbGV0dGVyLXNwYWNpbmc6IDNweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAzcHg7XFxyXFxufVxcclxcblxcclxcbi5lbS1mbG93LWxhYmVscyB7XFxyXFxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XFxyXFxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcbiAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGFiZWwge1xcclxcbiAgICBmb250LXNpemU6IDEzcHg7XFxyXFxuICAgIGZpbGw6IGJsYWNrO1xcclxcbiAgICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGFiZWwtc2hhZG93IHtcXHJcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDRweDtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuZW0tbGVnZW5kLWJhY2tncm91bmQge1xyXG4gICAgZmlsbDogd2hpdGU7XHJcbiAgICBvcGFjaXR5OiAwLjc7XHJcbiAgICByeDogMDtcclxuICAgIHJ5OiAwO1xyXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuLmVtLWxlZ2VuZC1sYWJlbCB7XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbiAgICBzdHJva2U6IG5vbmU7XHJcbiAgICBmaWxsOiBibGFjaztcclxuICAgIGRvbWluYW50LWJhc2VsaW5lOiB1bnNldDtcclxufVxyXG4uZW0tbGVnZW5kLXRpdGxlIHtcclxuICAgIGZvbnQtc2l6ZTogMTZweDtcclxuICAgIGZpbGw6IGJsYWNrO1xyXG59XHJcbi5lbS1sZWdlbmQtc2VwYXJhdG9yIHtcclxuICAgIHN0cm9rZTogd2hpdGU7XHJcbiAgICBzdHJva2Utd2lkdGg6IDE7XHJcbn1cclxuLmVtLWxlZ2VuZC10aWNrIHtcclxuICAgIHN0cm9rZTogI2Q4ZDhkODtcclxuICAgIHN0cm9rZS13aWR0aDogMTtcclxufVxyXG4uZW0tYml2YXJpYXRlLWZyYW1lIHtcclxuICAgIGZpbGw6IG5vbmU7XHJcbiAgICBzdHJva2U6IGJsYWNrO1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtbm9kYXRhIHtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuNTtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG4uZW0tYml2YXJpYXRlLWF4aXMtdGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAxNXB4O1xyXG59XHJcbi5lbS1iaXZhcmlhdGUtbm9kYXRhLWxhYmVsIHtcclxuICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS10aWNrIHtcclxuICAgIHN0cm9rZTogYmxhY2s7XHJcbiAgICBzdHJva2Utd2lkdGg6IDE7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS10aWNrLWxhYmVsIHtcclxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbn1cclxuLmVtLWJpdmFyaWF0ZS1zcXVhcmUsXHJcbi5lbS1sZWdlbmQtcmVjdCB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcblxyXG4uZW0tYml2YXJpYXRlLXNxdWFyZTpob3ZlcixcclxuLmVtLWxlZ2VuZC1yZWN0OmhvdmVyIHtcclxuICAgIHN0cm9rZS13aWR0aDogMjtcclxuICAgIHN0cm9rZTogcmVkO1xyXG59XHJcblxyXG4uZW0tcGllLXNpemUtbGVnZW5kLWxpbmUge1xyXG4gICAgc3Ryb2tlLWRhc2hhcnJheTogMjtcclxuICAgIHN0cm9rZTogZ3JleTtcclxufVxyXG5cclxuLmVtLWxlZ2VuZC1kaXZlcmdpbmctbGluZSB7XHJcbiAgICBzdHJva2U6IGJsYWNrO1xyXG59XHJcblxyXG4uZW0tbGVnZW5kLWhpc3RvZ3JhbS1iYXIge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy9sZWdlbmQuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksV0FBVztJQUNYLFlBQVk7SUFDWixLQUFLO0lBQ0wsS0FBSztJQUNMLG9CQUFvQjtBQUN4QjtBQUNBO0lBQ0ksZUFBZTtJQUNmLFlBQVk7SUFDWixXQUFXO0lBQ1gsd0JBQXdCO0FBQzVCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsV0FBVztBQUNmO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsZUFBZTtBQUNuQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGVBQWU7QUFDbkI7QUFDQTtJQUNJLFVBQVU7SUFDVixhQUFhO0FBQ2pCO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsaUJBQWlCO0lBQ2pCLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGVBQWU7QUFDbkI7QUFDQTtJQUNJLGVBQWU7SUFDZix5QkFBeUI7QUFDN0I7QUFDQTtJQUNJLGFBQWE7SUFDYixlQUFlO0FBQ25CO0FBQ0E7SUFDSSxtQkFBbUI7SUFDbkIsZUFBZTtBQUNuQjtBQUNBOztJQUVJLGVBQWU7SUFDZixhQUFhO0FBQ2pCOztBQUVBOztJQUVJLGVBQWU7SUFDZixXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxtQkFBbUI7SUFDbkIsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGFBQWE7QUFDakI7O0FBRUE7SUFDSSxlQUFlO0FBQ25CXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5lbS1sZWdlbmQtYmFja2dyb3VuZCB7XFxyXFxuICAgIGZpbGw6IHdoaXRlO1xcclxcbiAgICBvcGFjaXR5OiAwLjc7XFxyXFxuICAgIHJ4OiAwO1xcclxcbiAgICByeTogMDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5lbS1sZWdlbmQtbGFiZWwge1xcclxcbiAgICBmb250LXNpemU6IDE1cHg7XFxyXFxuICAgIHN0cm9rZTogbm9uZTtcXHJcXG4gICAgZmlsbDogYmxhY2s7XFxyXFxuICAgIGRvbWluYW50LWJhc2VsaW5lOiB1bnNldDtcXHJcXG59XFxyXFxuLmVtLWxlZ2VuZC10aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXHJcXG4gICAgZmlsbDogYmxhY2s7XFxyXFxufVxcclxcbi5lbS1sZWdlbmQtc2VwYXJhdG9yIHtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xcclxcbn1cXHJcXG4uZW0tbGVnZW5kLXRpY2sge1xcclxcbiAgICBzdHJva2U6ICNkOGQ4ZDg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMTtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS1mcmFtZSB7XFxyXFxuICAgIGZpbGw6IG5vbmU7XFxyXFxuICAgIHN0cm9rZTogYmxhY2s7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtbm9kYXRhIHtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjU7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS1heGlzLXRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLW5vZGF0YS1sYWJlbCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXHJcXG59XFxyXFxuLmVtLWJpdmFyaWF0ZS10aWNrIHtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xcclxcbn1cXHJcXG4uZW0tYml2YXJpYXRlLXRpY2stbGFiZWwge1xcclxcbiAgICB0ZXh0LWFuY2hvcjogbWlkZGxlO1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxufVxcclxcbi5lbS1iaXZhcmlhdGUtc3F1YXJlLFxcclxcbi5lbS1sZWdlbmQtcmVjdCB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgc3Ryb2tlOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWJpdmFyaWF0ZS1zcXVhcmU6aG92ZXIsXFxyXFxuLmVtLWxlZ2VuZC1yZWN0OmhvdmVyIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAyO1xcclxcbiAgICBzdHJva2U6IHJlZDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXBpZS1zaXplLWxlZ2VuZC1saW5lIHtcXHJcXG4gICAgc3Ryb2tlLWRhc2hhcnJheTogMjtcXHJcXG4gICAgc3Ryb2tlOiBncmV5O1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lIHtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWxlZ2VuZC1oaXN0b2dyYW0tYmFyIHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC8qIEdlbmVyYWwgdGV4dCBzZXR0aW5ncyAqL1xyXG50ZXh0IHtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG59XHJcblxyXG5hIHRleHQge1xyXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcclxufVxyXG5cclxuLyogTWFpbiBtYXAgKi9cclxuLmVtLW1hcCxcclxuLmVtLWxlZ2VuZCB7XHJcbiAgICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcclxufVxyXG5cclxuLyogQ29hc3RhbCBtYXJnaW4gKi9cclxuI2VtLWNvYXN0LW1hcmdpbiB7XHJcbiAgICBmaWx0ZXI6IHVybCgjZW0tY29hc3RhbC1ibHVyKTtcclxuICAgIHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XHJcbiAgICBmaWxsOiBub25lO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiA1O1xyXG4gICAgc3Ryb2tlOiByZ2IoMTYxLCAxOTgsIDIzNyk7XHJcbn1cclxuXHJcbi8qIFRpdGxlIGFuZCBzdWJ0aXRsZSBzdHlsaW5nICovXHJcbi5lbS10aXRsZSxcclxuLmVtLWluc2V0LXRpdGxlIHtcclxuICAgIGZpbGw6IGJsYWNrO1xyXG4gICAgc3Ryb2tlOiBub25lO1xyXG59XHJcblxyXG4uZW0tdGl0bGUge1xyXG4gICAgZm9udC1zaXplOiAyMXB4O1xyXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbn1cclxuXHJcbi5lbS1pbnNldC10aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbn1cclxuXHJcbi5lbS1zdWJ0aXRsZSxcclxuLmVtLWluc2V0LXN1YnRpdGxlIHtcclxuICAgIGZpbGw6ICM4NDgyODA7XHJcbiAgICBzdHJva2U6IG5vbmU7XHJcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xyXG4gICAgcGFpbnQtb3JkZXI6IHN0cm9rZTtcclxufVxyXG5cclxuLmVtLXN1YnRpdGxlIHtcclxuICAgIGZvbnQtc2l6ZTogMThweDtcclxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XHJcbn1cclxuXHJcbi5lbS1pbnNldC1zdWJ0aXRsZSB7XHJcbiAgICBmb250LXNpemU6IDEycHg7XHJcbn1cclxuXHJcbi5lbS1zb3VyY2UtcHJldGV4dCB7XHJcbiAgICBmb250LXNpemU6IDExcHg7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNXB4LCAtNXB4KTtcclxufVxyXG4uZW0tc291cmNlLWRhdGFzZXQtbGluayB7XHJcbiAgICBmb250LXNpemU6IDExcHg7XHJcbiAgICBmaWxsOiAjMGU0N2NiO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNXB4LCAtNXB4KTtcclxufVxyXG4uZW0tc291cmNlLWRhdGFzZXQtbGluazpob3ZlciB7XHJcbiAgICBmaWxsOiAjMDgyYjdhO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XHJcbn1cclxuXHJcbi5lbS1mcmFtZSB7XHJcbiAgICBzdHJva2Utd2lkdGg6IDA7XHJcbiAgICBzdHJva2U6IGdyZXk7XHJcbn1cclxuXHJcbi5lbS1pbnNldHMgLmVtLWZyYW1lIHtcclxuICAgIC8qIHRoaXMgd2lsbCBnaXZlIGEgZnJhbWUgdG8gaW5zZXQgbWFwcyAqL1xyXG4gICAgc3Ryb2tlOiBncmV5O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjNweCAhaW1wb3J0YW50O1xyXG59XHJcblxyXG4uZW0tc2VhIHtcclxuICAgIGZpbGw6IHdoaXRlO1xyXG4gICAgLyogcG9pbnRlci1ldmVudHM6IG5vbmU7ICovXHJcbn1cclxuLmVtLXNjYWxlYmFyLWxpbmUge1xyXG4gICAgc3Ryb2tlOiBibGFjaztcclxuICAgIHN0cm9rZS13aWR0aDogMC44cHg7XHJcbn1cclxuLmVtLXNjYWxlYmFyLWxhYmVsIHtcclxuICAgIGZvbnQtc2l6ZTogOXB4O1xyXG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcclxufVxyXG5cclxuLyogQm90dG9tIHRleHQgYW5kIHN5bWJvbCBzdHlsaW5nICovXHJcbi5lbS1mb290bm90ZSB7XHJcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xyXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xyXG4gICAgZm9udC1zaXplOiAxMXB4O1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoNXB4LCAtNXB4KTtcclxufVxyXG4uZW0tZm9vdG5vdGUgYSB7XHJcbiAgICBmaWxsOiAjMGU0N2NiO1xyXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XHJcbn1cclxuLmVtLWZvb3Rub3RlIGE6aG92ZXIge1xyXG4gICAgZmlsbDogIzBhMzI4ZTtcclxufVxyXG5cclxuLmVtLWNlbnRyb2lkIHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG5cclxuLyogR3JhdGljdWxlIHN0eWxpbmcgKi9cclxuLmVtLWdyYXRpY3VsZSB7XHJcbiAgICBzdHJva2U6IGxpZ2h0Z3JheTtcclxuICAgIHN0cm9rZS13aWR0aDogMTtcclxufVxyXG5cclxuLmVtLWZsb3ctbGluayB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbn1cclxuLmVtLWZsb3ctbGluay1vdXRsaW5lIHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG4uZW0tZmxvdy1sYWJlbHMge1xyXG4gICAgZm9udC1zaXplOiAxNXB4O1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAxcHg7XHJcbiAgICBmaWxsOiBibGFjaztcclxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG59XHJcbi5lbS1mbG93LWxhYmVscy1oYWxvIHtcclxuICAgIGZvbnQtc2l6ZTogMTVweDtcclxuICAgIHN0cm9rZS13aWR0aDogMnB4O1xyXG4gICAgZmlsbDogd2hpdGU7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxufVxyXG5cclxuLmVtLWdyaWQtcmVjdCxcclxuLmVtLWdyaWQtaGV4YWdvbiB7XHJcbiAgICBzdHJva2U6IHdoaXRlO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy9tYXAuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLDBCQUEwQjtBQUMxQjtJQUNJLG9CQUFvQjtBQUN4Qjs7QUFFQTtJQUNJLG1CQUFtQjtBQUN2Qjs7QUFFQSxhQUFhO0FBQ2I7O0lBRUkseUNBQXlDO0FBQzdDOztBQUVBLG1CQUFtQjtBQUNuQjtJQUNJLDZCQUE2QjtJQUM3QixzQkFBc0I7SUFDdEIscUJBQXFCO0lBQ3JCLFVBQVU7SUFDVixlQUFlO0lBQ2YsMEJBQTBCO0FBQzlCOztBQUVBLCtCQUErQjtBQUMvQjs7SUFFSSxXQUFXO0lBQ1gsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGVBQWU7SUFDZixpQkFBaUI7QUFDckI7O0FBRUE7SUFDSSxlQUFlO0FBQ25COztBQUVBOztJQUVJLGFBQWE7SUFDYixZQUFZO0lBQ1osc0JBQXNCO0lBQ3RCLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGVBQWU7SUFDZixnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxlQUFlO0FBQ25COztBQUVBO0lBQ0ksZUFBZTtJQUNmLGdDQUFnQztBQUNwQztBQUNBO0lBQ0ksZUFBZTtJQUNmLGFBQWE7SUFDYixlQUFlO0lBQ2YsMEJBQTBCO0lBQzFCLGdDQUFnQztBQUNwQztBQUNBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7SUFDZiwwQkFBMEI7QUFDOUI7O0FBRUE7SUFDSSxlQUFlO0lBQ2YsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLHlDQUF5QztJQUN6QyxZQUFZO0lBQ1osOEJBQThCO0FBQ2xDOztBQUVBO0lBQ0ksV0FBVztJQUNYLDBCQUEwQjtBQUM5QjtBQUNBO0lBQ0ksYUFBYTtJQUNiLG1CQUFtQjtBQUN2QjtBQUNBO0lBQ0ksY0FBYztJQUNkLG1CQUFtQjtBQUN2Qjs7QUFFQSxtQ0FBbUM7QUFDbkM7SUFDSSxtQkFBbUI7SUFDbkIsZUFBZTtJQUNmLGVBQWU7SUFDZiwrQkFBK0I7QUFDbkM7QUFDQTtJQUNJLGFBQWE7SUFDYiwwQkFBMEI7QUFDOUI7QUFDQTtJQUNJLGFBQWE7QUFDakI7O0FBRUE7SUFDSSxlQUFlO0FBQ25COztBQUVBLHNCQUFzQjtBQUN0QjtJQUNJLGlCQUFpQjtJQUNqQixlQUFlO0FBQ25COztBQUVBO0lBQ0ksZUFBZTtBQUNuQjtBQUNBO0lBQ0ksZUFBZTtBQUNuQjtBQUNBO0lBQ0ksZUFBZTtJQUNmLGlCQUFpQjtJQUNqQixXQUFXO0lBQ1gsb0JBQW9CO0FBQ3hCO0FBQ0E7SUFDSSxlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLFdBQVc7SUFDWCxvQkFBb0I7QUFDeEI7O0FBRUE7O0lBRUksYUFBYTtBQUNqQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBHZW5lcmFsIHRleHQgc2V0dGluZ3MgKi9cXHJcXG50ZXh0IHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbmEgdGV4dCB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxyXFxufVxcclxcblxcclxcbi8qIE1haW4gbWFwICovXFxyXFxuLmVtLW1hcCxcXHJcXG4uZW0tbGVnZW5kIHtcXHJcXG4gICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxyXFxufVxcclxcblxcclxcbi8qIENvYXN0YWwgbWFyZ2luICovXFxyXFxuI2VtLWNvYXN0LW1hcmdpbiB7XFxyXFxuICAgIGZpbHRlcjogdXJsKCNlbS1jb2FzdGFsLWJsdXIpO1xcclxcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xcclxcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XFxyXFxuICAgIGZpbGw6IG5vbmU7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogNTtcXHJcXG4gICAgc3Ryb2tlOiByZ2IoMTYxLCAxOTgsIDIzNyk7XFxyXFxufVxcclxcblxcclxcbi8qIFRpdGxlIGFuZCBzdWJ0aXRsZSBzdHlsaW5nICovXFxyXFxuLmVtLXRpdGxlLFxcclxcbi5lbS1pbnNldC10aXRsZSB7XFxyXFxuICAgIGZpbGw6IGJsYWNrO1xcclxcbiAgICBzdHJva2U6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5lbS10aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMjFweDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcblxcclxcbi5lbS1pbnNldC10aXRsZSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXN1YnRpdGxlLFxcclxcbi5lbS1pbnNldC1zdWJ0aXRsZSB7XFxyXFxuICAgIGZpbGw6ICM4NDgyODA7XFxyXFxuICAgIHN0cm9rZTogbm9uZTtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG4gICAgcGFpbnQtb3JkZXI6IHN0cm9rZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXN1YnRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAxOHB4O1xcclxcbiAgICBmb250LXdlaWdodDogMTAwO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0taW5zZXQtc3VidGl0bGUge1xcclxcbiAgICBmb250LXNpemU6IDEycHg7XFxyXFxufVxcclxcblxcclxcbi5lbS1zb3VyY2UtcHJldGV4dCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXHJcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTVweCwgLTVweCk7XFxyXFxufVxcclxcbi5lbS1zb3VyY2UtZGF0YXNldC1saW5rIHtcXHJcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcclxcbiAgICBmaWxsOiAjMGU0N2NiO1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNXB4LCAtNXB4KTtcXHJcXG59XFxyXFxuLmVtLXNvdXJjZS1kYXRhc2V0LWxpbms6aG92ZXIge1xcclxcbiAgICBmaWxsOiAjMDgyYjdhO1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tZnJhbWUge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDA7XFxyXFxuICAgIHN0cm9rZTogZ3JleTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWluc2V0cyAuZW0tZnJhbWUge1xcclxcbiAgICAvKiB0aGlzIHdpbGwgZ2l2ZSBhIGZyYW1lIHRvIGluc2V0IG1hcHMgKi9cXHJcXG4gICAgc3Ryb2tlOiBncmV5O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuM3B4ICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbi5lbS1zZWEge1xcclxcbiAgICBmaWxsOiB3aGl0ZTtcXHJcXG4gICAgLyogcG9pbnRlci1ldmVudHM6IG5vbmU7ICovXFxyXFxufVxcclxcbi5lbS1zY2FsZWJhci1saW5lIHtcXHJcXG4gICAgc3Ryb2tlOiBibGFjaztcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjhweDtcXHJcXG59XFxyXFxuLmVtLXNjYWxlYmFyLWxhYmVsIHtcXHJcXG4gICAgZm9udC1zaXplOiA5cHg7XFxyXFxuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XFxyXFxufVxcclxcblxcclxcbi8qIEJvdHRvbSB0ZXh0IGFuZCBzeW1ib2wgc3R5bGluZyAqL1xcclxcbi5lbS1mb290bm90ZSB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxyXFxuICAgIGN1cnNvcjogZGVmYXVsdDtcXHJcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg1cHgsIC01cHgpO1xcclxcbn1cXHJcXG4uZW0tZm9vdG5vdGUgYSB7XFxyXFxuICAgIGZpbGw6ICMwZTQ3Y2I7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbn1cXHJcXG4uZW0tZm9vdG5vdGUgYTpob3ZlciB7XFxyXFxuICAgIGZpbGw6ICMwYTMyOGU7XFxyXFxufVxcclxcblxcclxcbi5lbS1jZW50cm9pZCB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLyogR3JhdGljdWxlIHN0eWxpbmcgKi9cXHJcXG4uZW0tZ3JhdGljdWxlIHtcXHJcXG4gICAgc3Ryb2tlOiBsaWdodGdyYXk7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLWZsb3ctbGluayB7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuLmVtLWZsb3ctbGluay1vdXRsaW5lIHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uZW0tZmxvdy1sYWJlbHMge1xcclxcbiAgICBmb250LXNpemU6IDE1cHg7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMXB4O1xcclxcbiAgICBmaWxsOiBibGFjaztcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5lbS1mbG93LWxhYmVscy1oYWxvIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDJweDtcXHJcXG4gICAgZmlsbDogd2hpdGU7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uZW0tZ3JpZC1yZWN0LFxcclxcbi5lbS1ncmlkLWhleGFnb24ge1xcclxcbiAgICBzdHJva2U6IHdoaXRlO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC5lc3RhdC12aXMtdG9vbHRpcC10ZXh0IHtcclxuICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XHJcbiAgICBjb2xvcjogIzE3MWEyMjtcclxuICAgIHBhZGRpbmc6IDRweDtcclxuICAgIGZvbnQtc2l6ZTogMTZweDtcclxufVxyXG4uZXN0YXQtdmlzLXRvb2x0aXAtYmFyIHtcclxuICAgIGJhY2tncm91bmQ6ICM1MTU1NjA7XHJcbiAgICBjb2xvcjogI2ZmZmZmZjtcclxuICAgIHBhZGRpbmc6IDZweDtcclxuICAgIGZvbnQtc2l6ZTogMTZweDtcclxufVxyXG4udG9vbHRpcC1ldXJvc3RhdCB7XHJcbiAgICBmb250LWZhbWlseTogQXJpYWw7XHJcbiAgICBtYXgtd2lkdGg6IDI1MHB4O1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgcGFkZGluZzogMHB4O1xyXG4gICAgYm9yZGVyOiAwcHg7XHJcbiAgICBib3JkZXItcmFkaXVzOiAwcHg7XHJcbiAgICBib3gtc2hhZG93OiAwcHggNHB4IDZweCByZ2JhKDAsIDAsIDAsIDAuMSksIDBweCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBmb250LWZhbWlseTogSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgb3BhY2l0eTogMDtcclxuICAgIHotaW5kZXg6IDk5OTk5OTk5O1xyXG59XHJcbi5lbS10b29sdGlwLXBpZWNoYXJ0LWJyZWFrZG93biB7XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG4gICAgZm9udC1zaXplOiAxNHB4O1xyXG59XHJcbi5lbS10b29sdGlwLXBpZWNoYXJ0LWNvbnRhaW5lciB7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbn1cclxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY3NzL3Rvb2x0aXAuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksbUJBQW1CO0lBQ25CLGNBQWM7SUFDZCxZQUFZO0lBQ1osZUFBZTtBQUNuQjtBQUNBO0lBQ0ksbUJBQW1CO0lBQ25CLGNBQWM7SUFDZCxZQUFZO0lBQ1osZUFBZTtBQUNuQjtBQUNBO0lBQ0ksa0JBQWtCO0lBQ2xCLGdCQUFnQjtJQUNoQixnQkFBZ0I7SUFDaEIsaUJBQWlCO0lBQ2pCLFlBQVk7SUFDWixXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLDJFQUEyRTtJQUMzRSxrQkFBa0I7SUFDbEIseUNBQXlDO0lBQ3pDLG9CQUFvQjtJQUNwQixVQUFVO0lBQ1YsaUJBQWlCO0FBQ3JCO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsZUFBZTtBQUNuQjtBQUNBO0lBQ0ksa0JBQWtCO0FBQ3RCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5lc3RhdC12aXMtdG9vbHRpcC10ZXh0IHtcXHJcXG4gICAgYmFja2dyb3VuZDogI2ZmZmZmZjtcXHJcXG4gICAgY29sb3I6ICMxNzFhMjI7XFxyXFxuICAgIHBhZGRpbmc6IDRweDtcXHJcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcclxcbn1cXHJcXG4uZXN0YXQtdmlzLXRvb2x0aXAtYmFyIHtcXHJcXG4gICAgYmFja2dyb3VuZDogIzUxNTU2MDtcXHJcXG4gICAgY29sb3I6ICNmZmZmZmY7XFxyXFxuICAgIHBhZGRpbmc6IDZweDtcXHJcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcclxcbn1cXHJcXG4udG9vbHRpcC1ldXJvc3RhdCB7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBBcmlhbDtcXHJcXG4gICAgbWF4LXdpZHRoOiAyNTBweDtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxyXFxuICAgIHBhZGRpbmc6IDBweDtcXHJcXG4gICAgYm9yZGVyOiAwcHg7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDBweDtcXHJcXG4gICAgYm94LXNoYWRvdzogMHB4IDRweCA2cHggcmdiYSgwLCAwLCAwLCAwLjEpLCAwcHggMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgei1pbmRleDogOTk5OTk5OTk7XFxyXFxufVxcclxcbi5lbS10b29sdGlwLXBpZWNoYXJ0LWJyZWFrZG93biB7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXHJcXG59XFxyXFxuLmVtLXRvb2x0aXAtcGllY2hhcnQtY29udGFpbmVyIHtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYCNnX3dvcmxkYm4sXHJcbi5lbS13b3JsZHJnLFxyXG4uZW0td29ybGRibiB7XHJcbiAgICBzdHJva2UtbGluZWNhcDogcm91bmQ7XHJcbiAgICBzdHJva2UtbGluZWpvaW46IHJvdW5kO1xyXG59XHJcblxyXG4uZW0td29ybGRibiB7XHJcbiAgICBzdHJva2U6ICMwMDA7XHJcbiAgICBzdHJva2Utd2lkdGg6IDAuM3B4O1xyXG59XHJcblxyXG4uZW0td29ybGRibiB7XHJcbiAgICBmaWxsOiBub25lO1xyXG59XHJcblxyXG4uZW0td29ybGRyZyB7XHJcbiAgICBmaWxsOiAjZWZlZmVmO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcblxyXG4uZW0tYm4tZCB7XHJcbiAgICAvKiBkaXNwdXRlZCAqL1xyXG4gICAgc3Ryb2tlOiAjMDAwO1xyXG4gICAgc3Ryb2tlLXdpZHRoOiAwLjE7XHJcbiAgICBmaWxsOiBub25lO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2Nzcy93b3JsZC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7OztJQUdJLHFCQUFxQjtJQUNyQixzQkFBc0I7QUFDMUI7O0FBRUE7SUFDSSxZQUFZO0lBQ1osbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksVUFBVTtBQUNkOztBQUVBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsWUFBWTtJQUNaLGlCQUFpQjtJQUNqQixVQUFVO0FBQ2RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiI2dfd29ybGRibixcXHJcXG4uZW0td29ybGRyZyxcXHJcXG4uZW0td29ybGRibiB7XFxyXFxuICAgIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcXHJcXG4gICAgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXdvcmxkYm4ge1xcclxcbiAgICBzdHJva2U6ICMwMDA7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMC4zcHg7XFxyXFxufVxcclxcblxcclxcbi5lbS13b3JsZGJuIHtcXHJcXG4gICAgZmlsbDogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmVtLXdvcmxkcmcge1xcclxcbiAgICBmaWxsOiAjZWZlZmVmO1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5lbS1ibi1kIHtcXHJcXG4gICAgLyogZGlzcHV0ZWQgKi9cXHJcXG4gICAgc3Ryb2tlOiAjMDAwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuMTtcXHJcXG4gICAgZmlsbDogbm9uZTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCJ2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG5cbmV4cG9ydCB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbmV4cG9ydCB2YXIgbWFwID0gYXJyYXkubWFwO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuaW1wb3J0IGJpc2VjdG9yIGZyb20gXCIuL2Jpc2VjdG9yXCI7XG5cbnZhciBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuZXhwb3J0IHZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbmV4cG9ydCB2YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuZXhwb3J0IGRlZmF1bHQgYmlzZWN0UmlnaHQ7XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoY29tcGFyZSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7XG4gICAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiBmdW5jdGlvbihkLCB4KSB7XG4gICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtwYWlyfSBmcm9tIFwiLi9wYWlyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMwLCB2YWx1ZXMxLCByZWR1Y2UpIHtcbiAgdmFyIG4wID0gdmFsdWVzMC5sZW5ndGgsXG4gICAgICBuMSA9IHZhbHVlczEubGVuZ3RoLFxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4wICogbjEpLFxuICAgICAgaTAsXG4gICAgICBpMSxcbiAgICAgIGksXG4gICAgICB2YWx1ZTA7XG5cbiAgaWYgKHJlZHVjZSA9PSBudWxsKSByZWR1Y2UgPSBwYWlyO1xuXG4gIGZvciAoaTAgPSBpID0gMDsgaTAgPCBuMDsgKytpMCkge1xuICAgIGZvciAodmFsdWUwID0gdmFsdWVzMFtpMF0sIGkxID0gMDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWR1Y2UodmFsdWUwLCB2YWx1ZXMxW2kxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IHZhcmlhbmNlIGZyb20gXCIuL3ZhcmlhbmNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIHZhciB2ID0gdmFyaWFuY2UoYXJyYXksIGYpO1xuICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW4sXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cbiIsImltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgYmlzZWN0IGZyb20gXCIuL2Jpc2VjdFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgZXh0ZW50IGZyb20gXCIuL2V4dGVudFwiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5XCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcIi4vcmFuZ2VcIjtcbmltcG9ydCB7dGlja1N0ZXB9IGZyb20gXCIuL3RpY2tzXCI7XG5pbXBvcnQgc3R1cmdlcyBmcm9tIFwiLi90aHJlc2hvbGQvc3R1cmdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gaWRlbnRpdHksXG4gICAgICBkb21haW4gPSBleHRlbnQsXG4gICAgICB0aHJlc2hvbGQgPSBzdHVyZ2VzO1xuXG4gIGZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgeCxcbiAgICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFsdWVzW2ldID0gdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIHh6ID0gZG9tYWluKHZhbHVlcyksXG4gICAgICAgIHgwID0geHpbMF0sXG4gICAgICAgIHgxID0geHpbMV0sXG4gICAgICAgIHR6ID0gdGhyZXNob2xkKHZhbHVlcywgeDAsIHgxKTtcblxuICAgIC8vIENvbnZlcnQgbnVtYmVyIG9mIHRocmVzaG9sZHMgaW50byB1bmlmb3JtIHRocmVzaG9sZHMuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR6KSkge1xuICAgICAgdHogPSB0aWNrU3RlcCh4MCwgeDEsIHR6KTtcbiAgICAgIHR6ID0gcmFuZ2UoTWF0aC5jZWlsKHgwIC8gdHopICogdHosIHgxLCB0eik7IC8vIGV4Y2x1c2l2ZVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgdGhyZXNob2xkcyBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgdmFyIG0gPSB0ei5sZW5ndGg7XG4gICAgd2hpbGUgKHR6WzBdIDw9IHgwKSB0ei5zaGlmdCgpLCAtLW07XG4gICAgd2hpbGUgKHR6W20gLSAxXSA+IHgxKSB0ei5wb3AoKSwgLS1tO1xuXG4gICAgdmFyIGJpbnMgPSBuZXcgQXJyYXkobSArIDEpLFxuICAgICAgICBiaW47XG5cbiAgICAvLyBJbml0aWFsaXplIGJpbnMuXG4gICAgZm9yIChpID0gMDsgaSA8PSBtOyArK2kpIHtcbiAgICAgIGJpbiA9IGJpbnNbaV0gPSBbXTtcbiAgICAgIGJpbi54MCA9IGkgPiAwID8gdHpbaSAtIDFdIDogeDA7XG4gICAgICBiaW4ueDEgPSBpIDwgbSA/IHR6W2ldIDogeDE7XG4gICAgfVxuXG4gICAgLy8gQXNzaWduIGRhdGEgdG8gYmlucyBieSB2YWx1ZSwgaWdub3JpbmcgYW55IG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB4ID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKHgwIDw9IHggJiYgeCA8PSB4MSkge1xuICAgICAgICBiaW5zW2Jpc2VjdCh0eiwgeCwgMCwgbSldLnB1c2goZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbnM7XG4gIH1cblxuICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdmFsdWU7XG4gIH07XG5cbiAgaGlzdG9ncmFtLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtfWzBdLCBfWzFdXSksIGhpc3RvZ3JhbSkgOiBkb21haW47XG4gIH07XG5cbiAgaGlzdG9ncmFtLnRocmVzaG9sZHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhyZXNob2xkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBBcnJheS5pc0FycmF5KF8pID8gY29uc3RhbnQoc2xpY2UuY2FsbChfKSkgOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHRocmVzaG9sZDtcbiAgfTtcblxuICByZXR1cm4gaGlzdG9ncmFtO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBiaXNlY3QsIGJpc2VjdFJpZ2h0LCBiaXNlY3RMZWZ0fSBmcm9tIFwiLi9iaXNlY3RcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhc2NlbmRpbmd9IGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGJpc2VjdG9yfSBmcm9tIFwiLi9iaXNlY3RvclwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNyb3NzfSBmcm9tIFwiLi9jcm9zc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRlc2NlbmRpbmd9IGZyb20gXCIuL2Rlc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZXZpYXRpb259IGZyb20gXCIuL2RldmlhdGlvblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4dGVudH0gZnJvbSBcIi4vZXh0ZW50XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaGlzdG9ncmFtfSBmcm9tIFwiLi9oaXN0b2dyYW1cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aHJlc2hvbGRGcmVlZG1hbkRpYWNvbmlzfSBmcm9tIFwiLi90aHJlc2hvbGQvZnJlZWRtYW5EaWFjb25pc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRocmVzaG9sZFNjb3R0fSBmcm9tIFwiLi90aHJlc2hvbGQvc2NvdHRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aHJlc2hvbGRTdHVyZ2VzfSBmcm9tIFwiLi90aHJlc2hvbGQvc3R1cmdlc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1heH0gZnJvbSBcIi4vbWF4XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVhbn0gZnJvbSBcIi4vbWVhblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lZGlhbn0gZnJvbSBcIi4vbWVkaWFuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVyZ2V9IGZyb20gXCIuL21lcmdlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWlufSBmcm9tIFwiLi9taW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwYWlyc30gZnJvbSBcIi4vcGFpcnNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwZXJtdXRlfSBmcm9tIFwiLi9wZXJtdXRlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpbGV9IGZyb20gXCIuL3F1YW50aWxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFuZ2V9IGZyb20gXCIuL3JhbmdlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2Nhbn0gZnJvbSBcIi4vc2NhblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNodWZmbGV9IGZyb20gXCIuL3NodWZmbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdW19IGZyb20gXCIuL3N1bVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRpY2tzLCB0aWNrSW5jcmVtZW50LCB0aWNrU3RlcH0gZnJvbSBcIi4vdGlja3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc3Bvc2V9IGZyb20gXCIuL3RyYW5zcG9zZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZhcmlhbmNlfSBmcm9tIFwiLi92YXJpYW5jZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHppcH0gZnJvbSBcIi4vemlwXCI7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG0gPSBuLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkgc3VtICs9IHZhbHVlO1xuICAgICAgZWxzZSAtLW07XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkgc3VtICs9IHZhbHVlO1xuICAgICAgZWxzZSAtLW07XG4gICAgfVxuICB9XG5cbiAgaWYgKG0pIHJldHVybiBzdW0gLyBtO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5pbXBvcnQgcXVhbnRpbGUgZnJvbSBcIi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbnVtYmVycyA9IFtdO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkge1xuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVhbnRpbGUobnVtYmVycy5zb3J0KGFzY2VuZGluZyksIDAuNSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheXMpIHtcbiAgdmFyIG4gPSBhcnJheXMubGVuZ3RoLFxuICAgICAgbSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIGogPSAwLFxuICAgICAgbWVyZ2VkLFxuICAgICAgYXJyYXk7XG5cbiAgd2hpbGUgKCsraSA8IG4pIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgbWVyZ2VkID0gbmV3IEFycmF5KGopO1xuXG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXJnZWQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW47XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgaWYgKGYgPT0gbnVsbCkgZiA9IHBhaXI7XG4gIHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aCAtIDEsIHAgPSBhcnJheVswXSwgcGFpcnMgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgcGFpcnNbaV0gPSBmKHAsIHAgPSBhcnJheVsrK2ldKTtcbiAgcmV0dXJuIHBhaXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFpcihhLCBiKSB7XG4gIHJldHVybiBbYSwgYl07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgcmV0dXJuIHBlcm11dGVzO1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHZhbHVlb2YgPSBudW1iZXI7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLFxuICAgICAgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIGNvbXBhcmUpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBqID0gMCxcbiAgICAgIHhpLFxuICAgICAgeGogPSB2YWx1ZXNbal07XG5cbiAgaWYgKGNvbXBhcmUgPT0gbnVsbCkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGlmIChjb21wYXJlKHhpID0gdmFsdWVzW2ldLCB4aikgPCAwIHx8IGNvbXBhcmUoeGosIHhqKSAhPT0gMCkge1xuICAgICAgeGogPSB4aSwgaiA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgaTAsIGkxKSB7XG4gIHZhciBtID0gKGkxID09IG51bGwgPyBhcnJheS5sZW5ndGggOiBpMSkgLSAoaTAgPSBpMCA9PSBudWxsID8gMCA6ICtpMCksXG4gICAgICB0LFxuICAgICAgaTtcblxuICB3aGlsZSAobSkge1xuICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICB0ID0gYXJyYXlbbSArIGkwXTtcbiAgICBhcnJheVttICsgaTBdID0gYXJyYXlbaSArIGkwXTtcbiAgICBhcnJheVtpICsgaTBdID0gdDtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVzW2ldKSBzdW0gKz0gdmFsdWU7IC8vIE5vdGU6IHplcm8gYW5kIG51bGwgYXJlIGVxdWl2YWxlbnQuXG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdW07XG59XG4iLCJpbXBvcnQge21hcH0gZnJvbSBcIi4uL2FycmF5XCI7XG5pbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuLi9hc2NlbmRpbmdcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4uL251bWJlclwiO1xuaW1wb3J0IHF1YW50aWxlIGZyb20gXCIuLi9xdWFudGlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHZhbHVlcyA9IG1hcC5jYWxsKHZhbHVlcywgbnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMiAqIChxdWFudGlsZSh2YWx1ZXMsIDAuNzUpIC0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSkgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG59XG4iLCJpbXBvcnQgZGV2aWF0aW9uIGZyb20gXCIuLi9kZXZpYXRpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDMuNSAqIGRldmlhdGlvbih2YWx1ZXMpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLkxOMikgKyAxO1xufVxuIiwidmFyIGUxMCA9IE1hdGguc3FydCg1MCksXG4gICAgZTUgPSBNYXRoLnNxcnQoMTApLFxuICAgIGUyID0gTWF0aC5zcXJ0KDIpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHJldmVyc2UsXG4gICAgICBpID0gLTEsXG4gICAgICBuLFxuICAgICAgdGlja3MsXG4gICAgICBzdGVwO1xuXG4gIHN0b3AgPSArc3RvcCwgc3RhcnQgPSArc3RhcnQsIGNvdW50ID0gK2NvdW50O1xuICBpZiAoc3RhcnQgPT09IHN0b3AgJiYgY291bnQgPiAwKSByZXR1cm4gW3N0YXJ0XTtcbiAgaWYgKHJldmVyc2UgPSBzdG9wIDwgc3RhcnQpIG4gPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gbjtcbiAgaWYgKChzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpKSA9PT0gMCB8fCAhaXNGaW5pdGUoc3RlcCkpIHJldHVybiBbXTtcblxuICBpZiAoc3RlcCA+IDApIHtcbiAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAvIHN0ZXApO1xuICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0b3AgLSBzdGFydCArIDEpKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAoc3RhcnQgKyBpKSAqIHN0ZXA7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0ICogc3RlcCk7XG4gICAgc3RvcCA9IE1hdGguY2VpbChzdG9wICogc3RlcCk7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdGFydCAtIHN0b3AgKyAxKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRpY2tzW2ldID0gKHN0YXJ0IC0gaSkgLyBzdGVwO1xuICB9XG5cbiAgaWYgKHJldmVyc2UpIHRpY2tzLnJldmVyc2UoKTtcblxuICByZXR1cm4gdGlja3M7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXApIC8gTWF0aC5MTjEwKSxcbiAgICAgIGVycm9yID0gc3RlcCAvIE1hdGgucG93KDEwLCBwb3dlcik7XG4gIHJldHVybiBwb3dlciA+PSAwXG4gICAgICA/IChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpICogTWF0aC5wb3coMTAsIHBvd2VyKVxuICAgICAgOiAtTWF0aC5wb3coMTAsIC1wb3dlcikgLyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgc3RlcDAgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgc3RlcDEgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwMCkgLyBNYXRoLkxOMTApKSxcbiAgICAgIGVycm9yID0gc3RlcDAgLyBzdGVwMTtcbiAgaWYgKGVycm9yID49IGUxMCkgc3RlcDEgKj0gMTA7XG4gIGVsc2UgaWYgKGVycm9yID49IGU1KSBzdGVwMSAqPSA1O1xuICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcDEgKj0gMjtcbiAgcmV0dXJuIHN0b3AgPCBzdGFydCA/IC1zdGVwMSA6IHN0ZXAxO1xufVxuIiwiaW1wb3J0IG1pbiBmcm9tIFwiLi9taW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0cml4KSB7XG4gIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07KSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XG4gICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc3Bvc2U7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aChkKSB7XG4gIHJldHVybiBkLmxlbmd0aDtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gMCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG1lYW4gPSAwLFxuICAgICAgdmFsdWUsXG4gICAgICBkZWx0YSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobSA+IDEpIHJldHVybiBzdW0gLyAobSAtIDEpO1xufVxuIiwiaW1wb3J0IHRyYW5zcG9zZSBmcm9tIFwiLi90cmFuc3Bvc2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cmFuc3Bvc2UoYXJndW1lbnRzKTtcbn1cbiIsImV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG5leHBvcnQgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbmV4cG9ydCB2YXIgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgdmFyIGV4cCA9IE1hdGguZXhwO1xuZXhwb3J0IHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5leHBvcnQgdmFyIGxvZyA9IE1hdGgubG9nO1xuZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHBvdyA9IE1hdGgucG93O1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5leHBvcnQgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciB0YW4gPSBNYXRoLnRhbjtcblxuZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtNjtcbmV4cG9ydCB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCB2YXIgc3FydDFfMiA9IE1hdGguU1FSVDFfMjtcbmV4cG9ydCB2YXIgc3FydDIgPSBzcXJ0KDIpO1xuZXhwb3J0IHZhciBzcXJ0UGkgPSBzcXJ0KHBpKTtcbmV4cG9ydCB2YXIgdGF1ID0gcGkgKiAyO1xuZXhwb3J0IHZhciBkZWdyZWVzID0gMTgwIC8gcGk7XG5leHBvcnQgdmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmNpKHgpIHtcbiAgcmV0dXJuIHggPyB4IC8gTWF0aC5zaW4oeCkgOiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCh4KSB7XG4gIHJldHVybiB4ID4gMCA/IE1hdGguc3FydCh4KSA6IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgeCA9IGV4cCgyICogeCk7XG4gIHJldHVybiAoeCAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKGV4cCh4KSAtIGV4cCgteCkpIC8gMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKGV4cCh4KSArIGV4cCgteCkpIC8gMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyc2luaCh4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmNvc2goeCkge1xuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMSkpO1xufVxuIiwiaW1wb3J0IHtnZW9Qcm9qZWN0aW9uIGFzIHByb2plY3Rpb259IGZyb20gXCJkMy1nZW9cIjtcbmltcG9ydCB7YWJzLCBkZWdyZWVzLCBlcHNpbG9uMiwgZmxvb3IsIGhhbGZQaSwgbWF4LCBtaW4sIHBpLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbnZhciBLID0gW1xuICBbMC45OTg2LCAtMC4wNjJdLFxuICBbMS4wMDAwLCAwLjAwMDBdLFxuICBbMC45OTg2LCAwLjA2MjBdLFxuICBbMC45OTU0LCAwLjEyNDBdLFxuICBbMC45OTAwLCAwLjE4NjBdLFxuICBbMC45ODIyLCAwLjI0ODBdLFxuICBbMC45NzMwLCAwLjMxMDBdLFxuICBbMC45NjAwLCAwLjM3MjBdLFxuICBbMC45NDI3LCAwLjQzNDBdLFxuICBbMC45MjE2LCAwLjQ5NThdLFxuICBbMC44OTYyLCAwLjU1NzFdLFxuICBbMC44Njc5LCAwLjYxNzZdLFxuICBbMC44MzUwLCAwLjY3NjldLFxuICBbMC43OTg2LCAwLjczNDZdLFxuICBbMC43NTk3LCAwLjc5MDNdLFxuICBbMC43MTg2LCAwLjg0MzVdLFxuICBbMC42NzMyLCAwLjg5MzZdLFxuICBbMC42MjEzLCAwLjkzOTRdLFxuICBbMC41NzIyLCAwLjk3NjFdLFxuICBbMC41MzIyLCAxLjAwMDBdXG5dO1xuXG5LLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICBkWzFdICo9IDEuMDE0NDtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gcm9iaW5zb25SYXcobGFtYmRhLCBwaGkpIHtcbiAgdmFyIGkgPSBtaW4oMTgsIGFicyhwaGkpICogMzYgLyBwaSksXG4gICAgICBpMCA9IGZsb29yKGkpLFxuICAgICAgZGkgPSBpIC0gaTAsXG4gICAgICBheCA9IChrID0gS1tpMF0pWzBdLFxuICAgICAgYXkgPSBrWzFdLFxuICAgICAgYnggPSAoayA9IEtbKytpMF0pWzBdLFxuICAgICAgYnkgPSBrWzFdLFxuICAgICAgY3ggPSAoayA9IEtbbWluKDE5LCArK2kwKV0pWzBdLFxuICAgICAgY3kgPSBrWzFdLFxuICAgICAgaztcbiAgcmV0dXJuIFtcbiAgICBsYW1iZGEgKiAoYnggKyBkaSAqIChjeCAtIGF4KSAvIDIgKyBkaSAqIGRpICogKGN4IC0gMiAqIGJ4ICsgYXgpIC8gMiksXG4gICAgKHBoaSA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKSAqIChieSArIGRpICogKGN5IC0gYXkpIC8gMiArIGRpICogZGkgKiAoY3kgLSAyICogYnkgKyBheSkgLyAyKVxuICBdO1xufVxuXG5yb2JpbnNvblJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB5eSA9IHkgLyBoYWxmUGksXG4gICAgICBwaGkgPSB5eSAqIDkwLFxuICAgICAgaSA9IG1pbigxOCwgYWJzKHBoaSAvIDUpKSxcbiAgICAgIGkwID0gbWF4KDAsIGZsb29yKGkpKTtcbiAgZG8ge1xuICAgIHZhciBheSA9IEtbaTBdWzFdLFxuICAgICAgICBieSA9IEtbaTAgKyAxXVsxXSxcbiAgICAgICAgY3kgPSBLW21pbigxOSwgaTAgKyAyKV1bMV0sXG4gICAgICAgIHUgPSBjeSAtIGF5LFxuICAgICAgICB2ID0gY3kgLSAyICogYnkgKyBheSxcbiAgICAgICAgdCA9IDIgKiAoYWJzKHl5KSAtIGJ5KSAvIHUsXG4gICAgICAgIGMgPSB2IC8gdSxcbiAgICAgICAgZGkgPSB0ICogKDEgLSBjICogdCAqICgxIC0gMiAqIGMgKiB0KSk7XG4gICAgaWYgKGRpID49IDAgfHwgaTAgPT09IDEpIHtcbiAgICAgIHBoaSA9ICh5ID49IDAgPyA1IDogLTUpICogKGRpICsgaSk7XG4gICAgICB2YXIgaiA9IDUwLCBkZWx0YTtcbiAgICAgIGRvIHtcbiAgICAgICAgaSA9IG1pbigxOCwgYWJzKHBoaSkgLyA1KTtcbiAgICAgICAgaTAgPSBmbG9vcihpKTtcbiAgICAgICAgZGkgPSBpIC0gaTA7XG4gICAgICAgIGF5ID0gS1tpMF1bMV07XG4gICAgICAgIGJ5ID0gS1tpMCArIDFdWzFdO1xuICAgICAgICBjeSA9IEtbbWluKDE5LCBpMCArIDIpXVsxXTtcbiAgICAgICAgcGhpIC09IChkZWx0YSA9ICh5ID49IDAgPyBoYWxmUGkgOiAtaGFsZlBpKSAqIChieSArIGRpICogKGN5IC0gYXkpIC8gMiArIGRpICogZGkgKiAoY3kgLSAyICogYnkgKyBheSkgLyAyKSAtIHkpICogZGVncmVlcztcbiAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uMiAmJiAtLWogPiAwKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSB3aGlsZSAoLS1pMCA+PSAwKTtcbiAgdmFyIGF4ID0gS1tpMF1bMF0sXG4gICAgICBieCA9IEtbaTAgKyAxXVswXSxcbiAgICAgIGN4ID0gS1ttaW4oMTksIGkwICsgMildWzBdO1xuICByZXR1cm4gW1xuICAgIHggLyAoYnggKyBkaSAqIChjeCAtIGF4KSAvIDIgKyBkaSAqIGRpICogKGN4IC0gMiAqIGJ4ICsgYXgpIC8gMiksXG4gICAgcGhpICogcmFkaWFuc1xuICBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKHJvYmluc29uUmF3KVxuICAgICAgLnNjYWxlKDE1Mi42Myk7XG59XG4iLCIvLyBBZGRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgd2l0aCB0d2ljZSB0aGUgbm9ybWFsIHByZWNpc2lvbi5cbi8vIFJlZmVyZW5jZTogSi4gUi4gU2hld2NodWssIEFkYXB0aXZlIFByZWNpc2lvbiBGbG9hdGluZy1Qb2ludCBBcml0aG1ldGljIGFuZFxuLy8gRmFzdCBSb2J1c3QgR2VvbWV0cmljIFByZWRpY2F0ZXMsIERpc2NyZXRlICYgQ29tcHV0YXRpb25hbCBHZW9tZXRyeSAxOCgzKVxuLy8gMzA14oCTMzYzICgxOTk3KS5cbi8vIENvZGUgYWRhcHRlZCBmcm9tIEdlb2dyYXBoaWNMaWIgYnkgQ2hhcmxlcyBGLiBGLiBLYXJuZXksXG4vLyBodHRwOi8vZ2VvZ3JhcGhpY2xpYi5zb3VyY2Vmb3JnZS5uZXQvXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEFkZGVyO1xufVxuXG5mdW5jdGlvbiBBZGRlcigpIHtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG5BZGRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBZGRlcixcbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucyA9IC8vIHJvdW5kZWQgdmFsdWVcbiAgICB0aGlzLnQgPSAwOyAvLyBleGFjdCBlcnJvclxuICB9LFxuICBhZGQ6IGZ1bmN0aW9uKHkpIHtcbiAgICBhZGQodGVtcCwgeSwgdGhpcy50KTtcbiAgICBhZGQodGhpcywgdGVtcC5zLCB0aGlzLnMpO1xuICAgIGlmICh0aGlzLnMpIHRoaXMudCArPSB0ZW1wLnQ7XG4gICAgZWxzZSB0aGlzLnMgPSB0ZW1wLnQ7XG4gIH0sXG4gIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnM7XG4gIH1cbn07XG5cbnZhciB0ZW1wID0gbmV3IEFkZGVyO1xuXG5mdW5jdGlvbiBhZGQoYWRkZXIsIGEsIGIpIHtcbiAgdmFyIHggPSBhZGRlci5zID0gYSArIGIsXG4gICAgICBidiA9IHggLSBhLFxuICAgICAgYXYgPSB4IC0gYnY7XG4gIGFkZGVyLnQgPSAoYSAtIGF2KSArIChiIC0gYnYpO1xufVxuIiwiaW1wb3J0IHthc2luLCBhdGFuMiwgY29zLCBzaW4sIHNxcnR9IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgcmV0dXJuIFthdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGFzaW4oY2FydGVzaWFuWzJdKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gIHZhciBsYW1iZGEgPSBzcGhlcmljYWxbMF0sIHBoaSA9IHNwaGVyaWNhbFsxXSwgY29zUGhpID0gY29zKHBoaSk7XG4gIHJldHVybiBbY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICByZXR1cm4gW2FbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1dO1xufVxuXG4vLyBUT0RPIHJldHVybiBhXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuQWRkSW5QbGFjZShhLCBiKSB7XG4gIGFbMF0gKz0gYlswXSwgYVsxXSArPSBiWzFdLCBhWzJdICs9IGJbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgcmV0dXJuIFt2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gZFxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xuICB2YXIgbCA9IHNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgZFswXSAvPSBsLCBkWzFdIC89IGwsIGRbMl0gLz0gbDtcbn1cbiIsImltcG9ydCB7YXNpbiwgYXRhbjIsIGNvcywgZGVncmVlcywgZXBzaWxvbiwgZXBzaWxvbjIsIHJhZGlhbnMsIHNpbiwgc3FydH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4vbm9vcC5qc1wiO1xuaW1wb3J0IHN0cmVhbSBmcm9tIFwiLi9zdHJlYW0uanNcIjtcblxudmFyIFcwLCBXMSxcbiAgICBYMCwgWTAsIFowLFxuICAgIFgxLCBZMSwgWjEsXG4gICAgWDIsIFkyLCBaMixcbiAgICBsYW1iZGEwMCwgcGhpMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgeDAsIHkwLCB6MDsgLy8gcHJldmlvdXMgcG9pbnRcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBzcGhlcmU6IG5vb3AsXG4gIHBvaW50OiBjZW50cm9pZFBvaW50LFxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZDtcbiAgfVxufTtcblxuLy8gQXJpdGhtZXRpYyBtZWFuIG9mIENhcnRlc2lhbiB2ZWN0b3JzLlxuZnVuY3Rpb24gY2VudHJvaWRQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbihjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludENhcnRlc2lhbih4LCB5LCB6KSB7XG4gICsrVzA7XG4gIFgwICs9ICh4IC0gWDApIC8gVzA7XG4gIFkwICs9ICh5IC0gWTApIC8gVzA7XG4gIFowICs9ICh6IC0gWjApIC8gVzA7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gIHowID0gc2luKHBoaSk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnQ7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLFxuICAgICAgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLFxuICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgdyA9IGF0YW4yKHNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kKCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbi8vIFNlZSBKLiBFLiBCcm9jaywgVGhlIEluZXJ0aWEgVGVuc29yIGZvciBhIFNwaGVyaWNhbCBUcmlhbmdsZSxcbi8vIEouIEFwcGxpZWQgTWVjaGFuaWNzIDQyLCAyMzkgKDE5NzUpLlxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xuICBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEwMCwgcGhpMDApO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnQ7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICBjeCA9IHkwICogeiAtIHowICogeSxcbiAgICAgIGN5ID0gejAgKiB4IC0geDAgKiB6LFxuICAgICAgY3ogPSB4MCAqIHkgLSB5MCAqIHgsXG4gICAgICBtID0gc3FydChjeCAqIGN4ICsgY3kgKiBjeSArIGN6ICogY3opLFxuICAgICAgdyA9IGFzaW4obSksIC8vIGxpbmUgd2VpZ2h0ID0gYW5nbGVcbiAgICAgIHYgPSBtICYmIC13IC8gbTsgLy8gYXJlYSB3ZWlnaHQgbXVsdGlwbGllclxuICBYMiArPSB2ICogY3g7XG4gIFkyICs9IHYgKiBjeTtcbiAgWjIgKz0gdiAqIGN6O1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3QpIHtcbiAgVzAgPSBXMSA9XG4gIFgwID0gWTAgPSBaMCA9XG4gIFgxID0gWTEgPSBaMSA9XG4gIFgyID0gWTIgPSBaMiA9IDA7XG4gIHN0cmVhbShvYmplY3QsIGNlbnRyb2lkU3RyZWFtKTtcblxuICB2YXIgeCA9IFgyLFxuICAgICAgeSA9IFkyLFxuICAgICAgeiA9IFoyLFxuICAgICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICAvLyBJZiB0aGUgYXJlYS13ZWlnaHRlZCBjY2VudHJvaWQgaXMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbGVuZ3RoLXdlaWdodGVkIGNjZW50cm9pZC5cbiAgaWYgKG0gPCBlcHNpbG9uMikge1xuICAgIHggPSBYMSwgeSA9IFkxLCB6ID0gWjE7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXG4gICAgaWYgKFcxIDwgZXBzaWxvbikgeCA9IFgwLCB5ID0gWTAsIHogPSBaMDtcbiAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIHN0aWxsIGhhcyBhbiB1bmRlZmluZWQgY2NlbnRyb2lkLCB0aGVuIHJldHVybi5cbiAgICBpZiAobSA8IGVwc2lsb24yKSByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxuXG4gIHJldHVybiBbYXRhbjIoeSwgeCkgKiBkZWdyZWVzLCBhc2luKHogLyBzcXJ0KG0pKSAqIGRlZ3JlZXNdO1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UsIHNwaGVyaWNhbH0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YWNvcywgY29zLCBkZWdyZWVzLCBlcHNpbG9uLCByYWRpYW5zLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtyb3RhdGVSYWRpYW5zfSBmcm9tIFwiLi9yb3RhdGlvbi5qc1wiO1xuXG4vLyBHZW5lcmF0ZXMgYSBjaXJjbGUgY2VudGVyZWQgYXQgWzDCsCwgMMKwXSwgd2l0aCBhIGdpdmVuIHJhZGl1cyBhbmQgcHJlY2lzaW9uLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgdDAsIHQxKSB7XG4gIGlmICghZGVsdGEpIHJldHVybjtcbiAgdmFyIGNvc1JhZGl1cyA9IGNvcyhyYWRpdXMpLFxuICAgICAgc2luUmFkaXVzID0gc2luKHJhZGl1cyksXG4gICAgICBzdGVwID0gZGlyZWN0aW9uICogZGVsdGE7XG4gIGlmICh0MCA9PSBudWxsKSB7XG4gICAgdDAgPSByYWRpdXMgKyBkaXJlY3Rpb24gKiB0YXU7XG4gICAgdDEgPSByYWRpdXMgLSBzdGVwIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0MCA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQwKTtcbiAgICB0MSA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQxKTtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCA/IHQwIDwgdDEgOiB0MCA+IHQxKSB0MCArPSBkaXJlY3Rpb24gKiB0YXU7XG4gIH1cbiAgZm9yICh2YXIgcG9pbnQsIHQgPSB0MDsgZGlyZWN0aW9uID4gMCA/IHQgPiB0MSA6IHQgPCB0MTsgdCAtPSBzdGVwKSB7XG4gICAgcG9pbnQgPSBzcGhlcmljYWwoW2Nvc1JhZGl1cywgLXNpblJhZGl1cyAqIGNvcyh0KSwgLXNpblJhZGl1cyAqIHNpbih0KV0pO1xuICAgIHN0cmVhbS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICB9XG59XG5cbi8vIFJldHVybnMgdGhlIHNpZ25lZCBhbmdsZSBvZiBhIGNhcnRlc2lhbiBwb2ludCByZWxhdGl2ZSB0byBbY29zUmFkaXVzLCAwLCAwXS5cbmZ1bmN0aW9uIGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHBvaW50KSB7XG4gIHBvaW50ID0gY2FydGVzaWFuKHBvaW50KSwgcG9pbnRbMF0gLT0gY29zUmFkaXVzO1xuICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKHBvaW50KTtcbiAgdmFyIHJhZGl1cyA9IGFjb3MoLXBvaW50WzFdKTtcbiAgcmV0dXJuICgoLXBvaW50WzJdIDwgMCA/IC1yYWRpdXMgOiByYWRpdXMpICsgdGF1IC0gZXBzaWxvbikgJSB0YXU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VudGVyID0gY29uc3RhbnQoWzAsIDBdKSxcbiAgICAgIHJhZGl1cyA9IGNvbnN0YW50KDkwKSxcbiAgICAgIHByZWNpc2lvbiA9IGNvbnN0YW50KDYpLFxuICAgICAgcmluZyxcbiAgICAgIHJvdGF0ZSxcbiAgICAgIHN0cmVhbSA9IHtwb2ludDogcG9pbnR9O1xuXG4gIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgeFswXSAqPSBkZWdyZWVzLCB4WzFdICo9IGRlZ3JlZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgdmFyIGMgPSBjZW50ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgciA9IHJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucyxcbiAgICAgICAgcCA9IHByZWNpc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucztcbiAgICByaW5nID0gW107XG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucygtY1swXSAqIHJhZGlhbnMsIC1jWzFdICogcmFkaWFucywgMCkuaW52ZXJ0O1xuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHIsIHAsIDEpO1xuICAgIGMgPSB7dHlwZTogXCJQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBbcmluZ119O1xuICAgIHJpbmcgPSByb3RhdGUgPSBudWxsO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgY2lyY2xlLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjZW50ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFsrX1swXSwgK19bMV1dKSwgY2lyY2xlKSA6IGNlbnRlcjtcbiAgfTtcblxuICBjaXJjbGUucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcmFkaXVzO1xuICB9O1xuXG4gIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2lzaW9uID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiBwcmVjaXNpb247XG4gIH07XG5cbiAgcmV0dXJuIGNpcmNsZTtcbn1cbiIsImltcG9ydCBjbGlwIGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge2FicywgYXRhbiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIHBpLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsaXAoXG4gIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgY2xpcEFudGltZXJpZGlhbkxpbmUsXG4gIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZSxcbiAgWy1waSwgLWhhbGZQaV1cbik7XG5cbi8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXM6IDAgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vIGludGVyc2VjdGlvbnM7IDIgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIHNob3VsZCBiZSByZWpvaW5lZC5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5MaW5lKHN0cmVhbSkge1xuICB2YXIgbGFtYmRhMCA9IE5hTixcbiAgICAgIHBoaTAgPSBOYU4sXG4gICAgICBzaWduMCA9IE5hTixcbiAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgY2xlYW4gPSAxO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYTEsIHBoaTEpIHtcbiAgICAgIHZhciBzaWduMSA9IGxhbWJkYTEgPiAwID8gcGkgOiAtcGksXG4gICAgICAgICAgZGVsdGEgPSBhYnMobGFtYmRhMSAtIGxhbWJkYTApO1xuICAgICAgaWYgKGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24pIHsgLy8gbGluZSBjcm9zc2VzIGEgcG9sZVxuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCwgcGhpMCA9IChwaGkwICsgcGhpMSkgLyAyID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGExLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChzaWduMCAhPT0gc2lnbjEgJiYgZGVsdGEgPj0gcGkpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxuICAgICAgICBpZiAoYWJzKGxhbWJkYTAgLSBzaWduMCkgPCBlcHNpbG9uKSBsYW1iZGEwIC09IHNpZ24wICogZXBzaWxvbjsgLy8gaGFuZGxlIGRlZ2VuZXJhY2llc1xuICAgICAgICBpZiAoYWJzKGxhbWJkYTEgLSBzaWduMSkgPCBlcHNpbG9uKSBsYW1iZGExIC09IHNpZ24xICogZXBzaWxvbjtcbiAgICAgICAgcGhpMCA9IGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAgPSBsYW1iZGExLCBwaGkwID0gcGhpMSk7XG4gICAgICBzaWduMCA9IHNpZ24xO1xuICAgIH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgbGFtYmRhMCA9IHBoaTAgPSBOYU47XG4gICAgfSxcbiAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMiAtIGNsZWFuOyAvLyBpZiBpbnRlcnNlY3Rpb25zLCByZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSkge1xuICB2YXIgY29zUGhpMCxcbiAgICAgIGNvc1BoaTEsXG4gICAgICBzaW5MYW1iZGEwTGFtYmRhMSA9IHNpbihsYW1iZGEwIC0gbGFtYmRhMSk7XG4gIHJldHVybiBhYnMoc2luTGFtYmRhMExhbWJkYTEpID4gZXBzaWxvblxuICAgICAgPyBhdGFuKChzaW4ocGhpMCkgKiAoY29zUGhpMSA9IGNvcyhwaGkxKSkgKiBzaW4obGFtYmRhMSlcbiAgICAgICAgICAtIHNpbihwaGkxKSAqIChjb3NQaGkwID0gY29zKHBoaTApKSAqIHNpbihsYW1iZGEwKSlcbiAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcbiAgICAgIDogKHBoaTAgKyBwaGkxKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgdmFyIHBoaTtcbiAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGhhbGZQaTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIDApO1xuICAgIHN0cmVhbS5wb2ludChwaSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIDApO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGxhbWJkYSA9IGZyb21bMF0gPCB0b1swXSA/IHBpIDogLXBpO1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGxhbWJkYSAvIDI7XG4gICAgc3RyZWFtLnBvaW50KC1sYW1iZGEsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgfVxufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lcyA9IFtdLFxuICAgICAgbGluZTtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSwgbSkge1xuICAgICAgbGluZS5wdXNoKFt4LCB5LCBtXSk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgIH0sXG4gICAgbGluZUVuZDogbm9vcCxcbiAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgbGluZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5BZGRJblBsYWNlLCBjYXJ0ZXNpYW5Dcm9zcywgY2FydGVzaWFuRG90LCBjYXJ0ZXNpYW5TY2FsZSwgc3BoZXJpY2FsfSBmcm9tIFwiLi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2NpcmNsZVN0cmVhbX0gZnJvbSBcIi4uL2NpcmNsZS5qc1wiO1xuaW1wb3J0IHthYnMsIGNvcywgZXBzaWxvbiwgcGksIHJhZGlhbnMsIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgcG9pbnRFcXVhbCBmcm9tIFwiLi4vcG9pbnRFcXVhbC5qc1wiO1xuaW1wb3J0IGNsaXAgZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHZhciBjciA9IGNvcyhyYWRpdXMpLFxuICAgICAgZGVsdGEgPSA2ICogcmFkaWFucyxcbiAgICAgIHNtYWxsUmFkaXVzID0gY3IgPiAwLFxuICAgICAgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiBlcHNpbG9uOyAvLyBUT0RPIG9wdGltaXNlIGZvciB0aGlzIGNvbW1vbiBjYXNlXG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCBmcm9tLCB0byk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGNvcyhsYW1iZGEpICogY29zKHBoaSkgPiBjcjtcbiAgfVxuXG4gIC8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXMgdXNlZCBmb3IgcG9seWdvblxuICAvLyBjbGlwcGluZzogMCAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBub1xuICAvLyBpbnRlcnNlY3Rpb25zIDIgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgLy8gc2hvdWxkIGJlIHJlam9pbmVkLlxuICBmdW5jdGlvbiBjbGlwTGluZShzdHJlYW0pIHtcbiAgICB2YXIgcG9pbnQwLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICBjMCwgLy8gY29kZSBmb3IgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAsIC8vIHZpc2liaWxpdHkgb2YgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAwLCAvLyB2aXNpYmlsaXR5IG9mIGZpcnN0IHBvaW50XG4gICAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHYwMCA9IHYwID0gZmFsc2U7XG4gICAgICAgIGNsZWFuID0gMTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBvaW50MSA9IFtsYW1iZGEsIHBoaV0sXG4gICAgICAgICAgICBwb2ludDIsXG4gICAgICAgICAgICB2ID0gdmlzaWJsZShsYW1iZGEsIHBoaSksXG4gICAgICAgICAgICBjID0gc21hbGxSYWRpdXNcbiAgICAgICAgICAgICAgPyB2ID8gMCA6IGNvZGUobGFtYmRhLCBwaGkpXG4gICAgICAgICAgICAgIDogdiA/IGNvZGUobGFtYmRhICsgKGxhbWJkYSA8IDAgPyBwaSA6IC1waSksIHBoaSkgOiAwO1xuICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSkgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgIGlmICghcG9pbnQyIHx8IHBvaW50RXF1YWwocG9pbnQwLCBwb2ludDIpIHx8IHBvaW50RXF1YWwocG9pbnQxLCBwb2ludDIpKVxuICAgICAgICAgICAgcG9pbnQxWzJdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgZ29pbmcgaW5cbiAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnNpZGUgZ29pbmcgb3V0XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdLCAyKTtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgfSBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcbiAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAvLyBJZiB0aGUgY29kZXMgZm9yIHR3byBwb2ludHMgYXJlIGRpZmZlcmVudCwgb3IgYXJlIGJvdGggemVybyxcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgdGhpcyBzZWdtZW50IGludGVyc2VjdHMgd2l0aCB0aGUgc21hbGwgY2lyY2xlLlxuICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0sIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodjApIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgLy8gUmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIGlmIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBhbmQgbGFzdCBwb2ludHMgd2VyZSB2aXNpYmxlLlxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2xlYW4gfCAoKHYwMCAmJiB2MCkgPDwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVyc2VjdHMgdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIGEgYW5kIGIgd2l0aCB0aGUgY2xpcCBjaXJjbGUuXG4gIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICB2YXIgcGEgPSBjYXJ0ZXNpYW4oYSksXG4gICAgICAgIHBiID0gY2FydGVzaWFuKGIpO1xuXG4gICAgLy8gV2UgaGF2ZSB0d28gcGxhbmVzLCBuMS5wID0gZDEgYW5kIG4yLnAgPSBkMi5cbiAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBsaW5lIHAodCkgPSBjMSBuMSArIGMyIG4yICsgdCAobjEg4qivIG4yKS5cbiAgICB2YXIgbjEgPSBbMSwgMCwgMF0sIC8vIG5vcm1hbFxuICAgICAgICBuMiA9IGNhcnRlc2lhbkNyb3NzKHBhLCBwYiksXG4gICAgICAgIG4ybjIgPSBjYXJ0ZXNpYW5Eb3QobjIsIG4yKSxcbiAgICAgICAgbjFuMiA9IG4yWzBdLCAvLyBjYXJ0ZXNpYW5Eb3QobjEsIG4yKSxcbiAgICAgICAgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG5cbiAgICAvLyBUd28gcG9sYXIgcG9pbnRzLlxuICAgIGlmICghZGV0ZXJtaW5hbnQpIHJldHVybiAhdHdvICYmIGE7XG5cbiAgICB2YXIgYzEgPSAgY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LFxuICAgICAgICBuMXhuMiA9IGNhcnRlc2lhbkNyb3NzKG4xLCBuMiksXG4gICAgICAgIEEgPSBjYXJ0ZXNpYW5TY2FsZShuMSwgYzEpLFxuICAgICAgICBCID0gY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKEEsIEIpO1xuXG4gICAgLy8gU29sdmUgfHAodCl8XjIgPSAxLlxuICAgIHZhciB1ID0gbjF4bjIsXG4gICAgICAgIHcgPSBjYXJ0ZXNpYW5Eb3QoQSwgdSksXG4gICAgICAgIHV1ID0gY2FydGVzaWFuRG90KHUsIHUpLFxuICAgICAgICB0MiA9IHcgKiB3IC0gdXUgKiAoY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG5cbiAgICBpZiAodDIgPCAwKSByZXR1cm47XG5cbiAgICB2YXIgdCA9IHNxcnQodDIpLFxuICAgICAgICBxID0gY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShxLCBBKTtcbiAgICBxID0gc3BoZXJpY2FsKHEpO1xuXG4gICAgaWYgKCF0d28pIHJldHVybiBxO1xuXG4gICAgLy8gVHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gICAgdmFyIGxhbWJkYTAgPSBhWzBdLFxuICAgICAgICBsYW1iZGExID0gYlswXSxcbiAgICAgICAgcGhpMCA9IGFbMV0sXG4gICAgICAgIHBoaTEgPSBiWzFdLFxuICAgICAgICB6O1xuXG4gICAgaWYgKGxhbWJkYTEgPCBsYW1iZGEwKSB6ID0gbGFtYmRhMCwgbGFtYmRhMCA9IGxhbWJkYTEsIGxhbWJkYTEgPSB6O1xuXG4gICAgdmFyIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgIHBvbGFyID0gYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbixcbiAgICAgICAgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb247XG5cbiAgICBpZiAoIXBvbGFyICYmIHBoaTEgPCBwaGkwKSB6ID0gcGhpMCwgcGhpMCA9IHBoaTEsIHBoaTEgPSB6O1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZmlyc3QgcG9pbnQgaXMgYmV0d2VlbiBhIGFuZCBiLlxuICAgIGlmIChtZXJpZGlhblxuICAgICAgICA/IHBvbGFyXG4gICAgICAgICAgPyBwaGkwICsgcGhpMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gbGFtYmRhMCkgPCBlcHNpbG9uID8gcGhpMCA6IHBoaTEpXG4gICAgICAgICAgOiBwaGkwIDw9IHFbMV0gJiYgcVsxXSA8PSBwaGkxXG4gICAgICAgIDogZGVsdGEgPiBwaSBeIChsYW1iZGEwIDw9IHFbMF0gJiYgcVswXSA8PSBsYW1iZGExKSkge1xuICAgICAgdmFyIHExID0gY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHExLCBBKTtcbiAgICAgIHJldHVybiBbcSwgc3BoZXJpY2FsKHExKV07XG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGVzIGEgNC1iaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSBwb2ludCByZWxhdGl2ZSB0b1xuICAvLyB0aGUgc21hbGwgY2lyY2xlJ3MgYm91bmRpbmcgYm94LlxuICBmdW5jdGlvbiBjb2RlKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IHBpIC0gcmFkaXVzLFxuICAgICAgICBjb2RlID0gMDtcbiAgICBpZiAobGFtYmRhIDwgLXIpIGNvZGUgfD0gMTsgLy8gbGVmdFxuICAgIGVsc2UgaWYgKGxhbWJkYSA+IHIpIGNvZGUgfD0gMjsgLy8gcmlnaHRcbiAgICBpZiAocGhpIDwgLXIpIGNvZGUgfD0gNDsgLy8gYmVsb3dcbiAgICBlbHNlIGlmIChwaGkgPiByKSBjb2RlIHw9IDg7IC8vIGFib3ZlXG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cblxuICByZXR1cm4gY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWzAsIC1yYWRpdXNdIDogWy1waSwgcmFkaXVzIC0gcGldKTtcbn1cbiIsImltcG9ydCBjbGlwQnVmZmVyIGZyb20gXCIuL2J1ZmZlci5qc1wiO1xuaW1wb3J0IGNsaXBSZWpvaW4gZnJvbSBcIi4vcmVqb2luLmpzXCI7XG5pbXBvcnQge2Vwc2lsb24sIGhhbGZQaX0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBwb2x5Z29uQ29udGFpbnMgZnJvbSBcIi4uL3BvbHlnb25Db250YWlucy5qc1wiO1xuaW1wb3J0IHttZXJnZX0gZnJvbSBcImQzLWFycmF5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzdGFydCkge1xuICByZXR1cm4gZnVuY3Rpb24oc2luaykge1xuICAgIHZhciBsaW5lID0gY2xpcExpbmUoc2luayksXG4gICAgICAgIHJpbmdCdWZmZXIgPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHJpbmdTaW5rID0gY2xpcExpbmUocmluZ0J1ZmZlciksXG4gICAgICAgIHBvbHlnb25TdGFydGVkID0gZmFsc2UsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICByaW5nO1xuXG4gICAgdmFyIGNsaXAgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHN0YXJ0KTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHNpbmspO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIHNpbmsucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgaWYgKHBvaW50VmlzaWJsZShsYW1iZGEsIHBoaSkpIHNpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50TGluZShsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50UmluZyhsYW1iZGEsIHBoaSkge1xuICAgICAgcmluZy5wdXNoKFtsYW1iZGEsIHBoaV0pO1xuICAgICAgcmluZ1NpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIHJpbmdTaW5rLmxpbmVTdGFydCgpO1xuICAgICAgcmluZyA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XG4gICAgICByaW5nU2luay5saW5lRW5kKCk7XG5cbiAgICAgIHZhciBjbGVhbiA9IHJpbmdTaW5rLmNsZWFuKCksXG4gICAgICAgICAgcmluZ1NlZ21lbnRzID0gcmluZ0J1ZmZlci5yZXN1bHQoKSxcbiAgICAgICAgICBpLCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aCwgbSxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIHBvaW50O1xuXG4gICAgICByaW5nLnBvcCgpO1xuICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgcmluZyA9IG51bGw7XG5cbiAgICAgIGlmICghbikgcmV0dXJuO1xuXG4gICAgICAvLyBObyBpbnRlcnNlY3Rpb25zLlxuICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICBpZiAoKG0gPSBzZWdtZW50Lmxlbmd0aCAtIDEpID4gMCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHNpbmsucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlam9pbiBjb25uZWN0ZWQgc2VnbWVudHMuXG4gICAgICAvLyBUT0RPIHJldXNlIHJpbmdCdWZmZXIucmVqb2luKCk/XG4gICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG5cbiAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcih2YWxpZFNlZ21lbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbn1cblxuLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXG4vLyBhbmQgY2lyY2xlIGNsaXBwaW5nLCB0aGUgc2FtZSBjb21wYXJpc29uIGlzIHVzZWQuXG5mdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBhWzFdKVxuICAgICAgIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGJbMV0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIHQwID0gMCxcbiAgICAgIHQxID0gMSxcbiAgICAgIGR4ID0gYnggLSBheCxcbiAgICAgIGR5ID0gYnkgLSBheSxcbiAgICAgIHI7XG5cbiAgciA9IHgwIC0gYXg7XG4gIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB4MSAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICByID0geTAgLSBheTtcbiAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHkxIC0gYXk7XG4gIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIGlmICh0MCA+IDApIGFbMF0gPSBheCArIHQwICogZHgsIGFbMV0gPSBheSArIHQwICogZHk7XG4gIGlmICh0MSA8IDEpIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgY2xpcEJ1ZmZlciBmcm9tIFwiLi9idWZmZXIuanNcIjtcbmltcG9ydCBjbGlwTGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQgY2xpcFJlam9pbiBmcm9tIFwiLi9yZWpvaW4uanNcIjtcbmltcG9ydCB7bWVyZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuXG52YXIgY2xpcE1heCA9IDFlOSwgY2xpcE1pbiA9IC1jbGlwTWF4O1xuXG4vLyBUT0RPIFVzZSBkMy1wb2x5Z29u4oCZcyBwb2x5Z29uQ29udGFpbnMgaGVyZSBmb3IgdGhlIHJpbmcgY2hlY2s/XG4vLyBUT0RPIEVsaW1pbmF0ZSBkdXBsaWNhdGUgYnVmZmVyaW5nIGluIGNsaXBCdWZmZXIgYW5kIHBvbHlnb24ucHVzaD9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xpcFJlY3RhbmdsZSh4MCwgeTAsIHgxLCB5MSkge1xuXG4gIGZ1bmN0aW9uIHZpc2libGUoeCwgeSkge1xuICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgaWYgKGZyb20gPT0gbnVsbFxuICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxuICAgICAgICB8fCBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIGRvIHN0cmVhbS5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzXG4gICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxXG4gICAgICAgIDogYWJzKHBbMV0gLSB5MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXG4gICAgICAgIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyOyAvLyBhYnMocFsxXSAtIHkxKSA8IGVwc2lsb25cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlUG9pbnQoYS54LCBiLngpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVBvaW50KGEsIGIpIHtcbiAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksXG4gICAgICAgIGNiID0gY29ybmVyKGIsIDEpO1xuICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiXG4gICAgICAgIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXVxuICAgICAgICA6IGNhID09PSAxID8gYVswXSAtIGJbMF1cbiAgICAgICAgOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdXG4gICAgICAgIDogYlswXSAtIGFbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSxcbiAgICAgICAgYnVmZmVyU3RyZWFtID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgcmluZyxcbiAgICAgICAgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgeF8sIHlfLCB2XywgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgZmlyc3QsXG4gICAgICAgIGNsZWFuO1xuXG4gICAgdmFyIGNsaXBTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcbiAgICAgIHBvbHlnb25FbmQ6IHBvbHlnb25FbmRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgaWYgKHZpc2libGUoeCwgeSkpIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uSW5zaWRlKCkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xuICAgICAgICAgIGEwID0gYjAsIGExID0gYjEsIHBvaW50ID0gcmluZ1tqXSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTtcbiAgICAgICAgICBpZiAoYTEgPD0geTEpIHsgaWYgKGIxID4geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpID4gKGIxIC0gYTEpICogKHgwIC0gYTApKSArK3dpbmRpbmc7IH1cbiAgICAgICAgICBlbHNlIHsgaWYgKGIxIDw9IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA8IChiMSAtIGExKSAqICh4MCAtIGEwKSkgLS13aW5kaW5nOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpbmRpbmc7XG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIGdlb21ldHJ5IHdpdGhpbiBhIHBvbHlnb24gYW5kIHRoZW4gY2xpcCBpdCBlbiBtYXNzZS5cbiAgICBmdW5jdGlvbiBwb2x5Z29uU3RhcnQoKSB7XG4gICAgICBhY3RpdmVTdHJlYW0gPSBidWZmZXJTdHJlYW0sIHNlZ21lbnRzID0gW10sIHBvbHlnb24gPSBbXSwgY2xlYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25FbmQoKSB7XG4gICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uSW5zaWRlKCksXG4gICAgICAgICAgY2xlYW5JbnNpZGUgPSBjbGVhbiAmJiBzdGFydEluc2lkZSxcbiAgICAgICAgICB2aXNpYmxlID0gKHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICBpZiAoY2xlYW5JbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xuICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHZfID0gZmFsc2U7XG4gICAgICB4XyA9IHlfID0gTmFOO1xuICAgIH1cblxuICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cbiAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgLy8gY2xpcHBpbmcgaXNzdWVzLlxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICB9XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBpZiAodl8pIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goW3gsIHldKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICYmIHZfKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSxcbiAgICAgICAgICAgICAgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICBpZiAoY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpKSB7XG4gICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgaWYgKCF2KSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3RyZWFtO1xuICB9O1xufVxuIiwiaW1wb3J0IHBvaW50RXF1YWwgZnJvbSBcIi4uL3BvaW50RXF1YWwuanNcIjtcbmltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICB0aGlzLnggPSBwb2ludDtcbiAgdGhpcy56ID0gcG9pbnRzO1xuICB0aGlzLm8gPSBvdGhlcjsgLy8gYW5vdGhlciBpbnRlcnNlY3Rpb25cbiAgdGhpcy5lID0gZW50cnk7IC8vIGlzIGFuIGVudHJ5P1xuICB0aGlzLnYgPSBmYWxzZTsgLy8gdmlzaXRlZFxuICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsOyAvLyBuZXh0ICYgcHJldmlvdXNcbn1cblxuLy8gQSBnZW5lcmFsaXplZCBwb2x5Z29uIGNsaXBwaW5nIGFsZ29yaXRobTogZ2l2ZW4gYSBwb2x5Z29uIHRoYXQgaGFzIGJlZW4gY3V0XG4vLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4vLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gIHZhciBzdWJqZWN0ID0gW10sXG4gICAgICBjbGlwID0gW10sXG4gICAgICBpLFxuICAgICAgbjtcblxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl0sIHg7XG5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBpZiAoIXAwWzJdICYmICFwMVsyXSkge1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgZGVnZW5lcmF0ZSBjYXNlcyBieSBtb3ZpbmcgdGhlIHBvaW50XG4gICAgICBwMVswXSArPSAyICogZXBzaWxvbjtcbiAgICB9XG5cbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMCwgbnVsbCwgeCwgZmFsc2UpKTtcbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIG51bGwsIHgsIHRydWUpKTtcbiAgfSk7XG5cbiAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcbiAgbGluayhzdWJqZWN0KTtcbiAgbGluayhjbGlwKTtcblxuICBmb3IgKGkgPSAwLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjbGlwW2ldLmUgPSBzdGFydEluc2lkZSA9ICFzdGFydEluc2lkZTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHN1YmplY3RbMF0sXG4gICAgICBwb2ludHMsXG4gICAgICBwb2ludDtcblxuICB3aGlsZSAoMSkge1xuICAgIC8vIEZpbmQgZmlyc3QgdW52aXNpdGVkIGludGVyc2VjdGlvbi5cbiAgICB2YXIgY3VycmVudCA9IHN0YXJ0LFxuICAgICAgICBpc1N1YmplY3QgPSB0cnVlO1xuICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgZm9yIChpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICBzdHJlYW0ubGluZUVuZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbmsoYXJyYXkpIHtcbiAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgdmFyIG4sXG4gICAgICBpID0gMCxcbiAgICAgIGEgPSBhcnJheVswXSxcbiAgICAgIGI7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgIGIucCA9IGE7XG4gICAgYSA9IGI7XG4gIH1cbiAgYS5uID0gYiA9IGFycmF5WzBdO1xuICBiLnAgPSBhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuXG4gIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgfVxuXG4gIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgfTtcblxuICByZXR1cm4gY29tcG9zZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtyYW5nZX0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2FicywgY2VpbCwgZXBzaWxvbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgdmFyIHkgPSByYW5nZSh5MCwgeTEgLSBlcHNpbG9uLCBkeSkuY29uY2F0KHkxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHkubWFwKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVkoeDAsIHgxLCBkeCkge1xuICB2YXIgeCA9IHJhbmdlKHgwLCB4MSAtIGVwc2lsb24sIGR4KS5jb25jYXQoeDEpO1xuICByZXR1cm4gZnVuY3Rpb24oeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICB2YXIgeDEsIHgwLCBYMSwgWDAsXG4gICAgICB5MSwgeTAsIFkxLCBZMCxcbiAgICAgIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLFxuICAgICAgeCwgeSwgWCwgWSxcbiAgICAgIHByZWNpc2lvbiA9IDIuNTtcblxuICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKX07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICByZXR1cm4gcmFuZ2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxuICAgICAgICAuY29uY2F0KHJhbmdlKGNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpXG4gICAgICAgIC5jb25jYXQocmFuZ2UoY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb247IH0pLm1hcCh4KSlcbiAgICAgICAgLmNvbmNhdChyYW5nZShjZWlsKHkwIC8gZHkpICogZHksIHkxLCBkeSkuZmlsdGVyKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIGFicyh5ICUgRFkpID4gZXBzaWxvbjsgfSkubWFwKHkpKTtcbiAgfVxuXG4gIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbihjb29yZGluYXRlcykgeyByZXR1cm4ge3R5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXN9OyB9KTtcbiAgfTtcblxuICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgIFgoWDApLmNvbmNhdChcbiAgICAgICAgWShZMSkuc2xpY2UoMSksXG4gICAgICAgIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSxcbiAgICAgICAgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKVxuICAgICAgXVxuICAgIH07XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1ham9yKF8pLmV4dGVudE1pbm9yKF8pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW1gwLCBZMF0sIFtYMSwgWTFdXTtcbiAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgIGlmIChZMCA+IFkxKSBfID0gWTAsIFkwID0gWTEsIFkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgaWYgKHgwID4geDEpIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xuICAgIGlmICh5MCA+IHkxKSBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNYWpvcihfKS5zdGVwTWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbRFgsIERZXTtcbiAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgcHJlY2lzaW9uID0gK187XG4gICAgeCA9IGdyYXRpY3VsZVgoeTAsIHkxLCA5MCk7XG4gICAgeSA9IGdyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgIFggPSBncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xuICAgIFkgPSBncmF0aWN1bGVZKFgwLCBYMSwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIHJldHVybiBncmF0aWN1bGVcbiAgICAgIC5leHRlbnRNYWpvcihbWy0xODAsIC05MCArIGVwc2lsb25dLCBbMTgwLCA5MCAtIGVwc2lsb25dXSlcbiAgICAgIC5leHRlbnRNaW5vcihbWy0xODAsIC04MCAtIGVwc2lsb25dLCBbMTgwLCA4MCArIGVwc2lsb25dXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF0aWN1bGUxMCgpIHtcbiAgcmV0dXJuIGdyYXRpY3VsZSgpKCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtNjtcbmV4cG9ydCB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCB2YXIgdGF1ID0gcGkgKiAyO1xuXG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgdmFyIGFicyA9IE1hdGguYWJzO1xuZXhwb3J0IHZhciBhdGFuID0gTWF0aC5hdGFuO1xuZXhwb3J0IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgdmFyIGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBleHAgPSBNYXRoLmV4cDtcbmV4cG9ydCB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuZXhwb3J0IHZhciBsb2cgPSBNYXRoLmxvZztcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuZXhwb3J0IHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuZXhwb3J0IHZhciB0YW4gPSBNYXRoLnRhbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhdmVyc2luKHgpIHtcbiAgcmV0dXJuICh4ID0gc2luKHggLyAyKSkgKiB4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJpbXBvcnQgYWRkZXIgZnJvbSBcIi4uL2FkZGVyLmpzXCI7XG5pbXBvcnQge2Fic30gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciBhcmVhU3VtID0gYWRkZXIoKSxcbiAgICBhcmVhUmluZ1N1bSA9IGFkZGVyKCksXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGFyZWFTdHJlYW0gPSB7XG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0O1xuICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFTdHJlYW0ucG9pbnQgPSBub29wO1xuICAgIGFyZWFTdW0uYWRkKGFicyhhcmVhUmluZ1N1bSkpO1xuICAgIGFyZWFSaW5nU3VtLnJlc2V0KCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBhcmVhU3VtIC8gMjtcbiAgICBhcmVhU3VtLnJlc2V0KCk7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZWFSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50Rmlyc3QoeCwgeSkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50O1xuICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50KHgsIHkpIHtcbiAgYXJlYVJpbmdTdW0uYWRkKHkwICogeCAtIHgwICogeSk7XG4gIHgwID0geCwgeTAgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgYXJlYVBvaW50KHgwMCwgeTAwKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJlYVN0cmVhbTtcbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciB4MCA9IEluZmluaXR5LFxuICAgIHkwID0geDAsXG4gICAgeDEgPSAteDAsXG4gICAgeTEgPSB4MTtcblxudmFyIGJvdW5kc1N0cmVhbSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50LFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogbm9vcCxcbiAgcG9seWdvbkVuZDogbm9vcCxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm91bmRzID0gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgeDEgPSB5MSA9IC0oeTAgPSB4MCA9IEluZmluaXR5KTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludCh4LCB5KSB7XG4gIGlmICh4IDwgeDApIHgwID0geDtcbiAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gIGlmICh5ID4geTEpIHkxID0geTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYm91bmRzU3RyZWFtO1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG4vLyBUT0RPIEVuZm9yY2UgcG9zaXRpdmUgYXJlYSBmb3IgZXh0ZXJpb3IsIG5lZ2F0aXZlIGFyZWEgZm9yIGludGVyaW9yP1xuXG52YXIgWDAgPSAwLFxuICAgIFkwID0gMCxcbiAgICBaMCA9IDAsXG4gICAgWDEgPSAwLFxuICAgIFkxID0gMCxcbiAgICBaMSA9IDAsXG4gICAgWDIgPSAwLFxuICAgIFkyID0gMCxcbiAgICBaMiA9IDAsXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBwb2ludDogY2VudHJvaWRQb2ludCxcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcbiAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjZW50cm9pZCA9IFoyID8gW1gyIC8gWjIsIFkyIC8gWjJdXG4gICAgICAgIDogWjEgPyBbWDEgLyBaMSwgWTEgLyBaMV1cbiAgICAgICAgOiBaMCA/IFtYMCAvIFowLCBZMCAvIFowXVxuICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgWDAgPSBZMCA9IFowID1cbiAgICBYMSA9IFkxID0gWjEgPVxuICAgIFgyID0gWTIgPSBaMiA9IDA7XG4gICAgcmV0dXJuIGNlbnRyb2lkO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KHgsIHkpIHtcbiAgWDAgKz0geDtcbiAgWTAgKz0geTtcbiAgKytaMDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0TGluZTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0TGluZSh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludExpbmU7XG4gIGNlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50TGluZSh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgWjEgKz0gejtcbiAgY2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RSaW5nO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUG9pbnRSaW5nKHgwMCwgeTAwKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0UmluZyh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludFJpbmc7XG4gIGNlbnRyb2lkUG9pbnQoeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50UmluZyh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCxcbiAgICAgIGR5ID0geSAtIHkwLFxuICAgICAgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gIFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gIFoxICs9IHo7XG5cbiAgeiA9IHkwICogeCAtIHgwICogeTtcbiAgWDIgKz0geiAqICh4MCArIHgpO1xuICBZMiArPSB6ICogKHkwICsgeSk7XG4gIFoyICs9IHogKiAzO1xuICBjZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2VudHJvaWRTdHJlYW07XG4iLCJpbXBvcnQge3RhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblBhdGhDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCArIHRoaXMuX3JhZGl1cywgeSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKHgsIHksIHRoaXMuX3JhZGl1cywgMCwgdGF1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXN1bHQ6IG5vb3Bcbn07XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuLi9zdHJlYW0uanNcIjtcbmltcG9ydCBwYXRoQXJlYSBmcm9tIFwiLi9hcmVhLmpzXCI7XG5pbXBvcnQgcGF0aEJvdW5kcyBmcm9tIFwiLi9ib3VuZHMuanNcIjtcbmltcG9ydCBwYXRoQ2VudHJvaWQgZnJvbSBcIi4vY2VudHJvaWQuanNcIjtcbmltcG9ydCBQYXRoQ29udGV4dCBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQgcGF0aE1lYXN1cmUgZnJvbSBcIi4vbWVhc3VyZS5qc1wiO1xuaW1wb3J0IFBhdGhTdHJpbmcgZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHByb2plY3Rpb24sIGNvbnRleHQpIHtcbiAgdmFyIHBvaW50UmFkaXVzID0gNC41LFxuICAgICAgcHJvamVjdGlvblN0cmVhbSxcbiAgICAgIGNvbnRleHRTdHJlYW07XG5cbiAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjb250ZXh0U3RyZWFtKSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0U3RyZWFtLnJlc3VsdCgpO1xuICB9XG5cbiAgcGF0aC5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQXJlYSkpO1xuICAgIHJldHVybiBwYXRoQXJlYS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLm1lYXN1cmUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhNZWFzdXJlKSk7XG4gICAgcmV0dXJuIHBhdGhNZWFzdXJlLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGguYm91bmRzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQm91bmRzKSk7XG4gICAgcmV0dXJuIHBhdGhCb3VuZHMucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aENlbnRyb2lkKSk7XG4gICAgcmV0dXJuIHBhdGhDZW50cm9pZC5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLnByb2plY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdGlvblN0cmVhbSA9IF8gPT0gbnVsbCA/IChwcm9qZWN0aW9uID0gbnVsbCwgaWRlbnRpdHkpIDogKHByb2plY3Rpb24gPSBfKS5zdHJlYW0sIHBhdGgpIDogcHJvamVjdGlvbjtcbiAgfTtcblxuICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcbiAgICBjb250ZXh0U3RyZWFtID0gXyA9PSBudWxsID8gKGNvbnRleHQgPSBudWxsLCBuZXcgUGF0aFN0cmluZykgOiBuZXcgUGF0aENvbnRleHQoY29udGV4dCA9IF8pO1xuICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb2ludFJhZGl1cztcbiAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihwcm9qZWN0aW9uKS5jb250ZXh0KGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IGFkZGVyIGZyb20gXCIuLi9hZGRlci5qc1wiO1xuaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIGxlbmd0aFN1bSA9IGFkZGVyKCksXG4gICAgbGVuZ3RoUmluZyxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwLFxuICAgIHkwO1xuXG52YXIgbGVuZ3RoU3RyZWFtID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAobGVuZ3RoUmluZykgbGVuZ3RoUG9pbnQoeDAwLCB5MDApO1xuICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IG5vb3A7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoUmluZyA9IHRydWU7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSBudWxsO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtO1xuICAgIGxlbmd0aFN1bS5yZXNldCgpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50Rmlyc3QoeCwgeSkge1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludDtcbiAgeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHk7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50KHgsIHkpIHtcbiAgeDAgLT0geCwgeTAgLT0geTtcbiAgbGVuZ3RoU3VtLmFkZChzcXJ0KHgwICogeDAgKyB5MCAqIHkwKSk7XG4gIHgwID0geCwgeTAgPSB5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBsZW5ndGhTdHJlYW07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYXRoU3RyaW5nKCkge1xuICB0aGlzLl9zdHJpbmcgPSBbXTtcbn1cblxuUGF0aFN0cmluZy5wcm90b3R5cGUgPSB7XG4gIF9yYWRpdXM6IDQuNSxcbiAgX2NpcmNsZTogY2lyY2xlKDQuNSksXG4gIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgaWYgKChfID0gK18pICE9PSB0aGlzLl9yYWRpdXMpIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXMuX2NpcmNsZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fc3RyaW5nLnB1c2goXCJaXCIpO1xuICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTFwiLCB4LCBcIixcIiwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fY2lyY2xlID09IG51bGwpIHRoaXMuX2NpcmNsZSA9IGNpcmNsZSh0aGlzLl9yYWRpdXMpO1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHRoaXMuX2NpcmNsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc3RyaW5nLmxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3N0cmluZy5qb2luKFwiXCIpO1xuICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNpcmNsZShyYWRpdXMpIHtcbiAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXNcbiAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1c1xuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXNcbiAgICAgICsgXCJ6XCI7XG59XG4iLCJpbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbjtcbn1cbiIsImltcG9ydCBhZGRlciBmcm9tIFwiLi9hZGRlci5qc1wiO1xuaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbkNyb3NzLCBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlfSBmcm9tIFwiLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIHBpLCBxdWFydGVyUGksIHNpZ24sIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbnZhciBzdW0gPSBhZGRlcigpO1xuXG5mdW5jdGlvbiBsb25naXR1ZGUocG9pbnQpIHtcbiAgaWYgKGFicyhwb2ludFswXSkgPD0gcGkpXG4gICAgcmV0dXJuIHBvaW50WzBdO1xuICBlbHNlXG4gICAgcmV0dXJuIHNpZ24ocG9pbnRbMF0pICogKChhYnMocG9pbnRbMF0pICsgcGkpICUgdGF1IC0gcGkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwb2x5Z29uLCBwb2ludCkge1xuICB2YXIgbGFtYmRhID0gbG9uZ2l0dWRlKHBvaW50KSxcbiAgICAgIHBoaSA9IHBvaW50WzFdLFxuICAgICAgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBub3JtYWwgPSBbc2luKGxhbWJkYSksIC1jb3MobGFtYmRhKSwgMF0sXG4gICAgICBhbmdsZSA9IDAsXG4gICAgICB3aW5kaW5nID0gMDtcblxuICBzdW0ucmVzZXQoKTtcblxuICBpZiAoc2luUGhpID09PSAxKSBwaGkgPSBoYWxmUGkgKyBlcHNpbG9uO1xuICBlbHNlIGlmIChzaW5QaGkgPT09IC0xKSBwaGkgPSAtaGFsZlBpIC0gZXBzaWxvbjtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEobSA9IChyaW5nID0gcG9seWdvbltpXSkubGVuZ3RoKSkgY29udGludWU7XG4gICAgdmFyIHJpbmcsXG4gICAgICAgIG0sXG4gICAgICAgIHBvaW50MCA9IHJpbmdbbSAtIDFdLFxuICAgICAgICBsYW1iZGEwID0gbG9uZ2l0dWRlKHBvaW50MCksXG4gICAgICAgIHBoaTAgPSBwb2ludDBbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICBzaW5QaGkwID0gc2luKHBoaTApLFxuICAgICAgICBjb3NQaGkwID0gY29zKHBoaTApO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2osIGxhbWJkYTAgPSBsYW1iZGExLCBzaW5QaGkwID0gc2luUGhpMSwgY29zUGhpMCA9IGNvc1BoaTEsIHBvaW50MCA9IHBvaW50MSkge1xuICAgICAgdmFyIHBvaW50MSA9IHJpbmdbal0sXG4gICAgICAgICAgbGFtYmRhMSA9IGxvbmdpdHVkZShwb2ludDEpLFxuICAgICAgICAgIHBoaTEgPSBwb2ludDFbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICAgIHNpblBoaTEgPSBzaW4ocGhpMSksXG4gICAgICAgICAgY29zUGhpMSA9IGNvcyhwaGkxKSxcbiAgICAgICAgICBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICAgIHNpZ24gPSBkZWx0YSA+PSAwID8gMSA6IC0xLFxuICAgICAgICAgIGFic0RlbHRhID0gc2lnbiAqIGRlbHRhLFxuICAgICAgICAgIGFudGltZXJpZGlhbiA9IGFic0RlbHRhID4gcGksXG4gICAgICAgICAgayA9IHNpblBoaTAgKiBzaW5QaGkxO1xuXG4gICAgICBzdW0uYWRkKGF0YW4yKGsgKiBzaWduICogc2luKGFic0RlbHRhKSwgY29zUGhpMCAqIGNvc1BoaTEgKyBrICogY29zKGFic0RlbHRhKSkpO1xuICAgICAgYW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZGVsdGEgKyBzaWduICogdGF1IDogZGVsdGE7XG5cbiAgICAgIC8vIEFyZSB0aGUgbG9uZ2l0dWRlcyBlaXRoZXIgc2lkZSBvZiB0aGUgcG9pbnTigJlzIG1lcmlkaWFuIChsYW1iZGEpLFxuICAgICAgLy8gYW5kIGFyZSB0aGUgbGF0aXR1ZGVzIHNtYWxsZXIgdGhhbiB0aGUgcGFyYWxsZWwgKHBoaSk/XG4gICAgICBpZiAoYW50aW1lcmlkaWFuIF4gbGFtYmRhMCA+PSBsYW1iZGEgXiBsYW1iZGExID49IGxhbWJkYSkge1xuICAgICAgICB2YXIgYXJjID0gY2FydGVzaWFuQ3Jvc3MoY2FydGVzaWFuKHBvaW50MCksIGNhcnRlc2lhbihwb2ludDEpKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShhcmMpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3Mobm9ybWFsLCBhcmMpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGludGVyc2VjdGlvbik7XG4gICAgICAgIHZhciBwaGlBcmMgPSAoYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IC0xIDogMSkgKiBhc2luKGludGVyc2VjdGlvblsyXSk7XG4gICAgICAgIGlmIChwaGkgPiBwaGlBcmMgfHwgcGhpID09PSBwaGlBcmMgJiYgKGFyY1swXSB8fCBhcmNbMV0pKSB7XG4gICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QsIGRldGVybWluZSB3aGV0aGVyIHRoZSBTb3V0aCBwb2xlIGlzIGluc2lkZSBvciBvdXRzaWRlOlxuICAvL1xuICAvLyBJdCBpcyBpbnNpZGUgaWY6XG4gIC8vICogdGhlIHBvbHlnb24gd2luZHMgYXJvdW5kIGl0IGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbi5cbiAgLy8gKiB0aGUgcG9seWdvbiBkb2VzIG5vdCAoY3VtdWxhdGl2ZWx5KSB3aW5kIGFyb3VuZCBpdCwgYnV0IGhhcyBhIG5lZ2F0aXZlXG4gIC8vICAgKGNvdW50ZXItY2xvY2t3aXNlKSBhcmVhLlxuICAvL1xuICAvLyBTZWNvbmQsIGNvdW50IHRoZSAoc2lnbmVkKSBudW1iZXIgb2YgdGltZXMgYSBzZWdtZW50IGNyb3NzZXMgYSBsYW1iZGFcbiAgLy8gZnJvbSB0aGUgcG9pbnQgdG8gdGhlIFNvdXRoIHBvbGUuICBJZiBpdCBpcyB6ZXJvLCB0aGVuIHRoZSBwb2ludCBpcyB0aGVcbiAgLy8gc2FtZSBzaWRlIGFzIHRoZSBTb3V0aCBwb2xlLlxuXG4gIHJldHVybiAoYW5nbGUgPCAtZXBzaWxvbiB8fCBhbmdsZSA8IGVwc2lsb24gJiYgc3VtIDwgLWVwc2lsb24pIF4gKHdpbmRpbmcgJiAxKTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyBnZW9TdHJlYW19IGZyb20gXCIuLi9zdHJlYW0uanNcIjtcbmltcG9ydCBib3VuZHNTdHJlYW0gZnJvbSBcIi4uL3BhdGgvYm91bmRzLmpzXCI7XG5cbmZ1bmN0aW9uIGZpdChwcm9qZWN0aW9uLCBmaXRCb3VuZHMsIG9iamVjdCkge1xuICB2YXIgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgcHJvamVjdGlvbi5zY2FsZSgxNTApLnRyYW5zbGF0ZShbMCwgMF0pO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSkpO1xuICBmaXRCb3VuZHMoYm91bmRzU3RyZWFtLnJlc3VsdCgpKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KGNsaXApO1xuICByZXR1cm4gcHJvamVjdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSxcbiAgICAgICAgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSxcbiAgICAgICAgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksXG4gICAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSArd2lkdGgsXG4gICAgICAgIGsgPSB3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSxcbiAgICAgICAgeCA9ICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9IC1rICogYlswXVsxXTtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciBoID0gK2hlaWdodCxcbiAgICAgICAgayA9IGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pLFxuICAgICAgICB4ID0gLWsgKiBiWzBdWzBdLFxuICAgICAgICB5ID0gKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG4iLCJpbXBvcnQgY2xpcFJlY3RhbmdsZSBmcm9tIFwiLi4vY2xpcC9yZWN0YW5nbGUuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCB7Zml0RXh0ZW50LCBmaXRTaXplLCBmaXRXaWR0aCwgZml0SGVpZ2h0fSBmcm9tIFwiLi9maXQuanNcIjtcbmltcG9ydCB7Y29zLCBkZWdyZWVzLCByYWRpYW5zLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgayA9IDEsIHR4ID0gMCwgdHkgPSAwLCBzeCA9IDEsIHN5ID0gMSwgLy8gc2NhbGUsIHRyYW5zbGF0ZSBhbmQgcmVmbGVjdFxuICAgICAgYWxwaGEgPSAwLCBjYSwgc2EsIC8vIGFuZ2xlXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIC8vIGNsaXAgZXh0ZW50XG4gICAgICBreCA9IDEsIGt5ID0gMSxcbiAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybWVyKHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICB2YXIgcCA9IHByb2plY3Rpb24oW3gsIHldKVxuICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHBbMF0sIHBbMV0pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHBvc3RjbGlwID0gaWRlbnRpdHksXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGt4ID0gayAqIHN4O1xuICAgIGt5ID0gayAqIHN5O1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdGlvbiAocCkge1xuICAgIHZhciB4ID0gcFswXSAqIGt4LCB5ID0gcFsxXSAqIGt5O1xuICAgIGlmIChhbHBoYSkge1xuICAgICAgdmFyIHQgPSB5ICogY2EgLSB4ICogc2E7XG4gICAgICB4ID0geCAqIGNhICsgeSAqIHNhO1xuICAgICAgeSA9IHQ7XG4gICAgfSAgICBcbiAgICByZXR1cm4gW3ggKyB0eCwgeSArIHR5XTtcbiAgfVxuICBwcm9qZWN0aW9uLmludmVydCA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgeCA9IHBbMF0gLSB0eCwgeSA9IHBbMV0gLSB0eTtcbiAgICBpZiAoYWxwaGEpIHtcbiAgICAgIHZhciB0ID0geSAqIGNhICsgeCAqIHNhO1xuICAgICAgeCA9IHggKiBjYSAtIHkgKiBzYTtcbiAgICAgIHkgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gW3ggLyBreCwgeSAvIGt5XTtcbiAgfTtcbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm0ocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKTtcbiAgfTtcbiAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgfTtcbiAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcFJlY3RhbmdsZSh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICB9O1xuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVzZXQoKSkgOiBrO1xuICB9O1xuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eCA9ICtfWzBdLCB0eSA9ICtfWzFdLCByZXNldCgpKSA6IFt0eCwgdHldO1xuICB9XG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgc2EgPSBzaW4oYWxwaGEpLCBjYSA9IGNvcyhhbHBoYSksIHJlc2V0KCkpIDogYWxwaGEgKiBkZWdyZWVzO1xuICB9O1xuICBwcm9qZWN0aW9uLnJlZmxlY3RYID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN4ID0gXyA/IC0xIDogMSwgcmVzZXQoKSkgOiBzeCA8IDA7XG4gIH07XG4gIHByb2plY3Rpb24ucmVmbGVjdFkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3kgPSBfID8gLTEgOiAxLCByZXNldCgpKSA6IHN5IDwgMDtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0aW9uO1xufVxuIiwiaW1wb3J0IGNsaXBBbnRpbWVyaWRpYW4gZnJvbSBcIi4uL2NsaXAvYW50aW1lcmlkaWFuLmpzXCI7XG5pbXBvcnQgY2xpcENpcmNsZSBmcm9tIFwiLi4vY2xpcC9jaXJjbGUuanNcIjtcbmltcG9ydCBjbGlwUmVjdGFuZ2xlIGZyb20gXCIuLi9jbGlwL3JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4uL2NvbXBvc2UuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7Y29zLCBkZWdyZWVzLCByYWRpYW5zLCBzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge3JvdGF0ZVJhZGlhbnN9IGZyb20gXCIuLi9yb3RhdGlvbi5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IHtmaXRFeHRlbnQsIGZpdFNpemUsIGZpdFdpZHRoLCBmaXRIZWlnaHR9IGZyb20gXCIuL2ZpdC5qc1wiO1xuaW1wb3J0IHJlc2FtcGxlIGZyb20gXCIuL3Jlc2FtcGxlLmpzXCI7XG5cbnZhciB0cmFuc2Zvcm1SYWRpYW5zID0gdHJhbnNmb3JtZXIoe1xuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiByYWRpYW5zLCB5ICogcmFkaWFucyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciByID0gcm90YXRlKHgsIHkpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvaW50KHJbMF0sIHJbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSwgc3gsIHN5KSB7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5KSB7XG4gICAgeCAqPSBzeDsgeSAqPSBzeTtcbiAgICByZXR1cm4gW2R4ICsgayAqIHgsIGR5IC0gayAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsoeCAtIGR4KSAvIGsgKiBzeCwgKGR5IC0geSkgLyBrICogc3ldO1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCBkeCwgZHksIHN4LCBzeSwgYWxwaGEpIHtcbiAgdmFyIGNvc0FscGhhID0gY29zKGFscGhhKSxcbiAgICAgIHNpbkFscGhhID0gc2luKGFscGhhKSxcbiAgICAgIGEgPSBjb3NBbHBoYSAqIGssXG4gICAgICBiID0gc2luQWxwaGEgKiBrLFxuICAgICAgYWkgPSBjb3NBbHBoYSAvIGssXG4gICAgICBiaSA9IHNpbkFscGhhIC8gayxcbiAgICAgIGNpID0gKHNpbkFscGhhICogZHkgLSBjb3NBbHBoYSAqIGR4KSAvIGssXG4gICAgICBmaSA9IChzaW5BbHBoYSAqIGR4ICsgY29zQWxwaGEgKiBkeSkgLyBrO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHggKj0gc3g7IHkgKj0gc3k7XG4gICAgcmV0dXJuIFthICogeCAtIGIgKiB5ICsgZHgsIGR5IC0gYiAqIHggLSBhICogeV07XG4gIH1cbiAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gW3N4ICogKGFpICogeCAtIGJpICogeSArIGNpKSwgc3kgKiAoZmkgLSBiaSAqIHggLSBhaSAqIHkpXTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gIHJldHVybiBwcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHsgcmV0dXJuIHByb2plY3Q7IH0pKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpIHtcbiAgdmFyIHByb2plY3QsXG4gICAgICBrID0gMTUwLCAvLyBzY2FsZVxuICAgICAgeCA9IDQ4MCwgeSA9IDI1MCwgLy8gdHJhbnNsYXRlXG4gICAgICBsYW1iZGEgPSAwLCBwaGkgPSAwLCAvLyBjZW50ZXJcbiAgICAgIGRlbHRhTGFtYmRhID0gMCwgZGVsdGFQaGkgPSAwLCBkZWx0YUdhbW1hID0gMCwgcm90YXRlLCAvLyBwcmUtcm90YXRlXG4gICAgICBhbHBoYSA9IDAsIC8vIHBvc3Qtcm90YXRlIGFuZ2xlXG4gICAgICBzeCA9IDEsIC8vIHJlZmxlY3RYXG4gICAgICBzeSA9IDEsIC8vIHJlZmxlY3RYXG4gICAgICB0aGV0YSA9IG51bGwsIHByZWNsaXAgPSBjbGlwQW50aW1lcmlkaWFuLCAvLyBwcmUtY2xpcCBhbmdsZVxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCBwb3N0Y2xpcCA9IGlkZW50aXR5LCAvLyBwb3N0LWNsaXAgZXh0ZW50XG4gICAgICBkZWx0YTIgPSAwLjUsIC8vIHByZWNpc2lvblxuICAgICAgcHJvamVjdFJlc2FtcGxlLFxuICAgICAgcHJvamVjdFRyYW5zZm9ybSxcbiAgICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0sXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gcHJvamVjdFJvdGF0ZVRyYW5zZm9ybShwb2ludFswXSAqIHJhZGlhbnMsIHBvaW50WzFdICogcmFkaWFucyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZlcnQocG9pbnQpIHtcbiAgICBwb2ludCA9IHByb2plY3RSb3RhdGVUcmFuc2Zvcm0uaW52ZXJ0KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMsIHBvaW50WzFdICogZGVncmVlc107XG4gIH1cblxuICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnModHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkocHJlY2xpcChwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKSkpKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9IF8sIHRoZXRhID0gdW5kZWZpbmVkLCByZXNldCgpKSA6IHByZWNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gK18gPyBjbGlwQ2lyY2xlKHRoZXRhID0gXyAqIHJhZGlhbnMpIDogKHRoZXRhID0gbnVsbCwgY2xpcEFudGltZXJpZGlhbiksIHJlc2V0KCkpIDogdGhldGEgKiBkZWdyZWVzO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVjZW50ZXIoKSkgOiBrO1xuICB9O1xuXG4gIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArX1swXSwgeSA9ICtfWzFdLCByZWNlbnRlcigpKSA6IFt4LCB5XTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgcGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogW2xhbWJkYSAqIGRlZ3JlZXMsIHBoaSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlbHRhTGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhUGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhR2FtbWEgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogcmFkaWFucyA6IDAsIHJlY2VudGVyKCkpIDogW2RlbHRhTGFtYmRhICogZGVncmVlcywgZGVsdGFQaGkgKiBkZWdyZWVzLCBkZWx0YUdhbW1hICogZGVncmVlc107XG4gIH07XG5cbiAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9IF8gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IGFscGhhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJlZmxlY3RYID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN4ID0gXyA/IC0xIDogMSwgcmVjZW50ZXIoKSkgOiBzeCA8IDA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yZWZsZWN0WSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeSA9IF8gPyAtMSA6IDEsIHJlY2VudGVyKCkpIDogc3kgPCAwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMiA9IF8gKiBfKSwgcmVzZXQoKSkgOiBzcXJ0KGRlbHRhMik7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlY2VudGVyKCkge1xuICAgIHZhciBjZW50ZXIgPSBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCAwLCAwLCBzeCwgc3ksIGFscGhhKS5hcHBseShudWxsLCBwcm9qZWN0KGxhbWJkYSwgcGhpKSksXG4gICAgICAgIHRyYW5zZm9ybSA9IChhbHBoYSA/IHNjYWxlVHJhbnNsYXRlUm90YXRlIDogc2NhbGVUcmFuc2xhdGUpKGssIHggLSBjZW50ZXJbMF0sIHkgLSBjZW50ZXJbMV0sIHN4LCBzeSwgYWxwaGEpO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKTtcbiAgICBwcm9qZWN0VHJhbnNmb3JtID0gY29tcG9zZShwcm9qZWN0LCB0cmFuc2Zvcm0pO1xuICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0gPSBjb21wb3NlKHJvdGF0ZSwgcHJvamVjdFRyYW5zZm9ybSk7XG4gICAgcHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyKTtcbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICByZXR1cm4gcmVjZW50ZXIoKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFufSBmcm9tIFwiLi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgcmFkaWFucywgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcblxudmFyIG1heERlcHRoID0gMTYsIC8vIG1heGltdW0gZGVwdGggb2Ygc3ViZGl2aXNpb25cbiAgICBjb3NNaW5EaXN0YW5jZSA9IGNvcygzMCAqIHJhZGlhbnMpOyAvLyBjb3MobWluaW11bSBhbmd1bGFyIGRpc3RhbmNlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcm9qZWN0LCBkZWx0YTIpIHtcbiAgcmV0dXJuICtkZWx0YTIgPyByZXNhbXBsZShwcm9qZWN0LCBkZWx0YTIpIDogcmVzYW1wbGVOb25lKHByb2plY3QpO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZU5vbmUocHJvamVjdCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikge1xuXG4gIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgdmFyIGR4ID0geDEgLSB4MCxcbiAgICAgICAgZHkgPSB5MSAtIHkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChkMiA+IDQgKiBkZWx0YTIgJiYgZGVwdGgtLSkge1xuICAgICAgdmFyIGEgPSBhMCArIGExLFxuICAgICAgICAgIGIgPSBiMCArIGIxLFxuICAgICAgICAgIGMgPSBjMCArIGMxLFxuICAgICAgICAgIG0gPSBzcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksXG4gICAgICAgICAgcGhpMiA9IGFzaW4oYyAvPSBtKSxcbiAgICAgICAgICBsYW1iZGEyID0gYWJzKGFicyhjKSAtIDEpIDwgZXBzaWxvbiB8fCBhYnMobGFtYmRhMCAtIGxhbWJkYTEpIDwgZXBzaWxvbiA/IChsYW1iZGEwICsgbGFtYmRhMSkgLyAyIDogYXRhbjIoYiwgYSksXG4gICAgICAgICAgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksXG4gICAgICAgICAgeDIgPSBwWzBdLFxuICAgICAgICAgIHkyID0gcFsxXSxcbiAgICAgICAgICBkeDIgPSB4MiAtIHgwLFxuICAgICAgICAgIGR5MiA9IHkyIC0geTAsXG4gICAgICAgICAgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxuICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHsgLy8gYW5ndWxhciBkaXN0YW5jZVxuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCBsYW1iZGEyLCBhLCBiLCBjLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGxhbWJkYTAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgbGFtYmRhMCwgeDAsIHkwLCBhMCwgYjAsIGMwOyAvLyBwcmV2aW91cyBwb2ludFxuXG4gICAgdmFyIHJlc2FtcGxlU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25TdGFydCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7IH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIHgwID0gTmFOO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgbGFtYmRhMCA9IGxhbWJkYSwgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZVBvaW50KGxhbWJkYTAwID0gbGFtYmRhLCBwaGkpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICBsaW5lRW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4vY29tcG9zZS5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGRlZ3JlZXMsIHBpLCByYWRpYW5zLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiByb3RhdGlvbklkZW50aXR5KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbYWJzKGxhbWJkYSkgPiBwaSA/IGxhbWJkYSArIE1hdGgucm91bmQoLWxhbWJkYSAvIHRhdSkgKiB0YXUgOiBsYW1iZGEsIHBoaV07XG59XG5cbnJvdGF0aW9uSWRlbnRpdHkuaW52ZXJ0ID0gcm90YXRpb25JZGVudGl0eTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHJldHVybiAoZGVsdGFMYW1iZGEgJT0gdGF1KSA/IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gY29tcG9zZShyb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSksIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpKVxuICAgIDogcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpKVxuICAgIDogKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKVxuICAgIDogcm90YXRpb25JZGVudGl0eSk7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICByZXR1cm4gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gbGFtYmRhICs9IGRlbHRhTGFtYmRhLCBbbGFtYmRhID4gcGkgPyBsYW1iZGEgLSB0YXUgOiBsYW1iZGEgPCAtcGkgPyBsYW1iZGEgKyB0YXUgOiBsYW1iZGEsIHBoaV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHZhciByb3RhdGlvbiA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSk7XG4gIHJvdGF0aW9uLmludmVydCA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYSgtZGVsdGFMYW1iZGEpO1xuICByZXR1cm4gcm90YXRpb247XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgdmFyIGNvc0RlbHRhUGhpID0gY29zKGRlbHRhUGhpKSxcbiAgICAgIHNpbkRlbHRhUGhpID0gc2luKGRlbHRhUGhpKSxcbiAgICAgIGNvc0RlbHRhR2FtbWEgPSBjb3MoZGVsdGFHYW1tYSksXG4gICAgICBzaW5EZWx0YUdhbW1hID0gc2luKGRlbHRhR2FtbWEpO1xuXG4gIGZ1bmN0aW9uIHJvdGF0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgICB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgICBrID0geiAqIGNvc0RlbHRhUGhpICsgeCAqIHNpbkRlbHRhUGhpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSAtIGsgKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgLSB6ICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFHYW1tYSArIHkgKiBzaW5EZWx0YUdhbW1hKVxuICAgIF07XG4gIH1cblxuICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YUdhbW1hIC0geSAqIHNpbkRlbHRhR2FtbWE7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hICsgeiAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSArIGsgKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YVBoaSAtIHggKiBzaW5EZWx0YVBoaSlcbiAgICBdO1xuICB9O1xuXG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocm90YXRlKSB7XG4gIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMocm90YXRlWzBdICogcmFkaWFucywgcm90YXRlWzFdICogcmFkaWFucywgcm90YXRlLmxlbmd0aCA+IDIgPyByb3RhdGVbMl0gKiByYWRpYW5zIDogMCk7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlKGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUuaW52ZXJ0KGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59XG4iLCJmdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XG4gIGlmIChnZW9tZXRyeSAmJiBzdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICBzdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn1cblxudmFyIHN0cmVhbU9iamVjdFR5cGUgPSB7XG4gIEZlYXR1cmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9LFxuICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn07XG5cbnZhciBzdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW0uc3BoZXJlKCk7XG4gIH0sXG4gIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSwgMCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAwKTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtKTtcbiAgfSxcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0pO1xuICB9LFxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHN0cmVhbSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICBzdHJlYW0ubGluZUVuZCgpO1xufVxuXG5mdW5jdGlvbiBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBzdHJlYW0pIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAxKTtcbiAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgaWYgKG9iamVjdCAmJiBzdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgIHN0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QsIHN0cmVhbSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IHRyYW5zZm9ybWVyKG1ldGhvZHMpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW07XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICBzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkge31cblxuVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7IH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVFbmQoKTsgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cbn07XG4iLCJpbXBvcnQgeyBldmVudCwgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IGFyYywgY3VydmVDYXRtdWxsUm9tLCBjdXJ2ZUxpbmVhciwgbGluZSB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IGRpc3BhdGNoIH0gZnJvbSAnZDMtZGlzcGF0Y2gnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG52YXIgQW5ub3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5ub3RhdGlvbihfcmVmKSB7XG4gICAgdmFyIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgICAgeCA9IF9yZWYkeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeCxcbiAgICAgICAgX3JlZiR5ID0gX3JlZi55LFxuICAgICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgICBueCA9IF9yZWYubngsXG4gICAgICAgIG55ID0gX3JlZi5ueSxcbiAgICAgICAgX3JlZiRkeSA9IF9yZWYuZHksXG4gICAgICAgIGR5ID0gX3JlZiRkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkZHksXG4gICAgICAgIF9yZWYkZHggPSBfcmVmLmR4LFxuICAgICAgICBkeCA9IF9yZWYkZHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGR4LFxuICAgICAgICBfcmVmJGNvbG9yID0gX3JlZi5jb2xvcixcbiAgICAgICAgY29sb3IgPSBfcmVmJGNvbG9yID09PSB1bmRlZmluZWQgPyBcImdyZXlcIiA6IF9yZWYkY29sb3IsXG4gICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgIHN1YmplY3QgPSBfcmVmLnN1YmplY3QsXG4gICAgICAgIGNvbm5lY3RvciA9IF9yZWYuY29ubmVjdG9yLFxuICAgICAgICBub3RlID0gX3JlZi5ub3RlLFxuICAgICAgICBkaXNhYmxlID0gX3JlZi5kaXNhYmxlLFxuICAgICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEFubm90YXRpb24pO1xuXG4gICAgdGhpcy5fZHggPSBueCAhPT0gdW5kZWZpbmVkID8gbnggLSB4IDogZHg7XG4gICAgdGhpcy5fZHkgPSBueSAhPT0gdW5kZWZpbmVkID8gbnkgLSB5IDogZHk7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IFwiXCI7XG5cbiAgICB0aGlzLl90eXBlID0gdHlwZSB8fCBcIlwiO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICB0aGlzLm5vdGUgPSBub3RlIHx8IHt9O1xuICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yIHx8IHt9O1xuICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3QgfHwge307XG5cbiAgICB0aGlzLmRpc2FibGUgPSBkaXNhYmxlIHx8IFtdO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQW5ub3RhdGlvbiwgW3tcbiAgICBrZXk6IFwidXBkYXRlUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICBpZiAodGhpcy50eXBlLnNldFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudHlwZS5zZXRQb3NpdGlvbigpO1xuICAgICAgICBpZiAodGhpcy50eXBlLnN1YmplY3QgJiYgdGhpcy50eXBlLnN1YmplY3Quc2VsZWN0QWxsKFwiOm5vdCguaGFuZGxlKVwiKS5ub2RlcygpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRoaXMudHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJDb21wb25lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMudHlwZS5jbGVhckNvbXBvbmVudHMgJiYgdGhpcy50eXBlLmNsZWFyQ29tcG9uZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMudHlwZS5zZXRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy50eXBlLnNldE9mZnNldCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUuY29ubmVjdG9yLnNlbGVjdEFsbChcIjpub3QoLmhhbmRsZSlcIikubm9kZXMoKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aGlzLnR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR5cGUucmVkcmF3Tm90ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGFzc05hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIGlmICh0aGlzLnR5cGUuc2V0Q2xhc3NOYW1lKSB0aGlzLnR5cGUuc2V0Q2xhc3NOYW1lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodHlwZSkge1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmNsZWFyQ29tcG9uZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHgpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHkpIHtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb2xvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoY29sb3IpIHtcbiAgICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkeCkge1xuICAgICAgdGhpcy5fZHggPSBkeDtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkeSkge1xuICAgICAgdGhpcy5fZHkgPSBkeTtcbiAgICAgIHRoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm54XCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobngpIHtcbiAgICAgIHRoaXMuX2R4ID0gbnggLSB0aGlzLl94O1xuICAgICAgdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibnlcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShueSkge1xuICAgICAgdGhpcy5fZHkgPSBueSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMuX2R4LCB5OiB0aGlzLl9keSB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoX3JlZjIpIHtcbiAgICAgIHZhciB4ID0gX3JlZjIueCxcbiAgICAgICAgICB5ID0gX3JlZjIueTtcblxuICAgICAgdGhpcy5fZHggPSB4O1xuICAgICAgdGhpcy5fZHkgPSB5O1xuICAgICAgdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMuX3gsIHk6IHRoaXMuX3kgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKF9yZWYzKSB7XG4gICAgICB2YXIgeCA9IF9yZWYzLngsXG4gICAgICAgICAgeSA9IF9yZWYzLnk7XG5cbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLl94ICsgdGhpcy5fZHgsXG4gICAgICAgIHk6IHRoaXMuX3kgKyB0aGlzLl9keVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIHg6IHRoaXMuX3gsXG4gICAgICAgIHk6IHRoaXMuX3ksXG4gICAgICAgIGR4OiB0aGlzLl9keCxcbiAgICAgICAgZHk6IHRoaXMuX2R5XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5kYXRhICYmIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoID4gMCkganNvbi5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHRoaXMudHlwZSkganNvbi50eXBlID0gdGhpcy50eXBlO1xuICAgICAgaWYgKHRoaXMuX2NsYXNzTmFtZSkganNvbi5jbGFzc05hbWUgPSB0aGlzLl9jbGFzc05hbWU7XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3RvcikubGVuZ3RoID4gMCkganNvbi5jb25uZWN0b3IgPSB0aGlzLmNvbm5lY3RvcjtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnN1YmplY3QpLmxlbmd0aCA+IDApIGpzb24uc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm5vdGUpLmxlbmd0aCA+IDApIGpzb24ubm90ZSA9IHRoaXMubm90ZTtcblxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBbm5vdGF0aW9uO1xufSgpO1xuXG52YXIgQW5ub3RhdGlvbkNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25Db2xsZWN0aW9uKF9yZWYpIHtcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBfcmVmLmFubm90YXRpb25zLFxuICAgICAgICBhY2Nlc3NvcnMgPSBfcmVmLmFjY2Vzc29ycyxcbiAgICAgICAgYWNjZXNzb3JzSW52ZXJzZSA9IF9yZWYuYWNjZXNzb3JzSW52ZXJzZTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uQ29sbGVjdGlvbik7XG5cbiAgICB0aGlzLmFjY2Vzc29ycyA9IGFjY2Vzc29ycztcbiAgICB0aGlzLmFjY2Vzc29yc0ludmVyc2UgPSBhY2Nlc3NvcnNJbnZlcnNlO1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEFubm90YXRpb25Db2xsZWN0aW9uLCBbe1xuICAgIGtleTogXCJjbGVhclR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVHlwZXMobmV3U2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkLnR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGQuc3ViamVjdCA9IG5ld1NldHRpbmdzICYmIG5ld1NldHRpbmdzLnN1YmplY3QgfHwgZC5zdWJqZWN0O1xuICAgICAgICBkLmNvbm5lY3RvciA9IG5ld1NldHRpbmdzICYmIG5ld1NldHRpbmdzLmNvbm5lY3RvciB8fCBkLmNvbm5lY3RvcjtcbiAgICAgICAgZC5ub3RlID0gbmV3U2V0dGluZ3MgJiYgbmV3U2V0dGluZ3Mubm90ZSB8fCBkLm5vdGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25XaXRoQWNjZXNzb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uV2l0aEFjY2Vzc29ycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkLnR5cGUuc2V0UG9zaXRpb25XaXRoQWNjZXNzb3JzKF90aGlzLmFjY2Vzc29ycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE1vZGUoX2VkaXRNb2RlKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGEudHlwZS5lZGl0TW9kZSA9IF9lZGl0TW9kZTtcbiAgICAgICAgICBhLnR5cGUudXBkYXRlRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZURpc2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzYWJsZShkaXNhYmxlKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGRpc2FibGUuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGEudHlwZVtkXSkge1xuICAgICAgICAgICAgICBhLnR5cGVbZF0ucmVtb3ZlICYmIGEudHlwZVtkXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgYS50eXBlW2RdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVGV4dFdyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGV4dFdyYXAodGV4dFdyYXApIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoYS50eXBlICYmIGEudHlwZS51cGRhdGVUZXh0V3JhcCkge1xuICAgICAgICAgIGEudHlwZS51cGRhdGVUZXh0V3JhcCh0ZXh0V3JhcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRleHQoKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSAmJiBhLnR5cGUuZHJhd1RleHQpIHtcbiAgICAgICAgICBhLnR5cGUuZHJhd1RleHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU5vdGVQYWRkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU5vdGVQYWRkaW5nKG5vdGVQYWRkaW5nKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudHlwZSkge1xuICAgICAgICAgIGEudHlwZS5ub3RlUGFkZGluZyA9IG5vdGVQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwianNvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIganNvbiA9IGEuanNvbjtcbiAgICAgICAgaWYgKF90aGlzMi5hY2Nlc3NvcnNJbnZlcnNlICYmIGEuZGF0YSkge1xuICAgICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzMi5hY2Nlc3NvcnNJbnZlcnNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBqc29uLmRhdGFba10gPSBfdGhpczIuYWNjZXNzb3JzSW52ZXJzZVtrXSh7IHg6IGEueCwgeTogYS55IH0pO1xuXG4gICAgICAgICAgICAvL1RPRE8gbWFrZSB0aGlzIGZlYXNpYmxlIHRvIG1hcCBiYWNrIHRvIGRhdGEgZm9yIG90aGVyIHR5cGVzIG9mIHN1YmplY3RzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm90ZU5vZGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhLnR5cGUuZ2V0Tm90ZUJCb3hPZmZzZXQoKSwgeyBwb3NpdGlvblg6IGEueCwgcG9zaXRpb25ZOiBhLnkgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvL1RPRE86IGNvbWUgYmFjayBhbmQgcmV0aGluayBpZiBhLnggYW5kIGEueSBhcmUgYXBwbGljYWJsZSBpbiBhbGwgc2l0dWF0aW9uc1xuICAgIC8vIGdldCBjb25uZWN0b3JOb2RlcygpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChhID0+ICh7IC4uLmEudHlwZS5nZXRDb25uZWN0b3JCQm94KCksIHN0YXJ0WDogYS54LCBzdGFydFk6IGEueX0pKVxuICAgIC8vIH1cblxuICAgIC8vIGdldCBzdWJqZWN0Tm9kZXMoKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucy5tYXAoYSA9PiAoeyAuLi5hLnR5cGUuZ2V0U3ViamVjdEJCb3goKSwgc3RhcnRYOiBhLngsIHN0YXJ0WTogYS55fSkpXG4gICAgLy8gfVxuXG4gICAgLy8gZ2V0IGFubm90YXRpb25Ob2RlcygpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLmFubm90YXRpb25zLm1hcChhID0+ICh7IC4uLmEudHlwZS5nZXRBbm5vdGF0aW9uQkJveCgpLCBzdGFydFg6IGEueCwgc3RhcnRZOiBhLnl9KSlcbiAgICAvLyB9XG5cbiAgfV0pO1xuICByZXR1cm4gQW5ub3RhdGlvbkNvbGxlY3Rpb247XG59KCk7XG5cbnZhciBwb2ludEhhbmRsZSA9IGZ1bmN0aW9uIHBvaW50SGFuZGxlKF9yZWYpIHtcbiAgdmFyIF9yZWYkY3ggPSBfcmVmLmN4LFxuICAgICAgY3ggPSBfcmVmJGN4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRjeCxcbiAgICAgIF9yZWYkY3kgPSBfcmVmLmN5LFxuICAgICAgY3kgPSBfcmVmJGN5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRjeTtcblxuICByZXR1cm4geyBtb3ZlOiB7IHg6IGN4LCB5OiBjeSB9IH07XG59O1xuXG52YXIgY2lyY2xlSGFuZGxlcyA9IGZ1bmN0aW9uIGNpcmNsZUhhbmRsZXMoX3JlZjIpIHtcbiAgdmFyIF9yZWYyJGN4ID0gX3JlZjIuY3gsXG4gICAgICBjeCA9IF9yZWYyJGN4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkY3gsXG4gICAgICBfcmVmMiRjeSA9IF9yZWYyLmN5LFxuICAgICAgY3kgPSBfcmVmMiRjeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJGN5LFxuICAgICAgcjEgPSBfcmVmMi5yMSxcbiAgICAgIHIyID0gX3JlZjIucjIsXG4gICAgICBwYWRkaW5nID0gX3JlZjIucGFkZGluZztcblxuICB2YXIgaCA9IHsgbW92ZTogeyB4OiBjeCwgeTogY3kgfSB9O1xuXG4gIGlmIChyMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaC5yMSA9IHsgeDogY3ggKyByMSAvIE1hdGguc3FydCgyKSwgeTogY3kgKyByMSAvIE1hdGguc3FydCgyKSB9O1xuICB9XG5cbiAgaWYgKHIyICE9PSB1bmRlZmluZWQpIHtcbiAgICBoLnIyID0geyB4OiBjeCArIHIyIC8gTWF0aC5zcXJ0KDIpLCB5OiBjeSArIHIyIC8gTWF0aC5zcXJ0KDIpIH07XG4gIH1cblxuICBpZiAocGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaC5wYWRkaW5nID0geyB4OiBjeCArIHIxICsgcGFkZGluZywgeTogY3kgfTtcbiAgfVxuXG4gIHJldHVybiBoO1xufTtcblxuXG5cblxuXG4vL2FyYyBoYW5kbGVzXG52YXIgYWRkSGFuZGxlcyA9IGZ1bmN0aW9uIGFkZEhhbmRsZXMoX3JlZjUpIHtcbiAgdmFyIGdyb3VwID0gX3JlZjUuZ3JvdXAsXG4gICAgICBoYW5kbGVzID0gX3JlZjUuaGFuZGxlcyxcbiAgICAgIF9yZWY1JHIgPSBfcmVmNS5yLFxuICAgICAgciA9IF9yZWY1JHIgPT09IHVuZGVmaW5lZCA/IDEwIDogX3JlZjUkcjtcblxuICAvL2dpdmUgaXQgYSBncm91cCBhbmQgeCx5IHRvIGRyYXcgaGFuZGxlc1xuICAvL3RoZW4gZ2l2ZSBpdCBpbnN0cnVjdGlvbnMgb24gd2hhdCB0aGUgaGFuZGxlcyBjaGFuZ2VcbiAgdmFyIGggPSBncm91cC5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLmRhdGEoaGFuZGxlcyk7XG5cbiAgaC5lbnRlcigpLmFwcGVuZChcImNpcmNsZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIikuYXR0cihcImZpbGxcIiwgXCJncmV5XCIpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMC4xKS5hdHRyKFwiY3Vyc29yXCIsIFwibW92ZVwiKS5hdHRyKFwic3Ryb2tlLWRhc2hhcnJheVwiLCA1KS5hdHRyKFwic3Ryb2tlXCIsIFwiZ3JleVwiKS5jYWxsKGRyYWcoKS5jb250YWluZXIoc2VsZWN0KFwiZy5hbm5vdGF0aW9uc1wiKS5ub2RlKCkpLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zdGFydCAmJiBkLnN0YXJ0KGQpO1xuICB9KS5vbihcImRyYWdcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5kcmFnICYmIGQuZHJhZyhkKTtcbiAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5lbmQgJiYgZC5lbmQoZCk7XG4gIH0pKTtcblxuICBncm91cC5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0pLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0pLmF0dHIoXCJyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuciB8fCByO1xuICB9KS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gXCJoYW5kbGUgXCIgKyAoZC5jbGFzc05hbWUgfHwgXCJcIik7XG4gIH0pO1xuXG4gIGguZXhpdCgpLnJlbW92ZSgpO1xufTtcblxudmFyIGxlZnRSaWdodER5bmFtaWMgPSBmdW5jdGlvbiBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCB5KSB7XG4gIGlmIChhbGlnbiA9PT0gXCJkeW5hbWljXCIgfHwgYWxpZ24gPT09IFwibGVmdFwiIHx8IGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICBpZiAoeSA8IDApIHtcbiAgICAgIGFsaWduID0gXCJ0b3BcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ24gPSBcImJvdHRvbVwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxpZ247XG59O1xuXG52YXIgdG9wQm90dG9tRHluYW1pYyA9IGZ1bmN0aW9uIHRvcEJvdHRvbUR5bmFtaWMoYWxpZ24sIHgpIHtcbiAgaWYgKGFsaWduID09PSBcImR5bmFtaWNcIiB8fCBhbGlnbiA9PT0gXCJ0b3BcIiB8fCBhbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgYWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWduID0gXCJsZWZ0XCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGlnbjtcbn07XG5cbnZhciBvcmllbnRhdGlvblRvcEJvdHRvbSA9IFtcInRvcEJvdHRvbVwiLCBcInRvcFwiLCBcImJvdHRvbVwiXTtcbnZhciBvcmllbnRhdGlvbkxlZnRSaWdodCA9IFtcImxlZnRSaWdodFwiLCBcImxlZnRcIiwgXCJyaWdodFwiXTtcblxudmFyIG5vdGVBbGlnbm1lbnQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIF9yZWYkcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHBhZGRpbmcsXG4gICAgICBfcmVmJGJib3ggPSBfcmVmLmJib3gsXG4gICAgICBiYm94ID0gX3JlZiRiYm94ID09PSB1bmRlZmluZWQgPyB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSA6IF9yZWYkYmJveCxcbiAgICAgIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIG9yaWVudGF0aW9uID0gX3JlZi5vcmllbnRhdGlvbixcbiAgICAgIF9yZWYkb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfcmVmJG9mZnNldCA9PT0gdW5kZWZpbmVkID8geyB4OiAwLCB5OiAwIH0gOiBfcmVmJG9mZnNldDtcblxuICB2YXIgeCA9IC1iYm94Lng7XG4gIHZhciB5ID0gMDsgLy8tYmJveC55XG4gIGlmIChvcmllbnRhdGlvblRvcEJvdHRvbS5pbmRleE9mKG9yaWVudGF0aW9uKSAhPT0gLTEpIHtcbiAgICBhbGlnbiA9IHRvcEJvdHRvbUR5bmFtaWMoYWxpZ24sIG9mZnNldC54KTtcbiAgICBpZiAob2Zmc2V0LnkgPCAwICYmIG9yaWVudGF0aW9uID09PSBcInRvcEJvdHRvbVwiIHx8IG9yaWVudGF0aW9uID09PSBcInRvcFwiKSB7XG4gICAgICB5IC09IGJib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSBwYWRkaW5nO1xuICAgIH1cblxuICAgIGlmIChhbGlnbiA9PT0gXCJtaWRkbGVcIikge1xuICAgICAgeCAtPSBiYm94LndpZHRoIC8gMjtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHggLT0gYmJveC53aWR0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JpZW50YXRpb25MZWZ0UmlnaHQuaW5kZXhPZihvcmllbnRhdGlvbikgIT09IC0xKSB7XG4gICAgYWxpZ24gPSBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCBvZmZzZXQueSk7XG4gICAgaWYgKG9mZnNldC54IDwgMCAmJiBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0UmlnaHRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHggLT0gYmJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gcGFkZGluZztcbiAgICB9XG5cbiAgICBpZiAoYWxpZ24gPT09IFwibWlkZGxlXCIpIHtcbiAgICAgIHkgLT0gYmJveC5oZWlnaHQgLyAyO1xuICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwidG9wXCIpIHtcbiAgICAgIHkgLT0gYmJveC5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xufSk7XG5cbnZhciBsaW5lQnVpbGRlciA9IGZ1bmN0aW9uIGxpbmVCdWlsZGVyKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBfcmVmJGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGN1cnZlID0gX3JlZiRjdXJ2ZSA9PT0gdW5kZWZpbmVkID8gY3VydmVMaW5lYXIgOiBfcmVmJGN1cnZlLFxuICAgICAgY2FudmFzQ29udGV4dCA9IF9yZWYuY2FudmFzQ29udGV4dCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NJRCA9IF9yZWYuY2xhc3NJRDtcblxuICB2YXIgbGluZUdlbiA9IGxpbmUoKS5jdXJ2ZShjdXJ2ZSk7XG5cbiAgdmFyIGJ1aWxkZXIgPSB7XG4gICAgdHlwZTogJ3BhdGgnLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNsYXNzSUQ6IGNsYXNzSUQsXG4gICAgZGF0YTogZGF0YVxuICB9O1xuXG4gIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgbGluZUdlbi5jb250ZXh0KGNhbnZhc0NvbnRleHQpO1xuICAgIGJ1aWxkZXIucGF0aE1ldGhvZHMgPSBsaW5lR2VuO1xuICB9IGVsc2Uge1xuICAgIGJ1aWxkZXIuYXR0cnMgPSB7XG4gICAgICBkOiBsaW5lR2VuKGRhdGEpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyO1xufTtcblxudmFyIGFyY0J1aWxkZXIgPSBmdW5jdGlvbiBhcmNCdWlsZGVyKF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRleHQgPSBfcmVmMi5jYW52YXNDb250ZXh0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NJRCA9IF9yZWYyLmNsYXNzSUQ7XG5cblxuICB2YXIgYnVpbGRlciA9IHtcbiAgICB0eXBlOiAncGF0aCcsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgY2xhc3NJRDogY2xhc3NJRCxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG5cbiAgdmFyIGFyY1NoYXBlID0gYXJjKCkuaW5uZXJSYWRpdXMoZGF0YS5pbm5lclJhZGl1cyB8fCAwKS5vdXRlclJhZGl1cyhkYXRhLm91dGVyUmFkaXVzIHx8IGRhdGEucmFkaXVzIHx8IDIpLnN0YXJ0QW5nbGUoZGF0YS5zdGFydEFuZ2xlIHx8IDApLmVuZEFuZ2xlKGRhdGEuZW5kQW5nbGUgfHwgMiAqIE1hdGguUEkpO1xuXG4gIGlmIChjYW52YXNDb250ZXh0KSB7XG4gICAgYXJjU2hhcGUuY29udGV4dChjYW52YXNDb250ZXh0KTtcbiAgICBidWlsZGVyLnBhdGhNZXRob2RzID0gbGluZUdlbjtcbiAgfSBlbHNlIHtcblxuICAgIGJ1aWxkZXIuYXR0cnMgPSB7XG4gICAgICBkOiBhcmNTaGFwZSgpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyO1xufTtcblxudmFyIG5vdGVWZXJ0aWNhbCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgX3JlZiR4ID0gX3JlZi54LFxuICAgICAgeCA9IF9yZWYkeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeCxcbiAgICAgIF9yZWYkeSA9IF9yZWYueSxcbiAgICAgIHkgPSBfcmVmJHkgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHksXG4gICAgICBiYm94ID0gX3JlZi5iYm94LFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG5cbiAgYWxpZ24gPSBsZWZ0UmlnaHREeW5hbWljKGFsaWduLCBvZmZzZXQueSk7XG5cbiAgaWYgKGFsaWduID09PSBcInRvcFwiKSB7XG4gICAgeSAtPSBiYm94LmhlaWdodDtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHkgLT0gYmJveC5oZWlnaHQgLyAyO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBbW3gsIHldLCBbeCwgeSArIGJib3guaGVpZ2h0XV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJub3RlLWxpbmVcIiB9KV0gfTtcbn0pO1xuXG52YXIgbm90ZUhvcml6b250YWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICBiYm94ID0gX3JlZi5iYm94O1xuXG4gIGFsaWduID0gdG9wQm90dG9tRHluYW1pYyhhbGlnbiwgb2Zmc2V0LngpO1xuXG4gIGlmIChhbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgeCAtPSBiYm94LndpZHRoO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSBcIm1pZGRsZVwiKSB7XG4gICAgeCAtPSBiYm94LndpZHRoIC8gMjtcbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4LCB5XSwgW3ggKyBiYm94LndpZHRoLCB5XV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJub3RlLWxpbmVcIiB9KV0gfTtcbn0pO1xuXG52YXIgbGluZVNldHVwID0gZnVuY3Rpb24gbGluZVNldHVwKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBzdWJqZWN0VHlwZSA9IF9yZWYuc3ViamVjdFR5cGU7XG5cbiAgdmFyIGFubm90YXRpb24gPSB0eXBlLmFubm90YXRpb247XG4gIHZhciBvZmZzZXQgPSBhbm5vdGF0aW9uLnBvc2l0aW9uO1xuXG4gIHZhciB4MSA9IGFubm90YXRpb24ueCAtIG9mZnNldC54LFxuICAgICAgeDIgPSB4MSArIGFubm90YXRpb24uZHgsXG4gICAgICB5MSA9IGFubm90YXRpb24ueSAtIG9mZnNldC55LFxuICAgICAgeTIgPSB5MSArIGFubm90YXRpb24uZHk7XG5cbiAgdmFyIHN1YmplY3REYXRhID0gYW5ub3RhdGlvbi5zdWJqZWN0O1xuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJjaXJjbGVcIiAmJiAoc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzKSkge1xuICAgIHZhciBoID0gTWF0aC5zcXJ0KCh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKSk7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKC15MiAvIGgpO1xuICAgIHZhciByID0gc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzICsgKHN1YmplY3REYXRhLnJhZGl1c1BhZGRpbmcgfHwgMCk7XG5cbiAgICB4MSA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSAqIHIpICogKHgyIDwgMCA/IC0xIDogMSk7XG4gICAgeTEgPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkgKiByKSAqICh5MiA8IDAgPyAtMSA6IDEpO1xuICB9XG5cbiAgaWYgKHN1YmplY3RUeXBlID09PSBcInJlY3RcIikge1xuICAgIHZhciB3aWR0aCA9IHN1YmplY3REYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICAgIGlmICh3aWR0aCA+IDAgJiYgYW5ub3RhdGlvbi5keCA+IDAgfHwgd2lkdGggPCAwICYmIGFubm90YXRpb24uZHggPCAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMod2lkdGgpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keCkpIHgxID0gd2lkdGggLyAyO2Vsc2UgeDEgPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IDAgJiYgYW5ub3RhdGlvbi5keSA+IDAgfHwgaGVpZ2h0IDwgMCAmJiBhbm5vdGF0aW9uLmR5IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPiBNYXRoLmFicyhhbm5vdGF0aW9uLmR5KSkgeTEgPSBoZWlnaHQgLyAyO2Vsc2UgeTEgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmICh4MSA9PT0gd2lkdGggLyAyICYmIHkxID09PSBoZWlnaHQgLyAyKSB7XG4gICAgICB4MSA9IHgyO3kxID0geTI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtbeDEsIHkxXSwgW3gyLCB5Ml1dO1xufTtcblxudmFyIGNvbm5lY3RvckxpbmUgPSAoZnVuY3Rpb24gKGNvbm5lY3RvckRhdGEpIHtcbiAgdmFyIGRhdGEgPSBsaW5lU2V0dXAoY29ubmVjdG9yRGF0YSk7XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV0gfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yRWxib3cgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBzdWJqZWN0VHlwZSA9IF9yZWYuc3ViamVjdFR5cGU7XG5cblxuICB2YXIgYW5ub3RhdGlvbiA9IHR5cGUuYW5ub3RhdGlvbjtcbiAgdmFyIG9mZnNldCA9IGFubm90YXRpb24ucG9zaXRpb247XG5cbiAgdmFyIHgxID0gYW5ub3RhdGlvbi54IC0gb2Zmc2V0LngsXG4gICAgICB4MiA9IHgxICsgYW5ub3RhdGlvbi5keCxcbiAgICAgIHkxID0gYW5ub3RhdGlvbi55IC0gb2Zmc2V0LnksXG4gICAgICB5MiA9IHkxICsgYW5ub3RhdGlvbi5keTtcblxuICB2YXIgc3ViamVjdERhdGEgPSBhbm5vdGF0aW9uLnN1YmplY3Q7XG5cbiAgaWYgKHN1YmplY3RUeXBlID09PSBcInJlY3RcIikge1xuICAgIHZhciB3aWR0aCA9IHN1YmplY3REYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICAgIGlmICh3aWR0aCA+IDAgJiYgYW5ub3RhdGlvbi5keCA+IDAgfHwgd2lkdGggPCAwICYmIGFubm90YXRpb24uZHggPCAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMod2lkdGgpID4gTWF0aC5hYnMoYW5ub3RhdGlvbi5keCkpIHgxID0gd2lkdGggLyAyO2Vsc2UgeDEgPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IDAgJiYgYW5ub3RhdGlvbi5keSA+IDAgfHwgaGVpZ2h0IDwgMCAmJiBhbm5vdGF0aW9uLmR5IDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPiBNYXRoLmFicyhhbm5vdGF0aW9uLmR5KSkgeTEgPSBoZWlnaHQgLyAyO2Vsc2UgeTEgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGlmICh4MSA9PT0gd2lkdGggLyAyICYmIHkxID09PSBoZWlnaHQgLyAyKSB7XG4gICAgICB4MSA9IHgyO3kxID0geTI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGEgPSBbW3gxLCB5MV0sIFt4MiwgeTJdXTtcblxuICB2YXIgZGlmZlkgPSB5MiAtIHkxO1xuICB2YXIgZGlmZlggPSB4MiAtIHgxO1xuICB2YXIgeGUgPSB4MjtcbiAgdmFyIHllID0geTI7XG4gIHZhciBvcHBvc2l0ZSA9IHkyIDwgeTEgJiYgeDIgPiB4MSB8fCB4MiA8IHgxICYmIHkyID4geTEgPyAtMSA6IDE7XG5cbiAgaWYgKE1hdGguYWJzKGRpZmZYKSA8IE1hdGguYWJzKGRpZmZZKSkge1xuICAgIHhlID0geDI7XG4gICAgeWUgPSB5MSArIGRpZmZYICogb3Bwb3NpdGU7XG4gIH0gZWxzZSB7XG4gICAgeWUgPSB5MjtcbiAgICB4ZSA9IHgxICsgZGlmZlkgKiBvcHBvc2l0ZTtcbiAgfVxuXG4gIGlmIChzdWJqZWN0VHlwZSA9PT0gXCJjaXJjbGVcIiAmJiAoc3ViamVjdERhdGEub3V0ZXJSYWRpdXMgfHwgc3ViamVjdERhdGEucmFkaXVzKSkge1xuICAgIHZhciByID0gKHN1YmplY3REYXRhLm91dGVyUmFkaXVzIHx8IHN1YmplY3REYXRhLnJhZGl1cykgKyAoc3ViamVjdERhdGEucmFkaXVzUGFkZGluZyB8fCAwKTtcbiAgICB2YXIgbGVuZ3RoID0gciAvIE1hdGguc3FydCgyKTtcblxuICAgIGlmIChNYXRoLmFicyhkaWZmWCkgPiBsZW5ndGggJiYgTWF0aC5hYnMoZGlmZlkpID4gbGVuZ3RoKSB7XG4gICAgICB4MSA9IGxlbmd0aCAqICh4MiA8IDAgPyAtMSA6IDEpO1xuICAgICAgeTEgPSBsZW5ndGggKiAoeTIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gxLCB5MV0sIFt4ZSwgeWVdLCBbeDIsIHkyXV07XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmWCkgPiBNYXRoLmFicyhkaWZmWSkpIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbigteTIgLyByKTtcbiAgICAgIHgxID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpICogcikgKiAoeDIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gxLCB5Ml0sIFt4MiwgeTJdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9hbmdsZSA9IE1hdGguYWNvcyh4MiAvIHIpO1xuICAgICAgeTEgPSBNYXRoLmFicyhNYXRoLnNpbihfYW5nbGUpICogcikgKiAoeTIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGRhdGEgPSBbW3gyLCB5MV0sIFt4MiwgeTJdXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IFtbeDEsIHkxXSwgW3hlLCB5ZV0sIFt4MiwgeTJdXTtcbiAgfVxuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV0gfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yQ3VydmUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICBjb25uZWN0b3JEYXRhID0gX3JlZi5jb25uZWN0b3JEYXRhLFxuICAgICAgc3ViamVjdFR5cGUgPSBfcmVmLnN1YmplY3RUeXBlO1xuXG5cbiAgaWYgKCFjb25uZWN0b3JEYXRhKSB7XG4gICAgY29ubmVjdG9yRGF0YSA9IHt9O1xuICB9XG4gIGlmICghY29ubmVjdG9yRGF0YS5wb2ludHMgfHwgdHlwZW9mIGNvbm5lY3RvckRhdGEucG9pbnRzID09PSBcIm51bWJlclwiKSB7XG4gICAgY29ubmVjdG9yRGF0YS5wb2ludHMgPSBjcmVhdGVQb2ludHModHlwZS5hbm5vdGF0aW9uLm9mZnNldCwgY29ubmVjdG9yRGF0YS5wb2ludHMpO1xuICB9XG4gIGlmICghY29ubmVjdG9yRGF0YS5jdXJ2ZSkge1xuICAgIGNvbm5lY3RvckRhdGEuY3VydmUgPSBjdXJ2ZUNhdG11bGxSb207XG4gIH1cblxuICB2YXIgaGFuZGxlcyA9IFtdO1xuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIGNIYW5kbGVzID0gY29ubmVjdG9yRGF0YS5wb2ludHMubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHBvaW50SGFuZGxlKHsgY3g6IGNbMF0sIGN5OiBjWzFdIH0pLCB7IGluZGV4OiBpIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIHVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gdXBkYXRlUG9pbnQoaW5kZXgpIHtcbiAgICAgIGNvbm5lY3RvckRhdGEucG9pbnRzW2luZGV4XVswXSArPSBldmVudC5keDtcbiAgICAgIGNvbm5lY3RvckRhdGEucG9pbnRzW2luZGV4XVsxXSArPSBldmVudC5keTtcbiAgICAgIHR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgfTtcblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMoY0hhbmRsZXMubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGgubW92ZSwgeyBkcmFnOiB1cGRhdGVQb2ludC5iaW5kKHR5cGUsIGguaW5kZXgpIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gbGluZVNldHVwKHsgdHlwZTogdHlwZSwgc3ViamVjdFR5cGU6IHN1YmplY3RUeXBlIH0pO1xuICBkYXRhID0gW2RhdGFbMF1dLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShjb25uZWN0b3JEYXRhLnBvaW50cyksIFtkYXRhWzFdXSk7XG4gIHZhciBjb21wb25lbnRzID0gW2xpbmVCdWlsZGVyKHsgZGF0YTogZGF0YSwgY3VydmU6IGNvbm5lY3RvckRhdGEuY3VydmUsIGNsYXNzTmFtZTogXCJjb25uZWN0b3JcIiB9KV07XG5cbiAgcmV0dXJuIHsgY29tcG9uZW50czogY29tcG9uZW50cywgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbnZhciBjcmVhdGVQb2ludHMgPSBmdW5jdGlvbiBjcmVhdGVQb2ludHMob2Zmc2V0KSB7XG4gIHZhciBhbmNob3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyO1xuXG4gIHZhciBkaWZmID0geyB4OiBvZmZzZXQueCAvIChhbmNob3JzICsgMSksIHk6IG9mZnNldC55IC8gKGFuY2hvcnMgKyAxKSB9O1xuICB2YXIgcCA9IFtdO1xuXG4gIHZhciBpID0gMTtcbiAgZm9yICg7IGkgPD0gYW5jaG9yczsgaSsrKSB7XG4gICAgcC5wdXNoKFtkaWZmLnggKiBpICsgaSAlIDIgKiAyMCwgZGlmZi55ICogaSAtIGkgJSAyICogMjBdKTtcbiAgfVxuICByZXR1cm4gcDtcbn07XG5cbnZhciBjb25uZWN0b3JBcnJvdyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgYW5ub3RhdGlvbiA9IF9yZWYuYW5ub3RhdGlvbixcbiAgICAgIHN0YXJ0ID0gX3JlZi5zdGFydCxcbiAgICAgIGVuZCA9IF9yZWYuZW5kLFxuICAgICAgX3JlZiRzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWYkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHNjYWxlO1xuXG4gIHZhciBvZmZzZXQgPSBhbm5vdGF0aW9uLnBvc2l0aW9uO1xuICBpZiAoIXN0YXJ0KSB7XG4gICAgc3RhcnQgPSBbYW5ub3RhdGlvbi5keCwgYW5ub3RhdGlvbi5keV07XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBbLWVuZFswXSArIHN0YXJ0WzBdLCAtZW5kWzFdICsgc3RhcnRbMV1dO1xuICB9XG4gIGlmICghZW5kKSB7XG4gICAgZW5kID0gW2Fubm90YXRpb24ueCAtIG9mZnNldC54LCBhbm5vdGF0aW9uLnkgLSBvZmZzZXQueV07XG4gIH1cblxuICB2YXIgeDEgPSBlbmRbMF0sXG4gICAgICB5MSA9IGVuZFsxXTtcblxuICB2YXIgZHggPSBzdGFydFswXTtcbiAgdmFyIGR5ID0gc3RhcnRbMV07XG5cbiAgdmFyIHNpemUgPSAxMCAqIHNjYWxlO1xuICB2YXIgYW5nbGVPZmZzZXQgPSAxNiAvIDE4MCAqIE1hdGguUEk7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcblxuICBpZiAoZHggPCAwKSB7XG4gICAgYW5nbGUgKz0gTWF0aC5QSTtcbiAgfVxuXG4gIHZhciBkYXRhID0gW1t4MSwgeTFdLCBbTWF0aC5jb3MoYW5nbGUgKyBhbmdsZU9mZnNldCkgKiBzaXplICsgeDEsIE1hdGguc2luKGFuZ2xlICsgYW5nbGVPZmZzZXQpICogc2l6ZSArIHkxXSwgW01hdGguY29zKGFuZ2xlIC0gYW5nbGVPZmZzZXQpICogc2l6ZSArIHgxLCBNYXRoLnNpbihhbmdsZSAtIGFuZ2xlT2Zmc2V0KSAqIHNpemUgKyB5MV0sIFt4MSwgeTFdXTtcblxuICAvL1RPRE8gYWRkIGluIHJldmVyc2VcbiAgLy8gaWYgKGNhbnZhc0NvbnRleHQuYXJyb3dSZXZlcnNlKXtcbiAgLy8gICBkYXRhID0gW1t4MSwgeTFdLFxuICAvLyAgIFtNYXRoLmNvcyhhbmdsZSArIGFuZ2xlT2Zmc2V0KSpzaXplLCBNYXRoLnNpbihhbmdsZSArIGFuZ2xlT2Zmc2V0KSpzaXplXSxcbiAgLy8gICBbTWF0aC5jb3MoYW5nbGUgLSBhbmdsZU9mZnNldCkqc2l6ZSwgTWF0aC5zaW4oYW5nbGUgLSBhbmdsZU9mZnNldCkqc2l6ZV0sXG4gIC8vICAgW3gxLCB5MV1cbiAgLy8gICBdXG4gIC8vIH0gZWxzZSB7XG4gIC8vICAgZGF0YSA9IFtbeDEsIHkxXSxcbiAgLy8gICBbTWF0aC5jb3MoYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZSwgTWF0aC5zaW4oYW5nbGUgKyBhbmdsZU9mZnNldCkqc2l6ZV0sXG4gIC8vICAgW01hdGguY29zKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemUsIE1hdGguc2luKGFuZ2xlIC0gYW5nbGVPZmZzZXQpKnNpemVdLFxuICAvLyAgIFt4MSwgeTFdXG4gIC8vICAgXVxuICAvLyB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wb25lbnRzOiBbbGluZUJ1aWxkZXIoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0b3ItZW5kIGNvbm5lY3Rvci1hcnJvd1wiLFxuICAgICAgY2xhc3NJRDogXCJjb25uZWN0b3ItZW5kXCJcbiAgICB9KV1cbiAgfTtcbn0pO1xuXG52YXIgY29ubmVjdG9yRG90ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBsaW5lJCQxID0gX3JlZi5saW5lLFxuICAgICAgX3JlZiRzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWYkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHNjYWxlO1xuXG4gIHZhciBkb3QgPSBhcmNCdWlsZGVyKHtcbiAgICBjbGFzc05hbWU6IFwiY29ubmVjdG9yLWVuZCBjb25uZWN0b3ItZG90XCIsXG4gICAgY2xhc3NJRDogXCJjb25uZWN0b3ItZW5kXCIsXG4gICAgZGF0YTogeyByYWRpdXM6IDMgKiBNYXRoLnNxcnQoc2NhbGUpIH1cbiAgfSk7XG4gIGRvdC5hdHRycy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGxpbmUkJDEuZGF0YVswXVswXSArIFwiLCBcIiArIGxpbmUkJDEuZGF0YVswXVsxXSArIFwiKVwiO1xuXG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtkb3RdIH07XG59KTtcblxudmFyIHN1YmplY3RDaXJjbGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN1YmplY3REYXRhID0gX3JlZi5zdWJqZWN0RGF0YSxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgaWYgKCFzdWJqZWN0RGF0YS5yYWRpdXMgJiYgIXN1YmplY3REYXRhLm91dGVyUmFkaXVzKSB7XG4gICAgc3ViamVjdERhdGEucmFkaXVzID0gMjA7XG4gIH1cblxuICB2YXIgaGFuZGxlcyA9IFtdO1xuICB2YXIgYyA9IGFyY0J1aWxkZXIoeyBkYXRhOiBzdWJqZWN0RGF0YSwgY2xhc3NOYW1lOiBcInN1YmplY3RcIiB9KTtcbiAgaWYgKHR5cGUuZWRpdE1vZGUpIHtcbiAgICB2YXIgaCA9IGNpcmNsZUhhbmRsZXMoe1xuICAgICAgcjE6IGMuZGF0YS5vdXRlclJhZGl1cyB8fCBjLmRhdGEucmFkaXVzLFxuICAgICAgcjI6IGMuZGF0YS5pbm5lclJhZGl1cyxcbiAgICAgIHBhZGRpbmc6IHN1YmplY3REYXRhLnJhZGl1c1BhZGRpbmdcbiAgICB9KTtcblxuICAgIHZhciB1cGRhdGVSYWRpdXMgPSBmdW5jdGlvbiB1cGRhdGVSYWRpdXMoYXR0cikge1xuICAgICAgdmFyIHIgPSBzdWJqZWN0RGF0YVthdHRyXSArIGV2ZW50LmR4ICogTWF0aC5zcXJ0KDIpO1xuICAgICAgc3ViamVjdERhdGFbYXR0cl0gPSByO1xuICAgICAgdHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICB2YXIgY0hhbmRsZXMgPSBbX2V4dGVuZHMoe30sIGgucjEsIHtcbiAgICAgIGRyYWc6IHVwZGF0ZVJhZGl1cy5iaW5kKHR5cGUsIHN1YmplY3REYXRhLm91dGVyUmFkaXVzICE9PSB1bmRlZmluZWQgPyBcIm91dGVyUmFkaXVzXCIgOiBcInJhZGl1c1wiKVxuICAgIH0pXTtcblxuICAgIGlmIChzdWJqZWN0RGF0YS5pbm5lclJhZGl1cykge1xuICAgICAgY0hhbmRsZXMucHVzaChfZXh0ZW5kcyh7fSwgaC5yMiwgeyBkcmFnOiB1cGRhdGVSYWRpdXMuYmluZCh0eXBlLCBcImlubmVyUmFkaXVzXCIpIH0pKTtcbiAgICB9XG4gICAgaGFuZGxlcyA9IHR5cGUubWFwSGFuZGxlcyhjSGFuZGxlcyk7XG4gIH1cblxuICBjLmF0dHJzW1wiZmlsbC1vcGFjaXR5XCJdID0gMDtcblxuICByZXR1cm4geyBjb21wb25lbnRzOiBbY10sIGhhbmRsZXM6IGhhbmRsZXMgfTtcbn0pO1xuXG52YXIgc3ViamVjdFJlY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHN1YmplY3REYXRhID0gX3JlZi5zdWJqZWN0RGF0YSxcbiAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgaWYgKCFzdWJqZWN0RGF0YS53aWR0aCkge1xuICAgIHN1YmplY3REYXRhLndpZHRoID0gMTAwO1xuICB9XG4gIGlmICghc3ViamVjdERhdGEuaGVpZ2h0KSB7XG4gICAgc3ViamVjdERhdGEuaGVpZ2h0ID0gMTAwO1xuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcbiAgdmFyIHdpZHRoID0gc3ViamVjdERhdGEud2lkdGgsXG4gICAgICBoZWlnaHQgPSBzdWJqZWN0RGF0YS5oZWlnaHQ7XG5cblxuICB2YXIgZGF0YSA9IFtbMCwgMF0sIFt3aWR0aCwgMF0sIFt3aWR0aCwgaGVpZ2h0XSwgWzAsIGhlaWdodF0sIFswLCAwXV07XG4gIHZhciByZWN0ID0gbGluZUJ1aWxkZXIoeyBkYXRhOiBkYXRhLCBjbGFzc05hbWU6IFwic3ViamVjdFwiIH0pO1xuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIHVwZGF0ZVdpZHRoID0gZnVuY3Rpb24gdXBkYXRlV2lkdGgoKSB7XG4gICAgICBzdWJqZWN0RGF0YS53aWR0aCA9IGV2ZW50Lng7XG4gICAgICB0eXBlLnJlZHJhd1N1YmplY3QoKTtcbiAgICAgIHR5cGUucmVkcmF3Q29ubmVjdG9yKCk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiB1cGRhdGVIZWlnaHQoKSB7XG4gICAgICBzdWJqZWN0RGF0YS5oZWlnaHQgPSBldmVudC55O1xuICAgICAgdHlwZS5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0eXBlLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgIH07XG5cbiAgICB2YXIgckhhbmRsZXMgPSBbeyB4OiB3aWR0aCwgeTogaGVpZ2h0IC8gMiwgZHJhZzogdXBkYXRlV2lkdGguYmluZCh0eXBlKSB9LCB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0LCBkcmFnOiB1cGRhdGVIZWlnaHQuYmluZCh0eXBlKSB9XTtcblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMockhhbmRsZXMpO1xuICB9XG4gIHJlY3QuYXR0cnNbXCJmaWxsLW9wYWNpdHlcIl0gPSAwLjE7XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtyZWN0XSwgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbnZhciBzdWJqZWN0VGhyZXNob2xkID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdWJqZWN0RGF0YSA9IF9yZWYuc3ViamVjdERhdGEsXG4gICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gIHZhciBvZmZzZXQgPSB0eXBlLmFubm90YXRpb24ucG9zaXRpb247XG5cbiAgdmFyIHgxID0gKHN1YmplY3REYXRhLngxICE9PSB1bmRlZmluZWQgPyBzdWJqZWN0RGF0YS54MSA6IG9mZnNldC54KSAtIG9mZnNldC54LFxuICAgICAgeDIgPSAoc3ViamVjdERhdGEueDIgIT09IHVuZGVmaW5lZCA/IHN1YmplY3REYXRhLngyIDogb2Zmc2V0LngpIC0gb2Zmc2V0LngsXG4gICAgICB5MSA9IChzdWJqZWN0RGF0YS55MSAhPT0gdW5kZWZpbmVkID8gc3ViamVjdERhdGEueTEgOiBvZmZzZXQueSkgLSBvZmZzZXQueSxcbiAgICAgIHkyID0gKHN1YmplY3REYXRhLnkyICE9PSB1bmRlZmluZWQgPyBzdWJqZWN0RGF0YS55MiA6IG9mZnNldC55KSAtIG9mZnNldC55O1xuXG4gIHZhciBkYXRhID0gW1t4MSwgeTFdLCBbeDIsIHkyXV07XG4gIHJldHVybiB7IGNvbXBvbmVudHM6IFtsaW5lQnVpbGRlcih7IGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogJ3N1YmplY3QnIH0pXSB9O1xufSk7XG5cbnZhciBzdWJqZWN0QmFkZ2UgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIF9yZWYkc3ViamVjdERhdGEgPSBfcmVmLnN1YmplY3REYXRhLFxuICAgICAgc3ViamVjdERhdGEgPSBfcmVmJHN1YmplY3REYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkc3ViamVjdERhdGEsXG4gICAgICBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICB0eXBlID0gX3JlZiR0eXBlID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkdHlwZTtcbiAgdmFyIGFubm90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciB0eXBlU2V0dGluZ3MgPSB0eXBlLnR5cGVTZXR0aW5ncyAmJiB0eXBlLnR5cGVTZXR0aW5ncy5zdWJqZWN0O1xuXG4gIGlmICghc3ViamVjdERhdGEucmFkaXVzKSB7XG4gICAgaWYgKHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MucmFkaXVzKSB7XG4gICAgICBzdWJqZWN0RGF0YS5yYWRpdXMgPSB0eXBlU2V0dGluZ3MucmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJqZWN0RGF0YS5yYWRpdXMgPSAxNDtcbiAgICB9XG4gIH1cbiAgaWYgKCFzdWJqZWN0RGF0YS54KSB7XG4gICAgaWYgKHR5cGVTZXR0aW5ncyAmJiB0eXBlU2V0dGluZ3MueCkge1xuICAgICAgc3ViamVjdERhdGEueCA9IHR5cGVTZXR0aW5ncy54O1xuICAgIH1cbiAgfVxuICBpZiAoIXN1YmplY3REYXRhLnkpIHtcbiAgICBpZiAodHlwZVNldHRpbmdzICYmIHR5cGVTZXR0aW5ncy55KSB7XG4gICAgICBzdWJqZWN0RGF0YS55ID0gdHlwZVNldHRpbmdzLnk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhbmRsZXMgPSBbXTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIHJhZGl1cyA9IHN1YmplY3REYXRhLnJhZGl1cztcbiAgdmFyIGlubmVyUmFkaXVzID0gcmFkaXVzICogMC43O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICB2YXIgbm90Q29ybmVyT2Zmc2V0ID0gTWF0aC5zcXJ0KDIpICogcmFkaXVzO1xuICB2YXIgcGxhY2VtZW50ID0ge1xuICAgIHhsZWZ0Y29ybmVyOiAtcmFkaXVzLFxuICAgIHhyaWdodGNvcm5lcjogcmFkaXVzLFxuICAgIHl0b3Bjb3JuZXI6IC1yYWRpdXMsXG4gICAgeWJvdHRvbWNvcm5lcjogcmFkaXVzLFxuICAgIHhsZWZ0OiAtbm90Q29ybmVyT2Zmc2V0LFxuICAgIHhyaWdodDogbm90Q29ybmVyT2Zmc2V0LFxuICAgIHl0b3A6IC1ub3RDb3JuZXJPZmZzZXQsXG4gICAgeWJvdHRvbTogbm90Q29ybmVyT2Zmc2V0XG4gIH07XG5cbiAgaWYgKHN1YmplY3REYXRhLnggJiYgIXN1YmplY3REYXRhLnkpIHtcbiAgICB4ID0gcGxhY2VtZW50W1wieFwiICsgc3ViamVjdERhdGEueF07XG4gIH0gZWxzZSBpZiAoc3ViamVjdERhdGEueSAmJiAhc3ViamVjdERhdGEueCkge1xuICAgIHkgPSBwbGFjZW1lbnRbXCJ5XCIgKyBzdWJqZWN0RGF0YS55XTtcbiAgfSBlbHNlIGlmIChzdWJqZWN0RGF0YS54ICYmIHN1YmplY3REYXRhLnkpIHtcbiAgICB4ID0gcGxhY2VtZW50W1wieFwiICsgc3ViamVjdERhdGEueCArIFwiY29ybmVyXCJdO1xuICAgIHkgPSBwbGFjZW1lbnRbXCJ5XCIgKyBzdWJqZWN0RGF0YS55ICsgXCJjb3JuZXJcIl07XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiKVwiO1xuICB2YXIgY2lyY2xlYmcgPSBhcmNCdWlsZGVyKHsgY2xhc3NOYW1lOiBcInN1YmplY3RcIiwgZGF0YTogeyByYWRpdXM6IHJhZGl1cyB9IH0pO1xuICBjaXJjbGViZy5hdHRycy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIGNpcmNsZWJnLmF0dHJzLmZpbGwgPSBhbm5vdGF0aW9uLmNvbG9yO1xuICBjaXJjbGViZy5hdHRyc1tcInN0cm9rZS1saW5lY2FwXCJdID0gXCJyb3VuZFwiO1xuICBjaXJjbGViZy5hdHRyc1tcInN0cm9rZS13aWR0aFwiXSA9IFwiM3B4XCI7XG5cbiAgdmFyIGNpcmNsZSA9IGFyY0J1aWxkZXIoe1xuICAgIGNsYXNzTmFtZTogXCJzdWJqZWN0LXJpbmdcIixcbiAgICBkYXRhOiB7IG91dGVyUmFkaXVzOiByYWRpdXMsIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyB9XG4gIH0pO1xuXG4gIGNpcmNsZS5hdHRycy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIC8vIGNpcmNsZS5hdHRycy5maWxsID0gYW5ub3RhdGlvbi5jb2xvclxuICBjaXJjbGUuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gPSBcIjNweFwiO1xuICBjaXJjbGUuYXR0cnMuZmlsbCA9IFwid2hpdGVcIjtcblxuICB2YXIgcG9pbnRlciA9IHZvaWQgMDtcbiAgaWYgKHggJiYgeSB8fCAheCAmJiAheSkge1xuICAgIHBvaW50ZXIgPSBsaW5lQnVpbGRlcih7XG4gICAgICBjbGFzc05hbWU6IFwic3ViamVjdC1wb2ludGVyXCIsXG4gICAgICBkYXRhOiBbWzAsIDBdLCBbeCB8fCAwLCAwXSwgWzAsIHkgfHwgMF0sIFswLCAwXV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh4IHx8IHkpIHtcbiAgICB2YXIgbm90Q29ybmVyUG9pbnRlclhZID0gZnVuY3Rpb24gbm90Q29ybmVyUG9pbnRlclhZKHYpIHtcbiAgICAgIHZhciBzaWduID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgcmV0dXJuIHYgJiYgdiAvIE1hdGguc3FydCgyKSAvIE1hdGguc3FydCgyKSB8fCBzaWduICogcmFkaXVzIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH07XG5cbiAgICBwb2ludGVyID0gbGluZUJ1aWxkZXIoe1xuICAgICAgY2xhc3NOYW1lOiBcInN1YmplY3QtcG9pbnRlclwiLFxuICAgICAgZGF0YTogW1swLCAwXSwgW25vdENvcm5lclBvaW50ZXJYWSh4KSwgbm90Q29ybmVyUG9pbnRlclhZKHkpXSwgW25vdENvcm5lclBvaW50ZXJYWSh4LCAtMSksIG5vdENvcm5lclBvaW50ZXJYWSh5LCAtMSldLCBbMCwgMF1dXG4gICAgfSk7XG4gIH1cblxuICBpZiAocG9pbnRlcikge1xuICAgIHBvaW50ZXIuYXR0cnMuZmlsbCA9IGFubm90YXRpb24uY29sb3I7XG4gICAgcG9pbnRlci5hdHRyc1tcInN0cm9rZS1saW5lY2FwXCJdID0gXCJyb3VuZFwiO1xuICAgIHBvaW50ZXIuYXR0cnNbXCJzdHJva2Utd2lkdGhcIl0gPSBcIjNweFwiO1xuICAgIGNvbXBvbmVudHMucHVzaChwb2ludGVyKTtcbiAgfVxuXG4gIGlmICh0eXBlLmVkaXRNb2RlKSB7XG4gICAgdmFyIGRyYWdCYWRnZSA9IGZ1bmN0aW9uIGRyYWdCYWRnZSgpIHtcbiAgICAgIHN1YmplY3REYXRhLnggPSBldmVudC54IDwgLXJhZGl1cyAqIDIgPyBcImxlZnRcIiA6IGV2ZW50LnggPiByYWRpdXMgKiAyID8gXCJyaWdodFwiIDogdW5kZWZpbmVkO1xuICAgICAgc3ViamVjdERhdGEueSA9IGV2ZW50LnkgPCAtcmFkaXVzICogMiA/IFwidG9wXCIgOiBldmVudC55ID4gcmFkaXVzICogMiA/IFwiYm90dG9tXCIgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHR5cGUucmVkcmF3U3ViamVjdCgpO1xuICAgIH07XG5cbiAgICB2YXIgYkhhbmRsZXMgPSB7IHg6IHggKiAyLCB5OiB5ICogMiwgZHJhZzogZHJhZ0JhZGdlLmJpbmQodHlwZSkgfTtcbiAgICBpZiAoIWJIYW5kbGVzLnggJiYgIWJIYW5kbGVzLnkpIHtcbiAgICAgIGJIYW5kbGVzLnkgPSAtcmFkaXVzO1xuICAgIH1cblxuICAgIGhhbmRsZXMgPSB0eXBlLm1hcEhhbmRsZXMoW2JIYW5kbGVzXSk7XG4gIH1cblxuICB2YXIgdGV4dCA9IHZvaWQgMDtcbiAgaWYgKHN1YmplY3REYXRhLnRleHQpIHtcbiAgICB0ZXh0ID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBjbGFzc05hbWU6IFwiYmFkZ2UtdGV4dFwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgZmlsbDogXCJ3aGl0ZVwiLFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIi43ZW1cIixcbiAgICAgICAgdGV4dDogc3ViamVjdERhdGEudGV4dCxcbiAgICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBcIm1pZGRsZVwiLFxuICAgICAgICBkeTogXCIuMjVlbVwiLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudHMucHVzaChjaXJjbGViZyk7XG4gIGNvbXBvbmVudHMucHVzaChjaXJjbGUpO1xuICBjb21wb25lbnRzLnB1c2godGV4dCk7XG5cbiAgcmV0dXJuIHsgY29tcG9uZW50czogY29tcG9uZW50cywgaGFuZGxlczogaGFuZGxlcyB9O1xufSk7XG5cbi8vTm90ZSBvcHRpb25zXG4vL0Nvbm5lY3RvciBvcHRpb25zXG4vL1N1YmplY3Qgb3B0aW9uc1xudmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFR5cGUoX3JlZikge1xuICAgIHZhciBhID0gX3JlZi5hLFxuICAgICAgICBhbm5vdGF0aW9uID0gX3JlZi5hbm5vdGF0aW9uLFxuICAgICAgICBlZGl0TW9kZSA9IF9yZWYuZWRpdE1vZGUsXG4gICAgICAgIGRpc3BhdGNoZXIgPSBfcmVmLmRpc3BhdGNoZXIsXG4gICAgICAgIG5vdGVQYWRkaW5nID0gX3JlZi5ub3RlUGFkZGluZyxcbiAgICAgICAgYWNjZXNzb3JzID0gX3JlZi5hY2Nlc3NvcnM7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZSk7XG5cbiAgICB0aGlzLmEgPSBhO1xuXG4gICAgdGhpcy5ub3RlID0gYW5ub3RhdGlvbi5kaXNhYmxlLmluZGV4T2YoXCJub3RlXCIpID09PSAtMSAmJiBhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1ub3RlXCIpO1xuICAgIHRoaXMubm90ZUNvbnRlbnQgPSB0aGlzLm5vdGUgJiYgYS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgIHRoaXMuY29ubmVjdG9yID0gYW5ub3RhdGlvbi5kaXNhYmxlLmluZGV4T2YoXCJjb25uZWN0b3JcIikgPT09IC0xICYmIGEuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLWNvbm5lY3RvclwiKTtcbiAgICB0aGlzLnN1YmplY3QgPSBhbm5vdGF0aW9uLmRpc2FibGUuaW5kZXhPZihcInN1YmplY3RcIikgPT09IC0xICYmIGEuc2VsZWN0KFwiZy5hbm5vdGF0aW9uLXN1YmplY3RcIik7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIGlmIChkaXNwYXRjaGVyKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGFkZEhhbmRsZXJzLmJpbmQobnVsbCwgZGlzcGF0Y2hlciwgYW5ub3RhdGlvbik7XG4gICAgICBoYW5kbGVyKHsgY29tcG9uZW50OiB0aGlzLm5vdGUsIG5hbWU6IFwibm90ZVwiIH0pO1xuICAgICAgaGFuZGxlcih7IGNvbXBvbmVudDogdGhpcy5jb25uZWN0b3IsIG5hbWU6IFwiY29ubmVjdG9yXCIgfSk7XG4gICAgICBoYW5kbGVyKHsgY29tcG9uZW50OiB0aGlzLnN1YmplY3QsIG5hbWU6IFwic3ViamVjdFwiIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG4gICAgdGhpcy5lZGl0TW9kZSA9IGFubm90YXRpb24uZWRpdE1vZGUgfHwgZWRpdE1vZGU7XG4gICAgdGhpcy5ub3RlUGFkZGluZyA9IG5vdGVQYWRkaW5nICE9PSB1bmRlZmluZWQgPyBub3RlUGFkZGluZyA6IDM7XG4gICAgdGhpcy5vZmZzZXRDb3JuZXJYID0gMDtcbiAgICB0aGlzLm9mZnNldENvcm5lclkgPSAwO1xuXG4gICAgaWYgKGFjY2Vzc29ycyAmJiBhbm5vdGF0aW9uLmRhdGEpIHtcbiAgICAgIHRoaXMuaW5pdChhY2Nlc3NvcnMpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFR5cGUsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChhY2Nlc3NvcnMpIHtcbiAgICAgIGlmICghdGhpcy5hbm5vdGF0aW9uLngpIHtcbiAgICAgICAgdGhpcy5tYXBYKGFjY2Vzc29ycyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbi55KSB7XG4gICAgICAgIHRoaXMubWFwWShhY2Nlc3NvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFkoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoYWNjZXNzb3JzLnkpIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uLnkgPSBhY2Nlc3NvcnMueSh0aGlzLmFubm90YXRpb24uZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWChhY2Nlc3NvcnMpIHtcbiAgICAgIGlmIChhY2Nlc3NvcnMueCkge1xuICAgICAgICB0aGlzLmFubm90YXRpb24ueCA9IGFjY2Vzc29ycy54KHRoaXMuYW5ub3RhdGlvbi5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmEuc2VsZWN0QWxsKFwiY2lyY2xlLmhhbmRsZVwiKS5yZW1vdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd09uU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdPblNWRyhjb21wb25lbnQsIGJ1aWxkZXJzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYnVpbGRlcnMpKSB7XG4gICAgICAgIGJ1aWxkZXJzID0gW2J1aWxkZXJzXTtcbiAgICAgIH1cblxuICAgICAgYnVpbGRlcnMuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmMi50eXBlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgICAgICAgYXR0cnMgPSBfcmVmMi5hdHRycyxcbiAgICAgICAgICAgIGhhbmRsZXMgPSBfcmVmMi5oYW5kbGVzLFxuICAgICAgICAgICAgY2xhc3NJRCA9IF9yZWYyLmNsYXNzSUQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiaGFuZGxlXCIpIHtcbiAgICAgICAgICBhZGRIYW5kbGVzKHsgZ3JvdXA6IGNvbXBvbmVudCwgcjogYXR0cnMgJiYgYXR0cnMuciwgaGFuZGxlczogaGFuZGxlcyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdXaXRoQ2xhc3MoY29tcG9uZW50LCBbX3RoaXMuYW5ub3RhdGlvbl0sIHR5cGUsIGNsYXNzTmFtZSwgY2xhc3NJRCk7XG4gICAgICAgICAgdmFyIGVsID0gY29tcG9uZW50LnNlbGVjdCh0eXBlICsgXCIuXCIgKyAoY2xhc3NJRCB8fCBjbGFzc05hbWUpKTtcbiAgICAgICAgICB2YXIgYWRkQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgICAgdmFyIHJlbW92ZUF0dHJzID0gW107XG5cbiAgICAgICAgICB2YXIgY3VycmVudEF0dHJzID0gZWwubm9kZSgpLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBjdXJyZW50QXR0cnNbaV0ubmFtZTtcbiAgICAgICAgICAgIGlmIChhZGRBdHRycy5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBuYW1lICE9PSBcImNsYXNzXCIpIHJlbW92ZUF0dHJzLnB1c2gobmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgIGVsLnRleHQoYXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwuYXR0cihhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZW1vdmVBdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihhdHRyLCBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy9UT0RPOiBob3cgdG8gZXh0ZW5kIHRoaXMgdG8gYSBkcmF3T25DYW52YXMgbW9kZT9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5vdGVCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vdGVCQm94KCkge1xuICAgICAgcmV0dXJuIGJib3hXaXRob3V0SGFuZGxlcyh0aGlzLm5vdGUsIFwiLmFubm90YXRpb24tbm90ZS1jb250ZW50IHRleHRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5vdGVCQm94T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vdGVCQm94T2Zmc2V0KCkge1xuICAgICAgdmFyIGJib3ggPSBiYm94V2l0aG91dEhhbmRsZXModGhpcy5ub3RlLCBcIi5hbm5vdGF0aW9uLW5vdGUtY29udGVudFwiKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLm5vdGVDb250ZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIikuc3BsaXQoL1xcKHxcXCx8XFwpL2cpO1xuICAgICAgYmJveC5vZmZzZXRDb3JuZXJYID0gcGFyc2VGbG9hdCh0cmFuc2Zvcm1bMV0pICsgdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgYmJveC5vZmZzZXRDb3JuZXJZID0gcGFyc2VGbG9hdCh0cmFuc2Zvcm1bMl0pICsgdGhpcy5hbm5vdGF0aW9uLmR5O1xuICAgICAgYmJveC5vZmZzZXRYID0gdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgYmJveC5vZmZzZXRZID0gdGhpcy5hbm5vdGF0aW9uLmR5O1xuICAgICAgcmV0dXJuIGJib3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTdWJqZWN0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdmFyIHN1YmplY3REYXRhID0gdGhpcy5hbm5vdGF0aW9uLnN1YmplY3Q7XG4gICAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICAgIHZhciBzdWJqZWN0UGFyYW1zID0geyB0eXBlOiB0aGlzLCBzdWJqZWN0RGF0YTogc3ViamVjdERhdGEgfTtcblxuICAgICAgdmFyIHN1YmplY3QgPSB7fTtcbiAgICAgIGlmICh0eXBlID09PSBcImNpcmNsZVwiKSBzdWJqZWN0ID0gc3ViamVjdENpcmNsZShzdWJqZWN0UGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcInJlY3RcIikgc3ViamVjdCA9IHN1YmplY3RSZWN0KHN1YmplY3RQYXJhbXMpO2Vsc2UgaWYgKHR5cGUgPT09IFwidGhyZXNob2xkXCIpIHN1YmplY3QgPSBzdWJqZWN0VGhyZXNob2xkKHN1YmplY3RQYXJhbXMpO2Vsc2UgaWYgKHR5cGUgPT09IFwiYmFkZ2VcIikgc3ViamVjdCA9IHN1YmplY3RCYWRnZShzdWJqZWN0UGFyYW1zLCB0aGlzLmFubm90YXRpb24pO1xuXG4gICAgICB2YXIgX3N1YmplY3QgPSBzdWJqZWN0LFxuICAgICAgICAgIF9zdWJqZWN0JGNvbXBvbmVudHMgPSBfc3ViamVjdC5jb21wb25lbnRzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfc3ViamVjdCRjb21wb25lbnRzID09PSB1bmRlZmluZWQgPyBbXSA6IF9zdWJqZWN0JGNvbXBvbmVudHMsXG4gICAgICAgICAgX3N1YmplY3QkaGFuZGxlcyA9IF9zdWJqZWN0LmhhbmRsZXMsXG4gICAgICAgICAgaGFuZGxlcyA9IF9zdWJqZWN0JGhhbmRsZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX3N1YmplY3QkaGFuZGxlcztcblxuICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICYmIGMuYXR0cnMgJiYgIWMuYXR0cnMuc3Ryb2tlKSB7XG4gICAgICAgICAgYy5hdHRycy5zdHJva2UgPSBfdGhpczIuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdCh0aGlzLm1hcEhhbmRsZXMoW3sgZHJhZzogdGhpcy5kcmFnU3ViamVjdC5iaW5kKHRoaXMpIH1dKSk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7IHR5cGU6IFwiaGFuZGxlXCIsIGhhbmRsZXM6IGhhbmRsZXMgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q29ubmVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDb25uZWN0b3IoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICB2YXIgY29ubmVjdG9yRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5jb25uZWN0b3I7XG4gICAgICB2YXIgdHlwZSA9IGNvbm5lY3RvckRhdGEudHlwZSB8fCBjb250ZXh0LnR5cGU7XG4gICAgICB2YXIgY29ubmVjdG9yUGFyYW1zID0geyB0eXBlOiB0aGlzLCBjb25uZWN0b3JEYXRhOiBjb25uZWN0b3JEYXRhIH07XG4gICAgICBjb25uZWN0b3JQYXJhbXMuc3ViamVjdFR5cGUgPSB0aGlzLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnR5cGVTZXR0aW5ncy5zdWJqZWN0ICYmIHRoaXMudHlwZVNldHRpbmdzLnN1YmplY3QudHlwZTtcblxuICAgICAgdmFyIGNvbm5lY3RvciA9IHt9O1xuICAgICAgaWYgKHR5cGUgPT09IFwiY3VydmVcIikgY29ubmVjdG9yID0gY29ubmVjdG9yQ3VydmUoY29ubmVjdG9yUGFyYW1zKTtlbHNlIGlmICh0eXBlID09PSBcImVsYm93XCIpIGNvbm5lY3RvciA9IGNvbm5lY3RvckVsYm93KGNvbm5lY3RvclBhcmFtcyk7ZWxzZSBjb25uZWN0b3IgPSBjb25uZWN0b3JMaW5lKGNvbm5lY3RvclBhcmFtcyk7XG4gICAgICB2YXIgX2Nvbm5lY3RvciA9IGNvbm5lY3RvcixcbiAgICAgICAgICBfY29ubmVjdG9yJGNvbXBvbmVudHMgPSBfY29ubmVjdG9yLmNvbXBvbmVudHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF9jb25uZWN0b3IkY29tcG9uZW50cyA9PT0gdW5kZWZpbmVkID8gW10gOiBfY29ubmVjdG9yJGNvbXBvbmVudHMsXG4gICAgICAgICAgX2Nvbm5lY3RvciRoYW5kbGVzID0gX2Nvbm5lY3Rvci5oYW5kbGVzLFxuICAgICAgICAgIGhhbmRsZXMgPSBfY29ubmVjdG9yJGhhbmRsZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX2Nvbm5lY3RvciRoYW5kbGVzO1xuXG4gICAgICB2YXIgbGluZSQkMSA9IGNvbXBvbmVudHNbMF07XG4gICAgICAvL1RPRE86IGdlbmVyaWNpemUgdGhpcyBpbnRvIGZpbGwgdC9mIHN0cm9rZSB0L2ZcbiAgICAgIGlmIChsaW5lJCQxKSB7XG4gICAgICAgIGxpbmUkJDEuYXR0cnMuc3Ryb2tlID0gdGhpcy5hbm5vdGF0aW9uLmNvbG9yO1xuICAgICAgICBsaW5lJCQxLmF0dHJzLmZpbGwgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRUeXBlID0gY29ubmVjdG9yRGF0YS5lbmQgfHwgY29udGV4dC5lbmQ7XG4gICAgICB2YXIgZW5kID0ge307XG4gICAgICBpZiAoZW5kVHlwZSA9PT0gXCJhcnJvd1wiKSB7XG4gICAgICAgIHZhciBzID0gbGluZSQkMS5kYXRhWzFdO1xuICAgICAgICB2YXIgZSA9IGxpbmUkJDEuZGF0YVswXTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHNbMF0gLSBlWzBdLCAyKSArIE1hdGgucG93KHNbMV0gLSBlWzFdLCAyKSk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IDUgJiYgbGluZSQkMS5kYXRhWzJdKSB7XG4gICAgICAgICAgcyA9IGxpbmUkJDEuZGF0YVsyXTtcbiAgICAgICAgfVxuICAgICAgICBlbmQgPSBjb25uZWN0b3JBcnJvdyh7XG4gICAgICAgICAgYW5ub3RhdGlvbjogdGhpcy5hbm5vdGF0aW9uLFxuICAgICAgICAgIHN0YXJ0OiBzLFxuICAgICAgICAgIGVuZDogZSxcbiAgICAgICAgICBzY2FsZTogY29ubmVjdG9yRGF0YS5lbmRTY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kVHlwZSA9PT0gXCJkb3RcIikge1xuICAgICAgICBlbmQgPSBjb25uZWN0b3JEb3QoeyBsaW5lOiBsaW5lJCQxLCBzY2FsZTogY29ubmVjdG9yRGF0YS5lbmRTY2FsZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVuZFR5cGUgfHwgZW5kVHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5jb25uZWN0b3Iuc2VsZWN0KFwiLmNvbm5lY3Rvci1lbmRcIikucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQuY29tcG9uZW50cykge1xuICAgICAgICBlbmQuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYy5hdHRycy5maWxsID0gX3RoaXMzLmFubm90YXRpb24uY29sb3I7XG4gICAgICAgICAgYy5hdHRycy5zdHJva2UgPSBfdGhpczMuYW5ub3RhdGlvbi5jb2xvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbXBvbmVudHMgPSBjb21wb25lbnRzLmNvbmNhdChlbmQuY29tcG9uZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGlmIChoYW5kbGVzLmxlbmd0aCAhPT0gMCkgY29tcG9uZW50cy5wdXNoKHsgdHlwZTogXCJoYW5kbGVcIiwgaGFuZGxlczogaGFuZGxlcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Tm90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Tm90ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHZhciBub3RlRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlO1xuICAgICAgdmFyIGFsaWduID0gbm90ZURhdGEuYWxpZ24gfHwgY29udGV4dC5hbGlnbiB8fCBcImR5bmFtaWNcIjtcbiAgICAgIHZhciBub3RlUGFyYW1zID0ge1xuICAgICAgICBiYm94OiBjb250ZXh0LmJib3gsXG4gICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmFubm90YXRpb24ub2Zmc2V0XG4gICAgICB9O1xuICAgICAgdmFyIGxpbmVUeXBlID0gbm90ZURhdGEubGluZVR5cGUgfHwgY29udGV4dC5saW5lVHlwZTtcbiAgICAgIHZhciBub3RlID0ge307XG4gICAgICBpZiAobGluZVR5cGUgPT09IFwidmVydGljYWxcIikgbm90ZSA9IG5vdGVWZXJ0aWNhbChub3RlUGFyYW1zKTtlbHNlIGlmIChsaW5lVHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIG5vdGUgPSBub3RlSG9yaXpvbnRhbChub3RlUGFyYW1zKTtcblxuICAgICAgdmFyIF9ub3RlID0gbm90ZSxcbiAgICAgICAgICBfbm90ZSRjb21wb25lbnRzID0gX25vdGUuY29tcG9uZW50cyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX25vdGUkY29tcG9uZW50cyA9PT0gdW5kZWZpbmVkID8gW10gOiBfbm90ZSRjb21wb25lbnRzLFxuICAgICAgICAgIF9ub3RlJGhhbmRsZXMgPSBfbm90ZS5oYW5kbGVzLFxuICAgICAgICAgIGhhbmRsZXMgPSBfbm90ZSRoYW5kbGVzID09PSB1bmRlZmluZWQgPyBbXSA6IF9ub3RlJGhhbmRsZXM7XG5cbiAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBjLmF0dHJzLnN0cm9rZSA9IF90aGlzNC5hbm5vdGF0aW9uLmNvbG9yO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgIGhhbmRsZXMgPSB0aGlzLm1hcEhhbmRsZXMoW3sgeDogMCwgeTogMCwgZHJhZzogdGhpcy5kcmFnTm90ZS5iaW5kKHRoaXMpIH1dKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHsgdHlwZTogXCJoYW5kbGVcIiwgaGFuZGxlczogaGFuZGxlcyB9KTtcblxuICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLmRyYWdOb3RlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuZHJhZ3N0YXJ0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuZHJhZ2VuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubm90ZS5jYWxsKGRyYWcoKS5jb250YWluZXIoc2VsZWN0KFwiZy5hbm5vdGF0aW9uc1wiKS5ub2RlKCkpLm9uKFwic3RhcnRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnQoZCk7XG4gICAgICAgIH0pLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkcmFnZ2luZyhkKTtcbiAgICAgICAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZW5kKGQpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vdGUub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Tm90ZUNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGVDb250ZW50KGNvbnRleHQpIHtcbiAgICAgIHZhciBub3RlRGF0YSA9IHRoaXMuYW5ub3RhdGlvbi5ub3RlO1xuICAgICAgdmFyIHBhZGRpbmcgPSBub3RlRGF0YS5wYWRkaW5nICE9PSB1bmRlZmluZWQgPyBub3RlRGF0YS5wYWRkaW5nIDogdGhpcy5ub3RlUGFkZGluZztcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IG5vdGVEYXRhLm9yaWVudGF0aW9uIHx8IGNvbnRleHQub3JpZW50YXRpb24gfHwgXCJ0b3BCb3R0b21cIjtcbiAgICAgIHZhciBsaW5lVHlwZSA9IG5vdGVEYXRhLmxpbmVUeXBlIHx8IGNvbnRleHQubGluZVR5cGU7XG4gICAgICB2YXIgYWxpZ24gPSBub3RlRGF0YS5hbGlnbiB8fCBjb250ZXh0LmFsaWduIHx8IFwiZHluYW1pY1wiO1xuXG4gICAgICBpZiAobGluZVR5cGUgPT09IFwidmVydGljYWxcIikgb3JpZW50YXRpb24gPSBcImxlZnRSaWdodFwiO2Vsc2UgaWYgKGxpbmVUeXBlID09PSBcImhvcml6b250YWxcIikgb3JpZW50YXRpb24gPSBcInRvcEJvdHRvbVwiO1xuXG4gICAgICB2YXIgbm90ZVBhcmFtcyA9IHtcbiAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgYmJveDogY29udGV4dC5iYm94LFxuICAgICAgICBvZmZzZXQ6IHRoaXMuYW5ub3RhdGlvbi5vZmZzZXQsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcbiAgICAgICAgYWxpZ246IGFsaWduXG4gICAgICB9O1xuXG4gICAgICB2YXIgX25vdGVBbGlnbm1lbnQgPSBub3RlQWxpZ25tZW50KG5vdGVQYXJhbXMpLFxuICAgICAgICAgIHggPSBfbm90ZUFsaWdubWVudC54LFxuICAgICAgICAgIHkgPSBfbm90ZUFsaWdubWVudC55O1xuXG4gICAgICB0aGlzLm9mZnNldENvcm5lclggPSB4ICsgdGhpcy5hbm5vdGF0aW9uLmR4O1xuICAgICAgdGhpcy5vZmZzZXRDb3JuZXJZID0geSArIHRoaXMuYW5ub3RhdGlvbi5keTtcbiAgICAgIHRoaXMubm90ZSAmJiB0aGlzLm5vdGVDb250ZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiKVwiKTtcblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3T25TY3JlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd09uU2NyZWVuKGNvbXBvbmVudCwgZHJhd0Z1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3T25TVkcoY29tcG9uZW50LCBkcmF3RnVuY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhd1N1YmplY3QoKSB7XG4gICAgICB0aGlzLnN1YmplY3QgJiYgdGhpcy5kcmF3T25TY3JlZW4odGhpcy5zdWJqZWN0LCB0aGlzLmRyYXdTdWJqZWN0KCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdDb25uZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3Q29ubmVjdG9yKCkge1xuICAgICAgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5kcmF3T25TY3JlZW4odGhpcy5jb25uZWN0b3IsIHRoaXMuZHJhd0Nvbm5lY3RvcigpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3Tm90ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRyYXdOb3RlKCkge1xuICAgICAgdmFyIGJib3ggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuZ2V0Tm90ZUJCb3goKTtcblxuICAgICAgdGhpcy5ub3RlQ29udGVudCAmJiB0aGlzLmRyYXdPblNjcmVlbih0aGlzLm5vdGVDb250ZW50LCB0aGlzLmRyYXdOb3RlQ29udGVudCh7IGJib3g6IGJib3ggfSkpO1xuICAgICAgdGhpcy5ub3RlICYmIHRoaXMuZHJhd09uU2NyZWVuKHRoaXMubm90ZSwgdGhpcy5kcmF3Tm90ZSh7IGJib3g6IGJib3ggfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYW5ub3RhdGlvbi5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcG9zaXRpb24ueCArIFwiLCBcIiArIHBvc2l0aW9uLnkgKyBcIilcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQ29tcG9uZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLnN1YmplY3QgJiYgdGhpcy5zdWJqZWN0LnNlbGVjdChcIipcIikucmVtb3ZlKCk7XG4gICAgICB0aGlzLmNvbm5lY3RvciAmJiB0aGlzLmNvbm5lY3Rvci5zZWxlY3QoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgLy8gdGhpcy5ub3RlICYmIHRoaXMubm90ZS5zZWxlY3QoXCIqXCIpLnJlbW92ZSgpXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy5ub3RlKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmFubm90YXRpb24ub2Zmc2V0O1xuICAgICAgICB0aGlzLm5vdGUuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG9mZnNldC54ICsgXCIsIFwiICsgb2Zmc2V0LnkgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uV2l0aEFjY2Vzc29yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbldpdGhBY2Nlc3NvcnMoYWNjZXNzb3JzKSB7XG4gICAgICBpZiAoYWNjZXNzb3JzICYmIHRoaXMuYW5ub3RhdGlvbi5kYXRhKSB7XG4gICAgICAgIHRoaXMubWFwWChhY2Nlc3NvcnMpO1xuICAgICAgICB0aGlzLm1hcFkoYWNjZXNzb3JzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2xhc3NOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENsYXNzTmFtZSgpIHtcbiAgICAgIHRoaXMuYS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uIFwiICsgKHRoaXMuY2xhc3NOYW1lICYmIHRoaXMuY2xhc3NOYW1lKCkpICsgXCIgXCIgKyAodGhpcy5lZGl0TW9kZSA/IFwiZWRpdGFibGVcIiA6IFwiXCIpICsgXCIgXCIgKyAodGhpcy5hbm5vdGF0aW9uLmNsYXNzTmFtZSB8fCBcIlwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lKCk7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnNldE9mZnNldCgpO1xuICAgICAgdGhpcy5yZWRyYXdTdWJqZWN0KCk7XG4gICAgICB0aGlzLnJlZHJhd0Nvbm5lY3RvcigpO1xuICAgICAgdGhpcy5yZWRyYXdOb3RlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdzdGFydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdzdGFydGVkKCkge1xuICAgICAgZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmRpc3BhdGNoZXIgJiYgdGhpcy5kaXNwYXRjaGVyLmNhbGwoXCJkcmFnc3RhcnRcIiwgdGhpcy5hLCB0aGlzLmFubm90YXRpb24pO1xuICAgICAgdGhpcy5hLmNsYXNzZWQoXCJkcmFnZ2luZ1wiLCB0cnVlKTtcbiAgICAgIHRoaXMuYS5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnZW5kZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ2VuZGVkKCkge1xuICAgICAgdGhpcy5kaXNwYXRjaGVyICYmIHRoaXMuZGlzcGF0Y2hlci5jYWxsKFwiZHJhZ2VuZFwiLCB0aGlzLmEsIHRoaXMuYW5ub3RhdGlvbik7XG4gICAgICB0aGlzLmEuY2xhc3NlZChcImRyYWdnaW5nXCIsIGZhbHNlKTtcbiAgICAgIHRoaXMuYS5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdTdWJqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYWdTdWJqZWN0KCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5hbm5vdGF0aW9uLnBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24ueCArPSBldmVudC5keDtcbiAgICAgIHBvc2l0aW9uLnkgKz0gZXZlbnQuZHk7XG4gICAgICB0aGlzLmFubm90YXRpb24ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhZ05vdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ05vdGUoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5hbm5vdGF0aW9uLm9mZnNldDtcbiAgICAgIG9mZnNldC54ICs9IGV2ZW50LmR4O1xuICAgICAgb2Zmc2V0LnkgKz0gZXZlbnQuZHk7XG4gICAgICB0aGlzLmFubm90YXRpb24ub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBIYW5kbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcEhhbmRsZXMoaGFuZGxlcykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBoYW5kbGVzLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGgsIHtcbiAgICAgICAgICBzdGFydDogX3RoaXM1LmRyYWdzdGFydGVkLmJpbmQoX3RoaXM1KSxcbiAgICAgICAgICBlbmQ6IF90aGlzNS5kcmFnZW5kZWQuYmluZChfdGhpczUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeXBlO1xufSgpO1xuXG52YXIgY3VzdG9tVHlwZSA9IGZ1bmN0aW9uIGN1c3RvbVR5cGUoaW5pdGlhbFR5cGUsIHR5cGVTZXR0aW5ncywgX2luaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfaW5pdGlhbFR5cGUpIHtcbiAgICBpbmhlcml0cyhjdXN0b21UeXBlLCBfaW5pdGlhbFR5cGUpO1xuXG4gICAgZnVuY3Rpb24gY3VzdG9tVHlwZShzZXR0aW5ncykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgY3VzdG9tVHlwZSk7XG5cbiAgICAgIHZhciBfdGhpczYgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChjdXN0b21UeXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZSkpLmNhbGwodGhpcywgc2V0dGluZ3MpKTtcblxuICAgICAgX3RoaXM2LnR5cGVTZXR0aW5ncyA9IHR5cGVTZXR0aW5ncztcblxuICAgICAgaWYgKHR5cGVTZXR0aW5ncy5kaXNhYmxlKSB7XG4gICAgICAgIHR5cGVTZXR0aW5ncy5kaXNhYmxlLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBfdGhpczZbZF0gJiYgX3RoaXM2W2RdLnJlbW92ZSgpO1xuXG4gICAgICAgICAgX3RoaXM2W2RdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChkID09PSBcIm5vdGVcIikge1xuICAgICAgICAgICAgX3RoaXM2Lm5vdGVDb250ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXM2O1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKGN1c3RvbVR5cGUsIFt7XG4gICAgICBrZXk6IFwiY2xhc3NOYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJcIiArICh0eXBlU2V0dGluZ3MuY2xhc3NOYW1lIHx8IGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJjbGFzc05hbWVcIiwgdGhpcykgJiYgZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImNsYXNzTmFtZVwiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IFwiXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3U3ViamVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTdWJqZWN0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCA9IF9leHRlbmRzKHt9LCB0eXBlU2V0dGluZ3Muc3ViamVjdCwgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCk7XG4gICAgICAgIHJldHVybiBnZXQoY3VzdG9tVHlwZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXN0b21UeXBlLnByb3RvdHlwZSksIFwiZHJhd1N1YmplY3RcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdGhpcy50eXBlU2V0dGluZ3Muc3ViamVjdCkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Q29ubmVjdG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Nvbm5lY3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHlwZVNldHRpbmdzLmNvbm5lY3RvciA9IF9leHRlbmRzKHt9LCB0eXBlU2V0dGluZ3MuY29ubmVjdG9yLCB0aGlzLnR5cGVTZXR0aW5ncy5jb25uZWN0b3IpO1xuICAgICAgICByZXR1cm4gZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImRyYXdDb25uZWN0b3JcIiwgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgdHlwZVNldHRpbmdzLmNvbm5lY3RvciwgdGhpcy50eXBlU2V0dGluZ3MuY29ubmVjdG9yKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdOb3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vdGUoY29udGV4dCkge1xuICAgICAgICB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlID0gX2V4dGVuZHMoe30sIHR5cGVTZXR0aW5ncy5ub3RlLCB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlKTtcbiAgICAgICAgcmV0dXJuIGdldChjdXN0b21UeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUucHJvdG90eXBlKSwgXCJkcmF3Tm90ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIF9leHRlbmRzKHt9LCBjb250ZXh0LCB0eXBlU2V0dGluZ3Mubm90ZSwgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3Tm90ZUNvbnRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Tm90ZUNvbnRlbnQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZ2V0KGN1c3RvbVR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VzdG9tVHlwZS5wcm90b3R5cGUpLCBcImRyYXdOb3RlQ29udGVudFwiLCB0aGlzKS5jYWxsKHRoaXMsIF9leHRlbmRzKHt9LCBjb250ZXh0LCB0eXBlU2V0dGluZ3Mubm90ZSwgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSkpO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGFubm90YXRpb24sIGFjY2Vzc29ycykge1xuICAgICAgICBnZXQoY3VzdG9tVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1c3RvbVR5cGUpLCBcImluaXRcIiwgdGhpcykuY2FsbCh0aGlzLCBhbm5vdGF0aW9uLCBhY2Nlc3NvcnMpO1xuICAgICAgICBpZiAoX2luaXQpIHtcbiAgICAgICAgICBhbm5vdGF0aW9uID0gX2luaXQoYW5ub3RhdGlvbiwgYWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIGN1c3RvbVR5cGU7XG4gIH0oaW5pdGlhbFR5cGUpO1xufTtcblxudmFyIGQzTm90ZVRleHQgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgaW5oZXJpdHMoZDNOb3RlVGV4dCwgX1R5cGUpO1xuXG4gIGZ1bmN0aW9uIGQzTm90ZVRleHQocGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgZDNOb3RlVGV4dCk7XG5cbiAgICB2YXIgX3RoaXM3ID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoZDNOb3RlVGV4dC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGQzTm90ZVRleHQpKS5jYWxsKHRoaXMsIHBhcmFtcykpO1xuXG4gICAgX3RoaXM3LnRleHRXcmFwID0gcGFyYW1zLnRleHRXcmFwIHx8IDEyMDtcbiAgICBfdGhpczcuZHJhd1RleHQoKTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoZDNOb3RlVGV4dCwgW3tcbiAgICBrZXk6IFwidXBkYXRlVGV4dFdyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVGV4dFdyYXAodGV4dFdyYXApIHtcbiAgICAgIHRoaXMudGV4dFdyYXAgPSB0ZXh0V3JhcDtcbiAgICAgIHRoaXMuZHJhd1RleHQoKTtcbiAgICB9XG5cbiAgICAvL1RPRE86IGFkZCB1cGRhdGUgdGV4dCBmdW5jdGlvbmFsaXR5XG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLm5vdGUpIHtcbiAgICAgICAgbmV3V2l0aENsYXNzKHRoaXMubm90ZSwgW3RoaXMuYW5ub3RhdGlvbl0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuXG4gICAgICAgIHZhciBub3RlQ29udGVudCA9IHRoaXMubm90ZS5zZWxlY3QoXCJnLmFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgICAgICBuZXdXaXRoQ2xhc3Mobm90ZUNvbnRlbnQsIFt0aGlzLmFubm90YXRpb25dLCBcInJlY3RcIiwgXCJhbm5vdGF0aW9uLW5vdGUtYmdcIik7XG4gICAgICAgIG5ld1dpdGhDbGFzcyhub3RlQ29udGVudCwgW3RoaXMuYW5ub3RhdGlvbl0sIFwidGV4dFwiLCBcImFubm90YXRpb24tbm90ZS1sYWJlbFwiKTtcbiAgICAgICAgbmV3V2l0aENsYXNzKG5vdGVDb250ZW50LCBbdGhpcy5hbm5vdGF0aW9uXSwgXCJ0ZXh0XCIsIFwiYW5ub3RhdGlvbi1ub3RlLXRpdGxlXCIpO1xuXG4gICAgICAgIHZhciB0aXRsZUJCb3ggPSB7IGhlaWdodDogMCB9O1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmEuc2VsZWN0KFwidGV4dC5hbm5vdGF0aW9uLW5vdGUtbGFiZWxcIik7XG4gICAgICAgIHZhciB3cmFwTGVuZ3RoID0gdGhpcy5hbm5vdGF0aW9uLm5vdGUgJiYgdGhpcy5hbm5vdGF0aW9uLm5vdGUud3JhcCB8fCB0aGlzLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUud3JhcCB8fCB0aGlzLnRleHRXcmFwO1xuXG4gICAgICAgIHZhciB3cmFwU3BsaXR0ZXIgPSB0aGlzLmFubm90YXRpb24ubm90ZSAmJiB0aGlzLmFubm90YXRpb24ubm90ZS53cmFwU3BsaXR0ZXIgfHwgdGhpcy50eXBlU2V0dGluZ3MgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZSAmJiB0aGlzLnR5cGVTZXR0aW5ncy5ub3RlLndyYXBTcGxpdHRlcjtcblxuICAgICAgICB2YXIgYmdQYWRkaW5nID0gdGhpcy5hbm5vdGF0aW9uLm5vdGUgJiYgdGhpcy5hbm5vdGF0aW9uLm5vdGUuYmdQYWRkaW5nIHx8IHRoaXMudHlwZVNldHRpbmdzICYmIHRoaXMudHlwZVNldHRpbmdzLm5vdGUgJiYgdGhpcy50eXBlU2V0dGluZ3Mubm90ZS5iZ1BhZGRpbmc7XG5cbiAgICAgICAgdmFyIGJnUGFkZGluZ0ZpbmFsID0geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBiZ1BhZGRpbmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBiZ1BhZGRpbmdGaW5hbCA9IHtcbiAgICAgICAgICAgIHRvcDogYmdQYWRkaW5nLFxuICAgICAgICAgICAgYm90dG9tOiBiZ1BhZGRpbmcsXG4gICAgICAgICAgICBsZWZ0OiBiZ1BhZGRpbmcsXG4gICAgICAgICAgICByaWdodDogYmdQYWRkaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChiZ1BhZGRpbmcgJiYgKHR5cGVvZiBiZ1BhZGRpbmcgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihiZ1BhZGRpbmcpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGJnUGFkZGluZ0ZpbmFsID0gX2V4dGVuZHMoYmdQYWRkaW5nRmluYWwsIGJnUGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uLm5vdGUudGl0bGUpIHtcbiAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmEuc2VsZWN0KFwidGV4dC5hbm5vdGF0aW9uLW5vdGUtdGl0bGVcIik7XG4gICAgICAgICAgdGl0bGUudGV4dCh0aGlzLmFubm90YXRpb24ubm90ZS50aXRsZSk7XG4gICAgICAgICAgdGl0bGUuYXR0cihcImZpbGxcIiwgdGhpcy5hbm5vdGF0aW9uLmNvbG9yKTtcbiAgICAgICAgICB0aXRsZS5hdHRyKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpO1xuICAgICAgICAgIHRpdGxlLmNhbGwod3JhcCwgd3JhcExlbmd0aCwgd3JhcFNwbGl0dGVyKTtcbiAgICAgICAgICB0aXRsZUJCb3ggPSB0aXRsZS5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwudGV4dCh0aGlzLmFubm90YXRpb24ubm90ZS5sYWJlbCkuYXR0cihcImR4XCIsIFwiMFwiKTtcbiAgICAgICAgbGFiZWwuY2FsbCh3cmFwLCB3cmFwTGVuZ3RoLCB3cmFwU3BsaXR0ZXIpO1xuXG4gICAgICAgIGxhYmVsLmF0dHIoXCJ5XCIsIHRpdGxlQkJveC5oZWlnaHQgKiAxLjEgfHwgMCk7XG4gICAgICAgIGxhYmVsLmF0dHIoXCJmaWxsXCIsIHRoaXMuYW5ub3RhdGlvbi5jb2xvcik7XG5cbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldE5vdGVCQm94KCk7XG5cbiAgICAgICAgdGhpcy5hLnNlbGVjdChcInJlY3QuYW5ub3RhdGlvbi1ub3RlLWJnXCIpLmF0dHIoXCJ3aWR0aFwiLCBiYm94LndpZHRoICsgYmdQYWRkaW5nRmluYWwubGVmdCArIGJnUGFkZGluZ0ZpbmFsLnJpZ2h0KS5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0ICsgYmdQYWRkaW5nRmluYWwudG9wICsgYmdQYWRkaW5nRmluYWwuYm90dG9tKS5hdHRyKFwieFwiLCBiYm94LnggLSBiZ1BhZGRpbmdGaW5hbC5sZWZ0KS5hdHRyKFwieVwiLCAtYmdQYWRkaW5nRmluYWwudG9wKS5hdHRyKFwiZmlsbFwiLCBcIndoaXRlXCIpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBkM05vdGVUZXh0O1xufShUeXBlKTtcblxudmFyIGQzTGFiZWwgPSBjdXN0b21UeXBlKGQzTm90ZVRleHQsIHtcbiAgY2xhc3NOYW1lOiBcImxhYmVsXCIsXG4gIG5vdGU6IHsgYWxpZ246IFwibWlkZGxlXCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXQgPSBjdXN0b21UeXBlKGQzTm90ZVRleHQsIHtcbiAgY2xhc3NOYW1lOiBcImNhbGxvdXRcIixcbiAgbm90ZTogeyBsaW5lVHlwZTogXCJob3Jpem9udGFsXCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRFbGJvdyA9IGN1c3RvbVR5cGUoZDNDYWxsb3V0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IGVsYm93XCIsXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImVsYm93XCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRDdXJ2ZSA9IGN1c3RvbVR5cGUoZDNDYWxsb3V0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IGN1cnZlXCIsXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImN1cnZlXCIgfVxufSk7XG5cbnZhciBkM0JhZGdlID0gY3VzdG9tVHlwZShUeXBlLCB7XG4gIGNsYXNzTmFtZTogXCJiYWRnZVwiLFxuICBzdWJqZWN0OiB7IHR5cGU6IFwiYmFkZ2VcIiB9LFxuICBkaXNhYmxlOiBbXCJjb25uZWN0b3JcIiwgXCJub3RlXCJdXG59KTtcblxudmFyIGQzQ2FsbG91dENpcmNsZSA9IGN1c3RvbVR5cGUoZDNOb3RlVGV4dCwge1xuICBjbGFzc05hbWU6IFwiY2FsbG91dCBjaXJjbGVcIixcbiAgc3ViamVjdDogeyB0eXBlOiBcImNpcmNsZVwiIH0sXG4gIG5vdGU6IHsgbGluZVR5cGU6IFwiaG9yaXpvbnRhbFwiIH0sXG4gIGNvbm5lY3RvcjogeyB0eXBlOiBcImVsYm93XCIgfVxufSk7XG5cbnZhciBkM0NhbGxvdXRSZWN0ID0gY3VzdG9tVHlwZShkM05vdGVUZXh0LCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IHJlY3RcIixcbiAgc3ViamVjdDogeyB0eXBlOiBcInJlY3RcIiB9LFxuICBub3RlOiB7IGxpbmVUeXBlOiBcImhvcml6b250YWxcIiB9LFxuICBjb25uZWN0b3I6IHsgdHlwZTogXCJlbGJvd1wiIH1cbn0pO1xuXG52YXIgVGhyZXNob2xkTWFwID0gZnVuY3Rpb24gKF9kM0NhbGxvdXQpIHtcbiAgaW5oZXJpdHMoVGhyZXNob2xkTWFwLCBfZDNDYWxsb3V0KTtcblxuICBmdW5jdGlvbiBUaHJlc2hvbGRNYXAoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhyZXNob2xkTWFwKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGhyZXNob2xkTWFwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhyZXNob2xkTWFwKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUaHJlc2hvbGRNYXAsIFt7XG4gICAga2V5OiBcIm1hcFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWShhY2Nlc3NvcnMpIHtcbiAgICAgIGdldChUaHJlc2hvbGRNYXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGhyZXNob2xkTWFwLnByb3RvdHlwZSksIFwibWFwWVwiLCB0aGlzKS5jYWxsKHRoaXMsIGFjY2Vzc29ycyk7XG4gICAgICB2YXIgYSA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgIGlmICgoYS5zdWJqZWN0LngxIHx8IGEuc3ViamVjdC54MikgJiYgYS5kYXRhICYmIGFjY2Vzc29ycy55KSB7XG4gICAgICAgIGEueSA9IGFjY2Vzc29ycy55KGEuZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKGEuc3ViamVjdC54MSB8fCBhLnN1YmplY3QueDIpICYmICFhLngpIHtcbiAgICAgICAgYS54ID0gYS5zdWJqZWN0LngxIHx8IGEuc3ViamVjdC54MjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBYKGFjY2Vzc29ycykge1xuICAgICAgZ2V0KFRocmVzaG9sZE1hcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaHJlc2hvbGRNYXAucHJvdG90eXBlKSwgXCJtYXBYXCIsIHRoaXMpLmNhbGwodGhpcywgYWNjZXNzb3JzKTtcbiAgICAgIHZhciBhID0gdGhpcy5hbm5vdGF0aW9uO1xuICAgICAgaWYgKChhLnN1YmplY3QueTEgfHwgYS5zdWJqZWN0LnkyKSAmJiBhLmRhdGEgJiYgYWNjZXNzb3JzLngpIHtcbiAgICAgICAgYS54ID0gYWNjZXNzb3JzLngoYS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmICgoYS5zdWJqZWN0LnkxIHx8IGEuc3ViamVjdC55MikgJiYgIWEueSkge1xuICAgICAgICBhLnkgPSBhLnN1YmplY3QueTEgfHwgYS5zdWJqZWN0LnkyO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGhyZXNob2xkTWFwO1xufShkM0NhbGxvdXQpO1xuXG52YXIgZDNYWVRocmVzaG9sZCA9IGN1c3RvbVR5cGUoVGhyZXNob2xkTWFwLCB7XG4gIGNsYXNzTmFtZTogXCJjYWxsb3V0IHh5dGhyZXNob2xkXCIsXG4gIHN1YmplY3Q6IHsgdHlwZTogXCJ0aHJlc2hvbGRcIiB9XG59KTtcblxudmFyIG5ld1dpdGhDbGFzcyA9IGZ1bmN0aW9uIG5ld1dpdGhDbGFzcyhhLCBkLCB0eXBlLCBjbGFzc05hbWUsIGNsYXNzSUQpIHtcbiAgdmFyIGdyb3VwID0gYS5zZWxlY3RBbGwodHlwZSArIFwiLlwiICsgKGNsYXNzSUQgfHwgY2xhc3NOYW1lKSkuZGF0YShkKTtcbiAgZ3JvdXAuZW50ZXIoKS5hcHBlbmQodHlwZSkubWVyZ2UoZ3JvdXApLmF0dHIoXCJjbGFzc1wiLCBjbGFzc05hbWUpO1xuXG4gIGdyb3VwLmV4aXQoKS5yZW1vdmUoKTtcbiAgcmV0dXJuIGE7XG59O1xuXG52YXIgYWRkSGFuZGxlcnMgPSBmdW5jdGlvbiBhZGRIYW5kbGVycyhkaXNwYXRjaGVyLCBhbm5vdGF0aW9uLCBfcmVmMykge1xuICB2YXIgY29tcG9uZW50ID0gX3JlZjMuY29tcG9uZW50LFxuICAgICAgbmFtZSA9IF9yZWYzLm5hbWU7XG5cbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5vbihcIm1vdXNlb3Zlci5hbm5vdGF0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkaXNwYXRjaGVyLmNhbGwobmFtZSArIFwib3ZlclwiLCBjb21wb25lbnQsIGFubm90YXRpb24pO1xuICAgIH0pLm9uKFwibW91c2VvdXQuYW5ub3RhdGlvbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIuY2FsbChuYW1lICsgXCJvdXRcIiwgY29tcG9uZW50LCBhbm5vdGF0aW9uKTtcbiAgICB9KS5vbihcImNsaWNrLmFubm90YXRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyLmNhbGwobmFtZSArIFwiY2xpY2tcIiwgY29tcG9uZW50LCBhbm5vdGF0aW9uKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy9UZXh0IHdyYXBwaW5nIGNvZGUgYWRhcHRlZCBmcm9tIE1pa2UgQm9zdG9ja1xudmFyIHdyYXAgPSBmdW5jdGlvbiB3cmFwKHRleHQsIHdpZHRoLCB3cmFwU3BsaXR0ZXIpIHtcbiAgdmFyIGxpbmVIZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDEuMjtcblxuICB0ZXh0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0ID0gc2VsZWN0KHRoaXMpLFxuICAgICAgICB3b3JkcyA9IHRleHQudGV4dCgpLnNwbGl0KHdyYXBTcGxpdHRlciB8fCAvWyBcXHRcXHJcXG5dKy8pLnJldmVyc2UoKS5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgIHJldHVybiB3ICE9PSBcIlwiO1xuICAgIH0pO1xuICAgIHZhciB3b3JkID0gdm9pZCAwLFxuICAgICAgICBsaW5lJCQxID0gW10sXG4gICAgICAgIHRzcGFuID0gdGV4dC50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCAwLjggKyBcImVtXCIpO1xuXG4gICAgd2hpbGUgKHdvcmQgPSB3b3Jkcy5wb3AoKSkge1xuICAgICAgbGluZSQkMS5wdXNoKHdvcmQpO1xuICAgICAgdHNwYW4udGV4dChsaW5lJCQxLmpvaW4oXCIgXCIpKTtcbiAgICAgIGlmICh0c3Bhbi5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPiB3aWR0aCAmJiBsaW5lJCQxLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGluZSQkMS5wb3AoKTtcbiAgICAgICAgdHNwYW4udGV4dChsaW5lJCQxLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbGluZSQkMSA9IFt3b3JkXTtcbiAgICAgICAgdHNwYW4gPSB0ZXh0LmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJkeVwiLCBsaW5lSGVpZ2h0ICsgXCJlbVwiKS50ZXh0KHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgYmJveFdpdGhvdXRIYW5kbGVzID0gZnVuY3Rpb24gYmJveFdpdGhvdXRIYW5kbGVzKHNlbGVjdGlvbikge1xuICB2YXIgc2VsZWN0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiOm5vdCguaGFuZGxlKVwiO1xuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbi5zZWxlY3RBbGwoc2VsZWN0b3IpLm5vZGVzKCkucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgdmFyIGJib3ggPSBjLmdldEJCb3goKTtcbiAgICBwLnggPSBNYXRoLm1pbihwLngsIGJib3gueCk7XG4gICAgcC55ID0gTWF0aC5taW4ocC55LCBiYm94LnkpO1xuICAgIHAud2lkdGggPSBNYXRoLm1heChwLndpZHRoLCBiYm94LndpZHRoKTtcblxuICAgIHZhciB5T2Zmc2V0ID0gYyAmJiBjLmF0dHJpYnV0ZXMgJiYgYy5hdHRyaWJ1dGVzLnk7XG4gICAgcC5oZWlnaHQgPSBNYXRoLm1heChwLmhlaWdodCwgKHlPZmZzZXQgJiYgcGFyc2VGbG9hdCh5T2Zmc2V0LnZhbHVlKSB8fCAwKSArIGJib3guaGVpZ2h0KTtcbiAgICByZXR1cm4gcDtcbiAgfSwgeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbigpIHtcbiAgdmFyIGFubm90YXRpb25zID0gW10sXG4gICAgICBjb2xsZWN0aW9uID0gdm9pZCAwLFxuICAgICAgY29udGV4dCA9IHZvaWQgMCxcbiAgICAgIC8vVE9ETzogYWRkIGNhbnZhcyBmdW5jdGlvbmFsaXR5XG4gIGRpc2FibGUgPSBbXSxcbiAgICAgIGFjY2Vzc29ycyA9IHt9LFxuICAgICAgYWNjZXNzb3JzSW52ZXJzZSA9IHt9LFxuICAgICAgZWRpdE1vZGUgPSBmYWxzZSxcbiAgICAgIGlkcyA9IHZvaWQgMCxcbiAgICAgIHR5cGUgPSBkM0NhbGxvdXQsXG4gICAgICB0ZXh0V3JhcCA9IHZvaWQgMCxcbiAgICAgIG5vdGVQYWRkaW5nID0gdm9pZCAwLFxuICAgICAgYW5ub3RhdGlvbkRpc3BhdGNoZXIgPSBkaXNwYXRjaChcInN1YmplY3RvdmVyXCIsIFwic3ViamVjdG91dFwiLCBcInN1YmplY3RjbGlja1wiLCBcImNvbm5lY3Rvcm92ZXJcIiwgXCJjb25uZWN0b3JvdXRcIiwgXCJjb25uZWN0b3JjbGlja1wiLCBcIm5vdGVvdmVyXCIsIFwibm90ZW91dFwiLCBcIm5vdGVjbGlja1wiLCBcImRyYWdlbmRcIiwgXCJkcmFnc3RhcnRcIiksXG4gICAgICBzZWwgPSB2b2lkIDA7XG5cbiAgdmFyIGFubm90YXRpb24gPSBmdW5jdGlvbiBhbm5vdGF0aW9uKHNlbGVjdGlvbikge1xuICAgIHNlbCA9IHNlbGVjdGlvbjtcbiAgICAvL1RPRE86IGNoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIHN0aWxsIG5lZWRlZFxuICAgIGlmICghZWRpdE1vZGUpIHtcbiAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJjaXJjbGUuaGFuZGxlXCIpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2xhdGVkQW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGlmICghYS50eXBlKSB7XG4gICAgICAgIGEudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoIWEuZGlzYWJsZSkge1xuICAgICAgICBhLmRpc2FibGUgPSBkaXNhYmxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKGEpO1xuICAgIH0pO1xuXG4gICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24gfHwgbmV3IEFubm90YXRpb25Db2xsZWN0aW9uKHtcbiAgICAgIGFubm90YXRpb25zOiB0cmFuc2xhdGVkQW5ub3RhdGlvbnMsXG4gICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29ycyxcbiAgICAgIGFjY2Vzc29yc0ludmVyc2U6IGFjY2Vzc29yc0ludmVyc2UsXG4gICAgICBpZHM6IGlkc1xuICAgIH0pO1xuXG4gICAgdmFyIGFubm90YXRpb25HID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcImdcIikuZGF0YShbY29sbGVjdGlvbl0pO1xuICAgIGFubm90YXRpb25HLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uc1wiKTtcblxuICAgIHZhciBncm91cCA9IHNlbGVjdGlvbi5zZWxlY3QoXCJnLmFubm90YXRpb25zXCIpO1xuICAgIG5ld1dpdGhDbGFzcyhncm91cCwgY29sbGVjdGlvbi5hbm5vdGF0aW9ucywgXCJnXCIsIFwiYW5ub3RhdGlvblwiKTtcblxuICAgIHZhciBhbm5vdGF0aW9uID0gZ3JvdXAuc2VsZWN0QWxsKFwiZy5hbm5vdGF0aW9uXCIpO1xuXG4gICAgYW5ub3RhdGlvbi5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYSA9IHNlbGVjdCh0aGlzKTtcblxuICAgICAgYS5hdHRyKFwiY2xhc3NcIiwgXCJhbm5vdGF0aW9uXCIpO1xuXG4gICAgICBuZXdXaXRoQ2xhc3MoYSwgW2RdLCBcImdcIiwgXCJhbm5vdGF0aW9uLWNvbm5lY3RvclwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tc3ViamVjdFwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZVwiKTtcbiAgICAgIG5ld1dpdGhDbGFzcyhhLnNlbGVjdChcImcuYW5ub3RhdGlvbi1ub3RlXCIpLCBbZF0sIFwiZ1wiLCBcImFubm90YXRpb24tbm90ZS1jb250ZW50XCIpO1xuICAgICAgZC50eXBlID0gZC50eXBlLnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBPYmplY3RdXCIgPyBkLnR5cGUgOiBuZXcgZC50eXBlKHtcbiAgICAgICAgYTogYSxcbiAgICAgICAgYW5ub3RhdGlvbjogZCxcbiAgICAgICAgdGV4dFdyYXA6IHRleHRXcmFwLFxuICAgICAgICBub3RlUGFkZGluZzogbm90ZVBhZGRpbmcsXG4gICAgICAgIGVkaXRNb2RlOiBlZGl0TW9kZSxcbiAgICAgICAgZGlzcGF0Y2hlcjogYW5ub3RhdGlvbkRpc3BhdGNoZXIsXG4gICAgICAgIGFjY2Vzc29yczogYWNjZXNzb3JzXG4gICAgICB9KTtcbiAgICAgIGQudHlwZS5kcmF3KCk7XG4gICAgICBkLnR5cGUuZHJhd1RleHQgJiYgZC50eXBlLmRyYXdUZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5qc29uID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBjb25zb2xlLmxvZyhcIkFubm90YXRpb25zIEpTT04gd2FzIGNvcGllZCB0byB5b3VyIGNsaXBib2FyZC4gUGxlYXNlIG5vdGUgdGhlIGFubm90YXRpb24gdHlwZSBpcyBub3QgSlNPTiBjb21wYXRpYmxlLiBJdCBhcHBlYXJzIGluIHRoZSBvYmplY3RzIGFycmF5IGluIHRoZSBjb25zb2xlLCBidXQgbm90IGluIHRoZSBjb3BpZWQgSlNPTi5cIiwgY29sbGVjdGlvbi5qc29uKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICB3aW5kb3cuY29weShKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uLmpzb24ubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICBkZWxldGUgYS50eXBlO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSkpKTtcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYW5ub3RhdGlvbnMgJiYgY29sbGVjdGlvbikge1xuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICBhLnR5cGUuZHJhdygpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24udXBkYXRlVGV4dCh0ZXh0V3JhcCk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24udXBkYXRlZEFjY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb2xsZWN0aW9uLnNldFBvc2l0aW9uV2l0aEFjY2Vzc29ycygpO1xuICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmRpc2FibGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpc2FibGU7XG4gICAgZGlzYWJsZSA9IF87XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24udXBkYXRlRGlzYWJsZShkaXNhYmxlKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi50ZXh0V3JhcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGV4dFdyYXA7XG4gICAgdGV4dFdyYXAgPSBfO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZVRleHRXcmFwKHRleHRXcmFwKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5ub3RlUGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm90ZVBhZGRpbmc7XG4gICAgbm90ZVBhZGRpbmcgPSBfO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uLnVwZGF0ZU5vdGVQYWRkaW5nKG5vdGVQYWRkaW5nKTtcbiAgICAgIGFubm90YXRpb25zID0gY29sbGVjdGlvbi5hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG4gIC8vdG9kbyB0aGluayBvZiBob3cgdG8gaGFuZGxlIHdoZW4gdW5kZWZpbmVkIGlzIHNlbnRcbiAgYW5ub3RhdGlvbi50eXBlID0gZnVuY3Rpb24gKF8sIHNldHRpbmdzKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHlwZTtcbiAgICB0eXBlID0gXztcbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi5hbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS50eXBlLm5vdGUgJiYgYS50eXBlLm5vdGUuc2VsZWN0QWxsKFwiKjpub3QoLmFubm90YXRpb24tbm90ZS1jb250ZW50KVwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLm5vdGVDb250ZW50ICYmIGEudHlwZS5ub3RlQ29udGVudC5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBhLnR5cGUuc3ViamVjdCAmJiBhLnR5cGUuc3ViamVjdC5zZWxlY3RBbGwoXCIqXCIpLnJlbW92ZSgpO1xuICAgICAgICBhLnR5cGUuY29ubmVjdG9yICYmIGEudHlwZS5jb25uZWN0b3Iuc2VsZWN0QWxsKFwiKlwiKS5yZW1vdmUoKTtcbiAgICAgICAgYS50eXBlLnR5cGVTZXR0aW5ncyA9IHt9O1xuICAgICAgICBhLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIGEuc3ViamVjdCA9IHNldHRpbmdzICYmIHNldHRpbmdzLnN1YmplY3QgfHwgYS5zdWJqZWN0O1xuICAgICAgICBhLmNvbm5lY3RvciA9IHNldHRpbmdzICYmIHNldHRpbmdzLmNvbm5lY3RvciB8fCBhLmNvbm5lY3RvcjtcbiAgICAgICAgYS5ub3RlID0gc2V0dGluZ3MgJiYgc2V0dGluZ3Mubm90ZSB8fCBhLm5vdGU7XG4gICAgICB9KTtcblxuICAgICAgYW5ub3RhdGlvbnMgPSBjb2xsZWN0aW9uLmFubm90YXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmFubm90YXRpb25zID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMgfHwgYW5ub3RhdGlvbnM7XG4gICAgYW5ub3RhdGlvbnMgPSBfO1xuXG4gICAgaWYgKGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5hbm5vdGF0aW9ucykge1xuICAgICAgdmFyIHJlcnVuID0gYW5ub3RhdGlvbnMuc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWQudHlwZSB8fCBkLnR5cGUudG9TdHJpbmcoKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVydW4pIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGFubm90YXRpb24oc2VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxlY3Rpb24uYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgIGNvbnRleHQgPSBfO1xuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uYWNjZXNzb3JzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhY2Nlc3NvcnM7XG4gICAgYWNjZXNzb3JzID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLmFjY2Vzc29yc0ludmVyc2UgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFjY2Vzc29yc0ludmVyc2U7XG4gICAgYWNjZXNzb3JzSW52ZXJzZSA9IF87XG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH07XG5cbiAgYW5ub3RhdGlvbi5pZHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlkcztcbiAgICBpZHMgPSBfO1xuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uZWRpdE1vZGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVkaXRNb2RlO1xuICAgIGVkaXRNb2RlID0gXztcblxuICAgIGlmIChzZWwpIHtcbiAgICAgIHNlbC5zZWxlY3RBbGwoXCJnLmFubm90YXRpb25cIikuY2xhc3NlZChcImVkaXRhYmxlXCIsIGVkaXRNb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbi5lZGl0TW9kZShlZGl0TW9kZSk7XG4gICAgICBhbm5vdGF0aW9ucyA9IGNvbGxlY3Rpb24uYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICB9O1xuXG4gIGFubm90YXRpb24uY29sbGVjdGlvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgICBjb2xsZWN0aW9uID0gXztcbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgfTtcblxuICBhbm5vdGF0aW9uLm9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IGFubm90YXRpb25EaXNwYXRjaGVyLm9uLmFwcGx5KGFubm90YXRpb25EaXNwYXRjaGVyLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gYW5ub3RhdGlvbkRpc3BhdGNoZXIgPyBhbm5vdGF0aW9uIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGFubm90YXRpb247XG59XG5cbnZhciBpbmRleCA9IHtcbiAgYW5ub3RhdGlvbjogYW5ub3RhdGlvbixcbiAgYW5ub3RhdGlvblR5cGVCYXNlOiBUeXBlLFxuICBhbm5vdGF0aW9uTGFiZWw6IGQzTGFiZWwsXG4gIGFubm90YXRpb25DYWxsb3V0OiBkM0NhbGxvdXQsXG4gIGFubm90YXRpb25DYWxsb3V0Q3VydmU6IGQzQ2FsbG91dEN1cnZlLFxuICBhbm5vdGF0aW9uQ2FsbG91dEVsYm93OiBkM0NhbGxvdXRFbGJvdyxcbiAgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGU6IGQzQ2FsbG91dENpcmNsZSxcbiAgYW5ub3RhdGlvbkNhbGxvdXRSZWN0OiBkM0NhbGxvdXRSZWN0LFxuICBhbm5vdGF0aW9uWFlUaHJlc2hvbGQ6IGQzWFlUaHJlc2hvbGQsXG4gIGFubm90YXRpb25CYWRnZTogZDNCYWRnZSxcbiAgYW5ub3RhdGlvbkN1c3RvbVR5cGU6IGN1c3RvbVR5cGVcbn07XG5cbmV4cG9ydCB7IGFubm90YXRpb24sIFR5cGUgYXMgYW5ub3RhdGlvblR5cGVCYXNlLCBkM0xhYmVsIGFzIGFubm90YXRpb25MYWJlbCwgZDNDYWxsb3V0IGFzIGFubm90YXRpb25DYWxsb3V0LCBkM0NhbGxvdXRDdXJ2ZSBhcyBhbm5vdGF0aW9uQ2FsbG91dEN1cnZlLCBkM0NhbGxvdXRFbGJvdyBhcyBhbm5vdGF0aW9uQ2FsbG91dEVsYm93LCBkM0NhbGxvdXRDaXJjbGUgYXMgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGUsIGQzQ2FsbG91dFJlY3QgYXMgYW5ub3RhdGlvbkNhbGxvdXRSZWN0LCBkM1hZVGhyZXNob2xkIGFzIGFubm90YXRpb25YWVRocmVzaG9sZCwgZDNCYWRnZSBhcyBhbm5vdGF0aW9uQmFkZ2UsIGN1c3RvbVR5cGUgYXMgYW5ub3RhdGlvbkN1c3RvbVR5cGUgfTtleHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Um9sbHVwTmV4dC5qcy5tYXBcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBkaXNwYXRjaH0gZnJvbSBcIi4vc3JjL2Rpc3BhdGNoXCI7XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge2V2ZW50LCBjdXN0b21FdmVudCwgc2VsZWN0LCBtb3VzZSwgdG91Y2h9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2RyYWcsIHt5ZXNkcmFnfSBmcm9tIFwiLi9ub2RyYWdcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgRHJhZ0V2ZW50IGZyb20gXCIuL2V2ZW50XCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcigpIHtcbiAgcmV0dXJuICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBldmVudC54LCB5OiBldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gZGVmYXVsdFN1YmplY3QsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgZ2VzdHVyZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxuICAgICAgYWN0aXZlID0gMCxcbiAgICAgIG1vdXNlZG93bngsXG4gICAgICBtb3VzZWRvd255LFxuICAgICAgbW91c2Vtb3ZpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiBkcmFnKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd25lZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuZHJhZ1wiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC5kcmFnIHRvdWNoY2FuY2VsLmRyYWdcIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnZXN0dXJlID0gYmVmb3Jlc3RhcnQoXCJtb3VzZVwiLCBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgbW91c2UsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCFnZXN0dXJlKSByZXR1cm47XG4gICAgc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLmRyYWdcIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLmRyYWdcIiwgbW91c2V1cHBlZCwgdHJ1ZSk7XG4gICAgbm9kcmFnKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBtb3VzZW1vdmluZyA9IGZhbHNlO1xuICAgIG1vdXNlZG93bnggPSBldmVudC5jbGllbnRYO1xuICAgIG1vdXNlZG93bnkgPSBldmVudC5jbGllbnRZO1xuICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoKSB7XG4gICAgbm9ldmVudCgpO1xuICAgIGlmICghbW91c2Vtb3ZpbmcpIHtcbiAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBtb3VzZWRvd254LCBkeSA9IGV2ZW50LmNsaWVudFkgLSBtb3VzZWRvd255O1xuICAgICAgbW91c2Vtb3ZpbmcgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgIH1cbiAgICBnZXN0dXJlcy5tb3VzZShcImRyYWdcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZXVwcGVkKCkge1xuICAgIHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKTtcbiAgICB5ZXNkcmFnKGV2ZW50LnZpZXcsIG1vdXNlbW92aW5nKTtcbiAgICBub2V2ZW50KCk7XG4gICAgZ2VzdHVyZXMubW91c2UoXCJlbmRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIGMgPSBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBiZWZvcmVzdGFydCh0b3VjaGVzW2ldLmlkZW50aWZpZXIsIGMsIHRvdWNoLCB0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vZXZlbnQoKTtcbiAgICAgICAgZ2VzdHVyZShcImRyYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbigpO1xuICAgICAgICBnZXN0dXJlKFwiZW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZXN0YXJ0KGlkLCBjb250YWluZXIsIHBvaW50LCB0aGF0LCBhcmdzKSB7XG4gICAgdmFyIHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgcywgZHgsIGR5LFxuICAgICAgICBzdWJsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29weSgpO1xuXG4gICAgaWYgKCFjdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIFwiYmVmb3Jlc3RhcnRcIiwgcywgaWQsIGFjdGl2ZSwgcFswXSwgcFsxXSwgMCwgMCwgc3VibGlzdGVuZXJzKSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKGV2ZW50LnN1YmplY3QgPSBzID0gc3ViamVjdC5hcHBseSh0aGF0LCBhcmdzKSkgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHggPSBzLnggLSBwWzBdIHx8IDA7XG4gICAgICBkeSA9IHMueSAtIHBbMV0gfHwgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pKSByZXR1cm47XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZ2VzdHVyZSh0eXBlKSB7XG4gICAgICB2YXIgcDAgPSBwLCBuO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOiBnZXN0dXJlc1tpZF0gPSBnZXN0dXJlLCBuID0gYWN0aXZlKys7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5kXCI6IGRlbGV0ZSBnZXN0dXJlc1tpZF0sIC0tYWN0aXZlOyAvLyBub2JyZWFrXG4gICAgICAgIGNhc2UgXCJkcmFnXCI6IHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgbiA9IGFjdGl2ZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIHR5cGUsIHMsIGlkLCBuLCBwWzBdICsgZHgsIHBbMV0gKyBkeSwgcFswXSAtIHAwWzBdLCBwWzFdIC0gcDBbMV0sIHN1Ymxpc3RlbmVycyksIHN1Ymxpc3RlbmVycy5hcHBseSwgc3VibGlzdGVuZXJzLCBbdHlwZSwgdGhhdCwgYXJnc10pO1xuICAgIH07XG4gIH1cblxuICBkcmFnLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogZmlsdGVyO1xuICB9O1xuXG4gIGRyYWcuY29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogY29udGFpbmVyO1xuICB9O1xuXG4gIGRyYWcuc3ViamVjdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdWJqZWN0ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBzdWJqZWN0O1xuICB9O1xuXG4gIGRyYWcudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgZHJhZy5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBkcmFnIDogdmFsdWU7XG4gIH07XG5cbiAgZHJhZy5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCBkcmFnKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIGRyYWc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEcmFnRXZlbnQodGFyZ2V0LCB0eXBlLCBzdWJqZWN0LCBpZCwgYWN0aXZlLCB4LCB5LCBkeCwgZHksIGRpc3BhdGNoKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICB0aGlzLmlkZW50aWZpZXIgPSBpZDtcbiAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZHggPSBkeDtcbiAgdGhpcy5keSA9IGR5O1xuICB0aGlzLl8gPSBkaXNwYXRjaDtcbn1cblxuRHJhZ0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcbn07XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgZHJhZ30gZnJvbSBcIi4vZHJhZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRyYWdEaXNhYmxlLCB5ZXNkcmFnIGFzIGRyYWdFbmFibGV9IGZyb20gXCIuL25vZHJhZ1wiO1xuIiwiaW1wb3J0IHtzZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBub2V2ZW50IGZyb20gXCIuL25vZXZlbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHllc2RyYWcodmlldywgbm9jbGljaykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIGlmIChub2NsaWNrKSB7XG4gICAgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcbiAgfVxuICBpZiAoXCJvbnNlbGVjdHN0YXJ0XCIgaW4gcm9vdCkge1xuICAgIHNlbGVjdGlvbi5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gcm9vdC5fX25vc2VsZWN0O1xuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XG4gIH1cbn1cbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJ2YXIgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3IsIGNjdyA9ICEhY2N3O1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi9jcmVhdG9yXCI7XG5pbXBvcnQgc2VsZWN0IGZyb20gXCIuL3NlbGVjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3QoY3JlYXRvcihuYW1lKS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2VcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdGV9IGZyb20gXCIuL2NyZWF0ZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0b3J9IGZyb20gXCIuL2NyZWF0b3JcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsb2NhbH0gZnJvbSBcIi4vbG9jYWxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtYXRjaGVyfSBmcm9tIFwiLi9tYXRjaGVyXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbW91c2V9IGZyb20gXCIuL21vdXNlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmFtZXNwYWNlfSBmcm9tIFwiLi9uYW1lc3BhY2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2VzfSBmcm9tIFwiLi9uYW1lc3BhY2VzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY2xpZW50UG9pbnR9IGZyb20gXCIuL3BvaW50XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0fSBmcm9tIFwiLi9zZWxlY3RcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZWxlY3RBbGx9IGZyb20gXCIuL3NlbGVjdEFsbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNlbGVjdGlvbn0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3J9IGZyb20gXCIuL3NlbGVjdG9yXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2VsZWN0b3JBbGx9IGZyb20gXCIuL3NlbGVjdG9yQWxsXCI7XG5leHBvcnQge3N0eWxlVmFsdWUgYXMgc3R5bGV9IGZyb20gXCIuL3NlbGVjdGlvbi9zdHlsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRvdWNofSBmcm9tIFwiLi90b3VjaFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRvdWNoZXN9IGZyb20gXCIuL3RvdWNoZXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB3aW5kb3d9IGZyb20gXCIuL3dpbmRvd1wiO1xuZXhwb3J0IHtldmVudCwgY3VzdG9tRXZlbnR9IGZyb20gXCIuL3NlbGVjdGlvbi9vblwiO1xuIiwidmFyIG5leHRJZCA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvY2FsKCkge1xuICByZXR1cm4gbmV3IExvY2FsO1xufVxuXG5mdW5jdGlvbiBMb2NhbCgpIHtcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcbn1cblxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTG9jYWwsXG4gIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICB3aGlsZSAoIShpZCBpbiBub2RlKSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gbm9kZVtpZF07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLl8gaW4gbm9kZSAmJiBkZWxldGUgbm9kZVt0aGlzLl9dO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudFwiO1xuaW1wb3J0IHBvaW50IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGV2ZW50ID0gc291cmNlRXZlbnQoKTtcbiAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSBldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICByZXR1cm4gcG9pbnQobm9kZSwgZXZlbnQpO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSBcIi4vbmFtZXNwYWNlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lO1xufVxuIiwiZXhwb3J0IHZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgZXZlbnQpIHtcbiAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG5cbiAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgfVxuXG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuLi9uYW1lc3BhY2VcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGUoZnVsbG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuIiwiZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUoZmFsc2UpLCB0aGlzLm5leHRTaWJsaW5nKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUodHJ1ZSksIHRoaXMubmV4dFNpYmxpbmcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnRcIjtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3dcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2VcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGxcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGFcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXJcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemVcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHlcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0clwiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWRcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0XCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbFwiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlclwiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnRcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bVwiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaFwiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvclwiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3RvclwiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgZW50ZXIgPSB0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiID8gb25lbnRlcihlbnRlcikgOiBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICBpZiAob251cGRhdGUgIT0gbnVsbCkgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaSA9IC0xO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwidmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG5leHBvcnQgdmFyIGV2ZW50ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50KSkge1xuICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApO1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzKSAmIDgpKSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQxKSB7XG4gICAgdmFyIGV2ZW50MCA9IGV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgIGV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXZlbnQ7XG4gIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICBldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXZlbnQgPSBldmVudDA7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuIiwiZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgc2VsZWN0b3JBbGwgZnJvbSBcIi4uL3NlbGVjdG9yQWxsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyArK3NpemU7IH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvd1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7ZXZlbnR9IGZyb20gXCIuL3NlbGVjdGlvbi9vblwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnQgPSBldmVudCwgc291cmNlO1xuICB3aGlsZSAoc291cmNlID0gY3VycmVudC5zb3VyY2VFdmVudCkgY3VycmVudCA9IHNvdXJjZTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnRcIjtcbmltcG9ydCBwb2ludCBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLmNoYW5nZWRUb3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIHRvdWNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudFwiO1xuaW1wb3J0IHBvaW50IGZyb20gXCIuL3BvaW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIHRvdWNoZXMpIHtcbiAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHBvaW50cyA9IG5ldyBBcnJheShuKTsgaSA8IG47ICsraSkge1xuICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYXJjfSBmcm9tIFwiLi9zcmMvYXJjXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXJlYX0gZnJvbSBcIi4vc3JjL2FyZWFcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsaW5lfSBmcm9tIFwiLi9zcmMvbGluZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZX0gZnJvbSBcIi4vc3JjL3BpZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhZGlhbEFyZWF9IGZyb20gXCIuL3NyYy9yYWRpYWxBcmVhXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFkaWFsTGluZX0gZnJvbSBcIi4vc3JjL3JhZGlhbExpbmVcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbCwgc3ltYm9sc30gZnJvbSBcIi4vc3JjL3N5bWJvbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbENpcmNsZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC9jaXJjbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xDcm9zc30gZnJvbSBcIi4vc3JjL3N5bWJvbC9jcm9zc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbERpYW1vbmR9IGZyb20gXCIuL3NyYy9zeW1ib2wvZGlhbW9uZFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFNxdWFyZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC9zcXVhcmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xTdGFyfSBmcm9tIFwiLi9zcmMvc3ltYm9sL3N0YXJcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xUcmlhbmdsZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC90cmlhbmdsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFd5ZX0gZnJvbSBcIi4vc3JjL3N5bWJvbC93eWVcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXNDbG9zZWR9IGZyb20gXCIuL3NyYy9jdXJ2ZS9iYXNpc0Nsb3NlZFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQmFzaXNPcGVufSBmcm9tIFwiLi9zcmMvY3VydmUvYmFzaXNPcGVuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCYXNpc30gZnJvbSBcIi4vc3JjL2N1cnZlL2Jhc2lzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCdW5kbGV9IGZyb20gXCIuL3NyYy9jdXJ2ZS9idW5kbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9zcmMvY3VydmUvY2FyZGluYWxDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsT3Blbn0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhcmRpbmFsT3BlblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2FyZGluYWx9IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXJkaW5hbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2F0bXVsbFJvbUNsb3NlZH0gZnJvbSBcIi4vc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb21PcGVufSBmcm9tIFwiLi9zcmMvY3VydmUvY2F0bXVsbFJvbU9wZW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb219IGZyb20gXCIuL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVMaW5lYXJDbG9zZWR9IGZyb20gXCIuL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUxpbmVhcn0gZnJvbSBcIi4vc3JjL2N1cnZlL2xpbmVhclwiO1xuZXhwb3J0IHttb25vdG9uZVggYXMgY3VydmVNb25vdG9uZVgsIG1vbm90b25lWSBhcyBjdXJ2ZU1vbm90b25lWX0gZnJvbSBcIi4vc3JjL2N1cnZlL21vbm90b25lXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVOYXR1cmFsfSBmcm9tIFwiLi9zcmMvY3VydmUvbmF0dXJhbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlU3RlcCwgc3RlcEFmdGVyIGFzIGN1cnZlU3RlcEFmdGVyLCBzdGVwQmVmb3JlIGFzIGN1cnZlU3RlcEJlZm9yZX0gZnJvbSBcIi4vc3JjL2N1cnZlL3N0ZXBcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrfSBmcm9tIFwiLi9zcmMvc3RhY2tcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldEV4cGFuZH0gZnJvbSBcIi4vc3JjL29mZnNldC9leHBhbmRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldE5vbmV9IGZyb20gXCIuL3NyYy9vZmZzZXQvbm9uZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT2Zmc2V0U2lsaG91ZXR0ZX0gZnJvbSBcIi4vc3JjL29mZnNldC9zaWxob3VldHRlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXRXaWdnbGV9IGZyb20gXCIuL3NyYy9vZmZzZXQvd2lnZ2xlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlckFzY2VuZGluZ30gZnJvbSBcIi4vc3JjL29yZGVyL2FzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJEZXNjZW5kaW5nfSBmcm9tIFwiLi9zcmMvb3JkZXIvZGVzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJJbnNpZGVPdXR9IGZyb20gXCIuL3NyYy9vcmRlci9pbnNpZGVPdXRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyTm9uZX0gZnJvbSBcIi4vc3JjL29yZGVyL25vbmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyUmV2ZXJzZX0gZnJvbSBcIi4vc3JjL29yZGVyL3JldmVyc2VcIjtcbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IHtlcHNpbG9uLCBwaSwgaGFsZlBpLCB0YXV9IGZyb20gXCIuL21hdGhcIjtcblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gKHkzMiAqIHgxMCAtIHgzMiAqIHkxMCk7XG4gIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xufVxuXG4vLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtTGluZUludGVyc2VjdGlvbi5odG1sXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICB2YXIgeDAxID0geDAgLSB4MSxcbiAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIE1hdGguc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLFxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLFxuICAgICAgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxuICAgICAgZHgwID0gY3gwIC0geDAwLFxuICAgICAgZHkwID0gY3kwIC0geTAwLFxuICAgICAgZHgxID0gY3gxIC0geDAwLFxuICAgICAgZHkxID0gY3kxIC0geTAwO1xuXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcblxuICByZXR1cm4ge1xuICAgIGN4OiBjeDAsXG4gICAgY3k6IGN5MCxcbiAgICB4MDE6IC1veCxcbiAgICB5MDE6IC1veSxcbiAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcbiAgICB5MTE6IGN5MCAqIChyMSAvIHIgLSAxKVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gY29uc3RhbnQoMCksXG4gICAgICBwYWRSYWRpdXMgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGFyY0VuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IE1hdGguYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgIGVsc2UgaWYgKGRhID4gdGF1IC0gZXBzaWxvbikge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBNYXRoLmNvcyhhMCksIHIxICogTWF0aC5zaW4oYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogTWF0aC5jb3MoYTEpLCByMCAqIE1hdGguc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogTWF0aC5zcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBNYXRoLm1pbihNYXRoLmFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBNYXRoLnNpbihhcCkpLFxuICAgICAgICAgICAgcDEgPSBhc2luKHJwIC8gcjEgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbikgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICBlbHNlIGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MDEgPSByMSAqIE1hdGguY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBNYXRoLnNpbihhMDEpLFxuICAgICAgICAgIHgxMCA9IHIwICogTWF0aC5jb3MoYTEwKSxcbiAgICAgICAgICB5MTAgPSByMCAqIE1hdGguc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogTWF0aC5jb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogTWF0aC5zaW4oYTExKSxcbiAgICAgICAgICAgIHgwMCA9IHIwICogTWF0aC5jb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogTWF0aC5zaW4oYTAwKTtcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkpIHtcbiAgICAgICAgICB2YXIgb2MgPSBkYTAgPiBlcHNpbG9uID8gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSA6IFt4MTAsIHkxMF0sXG4gICAgICAgICAgICAgIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGJ4ID0geDExIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGtjID0gMSAvIE1hdGguc2luKE1hdGguYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgbGMgPSBNYXRoLnNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IE1hdGgubWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gTWF0aC5taW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBNYXRoLmF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIE1hdGguYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgTWF0aC5hdGFuMih0MS55MTEsIHQxLngxMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgTWF0aC5hdGFuMih0MC55MDEsIHQwLngwMSksIE1hdGguYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBNYXRoLmF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIE1hdGguYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBNYXRoLmF0YW4yKHQxLnkxMSwgdDEueDExKSwgTWF0aC5hdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgIHJldHVybiBbTWF0aC5jb3MoYSkgKiByLCBNYXRoLnNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB4MCA9IHBvaW50WCxcbiAgICAgIHgxID0gbnVsbCxcbiAgICAgIHkwID0gY29uc3RhbnQoMCksXG4gICAgICB5MSA9IHBvaW50WSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHtcbiAgICAgICAgICBqID0gaTtcbiAgICAgICAgICBvdXRwdXQuYXJlYVN0YXJ0KCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgweltrXSwgeTB6W2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQuYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIHtcbiAgICAgICAgeDB6W2ldID0gK3gwKGQsIGksIGRhdGEpLCB5MHpbaV0gPSAreTAoZCwgaSwgZGF0YSk7XG4gICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICByZXR1cm4gbGluZSgpLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpLmNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgxO1xuICB9O1xuXG4gIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTE7XG4gIH07XG5cbiAgYXJlYS5saW5lWDAgPVxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTApO1xuICB9O1xuXG4gIGFyZWEubGluZVkxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gIH07XG5cbiAgYXJlYS5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGFyZWEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBhcmVhLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJlYTtcbn1cbiIsImV4cG9ydCB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb25zdGFudCgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMyxcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyAyICogdGhhdC5feDEpIC8gMyxcbiAgICAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXG4gICAgKHRoYXQuX3kwICsgNCAqIHRoYXQuX3kxICsgeSkgLyA2XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpcy5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2Jhc2lzXCI7XG5cbmZ1bmN0aW9uIEJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MiA9IHgsIHRoaXMuX3kyID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5OyB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNDbG9zZWQoY29udGV4dCk7XG59XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59XG4iLCJpbXBvcnQge0Jhc2lzfSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGJldGEpIHtcblxuICBmdW5jdGlvbiBidW5kbGUoY29udGV4dCkge1xuICAgIHJldHVybiBiZXRhID09PSAxID8gbmV3IEJhc2lzKGNvbnRleHQpIDogbmV3IEJ1bmRsZShjb250ZXh0LCBiZXRhKTtcbiAgfVxuXG4gIGJ1bmRsZS5iZXRhID0gZnVuY3Rpb24oYmV0YSkge1xuICAgIHJldHVybiBjdXN0b20oK2JldGEpO1xuICB9O1xuXG4gIHJldHVybiBidW5kbGU7XG59KSgwLjg1KTtcbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhcmRpbmFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHtDYXJkaW5hbH0gZnJvbSBcIi4vY2FyZGluYWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdmFyIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgeDIgPSB0aGF0Ll94MixcbiAgICAgIHkyID0gdGhhdC5feTI7XG5cbiAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gIH1cblxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG59XG5cbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9jYXJkaW5hbENsb3NlZFwiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhdG11bGxSb21cIjtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsT3Blbn0gZnJvbSBcIi4vY2FyZGluYWxPcGVuXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcbiIsImZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcFwiO1xuXG5mdW5jdGlvbiBMaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZWxzZSB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyQ2xvc2VkKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBzbG9wZXMgb2YgdGhlIHRhbmdlbnRzIChIZXJtaXRlLXR5cGUgaW50ZXJwb2xhdGlvbikgYmFzZWQgb25cbi8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXG4vLyBJbnRlcnBvbGF0aW9uIGluIE9uZSBEaW1lbnNpb24uIEFzdHJvbm9teSBhbmQgQXN0cm9waHlzaWNzLCBWb2wuIDIzOSwgTk8uXG4vLyBOT1YoSUkpLCBQLiA0NDMsIDE5OTAuXG5mdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XG4gIHZhciBoMCA9IHRoYXQuX3gxIC0gdGhhdC5feDAsXG4gICAgICBoMSA9IHgyIC0gdGhhdC5feDEsXG4gICAgICBzMCA9ICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIChoMCB8fCBoMSA8IDAgJiYgLTApLFxuICAgICAgczEgPSAoeTIgLSB0aGF0Ll95MSkgLyAoaDEgfHwgaDAgPCAwICYmIC0wKSxcbiAgICAgIHAgPSAoczAgKiBoMSArIHMxICogaDApIC8gKGgwICsgaDEpO1xuICByZXR1cm4gKHNpZ24oczApICsgc2lnbihzMSkpICogTWF0aC5taW4oTWF0aC5hYnMoczApLCBNYXRoLmFicyhzMSksIDAuNSAqIE1hdGguYWJzKHApKSB8fCAwO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBvbmUtc2lkZWQgc2xvcGUuXG5mdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xuICB2YXIgaCA9IHRoYXQuX3gxIC0gdGhhdC5feDA7XG4gIHJldHVybiBoID8gKDMgKiAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyBoIC0gdCkgLyAyIDogdDtcbn1cblxuLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lI1JlcHJlc2VudGF0aW9uc1xuLy8gXCJ5b3UgY2FuIGV4cHJlc3MgY3ViaWMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGluIHRlcm1zIG9mIGN1YmljIELDqXppZXIgY3VydmVzXG4vLyB3aXRoIHJlc3BlY3QgdG8gdGhlIGZvdXIgdmFsdWVzIHAwLCBwMCArIG0wIC8gMywgcDEgLSBtMSAvIDMsIHAxXCIuXG5mdW5jdGlvbiBwb2ludCh0aGF0LCB0MCwgdDEpIHtcbiAgdmFyIHgwID0gdGhhdC5feDAsXG4gICAgICB5MCA9IHRoYXQuX3kwLFxuICAgICAgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICBkeCA9ICh4MSAtIHgwKSAvIDM7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk1vbm90b25lWC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9XG4gICAgdGhpcy5fdDAgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0MSA9IE5hTjtcblxuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBwb2ludCh0aGlzLCBzbG9wZTIodGhpcywgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpLCB0MSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICB0aGlzLl90MCA9IHQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWShjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBuZXcgUmVmbGVjdENvbnRleHQoY29udGV4dCk7XG59XG5cbihNb25vdG9uZVkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb25vdG9uZVgucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIE1vbm90b25lWC5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLCB5LCB4KTtcbn07XG5cbmZ1bmN0aW9uIFJlZmxlY3RDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubW92ZVRvKHksIHgpOyB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh5MSwgeDEsIHkyLCB4MiwgeSwgeCk7IH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbm90b25lWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVZKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gTmF0dXJhbChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5OYXR1cmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW107XG4gICAgdGhpcy5feSA9IFtdO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICBuID0geC5sZW5ndGg7XG5cbiAgICBpZiAobikge1xuICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHhbMF0sIHlbMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzFdLCB5WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBweCA9IGNvbnRyb2xQb2ludHMoeCksXG4gICAgICAgICAgICBweSA9IGNvbnRyb2xQb2ludHMoeSk7XG4gICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAxOyBpMSA8IG47ICsraTAsICsraTEpIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8ocHhbMF1baTBdLCBweVswXVtpMF0sIHB4WzFdW2kwXSwgcHlbMV1baTBdLCB4W2kxXSwgeVtpMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgbiA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgIHRoaXMuX3kucHVzaCgreSk7XG4gIH1cbn07XG5cbi8vIFNlZSBodHRwczovL3d3dy5wYXJ0aWNsZWluY2VsbC5jb20vMjAxMi9iZXppZXItc3BsaW5lcy8gZm9yIGRlcml2YXRpb24uXG5mdW5jdGlvbiBjb250cm9sUG9pbnRzKHgpIHtcbiAgdmFyIGksXG4gICAgICBuID0geC5sZW5ndGggLSAxLFxuICAgICAgbSxcbiAgICAgIGEgPSBuZXcgQXJyYXkobiksXG4gICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgciA9IG5ldyBBcnJheShuKTtcbiAgYVswXSA9IDAsIGJbMF0gPSAyLCByWzBdID0geFswXSArIDIgKiB4WzFdO1xuICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7ICsraSkgYVtpXSA9IDEsIGJbaV0gPSA0LCByW2ldID0gNCAqIHhbaV0gKyAyICogeFtpICsgMV07XG4gIGFbbiAtIDFdID0gMiwgYltuIC0gMV0gPSA3LCByW24gLSAxXSA9IDggKiB4W24gLSAxXSArIHhbbl07XG4gIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIG0gPSBhW2ldIC8gYltpIC0gMV0sIGJbaV0gLT0gbSwgcltpXSAtPSBtICogcltpIC0gMV07XG4gIGFbbiAtIDFdID0gcltuIC0gMV0gLyBiW24gLSAxXTtcbiAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSBhW2ldID0gKHJbaV0gLSBhW2kgKyAxXSkgLyBiW2ldO1xuICBiW24gLSAxXSA9ICh4W25dICsgYVtuIC0gMV0pIC8gMjtcbiAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyArK2kpIGJbaV0gPSAyICogeFtpICsgMV0gLSBhW2kgKyAxXTtcbiAgcmV0dXJuIFthLCBiXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IE5hdHVyYWwoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vbGluZWFyXCI7XG5cbmV4cG9ydCB2YXIgY3VydmVSYWRpYWxMaW5lYXIgPSBjdXJ2ZVJhZGlhbChjdXJ2ZUxpbmVhcik7XG5cbmZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xufVxuXG5SYWRpYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuXG4gIGZ1bmN0aW9uIHJhZGlhbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICB9XG5cbiAgcmFkaWFsLl9jdXJ2ZSA9IGN1cnZlO1xuXG4gIHJldHVybiByYWRpYWw7XG59XG4iLCJmdW5jdGlvbiBTdGVwKGNvbnRleHQsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX3QgPSB0O1xufVxuXG5TdGVwLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICgwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiB0aGlzLl9wb2ludCA9PT0gMikgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSk7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGlmICh0aGlzLl9saW5lID49IDApIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fdCA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHgxID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyB4ICogdGhpcy5fdDtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgdGhpcy5feSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94ID0geCwgdGhpcy5feSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDAuNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwQmVmb3JlKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEFmdGVyKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIHJldHVybiBkO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gcG9pbnRYLFxuICAgICAgeSA9IHBvaW50WSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIG91dHB1dC5wb2ludCgreChkLCBpLCBkYXRhKSwgK3koZCwgaSwgZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHg7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5O1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuIiwiZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciB0YXUgPSAyICogcGk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHt9XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIG4sIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aCwgeTsgaiA8IG07ICsraikge1xuICAgIGZvciAoeSA9IGkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIGlmICh5KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzZXJpZXNbaV1bal1bMV0gLz0geTtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMSkpIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDEsIHMwLCBzMSA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBzMCA9IHMxLCBzMSA9IHNlcmllc1tvcmRlcltpXV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIHMxW2pdWzFdICs9IHMxW2pdWzBdID0gaXNOYU4oczBbal1bMV0pID8gczBbal1bMF0gOiBzMFtqXVsxXTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaiA9IDAsIHMwID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMwLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCB5ID0gMDsgaSA8IG47ICsraSkgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcbiAgICBzMFtqXVsxXSArPSBzMFtqXVswXSA9IC15IC8gMjtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSB8fCAhKChtID0gKHMwID0gc2VyaWVzW29yZGVyWzBdXSkubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgczEgPSAwLCBzMiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBzaSA9IHNlcmllc1tvcmRlcltpXV0sXG4gICAgICAgICAgc2lqMCA9IHNpW2pdWzFdIHx8IDAsXG4gICAgICAgICAgc2lqMSA9IHNpW2ogLSAxXVsxXSB8fCAwLFxuICAgICAgICAgIHMzID0gKHNpajAgLSBzaWoxKSAvIDI7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7ICsraykge1xuICAgICAgICB2YXIgc2sgPSBzZXJpZXNbb3JkZXJba11dLFxuICAgICAgICAgICAgc2tqMCA9IHNrW2pdWzFdIHx8IDAsXG4gICAgICAgICAgICBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XG4gICAgICAgIHMzICs9IHNrajAgLSBza2oxO1xuICAgICAgfVxuICAgICAgczEgKz0gc2lqMCwgczIgKz0gczMgKiBzaWowO1xuICAgIH1cbiAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICBpZiAoczEpIHkgLT0gczIgLyBzMTtcbiAgfVxuICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBzdW1zID0gc2VyaWVzLm1hcChzdW0pO1xuICByZXR1cm4gbm9uZShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1thXSAtIHN1bXNbYl07IH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VtKHNlcmllcykge1xuICB2YXIgcyA9IDAsIGkgPSAtMSwgbiA9IHNlcmllcy5sZW5ndGgsIHY7XG4gIHdoaWxlICgrK2kgPCBuKSBpZiAodiA9ICtzZXJpZXNbaV1bMV0pIHMgKz0gdjtcbiAgcmV0dXJuIHM7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIGFzY2VuZGluZyhzZXJpZXMpLnJldmVyc2UoKTtcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcbmltcG9ydCB7c3VtfSBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgc3VtcyA9IHNlcmllcy5tYXAoc3VtKSxcbiAgICAgIG9yZGVyID0gbm9uZShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1tiXSAtIHN1bXNbYV07IH0pLFxuICAgICAgdG9wID0gMCxcbiAgICAgIGJvdHRvbSA9IDAsXG4gICAgICB0b3BzID0gW10sXG4gICAgICBib3R0b21zID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGogPSBvcmRlcltpXTtcbiAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgIHRvcHMucHVzaChqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICBib3R0b21zLnB1c2goaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvdHRvbXMucmV2ZXJzZSgpLmNvbmNhdCh0b3BzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkobik7XG4gIHdoaWxlICgtLW4gPj0gMCkgb1tuXSA9IG47XG4gIHJldHVybiBvO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIG5vbmUoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmdcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuaW1wb3J0IHt0YXV9IGZyb20gXCIuL21hdGhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsXG4gICAgICBzb3J0ID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSxcbiAgICAgIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSxcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQoMCk7XG5cbiAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBpbmRleCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYXJjcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYTAgPSArc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBkYSA9IE1hdGgubWluKHRhdSwgTWF0aC5tYXgoLXRhdSwgZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGEwKSksXG4gICAgICAgIGExLFxuICAgICAgICBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICB2O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh2ID0gYXJjc1tpbmRleFtpXSA9IGldID0gK3ZhbHVlKGRhdGFbaV0sIGksIGRhdGEpKSA+IDApIHtcbiAgICAgICAgc3VtICs9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWxseSBzb3J0IHRoZSBhcmNzIGJ5IHByZXZpb3VzbHktY29tcHV0ZWQgdmFsdWVzIG9yIGJ5IGRhdGEuXG4gICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0VmFsdWVzKGFyY3NbaV0sIGFyY3Nbal0pOyB9KTtcbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhcmNzISBUaGV5IGFyZSBzdG9yZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEncyBvcmRlci5cbiAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcbiAgICAgIGogPSBpbmRleFtpXSwgdiA9IGFyY3Nbal0sIGExID0gYTAgKyAodiA+IDAgPyB2ICogayA6IDApICsgcGEsIGFyY3Nbal0gPSB7XG4gICAgICAgIGRhdGE6IGRhdGFbal0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyY3M7XG4gIH1cblxuICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHZhbHVlO1xuICB9O1xuXG4gIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRWYWx1ZXMgPSBfLCBzb3J0ID0gbnVsbCwgcGllKSA6IHNvcnRWYWx1ZXM7XG4gIH07XG5cbiAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNvcnRWYWx1ZXMgPSBudWxsLCBwaWUpIDogc29ydDtcbiAgfTtcblxuICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBwYWRBbmdsZTtcbiAgfTtcblxuICByZXR1cm4gcGllO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWxcIjtcbmltcG9ydCBhcmVhIGZyb20gXCIuL2FyZWFcIjtcbmltcG9ydCB7cmFkaWFsTGluZX0gZnJvbSBcIi4vcmFkaWFsTGluZVwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgYSA9IGFyZWEoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhciksXG4gICAgICBjID0gYS5jdXJ2ZSxcbiAgICAgIHgwID0gYS5saW5lWDAsXG4gICAgICB4MSA9IGEubGluZVgxLFxuICAgICAgeTAgPSBhLmxpbmVZMCxcbiAgICAgIHkxID0gYS5saW5lWTE7XG5cbiAgYS5hbmdsZSA9IGEueCwgZGVsZXRlIGEueDtcbiAgYS5zdGFydEFuZ2xlID0gYS54MCwgZGVsZXRlIGEueDA7XG4gIGEuZW5kQW5nbGUgPSBhLngxLCBkZWxldGUgYS54MTtcbiAgYS5yYWRpdXMgPSBhLnksIGRlbGV0ZSBhLnk7XG4gIGEuaW5uZXJSYWRpdXMgPSBhLnkwLCBkZWxldGUgYS55MDtcbiAgYS5vdXRlclJhZGl1cyA9IGEueTEsIGRlbGV0ZSBhLnkxO1xuICBhLmxpbmVTdGFydEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHgwKCkpOyB9LCBkZWxldGUgYS5saW5lWDA7XG4gIGEubGluZUVuZEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHgxKCkpOyB9LCBkZWxldGUgYS5saW5lWDE7XG4gIGEubGluZUlubmVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHkwKCkpOyB9LCBkZWxldGUgYS5saW5lWTA7XG4gIGEubGluZU91dGVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiByYWRpYWxMaW5lKHkxKCkpOyB9LCBkZWxldGUgYS5saW5lWTE7XG5cbiAgYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gYTtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWxcIjtcbmltcG9ydCBsaW5lIGZyb20gXCIuL2xpbmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbExpbmUobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiByYWRpYWxMaW5lKGxpbmUoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhcikpO1xufVxuIiwiaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IG9mZnNldE5vbmUgZnJvbSBcIi4vb2Zmc2V0L25vbmVcIjtcbmltcG9ydCBvcmRlck5vbmUgZnJvbSBcIi4vb3JkZXIvbm9uZVwiO1xuXG5mdW5jdGlvbiBzdGFja1ZhbHVlKGQsIGtleSkge1xuICByZXR1cm4gZFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBjb25zdGFudChbXSksXG4gICAgICBvcmRlciA9IG9yZGVyTm9uZSxcbiAgICAgIG9mZnNldCA9IG9mZnNldE5vbmUsXG4gICAgICB2YWx1ZSA9IHN0YWNrVmFsdWU7XG5cbiAgZnVuY3Rpb24gc3RhY2soZGF0YSkge1xuICAgIHZhciBreiA9IGtleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgaSxcbiAgICAgICAgbSA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBuID0ga3oubGVuZ3RoLFxuICAgICAgICBzeiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgb3o7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmb3IgKHZhciBraSA9IGt6W2ldLCBzaSA9IHN6W2ldID0gbmV3IEFycmF5KG0pLCBqID0gMCwgc2lqOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHNpW2pdID0gc2lqID0gWzAsICt2YWx1ZShkYXRhW2pdLCBraSwgaiwgZGF0YSldO1xuICAgICAgICBzaWouZGF0YSA9IGRhdGFbal07XG4gICAgICB9XG4gICAgICBzaS5rZXkgPSBraTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBveiA9IG9yZGVyKHN6KTsgaSA8IG47ICsraSkge1xuICAgICAgc3pbb3pbaV1dLmluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBvZmZzZXQoc3osIG96KTtcbiAgICByZXR1cm4gc3o7XG4gIH1cblxuICBzdGFjay5rZXlzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGtleXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBrZXlzO1xuICB9O1xuXG4gIHN0YWNrLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN0YWNrKSA6IHZhbHVlO1xuICB9O1xuXG4gIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gXyA9PSBudWxsID8gb3JkZXJOb25lIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDogb3JkZXI7XG4gIH07XG5cbiAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG9mZnNldE5vbmUgOiBfLCBzdGFjaykgOiBvZmZzZXQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNpcmNsZSBmcm9tIFwiLi9zeW1ib2wvY2lyY2xlXCI7XG5pbXBvcnQgY3Jvc3MgZnJvbSBcIi4vc3ltYm9sL2Nyb3NzXCI7XG5pbXBvcnQgZGlhbW9uZCBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZFwiO1xuaW1wb3J0IHN0YXIgZnJvbSBcIi4vc3ltYm9sL3N0YXJcIjtcbmltcG9ydCBzcXVhcmUgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZVwiO1xuaW1wb3J0IHRyaWFuZ2xlIGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZVwiO1xuaW1wb3J0IHd5ZSBmcm9tIFwiLi9zeW1ib2wvd3llXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcblxuZXhwb3J0IHZhciBzeW1ib2xzID0gW1xuICBjaXJjbGUsXG4gIGNyb3NzLFxuICBkaWFtb25kLFxuICBzcXVhcmUsXG4gIHN0YXIsXG4gIHRyaWFuZ2xlLFxuICB3eWVcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGNvbnN0YW50KGNpcmNsZSksXG4gICAgICBzaXplID0gY29uc3RhbnQoNjQpLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuICAgIHR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS5kcmF3KGNvbnRleHQsICtzaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHlwZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHN5bWJvbCkgOiB0eXBlO1xuICB9O1xuXG4gIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNpemUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3ltYm9sKSA6IHNpemU7XG4gIH07XG5cbiAgc3ltYm9sLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gc3ltYm9sO1xufVxuIiwiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyksXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLFxuICAgICAgICB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB3ID0gTWF0aC5zcXJ0KHNpemUpLFxuICAgICAgICB4ID0gLXcgLyAyO1xuICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgfVxufTtcbiIsImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGhcIjtcblxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcbiAgICBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLFxuICAgIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsXG4gICAga3kgPSAtTWF0aC5jb3ModGF1IC8gMTApICoga3I7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCB5ICogMik7XG4gICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgYyA9IC0wLjUsXG4gICAgcyA9IE1hdGguc3FydCgzKSAvIDIsXG4gICAgayA9IDEgLyBNYXRoLnNxcnQoMTIpLFxuICAgIGEgPSAoayAvIDIgKyAxKSAqIDM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBhKSxcbiAgICAgICAgeDAgPSByIC8gMixcbiAgICAgICAgeTAgPSByICogayxcbiAgICAgICAgeDEgPSB4MCxcbiAgICAgICAgeTEgPSByICogayArIHIsXG4gICAgICAgIHgyID0gLXgxLFxuICAgICAgICB5MiA9IHkxO1xuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMgKiB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgKyBzICogeTEsIGMgKiB5MSAtIHMgKiB4MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5vcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cbiAgY3NzICs9IG9iai5jc3M7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH1cblxuICAvLyBGb3Igb2xkIElFXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCJpbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIgdCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLCBrZXksXG4gICAgICB4MCA9IEluZmluaXR5LCB5MCA9IHgwLCB4MSA9IC14MCwgeTEgPSAteDA7XG5cbiAgZnVuY3Rpb24gYmJveFBvaW50KHApIHtcbiAgICBwID0gdChwKTtcbiAgICBpZiAocFswXSA8IHgwKSB4MCA9IHBbMF07XG4gICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICBpZiAocFsxXSA+IHkxKSB5MSA9IHBbMV07XG4gIH1cblxuICBmdW5jdGlvbiBiYm94R2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG8uZ2VvbWV0cmllcy5mb3JFYWNoKGJib3hHZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGJib3hQb2ludChvLmNvb3JkaW5hdGVzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvLmNvb3JkaW5hdGVzLmZvckVhY2goYmJveFBvaW50KTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcmMubGVuZ3RoLCBwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwID0gdChhcmNbaV0sIGkpO1xuICAgICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgICAgaWYgKHBbMV0gPCB5MCkgeTAgPSBwWzFdO1xuICAgICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChrZXkgaW4gdG9wb2xvZ3kub2JqZWN0cykge1xuICAgIGJib3hHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIFt4MCwgeTAsIHgxLCB5MV07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCB4KSB7XG4gIHZhciBsbyA9IDAsIGhpID0gYS5sZW5ndGg7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKGFbbWlkXSA8IHgpIGxvID0gbWlkICsgMTtcbiAgICBlbHNlIGhpID0gbWlkO1xuICB9XG4gIHJldHVybiBsbztcbn1cbiIsImltcG9ydCByZXZlcnNlIGZyb20gXCIuL3JldmVyc2UuanNcIjtcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCBvKSB7XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgbyA9IHRvcG9sb2d5Lm9iamVjdHNbb107XG4gIHJldHVybiBvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCJcbiAgICAgID8ge3R5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIiwgZmVhdHVyZXM6IG8uZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24obykgeyByZXR1cm4gZmVhdHVyZSh0b3BvbG9neSwgbyk7IH0pfVxuICAgICAgOiBmZWF0dXJlKHRvcG9sb2d5LCBvKTtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZSh0b3BvbG9neSwgbykge1xuICB2YXIgaWQgPSBvLmlkLFxuICAgICAgYmJveCA9IG8uYmJveCxcbiAgICAgIHByb3BlcnRpZXMgPSBvLnByb3BlcnRpZXMgPT0gbnVsbCA/IHt9IDogby5wcm9wZXJ0aWVzLFxuICAgICAgZ2VvbWV0cnkgPSBvYmplY3QodG9wb2xvZ3ksIG8pO1xuICByZXR1cm4gaWQgPT0gbnVsbCAmJiBiYm94ID09IG51bGwgPyB7dHlwZTogXCJGZWF0dXJlXCIsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDogYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDoge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIGJib3g6IGJib3gsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIHRyYW5zZm9ybVBvaW50ID0gdHJhbnNmb3JtKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICBmdW5jdGlvbiBhcmMoaSwgcG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGgpIHBvaW50cy5wb3AoKTtcbiAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGg7IGsgPCBuOyArK2spIHtcbiAgICAgIHBvaW50cy5wdXNoKHRyYW5zZm9ybVBvaW50KGFba10sIGspKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludChwKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBvaW50KHApO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIGFyYyhhcmNzW2ldLCBwb2ludHMpO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0pOyAvLyBUaGlzIG1heSBoYXBwZW4gaWYgYW4gYXJjIGhhcyBvbmx5IHR3byBwb2ludHMuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICB2YXIgdHlwZSA9IG8udHlwZSwgY29vcmRpbmF0ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IHJldHVybiB7dHlwZTogdHlwZSwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9O1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGNvb3JkaW5hdGVzID0gcG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogY29vcmRpbmF0ZXMgPSBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBsaW5lKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAobGluZSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBwb2x5Z29uKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAocG9seWdvbik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogdHlwZSwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeShvKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYmJveH0gZnJvbSBcIi4vYmJveC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZlYXR1cmV9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXNoLCBtZXNoQXJjc30gZnJvbSBcIi4vbWVzaC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lcmdlLCBtZXJnZUFyY3N9IGZyb20gXCIuL21lcmdlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmVpZ2hib3JzfSBmcm9tIFwiLi9uZWlnaGJvcnMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBxdWFudGl6ZX0gZnJvbSBcIi4vcXVhbnRpemUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHVudHJhbnNmb3JtfSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmZ1bmN0aW9uIHBsYW5hclJpbmdBcmVhKHJpbmcpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IHJpbmcubGVuZ3RoLCBhLCBiID0gcmluZ1tuIC0gMV0sIGFyZWEgPSAwO1xuICB3aGlsZSAoKytpIDwgbikgYSA9IGIsIGIgPSByaW5nW2ldLCBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIHJldHVybiBNYXRoLmFicyhhcmVhKTsgLy8gTm90ZTogZG91YmxlZCBhcmVhIVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXJnZUFyY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICBncm91cHMgPSBbXTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogZXh0cmFjdChvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogby5hcmNzLmZvckVhY2goZXh0cmFjdCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QocG9seWdvbikge1xuICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgIChwb2x5Z29uc0J5QXJjW2FyYyA9IGFyYyA8IDAgPyB+YXJjIDogYXJjXSB8fCAocG9seWdvbnNCeUFyY1thcmNdID0gW10pKS5wdXNoKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWEocmluZykge1xuICAgIHJldHVybiBwbGFuYXJSaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pO1xuICB9XG5cbiAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICBncm91cC5wdXNoKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBhcmNzOiBncm91cHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICB2YXIgYXJjcyA9IFtdLCBuO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBleHRlcmlvciAodW5pcXVlKSBhcmNzLlxuICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgYXJjcyA9IHN0aXRjaCh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgcmluZyBpcyByZXR1cm5lZCxcbiAgICAgIC8vIGF0IG1vc3Qgb25lIG9mIHRoZXNlIHJpbmdzIGNhbiBiZSB0aGUgZXh0ZXJpb3I7XG4gICAgICAvLyBjaG9vc2UgdGhlIG9uZSB3aXRoIHRoZSBncmVhdGVzdCBhYnNvbHV0ZSBhcmVhLlxuICAgICAgaWYgKChuID0gYXJjcy5sZW5ndGgpID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgayA9IGFyZWEoYXJjc1swXSksIGtpLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKChraSA9IGFyZWEoYXJjc1tpXSkpID4gaykge1xuICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdCwgayA9IGtpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubGVuZ3RoID4gMDtcbiAgICB9KVxuICB9O1xufVxuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5KSB7XG4gIHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lc2hBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVzaEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKSB7XG4gIHZhciBhcmNzLCBpLCBuO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGFyY3MgPSBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpO1xuICBlbHNlIGZvciAoaSA9IDAsIGFyY3MgPSBuZXcgQXJyYXkobiA9IHRvcG9sb2d5LmFyY3MubGVuZ3RoKTsgaSA8IG47ICsraSkgYXJjc1tpXSA9IGk7XG4gIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoKHRvcG9sb2d5LCBhcmNzKX07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcyA9IFtdLFxuICAgICAgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgZ2VvbTtcblxuICBmdW5jdGlvbiBleHRyYWN0MChpKSB7XG4gICAgdmFyIGogPSBpIDwgMCA/IH5pIDogaTtcbiAgICAoZ2VvbXNCeUFyY1tqXSB8fCAoZ2VvbXNCeUFyY1tqXSA9IFtdKSkucHVzaCh7aTogaSwgZzogZ2VvbX0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDEoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MihhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QzKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoZ2VvbSA9IG8sIG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogZXh0cmFjdDEoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6IGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3QyKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBleHRyYWN0MyhvLmFyY3MpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBnZW9tZXRyeShvYmplY3QpO1xuXG4gIGdlb21zQnlBcmMuZm9yRWFjaChmaWx0ZXIgPT0gbnVsbFxuICAgICAgPyBmdW5jdGlvbihnZW9tcykgeyBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH1cbiAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcblxuICByZXR1cm4gYXJjcztcbn1cbiIsImltcG9ydCBiaXNlY3QgZnJvbSBcIi4vYmlzZWN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgdmFyIGluZGV4ZXNCeUFyYyA9IHt9LCAvLyBhcmMgaW5kZXggLT4gYXJyYXkgb2Ygb2JqZWN0IGluZGV4ZXNcbiAgICAgIG5laWdoYm9ycyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoYSA8IDApIGEgPSB+YTtcbiAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgaWYgKG8pIG8ucHVzaChpKTtcbiAgICAgIGVsc2UgaW5kZXhlc0J5QXJjW2FdID0gW2ldO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9seWdvbihhcmNzLCBpKSB7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobywgaSkge1xuICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcywgaSk7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBwb2x5Z29uLFxuICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzLCBpKSB7IGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgcG9seWdvbihhcmMsIGkpOyB9KTsgfVxuICB9O1xuXG4gIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgZm9yICh2YXIgaSBpbiBpbmRleGVzQnlBcmMpIHtcbiAgICBmb3IgKHZhciBpbmRleGVzID0gaW5kZXhlc0J5QXJjW2ldLCBtID0gaW5kZXhlcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgdmFyIGlqID0gaW5kZXhlc1tqXSwgaWsgPSBpbmRleGVzW2tdLCBuO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWpdKVtpID0gYmlzZWN0KG4sIGlrKV0gIT09IGlrKSBuLnNwbGljZShpLCAwLCBpayk7XG4gICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVpZ2hib3JzO1xufVxuIiwiaW1wb3J0IGJib3ggZnJvbSBcIi4vYmJveC5qc1wiO1xuaW1wb3J0IHVudHJhbnNmb3JtIGZyb20gXCIuL3VudHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBxdWFudGl6ZWRcIik7XG5cbiAgaWYgKCF0cmFuc2Zvcm0gfHwgIXRyYW5zZm9ybS5zY2FsZSkge1xuICAgIGlmICghKChuID0gTWF0aC5mbG9vcih0cmFuc2Zvcm0pKSA+PSAyKSkgdGhyb3cgbmV3IEVycm9yKFwibiBtdXN0IGJlIOKJpTJcIik7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveCB8fCBiYm94KHRvcG9sb2d5KTtcbiAgICB2YXIgeDAgPSBib3hbMF0sIHkwID0gYm94WzFdLCB4MSA9IGJveFsyXSwgeTEgPSBib3hbM10sIG47XG4gICAgdHJhbnNmb3JtID0ge3NjYWxlOiBbeDEgLSB4MCA/ICh4MSAtIHgwKSAvIChuIC0gMSkgOiAxLCB5MSAtIHkwID8gKHkxIC0geTApIC8gKG4gLSAxKSA6IDFdLCB0cmFuc2xhdGU6IFt4MCwgeTBdfTtcbiAgfSBlbHNlIHtcbiAgICBib3ggPSB0b3BvbG9neS5iYm94O1xuICB9XG5cbiAgdmFyIHQgPSB1bnRyYW5zZm9ybSh0cmFuc2Zvcm0pLCBib3gsIGtleSwgaW5wdXRzID0gdG9wb2xvZ3kub2JqZWN0cywgb3V0cHV0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHF1YW50aXplUG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4gdChwb2ludCk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUdlb21ldHJ5KGlucHV0KSB7XG4gICAgdmFyIG91dHB1dDtcbiAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogb3V0cHV0ID0ge3R5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsIGdlb21ldHJpZXM6IGlucHV0Lmdlb21ldHJpZXMubWFwKHF1YW50aXplR2VvbWV0cnkpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiUG9pbnRcIiwgY29vcmRpbmF0ZXM6IHF1YW50aXplUG9pbnQoaW5wdXQuY29vcmRpbmF0ZXMpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvdXRwdXQgPSB7dHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBpbnB1dC5jb29yZGluYXRlcy5tYXAocXVhbnRpemVQb2ludCl9OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKGlucHV0LmlkICE9IG51bGwpIG91dHB1dC5pZCA9IGlucHV0LmlkO1xuICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpIG91dHB1dC5iYm94ID0gaW5wdXQuYmJveDtcbiAgICBpZiAoaW5wdXQucHJvcGVydGllcyAhPSBudWxsKSBvdXRwdXQucHJvcGVydGllcyA9IGlucHV0LnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50aXplQXJjKGlucHV0KSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMSwgbiA9IGlucHV0Lmxlbmd0aCwgcCwgb3V0cHV0ID0gbmV3IEFycmF5KG4pOyAvLyBwZXNzaW1pc3RpY1xuICAgIG91dHB1dFswXSA9IHQoaW5wdXRbMF0sIDApO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHAgPSB0KGlucHV0W2ldLCBpKSlbMF0gfHwgcFsxXSkgb3V0cHV0W2orK10gPSBwOyAvLyBub24tY29pbmNpZGVudCBwb2ludHNcbiAgICBpZiAoaiA9PT0gMSkgb3V0cHV0W2orK10gPSBbMCwgMF07IC8vIGFuIGFyYyBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgIG91dHB1dC5sZW5ndGggPSBqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmb3IgKGtleSBpbiBpbnB1dHMpIG91dHB1dHNba2V5XSA9IHF1YW50aXplR2VvbWV0cnkoaW5wdXRzW2tleV0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUb3BvbG9neVwiLFxuICAgIGJib3g6IGJveCxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBvYmplY3RzOiBvdXRwdXRzLFxuICAgIGFyY3M6IHRvcG9sb2d5LmFyY3MubWFwKHF1YW50aXplQXJjKVxuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIG4pIHtcbiAgdmFyIHQsIGogPSBhcnJheS5sZW5ndGgsIGkgPSBqIC0gbjtcbiAgd2hpbGUgKGkgPCAtLWopIHQgPSBhcnJheVtpXSwgYXJyYXlbaSsrXSA9IGFycmF5W2pdLCBhcnJheVtqXSA9IHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgYXJjcykge1xuICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICBmcmFnbWVudEJ5U3RhcnQgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlFbmQgPSB7fSxcbiAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgZW1wdHlJbmRleCA9IC0xO1xuXG4gIC8vIFN0aXRjaCBlbXB0eSBhcmNzIGZpcnN0LCBzaW5jZSB0aGV5IG1heSBiZSBzdWJzdW1lZCBieSBvdGhlciBhcmNzLlxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgdDtcbiAgICBpZiAoYXJjLmxlbmd0aCA8IDMgJiYgIWFyY1sxXVswXSAmJiAhYXJjWzFdWzFdKSB7XG4gICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgfVxuICB9KTtcblxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHZhciBlID0gZW5kcyhpKSxcbiAgICAgICAgc3RhcnQgPSBlWzBdLFxuICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICBmLCBnO1xuXG4gICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgZi5wdXNoKGkpO1xuICAgICAgZi5lbmQgPSBlbmQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XG4gICAgICAgIHZhciBmZyA9IGcgPT09IGYgPyBmIDogZi5jb25jYXQoZyk7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgIGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICB2YXIgZ2YgPSBnID09PSBmID8gZiA6IGcuY29uY2F0KGYpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZ2Yuc3RhcnQgPSBnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZ2YuZW5kID0gZi5lbmRdID0gZ2Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSBbaV07XG4gICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRdID0gZjtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuZHMoaSkge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHAxID0gWzAsIDBdLCBhcmMuZm9yRWFjaChmdW5jdGlvbihkcCkgeyBwMVswXSArPSBkcFswXSwgcDFbMV0gKz0gZHBbMV07IH0pO1xuICAgIGVsc2UgcDEgPSBhcmNbYXJjLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpIHtcbiAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgIHZhciBmID0gZnJhZ21lbnRCeUVuZFtrXTtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgIGRlbGV0ZSBmLmVuZDtcbiAgICAgIGYuZm9yRWFjaChmdW5jdGlvbihpKSB7IHN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0gPSAxOyB9KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gIGZsdXNoKGZyYWdtZW50QnlTdGFydCwgZnJhZ21lbnRCeUVuZCk7XG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7IGlmICghc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSkgZnJhZ21lbnRzLnB1c2goW2ldKTsgfSk7XG5cbiAgcmV0dXJuIGZyYWdtZW50cztcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsIG4gPSBpbnB1dC5sZW5ndGgsIG91dHB1dCA9IG5ldyBBcnJheShuKTtcbiAgICBvdXRwdXRbMF0gPSAoeDAgKz0gaW5wdXRbMF0pICoga3ggKyBkeDtcbiAgICBvdXRwdXRbMV0gPSAoeTAgKz0gaW5wdXRbMV0pICoga3kgKyBkeTtcbiAgICB3aGlsZSAoaiA8IG4pIG91dHB1dFtqXSA9IGlucHV0W2pdLCArK2o7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsXG4gICAgICAgIG4gPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeDEgPSBNYXRoLnJvdW5kKChpbnB1dFswXSAtIGR4KSAvIGt4KSxcbiAgICAgICAgeTEgPSBNYXRoLnJvdW5kKChpbnB1dFsxXSAtIGR5KSAvIGt5KTtcbiAgICBvdXRwdXRbMF0gPSB4MSAtIHgwLCB4MCA9IHgxO1xuICAgIG91dHB1dFsxXSA9IHkxIC0geTAsIHkwID0geTE7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJpbXBvcnQge1xyXG4gICAgYW5ub3RhdGlvbixcclxuICAgIGFubm90YXRpb25MYWJlbCxcclxuICAgIGFubm90YXRpb25DYWxsb3V0LFxyXG4gICAgYW5ub3RhdGlvbkNhbGxvdXRSZWN0LFxyXG4gICAgYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGUsXHJcbiAgICBhbm5vdGF0aW9uWFlUaHJlc2hvbGQsXHJcbn0gZnJvbSAnZDMtc3ZnLWFubm90YXRpb24nXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQW5ub3RhdGlvbnMobWFwKSB7XHJcbiAgICBpZiAobWFwLnN2Z18pIHtcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBtYXAuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBtYXAuc3ZnSWRfKVxyXG4gICAgICAgIC8vY2xlYXIgcHJldmlvdXNcclxuICAgICAgICB6b29tR3JvdXAuc2VsZWN0QWxsKCcuZW0tYW5ub3RhdGlvbi1ncm91cCcpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIGNvbnN0IGFubm90YXRpb25zQ29uZmlnID0gbWFwLmFubm90YXRpb25zX1xyXG5cclxuICAgICAgICBpZiAoYW5ub3RhdGlvbnNDb25maWcpIHtcclxuICAgICAgICAgICAgLy8gRGVmaW5lIGEgbWFwIHRoYXQgbWFwcyB0aGUgdHlwZSBzdHJpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYW5ub3RhdGlvbiBmdW5jdGlvblxyXG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uVHlwZU1hcCA9IHtcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25MYWJlbDogYW5ub3RhdGlvbkxhYmVsLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNhbGxvdXQ6IGFubm90YXRpb25DYWxsb3V0LFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNhbGxvdXRSZWN0OiBhbm5vdGF0aW9uQ2FsbG91dFJlY3QsXHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uQ2FsbG91dENpcmNsZTogYW5ub3RhdGlvbkNhbGxvdXRDaXJjbGUsXHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uWFlUaHJlc2hvbGQ6IGFubm90YXRpb25YWVRocmVzaG9sZCwgLy8gQWRkIGFueSBvdGhlciB0eXBlcyB5b3UgbmVlZFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYXAgYW5ub3RhdGlvbnMgZGF0YSB0byBlbnN1cmUgZWFjaCBhbm5vdGF0aW9uIGhhcyB0aGUgcHJvcGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zV2l0aFR5cGVzID0gYW5ub3RhdGlvbnNDb25maWcuYW5ub3RhdGlvbnMubWFwKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSAndHlwZScgc3RyaW5nIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYW5ub3RhdGlvbiBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uVHlwZU1hcFtkLnR5cGVdIHx8IGFubm90YXRpb25MYWJlbCAvLyBEZWZhdWx0IHRvIGFubm90YXRpb25MYWJlbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uZCwgdHlwZTogYW5ub3RhdGlvblR5cGUgfSAvLyBVcGRhdGUgJ3R5cGUnIHdpdGggdGhlIGZ1bmN0aW9uIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBjb25zdCBtYWtlQW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uKCkudHlwZShhbm5vdGF0aW9uTGFiZWwpLmFubm90YXRpb25zKGFubm90YXRpb25zV2l0aFR5cGVzKS5lZGl0TW9kZShhbm5vdGF0aW9uc0NvbmZpZy5lZGl0TW9kZSlcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGVuZCBuZXdcclxuICAgICAgICAgICAgem9vbUdyb3VwLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWFubm90YXRpb24tZ3JvdXAnKS5jYWxsKG1ha2VBbm5vdGF0aW9ucylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0LCBzZWxlY3RBbGwgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGNzdlBhcnNlUm93cyB9IGZyb20gJ2QzLWRzdidcclxuXHJcbi8vIGRyYXcgZ3JpZCBjYXJ0b2dyYW0gZ2VvbWV0cmllc1xyXG5leHBvcnQgY29uc3QgYnVpbGRHcmlkQ2FydG9ncmFtQmFzZSA9IGZ1bmN0aW9uIChvdXQpIHtcclxuICAgIGNvbnN0IHpvb21Hcm91cCA9IHNlbGVjdChgI2VtLXpvb20tZ3JvdXAtJHtvdXQuc3ZnSWRffWApXHJcbiAgICBjb25zdCBncmlkR3JvdXAgPSB6b29tR3JvdXAuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnZW0tZ3JpZC1jb250YWluZXInKVxyXG5cclxuICAgIC8vIEVuc3VyZSBtYXJnaW5zIGV4aXN0IHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuICAgIG91dC5ncmlkQ2FydG9ncmFtTWFyZ2luc18gPSBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfIHx8IHsgdG9wOiA4MCwgcmlnaHQ6IDgwLCBib3R0b206IDgwLCBsZWZ0OiA4MCB9XHJcblxyXG4gICAgLy8gR2V0IGdyaWQgbGF5b3V0XHJcbiAgICBjb25zdCBncmlkTGF5b3V0ID0gZ2V0R3JpZExheW91dChvdXQpXHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBhcnNlR3JpZExheW91dChncmlkTGF5b3V0KVxyXG4gICAgY29uc3QgZ3JpZERhdGEgPSBnZXRHcmlkRGF0YShwb3NpdGlvbiwgb3V0KVxyXG5cclxuICAgIC8vIERyYXcgdGhlIGFwcHJvcHJpYXRlIGdyaWRcclxuICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbVNoYXBlXyA9PT0gJ2hleGFnb24nKSB7XHJcbiAgICAgICAgZHJhd0hleGFnb25HcmlkKGdyaWRHcm91cCwgZ3JpZERhdGEsIG91dClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHJhd1NxdWFyZUdyaWQoZ3JpZEdyb3VwLCBncmlkRGF0YSwgb3V0KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENlbnRlciB0aGUgZ3JpZFxyXG4gICAgY2VudGVyR3JpZChncmlkR3JvdXAsIG91dC53aWR0aF8sIG91dC5oZWlnaHRfLCBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfKVxyXG59XHJcblxyXG4vKiogRGV0ZXJtaW5lcyB0aGUgZ3JpZCBsYXlvdXQgYmFzZWQgb24gc2V0dGluZ3MgKi9cclxuY29uc3QgZ2V0R3JpZExheW91dCA9IChvdXQpID0+IHtcclxuICAgIGNvbnN0IHNxdWFyZUdyaWQgPSBgXHJcbiAgICAgICAgLElTLCAgLCAgLE5PLFNFLEZJLCAgLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICwgICwgICwgICxFRSwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsTFYsICAsICAsICAsICAsXHJcbiAgICAgICAgLElFLFVLLCAgLCAgLERLLCAgLExULCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICxOTCxERSxQTCwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsQkUsTFUsQ1osU0ssVUEsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLEZSLENILExJLEFULEhVLFJPLE1ELCAgLCAgLCAgLFxyXG4gICAgICAgICxQVCxFUywgICxJVCxTSSxIUixSUyxCRywgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsQkEsTUUsTUssICAsICAsICAsICBcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsQUwsRUwsVFIsR0UsICAsICBcclxuICAgICAgICAsICAsICAsICAsTVQsICAsICAsICAsICAsQ1ksICAsICAsICBgXHJcblxyXG4gICAgY29uc3QgaGV4YWdvbkdyaWQgPSBgXHJcbiAgICAgICAgLElTLCAgLCAgLCAgLCAgLCAgLCAgLCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICxOTyxTRSxGSSxFRSwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsTFYsICAsICAsICAsICAsXHJcbiAgICAgICAgLElFLFVLLCAgLCAgLERLLCAgLExULCAgLCAgLCAgLCAgLFxyXG4gICAgICAgICwgICwgICwgICxOTCxERSxQTCwgICwgICwgICwgICwgICxcclxuICAgICAgICAsICAsICAsQkUsTFUsQ1osU0ssVUEsICAsICAsICAsICAsXHJcbiAgICAgICAgLCAgLEZSLENILExJLEFULEhVLFJPLE1ELCAgLCAgLCAgLFxyXG4gICAgICAgICxQVCxFUywgICxJVCxTSSxIUixSUyxCRywgICwgICwgICxcclxuICAgICAgICAsICAsICAsICAsICAsICAsQkEsTUUsTUssICAsICAsICAsICBcclxuICAgICAgICAsICAsICAsICAsICAsICAsICAsQUwsRUwsVFIsR0UsICAsICBcclxuICAgICAgICAsICAsICAsICAsTVQsICAsICAsICAsICAsQ1ksICAsICAsICBgXHJcblxyXG4gICAgcmV0dXJuIG91dC5ncmlkQ2FydG9ncmFtUG9zaXRpb25zXyB8fCAob3V0LmdyaWRDYXJ0b2dyYW1TaGFwZV8gPT09ICdoZXhhZ29uJyA/IGhleGFnb25HcmlkIDogc3F1YXJlR3JpZClcclxufVxyXG5cclxuLyoqIFBhcnNlcyB0aGUgZ3JpZCBsYXlvdXQgYW5kIG1hcHMgZWFjaCBJRCB0byBpdHMgcG9zaXRpb24gKi9cclxuY29uc3QgcGFyc2VHcmlkTGF5b3V0ID0gKGdyaWRMYXlvdXQpID0+IHtcclxuICAgIGNvbnN0IHBvc2l0aW9uQnlJZCA9IG5ldyBNYXAoKVxyXG4gICAgY3N2UGFyc2VSb3dzKGdyaWRMYXlvdXQudHJpbSgpLCAocm93LCBqKSA9PiB7XHJcbiAgICAgICAgcm93LmZvckVhY2goKGlkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICgoaWQgPSBpZC50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkJ5SWQuc2V0KGlkLCBbaSwgal0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuICAgIHJldHVybiBwb3NpdGlvbkJ5SWRcclxufVxyXG5cclxuLyoqIENvbnZlcnRzIHBhcnNlZCBwb3NpdGlvbnMgaW50byBzdHJ1Y3R1cmVkIGdyaWQgZGF0YSAqL1xyXG5jb25zdCBnZXRHcmlkRGF0YSA9IChwb3NpdGlvbiwgb3V0KSA9PiB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwb3NpdGlvbiwgKFtpZCwgW2NvbCwgcm93XV0pID0+IHtcclxuICAgICAgICBjb25zdCBmZWF0dXJlID0gb3V0Lkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c3JnLmZpbmQoKHJnKSA9PiByZy5wcm9wZXJ0aWVzLmlkID09IGlkKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBjb2wsXHJcbiAgICAgICAgICAgIHJvdyxcclxuICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogZmVhdHVyZSA/IGZlYXR1cmUucHJvcGVydGllcy5uYSA6ICcnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcbi8qKiBEcmF3cyBhIHNxdWFyZSBncmlkICovXHJcbmNvbnN0IGRyYXdTcXVhcmVHcmlkID0gKGdyaWRHcm91cCwgZ3JpZERhdGEsIG91dCkgPT4ge1xyXG4gICAgY29uc3QgbnVtQ29scyA9IE1hdGgubWF4KC4uLmdyaWREYXRhLm1hcCgoZCkgPT4gZC5jb2wpKSArIDFcclxuICAgIGNvbnN0IG51bVJvd3MgPSBNYXRoLm1heCguLi5ncmlkRGF0YS5tYXAoKGQpID0+IGQucm93KSkgKyAxXHJcblxyXG4gICAgY29uc3QgbWFyZ2lucyA9IG91dC5ncmlkQ2FydG9ncmFtTWFyZ2luc19cclxuICAgIGNvbnN0IGNlbGxQYWRkaW5nID0gb3V0LmdyaWRDYXJ0b2dyYW1DZWxsUGFkZGluZ18gfHwgMCAvLyBLZWVwIGNlbGwgcGFkZGluZ1xyXG5cclxuICAgIGNvbnN0IGNlbGxXaWR0aCA9IChvdXQud2lkdGhfIC0gbWFyZ2lucy5sZWZ0IC0gbWFyZ2lucy5yaWdodCkgLyBudW1Db2xzIC0gY2VsbFBhZGRpbmdcclxuICAgIGNvbnN0IGNlbGxIZWlnaHQgPSAob3V0LmhlaWdodF8gLSBtYXJnaW5zLnRvcCAtIG1hcmdpbnMuYm90dG9tKSAvIG51bVJvd3MgLSBjZWxsUGFkZGluZ1xyXG4gICAgY29uc3QgY2VsbFNpemUgPSBNYXRoLm1pbihjZWxsV2lkdGgsIGNlbGxIZWlnaHQpXHJcblxyXG4gICAgZ3JpZEdyb3VwXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnLmVtLWdyaWQtY2VsbCcpXHJcbiAgICAgICAgLmRhdGEoZ3JpZERhdGEpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZ3JpZC1jZWxsJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IGB0cmFuc2xhdGUoJHtkLmNvbCAqIChjZWxsU2l6ZSArIGNlbGxQYWRkaW5nKSArIG1hcmdpbnMubGVmdH0sICR7ZC5yb3cgKiAoY2VsbFNpemUgKyBjZWxsUGFkZGluZykgKyBtYXJnaW5zLnRvcH0pYClcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuYXBwZW5kKCdyZWN0JykuYXR0cignd2lkdGgnLCBjZWxsU2l6ZSkuYXR0cignaGVpZ2h0JywgY2VsbFNpemUpLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtcmVjdCcpXHJcblxyXG4gICAgICAgICAgICBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAudGV4dChkLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBjZWxsU2l6ZSAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGNlbGxTaXplIC8gMiArIDUpXHJcbiAgICAgICAgfSlcclxufVxyXG5cclxuLyoqIERyYXdzIGEgaGV4YWdvbiBncmlkICovXHJcbmNvbnN0IGRyYXdIZXhhZ29uR3JpZCA9IChncmlkR3JvdXAsIGdyaWREYXRhLCBvdXQpID0+IHtcclxuICAgIGNvbnN0IG51bUNvbHMgPSBNYXRoLm1heCguLi5ncmlkRGF0YS5tYXAoKGQpID0+IGQuY29sKSkgKyAxXHJcbiAgICBjb25zdCBudW1Sb3dzID0gTWF0aC5tYXgoLi4uZ3JpZERhdGEubWFwKChkKSA9PiBkLnJvdykpICsgMVxyXG5cclxuICAgIGNvbnN0IG1hcmdpbnMgPSBvdXQuZ3JpZENhcnRvZ3JhbU1hcmdpbnNfXHJcbiAgICBjb25zdCBjZWxsUGFkZGluZyA9IG91dC5ncmlkQ2FydG9ncmFtQ2VsbFBhZGRpbmdfIHx8IDAgLy8gS2VlcCBjZWxsIHBhZGRpbmdcclxuXHJcbiAgICBjb25zdCBiYXNlSGV4UmFkaXVzID0gTWF0aC5taW4oXHJcbiAgICAgICAgKG91dC53aWR0aF8gLSBtYXJnaW5zLmxlZnQgLSBtYXJnaW5zLnJpZ2h0KSAvIChudW1Db2xzICogMS41KSxcclxuICAgICAgICAob3V0LmhlaWdodF8gLSBtYXJnaW5zLnRvcCAtIG1hcmdpbnMuYm90dG9tKSAvIChudW1Sb3dzICogTWF0aC5zcXJ0KDMpKVxyXG4gICAgKVxyXG5cclxuICAgIGNvbnN0IGhleFJhZGl1cyA9IGJhc2VIZXhSYWRpdXNcclxuICAgIGNvbnN0IGhleEhlaWdodCA9IE1hdGguc3FydCgzKSAqIGhleFJhZGl1c1xyXG5cclxuICAgIGdyaWRHcm91cFxyXG4gICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLWNlbGwnKVxyXG4gICAgICAgIC5kYXRhKGdyaWREYXRhKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtY2VsbCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBkLmNvbCAqICgxLjUgKiBoZXhSYWRpdXMgKyBjZWxsUGFkZGluZykgKyBtYXJnaW5zLmxlZnRcclxuICAgICAgICAgICAgY29uc3QgeSA9IGQucm93ICogKGhleEhlaWdodCArIGNlbGxQYWRkaW5nKSArIChkLmNvbCAlIDIgPT09IDEgPyAoaGV4SGVpZ2h0ICsgY2VsbFBhZGRpbmcpIC8gMiA6IDApICsgbWFyZ2lucy50b3BcclxuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIGRyYXdIZXhhZ29uKGhleFJhZGl1cykpLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtaGV4YWdvbicpXHJcblxyXG4gICAgICAgICAgICBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWdyaWQtdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAudGV4dChkLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCA1KVxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbi8qKiBHZW5lcmF0ZXMgdGhlIGhleGFnb24gcGF0aCAqL1xyXG5jb25zdCBkcmF3SGV4YWdvbiA9IChyKSA9PiB7XHJcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguUEkgLyAzXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IDYgfSwgKF8sIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IHIgKiBNYXRoLmNvcyhhbmdsZSAqIGkpXHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSByICogTWF0aC5zaW4oYW5nbGUgKiBpKVxyXG4gICAgICAgICAgICByZXR1cm4gYCR7aSA9PT0gMCA/ICdNJyA6ICdMJ30ke3h9LCR7eX1gXHJcbiAgICAgICAgfSkuam9pbignICcpICsgJyBaJ1xyXG4gICAgKVxyXG59XHJcblxyXG4vKiogQ2VudGVycyB0aGUgZ3JpZCB3aXRoaW4gdGhlIFNWRyAqL1xyXG5jb25zdCBjZW50ZXJHcmlkID0gKGdyaWRHcm91cCwgc3ZnV2lkdGgsIHN2Z0hlaWdodCwgbWFyZ2lucykgPT4ge1xyXG4gICAgZ3JpZEdyb3VwLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKVxyXG4gICAgICAgIGNvbnN0IGR4ID0gKHN2Z1dpZHRoIC0gbWFyZ2lucy5sZWZ0IC0gbWFyZ2lucy5yaWdodCAtIGJib3gud2lkdGgpIC8gMiAtIGJib3gueCArIG1hcmdpbnMubGVmdFxyXG4gICAgICAgIGNvbnN0IGR5ID0gKHN2Z0hlaWdodCAtIG1hcmdpbnMudG9wIC0gbWFyZ2lucy5ib3R0b20gLSBiYm94LmhlaWdodCkgLyAyIC0gYmJveC55ICsgbWFyZ2lucy50b3BcclxuICAgICAgICBncmlkR3JvdXAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2R4fSwgJHtkeX0pYClcclxuICAgIH0pXHJcbn1cclxuIiwiaW1wb3J0IHsgdXBkYXRlQ1NTUnVsZSB9IGZyb20gJy4vdXRpbHMuanMnXHJcblxyXG4vKiBwcmV0dGllci1pZ25vcmUgKi9cclxuLy8gdG8ga2VlcCB0cmFjayBvZiBkZXByZWNhdGVkIGZ1bmN0aW9ucyB3aGlsc3Qga2VlcGluZyB0aGUgY3VycmVudCB2ZXJzaW9uIGNsZWFuLlxyXG4vLyBhbHNvIHBhc3NlcyBhbnkgaW1wb3J0YW50IHBhcmFtZXRlcnMgdG8gdGhlIG5ldyBmdW5jdGlvbnMgKGlmIHRoZXkgZXhpc3QpIGFuZCBvdmVyd3JpdGVzIGFueSBDU1Mgc3R5bGUgcnVsZXMuXHJcbi8vIFRvIGJlIHJlbW92ZWQgd2hlbiBjb21wbGV0ZWx5IHBoYXNlZCBvdXQuXHJcblxyXG5leHBvcnQgY29uc3QgZGVmaW5lRGVwcmVjYXRlZEZ1bmN0aW9ucyA9IChvdXQpID0+IHtcclxuICAgIC8vIHN0eWxlc1xyXG4gICAgb3V0LnNlYUZpbGxTdHlsZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdzZWFGaWxsU3R5bGUoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLXNlYSBDU1MgY2xhc3MnKSwgdXBkYXRlQ1NTUnVsZSgnLmVtLXNlYScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmNudHJnRmlsbFN0eWxlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2NudHJnRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1jbnRyZyBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tY250cmcnLCdmaWxsJyx2KSwgb3V0KTtcclxuICAgIG91dC5udXRzcmdGaWxsU3R5bGUgPSAodikgPT4gKGNvbnNvbGUud2FybignbnV0c3JnRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1udXRzcmcgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLW51dHNyZycsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0Lm51dHNiblN0cm9rZSA9ICh2KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdudXRzYm5TdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmJuXzAsIC5ibl8xLCAuYm5fMiwgLmJuXzMgQ1NTIGNsYXNzZXMnKVxyXG4gICAgICAgIGlmICh2WycwJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzAnLCdzdHJva2UnLHZbJzAnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzEnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMScsJ3N0cm9rZScsdlsnMSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMiddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8yJywnc3Ryb2tlJyx2WycyJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WyczJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzMnLCdzdHJva2UnLHZbJzMnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC5udXRzYm5TdHJva2VXaWR0aCA9ICh2KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdudXRzYm5TdHJva2VXaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuYm5fMCwgLmJuXzEsIC5ibl8yLCAuYm5fMyBDU1MgY2xhc3NlcycpXHJcbiAgICAgICAgaWYgKHZbJzAnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMCcsJ3N0cm9rZS13aWR0aCcsdlsnMCddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnMSddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5ibl8xJywnc3Ryb2tlLXdpZHRoJyx2WycxJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WycyJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmJuXzInLCdzdHJva2Utd2lkdGgnLHZbJzInXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJzMnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuYm5fMycsJ3N0cm9rZS13aWR0aCcsdlsnMyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9O1xyXG4gICAgb3V0LmdyYXRpY3VsZVN0cm9rZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdncmF0aWN1bGVTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLWdyYXRpY3VsZSBDU1MgY2xhc3MnKSwgdXBkYXRlQ1NTUnVsZSgnLmVtLWdyYXRpY3VsZScsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQuZ3JhdGljdWxlU3Ryb2tlV2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignZ3JhdGljdWxlU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRCwgcGxlYXNlIHVzZSB0aGUgLmVtLWdyYXRpY3VsZSBDU1MgY2xhc3MnKSwgdXBkYXRlQ1NTUnVsZSgnLmVtLWdyYXRpY3VsZScsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7XHJcbiAgICBvdXQubnV0c3JnU2VsRmlsbFN0eSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdudXRzcmdTZWxGaWxsU3R5KCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgaG92ZXJDb2xvcigpIGluc3RlYWQnKSwgb3V0LmhvdmVyQ29sb3JfID0gdiwgb3V0KTtcclxuICAgIG91dC50aXRsZUZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50aXRsZUZvbnRTaXplKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS10aXRsZSBDU1MgY2xhc3MnKSx1cGRhdGVDU1NSdWxlKCcuZW0tdGl0bGUnLCdmb250LXNpemUnLHYpLCBvdXQpO1xyXG4gICAgb3V0LnN1YnRpdGxlRm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnN1YnRpdGxlRm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN1YnRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zdWJ0aXRsZScsJ2ZvbnQtc2l6ZScsdiksIG91dCk7XHJcbiAgICBvdXQuc3VidGl0bGVGb250V2VpZ2h0ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5zdWJ0aXRsZUZvbnRXZWlnaHQoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN1YnRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zdWJ0aXRsZScsJ2ZvbnQtd2VpZ2h0Jyx2KSwgb3V0KTtcclxuICAgIG91dC50aXRsZUZpbGwgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnRpdGxlRmlsbCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tdGl0bGUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXRpdGxlJywnZmlsbCcsdiksIG91dCk7XHJcbiAgICBvdXQuc3VidGl0bGVGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5zdWJ0aXRsZUZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN1YnRpdGxlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1zdWJ0aXRsZScsJ2ZpbGwnLHYpLCBvdXQpO1xyXG4gICAgb3V0LmNudGJuU3Ryb2tlID0gKHYpID0+IHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2NudGJuU3Ryb2tlKCkgaXMgbm93IERFUFJFQ0FURUQsIHBsZWFzZSB1c2UgdGhlIC5lbS1jbnRibiAuZW0tYm4tZXUgLmVtLWJuLWVmdGEgLmVtLWJuLWNjIC5lbS1ibi1vdGggQ1NTIGNsYXNzZXMnKVxyXG4gICAgICAgIGlmICh2WydldSddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1ldScsJ3N0cm9rZScsdlsnZXUnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2VmdGEnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tZWZ0YScsJ3N0cm9rZScsdlsnZWZ0YSddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnY2MnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tY2MnLCdzdHJva2UnLHZbJ2NjJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydvdGgnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tb3RoJywnc3Ryb2tlJyx2WydvdGgnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2NvJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWNvJywnc3Ryb2tlJyx2WydjbyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9O1xyXG4gICAgb3V0LmNudGJuU3Ryb2tlV2lkdGggPSAodikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignY250Ym5TdHJva2VXaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELCBwbGVhc2UgdXNlIHRoZSAuZW0tY250Ym4gLmVtLXdvcmxkYm4gLmVtLWJuLWV1IC5lbS1ibi1lZnRhIC5lbS1ibi1jYyAuZW0tYm4tb3RoIENTUyBjbGFzc2VzJylcclxuICAgICAgICBpZiAodlsnZXUnXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVDU1NSdWxlKCcuZW0tYm4tZXUnLCdzdHJva2Utd2lkdGgnLHZbJ2V1J10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydlZnRhJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWVmdGEnLCdzdHJva2Utd2lkdGgnLHZbJ2VmdGEnXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZbJ2NjJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLWNjJywnc3Ryb2tlLXdpZHRoJyx2WydjYyddKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodlsnb3RoJ10pIHtcclxuICAgICAgICAgICAgdXBkYXRlQ1NTUnVsZSgnLmVtLWJuLW90aCcsJ3N0cm9rZS13aWR0aCcsdlsnb3RoJ10pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2WydjbyddKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZS13aWR0aCcsdlsnY28nXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfTtcclxuICAgIG91dC53b3JsZFN0cm9rZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAud29ybGRTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXdvcmxkYm4gLmVtLWJuLWNvIC5lbS1ibi1kIENTUyBjbGFzc2VzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXdvcmxkYm4nLCdzdHJva2UnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkU3Ryb2tlV2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXdvcmxkYm4gLmVtLWJuLWNvIC5lbS1ibi1kIENTUyBjbGFzc2VzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXdvcmxkYm4nLCdzdHJva2Utd2lkdGgnLHYpLCBvdXQpO1xyXG4gICAgb3V0LndvcmxkQ29hc3RTdHJva2UgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkQ29hc3RTdHJva2UoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWJuLWNvIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZScsdiksIG91dCk7XHJcbiAgICBvdXQud29ybGRDb2FzdFN0cm9rZVdpZHRoID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC53b3JsZENvYXN0U3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWJuLWNvIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1ibi1jbycsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7XHJcbiAgICBvdXQud29ybGRGaWxsU3R5bGUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLndvcmxkRmlsbFN0eWxlKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS13b3JsZHJnIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS13b3JsZHJnJywnZmlsbCcsdiksIG91dCk7IFxyXG4gICAgb3V0LmNvYXN0YWxNYXJnaW5XaWR0aCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY29hc3RhbE1hcmdpbldpZHRoKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlICNlbS1jb2FzdC1tYXJnaW4gQ1NTIHJ1bGUnKSx1cGRhdGVDU1NSdWxlKCcjZW0tY29hc3QtbWFyZ2luJywnc3Ryb2tlLXdpZHRoJyx2KSwgb3V0KTsgIFxyXG4gICAgb3V0LmNvYXN0YWxNYXJnaW5Db2xvciA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuY29hc3RhbE1hcmdpbkNvbG9yKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlICNlbS1jb2FzdC1tYXJnaW4gQ1NTIHJ1bGUnKSx1cGRhdGVDU1NSdWxlKCcjZW0tY29hc3QtbWFyZ2luJywnc3Ryb2tlJyx2KSwgb3V0KTtcclxuICAgIG91dC5mb250RmFtaWx5ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5mb250RmFtaWx5KCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgdGhlIC5lbS1tYXAgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLW1hcCcsJ2ZvbnQtZmFtaWx5Jyx2KSwgb3V0KTtcclxuICAgIG91dC5ib3RUeHRGb250U2l6ZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuYm90VHh0Rm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZvb3Rub3RlIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mb290bm90ZScsJ2ZvbnQtc2l6ZScsdiksIG91dCk7XHJcbiAgICBvdXQuYm90VHh0RmlsbCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuYm90VHh0RmlsbCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tZm9vdG5vdGUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLWZvb3Rub3RlJywnZmlsbCcsdiksIG91dCk7XHJcbiAgICBvdXQuc2NhbGViYXJGb250U2l6ZSA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAuc2NhbGViYXJGb250U2l6ZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc2NhbGViYXItbGFiZWwgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLXNjYWxlYmFyLWxhYmVsJywnZm9udC1zaXplJyx2KSwgb3V0KTtcclxuICAgIG91dC5mcmFtZVN0cm9rZSA9ICh2KT0+IChjb25zb2xlLndhcm4oJ21hcC5mcmFtZVN0cm9rZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tZnJhbWUgQ1NTIGNsYXNzJyksdXBkYXRlQ1NTUnVsZSgnLmVtLWZyYW1lJywnc3Ryb2tlJyx2KSwgb3V0KTtcclxuICAgIG91dC5mcmFtZVN0cm9rZVdpZHRoID0gKHYpPT4gKGNvbnNvbGUud2FybignbWFwLmZyYW1lU3Ryb2tlV2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLWZyYW1lIENTUyBjbGFzcycpLHVwZGF0ZUNTU1J1bGUoJy5lbS1mcmFtZScsJ3N0cm9rZS13aWR0aCcsdiksIG91dCk7XHJcblxyXG4gICAvL290aGVyXHJcbiAgICBvdXQucHNDbGFzc2lmTWV0aG9kID0gKHYpID0+IChjb25zb2xlLndhcm4oJ3BzQ2xhc3NpZk1ldGhvZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHBzQ2xhc3NpZmljYXRpb25NZXRob2QgaW5zdGVhZCcpLG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9IHYsIG91dCk7XHJcbiAgICBvdXQuZ2VvQ2VudGVyID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5nZW9DZW50ZXIoKSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtYXAucG9zaXRpb24oe3gseSx6fSkgaW5zdGVhZC4nKSwgb3V0LnBvc2l0aW9uXy54ID0gdlswXSwgb3V0LnBvc2l0aW9uXy55ID0gdlsxXSwgb3V0KTtcclxuICAgIG91dC5waXhlbFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnBpeGVsU2l6ZSgpIGlzIG5vdyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSB6IHByb3BlcnR5IGluIG1hcC5wb3NpdGlvbih7eCx5LHp9KSBpbnN0ZWFkLicpLCBvdXQucG9zaXRpb25fLnogPSB2LCBvdXQpO1xyXG4gICAgb3V0LnBpeFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnBpeGVsU2l6ZSgpIGlzIG5vdyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSB6IHByb3BlcnR5IGluIG1hcC5wb3NpdGlvbih7eCx5LHp9KSBpbnN0ZWFkLicpLCBvdXQucG9zaXRpb25fLnogPSB2LCBvdXQpO1xyXG4gICAgb3V0LnRvb2x0aXBUZXh0ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC50b29sdGlwVGV4dCgpIGlzIG5vdyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1hcC50b29sdGlwKGNvbmZpZy50ZXh0RnVuY3Rpb24pIGluc3RlYWQuIFNlZSBBUEkgcmVmZXJlbmNlIGZvciBkZXRhaWxzLicpLCBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gdiwgb3V0KTtcclxuICAgIG91dC5jbGFzc2lmTWV0aG9kID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jbGFzc2lmTWV0aG9kKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLmNsYXNzaWZpY2F0aW9uTWV0aG9kKCkgaW5zdGVhZC4nKSwgb3V0LmNsYXNzaWZpY2F0aW9uTWV0aG9kXyA9IHYsb3V0KTtcclxuICAgIG91dC50aHJlc2hvbGQgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLnRocmVzaG9sZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC50aHJlc2hvbGRzKCkgaW5zdGVhZC4nKSwgb3V0LnRocmVzaG9sZHNfID0gdixvdXQpO1xyXG4gICAgb3V0LnBzVGhyZXNob2xkID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5wc1RocmVzaG9sZCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIG1hcC5wc1RocmVzaG9sZHMoKSBpbnN0ZWFkLicpLCBvdXQucHNUaHJlc2hvbGRzXyA9IHYsb3V0KTtcclxuICAgIG91dC5jbG5iID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jbG5iKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLm51bWJlck9mQ2xhc3NlcygpIGluc3RlYWQuJyksIG91dC5udW1iZXJPZkNsYXNzZXNfID0gdixvdXQpO1xyXG4gICAgb3V0Lm51dHNMdmwgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLm51dHNMdmwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSBtYXAubnV0c0xldmVsKCkgaW5zdGVhZC4nKSwgb3V0Lm51dHNMZXZlbF8gPSB2LG91dCk7XHJcbiAgICBvdXQubGcgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxnKCkgaXMgbm93IERFUFJFQ0FURUQuIHBsZWFzZSB1c2UgbWFwLmxhbmd1YWdlKCkgaW5zdGVhZC4nKSwgb3V0Lmxhbmd1YWdlXyA9IHYsb3V0KTtcclxuICAgIG91dC5ib3R0b21UZXh0ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdHRvbVRleHQgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2UgdGhlIGZvb3Rub3RlKCkgbWV0aG9kIGFuZCBlbS1mb290bm90ZSBDU1MgY2xhc3MgaW5zdGVhZC4nKSxvdXQuZm9vdG5vdGVfID0gdixvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZvbnRTaXplID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdFR4dEZvbnRTaXplIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIHRoZSBlbS1mb290bm90ZSBDU1MgY2xhc3MgaW5zdGVhZC4nKSxvdXQpO1xyXG4gICAgb3V0LmJvdFR4dEZpbGwgPSAodikgPT4gKGNvbnNvbGUud2FybignYm90VHh0RmlsbCBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSB0aGUgZW0tZm9vdG5vdGUgQ1NTIGNsYXNzIGluc3RlYWQuJyksb3V0KTtcclxuICAgIG91dC5ib3RUeHRQYWRkaW5nID0gKHYpID0+IChjb25zb2xlLndhcm4oJ2JvdFR4dFBhZGRpbmcgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2UgdGhlIGVtLWZvb3Rub3RlIENTUyBjbGFzcyBpbnN0ZWFkLicpLG91dCk7XHJcbiAgICBvdXQuYm90VHh0VG9vbHRpcFR4dCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdib3RUeHRUb29sdGlwVHh0IGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIGZvb3Rub3RlVG9vbHRpcFRleHQoKSBpbnN0ZWFkLicpLG91dCk7XHJcbiAgICBvdXQudG9vbHRpcFNob3dGbGFncyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ3Rvb2x0aXBTaG93RmxhZ3MgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LnRvb2x0aXAoe3Nob3dGbGFnc30pIGluc3RlYWQuJyksb3V0LnRvb2x0aXBfLnNob3dGbGFncyA9IHYsb3V0KTtcclxuICAgIG91dC5jb2xvckZ1biA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2NvbG9yRnVuIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5jb2xvckZ1bmN0aW9uKCkgaW5zdGVhZC4nKSxvdXQuY29sb3JGdW5jdGlvbl8gPSB2LG91dCk7XHJcbiAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW4gPSAodik9Pihjb25zb2xlLndhcm4oJ2ZpbHRlcnNEZWZpbml0aW9uRnVuIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uKCkgaW5zdGVhZC4nKSxvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8gPSB2LG91dCk7XHJcbiAgICBcclxuICAgIC8vbGFiZWxsaW5nXHJcbiAgICBvdXQubGFiZWxsaW5nID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxsaW5nIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe30pIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxzQ29uZmlnID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxzQ29uZmlnIGlzIG5vdyBERVBSRUNBVEVELiBQbGVhc2UgdXNlIG91dC5sYWJlbHMoe2NvbmZpZzp5b3VyQ29uZmlnfSkgY29uZmlndXJhdGlvbiBvYmplY3QgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0LmxhYmVsc18gPU9iamVjdC5hc3NpZ24ob3V0LmxhYmVsc18gfHwge30sIHsgY29uZmlnOiB2IH0pLG91dCk7XHJcbiAgICBvdXQuc3RhdExhYmVsc1Bvc2l0aW9ucyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ3N0YXRMYWJlbHNQb3NpdGlvbnMgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7c3RhdExhYmVsc1Bvc2l0aW9uczp5b3VyUG9zaXRpb25zfSkgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0LmxhYmVsc18gPSBPYmplY3QuYXNzaWduKG91dC5sYWJlbHNfIHx8IHt9LCB7IHN0YXRMYWJlbHNQb3NpdGlvbnM6IHYgfSksb3V0KTtcclxuICAgIG91dC5sYWJlbHNUb1Nob3cgPSAodikgPT4oY29uc29sZS53YXJuKCdsYWJlbHNUb1Nob3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxGaWx0ZXJGdW5jdGlvbjp5b3VyRnVuY3Rpb24ocmVnaW9uLG1hcCl9KSBmdW5jdGlvbiBpbnN0ZWFkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKSxvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93c1RvU2hvdyA9ICh2KSA9Pihjb25zb2xlLndhcm4oJ2xhYmVsU2hhZG93c1RvU2hvdyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbEZpbHRlckZ1bmN0aW9uOnlvdXJGdW5jdGlvbihyZWdpb24sbWFwKX0pIGZ1bmN0aW9uIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxTaGFkb3cgPSAodikgPT4oY29uc29sZS53YXJuKCdsYWJlbFNoYWRvdyBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbFNoYWRvdzpib29sZWFufSkgaW5zdGVhZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuJyksb3V0KTtcclxuICAgIG91dC5sYWJlbFNoYWRvd1dpZHRoID0gKHYpID0+KGNvbnNvbGUud2FybignbGFiZWxTaGFkb3cgaXMgbm93IERFUFJFQ0FURUQuIFBsZWFzZSB1c2Ugb3V0LmxhYmVscyh7bGFiZWxTaGFkb3c6Ym9vbGVhbn0pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxGaWx0ZXJGdW5jdGlvbiA9KHYpID0+KGNvbnNvbGUud2FybignbGFiZWxGaWx0ZXJGdW5jdGlvbiBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBvdXQubGFiZWxzKHtsYWJlbEZpbHRlckZ1bmN0aW9uOnlvdXJGdW5jdGlvbihyZWdpb24sbWFwKX0pIGluc3RlYWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLicpLG91dCk7XHJcbiAgICBvdXQubGFiZWxGaWxsID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbEZpbGwoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU3Ryb2tlID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbFN0cm9rZSgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxTdHJva2VXaWR0aCA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxTdHJva2VXaWR0aCgpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxPcGFjaXR5ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5sYWJlbE9wYWNpdHkoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsVmFsdWVzRm9udFNpemUgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsVmFsdWVzRm9udFNpemUoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzIENTUyBjbGFzcycpLCBvdXQpO1xyXG4gICAgb3V0LmxhYmVsU2hhZG93V2lkdGggPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmxhYmVsU2hhZG93V2lkdGgoKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgLmVtLXN0YXQtbGFiZWxzLXNoYWRvd3MgQ1NTIGNsYXNzJyksIG91dCk7XHJcbiAgICBvdXQubGFiZWxTaGFkb3dDb2xvciA9ICh2KSA9PiAoY29uc29sZS53YXJuKCdtYXAubGFiZWxTaGFkb3dDb2xvcigpIGlzIG5vdyBERVBSRUNBVEVELiBwbGVhc2UgdXNlIHRoZSAuZW0tc3RhdC1sYWJlbHMtc2hhZG93cyBDU1MgY2xhc3MnKSwgb3V0KTtcclxuXHJcbiAgICBvdXQuY291bnRyaWVzVG9TaG93ID0gKHYpID0+IChjb25zb2xlLndhcm4oJ21hcC5jb3VudHJpZXNUb1Nob3coKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgbWFwLmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbigpIGZ1bmN0aW9uIGlmIHlvdSB3aXNoIHRvIGZpbHRlciB0aGUgZGVmYXVsdCBnZW9tZXRyaWVzLicpLCBvdXQpO1xyXG4gICAgb3V0LmJvcmRlcnNUb1Nob3cgPSAodikgPT4gKGNvbnNvbGUud2FybignbWFwLmJvcmRlcnNUb1Nob3coKSBpcyBub3cgREVQUkVDQVRFRC4gcGxlYXNlIHVzZSB0aGUgbWFwLmZpbHRlckdlb21ldHJpZXNGdW5jdGlvbigpIGZ1bmN0aW9uIGlmIHlvdSB3aXNoIHRvIGZpbHRlciB0aGUgZGVmYXVsdCBnZW9tZXRyaWVzLicpLCBvdXQpO1xyXG59XHJcbiIsIi8vIHRha2VzIGNhcmUgb2YgdGhlIG1hcCdzIGdlb21ldHJpZXNcclxuaW1wb3J0IHsganNvbiB9IGZyb20gJ2QzLWZldGNoJ1xyXG5pbXBvcnQgeyBmZWF0dXJlIH0gZnJvbSAndG9wb2pzb24tY2xpZW50J1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IHsga29zb3ZvQm5GZWF0dXJlcyB9IGZyb20gJy4va29zb3ZvJ1xyXG5pbXBvcnQgeyBnZW9HcmF0aWN1bGUgfSBmcm9tICdkMy1nZW8nXHJcblxyXG4vLyBHZW9tZXRyaWVzIGNsYXNzIHdyYXBwZWQgYXMgYSBmdW5jdGlvblxyXG5leHBvcnQgY29uc3QgR2VvbWV0cmllcyA9IGZ1bmN0aW9uIChtYXAsIHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgIGxldCBvdXQgPSB7fVxyXG5cclxuICAgIC8vIGRlZmF1bHRzXHJcbiAgICBvdXQuZGVmYXVsdEdlb0RhdGEgPSB1bmRlZmluZWRcclxuICAgIG91dC5hbGxOVVRTR2VvRGF0YSA9IHVuZGVmaW5lZFxyXG4gICAgb3V0Lmdlb0pTT05zID0ge1xyXG4gICAgICAgIG1peGVkOiB7IHJnMDogdW5kZWZpbmVkLCByZzE6IHVuZGVmaW5lZCwgcmcyOiB1bmRlZmluZWQsIHJnMzogdW5kZWZpbmVkIH0sXHJcbiAgICAgICAgY250Ym46IHVuZGVmaW5lZCxcclxuICAgICAgICBjbnRyZzogdW5kZWZpbmVkLFxyXG4gICAgICAgIG51dHNibjogdW5kZWZpbmVkLFxyXG4gICAgICAgIG51dHNyZzogdW5kZWZpbmVkLFxyXG4gICAgICAgIGdyYTogdW5kZWZpbmVkLFxyXG4gICAgICAgIHdvcmxkcmc6IHVuZGVmaW5lZCxcclxuICAgICAgICB3b3JsZGJuOiB1bmRlZmluZWQsXHJcbiAgICAgICAga29zb3ZvOiB1bmRlZmluZWQsXHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXNlciBkZWZpbmVkIGdlb21ldHJpZXMgKGxheWVycylcclxuICAgIG91dC51c2VyR2VvbWV0cmllcyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vIHVzZXIgZGVmaW5lZCBzdGF0aXN0aWNhbCByZWdpb25zXHJcbiAgICBvdXQuc3RhdGlzdGljYWxSZWdpb25zID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLy9jZW50cm9pZHMgZm9yIHByb3Agc3ltYm9scyBldGNcclxuICAgIG91dC5jZW50cm9pZHNEYXRhID0gdW5kZWZpbmVkIC8vcmF3XHJcbiAgICBvdXQuY2VudHJvaWRzRmVhdHVyZXMgPSB1bmRlZmluZWQgLy9nZW9qc29uIGZlYXR1cmVzXHJcblxyXG4gICAgLy8gZ2V0IGdlb2pzb24gZmVhdHVyZXMgb2YgYWxsIHN0YXRpc3RpY2FsIHJlZ2lvbnNcclxuICAgIG91dC5nZXRSZWdpb25GZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobWFwLmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0Lmdlb0pTT05zLndvcmxkcmdcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbb3V0Lmdlb0pTT05zLm1peGVkLnJnMCwgb3V0Lmdlb0pTT05zLm1peGVkLnJnMSwgb3V0Lmdlb0pTT05zLm1peGVkLnJnMiwgb3V0Lmdlb0pTT05zLm1peGVkLnJnM11cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuZ2VvSlNPTnMubnV0c3JnLmNvbmNhdChvdXQuZ2VvSlNPTnMuY250cmcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYW5kIHBhcnNlcyAnZGVmYXVsdCcgZ2VvIGRhdGEgKGZvciBOVVRTIG9yIFdvcmxkIG1hcHMpXHJcbiAgICAgKi9cclxuICAgIG91dC5nZXREZWZhdWx0R2VvRGF0YSA9IGZ1bmN0aW9uIChnZW8sIGZpbHRlckdlb21ldHJpZXNGdW5jdGlvbiwgbnV0c0xldmVsKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBvdXQuZ2V0RGVmYXVsdEdlb0RhdGFQcm9taXNlKClcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGZpbHRlckdlb21ldHJpZXNGdW5jdGlvbihyZXN1bHRzKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3V0LmFsbE5VVFNHZW9EYXRhID0gcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgb3V0LmRlZmF1bHRHZW9EYXRhID0gcmVzdWx0c1swXVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNlbnRyb2lkc0RhdGEgPSBudXRzTGV2ZWwgPT09ICdtaXhlZCcgPyBbcmVzdWx0c1s0XSwgcmVzdWx0c1s1XSwgcmVzdWx0c1s2XSwgcmVzdWx0c1s3XV0gOiByZXN1bHRzWzFdXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNXb3JsZCA9IGdlbyA9PT0gJ1dPUkxEJ1xyXG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIFRvcG9KU09OIHRvIEdlb0pTT05cclxuICAgICAgICAgICAgICAgIGlmIChpc1dvcmxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLndvcmxkcmcgPSBmZWF0dXJlKG91dC5kZWZhdWx0R2VvRGF0YSwgb3V0LmRlZmF1bHRHZW9EYXRhLm9iamVjdHMuQ05UUl9SR18yME1fMjAyMF80MzI2KS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy53b3JsZGJuID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLkNOVFJfQk5fMjBNXzIwMjBfNDMyNikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvSlNPTnMua29zb3ZvID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLk5VVFNfQk5fMjBNXzIwMjFfUlNfWEtfYm9yZGVyKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5ncmF0aWN1bGUgPSBbZ2VvR3JhdGljdWxlKCkuc3RlcChbMzAsIDMwXSkoKV1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLmdyYXRpY3VsZSA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5ncmEpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLm51dHNyZyA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5udXRzcmcpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLm51dHNibiA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5udXRzYm4pLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmdlb0pTT05zLmNudHJnID0gZmVhdHVyZShvdXQuZGVmYXVsdEdlb0RhdGEsIG91dC5kZWZhdWx0R2VvRGF0YS5vYmplY3RzLmNudHJnKS5mZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5nZW9KU09Ocy5jbnRibiA9IGZlYXR1cmUob3V0LmRlZmF1bHRHZW9EYXRhLCBvdXQuZGVmYXVsdEdlb0RhdGEub2JqZWN0cy5jbnRibikuZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgZm9yIE51dHMySlNPTiB0b3BvanNvbiBkYXRhLlxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0RGVmYXVsdEdlb0RhdGFQcm9taXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG51dHNMZXZlbHMgPSBbMCwgMSwgMiwgM11cclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdXHJcblxyXG4gICAgICAgIGNvbnN0IGJ1aWxkVXJsID0gKGJhc2UsIHllYXIsIGdlbywgcHJvaiwgc2NhbGUsIGxldmVsLCB3aXRoQ2VudGVyID0gZmFsc2UpID0+IHtcclxuICAgICAgICAgICAgbGV0IHBhdGggPSBgJHtiYXNlfS8ke3llYXJ9YFxyXG5cclxuICAgICAgICAgICAgLy8gSW5jbHVkZSBnZW8gcGFydCBpZiBpdCdzIHNwZWNpZmllZCBhbmQgbm90ICdFVVInIG9yICdXT1JMRCdcclxuICAgICAgICAgICAgaWYgKGdlbyAmJiBnZW8gIT09ICdFVVInICYmIGdlbyAhPT0gJ1dPUkxEJykgcGF0aCArPSBgLyR7Z2VvfWBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBwcm9qZWN0aW9uXHJcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2dlbyA9PSAnV09STEQnID8gJzQzMjYnIDogcHJvan1gIC8vIHdvcmxkIGdlb2RhdGEgaXMgYWx3YXlzIDQzMjYsIHRoZW4gcmVwcm9qZWN0ZWRcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBzY2FsZSBvbmx5IGlmIG5vdCB1c2luZyBjZW50ZXIgcG9pbnRzXHJcbiAgICAgICAgICAgIGlmICghd2l0aENlbnRlciAmJiBzY2FsZSkgcGF0aCArPSBgLyR7c2NhbGV9YFxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBhcHByb3ByaWF0ZSBmaWxlIG5hbWVcclxuICAgICAgICAgICAgcGF0aCArPSBgLyR7d2l0aENlbnRlciA/ICdudXRzcHRfJyA6ICcnfSR7bGV2ZWx9Lmpzb25gXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnICYmIG1hcC5nZW9fICE9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIG51dHNMZXZlbHMuZm9yRWFjaCgobHZsKSA9PiBwcm9taXNlcy5wdXNoKGpzb24oYnVpbGRVcmwobWFwLm51dHMyanNvbkJhc2VVUkxfLCBtYXAubnV0c1llYXJfLCBtYXAuZ2VvXywgbWFwLnByb2pfLCBtYXAuc2NhbGVfLCBsdmwpKSkpXHJcbiAgICAgICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBudXRzTGV2ZWxzLmZvckVhY2goKGx2bCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGpzb24oYnVpbGRVcmwobWFwLm51dHMyanNvbkJhc2VVUkxfLCBtYXAubnV0c1llYXJfLCBtYXAuZ2VvXywgbWFwLnByb2pfLCBtYXAuc2NhbGVfLCBsdmwsIHRydWUpKSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobWFwLmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgY29uc3Qgd29ybGRNYXBUb3BvanNvblVSTCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS5pbmNsdWRlcygnZWMuZXVyb3BhLmV1JylcclxuICAgICAgICAgICAgICAgID8gJ2h0dHBzOi8vZWMuZXVyb3BhLmV1L2Fzc2V0cy9lc3RhdC9FL0U0L2dpc2NvL0lNQUdFL1dPUkxEXzQzMjYuanNvbidcclxuICAgICAgICAgICAgICAgIDogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldXJvc3RhdC9ldXJvc3RhdC1tYXAvbWFzdGVyL3NyYy9hc3NldHMvdG9wb2pzb24vV09STERfNDMyNi5qc29uJ1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGpzb24od29ybGRNYXBUb3BvanNvblVSTCkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChqc29uKGJ1aWxkVXJsKG1hcC5udXRzMmpzb25CYXNlVVJMXywgbWFwLm51dHNZZWFyXywgbWFwLmdlb18sIG1hcC5wcm9qXywgbWFwLnNjYWxlXywgbWFwLm51dHNMZXZlbF8pKSlcclxuICAgICAgICAgICAgaWYgKHdpdGhDZW50ZXJQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goanNvbihidWlsZFVybChtYXAubnV0czJqc29uQmFzZVVSTF8sIG1hcC5udXRzWWVhcl8sIG1hcC5nZW9fLCBtYXAucHJval8sIG1hcC5zY2FsZV8sIG1hcC5udXRzTGV2ZWxfLCB0cnVlKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9taXNlc1xyXG4gICAgfVxyXG4gICAgLyoqIENoZWNrcyBpZiBhbGwgZ2VvIGRhdGEgaXMgcmVhZHkgKi9cclxuICAgIG91dC5pc0dlb1JlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghb3V0LmRlZmF1bHRHZW9EYXRhICYmICFvdXQudXNlckdlb21ldHJpZXMpIHJldHVybiBmYWxzZVxyXG5cclxuICAgICAgICBsZXQgYWxsUmVhZHkgPSB0cnVlXHJcblxyXG4gICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMobWFwLmluc2V0VGVtcGxhdGVzXywgbnVsbCwgKGluc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaW5zZXQuR2VvbWV0cmllcy5pc0dlb1JlYWR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGFsbFJlYWR5ID0gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBhbGxSZWFkeVxyXG4gICAgfVxyXG5cclxuICAgIG91dC5zZXRVc2VyR2VvbWV0cmllcyA9IGZ1bmN0aW9uIChnZW9tZXRyaWVzKSB7XHJcbiAgICAgICAgdGhpcy51c2VyR2VvbWV0cmllcyA9IGdlb21ldHJpZXNcclxuXHJcbiAgICAgICAgLy8gZ2V0IHJlZ2lvbnMgdGhhdCBhcmUgbGlua2VkIHRvIHRoZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tZXRyeSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuc3RhdGlzdGljYWxSZWdpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY2FsUmVnaW9ucyA9IGdlb21ldHJ5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIG91dC5hZGREZWZhdWx0R2VvbWV0cmllc1RvTWFwID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgZHJhd0dyYXRpY3VsZSwgcGF0aEZ1bmN0aW9uLCBudXRzTGV2ZWwsIG51dHNZZWFyLCBnZW8sIHByb2osIHNjYWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMuZ3JhdGljdWxlICYmIGRyYXdHcmF0aWN1bGUpIHtcclxuICAgICAgICAgICAgLy9kcmF3IGdyYXRpY3VsZVxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWdyYXRpY3VsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZ3JhdGljdWxlJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy5ncmF0aWN1bGUpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBjb3VudHJ5IHJlZ2lvbnNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5jbnRyZykge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNudHJnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jbnRyZycpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMuY250cmcpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChjbnRyZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpZHMgZm9yIFJTIGFuZCBFTCBzbyB0aGF0IHdlIGNhbiBjaG9vc2Ugbm90IHRvIGFkZCBzdGF0aXN0aWNhbCBkYXRhIHRvIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBjbnRyZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09ICdSUycgfHwgaWQgPT0gJ0VMJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2VtLWNudHJnLScgKyBpZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgd29ybGQgbWFwXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMud29ybGRyZykge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXdvcmxkcmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXdvcmxkcmcnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLndvcmxkcmcpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBOVVRTIHJlZ2lvbnNcclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5udXRzcmcpIHtcclxuICAgICAgICAgICAgaWYgKG51dHNMZXZlbCA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0pTT05zLm1peGVkLnJnMCA9IHRoaXMuZ2VvSlNPTnMubnV0c3JnXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0pTT05zLm1peGVkLnJnMSA9IGZlYXR1cmUob3V0LmFsbE5VVFNHZW9EYXRhWzFdLCBvdXQuYWxsTlVUU0dlb0RhdGFbMV0ub2JqZWN0cy5udXRzcmcpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0pTT05zLm1peGVkLnJnMiA9IGZlYXR1cmUob3V0LmFsbE5VVFNHZW9EYXRhWzJdLCBvdXQuYWxsTlVUU0dlb0RhdGFbMl0ub2JqZWN0cy5udXRzcmcpLmZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0pTT05zLm1peGVkLnJnMyA9IGZlYXR1cmUob3V0LmFsbE5VVFNHZW9EYXRhWzNdLCBvdXQuYWxsTlVUU0dlb0RhdGFbM10ub2JqZWN0cy5udXRzcmcpLmZlYXR1cmVzXHJcblxyXG4gICAgICAgICAgICAgICAgLy9mb3IgbWl4ZWQgTlVUUywgd2UgYWRkIGV2ZXJ5IE5VVFMgcmVnaW9uIGFjcm9zcyBhbGwgbGV2ZWxzIGFuZCBoaWRlIGxldmVsIDEsMiwzIGJ5IGRlZmF1bHQsIG9ubHkgc2hvd2luZyB0aGVtIHdoZW4gdGhleSBoYXZlIHN0YXQgZGF0YVxyXG4gICAgICAgICAgICAgICAgLy8gc2VlIHVwZGF0ZUNsYXNzaWZpY2F0aW9uIGFuZCB1cGRhdGVTdHlsZSBpbiBtYXAtY2hvcm9wbGV0aC5qcyBmb3IgaGlkaW5nL3Nob3dpbmdcclxuICAgICAgICAgICAgICAgIDtbdGhpcy5nZW9KU09Ocy5taXhlZC5yZzAsIHRoaXMuZ2VvSlNPTnMubWl4ZWQucmcxLCB0aGlzLmdlb0pTT05zLm1peGVkLnJnMiwgdGhpcy5nZW9KU09Ocy5taXhlZC5yZzNdLmZvckVhY2goKHIsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL2FwcGVuZCBlYWNoIG51dHMgbGV2ZWwgdG8gbWFwXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYGVtLW51dHNyZyBlbS1udXRzcmctJHtpfWApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdsdmwnLCBpKSAvL3RvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggbnV0cyBsZXZlbHNcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgLy9hZGQga29zb3ZvXHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VvID09ICdFVVInICYmIChwcm9qID09ICczMDM1JyB8fCBwcm9qID09ICc0MzI2JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQga29zb3ZvIG1hbnVhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkS29zb3ZvQm9yZGVyKGNvbnRhaW5lciwgcGF0aEZ1bmN0aW9uLCBwcm9qLCBzY2FsZSwgbnV0c1llYXIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG51dHNMZXZlbCBpcyBub3QgJ21peGVkJ1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy5udXRzcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGNvdW50cnkgYm91bmRhcmllc1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLmNudGJuKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY250Ym4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNudGJuJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGhpcy5nZW9KU09Ocy5jbnRibilcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZXUgPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5lZnRhID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY2MgPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5vdGggPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5jbyA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGJuKSA9PiAnZW0tYm4tJyArIGJuLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2xhc3NMaXN0ID0gW11cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZXUgPT09ICdUJykgY2xhc3NMaXN0LnB1c2goJ2VtLWJuLWV1JylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5lZnRhID09PSAnVCcpIGNsYXNzTGlzdC5wdXNoKCdlbS1ibi1lZnRhJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5jYyA9PT0gJ1QnKSBjbGFzc0xpc3QucHVzaCgnZW0tYm4tY2MnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLm90aCA9PT0gJ1QnKSBjbGFzc0xpc3QucHVzaCgnZW0tYm4tb3RoJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5jbyA9PT0gJ1QnKSBjbGFzc0xpc3QucHVzaCgnZW0tYm4tY28nKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NMaXN0LmpvaW4oJyAnKSAvLyBVc2Ugam9pbiB3aXRoIGEgc3BhY2UgdG8gY3JlYXRlIGEgdmFsaWQgY2xhc3Mgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IE5VVFMgYm91bmRhcmllc1xyXG4gICAgICAgIGlmICh0aGlzLmdlb0pTT05zLm51dHNibiAmJiBudXRzTGV2ZWwgIT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5nZW9KU09Ocy5udXRzYm4uc29ydChmdW5jdGlvbiAoYm4xLCBibjIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBibjIucHJvcGVydGllcy5sdmwgLSBibjEucHJvcGVydGllcy5sdmxcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1udXRzYm4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLW51dHNibicpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMubnV0c2JuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuZXUgPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5lZnRhID09ICdUJykgcmV0dXJuIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJuLnByb3BlcnRpZXMuY2MgPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5vdGggPT0gJ1QnKSByZXR1cm4gYm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm4ucHJvcGVydGllcy5jbyA9PSAnVCcpIHJldHVybiBiblxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcHMgPSBibi5wcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9LT1NPVk9cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuaWQgPiAxMDAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbS1rb3Nvdm8tYm4nXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jbyA9PT0gJ1QnKSByZXR1cm4gJ2VtLWJuLWNvJ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsID0gWydlbS1ibi0nICsgcHJvcHMubHZsXVxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGJuLm90aCA9PT0gXCJUXCIpIGNsLnB1c2goXCJibi1vdGhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsLmpvaW4oJyAnKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyB3b3JsZCBib3VuZGFyaWVzXHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvSlNPTnMud29ybGRibikge1xyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXdvcmxkYm4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXdvcmxkYm4nKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLmdlb0pTT05zLndvcmxkYm4pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibi5wcm9wZXJ0aWVzLlBPTF9TVEFUID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Rpc3B1dGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZW0tYm4tZCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuQ09BU19GTEFHID09PSAnVCcgPyAnZW0tYm4tY28nIDogJ2VtLXdvcmxkYm4nXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLy5hdHRyKFwiaWRcIiwgKGJuKSA9PiBibi5wcm9wZXJ0aWVzLkNOVFJfQk5fSUQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5nZW9KU09Ocy5rb3Nvdm8pIHtcclxuICAgICAgICAgICAgLy9hZGQga29zb3ZvIHRvIHdvcmxkIG1hcHNcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1rb3Nvdm8tYm4nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWtvc292by1ibicpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuZ2VvSlNPTnMua29zb3ZvKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEtvc292b0JvcmRlcihjb250YWluZXIsIHBhdGhGdW5jdGlvbiwgcHJvaiwgc2NhbGUsIG51dHNZZWFyKSB7XHJcbiAgICAgICAgbGV0IGtvc292b0ZlYXR1cmUgPSBrb3Nvdm9CbkZlYXR1cmVzW251dHNZZWFyXSA/IGtvc292b0JuRmVhdHVyZXNbbnV0c1llYXJdW3Byb2pdW3NjYWxlXSA6IGtvc292b0JuRmVhdHVyZXNbMjAyNF1bcHJval1bc2NhbGVdXHJcbiAgICAgICAgbGV0IGtvc292b0JuID0gZmVhdHVyZShrb3Nvdm9GZWF0dXJlLCAnbnV0c2JuXzEnKS5mZWF0dXJlc1xyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWtvc292by1ibicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1rb3Nvdm8tYm4gZW0tYm4tY2MnKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdGEoa29zb3ZvQm4pXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIHBhdGhGdW5jdGlvbilcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGRzIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzIHRvIHRoZSBtYXBcclxuICAgICAqIEUuZy5cclxuICAgICAqIG1hcC5nZW9tZXRyaWVzKFtcclxuICAgICAqICB7IGlkOiAncmVnaW9ucycsIGZlYXR1cmVzOiBnZW9KU09OLmZlYXR1cmVzLCBjbGFzczogKGZlYXR1cmUpID0+ICdyZWdpb24nIH0sXHJcbiAgICAgKiAgeyBpZDogJ2JvcmRlcnMnLCBmZWF0dXJlczogYm9yZGVyc0RhdGEsIGNsYXNzOiAoZmVhdHVyZSkgPT4gJ2JvcmRlcicgfVxyXG4gICAgICogXSlcclxuICAgICAqIEBwYXJhbSBnZW9tZXRyaWVzIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggY29udGFpbmluZyBhbiBhcnJheSBvZiBnZW9KU09OIGZlYXR1cmVzXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyIGQzIHNlbGVjdGlvbiBvZiB0aGUgcGFyZW50IHRoYXQgd2UgYXBwZW5kIHRoZSBnZW9tZXRyaWVzIHRvXHJcbiAgICAgKiBAcGFyYW0gcGF0aEZ1bmN0aW9uIGQzIHBhdGggZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgb3V0LmFkZFVzZXJHZW9tZXRyaWVzVG9NYXAgPSBmdW5jdGlvbiAoZ2VvbWV0cmllcywgY29udGFpbmVyLCBwYXRoRnVuY3Rpb24pIHtcclxuICAgICAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb21ldHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBncm91cCA9IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBnZW9tZXRyeS5zdGF0aXN0aWNhbFJlZ2lvbnMgPyAnZW0tdXNlci1yZWdpb25zJyA6ICcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZ2VvbWV0cnkuY2xhc3MgPyBnZW9tZXRyeS5jbGFzcyA6ICcnKVxyXG5cclxuICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gZ3JvdXAuc2VsZWN0QWxsKCdwYXRoJykuZGF0YShnZW9tZXRyeS5mZWF0dXJlcykuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgcGF0aEZ1bmN0aW9uKVxyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgY3VzdG9tIGNhbGwgY2hhaW4gbW9kaWZpY2F0aW9ucyB0aHJvdWdoIG9uRWFjaFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGdlb21ldHJ5Lm9uRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkub25FYWNoKGVsZW1lbnRzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBtYXBUZW1wbGF0ZSB9IGZyb20gJy4vbWFwLXRlbXBsYXRlJ1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGluc2V0IG1hcHMgZm9yIGEgbWFwIHRlbXBsYXRlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYnVpbGRJbnNldHMgPSBmdW5jdGlvbiAob3V0LCB3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICBpZiAoIW91dC5pbnNldEJveFBvc2l0aW9uXykge1xyXG4gICAgICAgIG91dC5pbnNldEJveFBvc2l0aW9uXyA9IFtvdXQud2lkdGhfIC0gb3V0Lmluc2V0Qm94V2lkdGhfIC0gMiAqIG91dC5pbnNldEJveFBhZGRpbmdfLCAyICogb3V0Lmluc2V0Qm94UGFkZGluZ19dXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIGNvbnRhaW5lciB0byBkcmF3aW5nIGdyb3VwXHJcbiAgICAvLyBDYW5ub3QgcmVhZCBwcm9wZXJ0aWVzIG9mIHVuZGVmaW5lZCAocmVhZGluZyAnc3ZnSWQnKVxyXG4gICAgbGV0IHN2ZyA9IHNlbGVjdCgnIycgKyBvdXQuc3ZnSWRfKVxyXG4gICAgbGV0IGRyYXdpbmdHcm91cCA9IHN2Zy5zZWxlY3QoJyNlbS1kcmF3aW5nLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgY29uc3QgaW5nID0gZHJhd2luZ0dyb3VwXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWluc2V0cy1ncm91cCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWluc2V0cycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG91dC5pbnNldEJveFBvc2l0aW9uX1swXSArICcsJyArIG91dC5pbnNldEJveFBvc2l0aW9uX1sxXSArICcpJylcclxuXHJcbiAgICBpZiAob3V0Lmluc2V0c18gPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgIC8vaWYgbmVlZGVkLCB1c2UgZGVmYXVsdCBpbnNldCBjb25maWdcclxuICAgICAgICBvdXQuaW5zZXRzXyA9IGRlZmF1bHRJbnNldENvbmZpZyhvdXQuaW5zZXRCb3hXaWR0aF8sIG91dC5pbnNldEJveFBhZGRpbmdfKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFwcGVuZCBlYWNoIGluc2V0IHRvIG1hcFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuaW5zZXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG91dC5pbnNldHNfW2ldXHJcbiAgICAgICAgY29uZmlnLnN2Z0lkID0gY29uZmlnLnN2Z0lkIHx8ICdpbnNldCcgKyBjb25maWcuZ2VvICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpXHJcblxyXG4gICAgICAgIC8vZ2V0IHN2ZyBlbGVtZW50LlxyXG4gICAgICAgIGxldCBzdmcgPSBzZWxlY3QoJyMnICsgY29uZmlnLnN2Z0lkKVxyXG4gICAgICAgIGlmIChzdmcuc2l6ZSgpID09IDApIHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGl0IGFzIGFuIGVtYmVkZWQgU1ZHIGlmIGl0IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBjb25maWcueCA9PSB1bmRlZmluZWQgPyBvdXQuaW5zZXRCb3hQYWRkaW5nXyA6IGNvbmZpZy54XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBjb25maWcueSA9PSB1bmRlZmluZWQgPyBvdXQuaW5zZXRCb3hQYWRkaW5nXyArIGkgKiAob3V0Lmluc2V0Qm94UGFkZGluZ18gKyBvdXQuaW5zZXRCb3hXaWR0aF8pIDogY29uZmlnLnlcclxuICAgICAgICAgICAgY29uc3QgZ2dlbyA9IGluZ1xyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0taW5zZXQtJyArIGNvbmZpZy5zdmdJZClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1pbnNldCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKScpXHJcbiAgICAgICAgICAgIGdnZW8uYXBwZW5kKCdzdmcnKS5hdHRyKCdpZCcsIGNvbmZpZy5zdmdJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGJ1aWxkIGluc2V0XHJcbiAgICAgICAgLy8gR0lTQ08tMjY3NiAtIFBUIGF6b3JlcyBpbnNldCBoYXMgMiBpbnNldHMgd2l0aCB0aGUgc2FtZSBHZW8sIHNvIHNlY29uZCB3YXMgb3ZlcnJpZGluZyBmaXJzdDpcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzX1tjb25maWcuZ2VvXSkge1xyXG4gICAgICAgICAgICAvL2lmIGluc2V0IGFscmVhZHkgZXhpc3RzIGluIG1hcCB3aXRoIHNhbWUgZ2VvLCB0aGVuIHB1c2ggYm90aCB0byBhbiBhcnJheVxyXG4gICAgICAgICAgICBsZXQgaW5zZXQgPSBidWlsZEluc2V0KGNvbmZpZywgb3V0LCB3aXRoQ2VudGVyUG9pbnRzKVxyXG4gICAgICAgICAgICBpbnNldC5idWlsZE1hcFRlbXBsYXRlQmFzZSgpXHJcbiAgICAgICAgICAgIG91dC5pbnNldFRlbXBsYXRlc19bY29uZmlnLmdlb10gPSBbb3V0Lmluc2V0VGVtcGxhdGVzX1tjb25maWcuZ2VvXSwgaW5zZXRdXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGluc2V0ID0gYnVpbGRJbnNldChjb25maWcsIG91dCwgd2l0aENlbnRlclBvaW50cylcclxuICAgICAgICAgICAgbGV0IGRyYXduSW5zZXQgPSBpbnNldC5idWlsZE1hcFRlbXBsYXRlQmFzZSgpXHJcbiAgICAgICAgICAgIG91dC5pbnNldFRlbXBsYXRlc19bY29uZmlnLmdlb10gPSBkcmF3bkluc2V0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLyoqIEJ1aWxkIHRlbXBsYXRlIGZvciBpbnNldCwgYmFzZWQgb24gbWFpbiBvbmUgKi9cclxuY29uc3QgYnVpbGRJbnNldCA9IGZ1bmN0aW9uIChjb25maWcsIG91dCwgd2l0aENlbnRlclBvaW50cykge1xyXG4gICAgLy9UT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoYXRcclxuXHJcbiAgICAvL2NvcHkgbWFwXHJcbiAgICAvL2ZvcihsZXQga2V5X18gaW4gbWFwKSB7XHJcbiAgICAvL210W2tleV9fXSA9IG1hcFtrZXlfX107XHJcbiAgICAvL31cclxuXHJcbiAgICBjb25zdCBtdCA9IG1hcFRlbXBsYXRlKGNvbmZpZywgd2l0aENlbnRlclBvaW50cylcclxuXHJcbiAgICAvL2RlZmluZSBkZWZhdWx0IHZhbHVlcyBmb3IgaW5zZXQgY29uZmlnc1xyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9XHJcbiAgICBjb25maWcucHJvaiA9IGNvbmZpZy5wcm9qIHx8IF9kZWZhdWx0Q1JTW2NvbmZpZy5nZW9dXHJcbiAgICBjb25maWcuc2NhbGUgPSBjb25maWcuc2NhbGUgfHwgb3V0Lmluc2V0U2NhbGVfXHJcbiAgICBjb25maWcuZm9vdG5vdGUgPSBjb25maWcuZm9vdG5vdGUgfHwgJydcclxuICAgIGNvbmZpZy5zaG93U291cmNlTGluayA9IGNvbmZpZy5zaG93U291cmNlTGluayB8fCBmYWxzZVxyXG4gICAgY29uZmlnLnpvb21FeHRlbnQgPSBjb25maWcuem9vbUV4dGVudCB8fCBvdXQuaW5zZXRab29tRXh0ZW50X1xyXG4gICAgY29uZmlnLndpZHRoID0gY29uZmlnLndpZHRoIHx8IG91dC5pbnNldEJveFdpZHRoX1xyXG4gICAgY29uZmlnLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQgfHwgb3V0Lmluc2V0Qm94V2lkdGhfXHJcbiAgICBjb25maWcuaW5zZXRzID0gY29uZmlnLmluc2V0cyB8fCBbXVxyXG4gICAgY29uZmlnLmluc2V0VGVtcGxhdGVzID0gY29uZmlnLmluc2V0VGVtcGxhdGVzIHx8IHt9XHJcbiAgICBjb25maWcuY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2sgfHwgdW5kZWZpbmVkXHJcblxyXG4gICAgLy9jb3B5IG1haW4gbWFwIGF0dHJpYnV0ZXNcclxuICAgIDtbXHJcbiAgICAgICAgJ251dHNMZXZlbF8nLFxyXG4gICAgICAgICdudXRzWWVhcl8nLFxyXG4gICAgICAgICdob3ZlckNvbG9yXycsXHJcbiAgICAgICAgLy8nbnV0c2JuU3Ryb2tlXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAvLyAnbnV0c2JuU3Ryb2tlV2lkdGhfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdjbnRyZ0ZpbGxTdHlsZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2NudGJuU3Ryb2tlXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnY250Ym5TdHJva2VXaWR0aF8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ3NlYUZpbGxTdHlsZV8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2RyYXdDb2FzdGFsTWFyZ2luXycsXHJcbiAgICAgICAgJ2NvYXN0YWxNYXJnaW5Db2xvcl8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2NvYXN0YWxNYXJnaW5XaWR0aF8nLCAvLyBERVBSRUNBVEVEXHJcbiAgICAgICAgJ2NvYXN0YWxNYXJnaW5TdGREZXZfJyxcclxuICAgICAgICAnZ3JhdGljdWxlU3Ryb2tlXycsIC8vIERFUFJFQ0FURURcclxuICAgICAgICAnZ3JhdGljdWxlU3Ryb2tlV2lkdGhfJywgLy8gREVQUkVDQVRFRFxyXG4gICAgICAgICdsZ18nLFxyXG4gICAgICAgICdwcm9qZWN0aW9uRnVuY3Rpb25fJyxcclxuICAgICAgICAnZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uXycsXHJcbiAgICAgICAgJ3Byb2Nlc3NDZW50cm9pZHNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgbXRbYXR0XSA9IG91dFthdHRdXHJcbiAgICB9KVxyXG5cclxuICAgIC8vY29weSBzdGF0IG1hcCBhdHRyaWJ1dGVzL21ldGhvZHNcclxuICAgIDtbJ3N0YXQnLCAnc3RhdERhdGEnLCAnbGVnZW5kJywgJ2xlZ2VuZE9iaicsICdub0RhdGFUZXh0JywgJ2xhbmd1YWdlJywgJ3RyYW5zaXRpb25EdXJhdGlvbicsICd0b29sdGlwXycsICdjbGFzc1RvVGV4dF8nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBtdFthdHRdID0gb3V0W2F0dF1cclxuICAgIH0pXHJcblxyXG4gICAgLy9hcHBseSBjb25maWcgdmFsdWVzIGZvciBpbnNldFxyXG4gICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykgbXRba2V5ICsgJ18nXSA9IGNvbmZpZ1trZXldXHJcblxyXG4gICAgbXQuaXNJbnNldCA9IHRydWUgLy8gZmxhZyBmb3IgaW5zZXQtc3BlY2lmaWMgc2V0dGluZ3MgZS5nLiBDU1MgY2xhc3MgZm9yIHRpdGxlc1xyXG4gICAgcmV0dXJuIG10XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgaW5zZXRzIG1hcHMgZnJvbSB0aGUgRE9NXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVtb3ZlSW5zZXRzID0gZnVuY3Rpb24gKG91dCkge1xyXG4gICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICBmb3IgKGxldCB0ZW1wbGF0ZSBpbiBvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGxldCBpZCA9IG91dC5pbnNldFRlbXBsYXRlc19bdGVtcGxhdGVdLnN2Z0lkX1xyXG4gICAgICAgICAgICBsZXQgZXhpc3RpbmcgPSBzZWxlY3QoJyMnICsgaWQpXHJcbiAgICAgICAgICAgIC8vIGlmIChleGlzdGluZykgZXhpc3RpbmcucmVtb3ZlKClcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSBleGlzdGluZy5odG1sKCcnKSAvLyBlbXB0eSB0aGVtLCBidXQgZG9udCByZW1vdmUgdGhlbS5cclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0Lmluc2V0VGVtcGxhdGVzXyA9IHt9IC8vICBHSVNDTy0yNjc2XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IGluc2V0IHNldHRpbmcuXHJcbiAqIEBwYXJhbSB7Kn0gcyBUaGUgd2lkdGggb2YgdGhlIGluc2V0IGJveFxyXG4gKiBAcGFyYW0geyp9IHAgVGhlIHBhZGRpbmdcclxuICovXHJcbmNvbnN0IGRlZmF1bHRJbnNldENvbmZpZyA9IGZ1bmN0aW9uIChzLCBwKSB7XHJcbiAgICBjb25zdCBvdXQgPSBbXHJcbiAgICAgICAgeyBnZW86ICdJQycsIHg6IDAsIHk6IDAsIHdpZHRoOiBzLCBoZWlnaHQ6IDAuMyAqIHMgfSxcclxuICAgICAgICB7IGdlbzogJ0NBUklCJywgeDogMCwgeTogMC4zICogcyArIHAsIHdpZHRoOiAwLjUgKiBzLCBoZWlnaHQ6IHMgfSxcclxuICAgICAgICB7IGdlbzogJ0dGJywgeDogMC41ICogcywgeTogMC4zICogcyArIHAsIHdpZHRoOiAwLjUgKiBzLCBoZWlnaHQ6IDAuNzUgKiBzIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZW86ICdZVCcsXHJcbiAgICAgICAgICAgIHg6IDAuNSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuMDUgKiBzICsgcCxcclxuICAgICAgICAgICAgd2lkdGg6IDAuMjUgKiBzLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDAuMjUgKiBzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZW86ICdSRScsXHJcbiAgICAgICAgICAgIHg6IDAuNzUgKiBzLFxyXG4gICAgICAgICAgICB5OiAxLjA1ICogcyArIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnUFQyMCcsXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDEuMyAqIHMgKyAyICogcCxcclxuICAgICAgICAgICAgd2lkdGg6IDAuNzUgKiBzLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDAuMjUgKiBzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZW86ICdQVDMwJyxcclxuICAgICAgICAgICAgeDogMC43NSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuMyAqIHMgKyAyICogcCxcclxuICAgICAgICAgICAgd2lkdGg6IDAuMjUgKiBzLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDAuMjUgKiBzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBnZW86ICdNVCcsIHg6IDAsIHk6IDEuNTUgKiBzICsgMyAqIHAsIHdpZHRoOiAwLjI1ICogcywgaGVpZ2h0OiAwLjI1ICogcyB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnTEknLFxyXG4gICAgICAgICAgICB4OiAwLjI1ICogcyxcclxuICAgICAgICAgICAgeTogMS41NSAqIHMgKyAzICogcCxcclxuICAgICAgICAgICAgd2lkdGg6IDAuMjUgKiBzLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDAuMjUgKiBzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZW86ICdTSl9TVicsXHJcbiAgICAgICAgICAgIHg6IDAuNSAqIHMsXHJcbiAgICAgICAgICAgIHk6IDEuNTUgKiBzICsgMyAqIHAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLjI1ICogcyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLjI1ICogcyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2VvOiAnU0pfSk0nLFxyXG4gICAgICAgICAgICB4OiAwLjc1ICogcyxcclxuICAgICAgICAgICAgeTogMS41NSAqIHMgKyAzICogcCxcclxuICAgICAgICAgICAgd2lkdGg6IDAuMjUgKiBzLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDAuMjUgKiBzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyp7Z2VvOlwiSUNcIiwgeDowLCB5OjB9LCB7Z2VvOlwiUkVcIiwgeDpkZCwgeTowfSwge2dlbzpcIllUXCIsIHg6MipkZCwgeTowfSxcclxuXHRcdHtnZW86XCJHUFwiLCB4OjAsIHk6ZGR9LCB7Z2VvOlwiTVFcIiwgeDpkZCwgeTpkZH0sIHtnZW86XCJHRlwiLHNjYWxlOlwiMTBNXCIsIHg6MipkZCwgeTpkZH0sXHJcblx0XHR7Z2VvOlwiUFQyMFwiLCB4OjAsIHk6MipkZH0sIHtnZW86XCJQVDMwXCIsIHg6ZGQsIHk6MipkZH0sIHtnZW86XCJNVFwiLCB4OjIqZGQsIHk6MipkZH0sXHJcblx0XHR7Z2VvOlwiTElcIixzY2FsZTpcIjAxTVwiLCB4OjAsIHk6MypkZH0sIHtnZW86XCJTSl9TVlwiLCB4OmRkLCB5OjMqZGR9LCB7Z2VvOlwiU0pfSk1cIixzY2FsZTpcIjAxTVwiLCB4OjIqZGQsIHk6MypkZH0sKi9cclxuICAgICAgICAvL3tnZW86XCJDQVJJQlwiLCB4OjAsIHk6MzMwfSwge2dlbzpcIklTXCIsIHg6ZGQsIHk6MzMwfVxyXG4gICAgXVxyXG4gICAgLy9oaWRlIGdyYXRpY3VsZSBmb3IgaW5zZXRzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykgb3V0W2ldLmRyYXdHcmF0aWN1bGUgPSBmYWxzZVxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKiogRGVmYXVsdCBDUlMgZm9yIGVhY2ggZ2VvIGFyZWEgKi9cclxuY29uc3QgX2RlZmF1bHRDUlMgPSB7XHJcbiAgICBFVVI6ICczMDM1JyxcclxuICAgIElDOiAnMzI2MjgnLFxyXG4gICAgR1A6ICczMjYyMCcsXHJcbiAgICBNUTogJzMyNjIwJyxcclxuICAgIEdGOiAnMzI2MjInLFxyXG4gICAgUkU6ICczMjc0MCcsXHJcbiAgICBZVDogJzMyNzM4JyxcclxuICAgIE1UOiAnMzAzNScsXHJcbiAgICBQVDIwOiAnMzI2MjYnLFxyXG4gICAgUFQzMDogJzMyNjI4JyxcclxuICAgIExJOiAnMzAzNScsXHJcbiAgICBJUzogJzMwMzUnLFxyXG4gICAgU0pfU1Y6ICczMDM1JyxcclxuICAgIFNKX0pNOiAnMzAzNScsXHJcbiAgICBDQVJJQjogJzMyNjIwJyxcclxuICAgIFdPUkxEOiAnNTQwMzAnLFxyXG59XHJcbiIsIi8vIG1peGVkIG51dHMgZG9udCBkcmF3IG51dHNibiBzbyB3ZSBhZGQgdGhlbSBtYW51YWxseVxyXG5leHBvcnQgY29uc3Qga29zb3ZvQm5GZWF0dXJlcyA9IHtcclxuICAyMDIxOntcclxuICAgIDMwMzU6IHtcclxuICAgICAgJzAzTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1szMDYxLDEzMDNdLFstMTUyLC01OV0sWy0zMiwtNjZdLFstNjUsNzJdLFstOTYsN10sWy0xNiw1OV0sWy02NCwxOV0sWy01NiwtMzldLFstMTIwLDM5XSxbLTE4NCwtMTldLFstMTYsMjZdLFszMiw1Ml0sWy0xNiw3Ml0sWzI0LDQwXSxbOCwxODNdXSxbWzI4ODUsMF0sWy04LDQ2XSxbLTY1LDg1XSxbLTQwLC03XSxbLTQwLDQwXSxbMCwxMTFdLFs4MCwxM10sWzI1LDQ2XSxbNzIsMTNdLFs0MCw5OF0sWy01NiwxMThdLFsxNDQsMTk2XSxbLTI0LDc5XSxbODgsNTldLFstMjQsOThdLFstOCwyMF0sWzI0LDM5XSxbOCw1Ml0sWzQ4LDcyXSxbLTg4LDEyNV1dLFtbODI1LDI2MzhdLFstMTEyLC05OF0sWy03MiwtN10sWy04OCwtMTE4XSxbLTE3NiwtMzldLFs1NiwtOTFdLFs4OCwtMzNdLFsyNCwtNTNdLFs1NiwtMzldLFsyNCwtOTFdLFstNTYsLTQ2XSxbMjQsLTEwNV0sWy01NiwtOTJdLFstMTA0LDBdLFstNDgsLTEwNF0sWy0xNiwtNDBdLFstNTcsN10sWy00MCwtNTNdLFstMTYsLTc4XSxbMTEzLC0xMThdLFstOTcsLTY1XSxbLTg4LC05OV0sWy04MCwyMF0sWy04MCwtMzldLFstMjQsLTEzXV0sW1sxMDk4LDIzMDRdLFstMTkzLDY2XSxbMjQsMzldLFstMTYsMzldLFs2NSwxM10sWzAsMzNdLFstNjUsNzldLFstODgsNjVdXSxbWzIzMDgsMTY4OV0sWy0xNTMsLTIwXSxbLTY0LDU5XSxbLTQwLDddLFstOTYsLTI3XSxbLTEwNCwxMzhdLFstOCw5Ml0sWy0zMiw3OF0sWy02NCwyNl0sWy0zMiwtNTldLFstMjQsMF0sWy01Niw4Nl0sWy00MCwxMzddLFstMjUsNjVdLFstNTYsMF0sWy01Niw0Nl0sWy02NCwtNzJdLFstMTIwLDUzXSxbLTg4LC00MF0sWy04OCw0Nl1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzM3Ljc2MTA0NDc1Mjc3NzU2NSwzOC41NDczNDIwNTYyNjExM10sXCJ0cmFuc2xhdGVcIjpbNTE2NzAyMC4wMzc0NTE4NzMsMjIwMjI3OC41MTAzMjU1MTY2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDQsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwNSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAxLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDIsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMyxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzEwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1s5NjIsMF0sWy0yOSw3NV0sWzQ4LDEzMV0sWzIxLDM1XSxbMTEsMzhdLFszMiwxMTddLFstMjQsNDRdXSxbWzEwMjEsNDQwXSxbLTY0LC0yOV0sWy03MCwzNl0sWy0xMjAsMl0sWzMsMTIxXV0sW1s3NzAsNTcwXSxbLTEyNiwxNl0sWy00MCw5MV0sWy00NSw0XSxbLTUxLDkzXSxbLTE0Miw0XV0sW1syNzUsODkxXSxbLTEzMSwtOTldLFszMCwtMzZdLFsyNCwtMzFdLFstNiwtODZdLFstOTgsLTg2XSxbMTMsLTY0XSxbLTI3LC0zOF0sWy04MCwtMzFdXSxbWzM2Niw3NzhdLFstMzcsMjJdLFstNTQsOTFdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlsxMTMuMjA5OTQ0ODUxMzA5NywxMTQuMTI3ODIwODEzMDM4MDFdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA1LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDQsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMyxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAxLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDIsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcyME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbNTM2LDBdLFstMjQsNDVdLFsxNSwzMF0sWzQ1LDkyXSxbLTEsNDRdLFstMiwzN11dLFtbNTY5LDI0OF0sWy0xMzAsOV0sWy0xMCw2NF1dLFtbNDI5LDMyMV0sWy02NCwxMF0sWy03OCw5NF0sWy04MywxM11dLFtbMTUzLDUwMl0sWy03MywtNTFdLFsyNiwtODRdLFstNDgsLTUzXSxbLTMsLTUyXSxbLTU1LC0yNV1dLFtbMjA0LDQzOF0sWy01MSw2NF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzIwMy4xMjMwOTYwMTQ5NDEyNCwyMDIuNTY1NTE0NjMwMzEyNDZdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA1LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDQsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMyxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAxLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDIsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICc2ME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMzEwLDEzOF0sWy0zNiwtMl0sWy00MCw0Ml1dLFtbMjM0LDE3OF0sWy0xMjMsNjVdXSxbWzg0LDI3OF0sWy04NCwtMTQ3XV0sW1sxMTEsMjQzXSxbLTI3LDM1XV0sW1syOTIsMF0sWzE4LDEzOF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzM3Mi44NDI4MTczMDIxNTYzMywzNjQuODc2MTE4OTg1ODA1MzZdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDA0LFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDMsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6MTAwMDAwMSxcImx2bFwiOjEsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiVFwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjoxMDAwMDAyLFwibHZsXCI6MSxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJUXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOjEwMDAwMDUsXCJsdmxcIjoxLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIlRcIixcImNvXCI6XCJGXCJ9fV19fX1cclxuICAgIH0sXHJcbiAgICA0MzI2OiB7XHJcbiAgICAgICcwM00nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMTkwMCwxMjc1XSxbLTMwLDI3XSxbLTI3LC0xM10sWy0zNCwyM10sWy04Nyw2XSxbMjUsNTldLFsxLDcwXSxbMjAsMzRdLFsyNCwxNjddXSxbWzE3OTIsMTY0OF0sWy0xMTYsMV0sWy02Miw3N10sWy04OSwtOF0sWy02MCwxNDhdLFs3LDg2XSxbLTQsMTVdLFstMTMsNjBdLFstNDUsMjhdLFstMzMsLTQ4XSxbLTI2LDRdLFstMzEsMTQyXSxbLTExLDUzXSxbNSw0M10sWy0xOSw0NF0sWy0zOSw4XSxbLTQwLDQ5XSxbLTUyLC01OV0sWy05Myw3MV0sWy0zOCwtNl0sWy0xNiwtMjZdXSxbWzk0NSwyMzg4XSxbLTU0LDI3XSxbLTIwLDI4XSxbLTIyLC0zXSxbLTE3LDIyXSxbLTI1LDFdLFstMTAsMTBdLFs0LDE3XSxbMjcsMTRdLFstMTUsMjldLFsxLDE2XSxbNjgsMV0sWy04LDE2XSxbLTUsMzBdLFstMTQsMjldLFstMjcsNDJdLFstMjUsMjJdLFstMzAsNDFdXSxbWzc3MywyNzMwXSxbLTg5LC02OV0sWy02NCwtNF0sWy04MiwtOTJdLFstMTMzLC0xNV0sWzI3LC05M10sWzY0LC00M10sWzE2LC01MF0sWzM4LC00NF0sWzksLTc1XSxbLTQ4LC01MV0sWzUsLTQxXSxbNiwtNTBdLFstNTIsLTg0XSxbLTc4LDE0XSxbLTM1LC02Nl0sWy0zMywtNjFdLFstNDUsMTFdLFstMzUsLTQyXSxbLTE4LC03Ml0sWzMzLC03MV0sWzQ4LC01NV1dLFtbMTAxNywyMzMwXSxbLTcyLDU4XV0sW1szMDcsMTY3N10sWy0zNiwtMTJdLFstMjUsLTIxXSxbLTI2LC0xMF0sWy03NiwtOTBdLFstMTcsNF0sWy0zMCwzMV0sWy01MiwtMTRdLFstMjYsLTIzXSxbLTE5LDFdXSxbWzIzMTksMTE4NV0sWy0xMTYsLTMyXSxbLTM5LC01Ml0sWy00Miw3MF0sWy02OCwyM10sWy0xMiw1OF0sWy00MywyM10sWy00MiwtMjNdLFstNTcsMjNdXSxbWzIwNDQsMF0sWy00LDQzXSxbLTM4LDgyXSxbLTM0LDldLFstMjQsNDNdLFsxMyw5N10sWzYxLDRdLFszMiw0MV0sWzQ5LDBdLFszNyw4Ml0sWy0yNiwxMThdLFsxMzAsMTY3XSxbLTgsNzNdLFs3NCw0Nl0sWy0yLDE4XSxbLTksOTJdLFsyNCwzNV0sWzcsNDldLFs0OCw1Ml0sWy01NSwxMzRdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOlswLjAwMDYwMzgzMzkyODM5MDg5NzQsMC4wMDAzNjk4MzQ3NTU2Nzc2NTk3NV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDcsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX0sXHJcbiAgICAgICcxME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbNjU5LDQzOV0sWy01NCwxN10sWzE3LDExMV1dLFtbNjIyLDU2N10sWy05MywzMV0sWy0yNSw5Ml0sWy0zNiwxMV0sWy0yOSw5N10sWy0yMywxXSxbLTYzLDNdXSxbWzMyOCw4MjJdLFstMzMsNzRdLFstMjcsNDRdXSxbWzI2OCw5NDBdLFstNzIsLTQ0XSxbLTM4LC0zMV0sWzI3LC04Nl0sWy0xNCwtNjVdLFstODEsLTc4XSxbMTYsLTU4XV0sW1szNTMsODAyXSxbLTI1LDIwXV0sW1sxMDYsNTc4XSxbLTQxLC0xOV0sWy02NSwtMjhdXSxbWzgwNSw0MDhdLFstNTQsLTIxXSxbLTkyLDUyXV0sW1s3MDksMF0sWy0yMiw3Ml0sWzAsMTddLFs0MCwzNl0sWzE4LDY3XSxbNTMsMTAxXSxbMTYsNjRdLFstOSw1MV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAxNzQwNTIxNTQ3OTExNTI0LDAuMDAxMDc0MDk0NTU2MzgyOTkwN10sXCJ0cmFuc2xhdGVcIjpbMjAuMzUyOTI4MzkzMDAwMDcsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX0sXHJcbiAgICAgICcyME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMzgwLDI1Ml0sWy0yMSwyNl0sWzAsNDhdXSxbWzM1OSwzMjZdLFstNDksMTddLFstNTYsMTA3XSxbLTUxLDExXV0sW1sxODksNDcyXSxbLTM0LDY4XV0sW1sxNTUsNTQwXSxbLTY2LC0zOV0sWzE4LC02Nl0sWy01NCwtNjhdLFs4LC0zNV1dLFtbNjEsMzMyXSxbLTIxLC0xM10sWy0xMCwtMTJdLFstMTMsNV0sWy0xNywtN11dLFtbNDY0LDIzNF0sWy04NCwxOF1dLFtbNDA5LDBdLFstMTQsNDZdLFs2MSwxMTBdLFs4LDc4XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDMwMTgyNzY4MzE4OTY0OTgsMC4wMDE4Njk3MjAxNTM3MDM3MjQ1XSxcInRyYW5zbGF0ZVwiOlsyMC4zNTI5MjgzOTMwMDAwNyw0Mi4yNjI4MTc2NDMwMDAwNl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDAyLFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDAzLFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA0LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA1LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA3LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDAxLFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJsdmxcIjowLFwiaWRcIjoxMDAwMDA4LFwiY29cIjpcIkZcIixcIm90aFwiOlwiRlwiLH19XX19fSxcclxuICAgICAgJzYwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1syMzUsMTU2XSxbLTEzLDQ2XV0sW1syMjIsMjAyXSxbLTk2LDg0XV0sW1sxMTcsMjkzXSxbLTIxLDQyXV0sW1s5NiwzMzVdLFstNTgsLTEyOV1dLFtbMTI2LDI4Nl0sWy05LDddXSxbWzM4LDIwNl0sWy0zOCwtMTddXSxbWzI4NywxNDVdLFstNTIsMTFdXSxbWzI1MywwXSxbMzQsMTQ1XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDQ4Nzk3MjI4MjIyOTk1NjQsMC4wMDMwMTM4NzcyNjI2ODY2MDA2XSxcInRyYW5zbGF0ZVwiOlsyMC4zNTI5MjgzOTMwMDAwNzQsNDIuMjYyODE3NjQzMDAwMDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNixcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwMSxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwNyxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwibHZsXCI6MCxcImlkXCI6MTAwMDAwOCxcImNvXCI6XCJGXCIsXCJvdGhcIjpcIkZcIix9fV19fX1cclxuICAgIH1cclxuICB9LFxyXG4gIDIwMjQ6e1xyXG4gICAgMzAzNToge1xyXG4gICAgICAnMDNNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzcyOCwxNTA4XSxbLTQ4LDEyXSxbLTIyLDE4XSxbLTE1LC01XSxbLTE2LDEzXSxbLTIyLC00XSxbLTEwLDhdLFswLDEzXSxbMjEsMTNdLFstMTYsMTddLFswLDEzXSxbNTgsOV0sWy01LDhdLFstMTAsMjJdLFstMTYsMTddLFstMjcsMjVdLFstMjEsMTNdLFstMzIsMjZdXSxbWzE5MTIsMF0sWy02LDMwXSxbLTQyLDUxXSxbLTMyLDBdLFstMjEsMzBdLFswLDY5XSxbNTMsOF0sWzIxLDM1XSxbNDMsNF0sWzI2LDYwXSxbLTM3LDgxXSxbOTYsMTI5XSxbLTE2LDUxXSxbNTgsNDNdLFswLDldLFstMjEsNjRdLFsxNiwyNl0sWzUsMzRdLFszMiw0M10sWy01OCw4NV1dLFtbMjUwLDk0Ml0sWy0yNywtMTNdLFstMjEsLTE3XSxbLTIxLC04XSxbLTU5LC03M10sWy0xNiwwXSxbLTI2LDE3XSxbLTQzLC0xM10sWy0yMSwtMjFdLFstMTYsMF1dLFtbMTY1Nyw4NjFdLFstMjcsMTNdLFstMjEsLTEzXSxbLTMyLDEzXSxbLTc0LC05XSxbMTYsNDddLFstNiw0N10sWzExLDI2XSxbNSwxMjBdXSxbWzE1MjksMTEwNV0sWy0xMDAsLTE3XSxbLTY0LDQ3XSxbLTc1LC0xN10sWy02Myw5NF0sWy02LDYwXSxbLTUsMTNdLFstMTYsMzhdLFstNDIsMTNdLFstMjIsLTM4XSxbLTIxLDBdLFstNDIsOTRdLFstMTYsMzRdLFswLDMwXSxbLTIxLDMwXSxbLTMyLDBdLFstMzgsMzBdLFstNDIsLTQ3XSxbLTg1LDM5XSxbLTMyLC05XSxbLTEwLC0yMV1dLFtbNTQ3LDE3MjZdLFstNjksLTYwXSxbLTUzLC0xM10sWy01OSwtNzNdLFstMTExLC0yNV0sWzMyLC02MF0sWzU4LC0yMl0sWzE2LC0zNF0sWzM3LC0yNl0sWzE2LC01MV0sWy0zNywtMzldLFs1LC0zMF0sWzExLC0zNF0sWy0zNywtNjRdLFstNjQsNF0sWy0yNiwtNTFdLFstMjIsLTQ3XSxbLTQyLDRdLFstMjEsLTM0XSxbLTExLC01Ml0sWzM3LC00N10sWzQzLC0zMF1dLFtbNzk3LDE0NzhdLFstNjksMzBdXSxbWzIwMjksODUyXSxbLTk2LC0zOF0sWy0zMiwtMzldLFstNDIsNDNdLFstNTksNF0sWy0xNiwzOV0sWy00MiwxM10sWy0zMiwtMjJdLFstNTMsOV1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzU2Ljk3NjI5NjA4MzYxMTE5LDU4LjkxNTM0NjY2NTM2MzE5XSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAzXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA4XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA2XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAyXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAxXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA0XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA1XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA3XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICcxME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMjQyLDUwOF0sWy0zMyw0N10sWy0yNywyN11dLFtbNjM3LDBdLFstMjUsNDZdLFstMiwxMl0sWzMwLDI5XSxbNyw0N10sWzM0LDc1XSxbNyw0NV0sWy0xMiwzM11dLFtbODMsMzE4XSxbLTMyLC0xOF0sWy01MSwtMjZdXSxbWzU1MiwyOTBdLFstNDYsNV0sWzMsNzhdXSxbWzUwOSwzNzNdLFstNzksOF0sWy0zMCw1OV0sWy0zMCwzXSxbLTM0LDYyXSxbLTE5LC0xXSxbLTUyLC02XV0sW1sxODIsNTgyXSxbLTU1LC0zOV0sWy0yOCwtMjVdLFszMCwtNTZdLFstNSwtNDVdLFstNTksLTYyXSxbMTgsLTM3XV0sW1syNjUsNDk4XSxbLTIzLDEwXV0sW1s2NzYsMjg3XSxbLTQzLC0yMV0sWy04MSwyNF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzE3MS4wNzQ0OTgyNzQzMzM4MiwxNzQuNzIxNDU3NjM2NDU1MDldLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fSxcclxuICAgICAgJzIwTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1s1MCwxOTFdLFstMTcsLTExXSxbLTgsLTEwXSxbLTExLDFdLFstMTQsLTZdXSxbWzMwNSwyMjRdLFstNDQsNl0sWy01OCw2OF0sWy00NCwyXV0sW1sxMDksMzUwXSxbLTUyLC0zNl0sWzIxLC00NV0sWy0zOCwtNTRdLFsxMCwtMjRdXSxbWzE1OSwzMDBdLFstMTQsNl1dLFtbMTQ1LDMwNl0sWy0zNiw0NF1dLFtbMzgxLDBdLFstMTcsMzFdLFs0MSw4NV0sWy0xLDU3XV0sW1s0MDQsMTczXSxbLTc0LDJdXSxbWzMzMCwxNzVdLFstMjAsMTVdLFstNSwzNF1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzI4Ni4xMzI5NDM1NjA3NTc5NSwyOTAuNTM2ODIzODQxMTkxXSxcInRyYW5zbGF0ZVwiOls1MTY3MDIwLjAzNzQ1MTg3MywyMjAyMjc4LjUxMDMyNTUxNjZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA3XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAzXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA1XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA2XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA0XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA4XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAxXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAyXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX0sXHJcbiAgICAgICc2ME0nOntcInR5cGVcIjpcIlRvcG9sb2d5XCIsXCJhcmNzXCI6W1tbMjU4LDExMV0sWy00NywxXV0sW1szMiwxMjNdLFstMzIsLTE3XV0sW1syMTEsMTEyXSxbLTE2LDMyXV0sW1sxOTUsMTQ0XSxbLTk0LDQ5XV0sW1s3MCwyMjVdLFstMzgsLTEwMl1dLFtbMTAxLDE5M10sWy04LDRdXSxbWzkzLDE5N10sWy0yMywyOF1dLFtbMjQzLDBdLFsxNSwxMTFdXV0sXCJ0cmFuc2Zvcm1cIjp7XCJzY2FsZVwiOls0NDcuOTg5NDMxNjQyMTI1ODUsNDUxLjk0NjE3MDQxOTYzMDVdLFwidHJhbnNsYXRlXCI6WzUxNjcwMjAuMDM3NDUxODczLDIyMDIyNzguNTEwMzI1NTE2Nl19LFwib2JqZWN0c1wiOntcIm51dHNibl8xXCI6e1widHlwZVwiOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXCJnZW9tZXRyaWVzXCI6W3tcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDdcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDFcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbMl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDJcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbM10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDNcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNF0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDVcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNV0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDZcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbNl0sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDRcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19LHtcInR5cGVcIjpcIkxpbmVTdHJpbmdcIixcImFyY3NcIjpbN10sXCJwcm9wZXJ0aWVzXCI6e1wiaWRcIjpcIjEwMDAwMDhcIixcImx2bFwiOjAsXCJldVwiOlwiRlwiLFwiZWZ0YVwiOlwiRlwiLFwiY2NcIjpcIlRcIixcIm90aFwiOlwiRlwiLFwiY29cIjpcIkZcIn19XX19fVxyXG4gICAgfSxcclxuICAgIDQzMjY6IHtcclxuICAgICAgJzAzTSc6e1widHlwZVwiOlwiVG9wb2xvZ3lcIixcImFyY3NcIjpbW1sxNTQzLDBdLFstNCwzMl0sWy0yOCw2NV0sWy0yNCw1XSxbLTE5LDMzXSxbMTAsNzBdLFs0Nyw1XSxbMjMsMzNdLFszOCwwXSxbMjgsNTldLFstMTksOTJdLFs5NCwxMjRdLFstNSw1NF0sWzU2LDM3XSxbMCwxMV0sWy05LDcwXSxbMTksMjddLFs0LDM4XSxbMzgsMzhdLFstNDIsMTAyXV0sW1sxNzUwLDg5NV0sWy04NSwtMjddLFstMzIsLTM3XSxbLTI5LDU0XSxbLTU2LDE2XSxbLTUsNDNdLFstMzIsMTZdLFstMzMsLTE2XSxbLTQzLDE2XV0sW1sxNDM1LDk2MF0sWy0yMywyMl0sWy0xOSwtMTFdLFstMjgsMTZdLFstNjYsNV0sWzE5LDQ0XSxbMCw1NF0sWzE0LDI2XSxbMTksMTI1XV0sW1syMzAsMTI2Ml0sWy0yNCwtNV0sWy0yMywtMTZdLFstMTksLTExXSxbLTU2LC02NV0sWy0xNCwwXSxbLTI0LDI3XSxbLTM3LC0xMV0sWy0xOSwtMjFdLFstMTQsNV1dLFtbMTM1MSwxMjQxXSxbLTg0LDBdLFstNDcsNTldLFstNzEsLTZdLFstNDIsMTE0XSxbNSw2NF0sWy01LDExXSxbLTksNDNdLFstMzMsMjJdLFstMjQsLTM4XSxbLTIzLDZdLFstMjMsMTA4XSxbLTUsMzddLFswLDMzXSxbLTE0LDMyXSxbLTI4LDVdLFstMjksMzhdLFstNDIsLTQzXSxbLTcwLDU0XSxbLTI4LC01XSxbLTEwLC0yMl1dLFtbNTgyLDIwNTVdLFstNjYsLTQ5XSxbLTQ3LC01XSxbLTYxLC03MF0sWy0xMDMsLTExXSxbMTksLTcwXSxbNTEsLTMyXSxbMTAsLTM4XSxbMjgsLTMyXSxbOSwtNTRdLFstMzcsLTQ0XSxbNCwtMjZdLFs1LC0zOF0sWy0zNywtNjVdLFstNjEsMTFdLFstMjksLTQ5XSxbLTIzLC00OF0sWy0zMywxMV0sWy0yOCwtMzNdLFstMTQsLTU0XSxbMjgsLTU0XSxbMzMsLTQzXV0sW1s3NjksMTc1M10sWy01Niw0OF1dLFtbNzEzLDE4MDFdLFstNDIsMTddLFstMTQsMjFdLFstMTksMF0sWy05LDE2XSxbLTE5LDBdLFstMTAsNl0sWzUsMTZdLFsxOSwxMV0sWy05LDIxXSxbMCwxMV0sWzUxLDBdLFstNSwxMV0sWy00LDIyXSxbLTEwLDI2XSxbLTIzLDI3XSxbLTE5LDIyXSxbLTIzLDI3XV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDA3OTk0MjYxMzIwMjA4ODYyLDAuMDAwNDkxMzM4NDM1NTM0OTE2OV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUzNjE3NjgwODg0MDUsNDIuMjYyMTYzMTA4MTU1NDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnMTBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzUzOSwwXSxbLTE3LDUyXSxbMCwxM10sWzMwLDI3XSxbMTMsNDhdLFs0MSw3NF0sWzEzLDQ3XSxbLTgsMzhdXSxbWzYxMSwyOTldLFstNDEsLTE2XSxbLTY5LDM3XV0sW1s1MDEsMzIwXSxbLTQxLDEzXSxbMTIsODFdXSxbWzgwLDQyMV0sWy0zMSwtMTJdLFstNDksLTIwXV0sW1s0NzIsNDE0XSxbLTcxLDI0XSxbLTE4LDY2XSxbLTI4LDddLFstMjEsNzJdLFstMTgsMF0sWy00NywyXV0sW1syMDMsNjg2XSxbLTU0LC0zMl0sWy0yOSwtMjJdLFsyMSwtNjNdLFstMTIsLTQ3XSxbLTYwLC01N10sWzExLC00NF1dLFtbMjY5LDU4NV0sWy0yMCwxNl1dLFtbMjQ5LDYwMV0sWy0yNSw1M10sWy0yMSwzMl1dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDAyMjkwMDk4MzQ5ODI4NjM4LDAuMDAxNDcxODY2NTk2MjQ1MjY4NV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUzNjE3NjgwODg0MDUsNDIuMjYyMTYzMTA4MTU1NDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnMjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzMzNywwXSxbLTEyLDM2XSxbNTEsODRdLFs2LDYyXV0sW1szODIsMTgyXSxbLTY5LDEzXV0sW1szMTMsMTk1XSxbLTE3LDIwXSxbLTEsMzddXSxbWzUwLDI1Nl0sWy0xNywtMTBdLFstOCwtOF0sWy0xMSwzXSxbLTE0LC01XV0sW1syOTUsMjUyXSxbLTQwLDEzXSxbLTQ2LDgyXSxbLTQxLDldXSxbWzEyNyw0MTddLFstNTQsLTMwXSxbMTUsLTUxXSxbLTQ0LC01M10sWzYsLTI3XV0sW1sxNjgsMzU2XSxbLTEyLDEwXV0sW1sxNTYsMzY2XSxbLTI5LDUxXV1dLFwidHJhbnNmb3JtXCI6e1wic2NhbGVcIjpbMC4wMDM2NjE4MzIzMDYyNzUwMDE3LDAuMDAyNDIxMzQ0MDg4Nzg3MTgwNV0sXCJ0cmFuc2xhdGVcIjpbMjAuMzUzNjE3NjgwODg0MDUsNDIuMjYyMTYzMTA4MTU1NDA2XX0sXCJvYmplY3RzXCI6e1wibnV0c2JuXzFcIjp7XCJ0eXBlXCI6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcImdlb21ldHJpZXNcIjpbe1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlswXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwOFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsxXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlsyXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwMlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOlszXSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwN1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls0XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwM1wiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls1XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNVwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls2XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNlwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX0se1widHlwZVwiOlwiTGluZVN0cmluZ1wiLFwiYXJjc1wiOls3XSxcInByb3BlcnRpZXNcIjp7XCJpZFwiOlwiMTAwMDAwNFwiLFwibHZsXCI6MCxcImV1XCI6XCJGXCIsXCJlZnRhXCI6XCJGXCIsXCJjY1wiOlwiVFwiLFwib3RoXCI6XCJGXCIsXCJjb1wiOlwiRlwifX1dfX19LFxyXG4gICAgICAnNjBNJzp7XCJ0eXBlXCI6XCJUb3BvbG9neVwiLFwiYXJjc1wiOltbWzIyMCwwXSxbMjksMTE2XV0sW1syNDksMTE2XSxbLTQ1LDhdXSxbWzIwNCwxMjRdLFstMTIsMzddXSxbWzE5MiwxNjFdLFstODMsNjZdXSxbWzEwOSwyMjddLFstOCw2XV0sW1szMywxNjNdLFstMzMsLTEyXV0sW1s4MywyNjZdLFstNTAsLTEwM11dLFtbMTAxLDIzM10sWy0xOCwzM11dXSxcInRyYW5zZm9ybVwiOntcInNjYWxlXCI6WzAuMDA1NjE3NzUwNzY3MDU2NDI3LDAuMDAzNzk1ODY2NDg1MDUzNTg3XSxcInRyYW5zbGF0ZVwiOlsyMC4zNTM2MTc2ODA4ODQwNSw0Mi4yNjIxNjMxMDgxNTU0MDZdfSxcIm9iamVjdHNcIjp7XCJudXRzYm5fMVwiOntcInR5cGVcIjpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFwiZ2VvbWV0cmllc1wiOlt7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzBdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA4XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzFdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA3XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzJdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAyXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzNdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAzXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzRdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA2XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzVdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDAxXCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzZdLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA1XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fSx7XCJ0eXBlXCI6XCJMaW5lU3RyaW5nXCIsXCJhcmNzXCI6WzddLFwicHJvcGVydGllc1wiOntcImlkXCI6XCIxMDAwMDA0XCIsXCJsdmxcIjowLFwiZXVcIjpcIkZcIixcImVmdGFcIjpcIkZcIixcImNjXCI6XCJUXCIsXCJvdGhcIjpcIkZcIixcImNvXCI6XCJGXCJ9fV19fX1cclxuICAgIH1cclxuICB9XHJcbn0iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciwgZXhlY3V0ZUZvckFsbEluc2V0cyB9IGZyb20gJy4vdXRpbHMnXHJcblxyXG4vLyBoYW5kbGVzIGFsbCBtYXAgbGFiZWxzIGUuZy4gc3RhdCB2YWx1ZXMsIG9yIGxhYmVscyBzcGVjaWZpZWQgaW4gbWFwLmxhYmVscyh7bGFiZWxzOlt0ZXh0OidteUxhYmVsJywgeDoxMjMsIHk6IDEyM119KVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBhZGRMYWJlbHNUb01hcFxyXG4gKiBAcGFyYW0gbWFwIGV1cm9zdGF0bWFwIG1hcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gemcgem9vbWdyb3VwIChkMyBzZWxlY3Rpb24gb2Ygem9vbWFibGUgZWxlbWVudHMpXHJcbiAqIEBkZXNjcmlwdGlvbiBhcHBlbmRzIHRleHQgbGFiZWxzIHRvIHRoZSBtYXAuIExhYmVscyBjYW4gYmUgY291bnRyaWVzLCBjb3VudHJ5IGNvZGVzLCBvY2VhbiBuYW1lcyBvciBzdGF0aXN0aWNhbCB2YWx1ZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBhZGRMYWJlbHNUb01hcCA9IGZ1bmN0aW9uIChtYXAsIHpnKSB7XHJcbiAgICAvLyBzZXQgZGVmYXVsdHNcclxuICAgIGlmICghbWFwLmxhYmVsc18uY29uZmlnKSBtYXAubGFiZWxzXy5jb25maWcgPSBERUZBVUxUTEFCRUxTXHJcbiAgICBpZiAoIW1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnMpIG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnMgPSBERUZBVUxUU1RBVExBQkVMUE9TSVRJT05TXHJcblxyXG4gICAgLy8gY2xlYXIgZXhpc3Rpbmcgb3IgYXBwZW5kIG5ldyBjb250YWluZXJcclxuICAgIGxldCBleGlzdGluZyA9IHpnLnNlbGVjdCgnI2VtLWxhYmVscycpXHJcbiAgICBsZXQgbGFiZWxzQ29udGFpbmVyID0gZXhpc3RpbmcuZW1wdHkoKSA/IHpnLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLWxhYmVscycpIDogZXhpc3RpbmdcclxuXHJcbiAgICAvL2ZvciBzdGF0aXN0aWNhbCB2YWx1ZXMgb24gbWFwcyB3aXRob3V0IGNlbnRyb2lkcywgd2UgbmVlZCB0byBhZGQgY2VudHJvaWRzIGluaXRpYWxseSwgdGhlbiBhZGQgdGV4dCB0byB0aGVtIGxhdGVyIG9uY2UgdGhlIHN0YXQgZGF0YSBpcyBsb2FkZWRcclxuICAgIGlmIChtYXAubGFiZWxzXz8udmFsdWVzICYmIG1hcC5fbWFwVHlwZSAhPT0gJ3BzJykgYXBwZW5kU3RhdExhYmVsQ2VudHJvaWRzVG9NYXAobWFwLCBsYWJlbHNDb250YWluZXIpXHJcblxyXG4gICAgLy8gZ2V0IGxhYmVscyBhcnJheVxyXG4gICAgbGV0IGxhYmVsc0FycmF5ID0gbWFwLmxhYmVsc18/LmxhYmVscyB8fCBERUZBVUxUTEFCRUxTW2Ake21hcC5nZW99XyR7bWFwLnByb2pffS5jY2BdXHJcblxyXG4gICAgLy8gYXBwZW5kIG90aGVyIGxhYmVscyB0byBtYXBcclxuICAgIGlmIChsYWJlbHNBcnJheSkge1xyXG4gICAgICAgIC8vY29tbW9uIHN0eWxlcyBiZXR3ZWVuIGFsbCBsYWJlbCBzaGFkb3dzXHJcbiAgICAgICAgY29uc3Qgc2hhZG93ZyA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1zaGFkb3dzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAgICAgLy9jb21tb24gc3R5bGVzIGJldHdlZW4gYWxsIGxhYmVsc1xyXG4gICAgICAgIGNvbnN0IGxhYmVsZyA9IGxhYmVsc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sYWJlbHMnKS5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG5cclxuICAgICAgICAvL1NIQURPV1NcclxuICAgICAgICBpZiAobWFwLmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICAgICAgbGV0IHNoYWRvd3MgPSBzaGFkb3dnXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGxhYmVsc0FycmF5KVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+ICdlbS1sYWJlbC1zaGFkb3ctJyArIGQudGV4dC5yZXBsYWNlKC9cXHMrL2csICctJykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAoZCkgPT4gJ2VtLWxhYmVsLXNoYWRvdyBlbS1sYWJlbC1zaGFkb3ctJyArIGQuY2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQucm90YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8vZm9yIHJvdGF0ZWQgdGV4dCwgeCBhbmQgeSBwb3NpdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pWzBdXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvL2ZvciByb3RhdGVkIHRleHQsIHggYW5kIHkgcG9zaXRpb25zIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVsxXVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIC03KSAvLyBzZXQgeSBwb3NpdGlvbiBvZiBib3R0b20gb2YgdGV4dFxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQucm90YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBwb3NbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBwb3NbMV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwke3l9KSByb3RhdGUoJHtkLnJvdGF0ZX0pYFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncm90YXRlKDApJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnRleHRcclxuICAgICAgICAgICAgICAgIH0pIC8vIGRlZmluZSB0aGUgdGV4dCB0byBkaXNwbGF5XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0xBQkVMIHRleHRzXHJcbiAgICAgICAgbGFiZWxnXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAuZGF0YShsYWJlbHNBcnJheSlcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAnZW0tbGFiZWwtJyArIGQudGV4dC5yZXBsYWNlKC9cXHMrL2csICctJykpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIChkKSA9PiAnZW0tbGFiZWwgZW0tbGFiZWwtJyArIGQuY2xhc3MpXHJcbiAgICAgICAgICAgIC8vcG9zaXRpb24gbGFiZWxcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQucm90YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLy9mb3Igcm90YXRlZCB0ZXh0LCB4IGFuZCB5IHBvc2l0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgdHJhbnNmb3JtIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwLl9wcm9qZWN0aW9uKFtkLngsIGQueV0pWzBdXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8vZm9yIHJvdGF0ZWQgdGV4dCwgeCBhbmQgeSBwb3NpdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5fcHJvamVjdGlvbihbZC54LCBkLnldKVsxXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAtNykgLy8gc2V0IHkgcG9zaXRpb24gb2YgYm90dG9tIG9mIHRleHRcclxuICAgICAgICAgICAgLy90cmFuc2Zvcm0gbGFiZWxzIHdoaWNoIGhhdmUgYSBcInJvdGF0ZVwiIHByb3BlcnR5IGluIHRoZSBsYWJlbHMgY29uZmlnLiBGb3Igcm90YXRlZCBsYWJlbHMsIHRoZWlyIFgsWSBtdXN0IGFsc28gYmUgc2V0IGluIHRoZSB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIC8vIG5vdGU6IGRvbnQgYXBwbHkgdG8gY291bnRyeSBjb2RlIGxhYmVsc1xyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtYXAuX3Byb2plY3Rpb24oW2QueCwgZC55XSlcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHBvc1swXVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB5ID0gcG9zWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwke3l9KSByb3RhdGUoJHtkLnJvdGF0ZX0pYFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSgwKSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRleHRcclxuICAgICAgICAgICAgfSkgLy8gZGVmaW5lIHRoZSB0ZXh0IHRvIGRpc3BsYXlcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiB1cGRhdGVMYWJlbHNcclxuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSBleGlzdGluZyBtYXAgbGFiZWxzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXBkYXRlTGFiZWxzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgbGFiZWxzXHJcbiAgICAgICAgbGV0IHByZXZMYWJlbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJyNlbS1sYWJlbHMgPiAqJylcclxuICAgICAgICBpZiAocHJldkxhYmVscykgcHJldkxhYmVscy5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvLyBNYWluIG1hcFxyXG4gICAgICAgIGlmIChtYXAubGFiZWxzXykge1xyXG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJDb25maWcgPSBtYXAubGFiZWxzX1xyXG4gICAgICAgICAgICBsZXQgemcgPSBtYXAuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBtYXAuc3ZnSWRfKVxyXG4gICAgICAgICAgICBhZGRMYWJlbHNUb01hcChtYXAsIHpnKVxyXG4gICAgICAgICAgICBpZiAobWFzdGVyQ29uZmlnLnZhbHVlcyAmJiBtYXAudXBkYXRlVmFsdWVzTGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBtYXAudXBkYXRlVmFsdWVzTGFiZWxzKG1hcClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVmaW5lIHRoZSBjYWxsYmFjayB0byBhcHBseSB0byBlYWNoIGluc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5TGFiZWxzQ2FsbGJhY2sgPSAobWFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFzdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHpnID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgbWFwLnN2Z0lkXylcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmxhYmVsc18pIGFkZExhYmVsc1RvTWFwKG1hcCwgemcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc3RlckNvbmZpZy52YWx1ZXMgJiYgbWFwLnVwZGF0ZVZhbHVlc0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAudXBkYXRlVmFsdWVzTGFiZWxzKG1hcClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGxhYmVscyB0byBhbGwgaW5zZXRzIHVzaW5nIHRoZSBleGVjdXRlRm9yQWxsSW5zZXRzIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGlmIChtYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG1hcC5zdmdJZF8sIGFwcGx5TGFiZWxzQ2FsbGJhY2spXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgbGFiZWxzIG9uIHRoZSBtYXBcclxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBldXJvc3RhdC1tYXAgbWFwIGluc3RhbmNlXHJcbiAqIEByZXR1cm4ge21hcH0gb3V0XHJcbiAqIE5PVEU6IFRISVMgRlVOQ1RJT04gSVMgTk9UIENBTExFRCBGT1IgUFJPUE9SVElPTkFMIFNZTUJPTCBNQVBTXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXBkYXRlVmFsdWVzTGFiZWxzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgaWYgKCFtYXApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIG1hcCBzcGVjaWZpZWQnKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vY2xlYXIgcHJldmlvdXMgbGFiZWxzXHJcbiAgICBsZXQgcHJldkxhYmVscyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnZy5lbS1zdGF0LWxhYmVsID4gKicpXHJcbiAgICBwcmV2TGFiZWxzLnJlbW92ZSgpXHJcbiAgICBsZXQgcHJldlNoYWRvd3MgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJ2cuZW0tc3RhdC1sYWJlbC1zaGFkb3cgPiAqJylcclxuICAgIHByZXZTaGFkb3dzLnJlbW92ZSgpXHJcbiAgICBsZXQgc3RhdExhYmVscyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnZy5lbS1zdGF0LWxhYmVsJylcclxuXHJcbiAgICAvLyBmaWx0ZXIgc3RhdC1sYWJlbCBlbGVtZW50cyB0byBvbmx5IHNob3cgdGhvc2Ugd2l0aCBkYXRhXHJcbiAgICBjb25zdCBmaWx0ZXJGdW5jdGlvbiA9IG1hcC5sYWJlbHNfPy5zdGF0TGFiZWxzRmlsdGVyRnVuY3Rpb24gPyBtYXAubGFiZWxzXz8uc3RhdExhYmVsc0ZpbHRlckZ1bmN0aW9uIDogZGVmYXVsdFN0YXRMYWJlbEZpbHRlclxyXG4gICAgY29uc3Qgc3RhdERhdGEgPSBtYXAuc3RhdERhdGEoKVxyXG4gICAgc3RhdExhYmVsc1xyXG4gICAgICAgIC5maWx0ZXIoKHJnKSA9PiBmaWx0ZXJGdW5jdGlvbihyZywgbWFwKSlcclxuICAgICAgICAvLyAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gc3RhdExhYmVsc1RleHRGdW5jdGlvbihkLCBzdGF0RGF0YSkgLy8gVXNlICdkJyBkaXJlY3RseSBmb3IgdGhlIGxhYmVsIHRleHRcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgYmVoaW5kIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5iYWNrZ3JvdW5kcykgYXBwZW5kUmVjdChsYWJlbFRleHQsIHNlbClcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0ZXh0IGFmdGVyIHRoZSByZWN0YW5nbGVcclxuICAgICAgICAgICAgc2VsLmFwcGVuZCgndGV4dCcpLnRleHQobGFiZWxUZXh0KS5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVsLXRleHQnKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy8gRnVuY3Rpb24gdG8gYXBwZW5kIGEgcmVjdGFuZ2xlIGJlaGluZCB0aGUgbGFiZWxcclxuICAgIGZ1bmN0aW9uIGFwcGVuZFJlY3QobGFiZWxUZXh0LCBjb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IDUgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDIgLy8gQWRkIHNvbWUgcGFkZGluZyBhcm91bmQgdGhlIHRleHRcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHRleHQgZWxlbWVudCB0byBnZXQgdGhlIHNpemVcclxuICAgICAgICBjb25zdCBiYm94ID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlzaWJpbGl0eScsICdoaWRkZW4nKSAvLyBNYWtlIHRoZSB0ZW1wb3JhcnkgdGV4dCBpbnZpc2libGVcclxuICAgICAgICAgICAgLnRleHQobGFiZWxUZXh0KSAvLyBTZXQgdGhlIGxhYmVsIHRleHQgdG8gZ2V0IGl0cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgLm5vZGUoKVxyXG4gICAgICAgICAgICAuZ2V0QkJveCgpIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBiYm94LndpZHRoXHJcbiAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSBiYm94LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgYWZ0ZXIgZ2V0dGluZyB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdCgndGV4dFt2aXNpYmlsaXR5PVwiaGlkZGVuXCJdJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIHRvIGJlIGNlbnRlcmVkIG9uIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgeCA9IC1sYWJlbFdpZHRoIC8gMiAtIHBhZGRpbmdYIC8vIENlbnRlciB0aGUgcmVjdCBob3Jpem9udGFsbHlcclxuICAgICAgICBjb25zdCB5ID0gLWxhYmVsSGVpZ2h0IC8gMiAtIHBhZGRpbmdZIC8vIENlbnRlciB0aGUgcmVjdCB2ZXJ0aWNhbGx5XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCByZWN0YW5nbGUgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHgpIC8vIFBvc2l0aW9uIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSkgLy8gUG9zaXRpb24gcmVjdCB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGxhYmVsV2lkdGggKyAyICogcGFkZGluZ1gpIC8vIFdpZHRoIG9mIHRoZSByZWN0IHdpdGggcGFkZGluZ1xyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgbGFiZWxIZWlnaHQgKyAyICogcGFkZGluZ1kpIC8vIEhlaWdodCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxhYmVsLWJhY2tncm91bmQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vYWRkIHNoYWRvd3MgdG8gbGFiZWxzXHJcbiAgICBpZiAobWFwLmxhYmVsc18/LnNoYWRvd3MpIHtcclxuICAgICAgICBtYXAuc3ZnX1xyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLXN0YXQtbGFiZWwtc2hhZG93JylcclxuICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IGZpbHRlckZ1bmN0aW9uKHJnLCBtYXApKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IHN0YXRMYWJlbHNUZXh0RnVuY3Rpb24oZCwgc3RhdERhdGEpKSAvLyBVc2UgJ2QnIGRpcmVjdGx5IGZvciB0aGUgbGFiZWwgdGV4dClcclxuICAgIH1cclxuICAgIHJldHVybiBtYXBcclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiB0ZXh0IGZ1bmN0aW9uIGZvciBzdGF0aXN0aWNhbCBsYWJlbGxpbmdcclxuICogQHBhcmFtIHtPYmplY3R9IGQgZDMgc2VsZWN0aW9uIGpzb24gZGF0YSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBzdGF0TGFiZWxzVGV4dEZ1bmN0aW9uID0gKGQsIHN0YXREYXRhKSA9PiB7XHJcbiAgICBpZiAoc3RhdERhdGEgJiYgc3RhdERhdGE/LmdldCkge1xyXG4gICAgICAgIGNvbnN0IHN2ID0gc3RhdERhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICBpZiAoIXN2IHx8ICghc3YudmFsdWUgJiYgc3YgIT09IDAgJiYgc3YudmFsdWUgIT09IDApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzdi52YWx1ZSAhPT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2LnZhbHVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgc3RhdGlzdGljYWwgbGFiZWxzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIGQzIHNlbGVjdGlvbiBqc29uIGRhdGEgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdFN0YXRMYWJlbEZpbHRlciA9IChyZWdpb24sIG1hcCkgPT4ge1xyXG4gICAgY29uc3QgcyA9IG1hcC5zdGF0RGF0YSgpXHJcbiAgICBjb25zdCBzdiA9IHMuZ2V0KHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBhcHBlbmRTdGF0TGFiZWxDZW50cm9pZHNUb01hcCA9IGZ1bmN0aW9uIChtYXAsIGxhYmVsc0NvbnRhaW5lcikge1xyXG4gICAgLy92YWx1ZXMgbGFiZWwgc2hhZG93cyBwYXJlbnQgPGc+XHJcbiAgICBjb25zdCBnc2xzID0gbGFiZWxzQ29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXN0YXQtbGFiZWxzLXNoYWRvd3MnKS5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG5cclxuICAgIC8vIHZhbHVlcyBsYWJlbHMgcGFyZW50IDxnPlxyXG4gICAgY29uc3Qgc3RhdExhYmVsc0dyb3VwID0gbGFiZWxzQ29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXN0YXQtbGFiZWxzJykuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuXHJcbiAgICAvLyBvdXIgZmVhdHVyZXMgYXJyYXlcclxuICAgIGxldCBzdGF0TGFiZWxSZWdpb25zID0gW11cclxuXHJcbiAgICAvLyBkZWFmdWx0IGdlb21ldHJpZXNcclxuICAgIGlmIChtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy5udXRzcmcpIHtcclxuICAgICAgICAvL2FsbG93IGZvciBzdGF0IGxhYmVsIHBvc2l0aW9uaW5nIGJ5IGFkZGluZyBhIGcgZWxlbWVudCBoZXJlLCB0aGVuIGFkZGluZyB0aGUgdmFsdWVzIGluIHRoZSBtYXBUeXBlIHVwZGF0ZVZhbHVlc0xhYmVscyBmdW5jdGlvblxyXG4gICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgIHN0YXRMYWJlbFJlZ2lvbnMgPSBtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy5taXhlZC5yZzAuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmcxLFxyXG4gICAgICAgICAgICAgICAgbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmcyLFxyXG4gICAgICAgICAgICAgICAgbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubWl4ZWQucmczLFxyXG4gICAgICAgICAgICAgICAgbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMuY250cmcgLy8gTkVXOiBhbGxvdyBsYWJlbHMgZm9yIGNudHJnXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0TGFiZWxSZWdpb25zID0gbWFwLkdlb21ldHJpZXMuZ2VvSlNPTnMubnV0c3JnLmNvbmNhdChtYXAuR2VvbWV0cmllcy5nZW9KU09Ocy5jbnRyZylcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSB7XHJcbiAgICAgICAgLy8gdXNlciBkZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBzdGF0TGFiZWxSZWdpb25zID0gbWFwLkdlb21ldHJpZXMuc3RhdGlzdGljYWxSZWdpb25zLmZlYXR1cmVzXHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBkb250IGFkZCBsYWJlbHMgZm9yIHJlZ2lvbnMgdGhhdCBhcmUgbm90IHZpc2libGU/IHdoYXQgYWJvdXQgcGFubmluZyBhbmQgem9vbWluZyB0aG91Z2guIE9ubHkgcmVhbGx5IGFuIGlzc3VlIGZvciBtaXhlZCBOVVRTLlxyXG5cclxuICAgIC8vIHN0YXRzIGxhYmVsc1xyXG4gICAgY29uc3QgZmlsdGVyZWRSZWdpb25zID0gc3RhdExhYmVsUmVnaW9ucy5maWx0ZXIoKGQsIGksIHNlbGYpID0+IGkgPT09IHNlbGYuZmluZEluZGV4KCh0KSA9PiB0LnByb3BlcnRpZXMuaWQgPT09IGQucHJvcGVydGllcy5pZCkpXHJcbiAgICBzdGF0TGFiZWxzR3JvdXBcclxuICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAuZGF0YShmaWx0ZXJlZFJlZ2lvbnMpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgLy8gdXNlIHByZWRlZmluZWQgbGFiZWwgcG9zaXRpb25pbmdcclxuICAgICAgICAgICAgaWYgKG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnNbZC5wcm9wZXJ0aWVzLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zW2QucHJvcGVydGllcy5pZF1cclxuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtYXAuX3Byb2plY3Rpb24oW3Bvc2l0aW9uLngsIHBvc2l0aW9uLnldKVxyXG4gICAgICAgICAgICAgICAgbGV0IHggPSBwb3NbMF0udG9GaXhlZCgzKVxyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBwb3NbMV0udG9GaXhlZCgzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwke3l9KWBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IG1hcC5fcGF0aEZ1bmN0aW9uLmNlbnRyb2lkKGQpXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5sYWJlbHNfLnByb2Nlc3NWYWx1ZUxhYmVsQ2VudHJvaWRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VudHJvaWQgPSBtYXAubGFiZWxzXy5wcm9jZXNzVmFsdWVMYWJlbENlbnRyb2lkcyhkLCBjZW50cm9pZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBjYWxjdWxhdGUgY2VudHJvaWRzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgY2VudHJvaWQgKyAnKSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXN0YXQtbGFiZWwnKVxyXG5cclxuICAgIC8vIHN0YXQgbGFiZWxzIHNoYWRvd3NcclxuICAgIGlmIChtYXAubGFiZWxzXz8uc2hhZG93cykge1xyXG4gICAgICAgIGdzbHMuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAgICAgLmRhdGEoc3RhdExhYmVsUmVnaW9ucylcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHByZWRlZmluZWQgbGFiZWwgcG9zaXRpb25pbmdcclxuICAgICAgICAgICAgICAgIGlmIChtYXAubGFiZWxzXy5zdGF0TGFiZWxzUG9zaXRpb25zW2QucHJvcGVydGllcy5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gbWFwLl9wcm9qZWN0aW9uKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmxhYmVsc18uc3RhdExhYmVsc1Bvc2l0aW9uc1tkLnByb3BlcnRpZXMuaWRdLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5sYWJlbHNfLnN0YXRMYWJlbHNQb3NpdGlvbnNbZC5wcm9wZXJ0aWVzLmlkXS55LFxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBwb3NbMF0udG9GaXhlZCgzKVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB5ID0gcG9zWzFdLnRvRml4ZWQoMylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCR7eX0pYFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VudHJvaWQgPSBtYXAuX3BhdGhGdW5jdGlvbi5jZW50cm9pZChkKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmxhYmVsc18ucHJvY2Vzc1ZhbHVlTGFiZWxDZW50cm9pZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudHJvaWQgPSBtYXAubGFiZWxzXy5wcm9jZXNzVmFsdWVMYWJlbENlbnRyb2lkcyhkLCBjZW50cm9pZClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNhbGN1bGF0ZSBjZW50cm9pZHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgY2VudHJvaWQgKyAnKSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zdGF0LWxhYmVsLXNoYWRvdycpXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IGxhYmVscyBmb3IgY291bnRyeSAvIGdlb2dyYXBoaWNhbCBuYW1lcy5cclxuICogVXNpbmcgY2VudHJvaWRzIHdvdWxkIGNsYXNoIHdpdGggcHJvcG9ydGlvbmFsIHN5bWJvbHMsIGFuZCBhcmUgZ2VuZXJhbGx5IG5vdCBpZGVhbCBwbGFjZW1lbnRzLCBzbyBsYWJlbHMgYXJlIHBvc2l0aW9uZWQgaW5kZXBlbmRlbnRseVxyXG4gKiBMYWJlbHMgYXJlIHByb3ZpZGVkIGZvciBhbGwgc3VwcG9ydGVkIGxhbmd1YWdlczogXCJlblwiLFwiZnJcIiBhbmQgXCJkZVwiIChkZWZpbmVkIHVzaW5nIG1hcC5sYW5ndWFnZSgpKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRMQUJFTFMgPSB7XHJcbiAgICBFVVJfMzAzNToge1xyXG4gICAgICAgIGNjOiBbXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FMJywgeDogNTE1MDAwMCwgeTogMjA2MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQVQnLCB4OiA0NjcwMDAwLCB5OiAyNjkwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTggfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkUnLCB4OiAzOTMwMDAwLCB5OiAzMDEwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkcnLCB4OiA1NTY3MDAwLCB5OiAyMjUwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSFInLCB4OiA0ODQwMDAwLCB5OiAyNDgwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ1knLCB4OiA2NDI2MDAwLCB5OiAxNDgwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ1onLCB4OiA0NzA3MDAwLCB5OiAyOTIwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTggfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnREsnLCB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRUUnLCB4OiA1MjIwMDAwLCB5OiAzOTkwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRkknLCB4OiA1MTUwMDAwLCB5OiA0NDI0MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlInLCB4OiAzNzY3NzQwLCB5OiAyNjYyODE3LCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnREUnLCB4OiA0MzQ3Mjg0LCB5OiAzMDkzMjc2LCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRUwnLCB4OiA1MzcwMDAwLCB5OiAxNzUwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSFUnLCB4OiA1MDIwMDAwLCB5OiAyNjMwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVMnLCB4OiAzMDQwMDAwLCB5OiA0ODMzMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSUUnLCB4OiAzMTM2MDAwLCB5OiAzMzk0MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVQnLCB4OiA0NDY5OTY3LCB5OiAyMTgxOTYzLCBjbGFzczogJ2NjJywgc2l6ZTogMjIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFYnLCB4OiA1MjkwMDAwLCB5OiAzODAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFQnLCB4OiA1MTkwMDAwLCB5OiAzNjMwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFUnLCB4OiA0MTIwMDAwLCB5OiAyOTQwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTVQnLCB4OiA0NzMxMDAwLCB5OiAxMzAwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUUnLCB4OiA1MDczMDAwLCB5OiAyMTg1MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdHRScsIHg6IDY5NDI2ODAsIHk6IDI2NjAwMDAsIGNsYXNzOiAnY2MnIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1VBJywgeDogNTg5MDAwMCwgeTogMzA1MDAwMCwgY2xhc3M6ICdjYycgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQkEnLCB4OiA0OTQ5MjYyLCB5OiAyMzM4Njg4LCBjbGFzczogJ2NjJyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRCcsIHg6IDU3NDAwMDAsIHk6IDI3OTAwMDAsIGNsYXNzOiAnY2MnIH0sXHJcblxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNSycsIHg6IDUzMDAwMDAsIHk6IDIwODAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOTCcsIHg6IDQwMjAwMDAsIHk6IDMyMDgwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOTycsIHg6IDQzMDAwMDAsIHk6IDQxNDcwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQTCcsIHg6IDQ5NjQwMDAsIHk6IDMyMDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQVCcsIHg6IDI3NzAwMDAsIHk6IDE5OTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxOCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdSTycsIHg6IDU0NTEwMDAsIHk6IDI2MDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdSUycsIHg6IDUyMDAwMDAsIHk6IDIzNTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTSycsIHg6IDUwNDAwMDAsIHk6IDI4NjAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTSScsIHg6IDQ2NzUwMDAsIHk6IDI1MDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdFUycsIHg6IDMxNjAwOTYsIHk6IDE5MDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTRScsIHg6IDQ2MzAwMDAsIHk6IDQwMDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDSCcsIHg6IDQxNzAwMDAsIHk6IDI2MDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxNiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUUicsIHg6IDY1MTAwMDAsIHk6IDIxMDAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAyMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdVSycsIHg6IDM1NTgwMDAsIHk6IDMyNTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxNyB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZW46IFtcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVESVRFUlJBTkVBTiBTRUEnLCB4OiAzOTgwMDAwLCB5OiAxNjAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBVExBTlRJQyBPQ0VBTicsIHg6IDI4MjAwMDAsIHk6IDI1NDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyLCBsZXR0ZXJTcGFjaW5nOiAyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUlRIIFNFQScsIHg6IDM5MTUwMDAsIHk6IDM3MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JBTFRJQyBTRUEnLCB4OiA0OTAwMDAwLCB5OiAzNzMwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SV0VHSUFOIFNFQScsIHg6IDM4NTAwMDAsIHk6IDQ4MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JMQUNLIFNFQScsIHg6IDYzMDAwMDAsIHk6IDI1MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyLCBsZXR0ZXJTcGFjaW5nOiA0IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FMQkFOSUEnLCBjYzogJ0FMJywgeDogNTEwMDAwMCwgeTogMjA2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IDgwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FVU1RSSUEnLCBjYzogJ0FUJywgeDogNDY3MDAwMCwgeTogMjYyOTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCRUxHSVVNJywgY2M6ICdCRScsIHg6IDM5MDAwMDAsIHk6IDMwMzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAzMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCVUxHQVJJQScsIGNjOiAnQkcnLCB4OiA1NTY3MDAwLCB5OiAyMjU2MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NST0FUSUEnLCBjYzogJ0hSJywgeDogNDg3NjAwMCwgeTogMjQ1NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NZUFJVUycsIGNjOiAnQ1knLCB4OiA2NDI2MDAwLCB5OiAxNDgwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0NaRUNISUEnLCBjYzogJ0NaJywgeDogNDcwNzAwMCwgeTogMjg4NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdERU5NQVJLJywgY2M6ICdESycsIHg6IDQzMTYwMDAsIHk6IDM2MjEwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRVNUT05JQScsIGNjOiAnRUUnLCB4OiA1MjIwMDAwLCB5OiAzOTkwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRklOTEFORCcsIGNjOiAnRkknLCB4OiA1MTUwMDAwLCB5OiA0NDI0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSQU5DRScsIGNjOiAnRlInLCB4OiAzNzY3NzQwLCB5OiAyNjYyODE3LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0dFUk1BTlknLCBjYzogJ0RFJywgeDogNDM0NzI4NCwgeTogMzA5MzI3NiwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdHUkVFQ0UnLCBjYzogJ0VMJywgeDogNTQ3MDAwMCwgeTogMTg2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdIVU5HQVJZJywgY2M6ICdIVScsIHg6IDUwMjAwMDAsIHk6IDI2MzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSUNFTEFORCcsIGNjOiAnSVMnLCB4OiAzMDQwMDAwLCB5OiA0ODMzMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lSRUxBTkQnLCBjYzogJ0lFJywgeDogMzEzNjAwMCwgeTogMzM5NDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJVEFMWScsIGNjOiAnSVQnLCB4OiA0NDY5OTY3LCB5OiAyMTgxOTYzLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xBVFZJQScsIGNjOiAnTFYnLCB4OiA1MjkwMDAwLCB5OiAzODAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTElUSFVBTklBJywgY2M6ICdMVCcsIHg6IDUxOTAwMDAsIHk6IDM2MzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMVVguJywgY2M6ICdMVScsIHg6IDQxMjAwMDAsIHk6IDI5NDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNQUxUQScsIGNjOiAnTVQnLCB4OiA0NzMxMDAwLCB5OiAxMzMwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTU9OVC4nLCBjYzogJ01FJywgeDogNTA3MzAwMCwgeTogMjE4NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ04uIE1BQ0VET05JQScsIGNjOiAnTUsnLCB4OiA1MzAwMDAwLCB5OiAyMDgyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTkVUSEVSTEFORFMnLCBjYzogJ05MJywgeDogMzk3NzAwMCwgeTogMzIwODAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUldBWScsIGNjOiAnTk8nLCB4OiA0MzMwMDAwLCB5OiA0MTQ3MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT0xBTkQnLCBjYzogJ1BMJywgeDogNDk2NDAwMCwgeTogMzI2OTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQT1JUVUdBTCcsIGNjOiAnUFQnLCB4OiAyODMwMDAwLCB5OiAxOTkwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwLCByb3RhdGU6IC03NSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdST01BTklBJywgY2M6ICdSTycsIHg6IDU0NTEwMDAsIHk6IDI2MDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0VSQklBJywgY2M6ICdSUycsIHg6IDUyMDAwMDAsIHk6IDIzMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9WQUtJQScsIGNjOiAnU0snLCB4OiA1MDQwMDAwLCB5OiAyODM1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NMT1ZFTklBJywgY2M6ICdTSScsIHg6IDQ3MzUwMDAsIHk6IDI1MjIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAtMzAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU1BBSU4nLCBjYzogJ0VTJywgeDogMzE2MDA5NiwgeTogMTg1MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTV0VERU4nLCBjYzogJ1NFJywgeDogNDYzMDAwMCwgeTogNDEwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU1dJVFpFUkxBTkQnLCBjYzogJ0NIJywgeDogNDIwMDAwMCwgeTogMjU2NDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1RVUktFWScsIGNjOiAnVFInLCB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1UuSy4nLCBjYzogJ1VLJywgeDogMzU1ODAwMCwgeTogMzI1MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZnI6IFtcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUVSIE3DiURJVEVSUkFOw4lFJywgeDogNTQ3MjAwMCwgeTogMTI0MjAwMCwgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnT0PDiEFOIEFUTEFOVElRVUUnLCB4OiAyODIwMDAwLCB5OiAyNTQwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRVIgRFUgTk9SRCcsIHg6IDM5MTUwMDAsIHk6IDM3MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01FUiBCQUxUSVFVRScsIHg6IDQ5MDAwMDAsIHk6IDM2NzIwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCByb3RhdGU6IC01MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRVIgREUgTk9SVsOIR0UnLCB4OiAzODUwMDAwLCB5OiA0ODAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNRVIgTk9JUkUnLCB4OiA2MjY1MDAwLCB5OiAyNDcyMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTEJBTklFJywgeDogNTEwMDAwMCwgeTogMjA2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IDgwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FVVFJJQ0hFJywgeDogNDY3MDAwMCwgeTogMjYyOTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCRUxHSVFVRScsIHg6IDM5MDAwMDAsIHk6IDMwMzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAzMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCVUxHQVJJRScsIHg6IDU1NjcwMDAsIHk6IDIyNTYwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnQ1JPQVRJRScsIHg6IDQ4NzYwMDAsIHk6IDI0NTUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdDSFlQUkUnLCB4OiA2NDI2MDAwLCB5OiAxNDgwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1RDSMOJUVVJRScsIHg6IDQ3MDcwMDAsIHk6IDI4ODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnREFORU1BUksnLCB4OiA0MzE2MDAwLCB5OiAzNjIxMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0VTVE9OSUUnLCB4OiA1MjIwMDAwLCB5OiAzOTkwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZJTkxBTkRFJywgeDogNTEyNTAwMCwgeTogNDQyNDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUkFOQ0UnLCB4OiAzNzY3NzQwLCB5OiAyNjYyODE3LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FMTEVNQUdORScsIHg6IDQzNDcyODQsIHk6IDMwOTMyNzYsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR1LDiENFJywgeDogNTQyMDAwMCwgeTogMTg2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdIT05HUklFJywgeDogNTAyMDAwMCwgeTogMjY1NDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJU0xBTkRFJywgeDogMzA0MDAwMCwgeTogNDgzMzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJUkxBTkRFJywgeDogMzEzNjAwMCwgeTogMzM5NDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJVEFMSUUnLCB4OiA0NTAwMDAwLCB5OiAyMTgxOTYzLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0xFVFRPTklFJywgeDogNTI5MDAwMCwgeTogMzc3NjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMSVRVQU5JRScsIHg6IDUxOTAwMDAsIHk6IDM2MzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTFVYLicsIHg6IDQxMjAwMDAsIHk6IDI5NDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNQUxURScsIHg6IDQ3MzEwMDAsIHk6IDEzMzUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNT05ULicsIHg6IDUwNzMwMDAsIHk6IDIxODUwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNQUMuIERVIE5PUkQnLCB4OiA1MzAwMDAwLCB5OiAyMDgyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUEFZUy1CQVMnLCB4OiAzOTc3MDAwLCB5OiAzMjA4MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SVkVHRScsIHg6IDQzMzAwMDAsIHk6IDQxNDcwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogLTc1IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BPTE9HTkUnLCB4OiA0OTY0MDAwLCB5OiAzMjY5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BPUlRVR0FMJywgeDogMjgzNjEzNiwgeTogMTk1NjE3OSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUk9VTUFOSUUnLCB4OiA1NDUxMDAwLCB5OiAyNjAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NFUkJJRScsIHg6IDUyMDAwMDAsIHk6IDIzMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9WQVFVSUUnLCB4OiA1MDQwMDAwLCB5OiAyODM1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NMT1bDiU5JRScsIHg6IDQ3MzUwMDAsIHk6IDI1MjIwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiAtMzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRVNQQUdORScsIHg6IDMxNjAwOTYsIHk6IDE4NTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU1XDiERFJywgeDogNDcwMDAwMCwgeTogNDQwMTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU1VJU1NFJywgeDogNDIwMDAwMCwgeTogMjU2NDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1RVUlFVSUUnLCB4OiA2NTEwMDAwLCB5OiAyMTAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1JPWUFVTUUtVU5JJywgeDogMzU1ODAwMCwgeTogMzI1MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGU6IFtcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTUlUVEVMTUVFUicsIHg6IDU0NzIwMDAsIHk6IDEyMDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyLCBsZXR0ZXJTcGFjaW5nOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0FUTEFOVElTQ0hFUiBPWkVBTicsIHg6IDI4MjAwMDAsIHk6IDI1NDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUkRTRUUnLCB4OiAzOTE1MDAwLCB5OiAzNzAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdPU1RTRUUnLCB4OiA0OTAwMDAwLCB5OiAzNjcyMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SV0VHSVNDSEUgTUVFUicsIHg6IDM4NTAwMDAsIHk6IDQ4MDAwMDAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NDSFdBUlpFIE1FRVInLCB4OiA2MzAwMDAwLCB5OiAyNTAwMDAwLCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMiwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdBTEJBTklFTicsIHg6IDUxMDAwMDAsIHk6IDIwNjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNywgcm90YXRlOiA4MCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICfDllNURVJSRUlDSCcsIHg6IDQ2NTAwMDAsIHk6IDI2MjkwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdCRUxHSUVOJywgeDogMzkwMDAwMCwgeTogMzAzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IDMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0JVTEdBUklFTicsIHg6IDU1NjcwMDAsIHk6IDIyNTYwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnS1JPQVRJRU4nLCB4OiA0ODc2MDAwLCB5OiAyNDU1MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnWllQRVJOJywgeDogNjQyNjAwMCwgeTogMTQ4MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUU0NIRUNISUVOJywgeDogNDcwNzAwMCwgeTogMjg4NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0TDhE5FTUFSSycsIHg6IDQzMTYwMDAsIHk6IDM2MjEwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRVNUTEFORCcsIHg6IDUyMjAwMDAsIHk6IDM5OTAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGSU5OTEFORCcsIHg6IDUxNTAwMDAsIHk6IDQ0MjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlJBTktSRUlDSCcsIHg6IDM3Njc3NDAsIHk6IDI2NjI4MTcsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnREVVVFNDSExBTkQnLCB4OiA0MzQ3Mjg0LCB5OiAzMDkzMjc2LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0dSSUVDSEVOTEFORCcsIHg6IDU1NTAwMDAsIHk6IDE1MDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVU5HQVJOJywgeDogNTAyMDAwMCwgeTogMjYzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdJU0xBTkQnLCB4OiAzMDQwMDAwLCB5OiA0ODMzMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lSTEFORCcsIHg6IDMxMzYwMDAsIHk6IDMzOTQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnSVRBTElFTicsIHg6IDQ0Njk5NjcsIHk6IDIxODE5NjMsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIsIHJvdGF0ZTogMzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTEVUVExBTkQnLCB4OiA1MjkwMDAwLCB5OiAzODAwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTElUQVVFTicsIHg6IDUxOTAwMDAsIHk6IDM2MzAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdMVVguJywgeDogNDEyMDAwMCwgeTogMjk0MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01BTFRBJywgeDogNDczMTAwMCwgeTogMTMzMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ01PTlQuJywgeDogNTA3MzAwMCwgeTogMjE4NTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUkRNQVpFRE9OSUVOJywgeDogNTM1MDAwMCwgeTogMjA4MjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05JRURFUkxBTkRFJywgeDogMzk3NzAwMCwgeTogMzIwODAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ05PUldFR0VOJywgeDogNDMzMDAwMCwgeTogNDE0NzAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUE9MRU4nLCB4OiA0OTY0MDAwLCB5OiAzMjY5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1BPUlRVR0FMJywgeDogMjgzNjEzNiwgeTogMTk1NjE3OSwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnUlVNw4ROSUVOJywgeDogNTQ1MTAwMCwgeTogMjYwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTRVJCSUVOJywgeDogNTIwMDAwMCwgeTogMjMwMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NMT1dBS0VJJywgeDogNTA0MDAwMCwgeTogMjgzNTAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3LCByb3RhdGU6IC0zMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTTE9XRU5JRU4nLCB4OiA0NzM1MDAwLCB5OiAyNTIyMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcsIHJvdGF0ZTogLTMwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NQQU5JRU4nLCB4OiAzMTYwMDk2LCB5OiAxODUwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NDSFdFREVOJywgeDogNDY3MDAwMCwgeTogNDE4MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiwgcm90YXRlOiAtNzUgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnU0NIV0VJWicsIHg6IDQyMDAwMDAsIHk6IDI1NjQwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogNyB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdUUlVUSEFITicsIHg6IDY1MTAwMDAsIHk6IDIxMDAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfSxcclxuICAgICAgICAgICAgeyB0ZXh0OiAnVkVSRUlOSUdURVMnLCB4OiAzNTUwMDAwLCB5OiAzNTIwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0vDlk5JR1JFSUNIJywgeDogMzU1MDAwMCwgeTogMzQyMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAgSUNfMzI2Mjg6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0VTJywgeDogNDIwNDY4LCB5OiAzMTgwNjQ3LCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdDYW5hcnkgSXNsYW5kcycsIHg6IDQyMDQ2OCwgeTogMzE4MDY0NywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBmcjogW3sgdGV4dDogJ0xlcyDDrmxlcyBDYW5hcmllcycsIHg6IDQyMDQ2OCwgeTogMzE4MDY0NywgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ0thbmFyaXNjaGUgSW5zZWxuJywgeDogNDEwMDAwLCB5OiAzMTgwNjQ3LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgfSxcclxuICAgIEdQXzMyNjIwOiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdGUicsIHg6IDY2NzAwMCwgeTogMTc0MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnR3VhZGVsb3VwZScsIHg6IDcwMDAwMCwgeTogMTgxMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgIH0sXHJcbiAgICBNUV8zMjYyMDoge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnRlInLCB4OiA3MTY1MjEsIHk6IDE2MjEzMjIsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ01hcnRpbmlxdWUnLCB4OiA3MTY1MjEsIHk6IDE2MjEzMjIsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTIgfV0sXHJcbiAgICB9LFxyXG4gICAgR0ZfMzI2MjI6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0ZSJywgeDogMjY2ODUyLCB5OiA0NDQwNzQsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0d1eWFuZScsIHg6IDI2Njg1MiwgeTogNDQ0MDc0LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGRlOiBbeyB0ZXh0OiAnR3VheWFuYScsIHg6IDI2Njg1MiwgeTogNDQ0MDc0LCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgfSxcclxuICAgIFJFXzMyNzQwOiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdGUicsIHg6IDM0ODAxMSwgeTogNzY4MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnUsOpdW5pb24nLCB4OiAzNDgwMTEsIHk6IDc2ODAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICB9LFxyXG4gICAgWVRfMzI3Mzg6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ0ZSJywgeDogNTE2NTQ5LCB5OiA4NTkzOTIwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdNYXlvdHRlJywgeDogNTE2NTQ5LCB5OiA4NTkzOTIwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgfSxcclxuICAgIE1UXzMwMzU6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ01UJywgeDogNDcxOTc1NSwgeTogMTQxMDcwMSwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnTWFsdGEnLCB4OiA0NzE5NzU1LCB5OiAxNDEwNzAxLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgfSxcclxuICAgIFBUMjBfMzI2MjY6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ1BUJywgeDogMzk3NDE4LCB5OiA0MzIwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdBem9yZXMnLCB4OiAzOTc0MTgsIHk6IDQzMjAwMDAsIGNsYXNzOiAnY291bnRyaWVzJywgc2l6ZTogMTAgfV0sXHJcbiAgICAgICAgZnI6IFt7IHRleHQ6ICdBw6dvcmVzJywgeDogMzk3NDE4LCB5OiA0MjcxNDcxLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGRlOiBbeyB0ZXh0OiAnQXpvcmVuJywgeDogMzk3NDE4LCB5OiA0MjcxNDcxLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH1dLFxyXG4gICAgfSxcclxuICAgIFBUMzBfMzI2Mjg6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ1BUJywgeDogMzMzNTg2LCB5OiAzNjI0MDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTAsIHJvdGF0ZTogMzAgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdNYWRlaXJhJywgeDogMzMzNTg2LCB5OiAzNjI0MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwLCByb3RhdGU6IDMwIH1dLFxyXG4gICAgICAgIGZyOiBbeyB0ZXh0OiAnTWFkw6hyZScsIHg6IDMzMzU4NiwgeTogMzYyNDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCwgcm90YXRlOiAzMCB9XSxcclxuICAgIH0sXHJcbiAgICBMSV8zMDM1OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdMSScsIHg6IDQyODcwNjAsIHk6IDI2NjAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ0xpZWNodGVuc3RlaW4nLCB4OiA0Mjg3MDYwLCB5OiAyNjc5MDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDcgfV0sXHJcbiAgICB9LFxyXG4gICAgSVNfMzAzNToge1xyXG4gICAgICAgIGNjOiBbeyB0ZXh0OiAnSVMnLCB4OiAzMDExODA0LCB5OiA0OTYwMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogMTIgfV0sXHJcbiAgICAgICAgZW46IFt7IHRleHQ6ICdJY2VsYW5kJywgeDogMzAxMTgwNCwgeTogNDk2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgICAgICBmcjogW3sgdGV4dDogJ0lzbGFuZGUnLCB4OiAzMDExODA0LCB5OiA0OTYwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEyIH1dLFxyXG4gICAgICAgIGRlOiBbeyB0ZXh0OiAnSXNsYW5kJywgeDogMzAxMTgwNCwgeTogNDk2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMiB9XSxcclxuICAgIH0sXHJcbiAgICBTSl9TVl8zMDM1OiB7XHJcbiAgICAgICAgY2M6IFt7IHRleHQ6ICdOTycsIHg6IDQ1NzAwMDAsIHk6IDYyNjAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBlbjogW3sgdGV4dDogJ1N2YWxiYXJkJywgeDogNDU3MDAwMCwgeTogNjI2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9XSxcclxuICAgICAgICBkZTogW3sgdGV4dDogJ1NwaXR6YmVyZ2VuJywgeDogNDU3MDAwMCwgeTogNjI2MDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH1dLFxyXG4gICAgfSxcclxuICAgIFNKX0pNXzMwMzU6IHtcclxuICAgICAgICBjYzogW3sgdGV4dDogJ05PJywgeDogMzY0Nzc2MiwgeTogNTQyMDMwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH1dLFxyXG4gICAgICAgIGVuOiBbeyB0ZXh0OiAnSmFuIE1heWVuJywgeDogMzY0Nzc2MiwgeTogNTQyMDMwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH1dLFxyXG4gICAgfSxcclxuICAgIENBUklCXzMyNjIwOiB7XHJcbiAgICAgICAgY2M6IFtcclxuICAgICAgICAgICAgeyB0ZXh0OiAnRlInLCB4OiA3MDAwMDAsIHk6IDE4MTAwMDAsIGNsYXNzOiAnY2MnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdGUicsIHg6IDY0MDAwMCwgeTogMTU5MDAwMCwgY2xhc3M6ICdjYycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0ZSJywgeDogNTQwMDAwLCB5OiAxOTYyMDAwLCBjbGFzczogJ2NjJywgc2l6ZTogNyB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZW46IFtcclxuICAgICAgICAgICAgeyB0ZXh0OiAnR3VhZGVsb3VwZScsIHg6IDcwMDAwMCwgeTogMTgxMDAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdNYXJ0aW5pcXVlJywgeDogNTcwMDAwLCB5OiAxNTkwMDAwLCBjbGFzczogJ2NvdW50cmllcycsIHNpemU6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NhaW50IE1hcnRpbicsIHg6IDU5NzAwMCwgeTogMTk2MjAwMCwgY2xhc3M6ICdjb3VudHJpZXMnLCBzaXplOiA3IH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICAvLyBub3RlOiBXT1JMRCB4L3kgYXJlIGluIEVQU0c6NDMyNiB0aGVuIHJlcHJvamVjdGVkIGJ5IGQzIHRvIEVQU0c6NTQwMzBcclxuICAgIFdPUkxEXzU0MDMwOiB7XHJcbiAgICAgICAgZW46IFtcclxuICAgICAgICAgICAgeyB0ZXh0OiAnTk9SVEggQVRMQU5USUMnLCB4OiAtNDUsIHk6IDI1LCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTT1VUSCBBVExBTlRJQycsIHg6IC0xNSwgeTogLTI1LCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdTT1VUSCBQQUNJRklDJywgeDogLTEyNiwgeTogLTI1LCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdOT1JUSCcsIHg6IC0xMzYsIHk6IDI1LCBjbGFzczogJ3NlYXMnLCBzaXplOiAxMCwgbGV0dGVyU3BhY2luZzogMSB9LFxyXG4gICAgICAgICAgICB7IHRleHQ6ICdQQUNJRklDJywgeDogLTEzNCwgeTogMjAsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ0lORElBTiBPQ0VBTicsIHg6IDgwLCB5OiAtMjUsIGNsYXNzOiAnc2VhcycsIHNpemU6IDEwLCBsZXR0ZXJTcGFjaW5nOiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dDogJ1NPVVRIRVJOIE9DRUFOJywgeDogLTUsIHk6IC02NywgY2xhc3M6ICdzZWFzJywgc2l6ZTogMTAsIGxldHRlclNwYWNpbmc6IDYgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxufVxyXG5cclxuY29uc3QgREVGQVVMVFNUQVRMQUJFTFBPU0lUSU9OUyA9IHtcclxuICAgIEFMOiB7IHg6IDUxNTAwMDAsIHk6IDIwMDAwMDAgfSxcclxuICAgIEFUOiB7IHg6IDQ2NzAwMDAsIHk6IDI3NDAwMDAgfSxcclxuICAgIEJFOiB7IHg6IDM5MzAwMDAsIHk6IDMwNjAwMDAgfSxcclxuICAgIEJHOiB7IHg6IDU1NjcwMDAsIHk6IDIzMDAwMDAgfSxcclxuICAgIEhSOiB7IHg6IDQ2NTc3MTgsIHk6IDI0MDAyNDMgfSxcclxuICAgIENZOiB7IHg6IDY0MjYwMDAsIHk6IDE1NzAwMDAgfSxcclxuICAgIENIOiB7IHg6IDQxNzAwMDAsIHk6IDI2MDAwMDAgfSxcclxuICAgIENaOiB7IHg6IDQ3MDcwMDAsIHk6IDI5NTAwMDAgfSxcclxuICAgIERLOiB7IHg6IDQzMTYwMDAsIHk6IDM2MjEwMDAgfSxcclxuICAgIEVFOiB7IHg6IDUyMjAwMDAsIHk6IDQwNTAwMDAgfSxcclxuICAgIEZJOiB7IHg6IDUxNTAwMDAsIHk6IDQ0MjQwMDAgfSxcclxuICAgIEZSOiB7IHg6IDM3Njc3NDAsIHk6IDI2NjI4MTcgfSxcclxuICAgIERFOiB7IHg6IDQzNDcyODQsIHk6IDMwOTMyNzYgfSxcclxuICAgIEVMOiB7IHg6IDUzNzAwMDAsIHk6IDE3NTAwMDAgfSxcclxuICAgIEhVOiB7IHg6IDUwMjAwMDAsIHk6IDI2NzAwMDAgfSxcclxuICAgIElTOiB7IHg6IDMwNDAwMDAsIHk6IDQ4MzMwMDAgfSxcclxuICAgIElFOiB7IHg6IDMxMzYwMDAsIHk6IDMzOTQwMDAgfSxcclxuICAgIElUOiB7IHg6IDQ1MDAwMDAsIHk6IDIxODE5NjMgfSxcclxuICAgIExWOiB7IHg6IDUyOTAwMDAsIHk6IDM4NDAwMDAgfSxcclxuICAgIExUOiB7IHg6IDUxOTAwMDAsIHk6IDM2NzAwMDAgfSxcclxuICAgIExVOiB7IHg6IDQxMjAwMDAsIHk6IDI5NDAwMDAgfSxcclxuICAgIE1UOiB7IHg6IDQ4ODAwMDAsIHk6IDE0ODAwMDAgfSxcclxuICAgIEdFOiB7IHg6IDY5MTI2ODAsIHk6IDI2OTY1NTQgfSxcclxuICAgIFVBOiB7IHg6IDU4NjU1MDcsIHk6IDMxMzAxNTggfSxcclxuICAgIEJBOiB7IHg6IDQ5NTkyNjIsIHk6IDIzNjg2ODggfSxcclxuICAgIE1EOiB7IHg6IDU3MzYwMTYsIHk6IDI4MzU5NTcgfSxcclxuICAgIE1FOiB7IHg6IDUwNzMwMDAsIHk6IDIyMzAwMDAgfSxcclxuICAgIE1LOiB7IHg6IDUzMDAwMDAsIHk6IDIxMzAwMDAgfSxcclxuICAgIE5MOiB7IHg6IDQwMjAwMDAsIHk6IDMyMDgwMDAgfSxcclxuICAgIE5POiB7IHg6IDQzMDAwMDAsIHk6IDQxNDcwMDAgfSxcclxuICAgIFBMOiB7IHg6IDQ5NjQwMDAsIHk6IDMyMDAwMDAgfSxcclxuICAgIFBUOiB7IHg6IDI3NjAwMDAsIHk6IDE5OTAwMDAgfSxcclxuICAgIFJPOiB7IHg6IDU0NTEwMDAsIHk6IDI2MDAwMDAgfSxcclxuICAgIFJTOiB7IHg6IDUyMDAwMDAsIHk6IDIzNzAwMDAgfSxcclxuICAgIFNLOiB7IHg6IDUwNDAwMDAsIHk6IDI4OTAwMDAgfSxcclxuICAgIFNJOiB7IHg6IDQ2NjAwMDAsIHk6IDI1NTAwMDAgfSxcclxuICAgIEVTOiB7IHg6IDMyMDAwMDAsIHk6IDIwMDAwMDAgfSxcclxuICAgIFNFOiB7IHg6IDQ2MzAwMDAsIHk6IDQwMDAwMDAgfSxcclxuICAgIFRSOiB7IHg6IDY1MTAwMDAsIHk6IDIxMDAwMDAgfSxcclxuICAgIFVLOiB7IHg6IDM1NTgwMDAsIHk6IDMyNTAwMDAgfSxcclxuICAgIFJVOiB7IHg6IDY4NDIwODYsIHk6IDMyMzA1MTcgfSxcclxufVxyXG4iLCJpbXBvcnQgeyB6b29tLCB6b29tSWRlbnRpdHkgfSBmcm9tICdkMy16b29tJ1xyXG5pbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgZ2VvSWRlbnRpdHksIGdlb1BhdGgsIGdlb0NlbnRyb2lkIH0gZnJvbSAnZDMtZ2VvJ1xyXG5pbXBvcnQgeyBnZW9Sb2JpbnNvbiB9IGZyb20gJ2QzLWdlby1wcm9qZWN0aW9uJ1xyXG5pbXBvcnQgeyBnZXRCQk9YQXNHZW9KU09OLCBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgZ2V0UGFyYW1ldGVyQnlOYW1lLCBjb252ZXJ0UmVjdGFuZ2xlc1RvUGF0aHMgfSBmcm9tICcuL3V0aWxzJ1xyXG5pbXBvcnQgeyBhcHBlbmRBbm5vdGF0aW9ucyB9IGZyb20gJy4vYW5ub3RhdGlvbnMnXHJcbmltcG9ydCB7IGFkZExhYmVsc1RvTWFwLCB1cGRhdGVMYWJlbHMsIHVwZGF0ZVZhbHVlc0xhYmVscyB9IGZyb20gJy4vbGFiZWxzJ1xyXG5pbXBvcnQgeyBkZWZpbmVEZXByZWNhdGVkRnVuY3Rpb25zIH0gZnJvbSAnLi9kZXByZWNhdGVkJ1xyXG5pbXBvcnQgeyBHZW9tZXRyaWVzIH0gZnJvbSAnLi9nZW9tZXRyaWVzJ1xyXG5pbXBvcnQgeyBidWlsZEluc2V0cywgcmVtb3ZlSW5zZXRzIH0gZnJvbSAnLi9pbnNldHMnXHJcbmltcG9ydCB7IGFwcGVuZFN0YW1wIH0gZnJvbSAnLi9zdGFtcHMnXHJcbmltcG9ydCB7IGJ1aWxkR3JpZENhcnRvZ3JhbUJhc2UgfSBmcm9tICcuL2NhcnRvZ3JhbXMnXHJcblxyXG4vLyBzZXQgZGVmYXVsdCBkMyBsb2NhbGVcclxuZm9ybWF0RGVmYXVsdExvY2FsZSh7XHJcbiAgICBkZWNpbWFsOiAnLicsXHJcbiAgICB0aG91c2FuZHM6ICcgJyxcclxuICAgIGdyb3VwaW5nOiBbM10sXHJcbiAgICBjdXJyZW5jeTogWycnLCAn4oKsJ10sXHJcbn0pXHJcblxyXG4vKipcclxuICogVGhlIG1hcCB0ZW1wbGF0ZTogb25seSB0aGUgZ2VvbWV0cmljYWwgcGFydC5cclxuICogVG8gYmUgdXNlZCBhcyBhIGJhc2UgbWFwIGZvciBhIHN0YXRpc3RpY2FsIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSB3aXRoQ2VudGVyUG9pbnRzIFNldCB0byB0cnVlIChvciAxKSB0byBhZGQgcmVnaW9ucyBjZW50ZXIgcG9pbnRzIHRvIHRoZSBtYXAgdGVtcGxhdGUsIHRvIGJlIHVzZWQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2xzIG1hcHMgZm9yIGV4YW1wbGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwVGVtcGxhdGUgPSBmdW5jdGlvbiAoY29uZmlnLCB3aXRoQ2VudGVyUG9pbnRzLCBtYXBUeXBlKSB7XHJcbiAgICAvL2J1aWxkIG1hcCB0ZW1wbGF0ZSBvYmplY3RcclxuICAgIGNvbnN0IG91dCA9IHt9XHJcbiAgICBvdXQuX21hcFR5cGUgPSBtYXBUeXBlXHJcblxyXG4gICAgLy8gZXhwb3NlIGltcG9ydGVkIGZ1bmN0aW9uIHRvIG90aGVyIG1vZHVsZXNcclxuICAgIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMgPSB1cGRhdGVWYWx1ZXNMYWJlbHNcclxuXHJcbiAgICAvL21hcFxyXG4gICAgb3V0LnN2Z0lkXyA9ICdtYXAnXHJcbiAgICBvdXQuc3ZnXyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LndpZHRoXyA9IE1hdGgubWluKDc5NSwgd2luZG93LmlubmVyV2lkdGgpXHJcbiAgICBvdXQuaGVpZ2h0XyA9IDBcclxuICAgIG91dC5jb250YWluZXJJZF8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL2dlb2dyYXBoaWNhbCBmb2N1c1xyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1fID0gZmFsc2UgLy8gZHJhdyBnZW9tZXRyaWVzIGFzIGdyaWQgY2VsbHNcclxuICAgIG91dC5ncmlkQ2FydG9ncmFtU2hhcGVfID0gJ3NxdWFyZScgLy8gc3F1YXJlIG9yIGhleGFnb25cclxuICAgIG91dC5ncmlkQ2FydG9ncmFtTWFyZ2luc18gPSB7IHRvcDogODAsIHJpZ2h0OiA1MCwgYm90dG9tOiA4MCwgbGVmdDogMTUwIH1cclxuICAgIG91dC5ncmlkQ2FydG9ncmFtQ2VsbFBhZGRpbmdfID0gNFxyXG4gICAgb3V0LmdyaWRDYXJ0b2dyYW1Qb3NpdGlvbnNfID0gdW5kZWZpbmVkIC8vdXNlciBkZWZpbmVkIGNhcnRvZ3JhbXNcclxuICAgIG91dC5udXRzTGV2ZWxfID0gMyAvLyAwLDEsMiwzLCBvciAnbWl4ZWQnXHJcbiAgICBvdXQubnV0c1llYXJfID0gMjAyNFxyXG4gICAgb3V0Lmdlb18gPSAnRVVSJ1xyXG4gICAgb3V0LnByb2pfID0gJzMwMzUnXHJcbiAgICBvdXQucHJvamVjdGlvbkZ1bmN0aW9uXyA9IHVuZGVmaW5lZCAvLyBlLmcuIGQzLmdlb1JvYmluc29uKClcclxuICAgIG91dC5maWx0ZXJHZW9tZXRyaWVzRnVuY3Rpb25fID0gdW5kZWZpbmVkIC8vIHVzZXIgZGVmaW5lZCBmaWx0ZXIgZnVuY3Rpb25cclxuICAgIG91dC5zY2FsZV8gPSAnMjBNJyAvL1RPRE8gY2hvb3NlIGF1dG9tYXRpY2FsbHksIGRlcGVuZGluZyBvbiBwaXhlbFNpemUgP1xyXG4gICAgb3V0Lnpvb21FeHRlbnRfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQubWF4Qm91bmRzXyA9IHsgeE1pbjogLUluZmluaXR5LCB5TWluOiAtSW5maW5pdHksIHhNYXg6IEluZmluaXR5LCB5TWF4OiBJbmZpbml0eSB9XHJcbiAgICBvdXQuZ2VvbWV0cmllc18gPSB1bmRlZmluZWQgLy8gW3tpZDpTdHJpbmcsIGRhdGE6Z2VvanNvbiwgY2xhc3M6ZnVuY3Rpb259XSB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgb3V0LnByb2Nlc3NDZW50cm9pZHNfID0gdW5kZWZpbmVkIC8vIHJ1bnMgb3ZlciBzeW1ib2wgY2VudHJvaWRzXHJcbiAgICBvdXQucG9zaXRpb25fID0geyB4OiB1bmRlZmluZWQsIHk6IHVuZGVmaW5lZCwgejogdW5kZWZpbmVkIH0gLy8gbWFwIHZpZXdcclxuXHJcbiAgICAvL21hcCB0aXRsZVxyXG4gICAgb3V0LnRpdGxlXyA9ICcnXHJcbiAgICBvdXQudGl0bGVQb3NpdGlvbl8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL21hcCBzdWJ0aXRsZVxyXG4gICAgb3V0LnN1YnRpdGxlXyA9ICcnXHJcbiAgICBvdXQuc3VidGl0bGVQb3NpdGlvbl8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3NjYWxlYmFyXHJcbiAgICBvdXQuc2hvd1NjYWxlYmFyXyA9IGZhbHNlXHJcbiAgICBvdXQuc2NhbGViYXJQb3NpdGlvbl8gPSBbXVxyXG4gICAgb3V0LnNjYWxlYmFyVW5pdHNfID0gJyBrbScgLy9sYWJlbFxyXG4gICAgb3V0LnNjYWxlYmFyVGV4dE9mZnNldF8gPSBbMCwgMTJdXHJcbiAgICBvdXQuc2NhbGViYXJNYXhXaWR0aF8gPSAxNTAgLy9weFxyXG4gICAgb3V0LnNjYWxlYmFySGVpZ2h0XyA9IDkwIC8vcHhcclxuICAgIG91dC5zY2FsZWJhclN0cm9rZVdpZHRoXyA9IDEgLy9weFxyXG4gICAgb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8gPSA2XHJcbiAgICBvdXQuc2NhbGViYXJUaWNrSGVpZ2h0XyA9IDhcclxuXHJcbiAgICAvLyBzdGFtcCBhbm5vdGF0aW9uXHJcbiAgICBvdXQuc3RhbXBfID0gdW5kZWZpbmVkIC8vZS5nIHt4LHksdGV4dCxzaXplfVxyXG5cclxuICAgIC8vdG9vbHRpcFxyXG4gICAgb3V0LnRvb2x0aXBfID0ge1xyXG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXHJcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAyMDAsXHJcbiAgICAgICAgeE9mZnNldDogMCxcclxuICAgICAgICB5T2Zmc2V0OiAwLFxyXG4gICAgICAgIHRleHRGdW5jdGlvbjogbnVsbCxcclxuICAgICAgICBzaG93RmxhZ3M6IGZhbHNlLFxyXG4gICAgfSAvLyAgU2VlIHRvb2x0aXAuanMgZm9yIG1vcmUgZGV0YWlsc1xyXG5cclxuICAgIC8vIHJlZ2lvbiBtb3VzZW92ZXIgY29sb3JcclxuICAgIG91dC5ob3ZlckNvbG9yXyA9ICdyZWQnXHJcblxyXG4gICAgLy9jb2FzdGFsIG1hcmdpblxyXG4gICAgb3V0LmRyYXdDb2FzdGFsTWFyZ2luXyA9IGZhbHNlXHJcbiAgICBvdXQuY29hc3RhbE1hcmdpblN0ZERldl8gPSAzXHJcblxyXG4gICAgLy9ncmF0aWN1bGVcclxuICAgIG91dC5kcmF3R3JhdGljdWxlXyA9IGZhbHNlXHJcblxyXG4gICAgLy9iYWNrZ3JvdW5kIG1hcCB0b2dnbGUgKGUuZy4gZm9yIGRvcmxpbmcpXHJcbiAgICBvdXQuYmFja2dyb3VuZE1hcF8gPSB0cnVlXHJcblxyXG4gICAgLy9sYWJlbGxpbmdcclxuICAgIC8vIHNlZSBkb2NzXFxyZWZlcmVuY2UubWQjbGFiZWxsaW5nXHJcbiAgICBvdXQubGFiZWxzXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vYW5ub3RhdGlvbnNcclxuICAgIG91dC5hbm5vdGF0aW9uc18gPSB1bmRlZmluZWRcclxuICAgIG91dC5hbm5vdGF0aW9uc0FkZGVkID0gZmFsc2UgLy9zaW1wbGUgZmxhZyB0byBrbm93IHdoZW4gYW5ub3RhdGlvbnMgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWRcclxuXHJcbiAgICAvL2hhdGNoaW5nXHJcbiAgICBvdXQucGF0dGVybkZpbGxfID0gdW5kZWZpbmVkIC8vIGUuZy4ge3BhdHRlcm46J2hhdGNoaW5nJyxyZWdpb25JZHM6WydERScsJ0ZSJ119XHJcblxyXG4gICAgLy9kYXRhc2V0IHNvdXJjZSBsaW5rXHJcbiAgICBvdXQuc2hvd1NvdXJjZUxpbmtfID0gdHJ1ZVxyXG5cclxuICAgIC8vZGVmYXVsdCBjb3B5cmlnaHQgYW5kIGRpc2NsYWltZXIgdGV4dFxyXG4gICAgb3V0LmZvb3Rub3RlXyA9ICdBZG1pbmlzdHJhdGl2ZSBib3VuZGFyaWVzOiBcXHUwMEE5RXVyb0dlb2dyYXBoaWNzIFxcdTAwQTlVTi1GQU8gXFx1MDBBOUlOU1RBVCBcXHUwMEE5VHVya3N0YXQnIC8vXCIoQylFdXJvR2VvZ3JhcGhpY3MgKEMpVU4tRkFPIChDKVR1cmtzdGF0XCI7XHJcbiAgICBvdXQuZm9vdG5vdGVUb29sdGlwVGV4dF8gPVxyXG4gICAgICAgICdUaGUgZGVzaWduYXRpb25zIGVtcGxveWVkIGFuZCB0aGUgcHJlc2VudGF0aW9uIG9mIG1hdGVyaWFsIG9uIHRoaXMgbWFwIGRvIG5vdCBpbXBseSB0aGUgZXhwcmVzc2lvbiBvZiBhbnkgb3BpbmlvbiB3aGF0c29ldmVyIG9uIHRoZSBwYXJ0IG9mIHRoZSBFdXJvcGVhbiBVbmlvbiBjb25jZXJuaW5nIHRoZSBsZWdhbCBzdGF0dXMgb2YgYW55IGNvdW50cnksIHRlcnJpdG9yeSwgY2l0eSBvciBhcmVhIG9yIG9mIGl0cyBhdXRob3JpdGllcywgb3IgY29uY2VybmluZyB0aGUgZGVsaW1pdGF0aW9uIG9mIGl0cyBmcm9udGllcnMgb3IgYm91bmRhcmllcy4gS29zb3ZvKjogVGhpcyBkZXNpZ25hdGlvbiBpcyB3aXRob3V0IHByZWp1ZGljZSB0byBwb3NpdGlvbnMgb24gc3RhdHVzLCBhbmQgaXMgaW4gbGluZSB3aXRoIFVOU0NSIDEyNDQvMTk5OSBhbmQgdGhlIElDSiBPcGluaW9uIG9uIHRoZSBLb3Nvdm8gZGVjbGFyYXRpb24gb2YgaW5kZXBlbmRlbmNlLidcclxuXHJcbiAgICBvdXQubnV0czJqc29uQmFzZVVSTF8gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUuaW5jbHVkZXMoJ2VjLmV1cm9wYS5ldScpXHJcbiAgICAgICAgPyAnaHR0cHM6Ly9lYy5ldXJvcGEuZXUvYXNzZXRzL2VzdGF0L0UvRTQvZ2lzY28vcHViL251dHMyanNvbi92MidcclxuICAgICAgICA6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXVyb3N0YXQvTnV0czJqc29uL21hc3Rlci9wdWIvdjInXHJcblxyXG4gICAgLy9zdHlsZSBmb3Igbm8gZGF0YSByZWdpb25zXHJcbiAgICBvdXQubm9EYXRhRmlsbFN0eWxlXyA9ICcjYmNiY2JjJ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXRzLlxyXG4gICAgICogVGhlIG1hcCB0ZW1wbGF0ZSBoYXMgYSByZWN1cnNpdmUgc3RydWN0dXJlLlxyXG4gICAgICovXHJcblxyXG4gICAgLy9pbnNldHMgdG8gc2hvdywgYXMgYSBsaXN0IG9mIG1hcCB0ZW1wbGF0ZSBjb25maWdzLiBFeC46IFt7Z2VvOlwiTVRcIn0se2dlbzpcIkxJXCJ9LHtnZW86XCJQVDIwXCJ9XVxyXG4gICAgb3V0Lmluc2V0c18gPSBbXVxyXG4gICAgLy9pbnNldCB0ZW1wbGF0ZXMgLSBlYWNoIGluc2V0IGlzIGEgbWFwLXRlbXBsYXRlIGluc3RhbmNlLlxyXG4gICAgb3V0Lmluc2V0VGVtcGxhdGVzXyA9IHt9XHJcblxyXG4gICAgb3V0Lmluc2V0Qm94UG9zaXRpb25fID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuaW5zZXRCb3hQYWRkaW5nXyA9IDVcclxuICAgIG91dC5pbnNldEJveFdpZHRoXyA9IDIxMFxyXG4gICAgLy9vdXQuaW5zZXRab29tRXh0ZW50XyA9IFsxLCAzXTtcclxuICAgIG91dC5pbnNldFpvb21FeHRlbnRfID0gbnVsbCAvL3pvb20gZGlzYWJsZWQgYXMgZGVmYXVsdFxyXG4gICAgb3V0Lmluc2V0U2NhbGVfID0gJzAzTSdcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICBmb3IgKGNvbnN0IGF0dCBpbiBvdXQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2FybiBleGlzdGluZyB1c2VycyBvZiBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gYmFuaXNoZWQgdG8gdGhlIHNoYWRvdyByZWFsbS5cclxuICAgIGRlZmluZURlcHJlY2F0ZWRGdW5jdGlvbnMob3V0KVxyXG5cclxuICAgIC8vIGNvbnZlcnQgZ2VvIHRvIHVwcGVyY2FzZVxyXG4gICAgb3V0LmdlbyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0Lmdlb19cclxuICAgICAgICBvdXQuZ2VvXyA9IHYudG9VcHBlckNhc2UoKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL3NwZWNpYWwgb25lcyB3aGljaCBhZmZlY3QgYWxzbyB0aGUgaW5zZXRzXHJcbiAgICA7Wyd0b29sdGlwXycsICdudXRzMmpzb25CYXNlVVJMXycsICdwcm9jZXNzQ2VudHJvaWRzXyddLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHYpKSB7XHJcbiAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGRlZmF1bHQgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIGluIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRbYXR0XVtwXSA9IHZbcF1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3JlY3Vyc2l2ZSBjYWxsIHRvIGluc2V0IGNvbXBvbmVudHNcclxuICAgICAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMoXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmluc2V0VGVtcGxhdGVzXyxcclxuICAgICAgICAgICAgICAgICAgICBvdXQuc3ZnSWRfLFxyXG4gICAgICAgICAgICAgICAgICAgIChpbnNldCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm5OYW1lID0gYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXRbZm5OYW1lXSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHZcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL3RpdGxlIGdldHRlciBhbmQgc2V0dGVyXHJcbiAgICBvdXQudGl0bGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC50aXRsZV9cclxuICAgICAgICBvdXQudGl0bGVfID0gdlxyXG4gICAgICAgIGlmIChvdXQuc3ZnKCkpXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnI3RpdGxlJyArIG91dC5nZW8oKSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KHYpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vc3VidGl0bGUgZ2V0dGVyIGFuZCBzZXR0ZXJcclxuICAgIG91dC5zdWJ0aXRsZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnN1YnRpdGxlX1xyXG4gICAgICAgIG91dC5zdWJ0aXRsZV8gPSB2XHJcbiAgICAgICAgaWYgKG91dC5zdmcoKSlcclxuICAgICAgICAgICAgb3V0LnN2ZygpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcjc3VidGl0bGUnICsgb3V0LmdlbygpKVxyXG4gICAgICAgICAgICAgICAgLnRleHQodilcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9pbnNldHMgZ2V0dGVyL3NldHRlclxyXG4gICAgb3V0Lmluc2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuaW5zZXRzX1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgYXJndW1lbnRzWzBdID09PSAnZGVmYXVsdCcpIG91dC5pbnNldHNfID0gJ2RlZmF1bHQnXHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIGFyZ3VtZW50c1swXSA9PT0gZmFsc2UpIG91dC5pbnNldHNfID0gZmFsc2VcclxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSBvdXQuaW5zZXRzXyA9IGFyZ3VtZW50c1swXVxyXG4gICAgICAgIGVsc2Ugb3V0Lmluc2V0c18gPSBhcmd1bWVudHNcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZHluYW1pYyBkcmF3IGdyYXRpY3VsZVxyXG4gICAgb3V0LmRyYXdHcmF0aWN1bGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5kcmF3R3JhdGljdWxlX1xyXG4gICAgICAgIG91dC5kcmF3R3JhdGljdWxlXyA9IHZcclxuXHJcbiAgICAgICAgLy91cGRhdGUgZ3JhdGljdWxlXHJcbiAgICAgICAgbGV0IGdyYXRpY3VsZSA9IG91dC5zdmdfID8gb3V0LnN2ZygpLnNlbGVjdCgnI2VtLWdyYXRpY3VsZScpIDogbnVsbFxyXG4gICAgICAgIGxldCB6ZyA9IG91dC5zdmdfID8gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXykgOiBudWxsXHJcblxyXG4gICAgICAgIC8vIGlmIGV4aXN0aW5nIGFuZCBhcmd1bWVudCBpcyBmYWxzZVxyXG4gICAgICAgIGlmIChncmF0aWN1bGUpIHtcclxuICAgICAgICAgICAgaWYgKGdyYXRpY3VsZS5fZ3JvdXBzWzBdWzBdICYmIHYgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGdyYXRpY3VsZVxyXG4gICAgICAgICAgICAgICAgZ3JhdGljdWxlLnJlbW92ZSgpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbWFwIGFscmVhZHkgY3JlYXRlZCBhbmQgYXJndW1lbnQgaXMgdHJ1ZVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5HZW9tZXRyaWVzLmdlb0pTT05zLmdyYXRpY3VsZSAmJiBvdXQuX3BhdGhGdW5jdGlvbiAmJiB6ZyAmJiB2ID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGV4aXN0aW5nIGdyYXRpY3VsZVxyXG4gICAgICAgICAgICAgICAgZ3JhdGljdWxlLnJlbW92ZSgpXHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgbmV3IGdyYXRpY3VsZVxyXG4gICAgICAgICAgICAgICAgemcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tZ3JhdGljdWxlJylcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YShvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5ncmF0aWN1bGUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIG91dC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1ncmF0aWN1bGUnKVxyXG5cclxuICAgICAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyNlbS1ncmF0aWN1bGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBncmF0aWN1bGUgYmVoaW5kIGxhbmQgbWFzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvXyA9PSAnV09STEQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXNbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXNbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb2FzdGFsIG1hcmdpbiBvdmVycmlkZVxyXG4gICAgb3V0LmRyYXdDb2FzdGFsTWFyZ2luID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuZHJhd0NvYXN0YWxNYXJnaW5fXHJcbiAgICAgICAgb3V0LmRyYXdDb2FzdGFsTWFyZ2luXyA9IHZcclxuXHJcbiAgICAgICAgLy91cGRhdGUgZXhpc3RpbmdcclxuICAgICAgICBpZiAob3V0LnN2Z18pIHtcclxuICAgICAgICAgICAgbGV0IG1hcmdpbiA9IHNlbGVjdEFsbCgnI2VtLWNvYXN0LW1hcmdpbicpXHJcbiAgICAgICAgICAgIGxldCBmaWx0ZXIgPSBzZWxlY3QoJyNlbS1jb2FzdGFsLWJsdXInKVxyXG4gICAgICAgICAgICBsZXQgemcgPSBzZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKSB8fCBudWxsXHJcbiAgICAgICAgICAgIGlmIChtYXJnaW4uX2dyb3Vwc1swXVswXSAmJiB2ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcclxuICAgICAgICAgICAgICAgIG1hcmdpbi5yZW1vdmUoKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgPT0gdHJ1ZSAmJiBvdXQuX3BhdGhGdW5jdGlvbiAmJiB6Zykge1xyXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgZXhpc3RpbmcgZ3JhdGljdWxlXHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ucmVtb3ZlKClcclxuICAgICAgICAgICAgICAgIGZpbHRlci5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgLy9hZGQgZmlsdGVyXHJcbiAgICAgICAgICAgICAgICBvdXQuc3ZnX1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2ZpbHRlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0YWwtYmx1cicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAnLTIwMCUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJy0yMDAlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAnNDAwJScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsICc0MDAlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdmZUdhdXNzaWFuQmx1cicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdGREZXZpYXRpb24nLCBvdXQuY29hc3RhbE1hcmdpblN0ZERldl8pXHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGZvciBtYWluIG1hcCAtIGdlb21ldHJpZXMgYXJlIHN0aWxsIGluIG1lbW9yeSBzbyBubyByZWJ1aWxkIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd05ld0NvYXN0YWxNYXJnaW4gPSAobWFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gem9vbSBncm91cCBtaWdodCBub3QgYmUgaW5zaWRlIG1haW4gbWFwIChvdXQuc3ZnXylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBzZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBtYXAuc3ZnSWRfKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vZHJhdyBuZXcgY29hc3RhbCBtYXJnaW5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZyA9IHpvb21Hcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4nKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvdW50cmllcyBiblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuX2dlb20uY250Ym4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLWNudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKG1hcC5fZ2VvbS5jbnRibilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibi5wcm9wZXJ0aWVzLmNvID09PSAnVCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgbWFwLl9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLy9udXRzIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5fZ2VvbS5udXRzYm4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLW51dHMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShtYXAuX2dlb20ubnV0c2JuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuY28gPT09ICdUJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBtYXAuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAvL3dvcmxkIGJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5fZ2VvbS53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbi1udXRzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEobWFwLl9nZW9tLndvcmxkYm4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm4ucHJvcGVydGllcy5DT0FTX0ZMQUcgPT09ICdUJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBtYXAuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgZm9yIGluc2V0cyAtIHJlcXVpcmVzIGdlb21ldHJpZXMgc28gd2UgaGF2ZSB0byByZWJ1aWxkIGJhc2UgdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfICYmIG91dC5kcmF3Q29hc3RhbE1hcmdpbl8pIHtcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGRyYXdOZXdDb2FzdGFsTWFyZ2luKVxyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdOZXdDb2FzdGFsTWFyZ2luKG91dClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIG1hcmdpbiB0byBiYWNrIChpbiBmcm9udCBvZiBzZWEpXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RBbGwoJyNlbS1jb2FzdC1tYXJnaW4nKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuZ2VvXyA9PSAnV09STEQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlc1szXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzFdKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9hbm5vdGF0aW9ucyBvdmVycmlkZSAodXBkYXRlIGFmdGVyIGZpcnN0IGNhbGwpXHJcbiAgICBvdXQuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIC8vZ2V0XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmFubm90YXRpb25zX1xyXG4gICAgICAgIC8vc2V0XHJcbiAgICAgICAgb3V0LmFubm90YXRpb25zXyA9IHZcclxuICAgICAgICAvL3VwZGF0ZVxyXG4gICAgICAgIGFwcGVuZEFubm90YXRpb25zKG91dClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9zdGFtcHMgb3ZlcnJpZGUgKHVwZGF0ZSBhZnRlciBmaXJzdCBjYWxsKVxyXG4gICAgb3V0LnN0YW1wID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvL2dldFxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5zdGFtcF9cclxuICAgICAgICAvL3NldFxyXG4gICAgICAgIG91dC5zdGFtcF8gPSB2XHJcbiAgICAgICAgLy91cGRhdGVcclxuICAgICAgICBhcHBlbmRTdGFtcChvdXQuc3RhbXBfLCBvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vbGFiZWxzIG92ZXJyaWRlICh1cGRhdGUgYWZ0ZXIgZmlyc3QgY2FsbClcclxuICAgIG91dC5sYWJlbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIC8vZ2V0XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LmxhYmVsc19cclxuICAgICAgICAvL3NldFxyXG4gICAgICAgIG91dC5sYWJlbHNfID0gdlxyXG4gICAgICAgIC8vdXBkYXRlXHJcbiAgICAgICAgdXBkYXRlTGFiZWxzKG91dClcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW5pdGlhdGUgR2VvbWV0cmllcyBjbGFzc1xyXG4gICAgb3V0Lkdlb21ldHJpZXMgPSBHZW9tZXRyaWVzKG91dCwgd2l0aENlbnRlclBvaW50cylcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3RzIGdlb2dyYXBoaWMgZGF0YSBhbmQgdGhlbiBidWlsZHMgdGhlIG1hcCB0ZW1wbGF0ZVxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlR2VvTWFwVGVtcGxhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBFcmFzZSBwcmV2aW91cyBkYXRhXHJcbiAgICAgICAgb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEgPSBudWxsXHJcbiAgICAgICAgb3V0Lkdlb21ldHJpZXMuYWxsTlVUU0dlb0RhdGEgPSBudWxsXHJcbiAgICAgICAgb3V0Lkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YSA9IG51bGxcclxuXHJcbiAgICAgICAgaWYgKG91dC5nZW9tZXRyaWVzXykge1xyXG4gICAgICAgICAgICBvdXQuR2VvbWV0cmllcy5zZXRVc2VyR2VvbWV0cmllcyhvdXQuZ2VvbWV0cmllc18pXHJcbiAgICAgICAgICAgIC8vIHVzZSBjdXN0b20gdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICAgICAgb3V0LmJ1aWxkTWFwVGVtcGxhdGUoKVxyXG5cclxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFjayBpZiBkZWZpbmVkXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSBkZWZhdWx0XHJcbiAgICAgICAgICAgIG91dC5HZW9tZXRyaWVzLmdldERlZmF1bHRHZW9EYXRhKG91dC5nZW9fLCBvdXQuZmlsdGVyR2VvbWV0cmllc0Z1bmN0aW9uXywgb3V0Lm51dHNMZXZlbF8pLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3V0LmJ1aWxkTWFwVGVtcGxhdGUoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2sgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgZXhlY3V0ZUZvckFsbEluc2V0cyBmb3IgcmVjdXJzaXZlIGluc2V0IHVwZGF0ZXNcclxuICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIChpbnNldCkgPT4ge1xyXG4gICAgICAgICAgICBpbnNldC51cGRhdGVHZW9NYXBUZW1wbGF0ZShjYWxsYmFjaylcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBhIG1hcCBvYmplY3QsIGluY2x1ZGluZyBjb250YWluZXIsIGZyYW1lLCBtYXAgc3ZnLCBpbnNldHMgYW5kIGQzIHpvb21cclxuICAgICAqL1xyXG4gICAgb3V0LmJ1aWxkTWFwVGVtcGxhdGVCYXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vZ2V0IHN2ZyBlbGVtZW50LiBDcmVhdGUgaXQgaWYgaXQgZG9lcyBub3QgZXhpc3RzXHJcbiAgICAgICAgbGV0IHN2ZyA9IHNlbGVjdCgnIycgKyBvdXQuc3ZnSWQoKSlcclxuICAgICAgICBpZiAoc3ZnLnNpemUoKSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHN2ZyA9IHNlbGVjdCgnYm9keScpLmFwcGVuZCgnc3ZnJykuYXR0cignaWQnLCBvdXQuc3ZnSWQoKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgc3ZnLmF0dHIoJ2NsYXNzJywgJ2VtLW1hcCcpXHJcbiAgICAgICAgb3V0LnN2Z18gPSBzdmdcclxuXHJcbiAgICAgICAgLy9zZXQgY29udGFpbmVyIGZvciBjYXNlcyB3aGVyZSBjb250YWluZXIgY29udGFpbnMgdmFyaW91cyBtYXBzXHJcbiAgICAgICAgaWYgKCFvdXQuY29udGFpbmVySWRfKSBvdXQuY29udGFpbmVySWRfID0gb3V0LnN2Z0lkX1xyXG4gICAgICAgIC8vdG9vbHRpcCBuZWVkcyB0byBrbm93IGNvbnRhaW5lciB0byBwcmV2ZW50IG92ZXJmbG93XHJcbiAgICAgICAgaWYgKCFvdXQudG9vbHRpcF8uY29udGFpbmVySWQpIHtcclxuICAgICAgICAgICAgb3V0LnRvb2x0aXBfLmNvbnRhaW5lcklkID0gb3V0LmNvbnRhaW5lcklkX1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jbGVhciBTVkcgKHRvIGF2b2lkIGJ1aWxkaW5nIG11bHRpcGxlIHN2Z3Mgb24gdG9wIG9mIGVhY2ggb3RoZXIgZHVyaW5nIG11bHRpcGxlIGJ1aWxkKCkgY2FsbHMpXHJcbiAgICAgICAgc2VsZWN0QWxsKCcjJyArIG91dC5zdmdJZCgpICsgJyA+IConKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL3NldCBTVkcgZGltZW5zaW9uc1xyXG4gICAgICAgIGlmIChvdXQuZ2VvXy50b1VwcGVyQ2FzZSgpID09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgLy9pZiBubyBoZWlnaHQgd2FzIHNwZWNpZmllZCwgdXNlIDQ1JSBvZiB0aGUgd2lkdGguXHJcbiAgICAgICAgICAgIGlmICghb3V0LmhlaWdodCgpKSBvdXQuaGVpZ2h0KDAuNTUgKiBvdXQud2lkdGgoKSlcclxuICAgICAgICAgICAgc3ZnLmF0dHIoJ3dpZHRoJywgb3V0LndpZHRoKCkpLmF0dHIoJ2hlaWdodCcsIG91dC5oZWlnaHQoKSlcclxuXHJcbiAgICAgICAgICAgIC8vV09STEQgZ2VvIG9ubHkgYWNjZXB0cyBwcm9qIDU0MDMwIChyb2JpbnNvbikgYXQgdGhlIG1vbWVudFxyXG4gICAgICAgICAgICBvdXQucHJval8gPSA1NDAzMFxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2lmIG5vIGhlaWdodCB3YXMgc3BlY2lmaWVkLCB1c2UgODUlIG9mIHRoZSB3aWR0aC5cclxuICAgICAgICBpZiAoIW91dC5oZWlnaHQoKSkgb3V0LmhlaWdodCgwLjg1ICogb3V0LndpZHRoKCkpXHJcbiAgICAgICAgc3ZnLmF0dHIoJ3dpZHRoJywgb3V0LndpZHRoKCkpLmF0dHIoJ2hlaWdodCcsIG91dC5oZWlnaHQoKSlcclxuXHJcbiAgICAgICAgLy8gZWFjaCBtYXAgdGVtcGxhdGUgbmVlZHMgYSBjbGlwUGF0aCB0byBhdm9pZCBvdmVyZmxvdy4gU2VlIEdJU0NPLTI3MDdcclxuICAgICAgICBzdmcuYXBwZW5kKCdkZWZzJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWRlZnMnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdjbGlwUGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIG91dC5zdmdJZF8gKyAnLWNsaXAtcGF0aCcpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGNvbnZlcnRSZWN0YW5nbGVzVG9QYXRocygwLCAwLCBvdXQud2lkdGhfLCBvdXQuaGVpZ2h0XykpXHJcblxyXG4gICAgICAgIGlmIChvdXQuZHJhd0NvYXN0YWxNYXJnaW5fKSB7XHJcbiAgICAgICAgICAgIC8vZGVmaW5lIGZpbHRlciBmb3IgY29hc3RhbCBtYXJnaW5cclxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgnZmlsdGVyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdGFsLWJsdXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAnLTIwMCUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAnLTIwMCUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzQwMCUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsICc0MDAlJylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2ZlR2F1c3NpYW5CbHVyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpbicsICdTb3VyY2VHcmFwaGljJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdGREZXZpYXRpb24nLCBvdXQuY29hc3RhbE1hcmdpblN0ZERldl8pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NyZWF0ZSBkcmF3aW5nIGdyb3VwLCBhcyBmaXJzdCBjaGlsZFxyXG4gICAgICAgIGNvbnN0IGRnID0gc3ZnXHJcbiAgICAgICAgICAgIC5pbnNlcnQoJ2cnLCAnOmZpcnN0LWNoaWxkJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWRyYXdpbmctJyArIG91dC5zdmdJZF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1kcmF3aW5nLWdyb3VwJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoIycgKyBvdXQuc3ZnSWRfICsgJy1jbGlwLXBhdGgnICsgJyknKVxyXG5cclxuICAgICAgICAvL2NyZWF0ZSBtYWluIHpvb20gZ3JvdXBcclxuICAgICAgICBjb25zdCB6ZyA9IGRnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXpvb20tZ3JvdXAnKSAvL291dC5nZW8gY2hhbmdlZCB0byBvdXQuc3ZnSWQgaW4gb3JkZXIgdG8gYmUgdW5pcXVlXHJcblxyXG4gICAgICAgIC8vIGJ1aWxkIGluc2V0c1xyXG4gICAgICAgIHJlbW92ZUluc2V0cyhvdXQpIC8vcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgYnVpbGRJbnNldHMob3V0LCB3aXRoQ2VudGVyUG9pbnRzKSAvL2J1aWxkIG5ld1xyXG5cclxuICAgICAgICAvL2RyYXcgZnJhbWVcclxuICAgICAgICBkZy5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tZnJhbWUtJyArIG91dC5nZW9fKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZnJhbWUnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LndpZHRoXylcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5oZWlnaHRfKVxyXG5cclxuICAgICAgICBpZiAob3V0LnN0YW1wXykge1xyXG4gICAgICAgICAgICBhcHBlbmRTdGFtcChvdXQuc3RhbXBfLCBvdXQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlkIGFuIGVtcHR5IG1hcCB0ZW1wbGF0ZSwgYmFzZWQgb24gdGhlIGdlb21ldHJpZXMgb25seS5cclxuICAgICAqL1xyXG4gICAgb3V0LmJ1aWxkTWFwVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9wcmVwYXJlIGRyYXdpbmcgZ3JvdXBcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBvdXQuc3ZnKCkuc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAvL3JlbW92ZSBhbGwgY2hpbGRyZW5cclxuICAgICAgICB6b29tR3JvdXAuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gc2VwYXJhdGUgbG9naWMgZm9yIGNhcnRvZ3JhbXNcclxuICAgICAgICBpZiAob3V0LmdyaWRDYXJ0b2dyYW1fID09IHRydWUpIHtcclxuICAgICAgICAgICAgYnVpbGRHcmlkQ2FydG9ncmFtQmFzZShvdXQpXHJcbiAgICAgICAgICAgIG91dC5mb290bm90ZV8gPSBmYWxzZSAvL2RvbnQgbmVlZCBjb3B5cmlnaHRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGdlb2dyYXBoaWMgbG9naWNcclxuXHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGlmICghb3V0LnBvc2l0aW9uXy54IHx8ICFvdXQucG9zaXRpb25fLnkpIHtcclxuICAgICAgICAgICAgICAgIGRlZmluZURlZmF1bHRQb3NpdGlvbigpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy56ID0gb3V0LnBvc2l0aW9uXy56IHx8IGdldERlZmF1bHRaKClcclxuXHJcbiAgICAgICAgICAgIC8vIGQzIHByb2plY3Rpb24vcGF0aCBmdW5jdGlvbnNcclxuICAgICAgICAgICAgZGVmaW5lUHJvamVjdGlvbigpXHJcbiAgICAgICAgICAgIGRlZmluZVBhdGhGdW5jdGlvbigpXHJcblxyXG4gICAgICAgICAgICAvLyBkMyB6b29tXHJcbiAgICAgICAgICAgIGlmIChvdXQuem9vbUV4dGVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVNYXBab29tKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG91dC5iYWNrZ3JvdW5kTWFwXykge1xyXG4gICAgICAgICAgICAgICAgZHJhd0JhY2tncm91bmRNYXAob3V0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3ByZXBhcmUgZ3JvdXAgZm9yIHByb3BvcnRpb25hbCBzeW1ib2xzLCB3aXRoIGNlbnRyb2lkc1xyXG4gICAgICAgIGlmICh3aXRoQ2VudGVyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgIGFkZENlbnRyb2lkc1RvTWFwKG91dClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCBnZW9ncmFwaGljYWwgbGFiZWxzIHRvIG1hcFxyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXykge1xyXG4gICAgICAgICAgICBhZGRMYWJlbHNUb01hcChvdXQsIHpvb21Hcm91cClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYW5ub3RhdGlvbnNcclxuICAgICAgICBpZiAob3V0LmFubm90YXRpb25zXykge1xyXG4gICAgICAgICAgICBhcHBlbmRBbm5vdGF0aW9ucyhvdXQpXHJcbiAgICAgICAgICAgIG91dC5hbm5vdGF0aW9uc0FkZGVkID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIGlmIChvdXQudGl0bGUoKSkge1xyXG4gICAgICAgICAgICAvL2RlZmluZSBkZWZhdWx0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGxldCBjc3NDbGFzcyA9IG91dC5pc0luc2V0ID8gJ2VtLWluc2V0LXRpdGxlJyA6ICdlbS10aXRsZSdcclxuICAgICAgICAgICAgaWYgKCFvdXQudGl0bGVQb3NpdGlvbigpKSBvdXQudGl0bGVQb3NpdGlvbihbMTAsIGdldEZvbnRTaXplRnJvbUNsYXNzKGNzc0NsYXNzKSArIChvdXQuaXNJbnNldCA/IDAgOiAxMCldKVxyXG4gICAgICAgICAgICAvL2RyYXcgdGl0bGVcclxuICAgICAgICAgICAgb3V0LnN2ZygpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICd0aXRsZScgKyBvdXQuZ2VvXylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGNzc0NsYXNzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQudGl0bGVQb3NpdGlvbigpWzBdKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQudGl0bGVQb3NpdGlvbigpWzFdKVxyXG4gICAgICAgICAgICAgICAgLmh0bWwob3V0LnRpdGxlKCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3N1YnRpdGxlXHJcbiAgICAgICAgaWYgKG91dC5zdWJ0aXRsZSgpKSB7XHJcbiAgICAgICAgICAgIGxldCBjc3NTdWJ0aXRsZUNsYXNzID0gb3V0LmlzSW5zZXQgPyAnZW0taW5zZXQtc3VidGl0bGUnIDogJ2VtLXN1YnRpdGxlJ1xyXG4gICAgICAgICAgICBsZXQgY3NzVGl0bGVDbGFzcyA9IG91dC5pc0luc2V0ID8gJ2VtLWluc2V0LXRpdGxlJyA6ICdlbS10aXRsZSdcclxuICAgICAgICAgICAgLy9kZWZpbmUgZGVmYXVsdCBwb3NpdGlvblxyXG4gICAgICAgICAgICBpZiAoIW91dC5zdWJ0aXRsZVBvc2l0aW9uKCkpIG91dC5zdWJ0aXRsZVBvc2l0aW9uKFsxMCwgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoY3NzVGl0bGVDbGFzcykgKyBnZXRGb250U2l6ZUZyb21DbGFzcyhjc3NTdWJ0aXRsZUNsYXNzKSArIDE1XSlcclxuICAgICAgICAgICAgLy9kcmF3IHN1YnRpdGxlXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnc3VidGl0bGUnICsgb3V0Lmdlb18pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBjc3NTdWJ0aXRsZUNsYXNzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuc3VidGl0bGVQb3NpdGlvbigpWzBdKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuc3VidGl0bGVQb3NpdGlvbigpWzFdKVxyXG4gICAgICAgICAgICAgICAgLmh0bWwob3V0LnN1YnRpdGxlKCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2JvdHRvbSB0ZXh0XHJcbiAgICAgICAgaWYgKG91dC5mb290bm90ZV8pIHtcclxuICAgICAgICAgICAgYWRkRm9vdG5vdGUoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zb3VyY2UgZGF0YXNldCBVUkxcclxuICAgICAgICBpZiAob3V0LnNob3dTb3VyY2VMaW5rXykge1xyXG4gICAgICAgICAgICBsZXQgc3RhdFxyXG4gICAgICAgICAgICBpZiAod2l0aENlbnRlclBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgc3RhdCA9IG91dC5zdGF0KCdzaXplJylcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXQgPSBvdXQuc3RhdCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0LmV1cm9zdGF0RGF0YXNldENvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2RhdGFzZXQgbGlua1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gc3RhdC5ldXJvc3RhdERhdGFzZXRDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGBodHRwczovL2VjLmV1cm9wYS5ldS9ldXJvc3RhdC9kYXRhYnJvd3Nlci92aWV3LyR7Y29kZX0vZGVmYXVsdC90YWJsZT9sYW5nPWVuYFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5rID0gb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdhJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNvdXJjZS1kYXRhc2V0LWxpbmsnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaHJlZicsIHVybClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RhcmdldCcsICdfYmxhbmsnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNvdXJjZS1kYXRhc2V0LWxpbmstdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LndpZHRoXylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuaGVpZ2h0XylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoJ0VVUk9TVEFUJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcHJldGV4dCBcIlNvdXJjZTpcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5rVyA9IGxpbmsubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc291cmNlLXByZXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC53aWR0aF8gLSBsaW5rVyAtIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmhlaWdodF8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KCdTb3VyY2U6JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNjYWxlYmFyXHJcbiAgICAgICAgaWYgKG91dC5zaG93U2NhbGViYXJfKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQuc2NhbGViYXJQb3NpdGlvbl8ubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuc2NhbGViYXJQb3NpdGlvbl9bMF0gPSAxNVxyXG4gICAgICAgICAgICAgICAgb3V0LnNjYWxlYmFyUG9zaXRpb25fWzFdID0gb3V0LmhlaWdodF8gLSA1MFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZFNjYWxlYmFyVG9NYXAoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyYXdCYWNrZ3JvdW5kTWFwID0gZnVuY3Rpb24gKG91dCkge1xyXG4gICAgICAgIC8vZHJhdyBiYWNrZ3JvdW5kIG1hcFxyXG4gICAgICAgIGNvbnN0IHpvb21Hcm91cCA9IG91dC5zdmcoKS5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIC8vZHJhdyBzZWFcclxuICAgICAgICB6b29tR3JvdXBcclxuICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdzZWEnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2VhJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAtNSAqIG91dC53aWR0aF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgLTUgKiBvdXQuaGVpZ2h0XylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTEgKiBvdXQud2lkdGhfKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTEgKiBvdXQuaGVpZ2h0XylcclxuXHJcbiAgICAgICAgLy9zcGhlcmUgZm9yIHdvcmxkIG1hcFxyXG4gICAgICAgIGlmIChvdXQuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgIHpvb21Hcm91cC5hcHBlbmQoJ3BhdGgnKS5kYXR1bSh7IHR5cGU6ICdTcGhlcmUnIH0pLmF0dHIoJ2lkJywgJ3NwaGVyZScpLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbikuYXR0cignY2xhc3MnLCAnZW0tZ3JhdGljdWxlJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvYXN0YWwgbWFyZ2luXHJcbiAgICAgICAgaWYgKG91dC5kcmF3Q29hc3RhbE1hcmdpbl8pIHtcclxuICAgICAgICAgICAgYWRkQ29hc3RhbE1hcmdpblRvTWFwKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRyYXcgcG9seWdvbnMgYW5kIGJvcmRlcnNcclxuICAgICAgICBpZiAob3V0Lmdlb21ldHJpZXNfKSB7XHJcbiAgICAgICAgICAgIG91dC5HZW9tZXRyaWVzLmFkZFVzZXJHZW9tZXRyaWVzVG9NYXAob3V0Lmdlb21ldHJpZXNfLCB6b29tR3JvdXAsIG91dC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dC5HZW9tZXRyaWVzLmFkZERlZmF1bHRHZW9tZXRyaWVzVG9NYXAoXHJcbiAgICAgICAgICAgICAgICB6b29tR3JvdXAsXHJcbiAgICAgICAgICAgICAgICBvdXQuZHJhd0dyYXRpY3VsZV8sXHJcbiAgICAgICAgICAgICAgICBvdXQuX3BhdGhGdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIG91dC5udXRzTGV2ZWxfLFxyXG4gICAgICAgICAgICAgICAgb3V0Lm51dHNZZWFyXyxcclxuICAgICAgICAgICAgICAgIG91dC5nZW9fLFxyXG4gICAgICAgICAgICAgICAgb3V0LnByb2pfLFxyXG4gICAgICAgICAgICAgICAgb3V0LnNjYWxlX1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZURlZmF1bHRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0UG9zaXRpb24gPSBfZGVmYXVsdFBvc2l0aW9uW291dC5nZW9fICsgJ18nICsgb3V0LnByb2pfXVxyXG4gICAgICAgIGlmIChkZWZhdWx0UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy54ID0gb3V0LnBvc2l0aW9uXy54IHx8IGRlZmF1bHRQb3NpdGlvbi5nZW9DZW50ZXJbMF1cclxuICAgICAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gb3V0LnBvc2l0aW9uXy55IHx8IGRlZmF1bHRQb3NpdGlvbi5nZW9DZW50ZXJbMV1cclxuICAgICAgICB9IGVsc2UgaWYgKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhPy5iYm94KSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gY2VudGVyIG9mIGdlb0RhdGEgYmJveFxyXG4gICAgICAgICAgICBvdXQucG9zaXRpb25fLnggPSBvdXQucG9zaXRpb25fLnggfHwgMC41ICogKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbMF0gKyBvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzJdKVxyXG4gICAgICAgICAgICBvdXQucG9zaXRpb25fLnkgPSBvdXQucG9zaXRpb25fLnkgfHwgMC41ICogKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbMV0gKyBvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzNdKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vVE9ETzogYXV0by1kZWZpbmUgdXNlcj1kZWZpbmVkIGdlb21ldHJpZXMgZ2VvQ2VudGVyXHJcbiAgICAgICAgICAgIC8vIG91dC5wb3NpdGlvbl8ueCA9IEdlb21ldHJpZXMudXNlckdlb21ldHJpZXNcclxuICAgICAgICAgICAgLy8gb3V0LnBvc2l0aW9uXy55ID0gR2VvbWV0cmllcy51c2VyR2VvbWV0cmllc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb3B0aW9uYWw6IHNldCBmcm9tIFVSTFxyXG4gICAgICAgIHNldFZpZXdGcm9tVVJMKClcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZXREZWZhdWx0WiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0UG9zaXRpb24gPSBfZGVmYXVsdFBvc2l0aW9uW291dC5nZW9fICsgJ18nICsgb3V0LnByb2pfXVxyXG4gICAgICAgIGlmIChkZWZhdWx0UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIChkZWZhdWx0UG9zaXRpb24ucGl4ZWxTaXplICogODAwKSAvIG91dC53aWR0aF9cclxuICAgICAgICB9IGVsc2UgaWYgKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhPy5iYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIChvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzJdIC0gb3V0Lkdlb21ldHJpZXMuZGVmYXVsdEdlb0RhdGEuYmJveFswXSkgLyBvdXQud2lkdGhfLFxyXG4gICAgICAgICAgICAgICAgKG91dC5HZW9tZXRyaWVzLmRlZmF1bHRHZW9EYXRhLmJib3hbM10gLSBvdXQuR2VvbWV0cmllcy5kZWZhdWx0R2VvRGF0YS5iYm94WzFdKSAvIG91dC5oZWlnaHRfXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMTAwXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZVByb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRGVmaW5lIHByb2plY3Rpb24gYmFzZWQgb24gdGhlIGdlb2dyYXBoaWNhbCBjb250ZXh0XHJcblxyXG4gICAgICAgIGlmIChvdXQuZ2VvXyA9PT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAvLyBVc2UgUm9iaW5zb24gcHJvamVjdGlvbiBmb3IgdGhlIHdvcmxkIHdpdGggb3B0aW9uYWwgY3VzdG9tIHByb2plY3Rpb24gZnVuY3Rpb25cclxuICAgICAgICAgICAgb3V0Ll9wcm9qZWN0aW9uID1cclxuICAgICAgICAgICAgICAgIG91dC5wcm9qZWN0aW9uRnVuY3Rpb25fIHx8XHJcbiAgICAgICAgICAgICAgICBnZW9Sb2JpbnNvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbb3V0LndpZHRoXyAvIDIsIG91dC5oZWlnaHRfIC8gMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKChvdXQud2lkdGhfIC0gMjApIC8gKDIgKiBNYXRoLlBJKSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3Igbm9uLVdPUkxEIGdlbywgdXNlIGN1c3RvbSBvciBkZWZhdWx0IGlkZW50aXR5IHByb2plY3Rpb24gd2l0aCBjYWxjdWxhdGVkIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICBvdXQuX3Byb2plY3Rpb24gPVxyXG4gICAgICAgICAgICAgICAgb3V0LnByb2plY3Rpb25GdW5jdGlvbl8gfHwgZ2VvSWRlbnRpdHkoKS5yZWZsZWN0WSh0cnVlKS5maXRTaXplKFtvdXQud2lkdGhfLCBvdXQuaGVpZ2h0X10sIGdldEJCT1hBc0dlb0pTT04oZ2V0Q3VycmVudEJib3goKSkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgY3VycmVudCB2aWV3IGFzIGJib3hcclxuICAgIGNvbnN0IGdldEN1cnJlbnRCYm94ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IDAuNSAqIG91dC5wb3NpdGlvbl8ueiAqIG91dC53aWR0aF9cclxuICAgICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gMC41ICogb3V0LnBvc2l0aW9uXy56ICogb3V0LmhlaWdodF9cclxuICAgICAgICBjb25zdCBiYm94ID0gW291dC5wb3NpdGlvbl8ueCAtIGhhbGZXaWR0aCwgb3V0LnBvc2l0aW9uXy55IC0gaGFsZkhlaWdodCwgb3V0LnBvc2l0aW9uXy54ICsgaGFsZldpZHRoLCBvdXQucG9zaXRpb25fLnkgKyBoYWxmSGVpZ2h0XVxyXG4gICAgICAgIHJldHVybiBiYm94XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGVmaW5lUGF0aEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC5fcGF0aEZ1bmN0aW9uID0gZ2VvUGF0aCgpLnByb2plY3Rpb24ob3V0Ll9wcm9qZWN0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRlZmluZU1hcFpvb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHN2ZyA9IHNlbGVjdCgnIycgKyBvdXQuc3ZnSWQoKSlcclxuICAgICAgICBsZXQgcHJldmlvdXNUID0gem9vbUlkZW50aXR5XHJcbiAgICAgICAgY29uc3QgeG9vID0gem9vbSgpXHJcbiAgICAgICAgICAgIC5zY2FsZUV4dGVudChvdXQuem9vbUV4dGVudCgpKVxyXG4gICAgICAgICAgICAub24oJ3pvb20nLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUudHJhbnNmb3JtXHJcbiAgICAgICAgICAgICAgICBpZiAodC5rICE9PSBwcmV2aW91c1Quaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb21IYW5kbGVyKGUsIHByZXZpb3VzVClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFuSGFuZGxlcihlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGRlZmF1bHQgdHJhbnNmb3JtIHRvIG1hcFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAgICAgICAgIHpvb21Hcm91cC5hdHRyKCd0cmFuc2Zvcm0nLCB0KVxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNUID0gdFxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBzdmcuY2FsbCh4b28pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gWm9vbSBoYW5kbGVyIGZ1bmN0aW9uXHJcbiAgICBjb25zdCB6b29tSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCwgcHJldmlvdXNUKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZXZlbnQudHJhbnNmb3JtXHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJvamVjdGVkIGNlbnRlclxyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSAob3V0LndpZHRoXyAvIDIgLSB0cmFuc2Zvcm0ueCkgLyB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSAob3V0LmhlaWdodF8gLyAyIC0gdHJhbnNmb3JtLnkpIC8gdHJhbnNmb3JtLmtcclxuXHJcbiAgICAgICAgLy8gVXNlIHRoZSBwcm9qZWN0aW9uIHRvIGdldCB0aGUgcHJvamVjdGVkIGNlbnRlciBpbiBFUFNHOjMwMzVcclxuICAgICAgICBjb25zdCBbcHJvamVjdGVkWCwgcHJvamVjdGVkWV0gPSBvdXQuX3Byb2plY3Rpb24uaW52ZXJ0KFtjZW50ZXJYLCBjZW50ZXJZXSlcclxuXHJcbiAgICAgICAgLy8gc2V0IG5ldyBwb3NpdGlvblxyXG4gICAgICAgIG91dC5wb3NpdGlvbl8ueCA9IHByb2plY3RlZFhcclxuICAgICAgICBvdXQucG9zaXRpb25fLnkgPSBwcm9qZWN0ZWRZXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy56ID0gZ2V0TWV0cmVzUGVyUGl4ZWwodHJhbnNmb3JtLmsgLyBwcmV2aW91c1QuaylcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHN0cm9rZSBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICAgIHNjYWxlU3Ryb2tlV2lkdGhzKHRyYW5zZm9ybSlcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHN0cm9rZSBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXz8udmFsdWVzKSBzY2FsZUxhYmVsVGV4dHModHJhbnNmb3JtKVxyXG5cclxuICAgICAgICAvLyBhZGp1c3Qgc3Ryb2tlIGR5bmFtaWNhbGx5IGFjY29yZGluZyB0byB6b29tXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfPy5iYWNrZ3JvdW5kcykgc2NhbGVMYWJlbEJhY2tncm91bmRzKHRyYW5zZm9ybSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhZGp1c3RzIHRleHQgZWxlbWVudHMgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAqIEBwYXJhbSB7Kn0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNjYWxlTGFiZWxCYWNrZ3JvdW5kcyA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBvdXQuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gem9vbUdyb3VwLnNlbGVjdEFsbCgnLmVtLWxhYmVsLWJhY2tncm91bmQnKVxyXG4gICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXVxyXG5cclxuICAgICAgICBlbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQsIHgsIGFuZCB5IGZyb20gZGF0YSBhdHRyaWJ1dGVzIG9yIGN1cnJlbnQgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtd2lkdGgnKSkgfHwgcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ3dpZHRoJykpXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtaGVpZ2h0JykpIHx8IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCdoZWlnaHQnKSlcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxYID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEteCcpKSB8fCBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cigneCcpKVxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFkgPSBwYXJzZUZsb2F0KGVsZW1lbnQuYXR0cignZGF0YS15JykpIHx8IHBhcnNlRmxvYXQoZWxlbWVudC5hdHRyKCd5JykpXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZWxlbWVudHMgdGhhdCBoYXZlIHZhbGlkIHdpZHRoLCBoZWlnaHQsIHgsIGFuZCB5XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFdpZHRoID4gMCAmJiBvcmlnaW5hbEhlaWdodCA+IDAgJiYgIWlzTmFOKG9yaWdpbmFsWCkgJiYgIWlzTmFOKG9yaWdpbmFsWSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0LCB4LCBhbmQgeSBmb3IgdGhlIGZpcnN0IHRpbWUgaWYgbm90IGFscmVhZHkgc3RvcmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuYXR0cignZGF0YS13aWR0aCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXdpZHRoJywgb3JpZ2luYWxXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2RhdGEtaGVpZ2h0Jywgb3JpZ2luYWxIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXgnLCBvcmlnaW5hbFgpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXknLCBvcmlnaW5hbFkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgd2lkdGgsIGhlaWdodCwgeCwgYW5kIHkgYmFzZWQgb24gem9vbSBmYWN0b3IgKGludmVyc2Ugc2NhbGluZylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gb3JpZ2luYWxXaWR0aCAqICgxIC8gem9vbUZhY3RvcikgLy8gSW52ZXJzZSBzY2FsaW5nXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSBvcmlnaW5hbEhlaWdodCAqICgxIC8gem9vbUZhY3RvcikgLy8gSW52ZXJzZSBzY2FsaW5nXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRYID0gb3JpZ2luYWxYICogKDEgLyB6b29tRmFjdG9yKSAvLyBBZGp1c3QgeCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0WSA9IG9yaWdpbmFsWSAqICgxIC8gem9vbUZhY3RvcikgLy8gQWRqdXN0IHkgcG9zaXRpb25cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHN0eWxlIGNoYW5nZSB0byBhIGJhdGNoIGFycmF5XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goeyBlbGVtZW50LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRYLCB0YXJnZXRZIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBBcHBseSBhbGwgc3R5bGUgY2hhbmdlcyBhdCBvbmNlXHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKCh7IGVsZW1lbnQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRhcmdldFgsIHRhcmdldFkgfSkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LmF0dHIoJ3dpZHRoJywgdGFyZ2V0V2lkdGgpLmF0dHIoJ2hlaWdodCcsIHRhcmdldEhlaWdodCkuYXR0cigneCcsIHRhcmdldFgpLmF0dHIoJ3knLCB0YXJnZXRZKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhZGp1c3RzIHRleHQgZWxlbWVudHMgZHluYW1pY2FsbHkgYWNjb3JkaW5nIHRvIHpvb21cclxuICAgICAqIEBwYXJhbSB7Kn0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNjYWxlTGFiZWxUZXh0cyA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBjb25zdCB6b29tR3JvdXAgPSBvdXQuc3ZnXy5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBvdXQuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHpvb21Hcm91cC5zZWxlY3QoJyNlbS1sYWJlbHMnKVxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gbGFiZWxzLnNlbGVjdEFsbCgnKicpIC8vIFNlbGVjdCBhbGwgbGFiZWxzXHJcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IHRyYW5zZm9ybS5rXHJcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdXHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGZvbnQtc2l6ZSBmcm9tIGlubGluZSBvciBjb21wdXRlZCBzdHlsZVxyXG4gICAgICAgICAgICBjb25zdCBpbmxpbmVGb250U2l6ZSA9IGVsZW1lbnQuYXR0cignZm9udC1zaXplJylcclxuICAgICAgICAgICAgY29uc3QgY3NzRm9udFNpemUgPSBjb21wdXRlZFN0eWxlLmZvbnRTaXplXHJcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gaW5saW5lRm9udFNpemUgfHwgY3NzRm9udFNpemVcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBlbGVtZW50cyB0aGF0IGhhdmUgYSBmb250IHNpemUgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgJiYgcGFyc2VGbG9hdChmb250U2l6ZSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZvbnRTaXplID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtZnMnKSkgfHwgcGFyc2VGbG9hdChpbmxpbmVGb250U2l6ZSkgfHwgcGFyc2VGbG9hdChjc3NGb250U2l6ZSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgZm9udCBzaXplIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmF0dHIoJ2RhdGEtZnMnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS1mcycsIG9yaWdpbmFsRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgZm9udCBzaXplIGJhc2VkIG9uIHpvb20gZmFjdG9yXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRGb250U2l6ZSA9IG9yaWdpbmFsRm9udFNpemUgLyB6b29tRmFjdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzdHlsZSBjaGFuZ2UgdG8gYSBiYXRjaCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKHsgZWxlbWVudDogdGhpcywgdGFyZ2V0Rm9udFNpemUgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGFsbCBzdHlsZSBjaGFuZ2VzIGF0IG9uY2VcclxuICAgICAgICB1cGRhdGVzLmZvckVhY2goKHsgZWxlbWVudCwgdGFyZ2V0Rm9udFNpemUgfSkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdmb250LXNpemUnLCBgJHt0YXJnZXRGb250U2l6ZX1weGAsICdpbXBvcnRhbnQnKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gYWRqdXN0cyBhbGwgc3Ryb2tlLXdpZHRocyBkeW5hbWljYWxseSBhY2NvcmRpbmcgdG8gem9vbVxyXG4gICAgICogQHBhcmFtIHsqfSB0cmFuc2Zvcm1cclxuICAgICAqL1xyXG4gICAgY29uc3Qgc2NhbGVTdHJva2VXaWR0aHMgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gb3V0LnN2Z18uc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHpvb21Hcm91cC5zZWxlY3RBbGwoJyonKSAvLyBTZWxlY3QgYWxsIGVsZW1lbnRzIGluIHRoZSB6b29tIGdyb3VwXHJcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IHRyYW5zZm9ybS5rXHJcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IFtdXHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHN0cm9rZS13aWR0aCBmcm9tIGlubGluZSBvciBjb21wdXRlZCBzdHlsZVxyXG4gICAgICAgICAgICBjb25zdCBpbmxpbmVTdHJva2VXaWR0aCA9IGVsZW1lbnQuYXR0cignc3Ryb2tlLXdpZHRoJylcclxuICAgICAgICAgICAgY29uc3QgY3NzU3Ryb2tlV2lkdGggPSBjb21wdXRlZFN0eWxlLnN0cm9rZVdpZHRoXHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gaW5saW5lU3Ryb2tlV2lkdGggfHwgY3NzU3Ryb2tlV2lkdGhcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBlbGVtZW50cyB0aGF0IGhhdmUgYSBzdHJva2Ugd2lkdGggZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoc3Ryb2tlV2lkdGggJiYgcGFyc2VGbG9hdChzdHJva2VXaWR0aCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0cm9rZVdpZHRoID0gcGFyc2VGbG9hdChlbGVtZW50LmF0dHIoJ2RhdGEtc3cnKSkgfHwgcGFyc2VGbG9hdChpbmxpbmVTdHJva2VXaWR0aCkgfHwgcGFyc2VGbG9hdChjc3NTdHJva2VXaWR0aClcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgc3Ryb2tlIHdpZHRoIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmF0dHIoJ2RhdGEtc3cnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGF0YS1zdycsIG9yaWdpbmFsU3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgc3Ryb2tlIHdpZHRoXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRTdHJva2VXaWR0aCA9IG9yaWdpbmFsU3Ryb2tlV2lkdGggLyB6b29tRmFjdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzdHlsZSBjaGFuZ2UgdG8gYSBiYXRjaCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKHsgZWxlbWVudDogdGhpcywgdGFyZ2V0U3Ryb2tlV2lkdGggfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGFsbCBzdHlsZSBjaGFuZ2VzIGF0IG9uY2VcclxuICAgICAgICB1cGRhdGVzLmZvckVhY2goKHsgZWxlbWVudCwgdGFyZ2V0U3Ryb2tlV2lkdGggfSkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdzdHJva2Utd2lkdGgnLCBgJHt0YXJnZXRTdHJva2VXaWR0aH1weGAsICdpbXBvcnRhbnQnKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gZ2V0IHRoZSBjdXJyZW50IHZpZXcncyBtZXRyZXMgcGVyIHBpeGVsLCBiYXNlZCBvbiBhIHpvb21GYWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tRmFjdG9yIHRoaXMgem9vbSAvIHByZXZpb3VzIHpvb21cclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0TWV0cmVzUGVyUGl4ZWwgPSBmdW5jdGlvbiAoem9vbUZhY3Rvcikge1xyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGJvdW5kaW5nIGJveCB3aWR0aCBpbiBtZXRlcnNcclxuICAgICAgICBjb25zdCBiYm94ID0gZ2V0Q3VycmVudEJib3goKVxyXG4gICAgICAgIGNvbnN0IGJib3hXaWR0aCA9IGJib3hbMl0gLSBiYm94WzBdIC8vIEJCT1ggd2lkdGggaW4gbWV0ZXJzXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtZXRlcnMgcGVyIHBpeGVsXHJcbiAgICAgICAgY29uc3QgbWV0ZXJzUGVyUGl4ZWwgPSBiYm94V2lkdGggLyAob3V0LndpZHRoXyAqIHpvb21GYWN0b3IpXHJcblxyXG4gICAgICAgIHJldHVybiBtZXRlcnNQZXJQaXhlbFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhbiBoYW5kbGVyIGZ1bmN0aW9uXHJcbiAgICBjb25zdCBwYW5IYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50LCBwcmV2aW91c1QpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm1cclxuXHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJvamVjdGVkIGNlbnRlclxyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSAob3V0LndpZHRoXyAvIDIgLSB0cmFuc2Zvcm0ueCkgLyB0cmFuc2Zvcm0ua1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSAob3V0LmhlaWdodF8gLyAyIC0gdHJhbnNmb3JtLnkpIC8gdHJhbnNmb3JtLmtcclxuICAgICAgICBsZXQgW2dlb1gsIGdlb1ldID0gb3V0Ll9wcm9qZWN0aW9uLmludmVydChbY2VudGVyWCwgY2VudGVyWV0pXHJcblxyXG4gICAgICAgIC8vIENsYW1wIGdlb1ggYW5kIGdlb1kgdG8gbWF4IGJvdW5kcyBhbmQgYWRqdXN0IHRoZSBldmVudCB0cmFuc2Zvcm1cclxuICAgICAgICBpZiAob3V0Lm1heEJvdW5kc18ueE1pbiAhPT0gdW5kZWZpbmVkICYmIGdlb1ggPCBvdXQubWF4Qm91bmRzXy54TWluKSB7XHJcbiAgICAgICAgICAgIGdlb1ggPSBvdXQubWF4Qm91bmRzXy54TWluXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS54ID0gb3V0LndpZHRoXyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVswXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXQubWF4Qm91bmRzXy55TWluICE9PSB1bmRlZmluZWQgJiYgZ2VvWSA8IG91dC5tYXhCb3VuZHNfLnlNaW4pIHtcclxuICAgICAgICAgICAgZ2VvWSA9IG91dC5tYXhCb3VuZHNfLnlNaW5cclxuICAgICAgICAgICAgdHJhbnNmb3JtLnkgPSBvdXQuaGVpZ2h0XyAvIDIgLSBvdXQuX3Byb2plY3Rpb24oW2dlb1gsIGdlb1ldKVsxXSAqIHRyYW5zZm9ybS5rXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXQubWF4Qm91bmRzXy54TWF4ICE9PSB1bmRlZmluZWQgJiYgZ2VvWCA+IG91dC5tYXhCb3VuZHNfLnhNYXgpIHtcclxuICAgICAgICAgICAgZ2VvWCA9IG91dC5tYXhCb3VuZHNfLnhNYXhcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnggPSBvdXQud2lkdGhfIC8gMiAtIG91dC5fcHJvamVjdGlvbihbZ2VvWCwgZ2VvWV0pWzBdICogdHJhbnNmb3JtLmtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG91dC5tYXhCb3VuZHNfLnlNYXggIT09IHVuZGVmaW5lZCAmJiBnZW9ZID4gb3V0Lm1heEJvdW5kc18ueU1heCkge1xyXG4gICAgICAgICAgICBnZW9ZID0gb3V0Lm1heEJvdW5kc18ueU1heFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0ueSA9IG91dC5oZWlnaHRfIC8gMiAtIG91dC5fcHJvamVjdGlvbihbZ2VvWCwgZ2VvWV0pWzFdICogdHJhbnNmb3JtLmtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldCBuZXcgcG9zaXRpb25cclxuICAgICAgICBvdXQucG9zaXRpb25fLnggPSBnZW9YXHJcbiAgICAgICAgb3V0LnBvc2l0aW9uXy55ID0gZ2VvWVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgeCx5LHogZWxlbWVudHMgZnJvbSBVUkwgYW5kIGFzc2lnbiB0aGVtIHRvIHRoZSB2aWV3LiAqL1xyXG4gICAgY29uc3Qgc2V0Vmlld0Zyb21VUkwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IGdldFBhcmFtZXRlckJ5TmFtZSgneCcpLFxyXG4gICAgICAgICAgICB5ID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCd5JyksXHJcbiAgICAgICAgICAgIHogPSBnZXRQYXJhbWV0ZXJCeU5hbWUoJ3onKVxyXG4gICAgICAgIGlmICh4ICE9IG51bGwgJiYgeCAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt4KSkgb3V0LnBvc2l0aW9uXy54ID0gK3hcclxuICAgICAgICBpZiAoeSAhPSBudWxsICYmIHkgIT0gdW5kZWZpbmVkICYmICFpc05hTigreSkpIG91dC5wb3NpdGlvbl8ueSA9ICt5XHJcbiAgICAgICAgaWYgKHogIT0gbnVsbCAmJiB6ICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4oK3opKSBvdXQucG9zaXRpb25fLnogPSArelxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZEZvb3Rub3RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWZvb3Rub3RlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZvb3Rub3RlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG91dC5oZWlnaHRfKVxyXG4gICAgICAgICAgICAuaHRtbChvdXQuZm9vdG5vdGVfKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG91dC5fdG9vbHRpcC5td19fXyA9IG91dC5fdG9vbHRpcC5zdHlsZSgnbWF4LXdpZHRoJylcclxuICAgICAgICAgICAgICAgIG91dC5fdG9vbHRpcC5zdHlsZSgnbWF4LXdpZHRoJywgJzQwMHB4JylcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuZm9vdG5vdGVUb29sdGlwVGV4dF8pIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LmZvb3Rub3RlVG9vbHRpcFRleHRfKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5mb290bm90ZVRvb2x0aXBUZXh0Xykgb3V0Ll90b29sdGlwLm1vdXNlb3V0KGUpXHJcbiAgICAgICAgICAgICAgICBvdXQuX3Rvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcsIG91dC5fdG9vbHRpcC5td19fXylcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRDb2FzdGFsTWFyZ2luVG9NYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgemcgPSBvdXQuc3ZnKCkuc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICAvL2RyYXcgY29hc3RhbCBtYXJnaW5cclxuICAgICAgICBjb25zdCBjZyA9IHpnLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLWNvYXN0LW1hcmdpbicpLmF0dHIoJ2NsYXNzJywgJ2VtLWNvYXN0LW1hcmdpbicpXHJcblxyXG4gICAgICAgIC8vY291bnRyaWVzIGJuXHJcbiAgICAgICAgaWYgKG91dC5HZW9tZXRyaWVzLmdlb0pTT05zLmNudGJuKSB7XHJcbiAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLWNudCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY29hc3QtbWFyZ2luLWNudCcpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKG91dC5HZW9tZXRyaWVzLmdlb0pTT05zLmNudGJuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuY28gPT09ICdUJ1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBvdXQuX3BhdGhGdW5jdGlvbilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbnV0cyBiblxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5udXRzYm4pIHtcclxuICAgICAgICAgICAgY2cuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1jb2FzdC1tYXJnaW4tbnV0cycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY29hc3QtbWFyZ2luLW51dHMnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy5udXRzYm4pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm4ucHJvcGVydGllcy5jbyA9PT0gJ1QnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIG91dC5fcGF0aEZ1bmN0aW9uKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy93b3JsZCBiblxyXG4gICAgICAgIGlmIChvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy53b3JsZGJuKSB7XHJcbiAgICAgICAgICAgIGNnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tY29hc3QtbWFyZ2luLXdvcmxkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jb2FzdC1tYXJnaW4td29ybGQnKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShvdXQuR2VvbWV0cmllcy5nZW9KU09Ocy53b3JsZGJuKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJuLnByb3BlcnRpZXMuQ09BU19GTEFHID09PSAnVCdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgb3V0Ll9wYXRoRnVuY3Rpb24pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZENlbnRyb2lkc1RvTWFwID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIGxldCBjZW50cm9pZEZlYXR1cmVzXHJcblxyXG4gICAgICAgIGlmICghbWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YSkge1xyXG4gICAgICAgICAgICAvLyBpZiBjZW50cm9pZHMgZGF0YSBpcyBhYnNlbnQgKGUuZy4gZm9yIHdvcmxkIG1hcHMpIHRoZW4gY2FsY3VsYXRlIG1hbnVhbGx5XHJcbiAgICAgICAgICAgIGlmIChtYXAuZ2VvXyA9PSAnV09STEQnKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50cm9pZEZlYXR1cmVzID0gW11cclxuICAgICAgICAgICAgICAgIG1hcC5HZW9tZXRyaWVzLmdlb0pTT05zLndvcmxkcmcuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdGZWF0dXJlID0geyAuLi5mZWF0dXJlIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gZm9yIEZyYW5jZSAoYmVjYXVzZSBndXlhbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUucHJvcGVydGllcy5pZCA9PSAnRlInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZlYXR1cmUuZ2VvbWV0cnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogWzIuMiwgNDYuMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmVhdHVyZS5nZW9tZXRyeSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBnZW9DZW50cm9pZChmZWF0dXJlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2VudHJvaWRGZWF0dXJlcy5wdXNoKG5ld0ZlYXR1cmUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGNlbnRyb2lkRmVhdHVyZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YVswXS5mZWF0dXJlcyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5tYXAuR2VvbWV0cmllcy5jZW50cm9pZHNEYXRhWzFdLmZlYXR1cmVzLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkc0RhdGFbMl0uZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFwLkdlb21ldHJpZXMuY2VudHJvaWRzRGF0YVszXS5mZWF0dXJlcyxcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNlbnRyb2lkRmVhdHVyZXMgPSBtYXAuR2VvbWV0cmllcy5jZW50cm9pZHNEYXRhLmZlYXR1cmVzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXAucHJvY2Vzc0NlbnRyb2lkc18pIGNlbnRyb2lkRmVhdHVyZXMgPSBtYXAucHJvY2Vzc0NlbnRyb2lkc18oY2VudHJvaWRGZWF0dXJlcylcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHNjcmVlbiBjb29yZGluYXRlcyBhbmQgc2F2ZSBjZW50cm9pZHMgdG8gbWFwXHJcbiAgICAgICAgbWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcyA9IGNlbnRyb2lkRmVhdHVyZXMubWFwKChkKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSBtYXAuX3Byb2plY3Rpb24oZC5nZW9tZXRyeS5jb29yZGluYXRlcylcclxuICAgICAgICAgICAgZC5wcm9wZXJ0aWVzLmNlbnRyb2lkID0gY29vcmRzXHJcbiAgICAgICAgICAgIHJldHVybiBkXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gZW0tcHJvcC1zeW1ib2xzIGlzIHRoZSBnIGVsZW1lbnQgY29udGFpbmluZyBhbGwgcHJvcG9ydGlvbmFsIHN5bWJvbHMgZm9yIHRoZSBtYXBcclxuICAgICAgICBjb25zdCB6ZyA9IG1hcC5zdmcoKS5zZWxlY3QoJyNlbS16b29tLWdyb3VwLScgKyBtYXAuc3ZnSWRfKVxyXG4gICAgICAgIGNvbnN0IGdjcCA9IHpnLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2VtLXByb3Atc3ltYm9scycpXHJcblxyXG4gICAgICAgIC8vIGFkZCBjZW50cm9pZCBlbGVtZW50c1xyXG4gICAgICAgIC8vIHRoZW4gc3ltYm9scyBhcmUgZHJhd24vYXBwZW5kZWQgdG8gdGhlc2UgY29udGFpbmVycyBpbiB0aGUgbWFwLXR5cGUganMgZmlsZVxyXG4gICAgICAgIGNvbnN0IHN5bWJvbENvbnRhaW5lcnMgPSBnY3BcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgIC5kYXRhKG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBkLnByb3BlcnRpZXMuY2VudHJvaWRbMF0udG9GaXhlZCgzKSArICcsJyArIGQucHJvcGVydGllcy5jZW50cm9pZFsxXS50b0ZpeGVkKDMpICsgJyknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1jZW50cm9pZCcpIC8vIE9VUiBTWU1CT0wgQ09OVEFJTkVSXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAncHMnICsgZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGFkZFNjYWxlYmFyVG9NYXBcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhcHBlbmRzIGFuIFNWRyBzY2FsZWJhciB0byB0aGUgbWFwLiBVc2VzIHBpeGVsU2l6ZSB0byBjYWxjdWxhdGUgdW5pdHMgaW4ga21cclxuICAgICAqL1xyXG4gICAgY29uc3QgYWRkU2NhbGViYXJUb01hcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBKdWxpZW4ncyBuaWNlIHNjYWxlYmFyc1xyXG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSA1XHJcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoUGl4ID0gb3V0LnNjYWxlYmFyTWF4V2lkdGhfXHJcbiAgICAgICAgY29uc3QgdGV4dE9mZnNldFggPSBvdXQuc2NhbGViYXJUZXh0T2Zmc2V0X1swXVxyXG4gICAgICAgIGNvbnN0IHRleHRPZmZzZXRZID0gb3V0LnNjYWxlYmFyVGV4dE9mZnNldF9bMV1cclxuICAgICAgICBjb25zdCBwaXhlbFNpemVNID0gb3V0LnBvc2l0aW9uXy56XHJcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoTSA9IG1heExlbmd0aFBpeCAqIHBpeGVsU2l6ZU1cclxuICAgICAgICBjb25zdCBuaWNlTGVuZ3RoTSA9IG5pY2VTY2FsZUJhckxlbmd0aChtYXhMZW5ndGhNKVxyXG4gICAgICAgIGNvbnN0IG5pY2VMZW5ndGhQaXhlbCA9IG5pY2VMZW5ndGhNWzBdIC8gcGl4ZWxTaXplTVxyXG4gICAgICAgIGNvbnN0IHNjYWxlQmFyU3RhcnREaWdpdCA9IG5pY2VMZW5ndGhNWzFdXHJcbiAgICAgICAgY29uc3Qgc3ViZGl2aXNpb25OYnMgPSB7XHJcbiAgICAgICAgICAgIDE6IDQsXHJcbiAgICAgICAgICAgIDI6IDIsXHJcbiAgICAgICAgICAgIDU6IDUsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzY2FsZWJhckdyb3VwID0gb3V0XHJcbiAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtvdXQuc2NhbGViYXJQb3NpdGlvbl9bMF19LCR7b3V0LnNjYWxlYmFyUG9zaXRpb25fWzFdfSlgKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBtYXhMZW5ndGhQaXggKyAyMClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zY2FsZWJhckhlaWdodF8pXHJcblxyXG4gICAgICAgIC8vIHRvcCBsaW5lIGZ1bGwgd2lkdGhcclxuICAgICAgICAvLyBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgLy8gICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd5MScsIDEpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd4MicsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd5MicsIDEpXHJcblxyXG4gICAgICAgIC8vYm90dG9tIGxpbmUgZnVsbCB3aWR0aFxyXG4gICAgICAgIC8vIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAvLyAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lJylcclxuICAgICAgICAvLyAgICAgLmF0dHIoJ3gxJywgbWFyZ2luTGVmdClcclxuICAgICAgICAvLyAgICAgLmF0dHIoJ3kxJywgb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8pXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd4MicsIG5pY2VMZW5ndGhQaXhlbCArIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgLy8gICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclNlZ21lbnRIZWlnaHRfKVxyXG5cclxuICAgICAgICAvL2ZpcnN0IHRpY2tcclxuICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zY2FsZWJhclRpY2tIZWlnaHRfKVxyXG5cclxuICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbkxlZnQgKyB0ZXh0T2Zmc2V0WClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuc2NhbGViYXJUaWNrSGVpZ2h0XyArIHRleHRPZmZzZXRZKVxyXG4gICAgICAgICAgICAudGV4dCgnMCcpXHJcblxyXG4gICAgICAgIC8vbWlkZGxlIHRpY2tzXHJcbiAgICAgICAgY29uc3Qgc3ViZGl2aXNpb25OYiA9IHN1YmRpdmlzaW9uTmJzW3NjYWxlQmFyU3RhcnREaWdpdF1cclxuICAgICAgICBjb25zdCBkaXZpc2lvbldpZHRoID0gbmljZUxlbmd0aFBpeGVsIC8gc3ViZGl2aXNpb25OYlxyXG4gICAgICAgIGNvbnN0IGRpdmlzaW9uTWluV2lkdGggPSAxNVxyXG4gICAgICAgIGNvbnN0IG1pZGxpbmVZID0gb3V0LnNjYWxlYmFyU2VnbWVudEhlaWdodF8gLyAyICsgMVxyXG4gICAgICAgIGlmIChkaXZpc2lvbldpZHRoID49IGRpdmlzaW9uTWluV2lkdGgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdWJkaXZpc2lvbk5iOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgbWFyZ2luTGVmdCArIG91dC5zY2FsZWJhclN0cm9rZVdpZHRoXyAvIDIgKyBpICogZGl2aXNpb25XaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8pXHJcbiAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbkxlZnQgKyB0ZXh0T2Zmc2V0WCArIGkgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8gKyB0ZXh0T2Zmc2V0WSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChnZXRTY2FsZWJhckxhYmVsKChuaWNlTGVuZ3RoTVswXSAvIHN1YmRpdmlzaW9uTmIpICogaSkpXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lIGVtLXNjYWxlYmFyLW1pZGxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG1pZGxpbmVZKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeDEgPSBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIChpIC0gMSkgKiBkaXZpc2lvbldpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgxID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZWJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lIGVtLXNjYWxlYmFyLW1pZGxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBtaWRsaW5lWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLyAyICsgaSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBtaWRsaW5lWSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgZmluYWwgbWlkbGluZSBzZWdtZW50IChsYXN0IHNlZ21lbnQpXHJcbiAgICAgICAgICAgIGlmIChkaXZpc2lvbldpZHRoID49IGRpdmlzaW9uTWluV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZSBlbS1zY2FsZWJhci1taWRsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBtYXJnaW5MZWZ0ICsgKHN1YmRpdmlzaW9uTmIgLSAxKSAqIGRpdmlzaW9uV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgbWFyZ2luTGVmdCArIHN1YmRpdmlzaW9uTmIgKiBkaXZpc2lvbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG1pZGxpbmVZKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIGZ1bGwtbGVuZ3RoIGhvcml6b250YWwgbWlkLWxpbmVcclxuICAgICAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2NhbGViYXItbGluZSBlbS1zY2FsZWJhci1taWRsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG1hcmdpbkxlZnQgKyBvdXQuc2NhbGViYXJTdHJva2VXaWR0aF8gLSAxKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgbWlkbGluZVkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBtYXJnaW5MZWZ0ICsgb3V0LnNjYWxlYmFyU3Ryb2tlV2lkdGhfIC8gMiArIGRpdmlzaW9uV2lkdGggKiBzdWJkaXZpc2lvbk5iKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgbWlkbGluZVkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xhc3QgdGlja1xyXG4gICAgICAgIHNjYWxlYmFyR3JvdXBcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1zY2FsZWJhci1saW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgbmljZUxlbmd0aFBpeGVsICsgbWFyZ2luTGVmdClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgbmljZUxlbmd0aFBpeGVsICsgbWFyZ2luTGVmdClcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8pXHJcbiAgICAgICAgc2NhbGViYXJHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXNjYWxlYmFyLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBuaWNlTGVuZ3RoUGl4ZWwgKyBtYXJnaW5MZWZ0ICsgdGV4dE9mZnNldFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnNjYWxlYmFyVGlja0hlaWdodF8gKyB0ZXh0T2Zmc2V0WSlcclxuICAgICAgICAgICAgLnRleHQoZ2V0U2NhbGViYXJMYWJlbChuaWNlTGVuZ3RoTVswXSkgKyBvdXQuc2NhbGViYXJVbml0c18pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmljZVNjYWxlQmFyTGVuZ3RoID0gZnVuY3Rpb24gKHNjYWxlQmFyTGVuZ3RoKSB7XHJcbiAgICAgICAgLy9jb21wdXRlIHRoZSAnbmljZScgcG93ZXIgb2YgdGVuXHJcbiAgICAgICAgY29uc3QgcG93MTAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzY2FsZUJhckxlbmd0aCkgLyBNYXRoLmxvZygxMCkpKVxyXG5cclxuICAgICAgICAvL2NoZWNrIGlmIDUgdGltZXMgdGhpcyB2YWx1ZSBmaXRzXHJcbiAgICAgICAgaWYgKDUgKiBwb3cxMCA8PSBzY2FsZUJhckxlbmd0aCkgcmV0dXJuIFs1ICogcG93MTAsIDVdXHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgMiB0aW1lcyB0aGlzIHZhbHVlIGZpdHNcclxuICAgICAgICBpZiAoMiAqIHBvdzEwIDw9IHNjYWxlQmFyTGVuZ3RoKSByZXR1cm4gWzIgKiBwb3cxMCwgMl1cclxuXHJcbiAgICAgICAgLy9yZXR1cm5zIHRoZSBwb3dlciBvZiB0ZW5cclxuICAgICAgICByZXR1cm4gW3BvdzEwLCAxXVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdldFNjYWxlYmFyTGFiZWwgPSBmdW5jdGlvbiAodmFsdWVNKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlTSA8IDAuMDEpIHJldHVybiB2YWx1ZU0gKiAxMDAwICsgJ21tJ1xyXG4gICAgICAgIGlmICh2YWx1ZU0gPCAxKSByZXR1cm4gdmFsdWVNICogMTAwICsgJ2NtJ1xyXG4gICAgICAgIGlmICh2YWx1ZU0gPCAxMDAwKSByZXR1cm4gdmFsdWVNICogMSArICdtJ1xyXG4gICAgICAgIHJldHVybiB2YWx1ZU0gLyAxMDAwXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKiogRGVmYXVsdCBnZW9jZW50ZXIgcG9zaXRpb25zIGFuZCBwaXhlbFNpemUgKGZvciBkZWZhdWx0IHdpZHRoID0gODAwcHgpIGZvciB0ZXJyaXRvcmllcyBhbmQgcHJvamVjdGlvbnMuICovXHJcbmNvbnN0IF9kZWZhdWx0UG9zaXRpb24gPSB7XHJcbiAgICBFVVJfMzAzNTogeyBnZW9DZW50ZXI6IFs0NzkwMDAwLCAzNDIwMDAwXSwgcGl4ZWxTaXplOiA2NDAwIH0sXHJcbiAgICBJQ18zMjYyODogeyBnZW9DZW50ZXI6IFs0NDM0NjgsIDMxNDU2NDddLCBwaXhlbFNpemU6IDEwMDAgfSxcclxuICAgIEdQXzMyNjIwOiB7IGdlb0NlbnRlcjogWzY2OTQ5OCwgMTc4NDU1Ml0sIHBpeGVsU2l6ZTogMTMwIH0sXHJcbiAgICBNUV8zMjYyMDogeyBnZW9DZW50ZXI6IFs3MTY1MjEsIDE2MjEzMjJdLCBwaXhlbFNpemU6IDEzMCB9LFxyXG4gICAgR0ZfMzI2MjI6IHsgZ2VvQ2VudGVyOiBbMjY2ODUyLCA0NDQwNzRdLCBwaXhlbFNpemU6IDUwMCB9LFxyXG4gICAgUkVfMzI3NDA6IHsgZ2VvQ2VudGVyOiBbMzQ4MDExLCA3NjYxNjI3XSwgcGl4ZWxTaXplOiAxMzAgfSxcclxuICAgIFlUXzMyNzM4OiB7IGdlb0NlbnRlcjogWzUxNjU0OSwgODU4MzkyMF0sIHBpeGVsU2l6ZTogNzAgfSxcclxuICAgIE1UXzMwMzU6IHsgZ2VvQ2VudGVyOiBbNDcxOTc1NSwgMTQ0MTcwMV0sIHBpeGVsU2l6ZTogNzAgfSxcclxuICAgIFBUMjBfMzI2MjY6IHsgZ2VvQ2VudGVyOiBbMzk3NDE4LCA0MjcxNDcxXSwgcGl4ZWxTaXplOiAxNTAwIH0sXHJcbiAgICBQVDMwXzMyNjI4OiB7IGdlb0NlbnRlcjogWzMzMzU4NiwgMzYyMjcwNl0sIHBpeGVsU2l6ZTogMTUwIH0sXHJcbiAgICBMSV8zMDM1OiB7IGdlb0NlbnRlcjogWzQyODcwNjAsIDI2NzIwMDBdLCBwaXhlbFNpemU6IDQwIH0sXHJcbiAgICBJU18zMDM1OiB7IGdlb0NlbnRlcjogWzMwMTE4MDQsIDQ5NjAwMDBdLCBwaXhlbFNpemU6IDcwMCB9LFxyXG4gICAgU0pfU1ZfMzAzNTogeyBnZW9DZW50ZXI6IFs0NTcwMDAwLCA2MTYwMTU2XSwgcGl4ZWxTaXplOiA4MDAgfSxcclxuICAgIFNKX0pNXzMwMzU6IHsgZ2VvQ2VudGVyOiBbMzY0Nzc2MiwgNTQwODMwMF0sIHBpeGVsU2l6ZTogMTAwIH0sXHJcbiAgICBDQVJJQl8zMjYyMDogeyBnZW9DZW50ZXI6IFs2MzYzNDUsIDE2Njk0MzldLCBwaXhlbFNpemU6IDUwMCB9LFxyXG4gICAgV09STERfNTQwMzA6IHsgZ2VvQ2VudGVyOiBbMTQsIDE3XSwgcGl4ZWxTaXplOiA5MDAwIH0sXHJcbn1cclxuIiwiaW1wb3J0IHsgZ2V0UmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0dGVybkZpbGwobWFwLCBjb25maWdzID0gW10pIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWdzKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybigncGF0dGVybkZpbGwgZXhwZWN0cyBhbiBhcnJheSBvZiBjb25maWdzJylcclxuICAgICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGVmcyA9IG1hcC5zdmcoKS5zZWxlY3QoJ2RlZnMnKVxyXG4gICAgaWYgKGRlZnMuZW1wdHkoKSkge1xyXG4gICAgICAgIGRlZnMgPSBtYXAuc3ZnKCkuYXBwZW5kKCdkZWZzJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVwYXJlOiBtYXAgZWFjaCByZWdpb25JZCB0byBhbiBhcnJheSBvZiBwYXR0ZXJuSWRzXHJcbiAgICBjb25zdCByZWdpb25Ub1BhdHRlcm5JZHMgPSB7fVxyXG5cclxuICAgIGNvbmZpZ3MuZm9yRWFjaCgoY29uZmlnKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBwYXR0ZXJuID0gJ2hhdGNoaW5nJywgcmVnaW9uSWRzID0gW10sIGNvbG9yID0gJyMwMDAnLCBzdHJva2VXaWR0aCA9IDEsIGN1c3RvbVBhdHRlcm4gfSA9IGNvbmZpZ1xyXG5cclxuICAgICAgICBsZXQgcGF0dGVybklkXHJcblxyXG4gICAgICAgIGlmIChjdXN0b21QYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkTWF0Y2ggPSBjdXN0b21QYXR0ZXJuLm1hdGNoKC9pZD1bJ1wiXShbXidcIl0rKVsnXCJdLylcclxuICAgICAgICAgICAgaWYgKGlkTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHBhdHRlcm5JZCA9IGlkTWF0Y2hbMV1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWFwLnN2ZygpLnNlbGVjdChgIyR7cGF0dGVybklkfWApLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZzLm5vZGUoKS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGN1c3RvbVBhdHRlcm4pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2N1c3RvbVBhdHRlcm4gbXVzdCBpbmNsdWRlIGFuIGlkIGF0dHJpYnV0ZS4nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvcktleSA9IGNvbG9yLnJlcGxhY2UoJyMnLCAnJykudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgICBwYXR0ZXJuSWQgPSBgJHtwYXR0ZXJufS0ke2NvbG9yS2V5fS1zdyR7c3Ryb2tlV2lkdGh9YFxyXG4gICAgICAgICAgICBkZWZpbmVQYXR0ZXJuKG1hcCwgcGF0dGVybklkLCBwYXR0ZXJuLCBjb2xvciwgc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25maWcucGF0dGVybklkID0gcGF0dGVybklkXHJcblxyXG4gICAgICAgIHJlZ2lvbklkcy5mb3JFYWNoKChyZWdpb25JZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXJlZ2lvblRvUGF0dGVybklkc1tyZWdpb25JZF0pIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lvblRvUGF0dGVybklkc1tyZWdpb25JZF0gPSBbXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlZ2lvblRvUGF0dGVybklkc1tyZWdpb25JZF0ucHVzaChwYXR0ZXJuSWQpXHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcblxyXG4gICAgLy8gQXBwbHkgYWxsIHBhdHRlcm5zIGZvciBlYWNoIHJlZ2lvbiAoc3RhY2tpbmcgdGhlbSlcclxuICAgIG1hcC5zdmcoKVxyXG4gICAgICAgIC5zZWxlY3RBbGwoZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcCkpXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBkPy5wcm9wZXJ0aWVzPy5pZFxyXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuSWRzID0gcmVnaW9uVG9QYXR0ZXJuSWRzW2lkXVxyXG5cclxuICAgICAgICAgICAgaWYgKHBhdHRlcm5JZHMgJiYgcGF0dGVybklkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gc2VsZWN0KHRoaXMpXHJcblxyXG4gICAgICAgICAgICAgICAgcGF0dGVybklkcy5mb3JFYWNoKChwYXR0ZXJuSWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9uZSA9IG9yaWdpbmFsLm5vZGUoKS5jbG9uZU5vZGUodHJ1ZSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KGNsb25lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGB1cmwoIyR7cGF0dGVybklkfSlgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIChvcmlnaW5hbC5hdHRyKCdjbGFzcycpIHx8ICcnKSArICcgcGF0dGVybi1maWxsLW92ZXJsYXknKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5hcHBlbmQoKCkgPT4gY2xvbmUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lUGF0dGVybihtYXAsIHBhdHRlcm5JZCwgcGF0dGVybk5hbWUsIGNvbG9yLCBzdHJva2VXaWR0aCkge1xyXG4gICAgY29uc3QgZGVmcyA9IG1hcC5zdmcoKS5zZWxlY3QoJ2RlZnMnKVxyXG5cclxuICAgIGlmIChcclxuICAgICAgICBtYXBcclxuICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoYCMke0NTUy5lc2NhcGUocGF0dGVybklkKX1gKVxyXG4gICAgICAgICAgICAuZW1wdHkoKVxyXG4gICAgKSB7XHJcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGRlZnMuYXBwZW5kKCdwYXR0ZXJuJykuYXR0cignaWQnLCBwYXR0ZXJuSWQpLmF0dHIoJ3BhdHRlcm5Vbml0cycsICd1c2VyU3BhY2VPblVzZScpLmF0dHIoJ3dpZHRoJywgOCkuYXR0cignaGVpZ2h0JywgOClcclxuXHJcbiAgICAgICAgaWYgKHBhdHRlcm5OYW1lID09PSAnaGF0Y2hpbmcnKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4uYXBwZW5kKCdwYXRoJykuYXR0cignZCcsICdNLTEsMSBsMiwtMiBNMCw4IGw4LC04IE03LDkgbDIsLTInKS5hdHRyKCdzdHJva2UnLCBjb2xvcikuYXR0cignc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuTmFtZSA9PT0gJ2Nyb3NzaGF0Y2gnKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4uYXBwZW5kKCdwYXRoJykuYXR0cignZCcsICdNMCwwIGw4LDggTTgsMCBsLTgsOCcpLmF0dHIoJ3N0cm9rZScsIGNvbG9yKS5hdHRyKCdzdHJva2Utd2lkdGgnLCBzdHJva2VXaWR0aClcclxuICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm5OYW1lID09PSAnZG90cycpIHtcclxuICAgICAgICAgICAgcGF0dGVybi5hcHBlbmQoJ2NpcmNsZScpLmF0dHIoJ2N4JywgNCkuYXR0cignY3knLCA0KS5hdHRyKCdyJywgc3Ryb2tlV2lkdGgpLmF0dHIoJ2ZpbGwnLCBjb2xvcilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gcGF0dGVybiBcIiR7cGF0dGVybk5hbWV9XCIsIGRlZmF1bHRpbmcgdG8gaGF0Y2hpbmcuYClcclxuICAgICAgICAgICAgcGF0dGVybi5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgJ00tMSwxIGwyLC0yIE0wLDggbDgsLTggTTcsOSBsMiwtMicpLmF0dHIoJ3N0cm9rZScsIGNvbG9yKS5hdHRyKCdzdHJva2Utd2lkdGgnLCBzdHJva2VXaWR0aClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGNvbnN0IGFwcGVuZFN0YW1wID0gKHN0YW1wQ29uZmlnLCBtYXApID0+IHtcclxuICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tc3RhbXAnKVxyXG4gICAgICAgIGV4aXN0aW5nLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIGlmIChzdGFtcENvbmZpZykge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBtYXAuc3ZnXy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdlbS1zdGFtcCcpXHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdHNcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy5zaXplKSBzdGFtcENvbmZpZy5zaXplID0gNjBcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy54KSBzdGFtcENvbmZpZy54ID0gMjMwXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcueSkgc3RhbXBDb25maWcueSA9IDEwMFxyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLnRleHRDb2xvcikgc3RhbXBDb25maWcudGV4dENvbG9yID0gJyMwMDAnXHJcbiAgICAgICAgICAgIGlmICghc3RhbXBDb25maWcuc3RhbXBDb2xvcikgc3RhbXBDb25maWcuc3RhbXBDb2xvciA9ICcjMDAwJ1xyXG4gICAgICAgICAgICBpZiAoIXN0YW1wQ29uZmlnLnN0cm9rZVdpZHRoKSBzdGFtcENvbmZpZy5zdHJva2VXaWR0aCA9IDFcclxuICAgICAgICAgICAgaWYgKCFzdGFtcENvbmZpZy5saW5lSGVpZ2h0KSBzdGFtcENvbmZpZy5saW5lSGVpZ2h0ID0gMTVcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIHN0YW1wQ29uZmlnLnNpemUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBzdGFtcENvbmZpZy54KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5Jywgc3RhbXBDb25maWcueSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdlbS1zdGFtcC1jaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgc3RhbXBDb25maWcuc3RhbXBDb2xvcilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBzdGFtcENvbmZpZy5zdHJva2VXaWR0aClcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0ZXh0XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBzdGFtcENvbmZpZy50ZXh0XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gTWF0aC5zcXJ0KG1lYXN1cmVXaWR0aCh0ZXh0LnRyaW0oKSkgKiBzdGFtcENvbmZpZy5saW5lSGVpZ2h0KVxyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGdldExpbmVzKGdldFdvcmRzKHRleHQudHJpbSgpKSwgdGFyZ2V0V2lkdGgpXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRSYWRpdXMgPSBnZXRUZXh0UmFkaXVzKGxpbmVzLCBzdGFtcENvbmZpZy5saW5lSGVpZ2h0KVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIGluc2lkZSBjaXJjbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBzdGFtcENvbmZpZy50ZXh0Q29sb3IpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnZW0tc3RhbXAtdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3N0YW1wQ29uZmlnLnh9LCR7c3RhbXBDb25maWcueX0pIHNjYWxlKCR7c3RhbXBDb25maWcuc2l6ZSAvIHRleHRSYWRpdXN9KWApXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0c3BhbicpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShsaW5lcylcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0c3BhbicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiAoaSAtIGxpbmVzLmxlbmd0aCAvIDIgKyAwLjgpICogc3RhbXBDb25maWcubGluZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiBkLnRleHQucmVwbGFjZUFsbCgnficsICcgJykucmVwbGFjZUFsbCgnwrYnLCAnJykpIC8vIFJlbW92ZXMgwrYgKGxpbmUgYnJlYWtlcikgYW5kIH4gKG5vbiBicmVha2luZyBzcGFjZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIFNwbGl0dGluZyBieSBib3RoIHNwYWNlcyBhbmQgcGlsY3Jvd3NcclxuY29uc3QgZ2V0V29yZHMgPSAodGV4dCkgPT4ge1xyXG4gICAgcmV0dXJuIHRleHRcclxuICAgICAgICAuc3BsaXQoLyg/PD3Ctil8XFxzKy9nKVxyXG4gICAgICAgIC5tYXAoKHdvcmQpID0+IHdvcmQudHJpbSgpKVxyXG4gICAgICAgIC5maWx0ZXIoKHdvcmQpID0+IHdvcmQubGVuZ3RoID4gMClcclxufVxyXG5cclxuLy8gQ29tcHV0ZXMgdGV4dCB3aWR0aFxyXG5jb25zdCBtZWFzdXJlV2lkdGggPSAodGV4dCkgPT4ge1xyXG4gICAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKVxyXG4gICAgY29uc3QgdGV4dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3RleHQnKVxyXG5cclxuICAgIHRleHRFbGVtZW50LnRleHRDb250ZW50ID0gdGV4dFxyXG4gICAgc3ZnLmFwcGVuZENoaWxkKHRleHRFbGVtZW50KVxyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpXHJcblxyXG4gICAgY29uc3Qgd2lkdGggPSB0ZXh0RWxlbWVudC5nZXRDb21wdXRlZFRleHRMZW5ndGgoKVxyXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzdmcpXHJcblxyXG4gICAgcmV0dXJuIHdpZHRoICsgMTBcclxufVxyXG5cclxuLy8gQ29tcHV0ZSB0ZXh0IHJhZGl1c1xyXG5jb25zdCBnZXRUZXh0UmFkaXVzID0gKGxpbmVzLCBsaW5lSGVpZ2h0KSA9PiB7XHJcbiAgICBsZXQgcmFkaXVzID0gMFxyXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBsaW5lcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICBjb25zdCBkeSA9IChNYXRoLmFicyhpIC0gbiAvIDIgKyAwLjUpICsgMC41KSAqIGxpbmVIZWlnaHRcclxuICAgICAgICBjb25zdCBkeCA9IGxpbmVzW2ldLndpZHRoIC8gMlxyXG4gICAgICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgTWF0aC5zcXJ0KGR4ICoqIDIgKyBkeSAqKiAyKSlcclxuICAgIH1cclxuICAgIHJldHVybiByYWRpdXNcclxufVxyXG5cclxuLy8gSGFuZGxlcyBmb3JjZWQgbGluZSBicmVha3NcclxuY29uc3QgZ2V0TGluZXMgPSAod29yZHMsIHRhcmdldFdpZHRoKSA9PiB7XHJcbiAgICBsZXQgbGluZXMgPSBbXVxyXG4gICAgbGV0IGxpbmUgPSB7IHdpZHRoOiAwLCB0ZXh0OiAnJyB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSB3b3Jkcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICBpZiAod29yZHNbaV0gPT09ICfCticpIHtcclxuICAgICAgICAgICAgLy8gUHVzaCBjdXJyZW50IGxpbmUgKGlmIGl0IGhhcyB0ZXh0KVxyXG4gICAgICAgICAgICBpZiAobGluZS50ZXh0KSBsaW5lcy5wdXNoKGxpbmUpXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGVtcHR5IGxpbmVcclxuICAgICAgICAgICAgbGluZSA9IHsgd2lkdGg6IDAsIHRleHQ6ICcnIH1cclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsaW5lVGV4dDEgPSAobGluZS50ZXh0ID8gbGluZS50ZXh0ICsgJyAnIDogJycpICsgd29yZHNbaV1cclxuICAgICAgICBsZXQgbGluZVdpZHRoMSA9IG1lYXN1cmVXaWR0aChsaW5lVGV4dDEpXHJcblxyXG4gICAgICAgIGlmICgobGluZS53aWR0aCArIGxpbmVXaWR0aDEpIC8gMiA8IHRhcmdldFdpZHRoKSB7XHJcbiAgICAgICAgICAgIGxpbmUud2lkdGggPSBsaW5lV2lkdGgxXHJcbiAgICAgICAgICAgIGxpbmUudGV4dCA9IGxpbmVUZXh0MVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSlcclxuICAgICAgICAgICAgbGluZSA9IHsgd2lkdGg6IG1lYXN1cmVXaWR0aCh3b3Jkc1tpXSksIHRleHQ6IHdvcmRzW2ldIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxpbmUudGV4dCkgbGluZXMucHVzaChsaW5lKSAvLyBQdXNoIGxhc3QgbGluZSBpZiBpdCBleGlzdHNcclxuXHJcbiAgICByZXR1cm4gbGluZXNcclxufVxyXG4iLCJpbXBvcnQgeyBqc29uLCBjc3YgfSBmcm9tICdkMy1mZXRjaCdcclxuaW1wb3J0IHsgZ2V0RXN0YXREYXRhVVJMIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IEpTT05zdGF0IGZyb20gJ2pzb25zdGF0LXRvb2xraXQnXHJcbmltcG9ydCB7IGNzdlRvSW5kZXgsIGpzb25zdGF0VG9JbmRleCB9IGZyb20gJy4vdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBzdGF0aXN0aWNhbCBkYXRhc2V0LCB0byBiZSB1c2VkIGZvciBhIHN0YXRpc3RpY2FsIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBzdGF0RGF0YSA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vYnVpbGQgc3RhdCBkYXRhIG9iamVjdFxyXG4gICAgY29uc3Qgb3V0ID0ge31cclxuXHJcbiAgICBvdXQuX19kYXRhID0gdW5kZWZpbmVkIC8vZm9yIGRlYnVnZ2luZ1xyXG5cclxuICAgIC8vb3V0Lm1heE51bWJlck9mRGVjaW1hbHNJbkRhdGFzZXQgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMsIGluZGV4ZWQgYnkgTlVUUyBpZC5cclxuICAgICAqIEVhY2ggc3RhdCB2YWx1ZSBpcyBhbiBvYmplY3Qge3ZhbHVlLHN0YXR1c30uXHJcbiAgICAgKi9cclxuICAgIG91dC5fZGF0YV8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc3RhdCB2YWx1ZSB7dmFsdWUsc3RhdHVzfSBmcm9tIGEgbnV0cyBpZC5cclxuICAgICAqIElmIG5vIGFyZ3VtZW50IGlzIHNwZWNpZmllZCwgcmV0dXJucyB0aGUgZW50aXJlIGluZGV4LlxyXG4gICAgICogQHBhcmFtIHsqfSBudXRzSWRcclxuICAgICAqL1xyXG4gICAgb3V0LmdldCA9IChudXRzSWQpID0+IHtcclxuICAgICAgICBpZiAoIW51dHNJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0Ll9kYXRhX1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQuX2RhdGFfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0Ll9kYXRhX1tudXRzSWRdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHN0YXQgdmFsdWUgZnJvbSBhIG51dHMgaWQuXHJcbiAgICAgKiBAcGFyYW0geyp9IG51dHNJZFxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0VmFsdWUgPSAobnV0c0lkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcyA9IG91dC5nZXQobnV0c0lkKVxyXG4gICAgICAgIHJldHVybiBzID8gcy52YWx1ZSA6IHVuZGVmaW5lZFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgc3RhdCB2YWx1ZSBmcm9tIGEgbnV0cyBpZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbnV0c0lkXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8fCBTdHJpbmcgfHwgTnVtYmVyfSBzdGF0IFRoZSBuZXcgc3RhdGlzdGljYWwgZGF0YS4gVGhlIGZvcm1hdCBjYW4gYmUgZWl0aGVyIHt2YWx1ZTozNC4zMjQsc3RhdHVzOlwiZVwifSBvciBhIHRoZSB2YWx1ZSBvbmx5LlxyXG4gICAgICovXHJcbiAgICBvdXQuc2V0ID0gKG51dHNJZCwgc3RhdCkgPT4ge1xyXG4gICAgICAgIG91dC5fZGF0YV8gPSBvdXQuX2RhdGFfIHx8IHt9XHJcbiAgICAgICAgY29uc3QgcyA9IG91dC5fZGF0YV9bbnV0c0lkXVxyXG5cclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICBpZiAoc3RhdC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcy52YWx1ZSA9IHN0YXQudmFsdWVcclxuICAgICAgICAgICAgICAgIHMuc3RhdHVzID0gc3RhdC5zdGF0dXNcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGJlIGNhcmVmdWwgaGVyZSBzZXR0aW5nIHZhbHVlcyBoZXJlLCB3ZSBuZWVkIHRvIG1haW50YWluIHN0cmluZ3Mgd2l0aCB0cmFpbGluZyB6ZXJvcyBiZWNhdXNlIGluIEpTT04gMS4wID09PSAxIGFuZCB0aGV5IGFyZSByZW1vdmVkLiBVc2VyIG1pZ2h0IHdhbnQgc3RhdHMgbGFiZWxzIHdpdGggdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICBzLnZhbHVlID0gc3RhdFxyXG4gICAgICAgICAgICAgICAgLy9zLnZhbHVlID0gaXNOYU4oK3N0YXQpID8gc3RhdCA6ICtzdGF0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBiZSBjYXJlZnVsIGhlcmUgc2V0dGluZyB2YWx1ZXMgaGVyZSwgd2UgbmVlZCB0byBtYWludGFpbiBzdHJpbmdzIHdpdGggdHJhaWxpbmcgemVyb3MgYmVjYXVzZSBpbiBKU09OIDEuMCA9PT0gMSBhbmQgdGhleSBhcmUgcmVtb3ZlZC4gVXNlciBtaWdodCB3YW50IHN0YXRzIGxhYmVscyB3aXRoIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBvdXQuX2RhdGFfW251dHNJZF0gPSBzdGF0LnZhbHVlID8gc3RhdCA6IHsgdmFsdWU6IHN0YXQgfVxyXG4gICAgICAgICAgICAvL291dC5fZGF0YV9bbnV0c0lkXSA9IHN0YXQudmFsdWUgPyBzdGF0IDogeyB2YWx1ZTogaXNOYU4oK3N0YXQpID8gc3RhdCA6ICtzdGF0fVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc3RhdGlzdGljYWwgZGF0YSwgYWxyZWFkeSBpbmRleGVkIGJ5IG51dHNJZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBTb21ldGhpbmcgbGlrZTogeyBcIlBUXCI6MC4yLCBcIkxVXCI6MC42LCAuLi59LCBvciB3aXRoIHN0YXR1czogeyBcIlBUXCI6IHt2YWx1ZTowLjIsIHN0YXR1czpcImVcIn0sIFwiTFVcIjowLjYsIC4uLn1cclxuICAgICAqL1xyXG4gICAgb3V0LnNldERhdGEgPSAoZGF0YSkgPT4ge1xyXG4gICAgICAgIG91dC5fX2RhdGEgPSBkYXRhIC8vIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgICBvdXQuX2RhdGFfID0ge30gLy8gb3ZlcndyaXRlIGV4aXN0aW5nIGRhdGFcclxuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChudXRzSWQpID0+IG91dC5zZXQobnV0c0lkLCBkYXRhW251dHNJZF0pKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL2VnIGZvciBzcGFya2xpbmVzXHJcbiAgICBvdXQuc2V0TWFudWFsTXVsdGlEYXRlID0gZnVuY3Rpb24gKGRhdGFPYmplY3QpIHtcclxuICAgICAgICBvdXQuX2RhdGFfID0gb3V0Ll9kYXRhXyB8fCB7fVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHJlZ2lvbklkIGluIGRhdGFPYmplY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0ZVZhbHVlTWFwID0gZGF0YU9iamVjdFtyZWdpb25JZF1cclxuICAgICAgICAgICAgb3V0Ll9kYXRhX1tyZWdpb25JZF0gPSB7fVxyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBkYXRlIGluIGRhdGVWYWx1ZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRlVmFsdWVNYXBbZGF0ZV1cclxuICAgICAgICAgICAgICAgIG91dC5fZGF0YV9bcmVnaW9uSWRdW2RhdGVdID0geyB2YWx1ZTogdmFsdWUgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybiBhbGwgc3RhdCB2YWx1ZXMgYXMgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2xhc3NpZnkgdGhlIHZhbHVlcy4gKi9cclxuICAgIG91dC5nZXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3V0Ll9kYXRhXykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhvdXQuX2RhdGFfKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IHMgPT0gMCB8fCBzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogUmV0dXJuIHN0YXQgdW5pcXVlIHZhbHVlcy4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgY2F0ZWdvcmljYWwgbWFwcy4gKi9cclxuICAgIG91dC5nZXRVbmlxdWVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0Ll9kYXRhXylcclxuICAgICAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZSlcclxuICAgICAgICAgICAgLmZpbHRlcigoaXRlbSwgaSwgYXIpID0+IGFyLmluZGV4T2YoaXRlbSkgPT09IGkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCBtaW4gdmFsdWUuICovXHJcbiAgICBvdXQuZ2V0TWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdXQuX2RhdGFfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dC5fZGF0YV8pXHJcbiAgICAgICAgICAgICAgICAubWFwKChzKSA9PiBzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocykgPT4gcyA9PSAwIHx8IChzICYmIHMgIT09ICc6JykpXHJcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHYpID0+IE1hdGgubWluKGFjYywgdikpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEdldCBtYXggdmFsdWUuICovXHJcbiAgICBvdXQuZ2V0TWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdXQuX2RhdGFfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dC5fZGF0YV8pXHJcbiAgICAgICAgICAgICAgICAubWFwKChzKSA9PiBzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocykgPT4gcyA9PSAwIHx8IChzICYmIHMgIT09ICc6JykpXHJcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHYpID0+IE1hdGgubWF4KGFjYywgdikpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVjayBpZiB0aGUgc3RhdCBkYXRhIGlzIHJlYWR5LiAqL1xyXG4gICAgb3V0LmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dC5fZGF0YV8gIT0gdW5kZWZpbmVkXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNvbWUgbWV0YWRhdGEgKi9cclxuICAgIG91dC5tZXRhZGF0YSA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vYSB0ZXh0IGZvciB0aGUgc3RhdGl0aWNzIHVuaXQgb2YgbWVhc3VyZSwgdG8gYmUgc2hvd24gaW4gdGhlIHRvb2x0aXBcclxuICAgIG91dC51bml0VGV4dF8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHN0YXQgZGF0YSBmcm9tIHJlbW90ZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBudXRzTGV2ZWxcclxuICAgICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgb3V0LnJldHJpZXZlRnJvbVJlbW90ZSA9IGZ1bmN0aW9uIChudXRzTGV2ZWwsIGxhbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKG91dC5ldXJvc3RhdERhdGFzZXRDb2RlXykgdXBkYXRlRXVyb2Jhc2UobnV0c0xldmVsLCBsYW5nLCBjYWxsYmFjaylcclxuICAgICAgICBlbHNlIGlmIChvdXQuY3N2VVJMXykgdXBkYXRlQ1NWKGNhbGxiYWNrKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE8gZGVjb21wb3NlIGludG8gRXVyb2Jhc2UvanNvbnN0YXQgYW5kIENTViB0eXBlcyA/XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdXJvYmFzZS9qc29uc3RhdCBkYXRhIHNvdXJjZVxyXG4gICAgICogU2VlIGh0dHBzOi8vZWMuZXVyb3BhLmV1L2V1cm9zdGF0L3dlYi9qc29uLWFuZC11bmljb2RlLXdlYi1zZXJ2aWNlcy9nZXR0aW5nLXN0YXJ0ZWQvcmVzdC1yZXF1ZXN0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKiogVGhlIEV1cm9iYXNlIGRhdGFzZXQgY29kZSAqL1xyXG4gICAgb3V0LmV1cm9zdGF0RGF0YXNldENvZGVfID0gdW5kZWZpbmVkXHJcbiAgICAvKiogVGhlIEV1cm9iYXNlIGNvZGUgKi9cclxuICAgIG91dC5maWx0ZXJzXyA9IHsgbGFzdFRpbWVQZXJpb2Q6IDEgfVxyXG4gICAgLyoqIFRoZSBwcmVjaXNpb24gKG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcykgKi9cclxuICAgIG91dC5wcmVjaXNpb25fID0gMlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHByb21pc2UgZm9yIEV1cm9iYXNlL2pzb25zdGF0IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldEV1cm9iYXNlUHJvbWlzZSA9IGZ1bmN0aW9uIChudXRzTGV2ZWwsIGxhbmcpIHtcclxuICAgICAgICAvL3NldCBwcmVjaXNpb24gLy9ERVBSRUNBVEVEIDE2LzExLzIwMjEgaHR0cHM6Ly9lYy5ldXJvcGEuZXUvZXVyb3N0YXQvb25saW5lLWhlbHAvcHVibGljL2VuL05BVklHQVRJT05fV0REU1RyYW5zbGF0b3JfbWlncmF0aW9uX2VuLyNERUNPTU1JU1NJT05cclxuICAgICAgICAvL291dC5maWx0ZXJzX1tcInByZWNpc2lvblwiXSA9IG91dC5wcmVjaXNpb25fO1xyXG4gICAgICAgIC8vc2VsZWN0IG9ubHkgcmVxdWlyZWQgZ2VvIGdyb3VwcywgZGVwZW5kaW5nIG9uIHRoZSBzcGVjaWZpZWQgbnV0cyBsZXZlbFxyXG4gICAgICAgIGlmICghb3V0LmZpbHRlcnNfLmdlbykge1xyXG4gICAgICAgICAgICBvdXQuZmlsdGVyc19bJ2dlb0xldmVsJ10gPSBudXRzTGV2ZWwgKyAnJyA9PT0gJzAnID8gJ2NvdW50cnknIDogJ251dHMnICsgbnV0c0xldmVsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2ZvcmNlIGZpbHRlcmluZyBvZiBldXJvLWdlby1hZ2dyZWdhdGVzXHJcbiAgICAgICAgLy9vdXQuZmlsdGVyc19bXCJmaWx0ZXJOb25HZW9cIl0gPSAxOyAvL0RFUFJFQ0FURUQgMTYvMTEvMjAyMVxyXG5cclxuICAgICAgICAvL3JldHJpZXZlIHN0YXQgZGF0YSBmcm9tIEV1cm9zdGF0IEFQSVxyXG4gICAgICAgIHJldHVybiBqc29uKGdldEVzdGF0RGF0YVVSTChvdXQuZXVyb3N0YXREYXRhc2V0Q29kZV8sIG91dC5maWx0ZXJzXywgbGFuZykpXHJcbiAgICB9XHJcblxyXG4gICAgLy9mb3IgZXVyb2Jhc2Ugc3RhdGlzdGljYWwgZGF0YSB0byByZXRyaWV2ZSBmcm9tIEV1cm9zdGF0IEFQSVxyXG4gICAgY29uc3QgdXBkYXRlRXVyb2Jhc2UgPSBmdW5jdGlvbiAobnV0c0xldmVsLCBsYW5nLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vZXJhc2UgcHJldmlvdXMgZGF0YVxyXG4gICAgICAgIG91dC5fZGF0YV8gPSBudWxsXHJcblxyXG4gICAgICAgIGdldEV1cm9iYXNlUHJvbWlzZShudXRzTGV2ZWwsIGxhbmcpLnRoZW4oZnVuY3Rpb24gKGRhdGFfX18pIHtcclxuICAgICAgICAgICAgLy9kZWNvZGUgc3RhdCBkYXRhXHJcbiAgICAgICAgICAgIGNvbnN0IGpzZCA9IEpTT05zdGF0KGRhdGFfX18pXHJcblxyXG4gICAgICAgICAgICAvL3N0b3JlIGpzb25zdGF0IG1ldGFkYXRhXHJcbiAgICAgICAgICAgIG91dC5tZXRhZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBqc2QubGFiZWwsXHJcbiAgICAgICAgICAgICAgICBocmVmOiBqc2QuaHJlZixcclxuICAgICAgICAgICAgICAgIHNvdXJjZToganNkLnNvdXJjZSxcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IGpzZC51cGRhdGVkLFxyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBqc2QuZXh0ZW5zaW9uLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dC5tZXRhZGF0YS50aW1lID0ganNkLkRpbWVuc2lvbigndGltZScpLmlkWzBdXHJcblxyXG4gICAgICAgICAgICAvL2luZGV4XHJcbiAgICAgICAgICAgIG91dC5fZGF0YV8gPSBqc29uc3RhdFRvSW5kZXgoanNkKVxyXG4gICAgICAgICAgICAvL1RPRE86IHVzZSBtYXliZSBodHRwczovL2dpdGh1Yi5jb20vYmFkb3NhL0pTT04tc3RhdC9ibG9iL21hc3Rlci91dGlscy9mcm9tdGFibGUubWQgdG8gYnVpbGQgZGlyZWN0bHkgYW4gaW5kZXggP1xyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgdGltZSBzdGFtcCBvZiB0aGUganNvbnN0YXQgZGF0YXNldC5cclxuICAgICAqL1xyXG4gICAgb3V0LmdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IG91dC5maWx0ZXJzXy50aW1lXHJcbiAgICAgICAgaWYgKHQpIHJldHVybiB0XHJcbiAgICAgICAgaWYgKCFvdXQuX2RhdGFfKSByZXR1cm5cclxuICAgICAgICByZXR1cm4gb3V0Lm1ldGFkYXRhLnRpbWVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENTViBkYXRhIHNvdXJjZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqIFRoZSBDU1YgZmlsZSBVUkwgKi9cclxuICAgIG91dC5jc3ZVUkxfID0gdW5kZWZpbmVkXHJcbiAgICAvKiogVGhlIENTViBjb2x1bW4gd2l0aCB0aGUgTlVUUyBpZHMgKi9cclxuICAgIG91dC5nZW9Db2xfID0gJ2dlbydcclxuICAgIC8qKiBUaGUgQ1NWIGNvbHVtbiB3aXRoIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgKi9cclxuICAgIG91dC52YWx1ZUNvbF8gPSAndmFsdWUnXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gcHJvbWlzZSBmb3IgQ1NWIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldENTVlByb21pc2UgPSBmdW5jdGlvbiAobnV0c0xldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNzdihvdXQuY3N2VVJMXylcclxuICAgIH1cclxuXHJcbiAgICAvL2ZvciBzdGF0aXN0aWNhbCBkYXRhIHRvIHJldHJpZXZlIGZyb20gQ1NWIGZpbGVcclxuICAgIGNvbnN0IHVwZGF0ZUNTViA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIC8vZXJhc2UgcHJldmlvdXMgZGF0YVxyXG4gICAgICAgIG91dC5fZGF0YV8gPSBudWxsXHJcblxyXG4gICAgICAgIC8vcmV0cmlldmUgY3N2IGRhdGFcclxuICAgICAgICBnZXRDU1ZQcm9taXNlKCkudGhlbihmdW5jdGlvbiAoZGF0YV9fXykge1xyXG4gICAgICAgICAgICAvL2RlY29kZSBzdGF0IGRhdGFcclxuICAgICAgICAgICAgb3V0Ll9kYXRhXyA9IGNzdlRvSW5kZXgoZGF0YV9fXywgb3V0Lmdlb0NvbF8sIG91dC52YWx1ZUNvbF8pXHJcblxyXG4gICAgICAgICAgICAvL3N0b3JlIHNvbWUgbWV0YWRhdGFcclxuICAgICAgICAgICAgb3V0Lm1ldGFkYXRhID0geyBocmVmOiBvdXQuY3N2VVJMXyB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbJ3VuaXRUZXh0XyddLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleSArICdfJ10gPSBjb25maWdba2V5XVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBhcHBseUlubGluZVN0eWxlc0Zyb21DU1MsIGZsYWdzLCBzZXJpYWxpemUsIHJhc3Rlcml6ZSwgZ2V0RG93bmxvYWRVUkwgfSBmcm9tICcuL3V0aWxzJ1xyXG5pbXBvcnQgKiBhcyBNYXBUZW1wbGF0ZSBmcm9tICcuL21hcC10ZW1wbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdGlzdGljYWxEYXRhIGZyb20gJy4vc3RhdC1kYXRhJ1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZCdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgKiBhcyB0cCBmcm9tICcuLi90b29sdGlwL3Rvb2x0aXAnXHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3Qgc3RhdGlzdGljYWwgbWFwOiBBIG1hcCB0ZW1wbGF0ZSB3aXRoIHN0YXRpc3RpY2FsIGRhdGEsIHdpdGhvdXQgYW55IHBhcnRpY3VsYXIgc3R5bGluZyBydWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHdpdGhDZW50ZXJQb2ludHMgU2V0IHRvIHRydWUgKG9yIDEpIHRvIGFkZCByZWdpb25zIGNlbnRlciBwb2ludHMgdG8gdGhlIG1hcCB0ZW1wbGF0ZSwgdG8gYmUgdXNlZCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbHMgbWFwcyBmb3IgZXhhbXBsZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzdGF0TWFwID0gZnVuY3Rpb24gKGNvbmZpZywgd2l0aENlbnRlclBvaW50cywgbWFwVHlwZSkge1xyXG4gICAgLy9idWlsZCBzdGF0IG1hcCBmcm9tIG1hcCB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gTWFwVGVtcGxhdGUubWFwVGVtcGxhdGUoY29uZmlnLCB3aXRoQ2VudGVyUG9pbnRzLCBtYXBUeXBlKVxyXG5cclxuICAgIC8vc3RhdGlzdGljYWwgZGF0YVxyXG5cclxuICAgIC8vdGhlIHN0YXRpc3RpY2FsIGRhdGEgY29uZmlndXJhdGlvbi5cclxuICAgIC8vQSBtYXAgY2FuIGhhdmUgc2V2ZXJhbCBzdGF0IGRhdGFzZXRzLiBUaGlzIGlzIGEgZGljdGlvbmFyeSBvZiBhbGwgc3RhdCBjb25maWd1cmF0aW9uXHJcbiAgICBvdXQuc3RhdF8gPSB7IGRlZmF1bHQ6IHVuZGVmaW5lZCB9XHJcbiAgICBvdXQuc3RhdCA9IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgLy9ubyBhcmd1bWVudDogZ2V0dGVyIC0gcmV0dXJuIHRoZSBkZWZhdWx0IHN0YXRcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuc3RhdF9bJ2RlZmF1bHQnXVxyXG4gICAgICAgIC8vdHdvIGFyZ3VtZW50czogc2V0dGVyIC0gc2V0IHRoZSBjb25maWcgayB3aXRoIHZhbHVlIHZcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIG91dC5zdGF0X1trXSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgICAgICAvL29uZSBzdHJpbmcgYXJndW1lbnQ6IGdldHRlciAtIHJldHVybiB0aGUgY29uZmlnIGtcclxuICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnIHx8IGsgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiBvdXQuc3RhdF9ba11cclxuICAgICAgICAvL29uZSBub24tc3RyaW5nIGFyZ3VtZW50OiBzZXR0ZXIgLSBzZXQgdGhlIGVudGlyZSBkaWN0aW9ubmFyeVxyXG4gICAgICAgIG91dC5zdGF0XyA9IGsuZGVmYXVsdCA/IGsgOiB7IGRlZmF1bHQ6IGsgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL3RoZSBzdGF0aXN0aWNhbCBkYXRhLCByZXRyaWV2ZWQgZnJvbSB0aGUgY29uZmlnIGluZm9ybWF0aW9uLiBBcyBhIGRpY3Rpb25hcnkuXHJcbiAgICBvdXQuc3RhdERhdGFfID0ge1xyXG4gICAgICAgIGRlZmF1bHQ6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLFxyXG4gICAgICAgIGNvbG9yOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSxcclxuICAgICAgICBzaXplOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSxcclxuICAgICAgICB2MTogU3RhdGlzdGljYWxEYXRhLnN0YXREYXRhKCksXHJcbiAgICAgICAgdjI6IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YSgpLCAvL2JpdmFyaWF0ZVxyXG4gICAgICAgIHYzOiBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKSwgLy90cml2YXJpYXRlXHJcbiAgICB9XHJcbiAgICBvdXQuc3RhdERhdGEgPSBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5zdGF0RGF0YV9bJ2RlZmF1bHQnXVxyXG5cclxuICAgICAgICAvLyBsYXp5IGNyZWF0ZSBpZiBub3QgZXhpc3RcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZiAoIW91dC5zdGF0RGF0YV9ba10pIG91dC5zdGF0RGF0YV9ba10gPSBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0LnN0YXREYXRhX1trXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2V0dGVyXHJcbiAgICAgICAgb3V0LnN0YXREYXRhX1trXSA9IHZcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy90ZXN0IGZvciBubyBkYXRhIGNhc2VcclxuICAgIG91dC5ub0RhdGFUZXh0XyA9ICdObyBkYXRhIGF2YWlsYWJsZSdcclxuICAgIC8vbGFuZ2FnZSAoY3VycmVudGx5IHVzZWQgb25seSBmb3IgZXVyb3N0YXQgZGF0YSBBUEkpXHJcbiAgICBvdXQubGFuZ3VhZ2VfID0gJ2VuJ1xyXG4gICAgLy90cmFuc2l0aW9uIHRpbWUgZm9yIHJlbmRlcmluZ1xyXG4gICAgb3V0LnRyYW5zaXRpb25EdXJhdGlvbl8gPSA1MDBcclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gdW5kZWZpbmVkXHJcbiAgICAvL2ZvciBtYXBzIHVzaW5nIHNwZWNpYWwgZmlsbCBwYXR0ZXJucywgdGhpcyBpcyB0aGUgZnVuY3Rpb24gdG8gZGVmaW5lIHRoZW0gaW4gdGhlIFNWRyBpbWFnZSAtIFNlZSBmdW5jdGlvbnM6IGdldEZpbGxQYXR0ZXJuTGVnZW5kIGFuZCBnZXRGaWxsUGF0dGVybkRlZmluaXRpb25GdW5cclxuICAgIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9hIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIG1hcCBidWlsZCBpcyBjb21wbGV0ZS5cclxuICAgIG91dC5jYWxsYmFja18gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL2xlZ2VuZCBjb25maWd1cmF0aW9uXHJcbiAgICBvdXQubGVnZW5kXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9sZWdlbmQgb2JqZWN0XHJcbiAgICBvdXQubGVnZW5kT2JqXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbJ2xlZ2VuZF8nLCAnbGVnZW5kT2JqXycsICdub0RhdGFUZXh0XycsICdsYW5ndWFnZV8nLCAndHJhbnNpdGlvbkR1cmF0aW9uXycsICd0b29sdGlwVGV4dF8nLCAnZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8nLCAnY2FsbGJhY2tfJ10uZm9yRWFjaChcclxuICAgICAgICBmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIGlmIChvdXRba2V5XSAmJiBjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG5cclxuICAgIC8vIG92ZXJyaWRlIGxlZ2VuZCBmb3IgdXBkYXRpbmcgYWZ0ZXIgYnVpbGRcclxuICAgIG91dC5sZWdlbmQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5sZWdlbmRfXHJcblxyXG4gICAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIGxlZ2VuZFxyXG4gICAgICAgIGlmICh2ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZCA9IG91dC5sZWdlbmRPYmooKVxyXG4gICAgICAgICAgICBpZiAobGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWdlbmRTdmcgPSBzZWxlY3QoJyMnICsgbGVnZW5kLnN2Z0lkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZFN2Zy5zaXplKCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kU3ZnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LmxlZ2VuZF8gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9zZXQgbmV3IGxlZ2VuZCBjb25maWdcclxuICAgICAgICBvdXQubGVnZW5kXyA9IHZcclxuICAgICAgICAvL3VwZGF0ZSBpZiBleGlzdGluZyBsZWdlbmRcclxuICAgICAgICBpZiAob3V0LmxlZ2VuZE9ial8pIG91dC51cGRhdGVMZWdlbmQoKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBvdXQudXBkYXRlTGVnZW5kID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAob3V0LmxlZ2VuZE9ial8pIG91dC5sZWdlbmRPYmooKS51cGRhdGUoKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIHRoZSBtYXAuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uY2UsIHByZWZlcmFibHkgYWZ0ZXIgdGhlIG1hcCBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBzZXQgdG8gc29tZSBpbml0aWFsIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgb3V0LmJ1aWxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChvdXQucHJvamVjdGlvbkZ1bmN0aW9uXykgb3V0LnByb2ooJzQzMjYnKSAvL3doZW4gdXNpbmcgY3VzdG9tIGQzIHByb2plY3Rpb24gZnVuY3Rpb24gYWx3YXlzIHJlcXVlc3QgTlVUUzJKU09OIGluIFdHUzg0XHJcblxyXG4gICAgICAgIC8vYnVpbGQgbWFwIHRlbXBsYXRlIGJhc2VcclxuICAgICAgICBvdXQuYnVpbGRNYXBUZW1wbGF0ZUJhc2UoKVxyXG5cclxuICAgICAgICAvL2FkZCBhZGRpdGlvbmFsIGZpbHRlcnMgZm9yIGZpbGwgcGF0dGVybnMgZm9yIGV4YW1wbGVcclxuICAgICAgICBpZiAob3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fKSB7XHJcbiAgICAgICAgICAgIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXyhvdXQuc3ZnKCksIG91dC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sZWdlbmQgZWxlbWVudFxyXG4gICAgICAgIGlmIChvdXQubGVnZW5kKCkpIHtcclxuICAgICAgICAgICAgb3V0LmJ1aWxkTGVnZW5kKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZGVmaW5lIHRvb2x0aXBcclxuICAgICAgICAvL3ByZXBhcmUgbWFwIHRvb2x0aXBcclxuICAgICAgICBpZiAob3V0LnRvb2x0aXBfKSB7XHJcbiAgICAgICAgICAgIG91dC5fdG9vbHRpcCA9IHRwLnRvb2x0aXAob3V0LnRvb2x0aXBfKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vbm8gY29uZmlnIHNwZWNpZmllZCwgdXNlIGRlZmF1bHRcclxuICAgICAgICAgICAgb3V0Ll90b29sdGlwID0gdHAudG9vbHRpcCgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xhdW5jaCBnZW8gZGF0YSByZXRyaWV2YWxcclxuICAgICAgICBvdXQudXBkYXRlR2VvRGF0YSgpXHJcblxyXG4gICAgICAgIC8vbGF1bmNoIHN0YXQgZGF0YSByZXRyaWV2YWxcclxuICAgICAgICBvdXQudXBkYXRlU3RhdERhdGEoKVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgb3V0LmJ1aWxkTGVnZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vY3JlYXRlIGxlZ2VuZCBvYmplY3RcclxuICAgICAgICBvdXQubGVnZW5kT2JqKG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvcigpKG91dCwgb3V0LmxlZ2VuZCgpKSlcclxuICAgICAgICBjb25zdCBsZWdlbmQgPSBvdXQubGVnZW5kT2JqKClcclxuXHJcbiAgICAgICAgLy9nZXQgbGVnZW5kIHN2Zy4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIGNyZWF0ZSBpdCBlbWJlZGVkIHdpdGhpbiB0aGUgbWFwXHJcbiAgICAgICAgbGV0IGxlZ2VuZFN2ZyA9IHNlbGVjdCgnIycgKyBsZWdlbmQuc3ZnSWQpXHJcbiAgICAgICAgaWYgKGxlZ2VuZFN2Zy5zaXplKCkgPT0gMCkge1xyXG4gICAgICAgICAgICAvL2dldCBsZWdlbmQgcG9zaXRpb25cclxuICAgICAgICAgICAgY29uc3QgeCA9IGxlZ2VuZC54ID09IHVuZGVmaW5lZCA/IG91dC53aWR0aCgpIC0gMTAwIC0gbGVnZW5kLmJveFBhZGRpbmcgOiBsZWdlbmQueFxyXG4gICAgICAgICAgICBjb25zdCB5ID0gbGVnZW5kLnkgPT0gdW5kZWZpbmVkID8gbGVnZW5kLmJveFBhZGRpbmcgOiBsZWdlbmQueVxyXG5cclxuICAgICAgICAgICAgLy9idWlsZCBsZWdlbmQgU1ZHIGluIGEgbmV3IGdyb3VwXHJcbiAgICAgICAgICAgIG91dC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBsZWdlbmQuc3ZnSWQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlZ2VuZC5idWlsZCgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENoZWNrIGlmIGFsbCBzdGF0IGRhdGFzZXRzIGhhdmUgYmVlbiBsb2FkZWQuICovXHJcbiAgICBjb25zdCBpc1N0YXREYXRhUmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3V0LnN0YXREYXRhXykge1xyXG4gICAgICAgICAgICBjb25zdCBoYXNDb25maWcgPSAhIW91dC5zdGF0X1trZXldXHJcbiAgICAgICAgICAgIGNvbnN0IGhhc01hbnVhbERhdGEgPSAhIShvdXQuc3RhdERhdGFfW2tleV0gJiYgb3V0LnN0YXREYXRhX1trZXldLmdldCgpKVxyXG5cclxuICAgICAgICAgICAgaWYgKCFoYXNDb25maWcgJiYgIWhhc01hbnVhbERhdGEpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGlmICghb3V0LnN0YXREYXRhX1trZXldLmlzUmVhZHkoKSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXVuY2ggbWFwIGdlbyBkYXRhIHJldHJpZXZhbCwgYW5kIG1ha2UvdXBkYXRlIHRoZSBtYXAgb25jZSByZWNlaXZlZC5cclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYXR0cmlidXRlcyByZWxhdGVkIHRvIHRoZSBtYXAgZ2VvbWV0cmllcyBoYXZlIGNoYW5nZWQsIHRvIHJldHJpZXZlIHRoaXMgbmV3IGRhdGEgYW5kIHJlZnJlc2ggdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZUdlb0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUdlb01hcFRlbXBsYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgLy9pZiBzdGF0IGRhdGFzZXRzIGhhdmUgbm90IGJlZW4gbG9hZGVkLCB3YWl0IGFnYWluXHJcbiAgICAgICAgICAgIGlmICghaXNTdGF0RGF0YVJlYWR5KCkpIHJldHVyblxyXG5cclxuICAgICAgICAgICAgLy9wcm9jZWVkIHdpdGggbWFwIGNvbnN0cnVjdGlvblxyXG4gICAgICAgICAgICBvdXQudXBkYXRlU3RhdFZhbHVlcygpXHJcbiAgICAgICAgICAgIC8vZXhlY3V0ZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICAgICAgICBpZiAob3V0LmNhbGxiYWNrKCkpIG91dC5jYWxsYmFjaygpKG91dClcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXVuY2ggbWFwIGdlbyBzdGF0IGRhdGFzZXRzIHJldHJpZXZhbCwgYW5kIG1ha2UvdXBkYXRlIHRoZSBtYXAgb25jZSByZWNlaXZlZC5cclxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc3BlY2lmaWNhdGlvbnMgb24gdGhlIHN0YXQgZGF0YSBzb3VyY2VzIGF0dGFjaGVkIHRvIHRoZSBtYXAgaGF2ZSBjaGFuZ2VkLCB0byByZXRyaWV2ZSB0aGlzIG5ldyBkYXRhIGFuZCByZWZyZXNoIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGVTdGF0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKGxldCBzdGF0S2V5IGluIG91dC5zdGF0Xykge1xyXG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBvdXQuc3RhdChzdGF0S2V5KVxyXG4gICAgICAgICAgICBjb25zdCBtYW51YWxEYXRhID0gb3V0LnN0YXREYXRhKHN0YXRLZXkpLmdldD8uKClcclxuXHJcbiAgICAgICAgICAgIC8vIFNraXAgaWYgbmVpdGhlciBzdGF0IGNvbmZpZyBub3IgbWFudWFsIGRhdGFcclxuICAgICAgICAgICAgaWYgKCFjb25maWcgJiYgIW1hbnVhbERhdGEpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY29uZmlnLCBidWlsZCB0aGUgc3RhdERhdGEgb2JqZWN0IChvciByZXBsYWNlIGV4aXN0aW5nKVxyXG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0RGF0YSA9IFN0YXRpc3RpY2FsRGF0YS5zdGF0RGF0YShjb25maWcpXHJcbiAgICAgICAgICAgICAgICBvdXQuc3RhdERhdGEoc3RhdEtleSwgc3RhdERhdGEpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGF1bmNoIHJlbW90ZSByZXRyaWV2YWxcclxuICAgICAgICAgICAgICAgIGxldCBubCA9IG91dC5udXRzTGV2ZWxfXHJcbiAgICAgICAgICAgICAgICBpZiAobmwgPT09ICdtaXhlZCcpIG5sID0gMFxyXG5cclxuICAgICAgICAgICAgICAgIHN0YXREYXRhLnJldHJpZXZlRnJvbVJlbW90ZShubCwgb3V0Lmxhbmd1YWdlKCksICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW91dC5HZW9tZXRyaWVzLmlzR2VvUmVhZHkoKSkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0YXREYXRhUmVhZHkoKSkgcmV0dXJuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG91dC51cGRhdGVTdGF0VmFsdWVzKClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LmNhbGxiYWNrKCkpIG91dC5jYWxsYmFjaygpKG91dClcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2UvdXBkYXRlIHRoZSBtYXAgd2l0aCBuZXcgc3RhdCBkYXRhLlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBzdGF0IGRhdGEgYXR0YWNoZWQgdG8gdGhlIG1hcCBoYXZlIGNoYW5nZWQsIHRvIHJlZnJlc2ggdGhlIG1hcC5cclxuICAgICAqIElmIHRoZSBzdGF0IGRhdGEgc291cmNlcyBoYXZlIGNoYW5nZWQsIGNhbGwgKnVwZGF0ZVN0YXREYXRhKiBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlU3RhdFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3VwZGF0ZSBjbGFzc2lmaWNhdGlvbiBhbmQgc3R5bGVzXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uKClcclxuICAgICAgICBvdXQudXBkYXRlU3R5bGUoKVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmQsIGlmIGFueVxyXG4gICAgICAgIGlmIChvdXQubGVnZW5kXyAmJiBvdXQubGVnZW5kT2JqKCkpIG91dC5sZWdlbmRPYmooKS51cGRhdGUoKVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBtZXRob2QuXHJcbiAgICAgKiBNYWtlL3VwZGF0ZSB0aGUgbWFwIGFmdGVyIGNsYXNzaWZpY2F0aW9uIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGNoYW5nZWQuXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG51bWJlciBvZiBjbGFzc2VzLCBvciB0aGUgY2xhc3NpZmljYXRpb24gbWV0aG9kIGhhcyBjaGFuZ2VkLCBjYWxsIHRoaXMgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ01hcCB1cGRhdGVDbGFzc2lmaWNhdGlvbiBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IG1ldGhvZC5cclxuICAgICAqIE1ha2UvdXBkYXRlIHRoZSBtYXAgYWZ0ZXIgc3R5bGluZyBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjaGFuZ2VkLlxyXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBzdHlsZSAoY29sb3I/KSBmb3Igb25lIGxlZ2VuZCBlbGVtZW50IGhhcyBjaGFuZ2VkLCBjYWxsIHRoaXMgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ01hcCB1cGRhdGVTdHlsZSBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IG1ldGhvZC5cclxuICAgICAqIEZ1bmN0aW9uIHdoaWNoIHJldHVybiB0aGUgbGVnZW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ01hcCBnZXRMZWdlbmRDb25zdHJ1Y3RvciBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnKVxyXG4gICAgICAgIHJldHVybiBMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdGltZSBzdGFtcCBvZiB0aGUgbWFwLCBldmVuIGlmIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGRpbWVuc2lvbiBpbml0aWFsbHkuXHJcbiAgICAgKiBUaGlzIGFwcGxpZXMgb25seSBmb3Igc3RhdCBkYXRhIHJldHJpZXZlZCBmcm9tIEV1cm9zdGF0IEFQSS5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSB3aGVuIHRoZSBkYXRhIHJldHJpZXZlZCBpcyB0aGUgZnJlc2hlc3QsIGFuZCBvbmUgd2FudHMgdG8ga25vdyB3aGF0IHRoaXMgZGF0ZSBpcywgZm9yIGV4YW1wbGUgdG8gZGlzcGxheSBpdCBpbiB0aGUgbWFwIHRpdGxlLlxyXG4gICAgICovXHJcbiAgICBvdXQuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gb3V0LnN0YXREYXRhKCdkZWZhdWx0JykuZ2V0VGltZSgpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc29tZSBtYXAgYXR0cmlidXRlcyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIFVSTCBwYXJhbWV0ZXJzOlxyXG4gICAgICogXCJ3XCI6d2lkdGgsIFwiaFwiOmhlaWdodCwgXCJ4XCI6eEdlb0NlbnRlciwgXCJ5XCI6eUdlb0NlbnRlciwgXCJ6XCI6cGl4R2VvU2l6ZSwgXCJzXCI6c2NhbGUsIFwibHZsXCI6bnV0cyBsZXZlbCwgXCJ0aW1lXCI6dGltZSxcclxuICAgICAqIFwicHJvalwiOkNSUywgXCJnZW9cIjpnZW8gdGVycml0b3J5LCBcIm55XCI6bnV0cyB2ZXJzaW9uLCBcImxhbmd1YWdlXCI6bGFuZ2FnZSwgXCJudW1iZXJPZkNsYXNzZXNcIjpjbGFzcyBudW1iZXJcclxuICAgICAqL1xyXG4gICAgb3V0LnNldEZyb21VUkwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0cyA9IGdldFVSTFBhcmFtZXRlcnMoKVxyXG4gICAgICAgIGlmIChvcHRzLncpIG91dC53aWR0aChvcHRzLncpXHJcbiAgICAgICAgaWYgKG9wdHMuaCkgb3V0LmhlaWdodChvcHRzLmgpXHJcbiAgICAgICAgaWYgKG9wdHMueCAmJiBvcHRzLnkpIG91dC5nZW9DZW50ZXIoW29wdHMueCwgb3B0cy55XSlcclxuICAgICAgICBpZiAob3B0cy56KSBvdXQucGl4ZWxTaXplKG9wdHMueilcclxuICAgICAgICBpZiAob3B0cy5zKSBvdXQuc2NhbGUob3B0cy5zKVxyXG4gICAgICAgIGlmIChvcHRzLmx2bCkgb3V0Lm51dHNMZXZlbChvcHRzLmx2bClcclxuICAgICAgICBpZiAob3B0cy50aW1lKSB7XHJcbiAgICAgICAgICAgIG91dC5maWx0ZXJzXy50aW1lID0gb3B0cy50aW1lXHJcbiAgICAgICAgICAgIGRlbGV0ZSBvdXQuZmlsdGVyc18ubGFzdFRpbWVQZXJpb2RcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMucHJvaikgb3V0LnByb2oob3B0cy5wcm9qKVxyXG4gICAgICAgIGlmIChvcHRzLmdlbykgb3V0LmdlbyhvcHRzLmdlbylcclxuICAgICAgICBpZiAob3B0cy5ueSkgb3V0Lm51dHNZZWFyKG9wdHMubnkpXHJcbiAgICAgICAgaWYgKG9wdHMubGFuZ3VhZ2UpIG91dC5sYW5ndWFnZShvcHRzLmxhbmd1YWdlKVxyXG4gICAgICAgIGlmIChvcHRzLm51bWJlck9mQ2xhc3Nlcykgb3V0Lm51bWJlck9mQ2xhc3Nlcygrb3B0cy5udW1iZXJPZkNsYXNzZXMpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGV4cG9ydE1hcFRvU1ZHXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRXhwb3J0cyB0aGUgY3VycmVudCBtYXAgd2l0aCBzdHlsaW5nIHRvIFNWRyBhbmQgZG93bmxvYWRzIGl0XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBvdXQuZXhwb3J0TWFwVG9TVkcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ2xvbmUgdGhlIG9yaWdpbmFsIFNWRyBub2RlIHRvIGF2b2lkIG1vZGlmeWluZyB0aGUgRE9NXHJcbiAgICAgICAgY29uc3Qgc3ZnTm9kZUNsb25lID0gb3V0LnN2Z18ubm9kZSgpLmNsb25lTm9kZSh0cnVlKVxyXG4gICAgICAgIC8vIEFkZCBYTUwgbmFtZXNwYWNlcyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XHJcbiAgICAgICAgaWYgKCFzdmdOb2RlQ2xvbmUuaGFzQXR0cmlidXRlKCd4bWxucycpKSB7XHJcbiAgICAgICAgICAgIHN2Z05vZGVDbG9uZS5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJylcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdmdOb2RlQ2xvbmUuaGFzQXR0cmlidXRlKCd4bWxuczp4bGluaycpKSB7XHJcbiAgICAgICAgICAgIHN2Z05vZGVDbG9uZS5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgYXBwZW5kIHRoZSBjbG9uZSB0byB0aGUgZG9jdW1lbnQgdG8gY29tcHV0ZSBzdHlsZXNcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Z05vZGVDbG9uZSlcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBDU1MgdG8gaW5saW5lIHN0eWxlcyBiZWZvcmUgc2F2aW5nIHRoZSBTVkdcclxuICAgICAgICBhcHBseUlubGluZVN0eWxlc0Zyb21DU1Moc3ZnTm9kZUNsb25lKVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGNsb25lZCBTVkcgZnJvbSB0aGUgZG9jdW1lbnQgYWZ0ZXIgYXBwbHlpbmcgc3R5bGVzXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzdmdOb2RlQ2xvbmUpXHJcblxyXG4gICAgICAgIGNvbnN0IHN2Z1VybCA9IGdldERvd25sb2FkVVJMKHN2Z05vZGVDbG9uZSlcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgZG93bmxvYWQgbGluayBhbmQgdHJpZ2dlciBkb3dubG9hZFxyXG4gICAgICAgIGNvbnN0IGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxyXG4gICAgICAgIGRvd25sb2FkTGluay5ocmVmID0gc3ZnVXJsXHJcbiAgICAgICAgZG93bmxvYWRMaW5rLmRvd25sb2FkID0gJ2V1cm9zdGF0bWFwLnN2ZydcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkTGluaylcclxuICAgICAgICBkb3dubG9hZExpbmsuY2xpY2soKVxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRMaW5rKVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gZXhwb3J0TWFwVG9QTkdcclxuICAgICAqIEBkZXNjcmlwdGlvbiBFeHBvcnRzIHRoZSBjdXJyZW50IG1hcCB3aXRoIHN0eWxpbmcgdG8gUE5HIGFuZCBkb3dubG9hZHMgaXRcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIG91dC5leHBvcnRNYXBUb1BORyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgY29uc3Qgc3ZnTm9kZUNsb25lID0gb3V0LnN2Z18ubm9kZSgpLmNsb25lTm9kZSh0cnVlKVxyXG4gICAgICAgIC8vIENvbnZlcnQgQ1NTIHRvIGlubGluZSBzdHlsZXMgYmVmb3JlIHNhdmluZyB0aGUgU1ZHXHJcbiAgICAgICAgYXBwbHlJbmxpbmVTdHlsZXNGcm9tQ1NTKHN2Z05vZGVDbG9uZSlcclxuXHJcbiAgICAgICAgLy8gU3RlcCAxOiBTZXJpYWxpemUgdGhlIFNWRyBub2RlIHRvIGEgc3RyaW5nXHJcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKClcclxuICAgICAgICBjb25zdCBzdmdTdHJpbmcgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Z05vZGVDbG9uZSlcclxuXHJcbiAgICAgICAgLy8gU3RlcCAyOiBDcmVhdGUgYSBCbG9iIGZyb20gdGhlIHNlcmlhbGl6ZWQgU1ZHXHJcbiAgICAgICAgY29uc3Qgc3ZnQmxvYiA9IG5ldyBCbG9iKFtzdmdTdHJpbmddLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgnIH0pXHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMzogQ3JlYXRlIGEgVVJMIGZvciB0aGUgQmxvYlxyXG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3ZnQmxvYilcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMgZnJvbSB0aGUgU1ZHXHJcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCBzdmdOb2RlQ2xvbmUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpXHJcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHN2Z05vZGVDbG9uZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXHJcblxyXG4gICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NWRyB3aWR0aCBvciBoZWlnaHQgYXR0cmlidXRlcyBhcmUgbWlzc2luZyBvciBpbnZhbGlkLicpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGVwIDQ6IENyZWF0ZSBhbiBJbWFnZSBlbGVtZW50IGFuZCBsb2FkIHRoZSBCbG9iIFVSTFxyXG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXHJcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU3RlcCA1OiBEcmF3IHRoZSBpbWFnZSBvbiBhIGNhbnZhc1xyXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBwYXJzZUZsb2F0KHdpZHRoKSAvLyBTZXQgY2FudmFzIHdpZHRoIGZyb20gU1ZHJ3Mgd2lkdGggYXR0cmlidXRlXHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJzZUZsb2F0KGhlaWdodCkgLy8gU2V0IGNhbnZhcyBoZWlnaHQgZnJvbSBTVkcncyBoZWlnaHQgYXR0cmlidXRlXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcclxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIDY6IENvbnZlcnQgdGhlIGNhbnZhcyB0byBhIFBORyBibG9iXHJcbiAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKHBuZ0Jsb2IpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0ZXAgNzogRG93bmxvYWQgdGhlIFBORyBmaWxlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbmdVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHBuZ0Jsb2IpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5ocmVmID0gcG5nVXJsXHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuZG93bmxvYWQgPSAnZXVyb3N0YXQtbWFwLnBuZydcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKVxyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRMaW5rLmNsaWNrKClcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRMaW5rKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIFVSTHNcclxuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKVxyXG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChwbmdVcmwpXHJcbiAgICAgICAgICAgIH0sICdpbWFnZS9wbmcnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBpbWFnZSBzb3VyY2UgdG8gdGhlIEJsb2IgVVJMXHJcbiAgICAgICAgaW1nLnNyYyA9IHVybFxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSBzb21lIFVSTCBwYXJhbWV0ZXJzLCB3aGljaCBjb3VsZCBiZSB0aGVuIHJldXNlZCBhcyBtYXAgZGVmaW5pdGlvbiBwYXJhbWV0ZXJzLlxyXG4gKiBUaGlzIGFsbG93IGEgcXVpY2sgbWFwIGN1c3RvbWlzYXRpb24gYnkgc2ltcGx5IGFkZGluZyBhbmQgY2hhbmdpbmcgc29tZSBVUkwgcGFyYW1ldGVycy5cclxuICogU2VlIG1hcCBtZXRob2Q6IHNldEZyb21VUkwoLi4uKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFVSTFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBwcyA9IHt9XHJcbiAgICBjb25zdCBwID0gWyd3JywgJ2gnLCAneCcsICd5JywgJ3onLCAncycsICdsdmwnLCAndGltZScsICdwcm9qJywgJ2dlbycsICdueScsICdsYW5ndWFnZScsICdzbCcsICdudW1iZXJPZkNsYXNzZXMnXVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSBwc1twW2ldXSA9IGdldFVSTFBhcmFtZXRlckJ5TmFtZShwW2ldKVxyXG4gICAgcmV0dXJuIHBzXHJcbn1cclxuIiwiLy8gZS5nLiB0byBiZSB1c2VkIHdpdGggZGVwcmVjYXRlZCAuc3R5bGUoKSBmdW5jdGlvbnMuIFRoZXkgd2lsbCBub3cgdXBkYXRlIENTUyBjbGFzc2VzLlxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ1NTUnVsZShzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSB7XHJcbiAgICAvLyBWYWxpZGF0ZSB0aGUgc2VsZWN0b3JcclxuICAgIGlmICghc2VsZWN0b3Iuc3RhcnRzV2l0aCgnLicpICYmICFzZWxlY3Rvci5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3I6IE11c3Qgc3RhcnQgd2l0aCBcIi5cIiBmb3IgY2xhc3NlcyBvciBcIiNcIiBmb3IgSURzLicpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJ1bGUgYWxyZWFkeSBleGlzdHMgaW4gYW55IHN0eWxlc2hlZXRcclxuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5zdHlsZVNoZWV0cylcclxuICAgIGZvciAoY29uc3Qgc3R5bGVTaGVldCBvZiBzdHlsZVNoZWV0cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gc3R5bGVTaGVldC5jc3NSdWxlcyB8fCBzdHlsZVNoZWV0LnJ1bGVzXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JUZXh0ID09PSBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvcGVydHkgaWYgdGhlIHJ1bGUgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBTb21lIHN0eWxlc2hlZXRzIChlLmcuLCBjcm9zcy1vcmlnaW4pIG1heSBub3QgYmUgYWNjZXNzaWJsZVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBhY2Nlc3MgcnVsZXMgaW4gc3R5bGVzaGVldDpgLCBlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgcnVsZSBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYSBuZXcgc3R5bGVzaGVldCBhbmQgYWRkIGl0XHJcbiAgICBsZXQgY3VzdG9tU2hlZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VzdG9tLXN0eWxlcycpXHJcbiAgICBpZiAoIWN1c3RvbVNoZWV0KSB7XHJcbiAgICAgICAgY3VzdG9tU2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXHJcbiAgICAgICAgY3VzdG9tU2hlZXQuaWQgPSAnY3VzdG9tLXN0eWxlcydcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGN1c3RvbVNoZWV0KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0aGUgbmV3IHJ1bGUgdG8gdGhlIGN1c3RvbSBzdHlsZXNoZWV0XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGN1c3RvbVNoZWV0LnNoZWV0Lmluc2VydFJ1bGUoYCR7c2VsZWN0b3J9IHsgJHtwcm9wZXJ0eX06ICR7dmFsdWV9OyB9YCwgY3VzdG9tU2hlZXQuc2hlZXQuY3NzUnVsZXMubGVuZ3RoKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBpbnNlcnQgcnVsZTogJHtzZWxlY3Rvcn0geyAke3Byb3BlcnR5fTogJHt2YWx1ZX07IH1gLCBlKVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Rm9udFNpemVGcm9tQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgY2xhc3NcclxuICAgIGNvbnN0IHRlbXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIHRlbXBFbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxyXG5cclxuICAgIC8vIEFwcGx5IGlubGluZSBzdHlsZXMgdG8gbWluaW1pemUgbGF5b3V0IGludGVyZmVyZW5jZVxyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUud2lkdGggPSAnYXV0bydcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQgPSAnbm9ybWFsJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnaW5pdGlhbCdcclxuXHJcbiAgICAvLyBBcHBlbmQgZGlyZWN0bHkgdG8gdGhlIGJvZHlcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcEVsZW1lbnQpXHJcblxyXG4gICAgLy8gR2V0IHRoZSBjb21wdXRlZCBmb250LXNpemUgcHJvcGVydHkgYW5kIHBhcnNlIGl0IHRvIGEgbnVtYmVyXHJcbiAgICBjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGVtcEVsZW1lbnQpLmZvbnRTaXplKVxyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQgYm9keVxyXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudClcclxuXHJcbiAgICByZXR1cm4gZm9udFNpemUgfHwgMFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBwcm9wZXJ0eU5hbWUpIHtcclxuICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBjbGFzc1xyXG4gICAgY29uc3QgdGVtcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgdGVtcEVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lXHJcblxyXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlcyB0byBtaW5pbWl6ZSBsYXlvdXQgaW50ZXJmZXJlbmNlXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcclxuICAgIHRlbXBFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nXHJcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS53aWR0aCA9ICdhdXRvJ1xyXG4gICAgdGVtcEVsZW1lbnQuc3R5bGUubGluZUhlaWdodCA9ICdub3JtYWwnXHJcblxyXG4gICAgLy8gQXBwZW5kIGRpcmVjdGx5IHRvIHRoZSBib2R5XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBFbGVtZW50KVxyXG5cclxuICAgIC8vIEdldCB0aGUgY29tcHV0ZWQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxyXG4gICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRlbXBFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSlcclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGJvZHlcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQpXHJcblxyXG4gICAgcmV0dXJuIHByb3BlcnR5VmFsdWUgfHwgbnVsbFxyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGFsbCBDU1MgcnVsZXMgZGVmaW5lZCBpbiB0aGUgZG9jdW1lbnRcclxuZnVuY3Rpb24gZ2V0QWxsQ1NTUnVsZXMoKSB7XHJcbiAgICBsZXQgY3NzUnVsZXMgPSBbXVxyXG4gICAgZm9yIChsZXQgc2hlZXQgb2YgZG9jdW1lbnQuc3R5bGVTaGVldHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBTb21lIHN0eWxlc2hlZXRzIG1heSBub3QgYmUgYWNjZXNzaWJsZSBkdWUgdG8gQ09SUywgc28gd2UgY2F0Y2ggYW55IGVycm9yc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIHNoZWV0LmNzc1J1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjc3NSdWxlcy5wdXNoKHJ1bGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGFjY2VzcyBzdHlsZXNoZWV0OicsIHNoZWV0LmhyZWYsIGUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNzc1J1bGVzXHJcbn1cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgZXhwbGljaXRseSBkZWZpbmVkIHN0eWxlcyBmcm9tIENTUyBmb3IgYW4gZWxlbWVudFxyXG5mdW5jdGlvbiBnZXRTdHlsZXNGcm9tQ1NTKGVsZW1lbnQpIHtcclxuICAgIGxldCBtYXRjaGVkUnVsZXMgPSBbXVxyXG4gICAgY29uc3QgY3NzUnVsZXMgPSBnZXRBbGxDU1NSdWxlcygpXHJcblxyXG4gICAgY3NzUnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMocnVsZS5zZWxlY3RvclRleHQpKSB7XHJcbiAgICAgICAgICAgIG1hdGNoZWRSdWxlcy5wdXNoKHJ1bGUuc3R5bGUpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBDcmVhdGUgYW4gb2JqZWN0IG9mIHRoZSBleHBsaWNpdGx5IHNldCBzdHlsZXNcclxuICAgIGxldCBleHBsaWNpdFN0eWxlcyA9IHt9XHJcbiAgICBtYXRjaGVkUnVsZXMuZm9yRWFjaCgoc3R5bGUpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gc3R5bGVbaV1cclxuICAgICAgICAgICAgZXhwbGljaXRTdHlsZXNbcHJvcGVydHldID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSlcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBleHBsaWNpdFN0eWxlc1xyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYXBwbHkgaW5saW5lIHN0eWxlcyBleHBsaWNpdGx5IHNldCBpbiBDU1MuIFVzZWZ1bCBmb3IgZXhwb3J0aW5nIFNWR3Mgd2l0aCBDU1Mgc3R5bGVzLlxyXG5leHBvcnQgY29uc3QgYXBwbHlJbmxpbmVTdHlsZXNGcm9tQ1NTID0gKHN2Z0VsZW1lbnQpID0+IHtcclxuICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gc3ZnRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJylcclxuXHJcbiAgICBhbGxFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3NzU3R5bGVzID0gZ2V0U3R5bGVzRnJvbUNTUyhlbGVtZW50KVxyXG5cclxuICAgICAgICAvLyBBcHBseSBlYWNoIGV4cGxpY2l0bHkgZGVmaW5lZCBDU1Mgc3R5bGUgYXMgYW4gaW5saW5lIHN0eWxlXHJcbiAgICAgICAgT2JqZWN0LmtleXMoY3NzU3R5bGVzKS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNzc1N0eWxlc1twcm9wZXJ0eV1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBwcm9wZXJ0eSBhbHJlYWR5IGhhcyBhbiBpbmxpbmUgc3R5bGVcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJbmxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSlcclxuXHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdJbmxpbmVTdHlsZSAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZXhpc3RpbmcgaW5saW5lIHN0eWxlLCBzZXQgdGhlIG5ldyBzdHlsZVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIEdlb0pTT04gZmVhdHVyZSByZXByZXNlbnRpbmcgYSBib3VuZGluZyBib3gsIHdpdGggbXVsdGlwb2ludCBnZW9tZXRyeS5cclxuICogVGhpcyBib3VuZGluZyBib3ggaXMgYW4gYXJyYXkgbGlrZSB0aGUgb25lIGluIHRvcG9qc29uIGJib3ggZWxlbWVudC5cclxuICogW3htaW4seW1pbix4bWF4LHltYXhdXHJcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciB0byBjYWxsIGQzLmZpdFNpemUoW3csIGhdLCBnZXRUb3BvSlNPTkV4dGVudEFzR2VvSlNPTih0b3BvLmJib3gpKSlcclxuICpcclxuICogQHBhcmFtIHsqfSBiYiBUaGUgYm91bmRpbmcgYm94IFt4bWluLHltaW4seG1heCx5bWF4XS4gRm9yIHRvcG9qc29uIGRhdGEsIGp1c3QgZ2l2ZSB0aGUgdG9wb2pzb24uYmJveCBlbGVtZW50LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEJCT1hBc0dlb0pTT04gPSBmdW5jdGlvbiAoYmIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxyXG4gICAgICAgIGdlb21ldHJ5OiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdNdWx0aVBvaW50JyxcclxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcclxuICAgICAgICAgICAgICAgIFtiYlswXSwgYmJbMV1dLFxyXG4gICAgICAgICAgICAgICAgW2JiWzJdLCBiYlszXV0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgfSxcclxuICAgIH1cclxufVxyXG5cclxuLy8gaW5kZXhpbmdcclxuXHJcbi8qKlxyXG4gKiBJbmRleCBKU09OU3RhdCBzdGF0IHZhbHVlcyBieSAnZ2VvJyBjb2RlLlxyXG4gKiBSZXR1cm4gYSBzdHJ1Y3R1cmUgbGlrZToge2dlbzp7dmFsdWU6MCxzdGF0dXM6XCJcIn19XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0ganNEYXRhIFRoZSBKU09OU3RhdCBkYXRhIHRvIGluZGV4XHJcbiAqL1xyXG5leHBvcnQgY29uc3QganNvbnN0YXRUb0luZGV4ID0gZnVuY3Rpb24gKGpzRGF0YSkge1xyXG4gICAgY29uc3QgaW5kID0ge31cclxuICAgIGNvbnN0IGdlb3MgPSBqc0RhdGEuRGltZW5zaW9uKCdnZW8nKS5pZFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9zLmxlbmd0aDsgaSsrKSBpbmRbZ2Vvc1tpXV0gPSBqc0RhdGEuRGF0YShpKVxyXG4gICAgcmV0dXJuIGluZFxyXG59XHJcblxyXG4vKipcclxuICogSW5kZXggQ1NWIHN0YXQgdmFsdWVzIGJ5ICdnZW8nIGNvZGUuXHJcbiAqIFJldHVybiBhIHN0cnVjdHVyZSBsaWtlOiB7Z2VvOnt2YWx1ZTowLHN0YXR1czpcIlwifX1cclxuICpcclxuICogQHBhcmFtIHsqfSBjc3ZEYXRhIFRoZSBDU1YgZGF0YSB0byBpbmRleFxyXG4gKiBAcGFyYW0geyp9IGdlb0NvbCBUaGUgbmFtZSBvZiB0aGUgZ2VvIGNvbHVtbiBpbiB0aGUgQ1NWIGRhdGFcclxuICogQHBhcmFtIHsqfSB2YWx1ZUNvbCBUaGUgbmFtZSBvZiB0aGUgc3RhdGlzdGljYWwgdmFsdWUgY29sdW1uIGluIHRoZSBDU1YgZmlsZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjc3ZUb0luZGV4ID0gZnVuY3Rpb24gKGNzdkRhdGEsIGdlb0NvbCwgdmFsdWVDb2wpIHtcclxuICAgIGNvbnN0IGluZCA9IHt9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzdkRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkID0gY3N2RGF0YVtpXVxyXG4gICAgICAgIGNvbnN0IHYgPSBkW3ZhbHVlQ29sXVxyXG4gICAgICAgIGlmICghdikge1xyXG4gICAgICAgICAgICBpbmRbZFtnZW9Db2xdXSA9IHsgdmFsdWU6ICc6Jywgc3RhdHVzOiAnJyB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5kW2RbZ2VvQ29sXV0gPSB7IHZhbHVlOiBpc05hTigrdikgPyB2IDogK3YsIHN0YXR1czogJycgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpbmRcclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHN0cmluZyB3aXRoIHNwYWNlIGFzIHRob3VzYW5kIHNlcGFyYXRvclxyXG4gKiBAZnVuY3Rpb24gc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IgPSBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICByZXR1cm4gbnVtYmVyLnRvTG9jYWxlU3RyaW5nKCdlbicpLnJlcGxhY2UoLywvZ2ksICcgJylcclxufVxyXG5cclxuLy9SRVNUIEFQSVxyXG5leHBvcnQgY29uc3QgZ2V0RXN0YXRSZXN0RGF0YVVSTEJhc2UgPSAnaHR0cHM6Ly9lYy5ldXJvcGEuZXUvZXVyb3N0YXQvYXBpL2Rpc3NlbWluYXRpb24vc3RhdGlzdGljcy8xLjAvZGF0YS8nXHJcblxyXG4vKipcclxuICogQnVpbGQgVVJMIHRvIGZldGNoIGRhdGEgZnJvbSBldXJvYmFzZSBSRVNUIEFQSS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRDb2RlIFRoZSBFdXJvYmFzZSBkYXRhc2V0IGNvZGVcclxuICogQHBhcmFtIHtvYmplY3Q9fSBmaWx0ZXJzIFRoZSBmaWx0ZXIgcGFyYW1ldGVycyBhcyBmb3IgZXhhbXBsZToge2tleTp2YWx1ZSxrZXk6W3ZhbHVlMSx2YWx1ZTIsdmFsdWUzXX1cclxuICogQHBhcmFtIHtudW1iZXI9fSBsYW5nXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZm9ybWF0XHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gdmVyc2lvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEVzdGF0RGF0YVVSTCA9IGZ1bmN0aW9uIChkYXRhc2V0Q29kZSwgZmlsdGVycywgbGFuZywgZm9ybWF0KSB7XHJcbiAgICBsYW5nID0gbGFuZyB8fCAnZW4nXHJcbiAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJ2pzb24nXHJcbiAgICB2YXIgdXJsID0gW11cclxuICAgIHVybC5wdXNoKGdldEVzdGF0UmVzdERhdGFVUkxCYXNlLCBkYXRhc2V0Q29kZSwgJz8nLCAnZm9ybWF0PScsIGZvcm1hdCwgJyZsYW5nPScsIGxhbmcpXHJcbiAgICBpZiAoZmlsdGVycylcclxuICAgICAgICBmb3IgKHZhciBwYXJhbSBpbiBmaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gZmlsdGVyc1twYXJhbV1cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykpIGZvciAodmFyIGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykgdXJsLnB1c2goJyYnLCBwYXJhbSwgJz0nLCBvW2ldKVxyXG4gICAgICAgICAgICBlbHNlIHVybC5wdXNoKCcmJywgcGFyYW0sICc9JywgbylcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdXJsLmpvaW4oJycpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFVSTFBhcmFtZXRlckJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dLywgJ1xcXFxdJylcclxuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIG5hbWUgKyAnPShbXiYjXSopJyksXHJcbiAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWMobG9jYXRpb24uc2VhcmNoKVxyXG4gICAgcmV0dXJuICFyZXN1bHRzID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHRzWzFdLnJlcGxhY2UoL1xcKy9nLCAnICcpKVxyXG59XHJcblxyXG4vL2ZsYWdzXHJcbmV4cG9ydCBjb25zdCBmbGFncyA9IHtcclxuICAgIGI6ICdicmVhayBpbiB0aW1lIHNlcmllcycsXHJcbiAgICBjOiAnY29uZmlkZW50aWFsJyxcclxuICAgIGQ6ICdkZWZpbml0aW9uIGRpZmZlcnMsIHNlZSBtZXRhZGF0YScsXHJcbiAgICBlOiAnZXN0aW1hdGVkJyxcclxuICAgIGY6ICdmb3JlY2FzdCcsXHJcbiAgICBuOiAnbm90IHNpZ25pZmljYW50JyxcclxuICAgIHA6ICdwcm92aXNpb25hbCcsXHJcbiAgICByOiAncmV2aXNlZCcsXHJcbiAgICBzOiAnRXVyb3N0YXQgZXN0aW1hdGUnLFxyXG4gICAgdTogJ2xvdyByZWxpYWJpbGl0eScsXHJcbiAgICB6OiAnbm90IGFwcGxpY2FibGUnLFxyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uIEV4ZWN1dGVzIGEgZnVuY3Rpb24gZm9yIGFsbCBpbnNldCBtYXBzLiBTb21lIGluc2V0cyBtaWdodCBiZSBleHRlcm5hbCBTVkdzIHdoaWNoIGlzIHdoeSB0aGlzIGZ1bmN0aW9uIHdhcyBjcmVhdGVkLlxyXG4gKiBAcGFyYW0geyp9IGluc2V0cyBtYXAuaW5zZXRzXHJcbiAqIEBwYXJhbSB7Kn0gbWFpblN2Z0lkIHRoZSBJRCBvZiB0aGUgbWFwJ3Mgc3ZnXHJcbiAqIEBwYXJhbSB7Kn0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggaW5zZXRcclxuICogQHBhcmFtIHsqfSBbcGFyYW1ldGVyPW51bGxdIHRoZSBwYXJhbWV0ZXIgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tcclxuICogQHBhcmFtIHsqfSBbcGFyYW1ldGVyMj1udWxsXSB0aGUgcGFyYW1ldGVyIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZXhlY3V0ZUZvckFsbEluc2V0cyA9IGZ1bmN0aW9uIChpbnNldHMsIG1haW5TdmdJZCwgY2FsbGJhY2ssIHBhcmFtZXRlciA9IG51bGwsIHBhcmFtZXRlcjIgPSBudWxsKSB7XHJcbiAgICBmb3IgKGNvbnN0IGdlbyBpbiBpbnNldHMpIHtcclxuICAgICAgICBjb25zdCBpbnNldEdyb3VwID0gaW5zZXRzW2dlb11cclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zZXRHcm91cCkpIHtcclxuICAgICAgICAgICAgaW5zZXRHcm91cC5mb3JFYWNoKChpbnNldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCBhcnJheXMgZm9yIG11bHRpcGxlIGluc2V0cyB3aXRoIHRoZSBzYW1lIGdlb1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXQuZm9yRWFjaCgobmVzdGVkSW5zZXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZEluc2V0LnN2Z0lkXyAhPT0gbWFpblN2Z0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXN0ZWRJbnNldCwgcGFyYW1ldGVyLCBwYXJhbWV0ZXIyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2V0LnN2Z0lkXyAhPT0gbWFpblN2Z0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc2V0LCBwYXJhbWV0ZXIsIHBhcmFtZXRlcjIpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNhbGxiYWNrIHRvIHVuaXF1ZSBpbnNldFxyXG4gICAgICAgICAgICBpZiAoaW5zZXRHcm91cC5zdmdJZF8gIT09IG1haW5TdmdJZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaW5zZXRHcm91cCwgcGFyYW1ldGVyLCBwYXJhbWV0ZXIyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdXBwZXJDYXNlRmlyc3RMZXR0ZXIgPSAoc3RyaW5nKSA9PiBgJHtzdHJpbmcuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKX0ke3N0cmluZy5zbGljZSgxKX1gXHJcblxyXG5leHBvcnQgY29uc3QgbG93ZXJDYXNlQWxsV29yZHNFeGNlcHRGaXJzdExldHRlcnMgPSAoc3RyaW5nKSA9PlxyXG4gICAgc3RyaW5nLnJlcGxhY2VBbGwoL1xcUyovZywgKHdvcmQpID0+IGAke3dvcmQuc2xpY2UoMCwgMSl9JHt3b3JkLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCl9YClcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREb3dubG9hZFVSTChzdmdOb2RlKSB7XHJcbiAgICAvLyBDcmVhdGUgWE1MIGhlYWRlciB0byBlbnN1cmUgdGhlIFNWRyBpcyByZWNvZ25pemVkIHByb3Blcmx5XHJcbiAgICBjb25zdCB4bWxIZWFkZXIgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwibm9cIj8+XFxuJ1xyXG5cclxuICAgIC8vIGNyZWF0ZSBibG9iXHJcbiAgICBjb25zdCBzdmdDb250ZW50ID0geG1sSGVhZGVyICsgc3ZnTm9kZS5vdXRlckhUTUxcclxuICAgIGNvbnN0IHN2Z0Jsb2IgPSBuZXcgQmxvYihbc3ZnQ29udGVudF0sIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCcgfSlcclxuICAgIGNvbnN0IHN2Z1VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3ZnQmxvYilcclxuICAgIHJldHVybiBzdmdVcmxcclxufVxyXG5cclxuLy8gUmFzdGVyaXplIGZ1bmN0aW9uIHdpdGggYWRkaXRpb25hbCBlcnJvciBoYW5kbGluZ1xyXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHN2Zykge1xyXG4gICAgY29uc3QgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXHJcbiAgICBjb25zdCB4bGlua25zID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXHJcbiAgICBjb25zdCBzdmducyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcclxuICAgIGNvbnN0IGZyYWdtZW50ID0gd2luZG93LmxvY2F0aW9uLmhyZWYgKyAnIydcclxuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoc3ZnLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgbnVsbCwgZmFsc2UpXHJcbiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2Ygd2Fsa2VyLmN1cnJlbnROb2RlLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUuaW5jbHVkZXMoZnJhZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyLnZhbHVlID0gYXR0ci52YWx1ZS5yZXBsYWNlKGZyYWdtZW50LCAnIycpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdmcuc2V0QXR0cmlidXRlTlMoeG1sbnMsICd4bWxucycsIHN2Z25zKVxyXG4gICAgc3ZnLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCAneG1sbnM6eGxpbmsnLCB4bGlua25zKVxyXG4gICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyB3aW5kb3cuWE1MU2VyaWFsaXplcigpXHJcbiAgICBjb25zdCBzdHJpbmcgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN2ZylcclxuICAgIHJldHVybiBuZXcgQmxvYihbc3RyaW5nXSwgeyB0eXBlOiAnaW1hZ2Uvc3ZnK3htbCcgfSlcclxufVxyXG5cclxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svc2F2aW5nLXN2XHJcbi8vc3ZnIHRvIGNhbnZhcyBibG9iIHByb21pc2VcclxuZXhwb3J0IGZ1bmN0aW9uIHJhc3Rlcml6ZShzdmcpIHtcclxuICAgIGxldCByZXNvbHZlLCByZWplY3RcclxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoeSwgbikgPT4gKChyZXNvbHZlID0geSksIChyZWplY3QgPSBuKSkpXHJcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpXHJcbiAgICBpbWFnZS5vbmVycm9yID0gcmVqZWN0XHJcbiAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVjdCA9IHN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodFxyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodClcclxuICAgICAgICBjb250ZXh0LmNhbnZhcy50b0Jsb2IocmVzb2x2ZSlcclxuICAgIH1cclxuICAgIGltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc2VyaWFsaXplKHN2ZykpXHJcbiAgICByZXR1cm4gcHJvbWlzZVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgVVJMIHBhcmFtZXRlciBieSBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJCeU5hbWUobmFtZSkge1xyXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpXHJcbiAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKCdbXFxcXD8mXScgKyBuYW1lICsgJz0oW14mI10qKScpLFxyXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKGxvY2F0aW9uLnNlYXJjaClcclxuICAgIHJldHVybiAhcmVzdWx0cyA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGhleFRvUmdiID0gKGhleCkgPT4ge1xyXG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoJyMnLCAnJylcclxuICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgaGV4ID0gaGV4XHJcbiAgICAgICAgICAgIC5zcGxpdCgnJylcclxuICAgICAgICAgICAgLm1hcCgoaCkgPT4gaCArIGgpXHJcbiAgICAgICAgICAgIC5qb2luKCcnKVxyXG4gICAgfVxyXG4gICAgY29uc3QgaW50ID0gcGFyc2VJbnQoaGV4LCAxNilcclxuICAgIHJldHVybiBbKGludCA+PiAxNikgJiAyNTUsIChpbnQgPj4gOCkgJiAyNTUsIGludCAmIDI1NV1cclxufVxyXG5cclxuLy9ibGVuZHMgdHdvIGNvbG9ycyB1c2luZyAnbXVsdGlwbHknIGJsZW5kaW5nIG1vZGUuIFJldHVybnMgdGhlIGJsZW5kZWQgY29sb3IgYXMgYW4gUkdCIHN0cmluZ1xyXG5leHBvcnQgY29uc3QgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4ID0gKGNvbG9ycykgPT4ge1xyXG4gICAgLy8gQ29udmVydCBoZXggY29sb3IgdG8gUkdCXHJcbiAgICBjb25zdCBoZXhUb1JnYiA9IChoZXgpID0+IHtcclxuICAgICAgICBoZXggPSBoZXgucmVwbGFjZSgnIycsICcnKVxyXG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIGhleCA9IGhleFxyXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoaCkgPT4gaCArIGgpXHJcbiAgICAgICAgICAgICAgICAuam9pbignJylcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW50ID0gcGFyc2VJbnQoaGV4LCAxNilcclxuICAgICAgICByZXR1cm4gWyhpbnQgPj4gMTYpICYgMjU1LCAoaW50ID4+IDgpICYgMjU1LCBpbnQgJiAyNTVdXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCBSR0IgdG8gaGV4XHJcbiAgICBjb25zdCByZ2JUb0hleCA9IChbciwgZywgYl0pID0+IGAjJHtbciwgZywgYl0ubWFwKChjKSA9PiBjLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKX1gXHJcblxyXG4gICAgLy8gQ29udmVydCBhbGwgaGV4IGNvbG9ycyB0byBSR0IgYXJyYXlzXHJcbiAgICBjb25zdCByZ2JDb2xvcnMgPSBjb2xvcnMubWFwKGhleFRvUmdiKVxyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc3VsdCB3aXRoIHRoZSBmaXJzdCBjb2xvclxyXG4gICAgbGV0IGJsZW5kZWQgPSBbLi4ucmdiQ29sb3JzWzBdXVxyXG5cclxuICAgIC8vIFNlcXVlbnRpYWxseSBtdWx0aXBseSBlYWNoIGNvbG9yIHdpdGggdGhlIHJlc3VsdFxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZ2JDb2xvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBibGVuZGVkID0gYmxlbmRlZC5tYXAoKHYsIGlkeCkgPT4gTWF0aC5yb3VuZCgodiAvIDI1NSkgKiAocmdiQ29sb3JzW2ldW2lkeF0gLyAyNTUpICogMjU1KSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIGJsZW5kZWQgY29sb3IgYXMgYSBoZXggY29kZVxyXG4gICAgcmV0dXJuIHJnYlRvSGV4KGJsZW5kZWQpXHJcbn1cclxuXHJcbi8vIGNvbnZlcnQgcmVjdCBhdHRyaWJ1dGVzIGludG8gYW4gU1ZHIHBhdGggc3RyaW5nXHJcbi8vIHVzZWQgZm9yIHdvcmthcm91bmQgd2hlcmVieSBjbGlwUGF0aHMgd2hpY2ggdXNlIHJlY3QgZWxlbWVudHMgZG8gbm90IHdvcmsgaW4gYWRvYmUgaWxsdXN0cmF0b3JcclxuZXhwb3J0IGNvbnN0IGNvbnZlcnRSZWN0YW5nbGVzVG9QYXRocyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoeCwgMTApXHJcbiAgICB2YXIgeSA9IHBhcnNlRmxvYXQoeSwgMTApXHJcbiAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KHdpZHRoLCAxMClcclxuICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KGhlaWdodCwgMTApXHJcblxyXG4gICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcnXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICdNJyArIHggKyAnLCcgKyB5ICsgJ0wnICsgKHggKyB3aWR0aCkgKyAnLCcgKyB5ICsgJyAnICsgKHggKyB3aWR0aCkgKyAnLCcgKyAoeSArIGhlaWdodCkgKyAnICcgKyB4ICsgJywnICsgKHkgKyBoZWlnaHQpICsgJ3onXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKGJhY2tncm91bmRDb2xvcikge1xyXG4gICAgbGV0IHIsIGcsIGJcclxuXHJcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZWxlbWVudCB0byBoYW5kbGUgbmFtZWQgY29sb3JzXHJcbiAgICBpZiAoIWJhY2tncm91bmRDb2xvci5zdGFydHNXaXRoKCdyZ2InKSAmJiAhYmFja2dyb3VuZENvbG9yLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgICAgIHRlbXBEaXYuc3R5bGUuY29sb3IgPSBiYWNrZ3JvdW5kQ29sb3JcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBEaXYpXHJcbiAgICAgICAgY29uc3QgY29tcHV0ZWRDb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRlbXBEaXYpLmNvbG9yXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wRGl2KVxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvciA9IGNvbXB1dGVkQ29sb3IgLy8gQ29udmVydCBuYW1lZCBjb2xvciB0byBSR0JcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgaGV4IGNvbG9ycyBsaWtlICcjRkZGRkZGJyBvciAnI0ZGRidcclxuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3Iuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgbGV0IGhleCA9IGJhY2tncm91bmRDb2xvci5yZXBsYWNlKCcjJywgJycpXHJcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICAgICAgaGV4ID0gaGV4XHJcbiAgICAgICAgICAgICAgICAuc3BsaXQoJycpXHJcbiAgICAgICAgICAgICAgICAubWFwKChjKSA9PiBjICsgYylcclxuICAgICAgICAgICAgICAgIC5qb2luKCcnKVxyXG4gICAgICAgIH1cclxuICAgICAgICByID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygwLCAyKSwgMTYpXHJcbiAgICAgICAgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KVxyXG4gICAgICAgIGIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDQsIDYpLCAxNilcclxuICAgIH1cclxuICAgIC8vIEhhbmRsZSBSR0IgY29sb3JzIGxpa2UgJ3JnYigyNTUsMjU1LDI1NSknXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCByZ2IgPSBiYWNrZ3JvdW5kQ29sb3IubWF0Y2goL1xcZCsvZylcclxuICAgICAgICByID0gcGFyc2VJbnQocmdiWzBdKVxyXG4gICAgICAgIGcgPSBwYXJzZUludChyZ2JbMV0pXHJcbiAgICAgICAgYiA9IHBhcnNlSW50KHJnYlsyXSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgbHVtaW5hbmNlXHJcbiAgICBjb25zdCBsdW1pbmFuY2UgPSAwLjIxMjYgKiAociAvIDI1NSkgKyAwLjcxNTIgKiAoZyAvIDI1NSkgKyAwLjA3MjIgKiAoYiAvIDI1NSlcclxuXHJcbiAgICAvLyBSZXR1cm4gYmxhY2sgZm9yIGxpZ2h0IGJhY2tncm91bmRzLCB3aGl0ZSBmb3IgZGFyayBiYWNrZ3JvdW5kc1xyXG4gICAgcmV0dXJuIGx1bWluYW5jZSA+IDAuNSA/ICdibGFjaycgOiAnd2hpdGUnXHJcbn1cclxuXHJcbi8vIGdldCBjc3Mgc2VsZWN0b3IuIERpZmZlcmVudCBtYXBzIGhhdmUgZGlmZmVyZW50IHNlbGVjdG9ycyBmb3IgdGhlaXIgcmVnaW9ucy5cclxuZXhwb3J0IGNvbnN0IGdldFJlZ2lvbnNTZWxlY3RvciA9IChtYXApID0+IHtcclxuICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgcmV0dXJuICcjZW0tdXNlci1yZWdpb25zIHBhdGgnXHJcbiAgICBpZiAobWFwLmdyaWRDYXJ0b2dyYW1fKSByZXR1cm4gJyNlbS1ncmlkLWNvbnRhaW5lciAuZW0tZ3JpZC1jZWxsJ1xyXG4gICAgaWYgKG1hcC5nZW9fID09PSAnV09STEQnKSByZXR1cm4gJyNlbS13b3JsZHJnIHBhdGgnXHJcbiAgICByZXR1cm4gJyNlbS1udXRzcmcgcGF0aDpub3QoI2VtLWNudHJnLVJTKTpub3QoI2VtLWNudHJnLUVMKSwgI2VtLWNudHJnIHBhdGg6bm90KCNlbS1jbnRyZy1SUyk6bm90KCNlbS1jbnRyZy1FTCknXHJcbn1cclxuXHJcbi8vIGdldCBjc3Mgc2VsZWN0b3IgZm9yIGxlZ2VuZCBtb3VzZSBob3Zlci4gRGlmZmVyZW50IG1hcHMgaGF2ZSBkaWZmZXJlbnQgc2VsZWN0b3JzIGZvciB0aGVpciByZWdpb25zXHJcbmV4cG9ydCBjb25zdCBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IgPSAobWFwKSA9PiB7XHJcbiAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHJldHVybiAnI2VtLXVzZXItcmVnaW9ucydcclxuICAgIGlmIChtYXAuZ3JpZENhcnRvZ3JhbV8pIHJldHVybiAnI2VtLWdyaWQtY29udGFpbmVyJ1xyXG4gICAgaWYgKG1hcC5nZW9fID09PSAnV09STEQnKSByZXR1cm4gJyNlbS13b3JsZHJnJ1xyXG4gICAgcmV0dXJuICcjZW0tbnV0c3JnLCAjZW0tY250cmcnXHJcbn1cclxuIiwiaW1wb3J0ICogYXMgQ2hvcm9wbGV0aCBmcm9tICcuL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoJ1xyXG5pbXBvcnQgKiBhcyBQcm9wb3J0aW9uYWxTeW1ib2wgZnJvbSAnLi9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMnXHJcbmltcG9ydCAqIGFzIENhdGVnb3JpY2FsIGZyb20gJy4vbWFwdHlwZXMvbWFwLWNhdGVnb3JpY2FsJ1xyXG5pbXBvcnQgKiBhcyBCaXZhcmlhdGVDaG9yb3BsZXRoIGZyb20gJy4vbWFwdHlwZXMvbWFwLWNob3JvcGxldGgtYml2YXJpYXRlJ1xyXG5pbXBvcnQgKiBhcyBUcml2YXJpYXRlQ2hvcm9wbGV0aCBmcm9tICcuL21hcHR5cGVzL21hcC1jaG9yb3BsZXRoLXRyaXZhcmlhdGUnXHJcbmltcG9ydCAqIGFzIFN0cmlwZUNvbXBvc2l0aW9uIGZyb20gJy4vbWFwdHlwZXMvbWFwLXN0cmlwZS1jb21wb3NpdGlvbidcclxuaW1wb3J0ICogYXMgUGllQ2hhcnRzIGZyb20gJy4vbWFwdHlwZXMvbWFwLXBpZWNoYXJ0cydcclxuaW1wb3J0ICogYXMgU3BhcmtsaW5lcyBmcm9tICcuL21hcHR5cGVzL21hcC1zcGFya2xpbmVzJ1xyXG5pbXBvcnQgKiBhcyBGbG93TWFwIGZyb20gJy4vbWFwdHlwZXMvbWFwLWZsb3cnXHJcbmltcG9ydCAqIGFzIG10IGZyb20gJy4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0IHsgREVGQVVMVExBQkVMUyB9IGZyb20gJy4vY29yZS9sYWJlbHMnXHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGEgZXVyb3N0YXQtbWFwIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHsqfSB0eXBlIFRoZSB0eXBlIG9mIG1hcCAoJ2NoJyBmb3IgY2hvcm9wbGV0aCwgZXRjLilcclxuICogQHBhcmFtIHsqfSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBFeC46IHsgdGl0bGU6IFwiTWFwIHRpdGxlXCIsIGdlb0NlbnRlcjogWzIzMyw2NTRdLCAuLi59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZykge1xyXG4gICAgLy9jaG9yb3BsZXRoIG1hcFxyXG4gICAgaWYgKHR5cGUgPT0gJ2Nob3JvcGxldGgnIHx8IHR5cGUgPT0gJ2NoJykgcmV0dXJuIENob3JvcGxldGgubWFwKGNvbmZpZylcclxuICAgIC8vY2F0ZWdvcmljYWwgbWFwXHJcbiAgICBpZiAodHlwZSA9PSAnY2F0ZWdvcmljYWwnIHx8IHR5cGUgPT0gJ2N0JykgcmV0dXJuIENhdGVnb3JpY2FsLm1hcChjb25maWcpXHJcbiAgICAvL3Byb3BvcnRpb25uYWwgc3ltYm9scyBtYXBcclxuICAgIGlmICh0eXBlID09ICdwcm9wb3J0aW9uYWxTeW1ib2wnIHx8IHR5cGUgPT0gJ3BzJykgcmV0dXJuIFByb3BvcnRpb25hbFN5bWJvbC5tYXAoY29uZmlnKVxyXG4gICAgLy9iaXZhcmlhdGUgY2hvcm9wbGV0aFxyXG4gICAgaWYgKHR5cGUgPT0gJ2JpdmFyaWF0ZUNob3JvcGxldGgnIHx8IHR5cGUgPT0gJ2NoYmknKSByZXR1cm4gQml2YXJpYXRlQ2hvcm9wbGV0aC5tYXAoY29uZmlnKVxyXG4gICAgLy90cml2YXJpYXRlIGNob3JvcGxldGhcclxuICAgIGlmICh0eXBlID09ICd0cml2YXJpYXRlQ2hvcm9wbGV0aCcgfHwgdHlwZSA9PSAnY2hiaScpIHJldHVybiBUcml2YXJpYXRlQ2hvcm9wbGV0aC5tYXAoY29uZmlnKVxyXG4gICAgLy9zdHJpcGVzIGNvbXBvc2l0aW9uXHJcbiAgICBpZiAodHlwZSA9PSAnc3RyaXBlQ29tcG9zaXRpb24nIHx8IHR5cGUgPT0gJ3Njb21wJykgcmV0dXJuIFN0cmlwZUNvbXBvc2l0aW9uLm1hcChjb25maWcpXHJcbiAgICAvL3Byb3BvcnRpb25hbCBwaWUgY2hhcnRzXHJcbiAgICBpZiAodHlwZSA9PSAncGllQ2hhcnQnIHx8IHR5cGUgPT0gJ3BpZScpIHJldHVybiBQaWVDaGFydHMubWFwKGNvbmZpZylcclxuICAgIC8vc3BhcmtsaW5lIG1hcHNcclxuICAgIGlmICh0eXBlID09ICdzcGFya2xpbmUnIHx8IHR5cGUgPT0gJ3NwYXJrJyB8fCB0eXBlID09ICdzcGFya2xpbmVzJykgcmV0dXJuIFNwYXJrbGluZXMubWFwKGNvbmZpZylcclxuICAgIC8vZmxvdyBtYXBzXHJcbiAgICBpZiAodHlwZSA9PSAnZmxvdycgfHwgdHlwZSA9PSAnZmxvd21hcCcpIHJldHVybiBGbG93TWFwLm1hcChjb25maWcpXHJcblxyXG4gICAgLy9hZGQgbmV3IG1hcCB0eXBlcyBoZXJlXHJcbiAgICAvL2lmKHR5cGUgPT0gXCJYWFwiKSByZXR1cm4gbWFwWFgubWFwKGNvbmZpZyk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ1VuZXhwZWN0ZWQgbWFwIHR5cGU6ICcgKyB0eXBlKVxyXG4gICAgcmV0dXJuIG10LnN0YXRNYXAoY29uZmlnLCB0cnVlLCB0eXBlKVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggYnVpbGRzIGZpbGwgcGF0dGVybnMgc3R5bGUuXHJcbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBoYXMgZm9yIGFyZ3VtZW50cyB0aGUgU1ZHIGVsZW1lbnQgd2hlcmUgdG8gdXNlIHRoZSBmaWxsIHBhdHRlcm4sIGFuZCB0aGUgbnVtYmVyIG9mIGNsYXNzZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gb3B0cyBWYXJpb3VzIHBhcmFtZXRlcnMgb24gdGhlIGZpbGwgcGF0dGVybi5cclxuICogQHJldHVybnMge2Z1bmN0aW9ufVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldEZpbGxQYXR0ZXJuRGVmaW5pdGlvbkZ1bmN0aW9uID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcbiAgICBvcHRzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAnY2lyY2xlJ1xyXG4gICAgY29uc3QgcHMgPSBvcHRzLnBhdHRlcm5TaXplIHx8IDVcclxuICAgIGNvbnN0IHNtaW4gPSBvcHRzLm1pblNpemUgfHwgMVxyXG4gICAgY29uc3Qgc21heCA9IG9wdHMubWF4U2l6ZSB8fCA1LjVcclxuICAgIG9wdHMuYmNrQ29sb3IgPSBvcHRzLmJja0NvbG9yIHx8ICd3aGl0ZSdcclxuICAgIG9wdHMuc3ltYkNvbG9yID0gb3B0cy5zeW1iQ29sb3IgfHwgJ2JsYWNrJ1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdmcsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgIC8vY2xlYXIgcHJldmlvdXNcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcuZW0tZmlsbC1wYXR0ZXJuJykucmVtb3ZlKClcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2xhc3NlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpID0gc21pbiArICgoc21heCAtIHNtaW4pICogaSkgLyAobnVtYmVyT2ZDbGFzc2VzIC0gMSlcclxuICAgICAgICAgICAgY29uc3QgcGF0dCA9IHN2Z1xyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZmlsbC1wYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdwYXR0ZXJuXycgKyBpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAnMCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsICcwJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHBzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHBzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BhdHRlcm5Vbml0cycsICd1c2VyU3BhY2VPblVzZScpXHJcbiAgICAgICAgICAgIHBhdHQuYXBwZW5kKCdyZWN0JykuYXR0cigneCcsIDApLmF0dHIoJ3knLCAwKS5hdHRyKCd3aWR0aCcsIHBzKS5hdHRyKCdoZWlnaHQnLCBwcykuc3R5bGUoJ3N0cm9rZScsICdub25lJykuc3R5bGUoJ2ZpbGwnLCBvcHRzLmJja0NvbG9yKVxyXG4gICAgICAgICAgICBpZiAob3B0cy5zaGFwZSA9PSAnc3F1YXJlJylcclxuICAgICAgICAgICAgICAgIHBhdHQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHNpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBzaSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBvcHRzLnN5bWJDb2xvcilcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcGF0dC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgcHMgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgcHMgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBzaSAqIDAuNSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBvcHRzLnN5bWJDb2xvcilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0TGFiZWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIERFRkFVTFRMQUJFTFNcclxufVxyXG5cclxuaW1wb3J0IHsgdmVyc2lvbiBhcyBwa2dWZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJ1xyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IHBrZ1ZlcnNpb25cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IGV4ZWN1dGVGb3JBbGxJbnNldHMgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBhcHBlbmRQYXR0ZXJuRmlsbExlZ2VuZCB9IGZyb20gJy4vbGVnZW5kLXBhdHRlcm4tZmlsbCdcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgY2F0ZWdvcmljYWwgbWFwc1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG1hcFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXAsIGNvbmZpZykge1xyXG4gICAgLy9idWlsZCBnZW5lcmljIGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBtYXBcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVXaWR0aCA9IDEzXHJcbiAgICAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZUhlaWdodCA9IDE1XHJcbiAgICAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZVBhZGRpbmcgPSA1XHJcbiAgICAvL3RoZSBmb250IHNpemUgb2YgdGhlIGxlZ2VuZCBsYWJlbFxyXG4gICAgb3V0LmxhYmVsRm9udFNpemUgPSAxMlxyXG4gICAgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubGFiZWxPZmZzZXQgPSA1XHJcbiAgICAvL3Nob3cgbm8gZGF0YVxyXG4gICAgb3V0Lm5vRGF0YSA9IHRydWVcclxuICAgIC8vbm8gZGF0YSBsYWJlbCB0ZXh0XHJcbiAgICBvdXQubm9EYXRhVGV4dCA9ICdObyBkYXRhJ1xyXG4gICAgLy8gYWxsb3cgdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiB0aGUgbGVnZW5kIGVsZW1lbnRzIG1hbnVhbGx5IGFzIGFuIGFycmF5XHJcbiAgICBvdXQub3JkZXIgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKSBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGlmIChvdXQubGdnLm5vZGUoKSAmJiBvdXQubWFwLmNsYXNzaWZpZXJfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gb3V0LmxnZ1xyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgICAgICBvdXQubWFrZUJhY2tncm91bmRCb3goKVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgICAgIGlmIChvdXQudGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KG91dC50aXRsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgY2F0ZWdvcnkgY29kZXNcclxuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gbWFwLmNsYXNzVG9GaWxsU3R5bGUoKSA/IE9iamVjdC5rZXlzKG1hcC5jbGFzc1RvRmlsbFN0eWxlKCkpIDogbWFwLmNsYXNzaWZpZXJfLmRvbWFpbigpXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbHMgPSBvdXQub3JkZXIgPyBvdXQub3JkZXIgOiBkb21haW5cclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBsZWdlbmQgZWxlbWVudHMgZm9yIGNsYXNzZXM6IHJlY3RhbmdsZSArIGxhYmVsXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWNscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy90aGUgY2xhc3NcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbF8gPSBlY2xzW2ldXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBtYXAuY2xhc3NpZmllcl8oZWNsXylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxDb2xvciA9IG1hcC5jbGFzc1RvRmlsbFN0eWxlX1tlY2xfXVxyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArIGkgKiAob3V0LnNoYXBlSGVpZ2h0ICsgb3V0LnNoYXBlUGFkZGluZylcclxuXHJcbiAgICAgICAgICAgICAgICAvL3JlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZpbGxDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIHVuaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAvL2xhYmVsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQobWFwLmNsYXNzVG9UZXh0KCkgPyBtYXAuY2xhc3NUb1RleHQoKVtlY2xfXSA6IGVjbF8pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vJ25vIGRhdGEnIGxlZ2VuZCBib3hcclxuICAgICAgICAgICAgaWYgKG91dC5ub0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgKyBlY2xzLmxlbmd0aCAqIChvdXQuc2hhcGVIZWlnaHQgKyBvdXQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbWFwLm5vRGF0YUZpbGxTdHlsZV8pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCB1bmhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vJ25vIGRhdGEnIGxhYmVsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQob3V0Lm5vRGF0YVRleHQpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBwYXR0ZXJuIGZpbGwgbGVnZW5kIGl0ZW1zIEJFTE9XIHRoZSBtYWluIGxlZ2VuZFxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgY2hvcm9wbGV0aCBsZWdlbmQgYm94XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZEhlaWdodCA9IG91dC5sZ2cubm9kZSgpLmdldEJCb3goKS5oZWlnaHRcclxuICAgICAgICAgICAgYXBwZW5kUGF0dGVybkZpbGxMZWdlbmQobWFwLCBvdXQubGdnLCB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVdpZHRoOiBvdXQuc2hhcGVXaWR0aCxcclxuICAgICAgICAgICAgICAgIHNoYXBlSGVpZ2h0OiBvdXQuc2hhcGVIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBsYWJlbE9mZnNldDogb3V0LmxhYmVsT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgYm94UGFkZGluZzogb3V0LmJveFBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiBsZWdlbmRIZWlnaHQgKyBvdXQuYm94UGFkZGluZyArIDUsIC8vIDw8IHRoaXMgc2hpZnRzIHBhdHRlcm4gbGVnZW5kIGRvd25cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGxlZ2VuZCBib3ggZGltZW5zaW9uc1xyXG4gICAgICAgICAgICBvdXQuc2V0Qm94RGltZW5zaW9uKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHJlZ2lvbnMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gb3V0Lmdlb18gPT09ICdXT1JMRCcgPyAnI2VtLXdvcmxkcmcnIDogJyNlbS1udXRzcmcnXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSBzZWxlY3RvciA9ICcjZW0tdXNlci1yZWdpb25zJyAvLyBmb3IgdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoJ1tlY2xdJylcclxuXHJcbiAgICAgICAgLy8gU2V0IGFsbCByZWdpb25zIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5zdHlsZSgnZmlsbCcsICd3aGl0ZScpXHJcblxyXG4gICAgICAgIC8vIEhpZ2hsaWdodCBvbmx5IHRoZSBzZWxlY3RlZCByZWdpb25zIGJ5IHJlc3RvcmluZyB0aGVpciBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUmVnaW9ucyA9IGFsbFJlZ2lvbnMuZmlsdGVyKFwiW2VjbD0nXCIgKyBlY2wgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsZWN0ZWRSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgcmVnaW9ucyB0byB0aGVpciBvcmlnaW5hbCBjb2xvcnMgb24gbW91c2VvdXRcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgZmlsbF9fXyBhdHRyaWJ1dGVcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IGxpbmUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Rm9udFNpemVGcm9tQ2xhc3MsIGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIGNob3JvcGxldGgtYml2YXJpYXRlIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IGZvciB0aGUgbWFwXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICAvL3NpemVcclxuICAgIG91dC5zcXVhcmVTaXplID0gMTAwXHJcblxyXG4gICAgLy9vcmllbnRhdGlvblxyXG4gICAgb3V0LnJvdGF0aW9uID0gMFxyXG5cclxuICAgIC8vbGFiZWxzXHJcbiAgICBvdXQubGFiZWwxID0gJ1ZhcmlhYmxlIDEnXHJcbiAgICBvdXQubGFiZWwyID0gJ1ZhcmlhYmxlIDInXHJcblxyXG4gICAgLy9nZXQgdGhlIGZvbnQgc2l6ZSBvZiB0aGUgdGV4dHNcclxuICAgIG91dC5heGlzVGl0bGVGb250U2l6ZSA9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1iaXZhcmlhdGUtYXhpcy10aXRsZScpXHJcblxyXG4gICAgLy9icmVha3NcclxuICAgIG91dC5icmVha3MxID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuYnJlYWtzMiA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnNob3dCcmVha3MgPSBmYWxzZSAvLyBpZiBzZXQgdG8gdHJ1ZSBhbmQgYnJlYWtzMSBhbmQgYnJlYWtzMiBhcmUgdW5kZWZpbmVkIHRoZW4gYnJlYWtzIGFyZSBhdXRvbWF0aWNhbGx5IGRlZmluZWRcclxuICAgIG91dC50aWNrTGVuZ3RoID0gNSAvLyBsZW5ndGggb2YgdGhlIHRpY2tzXHJcblxyXG4gICAgLy9heGlzXHJcbiAgICBvdXQueUF4aXNMYWJlbHNPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfVxyXG4gICAgb3V0LnhBeGlzTGFiZWxzT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH1cclxuXHJcbiAgICAvL2F4aXMgdGl0bGVzXHJcbiAgICBvdXQueUF4aXNUaXRsZU9mZnNldCA9IHsgeDogMCwgeTogMCB9XHJcbiAgICBvdXQueEF4aXNUaXRsZU9mZnNldCA9IHsgeDogMCwgeTogMCB9XHJcblxyXG4gICAgLy9zaG93IG5vIGRhdGFcclxuICAgIG91dC5ub0RhdGEgPSB0cnVlXHJcbiAgICAvL3Nob3cgbm8gZGF0YVxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlSGVpZ2h0ID0gMjBcclxuICAgIG91dC5ub0RhdGFTaGFwZVdpZHRoID0gMjVcclxuXHJcbiAgICAvL25vIGRhdGEgdGV4dCBsYWJlbFxyXG4gICAgb3V0Lm5vRGF0YVRleHQgPSAnTm8gZGF0YSdcclxuXHJcbiAgICAvL292ZXJyaWRlIHBhZGRpbmdcclxuICAgIG91dC5ib3hQYWRkaW5nID0gb3V0LmxhYmVsRm9udFNpemVcclxuXHJcbiAgICAvL2FkZCBleHRyYSBkaXN0YW5jZSBiZXR3ZWVuIGxlZ2VuZCBhbmQgbm8gZGF0YSBpdGVtXHJcbiAgICBvdXQubm9EYXRhWU9mZnNldCA9IDMwXHJcblxyXG4gICAgLy9hcnJvd3NcclxuICAgIG91dC5heGlzQXJyb3dzID0gdHJ1ZSAvLyBpZiBzZXQgdG8gdHJ1ZSwgYXJyb3dzIGFyZSBkcmF3biBhdCB0aGUgZW5kIG9mIHRoZSBheGVzXHJcbiAgICBvdXQuYXJyb3dIZWlnaHQgPSAxNVxyXG4gICAgb3V0LmFycm93V2lkdGggPSAxNFxyXG4gICAgb3V0LmFycm93UGFkZGluZyA9IDEwIC8vIHBhZGRpbmcgYmV0d2VlbiBhcnJvdyBhbmQgYXhpcyBsYWJlbFxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIGZvciAobGV0IGtleSBpbiBjb25maWcpIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgLy8gSG9yaXpvbnRhbCBzaGlmdCB0byBtb3ZlIGV2ZXJ5dGhpbmcgcmlnaHQgKGFkanVzdCB0aGlzIHZhbHVlIGFzIG5lZWRlZClcclxuICAgICAgICBvdXQuX2hvcml6b250YWxPZmZzZXQgPSBvdXQuYXhpc1RpdGxlRm9udFNpemUgKyBvdXQuYXJyb3dQYWRkaW5nIC8vIEFkanVzdCB0aGlzIHZhbHVlIHRvIG1vdmUgdGhlIHdob2xlIGxlZ2VuZCB0byB0aGUgcmlnaHRcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBvdXQubGdnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIERyYXcgYmFja2dyb3VuZCBib3hcclxuICAgICAgICBvdXQubWFrZUJhY2tncm91bmRCb3goKVxyXG5cclxuICAgICAgICAvLyBEcmF3IHRpdGxlXHJcbiAgICAgICAgaWYgKG91dC50aXRsZSkge1xyXG4gICAgICAgICAgICBvdXQubGdnXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4YyArIG91dC5faG9yaXpvbnRhbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC50aXRsZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICBvdXQuX3kgPSBvdXQuYm94UGFkZGluZyArIChvdXQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMClcclxuXHJcbiAgICAgICAgLy8gU3F1YXJlIGdyb3VwIHdpdGggaG9yaXpvbnRhbCBvZmZzZXRcclxuICAgICAgICBhZGRTcXVhcmVzKClcclxuXHJcbiAgICAgICAgLy8gc2V0IGJyZWFrcyBpZiB1c2VyIGhhc250IGRlZmluZWQgdGhlbSBidXQgaGFzIGVuYWJsZWQgdGhlbVxyXG4gICAgICAgIGlmICghb3V0LmJyZWFrczEgJiYgIW91dC5icmVha3MyICYmIG91dC5zaG93QnJlYWtzKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBxdWFudGlsZXMgZm9yIHRoZSBmaXJzdCB2YXJpYWJsZSAoWCBheGlzKSBhbmQgdHJ1bmNhdGUgdG8gb25lIGRlY2ltYWwgcGxhY2VcclxuICAgICAgICAgICAgb3V0LmJyZWFrczEgPSBtYXAuY2xhc3NpZmllcjFfLnF1YW50aWxlcygpLm1hcCgodmFsdWUpID0+IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCgwKSkpXHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgcXVhbnRpbGVzIGZvciB0aGUgc2Vjb25kIHZhcmlhYmxlIChZIGF4aXMpIGFuZCB0cnVuY2F0ZSB0byBvbmUgZGVjaW1hbCBwbGFjZVxyXG4gICAgICAgICAgICBvdXQuYnJlYWtzMiA9IG1hcC5jbGFzc2lmaWVyMl8ucXVhbnRpbGVzKCkubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDApKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgYnJlYWtzIGxhYmVscyAxIChYIGF4aXMpXHJcbiAgICAgICAgYWRkQnJlYWtMYWJlbHMoKVxyXG5cclxuICAgICAgICBvdXQuX3hBeGlzQXJyb3dZID0gMFxyXG4gICAgICAgIG91dC5feUF4aXNBcnJvd1ggPSAwXHJcbiAgICAgICAgaWYgKG91dC5heGlzQXJyb3dzKSB7XHJcbiAgICAgICAgICAgIGFkZEF4aXNBcnJvd3MoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWRkQXhpc1RpdGxlcygpXHJcblxyXG4gICAgICAgIC8vIEFycm93IGRlZnNcclxuICAgICAgICBvdXQubGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RlZnMnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdtYXJrZXInKVxyXG4gICAgICAgICAgICAuYXR0cigndmlld0JveCcsIGAwIDAgJHtvdXQuYXJyb3dXaWR0aH0gJHtvdXQuYXJyb3dIZWlnaHR9YClcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2Fycm93aGVhZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZYJywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCA1KVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCBvdXQuYXJyb3dXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIG91dC5hcnJvd0hlaWdodClcclxuICAgICAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcclxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgJ00gMCAwIEwgNSA1IEwgMCAxMCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXItdW5pdHMnLCAnc3Ryb2tlV2lkdGgnKVxyXG5cclxuICAgICAgICAvLyAnTm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChvdXQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGFkZE5vRGF0YUVsZW1lbnQoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IGxlZ2VuZCBib3ggZGltZW5zaW9uc1xyXG4gICAgICAgIG91dC5zZXRCb3hEaW1lbnNpb24oKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZE5vRGF0YUVsZW1lbnQoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9EYXRhWU9mZnNldCA9XHJcbiAgICAgICAgICAgIG91dC5yb3RhdGlvbiA9PT0gMCA/IG91dC5ub0RhdGFZT2Zmc2V0ICsgb3V0LnNxdWFyZVNpemUgLyBvdXQubWFwLm51bWJlck9mQ2xhc3Nlc18gKyBvdXQuYXJyb3dIZWlnaHQgLyAyIDogb3V0Lm5vRGF0YVlPZmZzZXRcclxuXHJcbiAgICAgICAgbGV0IG5vRGF0YVkgPVxyXG4gICAgICAgICAgICBvdXQucm90YXRpb24gPT09IDAgPyBvdXQuX3kgKyBvdXQuc3F1YXJlU2l6ZSArIG5vRGF0YVlPZmZzZXQgOiBvdXQuX3kgKyAxLjQxNDIgKiBvdXQuc3F1YXJlU2l6ZSArIG91dC5ib3hQYWRkaW5nICogMiArIG5vRGF0YVlPZmZzZXRcclxuXHJcbiAgICAgICAgb3V0LmxnZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1ub2RhdGEnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0Lm5vRGF0YVNoYXBlV2lkdGggLyAyKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG5vRGF0YVkgKyAob3V0LnJvdGF0aW9uID09IDAgPyAwIDogLTEwKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0Lm5vRGF0YVNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQubm9EYXRhU2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG91dC5tYXAubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaW9ucyA9IG91dC5tYXAubnV0c0xldmVsXyA9PSAnbWl4ZWQnID8gc2VsZWN0QWxsKCcjZW0tbnV0c3JnJykgOiBzZWxlY3QoJyNlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gcmVnaW9ucy5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIilcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsICdyZWQnKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgblJnID0gb3V0Lm1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcgPyBzZWxlY3RBbGwoJyNlbS1udXRzcmcnKSA6IHNlbGVjdCgnI2VtLW51dHNyZycpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBuUmcuc2VsZWN0QWxsKFwiW25kPSduZCddXCIpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBvdXQubWFwLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIG91dC5sZ2dcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtbm9kYXRhLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIG91dC5ub0RhdGFTaGFwZVdpZHRoICsgKG91dC5ub0RhdGFTaGFwZVdpZHRoIC8gMiArIDUpKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIG5vRGF0YVkgKyBvdXQubm9EYXRhU2hhcGVIZWlnaHQgKiAwLjUgKyAxICsgKG91dC5yb3RhdGlvbiA9PSAwID8gMCA6IC0xMCkpXHJcbiAgICAgICAgICAgIC50ZXh0KG91dC5ub0RhdGFUZXh0KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFNxdWFyZXMoKSB7XHJcbiAgICAgICAgY29uc3QgbGdnID0gb3V0LmxnZ1xyXG4gICAgICAgIGNvbnN0IG51bWJlck9mQ2xhc3NlcyA9IG91dC5tYXAubnVtYmVyT2ZDbGFzc2VzKClcclxuICAgICAgICBjb25zdCBzeiA9IG91dC5zcXVhcmVTaXplIC8gbnVtYmVyT2ZDbGFzc2VzXHJcbiAgICAgICAgY29uc3QgeGMgPSBvdXQucm90YXRpb24gPT09IDAgPyAwIDogMC43MDcxICogb3V0LnNxdWFyZVNpemUgKyBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxYID0gMFxyXG5cclxuICAgICAgICBjb25zdCBzcXVhcmUgPSBsZ2dcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdiaXZhcmlhdGUtc3F1YXJlcy1jaGFydCcpXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICAgICAgICBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmcgKyBvdXQuX2hvcml6b250YWxPZmZzZXR9LCR7eGMgKyBvdXQuX3l9KSByb3RhdGUoJHtvdXQucm90YXRpb259KSB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZ30sMClgXHJcbiAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgLy8gRHJhdyByZWN0YW5nbGVzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bWJlck9mQ2xhc3NlczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wxID0gbnVtYmVyT2ZDbGFzc2VzIC0gaSAtIDFcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbDIgPSBudW1iZXJPZkNsYXNzZXMgLSBqIC0gMVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbCA9IG91dC5tYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKGVjbDEsIGVjbDIpXHJcblxyXG4gICAgICAgICAgICAgICAgc3F1YXJlXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1zcXVhcmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgaW5pdGlhbFggKyAobnVtYmVyT2ZDbGFzc2VzIC0gMSAtIGkpICogc3opXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBqICogc3opXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc3opXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHN6KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZpbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsMSwgZWNsMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBlY2wxLCBlY2wyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5yYWlzZSgpIC8vIHJhaXNlIGxlZ2VuZCBzcXVhcmUgdG8gYXZvaWQgc3Ryb2tlIGlzc3VlXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGVjbDEsIGVjbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGcmFtZVxyXG4gICAgICAgIHNxdWFyZVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1mcmFtZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgaW5pdGlhbFgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNxdWFyZVNpemUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc3F1YXJlU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDAuNylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRCcmVha0xhYmVscygpIHtcclxuICAgICAgICBjb25zdCB4YyA9IG91dC5yb3RhdGlvbiA9PT0gMCA/IDAgOiAwLjcwNzEgKiBvdXQuc3F1YXJlU2l6ZSArIG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFggPSAwXHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDbGFzc2VzID0gb3V0Lm1hcC5udW1iZXJPZkNsYXNzZXMoKVxyXG4gICAgICAgIGNvbnN0IHN6ID0gb3V0LnNxdWFyZVNpemUgLyBudW1iZXJPZkNsYXNzZXNcclxuXHJcbiAgICAgICAgLy8gZ3JvdXAgd2l0aCBob3Jpem9udGFsIG9mZnNldFxyXG4gICAgICAgIGNvbnN0IGJyZWFrTGFiZWxzID0gb3V0LmxnZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JpdmFyaWF0ZS1icmVhay1sYWJlbHMnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICAgICAgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nICsgb3V0Ll9ob3Jpem9udGFsT2Zmc2V0fSwke3hjICsgb3V0Ll95fSkgcm90YXRlKCR7b3V0LnJvdGF0aW9ufSkgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmd9LDApYFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgaWYgKG91dC5icmVha3MxKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LmJyZWFrczEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBpbml0aWFsWCArIHN6ICogKGkgKyAxKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG91dC5zcXVhcmVTaXplICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJylcclxuXHJcbiAgICAgICAgICAgICAgICBicmVha0xhYmVsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtdGljay1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4ICsgb3V0LnhBeGlzTGFiZWxzT2Zmc2V0LnggKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC54QXhpc0xhYmVsc09mZnNldC55IClcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQuYnJlYWtzMVtpXSlcclxuXHJcbiAgICAgICAgICAgICAgICBicmVha0xhYmVsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1iaXZhcmlhdGUtdGljaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIG91dC5zcXVhcmVTaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIG91dC5zcXVhcmVTaXplICsgb3V0LnRpY2tMZW5ndGgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgYnJlYWtzIGxhYmVscyAyIChZIGF4aXMpXHJcbiAgICAgICAgaWYgKG91dC5icmVha3MyKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LmJyZWFrczIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBpbml0aWFsWFxyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHN6ICogKGkgKyAyKSAtIHN6XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWtMYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeCArIG91dC55QXhpc0xhYmVsc09mZnNldC54KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSAtIG91dC55QXhpc0xhYmVsc09mZnNldC55IC0gKG91dC50aWNrTGVuZ3RoICsgMikpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoWy4uLm91dC5icmVha3MyXS5yZXZlcnNlKClbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGByb3RhdGUoLTkwLCAke3h9LCAke3l9KWApXHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWtMYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCAtIG91dC50aWNrTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRBeGlzVGl0bGVzKCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0gb3V0LnJvdGF0aW9uID09PSAwID8gMCA6IDAuNzA3MSAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBjb25zdCBpbml0aWFsWCA9IDBcclxuXHJcbiAgICAgICAgY29uc3QgYXhpc1RpdGxlcyA9IG91dC5sZ2dcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdiaXZhcmlhdGUtYXhpcy10aXRsZXMnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICAgICAgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nICsgb3V0Ll9ob3Jpem9udGFsT2Zmc2V0fSwke3hjICsgb3V0Ll95fSkgcm90YXRlKCR7b3V0LnJvdGF0aW9ufSkgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmd9LDApYFxyXG4gICAgICAgICAgICApXHJcblxyXG4gICAgICAgIC8vIFggYXhpcyB0aXRsZVxyXG4gICAgICAgIGxldCB4QXhpc1RpdGxlWSA9IG91dC5zcXVhcmVTaXplICsgb3V0LnhBeGlzTGFiZWxzT2Zmc2V0LnkgKyAob3V0LmF4aXNBcnJvd3MgPyBvdXQuYXJyb3dQYWRkaW5nICsgb3V0LmFycm93SGVpZ2h0IDogNylcclxuICAgICAgICBsZXQgeEF4aXNUaXRsZVggPSBpbml0aWFsWFxyXG4gICAgICAgIGlmIChvdXQuc2hvd0JyZWFrcyB8fCAob3V0LmJyZWFrczEgJiYgb3V0LmJyZWFrczIpKSB4QXhpc1RpdGxlWSArPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tYml2YXJpYXRlLXRpY2stbGFiZWwnKSAvLyBtb3ZlIG92ZXIgZm9yIHRpY2sgbGFiZWxzXHJcbiAgICAgICAgaWYgKG91dC54QXhpc1RpdGxlT2Zmc2V0KSB4QXhpc1RpdGxlWSArPSBvdXQueEF4aXNUaXRsZU9mZnNldC55XHJcbiAgICAgICAgaWYgKG91dC54QXhpc1RpdGxlT2Zmc2V0KSB4QXhpc1RpdGxlWCArPSBvdXQueEF4aXNUaXRsZU9mZnNldC54XHJcbiAgICAgICAgYXhpc1RpdGxlc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlIGVtLWJpdmFyaWF0ZS1heGlzLXRpdGxlLXgnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHhBeGlzVGl0bGVYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHhBeGlzVGl0bGVZKVxyXG4gICAgICAgICAgICAudGV4dChvdXQubGFiZWwxKVxyXG4gICAgICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXHJcblxyXG4gICAgICAgIC8vIFkgYXhpcyB0aXRsZVxyXG4gICAgICAgIGxldCB5QXhpc1RpdGxlWSA9IChvdXQuYXhpc0Fycm93cyA/IG91dC5feUF4aXNBcnJvd1ggLSBvdXQuYXJyb3dQYWRkaW5nIDogNykgKyAob3V0LnJvdGF0aW9uID09IC00NSA/IC00IDogLTEwKSAvLyBhZGp1c3QgZm9yIHJvdGF0aW9uXHJcbiAgICAgICAgaWYgKG91dC5zaG93QnJlYWtzIHx8IChvdXQuYnJlYWtzMSAmJiBvdXQuYnJlYWtzMikpIHhBeGlzVGl0bGVZICs9IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1iaXZhcmlhdGUtdGljay1sYWJlbCcpIC8vIG1vdmUgb3ZlciBmb3IgdGljayBsYWJlbHNcclxuICAgICAgICBsZXQgeUF4aXNUaXRsZVggPSAtb3V0LnNxdWFyZVNpemVcclxuICAgICAgICAvL21hbnVhbCBvZmZzZXRzXHJcbiAgICAgICAgaWYgKG91dC55QXhpc1RpdGxlT2Zmc2V0KSB5QXhpc1RpdGxlWSArPSBvdXQueUF4aXNUaXRsZU9mZnNldC55XHJcbiAgICAgICAgaWYgKG91dC55QXhpc1RpdGxlT2Zmc2V0KSB5QXhpc1RpdGxlWCArPSBvdXQueUF4aXNUaXRsZU9mZnNldC54XHJcbiAgICAgICAgYXhpc1RpdGxlc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlIGVtLWJpdmFyaWF0ZS1heGlzLXRpdGxlLXknKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHlBeGlzVGl0bGVYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHlBeGlzVGl0bGVZKVxyXG4gICAgICAgICAgICAudGV4dChvdXQubGFiZWwyKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsIG91dC5yb3RhdGlvbiA8IDAgPyBgdHJhbnNsYXRlKCR7b3V0LmF4aXNBcnJvd3MgPyAtNTEgOiAtMTV9cHgsIDk1cHgpIHJvdGF0ZSg5MGRlZylgIDogJ3JvdGF0ZSgtOTBkZWcpJylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRBeGlzQXJyb3dzKCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0gb3V0LnJvdGF0aW9uID09PSAwID8gMCA6IDAuNzA3MSAqIG91dC5zcXVhcmVTaXplICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBjb25zdCBpbml0aWFsWCA9IDBcclxuXHJcbiAgICAgICAgLy8gZ3JvdXAgd2l0aCBob3Jpem9udGFsIG9mZnNldFxyXG4gICAgICAgIGNvbnN0IGF4aXNBcnJvd3MgPSBvdXQubGdnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYml2YXJpYXRlLWF4aXMtYXJyb3dzJylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgICAgICAgIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZyArIG91dC5faG9yaXpvbnRhbE9mZnNldH0sJHt4YyArIG91dC5feX0pIHJvdGF0ZSgke291dC5yb3RhdGlvbn0pIHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nfSwwKWBcclxuICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgWCBheGlzIGFycm93XHJcbiAgICAgICAgb3V0Ll94QXhpc0Fycm93WSA9IG91dC5zcXVhcmVTaXplICsgb3V0LnRpY2tMZW5ndGggKyBvdXQuYXJyb3dQYWRkaW5nXHJcbiAgICAgICAgaWYgKG91dC5zaG93QnJlYWtzIHx8IChvdXQuYnJlYWtzMSAmJiBvdXQuYnJlYWtzMikpIG91dC5feEF4aXNBcnJvd1kgKz0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS10aWNrLWxhYmVsJykgLyAxLjUgLy8gbW92ZSBvdmVyIGZvciB0aWNrIGxhYmVsc1xyXG5cclxuICAgICAgICBheGlzQXJyb3dzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWF4aXMtYXJyb3cnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdkJyxcclxuICAgICAgICAgICAgICAgIGxpbmUoKShbXHJcbiAgICAgICAgICAgICAgICAgICAgW2luaXRpYWxYLCBvdXQuX3hBeGlzQXJyb3dZXSxcclxuICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbFggKyBvdXQuc3F1YXJlU2l6ZSwgb3V0Ll94QXhpc0Fycm93WV0sXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgWSBheGlzIGFycm93XHJcbiAgICAgICAgb3V0Ll95QXhpc0Fycm93WCA9IC1vdXQudGlja0xlbmd0aCAtIG91dC5hcnJvd1BhZGRpbmdcclxuICAgICAgICBpZiAob3V0LnNob3dCcmVha3MgfHwgKG91dC5icmVha3MxICYmIG91dC5icmVha3MyKSkgb3V0Ll95QXhpc0Fycm93WCAtPSBvdXQubGFiZWxGb250U2l6ZSAvIDIgLy8gbW92ZSBvdmVyIGZvciB0aWNrIGxhYmVsc1xyXG5cclxuICAgICAgICBheGlzQXJyb3dzXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tYml2YXJpYXRlLWF4aXMtYXJyb3cnKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdkJyxcclxuICAgICAgICAgICAgICAgIGxpbmUoKShbXHJcbiAgICAgICAgICAgICAgICAgICAgW291dC5feUF4aXNBcnJvd1gsIG91dC5zcXVhcmVTaXplXSxcclxuICAgICAgICAgICAgICAgICAgICBbb3V0Ll95QXhpc0Fycm93WCwgMF0sXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyLWVuZCcsICd1cmwoI2Fycm93aGVhZCknKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpZ2hsaWdodCBzZWxlY3RlZCByZWdpb25zIG9uIG1vdXNlb3ZlclxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGVjbDEsIGVjbDIpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgY29uc3QgYWxsUmVnaW9ucyA9IG1hcC5zdmdfLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKGBbZWNsMV1gKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHJlZ2lvbnMgdG8gd2hpdGVcclxuICAgICAgICBhbGxSZWdpb25zLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWdpb25zID0gYWxsUmVnaW9ucy5maWx0ZXIoYFtlY2wxPScke2VjbDF9J11gKS5maWx0ZXIoYFtlY2wyPScke2VjbDJ9J11gKVxyXG4gICAgICAgIHNlbGVjdGVkUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChgW2VjbDFdYClcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IHNlbGVjdCwgc2VsZWN0QWxsIH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4IH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgY2hvcm9wbGV0aC10cml2YXJpYXRlIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIGNvbnN0IG91dCA9IExlZ2VuZC5sZWdlbmQobWFwKVxyXG5cclxuICAgIC8vIERlZmF1bHQgc2V0dGluZ3NcclxuICAgIG91dC53aWR0aCA9IDIzMFxyXG4gICAgb3V0LmhlaWdodCA9IDIzMFxyXG5cclxuICAgIG91dC5sYWJlbDEgPSAnVmFyaWFibGUgMSdcclxuICAgIG91dC5sYWJlbDIgPSAnVmFyaWFibGUgMidcclxuICAgIG91dC5sYWJlbDMgPSAnVmFyaWFibGUgMycgLy8gQWRkIGEgbGFiZWwgZm9yIHRoZSB0aGlyZCB2YXJpYWJsZVxyXG4gICAgb3V0LmF4aXNUaXRsZUZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWJpdmFyaWF0ZS1heGlzLXRpdGxlJylcclxuICAgIG91dC5zaG93QnJlYWtzID0gZmFsc2VcclxuICAgIG91dC5ub0RhdGEgPSB0cnVlXHJcbiAgICBvdXQubm9EYXRhU2hhcGVIZWlnaHQgPSAyMFxyXG4gICAgb3V0Lm5vRGF0YVNoYXBlV2lkdGggPSAyNVxyXG4gICAgb3V0Lm5vRGF0YVRleHQgPSAnTm8gZGF0YSdcclxuICAgIG91dC5ib3hQYWRkaW5nID0gNjAgLy8gZGVwZW5kcyBvbiB2YXJpYWJsZSAxIGxhYmVsIGxlbmd0aCByZWFsbHlcclxuICAgIG91dC5ub0RhdGFZT2Zmc2V0ID0gMjBcclxuICAgIG91dC5hcnJvd0hlaWdodCA9IDE1XHJcbiAgICBvdXQuYXJyb3dXaWR0aCA9IDE0XHJcbiAgICBvdXQuYXJyb3dQYWRkaW5nID0gMTBcclxuXHJcbiAgICBpZiAoY29uZmlnKSBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZSB0aGUgdXBkYXRlIG1ldGhvZCB0byBoYW5kbGUgdHJpdmFyaWF0ZSBsZWdlbmRzXHJcbiAgICAgKi9cclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcbiAgICAgICAgY29uc3QgbGdnID0gb3V0LmxnZ1xyXG4gICAgICAgIGNvbnN0IG51bWJlck9mQ2xhc3NlcyA9IG91dC5tYXAubnVtYmVyT2ZDbGFzc2VzKClcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHBhZGRpbmcgdG8gdGhlIG1haW4gPGc+IGdyb3VwXHJcbiAgICAgICAgY29uc3QgcGFkZGVkR3JvdXAgPSBsZ2cuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke291dC5ib3hQYWRkaW5nfSwgJHtvdXQuYm94UGFkZGluZ30pYClcclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIHtcclxuICAgICAgICAgICAgcGFkZGVkR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApIC8vIFN0YXJ0IGF0IDAgd2l0aGluIHRoZSBwYWRkZWQgZ3JvdXBcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LnRpdGxlRm9udFNpemUpIC8vIFZlcnRpY2FsIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSB0cml2YXJpYXRlIFZlbm4gZGlhZ3JhbVxyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IFtvdXQubGFiZWwxLCBvdXQubGFiZWwyLCBvdXQubGFiZWwzXVxyXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IFtvdXQubWFwLmNvbG9yMV8sIG91dC5tYXAuY29sb3IyXywgb3V0Lm1hcC5jb2xvcjNfXVxyXG5cclxuICAgICAgICBkcmF3VHJpdmFyaWF0ZVZlbm5EaWFncmFtKHBhZGRlZEdyb3VwLCBjb2xvcnMsIGxhYmVscylcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHRyaXZhcmlhdGUgKFZlbm4gRGlhZ3JhbSkgb3IgYml2YXJpYXRlIChncmlkKSBsZWdlbmRcclxuICAgICAgICAvLyBpZiAobnVtYmVyT2ZDbGFzc2VzID09PSA3KSB7XHJcbiAgICAgICAgLy8gICAgIGRyYXdUcml2YXJpYXRlVmVubkRpYWdyYW0obGdnLCBvdXQpXHJcbiAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgZHJhd1RyaXZhcmlhdGVUZXJuYXJ5UGxvdChsZ2csIG91dCwgbnVtYmVyT2ZDbGFzc2VzKVxyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdUcml2YXJpYXRlVmVubkRpYWdyYW0oY29udGFpbmVyLCBjb2xvcnMsIGxhYmVscykge1xyXG4gICAgLy9zcGVjcyBmb3IgQ2lyY2xlIDFcclxuICAgIGNvbnN0IHhDZW50ZXIxID0gNTBcclxuICAgIGNvbnN0IHlDZW50ZXIxID0gNTBcclxuICAgIGNvbnN0IGNpcmNsZVJhZCA9IDMwXHJcblxyXG4gICAgLy9kcmF3IENpcmNsZSAxXHJcbiAgICAvLyBjb25zdCBjaXJjbGUxID0gY29udGFpbmVyXHJcbiAgICAvLyAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgIC8vICAgICAuYXR0cigncicsIGNpcmNsZVJhZClcclxuICAgIC8vICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeENlbnRlcjEgKyAnLCcgKyB5Q2VudGVyMSArICcpJylcclxuXHJcbiAgICAvL2FkZCdsIHNwZWNzIGZvciBDaXJjbGUgMlxyXG4gICAgY29uc3Qgb2Zmc2V0RmFjdG9yID0gMS4yXHJcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRGYWN0b3IgKiBjaXJjbGVSYWRcclxuICAgIGNvbnN0IHhDZW50ZXIyID0geENlbnRlcjEgKyBvZmZzZXRcclxuICAgIGNvbnN0IHlDZW50ZXIyID0geUNlbnRlcjEgLy9jcmVhdGluZyBuZXcgdmFyIGZvciBjbGFyaXR5XHJcblxyXG4gICAgLy9kcmF3IENpcmNsZSAyXHJcbiAgICAvLyBjb25zdCBjaXJjbGUyID0gY29udGFpbmVyXHJcbiAgICAvLyAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgIC8vICAgICAuYXR0cigncicsIGNpcmNsZVJhZClcclxuICAgIC8vICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeENlbnRlcjIgKyAnLCcgKyB5Q2VudGVyMiArICcpJylcclxuXHJcbiAgICAvL2FkZCdsIHNwZWNzIGZvciBDaXJjbGUgM1xyXG4gICAgY29uc3QgeENlbnRlcjMgPSB4Q2VudGVyMSArIG9mZnNldCAvIDJcclxuICAgIGNvbnN0IHlDZW50ZXIzID0geUNlbnRlcjEgKyAoTWF0aC5zcXJ0KDMpICogb2Zmc2V0KSAvIDJcclxuXHJcbiAgICAvL2RyYXcgQ2lyY2xlIDNcclxuICAgIC8vIGNvbnN0IGNpcmNsZTMgPSBjb250YWluZXJcclxuICAgIC8vICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgLy8gICAgIC5hdHRyKCdyJywgY2lyY2xlUmFkKVxyXG4gICAgLy8gICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4Q2VudGVyMyArICcsJyArIHlDZW50ZXIzICsgJyknKVxyXG5cclxuICAgIC8vY29tcHV0ZSBmaXJzdCBwb2ludHMgb2YgaW50ZXJzZWN0aW9uXHJcbiAgICBjb25zdCB0cmlIZWlnaHQgPSBNYXRoLnNxcnQoY2lyY2xlUmFkICoqIDIgLSAob2Zmc2V0IC8gMikgKiogMilcclxuICAgIC8vb3V0ZXIgaW50ZXJzZWN0aW9uIG9mIENpcmNsZXMgMSBhbmQgMlxyXG4gICAgY29uc3QgeElzZWN0MSA9IHhDZW50ZXIzXHJcbiAgICBjb25zdCB5SXNlY3QxID0geUNlbnRlcjEgLSB0cmlIZWlnaHRcclxuICAgIC8vaW5uZXIgaW50ZXJzZWN0aW9uIG9mIENpcmNsZXMgMSBhbmQgMlxyXG4gICAgY29uc3QgeElzZWN0NCA9IHhDZW50ZXIzXHJcbiAgICBjb25zdCB5SXNlY3Q0ID0geUNlbnRlcjEgKyB0cmlIZWlnaHRcclxuXHJcbiAgICAvL3RyZWF0IFwidHJpSGVpZ2h0XCIgYXMgdGhlIGh5cG90ZW5ldXNlIG9mIGEgMzAuNjAuOTAgdHJpYW5nbGUuXHJcbiAgICAvL3RoaXMgdGVsbHMgdXMgdGhlIHNoaWZ0IGZyb20gdGhlIG1pZHBvaW50IG9mIGEgbGVnIG9mIHRoZSB0cmlhbmdsZVxyXG4gICAgLy90byB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXHJcbiAgICBjb25zdCB4RGVsdGEgPSAodHJpSGVpZ2h0ICogTWF0aC5zcXJ0KDMpKSAvIDJcclxuICAgIGNvbnN0IHlEZWx0YSA9IHRyaUhlaWdodCAvIDJcclxuXHJcbiAgICBjb25zdCB4TWlkcG9pbnRDMUMzID0gKHhDZW50ZXIxICsgeENlbnRlcjMpIC8gMlxyXG4gICAgY29uc3QgeE1pZHBvaW50QzJDMyA9ICh4Q2VudGVyMiArIHhDZW50ZXIzKSAvIDJcclxuICAgIGNvbnN0IHlNaWRwb2ludEJvdGggPSAoeUNlbnRlcjEgKyB5Q2VudGVyMykgLyAyXHJcblxyXG4gICAgLy9maW5kIHRoZSByZXN0IG9mIHRoZSBwb2ludHMgb2YgaW50ZXJzZWN0aW9uXHJcbiAgICBjb25zdCB4SXNlY3QyID0geE1pZHBvaW50QzFDMyAtIHhEZWx0YVxyXG4gICAgY29uc3QgeUlzZWN0MiA9IHlNaWRwb2ludEJvdGggKyB5RGVsdGFcclxuICAgIGNvbnN0IHhJc2VjdDMgPSB4TWlkcG9pbnRDMkMzICsgeERlbHRhXHJcbiAgICBjb25zdCB5SXNlY3QzID0geU1pZHBvaW50Qm90aCArIHlEZWx0YVxyXG5cclxuICAgIGNvbnN0IHhJc2VjdDUgPSB4TWlkcG9pbnRDMUMzICsgeERlbHRhXHJcbiAgICBjb25zdCB5SXNlY3Q1ID0geU1pZHBvaW50Qm90aCAtIHlEZWx0YVxyXG4gICAgY29uc3QgeElzZWN0NiA9IHhNaWRwb2ludEMyQzMgLSB4RGVsdGFcclxuICAgIGNvbnN0IHlJc2VjdDYgPSB5TWlkcG9pbnRCb3RoIC0geURlbHRhXHJcblxyXG4gICAgY29uc3QgeFBvaW50cyA9IFt4SXNlY3QxLCB4SXNlY3QyLCB4SXNlY3QzLCB4SXNlY3Q0LCB4SXNlY3Q1LCB4SXNlY3Q2XVxyXG4gICAgY29uc3QgeVBvaW50cyA9IFt5SXNlY3QxLCB5SXNlY3QyLCB5SXNlY3QzLCB5SXNlY3Q0LCB5SXNlY3Q1LCB5SXNlY3Q2XVxyXG5cclxuICAgIGNvbnN0IG1ha2VJcm9uU2hhcGVzID0gKFt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBgTSAke3gxfSAke3kxfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAxICR7eDJ9ICR7eTJ9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDAgJHt4M30gJHt5M31cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMSAke3gxfSAke3kxfWBcclxuICAgICAgICByZXR1cm4gcGF0aFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ha2VTdW5TaGFwZXMgPSAoW3gxLCB4MiwgeDMsIHkxLCB5MiwgeTNdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGBNICR7eDF9ICR7eTF9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDAgJHt4Mn0gJHt5Mn1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMCAke3gzfSAke3kzfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMSAxICR7eDF9ICR7eTF9YFxyXG4gICAgICAgIHJldHVybiBwYXRoXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWFrZVJvdW5kZWRUcmkgPSAoW3gxLCB4MiwgeDMsIHkxLCB5MiwgeTNdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGBNICR7eDF9ICR7eTF9XHJcbiAgICAgICAgICAgICBBICR7Y2lyY2xlUmFkfSAke2NpcmNsZVJhZH0gMCAwIDEgJHt4Mn0gJHt5Mn1cclxuICAgICAgICAgICAgIEEgJHtjaXJjbGVSYWR9ICR7Y2lyY2xlUmFkfSAwIDAgMSAke3gzfSAke3kzfVxyXG4gICAgICAgICAgICAgQSAke2NpcmNsZVJhZH0gJHtjaXJjbGVSYWR9IDAgMCAxICR7eDF9ICR7eTF9YFxyXG4gICAgICAgIHJldHVybiBwYXRoXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXJvblBvaW50cyA9IFtcclxuICAgICAgICBbMSwgNSwgNl0sXHJcbiAgICAgICAgWzMsIDQsIDVdLFxyXG4gICAgICAgIFsyLCA2LCA0XSxcclxuICAgIF1cclxuICAgIGNvbnN0IHN1blBvaW50cyA9IFtcclxuICAgICAgICBbMywgNSwgMV0sXHJcbiAgICAgICAgWzIsIDQsIDNdLFxyXG4gICAgICAgIFsxLCA2LCAyXSxcclxuICAgIF1cclxuICAgIGNvbnN0IHJvdW5kZWRUcmlQb2ludHMgPSBbWzUsIDQsIDZdXVxyXG5cclxuICAgIC8vIG1haW4gY2lyY2xlcyAocmF3IGNvbG9ycylcclxuICAgIHN1blBvaW50cy5mb3JFYWNoKChwb2ludHMsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHRDeWNsZSA9IHBvaW50cy5tYXAoKGkpID0+IHhQb2ludHNbaSAtIDFdKS5jb25jYXQocG9pbnRzLm1hcCgoaSkgPT4geVBvaW50c1tpIC0gMV0pKVxyXG4gICAgICAgIGNvbnN0IHNoYXBlID0gbWFrZVN1blNoYXBlcyhwdEN5Y2xlKVxyXG5cclxuICAgICAgICBjb250YWluZXIuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHNoYXBlKS5hdHRyKCdjbGFzcycsICdzZWdtZW50JykuYXR0cignZmlsbCcsIGNvbG9yc1tpbmRleF0pLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBmaXJzdCBpbnRlcnNlY3RzIChjb21iaW5hdGlvbiBvZiAyIGNvbG9ycylcclxuICAgIGlyb25Qb2ludHMuZm9yRWFjaCgocG9pbnRzLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHB0Q3ljbGUgPSBwb2ludHMubWFwKChpKSA9PiB4UG9pbnRzW2kgLSAxXSkuY29uY2F0KHBvaW50cy5tYXAoKGkpID0+IHlQb2ludHNbaSAtIDFdKSlcclxuICAgICAgICBjb25zdCBzaGFwZSA9IG1ha2VJcm9uU2hhcGVzKHB0Q3ljbGUpXHJcblxyXG4gICAgICAgIGxldCBjb2xvclxyXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcnNbMl0sIGNvbG9yc1swXV0pIC8vIHBpbmsgKyBjeWFuXHJcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcnNbMV0sIGNvbG9yc1swXV0pIC8vIGN5YW4gKyB5ZWxsb3dcclxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09IDIpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yc1sxXSwgY29sb3JzWzJdXSkgLy8gcGluayArIHllbGxvd1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBzaGFwZSkuYXR0cignY2xhc3MnLCAnc2VnbWVudCcpLmF0dHIoJ2ZpbGwnLCBjb2xvcikuYXR0cignb3BhY2l0eScsIDEpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIG51Y2xldXMgKGNvbWJpbmF0aW9uIG9mIGFsbCAzIGNvbG9ycylcclxuICAgIHJvdW5kZWRUcmlQb2ludHMuZm9yRWFjaCgocG9pbnRzLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHB0Q3ljbGUgPSBwb2ludHMubWFwKChpKSA9PiB4UG9pbnRzW2kgLSAxXSkuY29uY2F0KHBvaW50cy5tYXAoKGkpID0+IHlQb2ludHNbaSAtIDFdKSlcclxuICAgICAgICBjb25zdCBzaGFwZSA9IG1ha2VSb3VuZGVkVHJpKHB0Q3ljbGUpXHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoY29sb3JzKVxyXG5cclxuICAgICAgICBjb250YWluZXIuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHNoYXBlKS5hdHRyKCdjbGFzcycsICdzZWdtZW50JykuYXR0cignZmlsbCcsIGNvbG9yKS5hdHRyKCdvcGFjaXR5JywgMSlcclxuICAgIH0pXHJcblxyXG4gICAgY29udGFpbmVyXHJcbiAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5zZWdtZW50JylcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKCdvcGFjaXR5JywgMC44KS5kdXJhdGlvbig1MDApXHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmF0dHIoJ29wYWNpdHknLCAxKS5kdXJhdGlvbig1MDApXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvLyBsYWJlbCBpbnRlcnNlY3RzXHJcbiAgICBjb25zdCB5T2Zmc2V0ID0gY29udGFpbmVyXHJcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQobGFiZWxzWzBdKVxyXG4gICAgICAgIC5hdHRyKCd4JywgeENlbnRlcjEgLSBjaXJjbGVSYWQgLSAzKVxyXG4gICAgICAgIC5hdHRyKCd5JywgeENlbnRlcjEpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Zlbm4tbGFiZWwnKVxyXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgY29udGFpbmVyXHJcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQobGFiZWxzWzFdKVxyXG4gICAgICAgIC5hdHRyKCd4JywgeENlbnRlcjIgKyBjaXJjbGVSYWQgKyAzKVxyXG4gICAgICAgIC5hdHRyKCd5JywgeUNlbnRlcjIpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Zlbm4tbGFiZWwnKVxyXG4gICAgY29udGFpbmVyXHJcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQobGFiZWxzWzJdKVxyXG4gICAgICAgIC5hdHRyKCd4JywgeENlbnRlcjMpXHJcbiAgICAgICAgLmF0dHIoJ3knLCB5Q2VudGVyMyArIGNpcmNsZVJhZCArIDE1KVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZW5uLWxhYmVsJylcclxuICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIGEgdHJpdmFyaWF0ZSBsZWdlbmQgYXMgYSBWZW5uIERpYWdyYW1cclxuICovXHJcbmZ1bmN0aW9uIGRyYXdUcml2YXJpYXRlVmVubkRpYWdyYW0yKHN2ZywgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgbGFiZWxzLCBjb2xvcnMpIHtcclxuICAgIGNvbnN0IHJhZGl1cyA9IGNvbnRhaW5lcldpZHRoIC8gNSAvLyBSYWRpdXMgb2YgZWFjaCBjaXJjbGVcclxuICAgIGNvbnN0IGNlbnRlclggPSBjb250YWluZXJXaWR0aCAvIDJcclxuICAgIGNvbnN0IGNlbnRlclkgPSBjb250YWluZXJIZWlnaHQgLyAyXHJcbiAgICBjb25zdCBvZmZzZXQgPSByYWRpdXMgLyAxLjVcclxuXHJcbiAgICAvLyBEZWZpbmUgY2lyY2xlIHBvc2l0aW9uc1xyXG4gICAgY29uc3QgY2lyY2xlcyA9IFtcclxuICAgICAgICB7IGlkOiAnY2lyY2xlMScsIGN4OiBjZW50ZXJYIC0gb2Zmc2V0LCBjeTogY2VudGVyWSwgbGFiZWw6IGxhYmVsc1swXSwgY29sb3I6IGNvbG9yc1swXSB9LFxyXG4gICAgICAgIHsgaWQ6ICdjaXJjbGUyJywgY3g6IGNlbnRlclggKyBvZmZzZXQsIGN5OiBjZW50ZXJZLCBsYWJlbDogbGFiZWxzWzFdLCBjb2xvcjogY29sb3JzWzFdIH0sXHJcbiAgICAgICAgeyBpZDogJ2NpcmNsZTMnLCBjeDogY2VudGVyWCwgY3k6IGNlbnRlclkgKyBvZmZzZXQgKiAxLjUsIGxhYmVsOiBsYWJlbHNbMl0sIGNvbG9yOiBjb2xvcnNbMl0gfSxcclxuICAgIF1cclxuXHJcbiAgICAvLyBEcmF3IGNpcmNsZXNcclxuICAgIGNpcmNsZXMuZm9yRWFjaCgoeyBpZCwgY3gsIGN5LCBsYWJlbCwgY29sb3IgfSwgaW5kZXgpID0+IHtcclxuICAgICAgICBzdmcuYXBwZW5kKCdjaXJjbGUnKS5hdHRyKCdpZCcsIGlkKS5hdHRyKCdjeCcsIGN4KS5hdHRyKCdjeScsIGN5KS5hdHRyKCdyJywgcmFkaXVzKS5zdHlsZSgnZmlsbCcsIGNvbG9yKS5zdHlsZSgnb3BhY2l0eScsIDEpXHJcblxyXG4gICAgICAgIC8vIEFkZCBsYWJlbHMgd2l0aCBzcGVjaWZpYyBwb3NpdGlvbmluZ1xyXG4gICAgICAgIGNvbnN0IGxhYmVsWCA9XHJcbiAgICAgICAgICAgIGluZGV4ID09PSAwXHJcbiAgICAgICAgICAgICAgICA/IGN4IC0gcmFkaXVzIC0gMTAgLy8gTGVmdCBvZiB0aGUgZmlyc3QgY2lyY2xlXHJcbiAgICAgICAgICAgICAgICA6IGluZGV4ID09PSAxXHJcbiAgICAgICAgICAgICAgICAgID8gY3ggKyByYWRpdXMgKyAxMCAvLyBSaWdodCBvZiB0aGUgc2Vjb25kIGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgICA6IGN4IC8vIEJlbG93IHRoZSB0aGlyZCBjaXJjbGVcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWxZID0gaW5kZXggPCAyID8gY3kgOiBjeSArIHJhZGl1cyArIDIwIC8vIFNhbWUgeSBmb3IgZmlyc3QgdHdvIGNpcmNsZXMsIGJlbG93IGZvciB0aGUgdGhpcmRcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbGFiZWxYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGxhYmVsWSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgaW5kZXggPCAyID8gKGluZGV4ID09PSAwID8gJ2VuZCcgOiAnc3RhcnQnKSA6ICdtaWRkbGUnKSAvLyBBZGp1c3QgYWxpZ25tZW50XHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZW5uLWxhYmVsJylcclxuICAgICAgICAgICAgLnRleHQobGFiZWwpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIERyYXdzIGEgdHJpdmFyaWF0ZSBsZWdlbmQgYXMgYSB0ZXJuYXJ5IHBsb3RcclxuICovXHJcbmZ1bmN0aW9uIGRyYXdUcml2YXJpYXRlVGVybmFyeVBsb3QobGdnLCBvdXQsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgY29uc3Qgc2l6ZSA9IG91dC5zcXVhcmVTaXplIC8vIFNpemUgb2YgdGhlIGxlZ2VuZCBhcmVhXHJcbiAgICBjb25zdCBwYWRkaW5nID0gMjAgLy8gUGFkZGluZyBhcm91bmQgdGhlIHBsb3RcclxuICAgIGNvbnN0IHJhZGl1cyA9IDUgLy8gUmFkaXVzIG9mIGVhY2ggY2xhc3MgcG9pbnRcclxuICAgIGNvbnN0IHRyaWFuZ2xlSGVpZ2h0ID0gKE1hdGguc3FydCgzKSAvIDIpICogc2l6ZVxyXG5cclxuICAgIGNvbnN0IHRlcm5hcnlHcm91cCA9IGxnZ1xyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd0cml2YXJpYXRlLXRlcm5hcnktcGxvdCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtvdXQuYm94UGFkZGluZyArIHNpemUgLyAyfSwgJHtvdXQuYm94UGFkZGluZyArIHRyaWFuZ2xlSGVpZ2h0IC8gMn0pYClcclxuXHJcbiAgICAvLyBEcmF3IHRoZSB0cmlhbmdsZVxyXG4gICAgY29uc3QgdmVydGljZXMgPSBbXHJcbiAgICAgICAgeyB4OiAwLCB5OiAtdHJpYW5nbGVIZWlnaHQgLyAyIH0sIC8vIFRvcCB2ZXJ0ZXggKFZhcmlhYmxlIDEpXHJcbiAgICAgICAgeyB4OiAtc2l6ZSAvIDIsIHk6IHRyaWFuZ2xlSGVpZ2h0IC8gMiB9LCAvLyBCb3R0b20tbGVmdCB2ZXJ0ZXggKFZhcmlhYmxlIDIpXHJcbiAgICAgICAgeyB4OiBzaXplIC8gMiwgeTogdHJpYW5nbGVIZWlnaHQgLyAyIH0sIC8vIEJvdHRvbS1yaWdodCB2ZXJ0ZXggKFZhcmlhYmxlIDMpXHJcbiAgICBdXHJcblxyXG4gICAgdGVybmFyeUdyb3VwXHJcbiAgICAgICAgLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgLmF0dHIoJ3BvaW50cycsIHZlcnRpY2VzLm1hcCgoZCkgPT4gYCR7ZC54fSwke2QueX1gKS5qb2luKCcgJykpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcblxyXG4gICAgLy8gTGFiZWwgdGhlIHZlcnRpY2VzXHJcbiAgICBjb25zdCBsYWJlbHMgPSBbb3V0LmxhYmVsMSwgb3V0LmxhYmVsMiwgb3V0LmxhYmVsM11cclxuICAgIHZlcnRpY2VzLmZvckVhY2goKHZlcnRleCwgaSkgPT4ge1xyXG4gICAgICAgIHRlcm5hcnlHcm91cFxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB2ZXJ0ZXgueClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCB2ZXJ0ZXgueSAtIChpID09PSAwID8gMTAgOiAtMjApKSAvLyBPZmZzZXQgbGFiZWxzXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0ZXJuYXJ5LWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsc1tpXSlcclxuICAgIH0pXHJcblxyXG4gICAgLy8gUGxvdCB0aGUgcG9pbnRzIGluc2lkZSB0aGUgdGVybmFyeSBwbG90XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2xhc3NlczsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJPZkNsYXNzZXMgLSBpOyBqKyspIHtcclxuICAgICAgICAgICAgY29uc3QgayA9IG51bWJlck9mQ2xhc3NlcyAtIGkgLSBqIC0gMSAvLyBFbnN1cmUgc3VtIG9mIGkgKyBqICsgayA9IG51bWJlck9mQ2xhc3NlcyAtIDFcclxuICAgICAgICAgICAgY29uc3QgeCA9ICgoaiAtIGspICogc2l6ZSkgLyAoMiAqIChudW1iZXJPZkNsYXNzZXMgLSAxKSkgLy8gSG9yaXpvbnRhbCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjb25zdCB5ID0gKGkgKiAtdHJpYW5nbGVIZWlnaHQpIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpIC8vIFZlcnRpY2FsIHBvc2l0aW9uXHJcblxyXG4gICAgICAgICAgICBjb25zdCBmaWxsID0gb3V0Lm1hcC5jbGFzc1RvRmlsbFN0eWxlKCkoaSwgaiwgaylcclxuXHJcbiAgICAgICAgICAgIHRlcm5hcnlHcm91cFxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCByYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGZpbGwpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGksIGosIGspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGksIGosIGspXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgaSwgaiwgaylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wxLCBlY2wyKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gb3V0Lmdlb18gPT09ICdXT1JMRCcgPyAnI2VtLXdvcmxkcmcnIDogJyNlbS1udXRzcmcnXHJcbiAgICAgICAgaWYgKG1hcC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSBzZWxlY3RvciA9ICcjZW0tdXNlci1yZWdpb25zJyAvLyBmb3IgdXNlci1kZWZpbmVkIGdlb21ldHJpZXNcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoYFtlY2wxXWApXHJcblxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVnaW9ucyB0byB3aGl0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBhbGxSZWdpb25zLmZpbHRlcihgW2VjbDE9JyR7ZWNsMX0nXWApLmZpbHRlcihgW2VjbDI9JyR7ZWNsMn0nXWApXHJcbiAgICAgICAgc2VsZWN0ZWRSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgcmVnaW9ucyB0byB0aGVpciBvcmlnaW5hbCBjb2xvcnMgb24gbW91c2VvdXRcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3IgPSBvdXQuZ2VvXyA9PT0gJ1dPUkxEJyA/ICcjZW0td29ybGRyZycgOiAnI2VtLW51dHNyZydcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHNlbGVjdG9yID0gJyNlbS11c2VyLXJlZ2lvbnMnIC8vIGZvciB1c2VyLWRlZmluZWQgZ2VvbWV0cmllc1xyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChgW2VjbDFdYClcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzY2FsZUJhbmQsIHNjYWxlTGluZWFyIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IGF4aXNMZWZ0LCBheGlzQm90dG9tIH0gZnJvbSAnZDMtYXhpcydcclxuaW1wb3J0IHsgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Rm9udFNpemVGcm9tQ2xhc3MsIGdldExlZ2VuZFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCB7IGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQtcGF0dGVybi1maWxsJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGZvciBjaG9yb3BsZXRoIG1hcHNcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IChpbmhlcml0KVxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgb3V0LmxhYmVsVHlwZSA9ICd0aHJlc2hvbGRzJyAvLyB0aHJlc2hvbGRzIHx8IHJhbmdlc1xyXG4gICAgLy90aGUgb3JkZXIgb2YgdGhlIGxlZ2VuZCBlbGVtZW50cy4gU2V0IHRvIGZhbHNlIHRvIGludmVydC5cclxuICAgIG91dC5hc2NlbmRpbmcgPSB0cnVlXHJcbiAgICAvL3RoZSB3aWR0aCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlV2lkdGggPSAyNVxyXG4gICAgLy90aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICBvdXQuc2hhcGVIZWlnaHQgPSAyMFxyXG4gICAgLy90aGUgc2VwYXJhdGlvbiBsaW5lIGxlbmd0aFxyXG4gICAgb3V0LnNlcExpbmVMZW5ndGggPSBvdXQuc2hhcGVXaWR0aFxyXG4gICAgLy90aWNrIGxpbmUgbGVuZ3RoIGluIHBpeGVsc1xyXG4gICAgb3V0LnRpY2tMZW5ndGggPSA0XHJcbiAgICAvL3RoZSBudW1iZXIgb2YgZGVjaW1hbCBmb3IgdGhlIGxlZ2VuZCBsYWJlbHNcclxuICAgIG91dC5kZWNpbWFscyA9IDBcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxlZ2VuZCBib3ggZWxlbWVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBsYWJlbFxyXG4gICAgb3V0LmxhYmVsT2Zmc2V0ID0gM1xyXG4gICAgLy9sYWJlbEZvcm1hdHRlciBmdW5jdGlvblxyXG4gICAgb3V0LmxhYmVsRm9ybWF0dGVyID0gbnVsbFxyXG4gICAgLy8gbWFudWFsbHkgZGVmaW5lIGxhYmVsc1xyXG4gICAgb3V0LmxhYmVscyA9IG51bGxcclxuXHJcbiAgICAvLyBIaXN0b2dyYW0gY29uZmlnIGFzIG5lc3RlZCBvYmplY3RcclxuICAgIG91dC5oaXN0b2dyYW0gPSBudWxsXHJcblxyXG4gICAgLy9kaXZlcmdpbmcgbGluZVxyXG4gICAgb3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwgPSB1bmRlZmluZWRcclxuICAgIG91dC5wb2ludE9mRGl2ZXJnZW5jZSA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnBvaW50T2ZEaXZlcmdlbmNlUGFkZGluZyA9IDdcclxuICAgIG91dC5kaXZlcmdpbmdMaW5lTGVuZ3RoID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuZGl2ZXJnaW5nQXJyb3dMZW5ndGggPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3Nob3cgbm8gZGF0YVxyXG4gICAgb3V0Lm5vRGF0YSA9IHRydWVcclxuICAgIC8vbm8gZGF0YSB0ZXh0IGxhYmVsXHJcbiAgICBvdXQubm9EYXRhVGV4dCA9ICdObyBkYXRhJ1xyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdoaXN0b2dyYW0nICYmIHR5cGVvZiBjb25maWdba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIG91dC5oaXN0b2dyYW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcclxuICAgICAgICAgICAgICAgICAgICBzaG93Q291bnRzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBzaG93UGVyY2VudGFnZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsUm90YXRpb246IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxGb3JtYXQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWcuaGlzdG9ncmFtLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBpZiAob3V0LmxnZy5ub2RlKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnXHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveCBhbmQgdGl0bGUgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94KClcclxuICAgICAgICAgICAgaWYgKG91dC50aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNzc0ZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpdGxlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmJveFBhZGRpbmcgKyBjc3NGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQudGl0bGUpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZXhpdCBlYXJseSBpZiBubyBjbGFzc2lmaWVyXHJcbiAgICAgICAgICAgIGlmICghbWFwLmNsYXNzVG9GaWxsU3R5bGUoKSkgcmV0dXJuXHJcblxyXG4gICAgICAgICAgICAvL3NldCBkZWZhdWx0IHBvaW50IG9mIGRpdmVyZ2VuY2UgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgICAgICBpZiAob3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwgJiYgIW91dC5wb2ludE9mRGl2ZXJnZW5jZSkgb3V0LnBvaW50T2ZEaXZlcmdlbmNlID0gbWFwLm51bWJlck9mQ2xhc3Nlc18gLyAyXHJcblxyXG4gICAgICAgICAgICBpZiAob3V0Lmhpc3RvZ3JhbSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlSGlzdG9ncmFtTGVnZW5kKClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGFiZWxUeXBlID09PSAncmFuZ2VzJykgY3JlYXRlUmFuZ2VzTGVnZW5kKClcclxuICAgICAgICAgICAgICAgIGVsc2UgY3JlYXRlVGhyZXNob2xkc0xlZ2VuZCgpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBjaG9yb3BsZXRoIGxlZ2VuZCBib3hcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gb3V0LmxnZy5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodFxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHBhdHRlcm4gZmlsbCBsZWdlbmQgaXRlbXMgQkVMT1cgdGhlIG1haW4gbGVnZW5kXHJcbiAgICAgICAgICAgIGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kKG1hcCwgb3V0LmxnZywge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVXaWR0aDogb3V0LnNoYXBlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBzaGFwZUhlaWdodDogb3V0LnNoYXBlSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgbGFiZWxPZmZzZXQ6IG91dC5sYWJlbE9mZnNldCxcclxuICAgICAgICAgICAgICAgIGJveFBhZGRpbmc6IG91dC5ib3hQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogbGVnZW5kSGVpZ2h0ICsgb3V0LmJveFBhZGRpbmcgKyA1LCAvLyA8PCB0aGlzIHNoaWZ0cyBwYXR0ZXJuIGxlZ2VuZCBkb3duXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIG91dC5zZXRCb3hEaW1lbnNpb24oKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRUaHJlc2hvbGRzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID1cclxuICAgICAgICAgICAgbWFwLnRocmVzaG9sZHNfLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gbWFwLnRocmVzaG9sZHNfXHJcbiAgICAgICAgICAgICAgICA6IEFycmF5LmZyb20oeyBsZW5ndGg6IG1hcC5udW1iZXJPZkNsYXNzZXNfIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKChfLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXAuY2xhc3NpZmllcigpLmludmVydEV4dGVudChpbmRleClbb3V0LmFzY2VuZGluZyA/IDAgOiAxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgxKSAvLyBSZW1vdmUgdGhlIGZpcnN0IGVudHJ5IGFuZCByZXR1cm4gdGhlIHJlc3QgYXMgYW4gYXJyYXlcclxuICAgICAgICByZXR1cm4gdGhyZXNob2xkc1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbG9ycygpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgcmV0dXJuIG1hcC5jb2xvcnNfXHJcbiAgICAgICAgICAgID8gbWFwLmNvbG9yc19cclxuICAgICAgICAgICAgOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBtYXAubnVtYmVyT2ZDbGFzc2VzXyB9KS5tYXAoKF8sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYXAuY2xhc3NUb0ZpbGxTdHlsZSgpKGluZGV4LCBtYXAubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERhdGEoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG1hcC5zdGF0RGF0YSgpLl9kYXRhXykubWFwKChpdGVtKSA9PiBpdGVtLnZhbHVlKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRocmVzaG9sZHNMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbSA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcbiAgICAgICAgLy8gTGFiZWwgZm9ybWF0dGVyXHJcbiAgICAgICAgY29uc3QgZm9ybWF0TGFiZWwgPSBvdXQubGFiZWxGb3JtYXR0ZXIgfHwgZm9ybWF0KGAuJHtvdXQuZGVjaW1hbHN9ZmApXHJcbiAgICAgICAgbGV0IGJhc2VZID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBpZiAob3V0LnRpdGxlKSBiYXNlWSA9IGJhc2VZICsgZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpICsgOCAvLyB0aXRsZSBzaXplICsgcGFkZGluZ1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5udW1iZXJPZkNsYXNzZXNfOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgeSA9IGJhc2VZICsgaSAqIG91dC5zaGFwZUhlaWdodFxyXG4gICAgICAgICAgICBjb25zdCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gb3V0LmFzY2VuZGluZyA/IG0ubnVtYmVyT2ZDbGFzc2VzKCkgLSBpIC0gMSA6IGlcclxuICAgICAgICAgICAgY29uc3QgZmlsbENvbG9yID0gbS5jbGFzc1RvRmlsbFN0eWxlKCkoZWNsLCBtLm51bWJlck9mQ2xhc3Nlc18pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlIGZvciBlYWNoIGNsYXNzXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1yZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZpbGxDb2xvcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgc2VwYXJhdGlvbiBsaW5lXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGdnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1zZXBhcmF0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2VwTGluZUxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGljayBsaW5lXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGdnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aWNrJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBvdXQuYm94UGFkZGluZyArIG91dC5zZXBMaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2VwTGluZUxlbmd0aCArIG91dC50aWNrTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBsYWJlbFxyXG4gICAgICAgICAgICBpZiAoaSA8IG0ubnVtYmVyT2ZDbGFzc2VzKCkgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGxhYmVsIHNvIHdlIGNhbiBtb3ZlIGl0IGluIGRyYXdEaXZlcmdpbmdMaW5lXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGxnZ1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBNYXRoLm1heChvdXQuc2hhcGVXaWR0aCwgb3V0LnNlcExpbmVMZW5ndGggKyBvdXQudGlja0xlbmd0aCkgKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vIH52ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChvdXQubGFiZWxzID8gb3V0LmxhYmVsc1tpXSA6IGZvcm1hdExhYmVsKG0uY2xhc3NpZmllcigpLmludmVydEV4dGVudChlY2wpW291dC5hc2NlbmRpbmcgPyAwIDogMV0pKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1hcmsgbGFiZWwgc28gd2UgY2FuIG1vdmUgaXQgaW4gZHJhd0RpdmVyZ2luZ0xpbmVcclxuICAgICAgICAgICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCAmJiBpID09IG91dC5wb2ludE9mRGl2ZXJnZW5jZSAtIDEpIGxhYmVsLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCBlbS1sZWdlbmQtbGFiZWwtZGl2ZXJnZW5jZScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgZGl2ZXJnaW5nIGxpbmUgaWYgYXBwbGljYWJsZS4gV2UgZHJhdyBpdCBhZnRlcndhcmRzIHNvIHRoYXQgd2UgY2FuIGNhbGN1bGF0ZSB0aGUgbWF4IGxlbmd0aCBvZiB0aGUgbGVnZW5kIGxhYmVscyBzbyBpdCBkb2VzbnQgY292ZXIgdGhlbVxyXG4gICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5udW1iZXJPZkNsYXNzZXNfOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gYmFzZVkgKyBpICogb3V0LnNoYXBlSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAvLyBwb2ludCBvZiBkaXZlcmdlbmNlIGluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd0RpdmVyZ2luZ0xpbmUoeSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ05vIGRhdGEnIGJveCBhbmQgbGFiZWwgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgIGlmIChvdXQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBiYXNlWSArIG0ubnVtYmVyT2ZDbGFzc2VzKCkgKiBvdXQuc2hhcGVIZWlnaHQgKyBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgb3V0Lm1hcC5ub0RhdGFGaWxsU3R5bGVfKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGxnZy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZXNMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2dcclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gZ2V0VGhyZXNob2xkcygpXHJcbiAgICAgICAgY29uc3QgZGVmYXVsdExhYmVsbGVyID0gKGxhYmVsLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSByZXR1cm4gYD4gJHt0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gMV19YCAvL3RvcFxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhyZXNob2xkcy5sZW5ndGgpIHJldHVybiBgPCAke3RocmVzaG9sZHNbMF19YCAvL2JvdHRvbVxyXG4gICAgICAgICAgICByZXR1cm4gYCR7dGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIGkgLSAxXX0gLSA8ICR7dGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIGldfSAgYCAvL2luLWJldHdlZW5cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGFiZWxGb3JtYXR0ZXIgPSBvdXQubGFiZWxGb3JtYXR0ZXIgfHwgZGVmYXVsdExhYmVsbGVyXHJcblxyXG4gICAgICAgIGxldCBiYXNlWSA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgaWYgKG91dC50aXRsZSkgYmFzZVkgPSBiYXNlWSArIGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1sZWdlbmQtdGl0bGUnKSArIDggLy8gdGl0bGUgc2l6ZSArIHBhZGRpbmdcclxuXHJcbiAgICAgICAgLy8gZm9yIGVhY2ggY2xhc3NcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5udW1iZXJPZkNsYXNzZXNfOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHkgPSBiYXNlWSArIGkgKiBvdXQuc2hhcGVIZWlnaHRcclxuICAgICAgICAgICAgY29uc3QgeCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IG91dC5hc2NlbmRpbmcgPyBtYXAubnVtYmVyT2ZDbGFzc2VzKCkgLSBpIC0gMSA6IGlcclxuICAgICAgICAgICAgY29uc3QgZmlsbENvbG9yID0gbWFwLmNsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG1hcC5udW1iZXJPZkNsYXNzZXNfKVxyXG4gICAgICAgICAgICBjb25zdCBpdGVtQ29udGFpbmVyID0gY29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgICAgIC8vIHNoaWZ0IGxlZ2VuZCBpdGVtcyBkb3duIGFmdGVyIHBvaW50IG9mIGRpdmVyZ2VuY2UgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgICAgICBpZiAob3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwgJiYgaSA+PSBvdXQucG9pbnRPZkRpdmVyZ2VuY2UpIHkgKz0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlUGFkZGluZ1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmaWxsQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykucmFpc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgc2VwYXJhdGlvbiBsaW5lXHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtc2VwYXJhdG9yJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNlcExpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIGxhYmVsc1xyXG4gICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIE1hdGgubWF4KG91dC5zaGFwZVdpZHRoLCBvdXQuc2VwTGluZUxlbmd0aCArIG91dC50aWNrTGVuZ3RoKSArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5sYWJlbHMgPyBvdXQubGFiZWxzW2ldIDogbGFiZWxGb3JtYXR0ZXIobWFwLmNsYXNzaWZpZXIoKS5pbnZlcnRFeHRlbnQoZWNsKVtvdXQuYXNjZW5kaW5nID8gMCA6IDFdLCBpKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgZGl2ZXJnaW5nIGxpbmUgaWYgYXBwbGljYWJsZS4gV2UgZHJhdyBpdCBhZnRlcndhcmRzIHNvIHRoYXQgd2UgY2FuIGNhbGN1bGF0ZSB0aGUgbWF4IGxlbmd0aCBvZiB0aGUgbGVnZW5kIGxhYmVscyBzbyBpdCBkb2VzbnQgY292ZXIgdGhlbVxyXG4gICAgICAgIGlmIChvdXQucG9pbnRPZkRpdmVyZ2VuY2VMYWJlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5udW1iZXJPZkNsYXNzZXNfOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gYmFzZVkgKyBpICogb3V0LnNoYXBlSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAvLyBwb2ludCBvZiBkaXZlcmdlbmNlIGluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd0RpdmVyZ2luZ0xpbmUoeSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ05vIGRhdGEnIGJveCBhbmQgbGFiZWwgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgIGlmIChvdXQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vRGF0YUl0ZW1Db250YWluZXIgPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0nKVxyXG4gICAgICAgICAgICBsZXQgeSA9IGJhc2VZICsgbWFwLm51bWJlck9mQ2xhc3NlcygpICogb3V0LnNoYXBlSGVpZ2h0ICsgb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgLy9pZiAob3V0LnBvaW50T2ZEaXZlcmdlbmNlKSB5ICs9IG91dC5wb2ludE9mRGl2ZXJnZW5jZVBhZGRpbmcgLy8gc2hpZnQgbGVnZW5kIGl0ZW1zIGRvd24gYWZ0ZXIgcG9pbnQgb2YgZGl2ZXJnZW5jZVxyXG4gICAgICAgICAgICBub0RhdGFJdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgb3V0Lm1hcC5ub0RhdGFGaWxsU3R5bGVfKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnJhaXNlKClcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG1hcCwgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG1hcC5pbnNldFRlbXBsYXRlc18sIG1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMobWFwLmluc2V0VGVtcGxhdGVzXywgbWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIG5vRGF0YUl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyBvdXQubGFiZWxPZmZzZXQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBvdXQuc2hhcGVIZWlnaHQgKiAwLjUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3RGl2ZXJnaW5nTGluZSh5KSB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gb3V0LmxnZy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtZGl2ZXJnZW5jZS1jb250YWluZXInKVxyXG4gICAgICAgIGNvbnN0IG1hcmtlckhlaWdodCA9IDZcclxuICAgICAgICBjb25zdCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICBpZiAob3V0LmxhYmVsVHlwZSA9PSAncmFuZ2VzJykgeSA9IHkgKyBvdXQucG9pbnRPZkRpdmVyZ2VuY2VQYWRkaW5nIC8gMiAvLyBtb3ZlIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHNwYWNlIGJldHdlZW4gbGVnZW5kIGl0ZW1cclxuICAgICAgICBsZXQgbWF4TGFiZWxMZW5ndGggPSBvdXQubGdnXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5lbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAubm9kZXMoKVxyXG4gICAgICAgICAgICAucmVkdWNlKChtYXgsIG5vZGUpID0+IE1hdGgubWF4KG1heCwgbm9kZS5nZXRCQm94KCkud2lkdGgpLCAwKVxyXG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBvdXQuZGl2ZXJnaW5nTGluZUxlbmd0aCB8fCBtYXhMYWJlbExlbmd0aCArIG91dC5ib3hQYWRkaW5nICsgb3V0LnNoYXBlV2lkdGggKyAxMCAvLyArIHBhZGRpbmdcclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aGUgaG9yaXpvbnRhbCBkaXZlcmdlbmNlIGxpbmVcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIHgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIHggKyBsaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWRpdmVyZ2luZy1saW5lJylcclxuXHJcbiAgICAgICAgLy8gZGl2ZXJnZW5jZSBsaW5lIHdpdGggdXAgYW5kIGRvd24gYXJyb3dzXHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gb3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwuc3BsaXQoJ3wnKVxyXG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25MaW5lTGVuZ3RoID0gb3V0LmRpdmVyZ2luZ0Fycm93TGVuZ3RoIHx8IDMwXHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkxpbmVYID0geCArIGxpbmVMZW5ndGhcclxuICAgICAgICAgICAgLy8gQWRkIGFycm93aGVhZCBtYXJrZXIgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICBjb25zdCBkZWZzID0gY29udGFpbmVyLmFwcGVuZCgnZGVmcycpXHJcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kKCdtYXJrZXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2Fycm93aGVhZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCBtYXJrZXJIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgbWFya2VySGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3JlZlgnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3JlZlknLCBtYXJrZXJIZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIGAwIDAsICR7bWFya2VySGVpZ2h0fSAke21hcmtlckhlaWdodCAvIDJ9LCAwICR7bWFya2VySGVpZ2h0fWApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcblxyXG4gICAgICAgICAgICAvLyBVcHdhcmQgbGluZSB3aXRoIGFycm93aGVhZFxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1kaXZlcmdpbmctbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBkaXJlY3Rpb25MaW5lWClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkgLSBkaXJlY3Rpb25MaW5lTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ21hcmtlci1lbmQnLCAndXJsKCNhcnJvd2hlYWQpJylcclxuXHJcbiAgICAgICAgICAgIC8vIERvd253YXJkIGxpbmUgd2l0aCBhcnJvd2hlYWRcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtZGl2ZXJnaW5nLWxpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZGlyZWN0aW9uTGluZVgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZGlyZWN0aW9uTGluZVgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5ICsgZGlyZWN0aW9uTGluZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXItZW5kJywgJ3VybCgjYXJyb3doZWFkKScpXHJcblxyXG4gICAgICAgICAgICAvLyBMYWJlbHMgZm9yIHVwd2FyZCBhbmQgZG93bndhcmQgbGluZXNcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBkaXJlY3Rpb25MaW5lWCArIDEwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5IC0gZGlyZWN0aW9uTGluZUxlbmd0aCArIDEwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChsYWJlbHNbMF0pXHJcblxyXG4gICAgICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGRpcmVjdGlvbkxpbmVYICsgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHkgKyBkaXJlY3Rpb25MaW5lTGVuZ3RoIC0gMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGxhYmVsc1sxXSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBqdXN0IHRoZSBzaW5nbGUgbGFiZWxcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtZGl2ZXJnaW5nLWxhYmVsIGVtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHggKyBsaW5lTGVuZ3RoICsgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnBvaW50T2ZEaXZlcmdlbmNlTGFiZWwpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL21vdmUgdGhyZXNob2xkIGxhYmVsIG91dCBvZiB0aGUgd2F5IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgaWYgKG91dC5sYWJlbFR5cGUgPT0gJ3RocmVzaG9sZHMnKSB7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBpdCB0byBlbmQgb2YgbGluZVxyXG4gICAgICAgICAgICAgICAgb3V0LmxnZy5zZWxlY3RBbGwoJy5lbS1sZWdlbmQtbGFiZWwtZGl2ZXJnZW5jZScpLmF0dHIoJ3gnLCB4ICsgbGluZUxlbmd0aCArIDEwKVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRpY2sgbGluZVxyXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aWNrJylcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXR0cigneDEnLCB4ICsgbGluZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXR0cigneTEnLCB5KVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5hdHRyKCd4MicsIHggKyBsaW5lTGVuZ3RoICsgNSlcclxuICAgICAgICAgICAgICAgIC8vICAgICAuYXR0cigneTInLCB5KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgaXQgc28gaXQgZG9lc250IGNsYXNoIHdpdGggcG9pbnRPZkRpdmVyZ2VuY2VMYWJlbFxyXG4gICAgICAgICAgICAgICAgb3V0LmxnZy5zZWxlY3RBbGwoJy5lbS1sZWdlbmQtbGFiZWwtZGl2ZXJnZW5jZScpLnJlbW92ZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSGlzdG9ncmFtTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSBnZXRUaHJlc2hvbGRzKClcclxuICAgICAgICBjb25zdCBjb2xvcnMgPSBnZXRDb2xvcnMoKVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXREYXRhKClcclxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IG91dC5oaXN0b2dyYW0ub3JpZW50YXRpb24gfHwgJ2hvcml6b250YWwnXHJcbiAgICAgICAgY29uc3Qgc2hvd0NvdW50cyA9IG91dC5oaXN0b2dyYW0uc2hvd0NvdW50c1xyXG4gICAgICAgIGNvbnN0IHNob3dQZXJjZW50YWdlcyA9IG91dC5oaXN0b2dyYW0uc2hvd1BlcmNlbnRhZ2VzXHJcbiAgICAgICAgY29uc3QgbGFiZWxSb3RhdGlvbiA9IG91dC5oaXN0b2dyYW0ubGFiZWxSb3RhdGlvbiB8fCAwXHJcbiAgICAgICAgY29uc3QgbGFiZWxGb3JtYXQgPSBvdXQuaGlzdG9ncmFtLmxhYmVsRm9ybWF0XHJcbiAgICAgICAgY29uc3QgbGFiZWxGb3JtYXR0ZXIgPSBvdXQuaGlzdG9ncmFtLmxhYmVsRm9ybWF0dGVyXHJcblxyXG4gICAgICAgIGxldCBjb3VudHMgPSBuZXcgQXJyYXkobWFwLm51bWJlck9mQ2xhc3Nlc18pLmZpbGwoMClcclxuICAgICAgICBkYXRhLmZvckVhY2goKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzSW5kZXggPSBtYXAuY2xhc3NpZmllcigpKHZhbHVlKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsYXNzSW5kZXggPT09ICdudW1iZXInICYmIGNsYXNzSW5kZXggPj0gMCAmJiBjbGFzc0luZGV4IDwgY291bnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY291bnRzW2NsYXNzSW5kZXhdKytcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNvbnN0IHJldmVyc2VkQ291bnRzID0gY291bnRzLnNsaWNlKCkucmV2ZXJzZSgpXHJcbiAgICAgICAgY29uc3QgdG90YWwgPSBjb3VudHMucmVkdWNlKChzdW0sIGQpID0+IHN1bSArIGQsIDApXHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRQZXJjZW50YWdlcyA9IHJldmVyc2VkQ291bnRzLm1hcCgoZCkgPT4gKHRvdGFsID4gMCA/IChkIC8gdG90YWwpICogMTAwIDogMCkpXHJcblxyXG4gICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuICAgICAgICBjb25zdCBiYXNlWSA9IG91dC5ib3hQYWRkaW5nICsgKG91dC50aXRsZSA/IGdldEZvbnRTaXplRnJvbUNsYXNzKCdlbS1sZWdlbmQtdGl0bGUnKSArIDM4IDogMzApXHJcbiAgICAgICAgY29uc3Qgc3ZnV2lkdGggPSAzMDBcclxuICAgICAgICBjb25zdCBzdmdIZWlnaHQgPSAzMDBcclxuICAgICAgICBjb25zdCBiYXJHcm91cCA9IGxnZy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtaGlzdG9ncmFtJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke2Jhc2VZfSlgKVxyXG5cclxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgZHJhd1ZlcnRpY2FsSGlzdG9ncmFtKGJhckdyb3VwKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRyYXdIb3Jpem9udGFsSGlzdG9ncmFtKGJhckdyb3VwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd1ZlcnRpY2FsSGlzdG9ncmFtKGJhckdyb3VwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IHsgdG9wOiAyMCwgcmlnaHQ6IDYwLCBib3R0b206IDQwLCBsZWZ0OiAxNTAgfVxyXG4gICAgICAgICAgICBjb25zdCB5U2NhbGUgPSBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihyZXZlcnNlZENvdW50cy5tYXAoKF8sIGkpID0+IGkpKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFttYXJnaW4udG9wLCBzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tXSlcclxuICAgICAgICAgICAgICAgIC5wYWRkaW5nKDAuMSlcclxuICAgICAgICAgICAgY29uc3QgeFNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgbWF4KHJldmVyc2VkQ291bnRzKV0pXHJcbiAgICAgICAgICAgICAgICAubmljZSgpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoW21hcmdpbi5sZWZ0LCBzdmdXaWR0aCAtIG1hcmdpbi5yaWdodF0pXHJcblxyXG4gICAgICAgICAgICAvLyBCYXJzXHJcbiAgICAgICAgICAgIGJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHJldmVyc2VkQ291bnRzKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1oaXN0b2dyYW0tYmFyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKF8sIGkpID0+IHlTY2FsZShpKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgeVNjYWxlLmJhbmR3aWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQpID0+IHhTY2FsZShkKSAtIG1hcmdpbi5sZWZ0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoXywgaSkgPT4gY29sb3JzW2NvbG9ycy5sZW5ndGggLSBpIC0gMV0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsJywgKF8sIGkpID0+IGkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGhhbmRsZU1vdXNlT3ZlcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBoYW5kbGVNb3VzZU91dClcclxuXHJcbiAgICAgICAgICAgIC8vIEJhciBsYWJlbHNcclxuICAgICAgICAgICAgaWYgKHNob3dDb3VudHMgfHwgc2hvd1BlcmNlbnRhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBiYXJHcm91cFxyXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQuZW0taGlzdG9ncmFtLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YShyZXZlcnNlZENvdW50cylcclxuICAgICAgICAgICAgICAgICAgICAuam9pbigndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCBlbS1oaXN0b2dyYW0tbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IHhTY2FsZShkKSArIDUpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoXywgaSkgPT4geVNjYWxlKGkpICsgeVNjYWxlLmJhbmR3aWR0aCgpIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoKF8sIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKHJldmVyc2VkUGVyY2VudGFnZXNbaV0sIHJldmVyc2VkQ291bnRzW2ldLCBpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG93UGVyY2VudGFnZXMgPyBgJHtyZXZlcnNlZFBlcmNlbnRhZ2VzW2ldLnRvRml4ZWQoMSl9JWAgOiByZXZlcnNlZENvdW50c1tpXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEF4aXNcclxuICAgICAgICAgICAgYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWxlZ2VuZC1oaXN0b2dyYW0teS1heGlzJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCAwKWApXHJcbiAgICAgICAgICAgICAgICAuY2FsbChcclxuICAgICAgICAgICAgICAgICAgICBheGlzTGVmdCh5U2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZU91dGVyKDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgoXywgaSkgPT4gZm9ybWF0VGlja0xhYmVsKGkpKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd0hvcml6b250YWxIaXN0b2dyYW0oYmFyR3JvdXApIHtcclxuICAgICAgICAgICAgY29uc3QgbWFyZ2luID0geyB0b3A6IDIwLCByaWdodDogNjAsIGJvdHRvbTogNDAsIGxlZnQ6IDEwIH1cclxuICAgICAgICAgICAgY29uc3QgeFNjYWxlID0gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgICAgIC5kb21haW4ocmV2ZXJzZWRDb3VudHMubWFwKChfLCBpKSA9PiBpKSlcclxuICAgICAgICAgICAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHN2Z1dpZHRoIC0gbWFyZ2luLnJpZ2h0XSlcclxuICAgICAgICAgICAgICAgIC5wYWRkaW5nKDAuMSlcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHlTY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIG1heChyZXZlcnNlZENvdW50cyldKVxyXG4gICAgICAgICAgICAgICAgLm5pY2UoKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFtzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tLCBtYXJnaW4udG9wXSlcclxuXHJcbiAgICAgICAgICAgIC8vIEJhcnNcclxuICAgICAgICAgICAgYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocmV2ZXJzZWRDb3VudHMpXHJcbiAgICAgICAgICAgICAgICAuam9pbigncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWhpc3RvZ3JhbS1iYXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoXywgaSkgPT4geFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4geVNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeFNjYWxlLmJhbmR3aWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkKSA9PiBzdmdIZWlnaHQgLSBtYXJnaW4uYm90dG9tIC0geVNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoXywgaSkgPT4gY29sb3JzW2NvbG9ycy5sZW5ndGggLSBpIC0gMV0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsJywgKF8sIGkpID0+IGkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGhhbmRsZU1vdXNlT3ZlcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBoYW5kbGVNb3VzZU91dClcclxuXHJcbiAgICAgICAgICAgIC8vIEJhciBsYWJlbHMgKGNlbnRlcmVkKVxyXG4gICAgICAgICAgICBpZiAoc2hvd0NvdW50cyB8fCBzaG93UGVyY2VudGFnZXMpIHtcclxuICAgICAgICAgICAgICAgIGJhckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dC5lbS1oaXN0b2dyYW0tbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHJldmVyc2VkQ291bnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsIGVtLWhpc3RvZ3JhbS1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoXywgaSkgPT4geFNjYWxlKGkpICsgeFNjYWxlLmJhbmR3aWR0aCgpIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiB5U2NhbGUoZCkgLSA1KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KChfLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbEZvcm1hdHRlcihyZXZlcnNlZFBlcmNlbnRhZ2VzW2ldLCByZXZlcnNlZENvdW50c1tpXSwgaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvd1BlcmNlbnRhZ2VzID8gYCR7cmV2ZXJzZWRQZXJjZW50YWdlc1tpXS50b0ZpeGVkKDEpfSVgIDogcmV2ZXJzZWRDb3VudHNbaV1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBeGlzIChvbmx5IGZvciBsYWJlbFR5cGUgPT09ICd0aHJlc2hvbGRzJylcclxuICAgICAgICAgICAgY29uc3QgYXhpc0dyb3VwID0gYmFyR3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWxlZ2VuZC1oaXN0b2dyYW0teC1heGlzJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7c3ZnSGVpZ2h0IC0gbWFyZ2luLmJvdHRvbX0pYClcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQubGFiZWxUeXBlID09PSAndGhyZXNob2xkcycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHJlc2hvbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFuZEluZGV4ID0gdGhyZXNob2xkcy5sZW5ndGggLSBpIC0gMVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4U2NhbGUoYmFuZEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQpIHBvc2l0aW9ucy5wdXNoKHggKyB4U2NhbGUuYmFuZHdpZHRoKCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRhcnlTY2FsZSA9IHNjYWxlTGluZWFyKCkuZG9tYWluKFswLCBzdmdXaWR0aF0pLnJhbmdlKFswLCBzdmdXaWR0aF0pXHJcblxyXG4gICAgICAgICAgICAgICAgYXhpc0dyb3VwLmNhbGwoXHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0JvdHRvbShib3VuZGFyeVNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyhwb3NpdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KChfLCBpKSA9PiAobGFiZWxGb3JtYXQgPyBsYWJlbEZvcm1hdCh0aHJlc2hvbGRzW2ldLCBpKSA6IHRocmVzaG9sZHNbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplT3V0ZXIoMClcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF4aXNHcm91cC5jYWxsKGF4aXNCb3R0b20oeFNjYWxlKS50aWNrU2l6ZU91dGVyKDApLnRpY2tTaXplKDApKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBheGlzR3JvdXBcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCBlbS10aWNrLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGByb3RhdGUoLSR7bGFiZWxSb3RhdGlvbn0pYClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdFRpY2tMYWJlbChpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQubGFiZWxUeXBlID09PSAndGhyZXNob2xkcycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJyZWFrSW5kZXggPSB0aHJlc2hvbGRzLmxlbmd0aCAtIGkgLSAxXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1ticmVha0luZGV4XSA/PyAnJ1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHJldHVybiBgPiAke3RocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSAxXX1gXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhyZXNob2xkcy5sZW5ndGgpIHJldHVybiBgPCAke3RocmVzaG9sZHNbMF19YFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpIC0gMV19IC0gPCAke3RocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpXX1gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlT3ZlcihfLCBpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKS5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkSW5kZXggPSBjb2xvcnMubGVuZ3RoIC0gMSAtIHBhcnNlSW50KGVjbCwgMTApXHJcbiAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCByZXZlcnNlZEluZGV4KVxyXG4gICAgICAgICAgICBpZiAobWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhtYXAuaW5zZXRUZW1wbGF0ZXNfLCBtYXAuc3ZnSWQsIGhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VPdXQoXywgaSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcykuc3R5bGUoJ3N0cm9rZScsICdub25lJylcclxuICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG1hcClcclxuICAgICAgICAgICAgaWYgKG1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMobWFwLmluc2V0VGVtcGxhdGVzXywgbWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGlnaGxpZ2h0IHNlbGVjdGVkIHJlZ2lvbnMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRMZWdlbmRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHJlZ2lvbnMgdG8gd2hpdGVcclxuICAgICAgICBhbGxSZWdpb25zLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWdpb25zID0gYWxsUmVnaW9ucy5maWx0ZXIoXCJbZWNsPSdcIiArIGVjbCArIFwiJ11cIilcclxuICAgICAgICBzZWxlY3RlZFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHJlZ2lvbnNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGFsbCByZWdpb25zIHRvIHRoZWlyIG9yaWdpbmFsIGNvbG9ycyBvbiBtb3VzZW91dFxyXG4gICAgZnVuY3Rpb24gdW5oaWdobGlnaHRSZWdpb25zKG1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKHNlbGVjdG9yKS5zZWxlY3RBbGwoJ1tlY2xdJylcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsUmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vZGVwcmVjYXRlZFxyXG4gICAgb3V0LmxhYmVsRGVjTmIgPSAodikgPT4gKGNvbnNvbGUud2FybignbGFiZWxEZWNOYiBpcyBub3cgREVQUkVDQVRFRC4gUGxlYXNlIHVzZSBkZWNpbWFscyBpbnN0ZWFkLicpLCBvdXQpXHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgKiBhcyBMZWdlbmQgZnJvbSAnLi9sZWdlbmQnXHJcbmltcG9ydCB7IGZvcm1hdERlZmF1bHRMb2NhbGUgfSBmcm9tICdkMy1mb3JtYXQnXHJcblxyXG4vL3NldCBsZWdlbmQgbGFiZWxzIGxvY2FsZVxyXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcclxuICAgIGRlY2ltYWw6ICcuJyxcclxuICAgIHRob3VzYW5kczogJyAnLFxyXG4gICAgZ3JvdXBpbmc6IFszXSxcclxuICAgIGN1cnJlbmN5OiBbJycsICfigqwnXSxcclxufSlcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbCBtYXBcclxuICpcclxuICogQHBhcmFtIHsqfSBtYXBcclxuICovXHJcbmV4cG9ydCBjb25zdCBsZWdlbmQgPSBmdW5jdGlvbiAobWFwLCBjb25maWcpIHtcclxuICAgIC8vYnVpbGQgZ2VuZXJpYyBsZWdlbmQgb2JqZWN0IGZvciB0aGUgbWFwXHJcbiAgICBjb25zdCBvdXQgPSBMZWdlbmQubGVnZW5kKG1hcClcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSAnY29sb3JMZWdlbmQnIHx8IGtleSA9PSAnc2l6ZUxlZ2VuZCcpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgaW4gb3V0W2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIGNvbmZpZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRba2V5XVtwXSA9IGNvbmZpZ1trZXldW3BdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jb2xvckxlZ2VuZCA9PSBmYWxzZSkgb3V0LmNvbG9yTGVnZW5kID0gZmFsc2VcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgY29uc3QgbSA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBsZWdlbmQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAobS5sZWdlbmRfKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbS5sZWdlbmRfKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHAgaW4gb3V0W2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9vdmVycmlkZSBlYWNoIHByb3BlcnR5IGluIHNpemUgYW5kIGNvbG9yIGxlZ2VuZCBtLmxlZ2VuZF9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ubGVnZW5kX1trZXldW3BdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gbS5sZWdlbmRfW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0W2tleV0gPSBtLmxlZ2VuZF9ba2V5XVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIGJ1aWxkRmxvd0xlZ2VuZCgpXHJcblxyXG4gICAgICAgIC8vc2V0IGxlZ2VuZCBib3ggZGltZW5zaW9uc1xyXG4gICAgICAgIG91dC5zZXRCb3hEaW1lbnNpb24oKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIGEgbGVnZW5kIHdoaWNoIGlsbHVzdHJhdGVzIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgb2YgZGlmZmVyZW50IGZsb3cgc3ltYm9sIHNpemVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBtYXAgbWFwIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRhaW5lciBwYXJlbnQgbGVnZW5kIG9iamVjdCBmcm9tIGNvcmUvbGVnZW5kLmpzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRmxvd0xlZ2VuZChtKSB7fVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGdldEZvbnRTaXplRnJvbUNsYXNzIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRQYXR0ZXJuRmlsbExlZ2VuZChtYXAsIGNvbnRhaW5lciwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgc2hhcGVXaWR0aCA9IDI1LFxyXG4gICAgICAgIHNoYXBlSGVpZ2h0ID0gMjAsXHJcbiAgICAgICAgbGFiZWxPZmZzZXQgPSAzLFxyXG4gICAgICAgIGJveFBhZGRpbmcgPSA1LFxyXG4gICAgICAgIG9mZnNldFkgPSAwLCAvLyA8PCBuZXdcclxuICAgIH0gPSBvcHRpb25zXHJcblxyXG4gICAgaWYgKCFtYXAucGF0dGVybkZpbGxfKSByZXR1cm5cclxuXHJcbiAgICBtYXAucGF0dGVybkZpbGxfLmZvckVhY2goKGNmZywgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoIWNmZy5sZWdlbmRMYWJlbCkgcmV0dXJuIC8vIHNraXAgaWYgbm8gbGFiZWxcclxuXHJcbiAgICAgICAgY29uc3QgeSA9IG9mZnNldFkgKyBpbmRleCAqIChzaGFwZUhlaWdodCArIGJveFBhZGRpbmcpXHJcblxyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBjb250YWluZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0gcGF0dGVybi1maWxsLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIGNvbnN0IHBhdHRlcm5Db2xvciA9IGNmZy5jb2xvciB8fCAnIzAwMCcgLy8gZmFsbGJhY2sgdG8gYmxhY2sgaWYgbm8gY29sb3IgcHJvdmlkZWRcclxuICAgICAgICBjb25zdCBpc1doaXRlUGF0dGVybiA9IHBhdHRlcm5Db2xvci50b0xvd2VyQ2FzZSgpID09PSAnI2ZmZicgfHwgcGF0dGVybkNvbG9yLnRvTG93ZXJDYXNlKCkgPT09ICd3aGl0ZSdcclxuXHJcbiAgICAgICAgLy8gQWRkIGJhY2tncm91bmQgaWYgcGF0dGVybiBpcyB3aGl0ZVxyXG4gICAgICAgIGlmIChpc1doaXRlUGF0dGVybikge1xyXG4gICAgICAgICAgICBpdGVtLmFwcGVuZCgncmVjdCcpLmF0dHIoJ3gnLCBib3hQYWRkaW5nKS5hdHRyKCd5JywgeSkuYXR0cignd2lkdGgnLCBzaGFwZVdpZHRoKS5hdHRyKCdoZWlnaHQnLCBzaGFwZUhlaWdodCkuYXR0cignZmlsbCcsICcjZGRkJykgLy8gbGlnaHQgZ3JheSBiYWNrZ3JvdW5kXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgcGF0dGVybiBvdmVybGF5XHJcbiAgICAgICAgaXRlbS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIGJveFBhZGRpbmcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGB1cmwoIyR7Y2ZnLnBhdHRlcm5JZCB8fCBjZmcucGF0dGVybn0pYClcclxuXHJcbiAgICAgICAgLy8gQWRkIGxhYmVsXHJcbiAgICAgICAgaXRlbS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBib3hQYWRkaW5nICsgc2hhcGVXaWR0aCArIGxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHkgKyBzaGFwZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAudGV4dChjZmcubGVnZW5kTGFiZWwpXHJcbiAgICB9KVxyXG59XHJcbiIsImltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0ICogYXMgTGVnZW5kIGZyb20gJy4vbGVnZW5kJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2wgbWFwXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy9zcGFjaW5nIGJldHdlZW4gY29sb3IgJiBzaXplIGxlZ2VuZHMgKGlmIGFwcGxpY2FibGUpXHJcbiAgICBvdXQubGVnZW5kU3BhY2luZyA9IDE1XHJcblxyXG4gICAgLy9zaXplIGxlZ2VuZCBjb25maWcgKGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIHZhbHVlcyBvZiBkaWZmZXJlbnQgcGllIHNpemVzKVxyXG4gICAgb3V0LnNpemVMZWdlbmQgPSB7XHJcbiAgICAgICAgdGl0bGU6IG51bGwsXHJcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAzMCwgLy9wYWRkaW5nIGJldHdlZW4gdGl0bGUgYW5kIGJvZHlcclxuICAgICAgICB2YWx1ZXM6IG51bGwsXHJcbiAgICB9XHJcblxyXG4gICAgLy9jb2xvdXIgbGVnZW5kIGNvbmZpZyAobGVnZW5kIGlsbHVzdHJhdGluZyB0aGUgdmFsdWVzIG9mIGRpZmZlcmVudCBwaWUgY29sb3VycylcclxuICAgIG91dC5jb2xvckxlZ2VuZCA9IHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICBsYWJlbE9mZnNldDogNSwgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICAgICAgc2hhcGVXaWR0aDogMjUsIC8vdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICAgICAgc2hhcGVIZWlnaHQ6IDIwLCAvL3RoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgICAgICBzaGFwZVBhZGRpbmc6IDUsIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgICAgIG5vRGF0YTogdHJ1ZSwgLy9zaG93IG5vIGRhdGFcclxuICAgICAgICBub0RhdGFUZXh0OiAnTm8gZGF0YScsIC8vbm8gZGF0YSBsYWJlbCB0ZXh0XHJcbiAgICB9XHJcblxyXG4gICAgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ID0gMFxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09ICdjb2xvckxlZ2VuZCcgfHwga2V5ID09ICdzaXplTGVnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgZWFjaCBwcm9wZXJ0eSBpbiBzaXplIGFuZCBjb2xvciBsZWdlbmQgY29uZmlnc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdba2V5XVtwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtrZXldW3BdID0gY29uZmlnW2tleV1bcF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9IGNvbmZpZ1trZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbmZpZygpXHJcbiAgICAgICAgb3V0LnVwZGF0ZUNvbnRhaW5lcigpXHJcblxyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vIGxlZ2VuZCBmb3Igc2l6ZXNcclxuICAgICAgICBpZiAobWFwLnNpemVDbGFzc2lmaWVyXykge1xyXG4gICAgICAgICAgICBidWlsZFNpemVMZWdlbmQoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGVnZW5kIGZvciBwcyBjb2xvciB2YWx1ZXNcclxuICAgICAgICBidWlsZENvbG9yTGVnZW5kKClcclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgd2hpY2ggaWxsdXN0cmF0ZXMgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgcGllIGNoYXJ0IHNpemVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBtIG1hcFxyXG4gICAgICogQHBhcmFtIHsqfSBsZ2cgcGFyZW50IGxlZ2VuZCBvYmplY3QgZnJvbSBjb3JlL2xlZ2VuZC5qc1xyXG4gICAgICogQHBhcmFtIHsqfSBjb25maWcgc2l6ZSBsZWdlbmQgY29uZmlnIG9iamVjdCAoc2l6ZUxlZ2VuZCBvYmplY3Qgc3BlY2lmaWVkIGFzIHByb3BlcnR5IG9mIGxlZ2VuZCgpIGNvbmZpZyBvYmplY3QpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2l6ZUxlZ2VuZCgpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBvdXQubWFwXHJcbiAgICAgICAgY29uc3QgY29uZmlnID0gb3V0LnNpemVMZWdlbmRcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZS1zaXplLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IG1hcC5zaXplQ2xhc3NpZmllcl8uZG9tYWluKClcclxuXHJcbiAgICAgICAgLy8gQXNzaWduIGRlZmF1bHQgY2lyY2xlIHJhZGlpIGlmIG5vbmUgc3BlY2lmaWVkIGJ5IHVzZXJcclxuICAgICAgICBpZiAoIWNvbmZpZy52YWx1ZXMpIHtcclxuICAgICAgICAgICAgY29uZmlnLnZhbHVlcyA9IFtNYXRoLmZsb29yKGRvbWFpblsxXSksIE1hdGguZmxvb3IoZG9tYWluWzBdKV1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBjaXJjbGUgc2l6ZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxlZ2VuZFxyXG4gICAgICAgIGxldCBtYXhTaXplID0gbWFwLnNpemVDbGFzc2lmaWVyXyhtYXgoY29uZmlnLnZhbHVlcykpXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgdGl0bGUgdG8gdGhlIGNvbnRhaW5lciBpZiBhdmFpbGFibGVcclxuICAgICAgICBpZiAoIWNvbmZpZy50aXRsZSAmJiBvdXQudGl0bGUpIGNvbmZpZy50aXRsZSA9IG91dC50aXRsZSAvLyBBbGxvdyByb290IGxlZ2VuZCB0aXRsZVxyXG4gICAgICAgIGxldCB0aXRsZUhlaWdodCA9IDAgLy8gVGhpcyB3aWxsIGJlIGFkanVzdGVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHRpdGxlIGV4aXN0c1xyXG4gICAgICAgIGlmIChjb25maWcudGl0bGUpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKSAvLyBQb3NpdGlvbiB0aGUgdGl0bGUgYXQgdGhlIGxlZnQgZWRnZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKSAvLyBUaXRsZSBhdCB0b3AsIHdpdGhpbiBwYWRkaW5nXHJcbiAgICAgICAgICAgICAgICAudGV4dChjb25maWcudGl0bGUpXHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3QgdGl0bGUgaGVpZ2h0ICh1c2luZyB0aGUgdGl0bGUgZm9udCBzaXplIGFzIGEgcHJveHkpXHJcbiAgICAgICAgICAgIHRpdGxlSGVpZ2h0ID0gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyArIGNvbmZpZy50aXRsZVBhZGRpbmdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdyBwb3NpdGlvbiB0aGUgY2lyY2xlcyAqKmJlbG93KiogdGhlIHRpdGxlXHJcbiAgICAgICAgbGV0IHkgPSB0aXRsZUhlaWdodCArIG91dC5ib3hQYWRkaW5nICsgbWF4U2l6ZSAqIDIgLy8gUG9zaXRpb24gY2lyY2xlcyBhZnRlciB0aXRsZSBoZWlnaHRcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBsZWdlbmQgY2lyY2xlc1xyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1zID0gY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShjb25maWcudmFsdWVzKVxyXG4gICAgICAgICAgICAuam9pbignZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtaXRlbScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWF4U2l6ZSArIG91dC5ib3hQYWRkaW5nfSwgJHt5fSlgKSAvLyBEeW5hbWljYWxseSBtb3ZlIHRoZSBjaXJjbGVzIGRvd25cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGNpcmNsZXMgdG8gZWFjaCBncm91cFxyXG4gICAgICAgIGxlZ2VuZEl0ZW1zXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtY2lyY2xlJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgKGQpID0+IC1tYXAuc2l6ZUNsYXNzaWZpZXJfKGQpKSAvLyBQb3NpdGlvbiBjaXJjbGVzIGJhc2VkIG9uIHRoZWlyIHNpemVcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBtYXAuc2l6ZUNsYXNzaWZpZXJfKSAvLyBSYWRpdXMgaXMgY2FsY3VsYXRlZCBmcm9tIHNpemUgY2xhc3NpZmllclxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgbGFiZWxzIHRvIGVhY2ggZ3JvdXBcclxuICAgICAgICBsZWdlbmRJdGVtc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+IC0yICogbWFwLnNpemVDbGFzc2lmaWVyXyhkKSAtIG91dC5sYWJlbEZvbnRTaXplIC0gMikgLy8gUG9zaXRpb24gbGFiZWxzIHJlbGF0aXZlIHRvIGNpcmNsZXNcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAzMCkgLy8gU2V0IHRoZSB4LXBvc2l0aW9uIGZvciB0aGUgbGFiZWxzXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4bWw6c3BhY2UnLCAncHJlc2VydmUnKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gZC50b0xvY2FsZVN0cmluZygnZW4nKS5yZXBsYWNlKC8sL2dpLCAnICcpKSAvLyBGb3JtYXQgdGhlIGxhYmVsIHRleHRcclxuXHJcbiAgICAgICAgLy8gQWRkIGxpbmVzIHBvaW50aW5nIHRvIHRoZSB0b3Agb2YgdGhlIGNvcnJlc3BvbmRpbmcgY2lyY2xlXHJcbiAgICAgICAgbGVnZW5kSXRlbXNcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1waWUtc2l6ZS1sZWdlbmQtbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIDMwKVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAoZCkgPT4gLTIgKiBtYXAuc2l6ZUNsYXNzaWZpZXJfKGQpKSAvLyBQb3NpdGlvbiBsaW5lcyByZWxhdGl2ZSB0byBjaXJjbGVzXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIChkKSA9PiAtMiAqIG1hcC5zaXplQ2xhc3NpZmllcl8oZCkpIC8vIFNhbWUgcG9zaXRpb24gZm9yIHRoZSB5MiB0byBtYWtlIGEgaG9yaXpvbnRhbCBsaW5lXHJcblxyXG4gICAgICAgIC8vIFNhdmUgdGhlIGhlaWdodCB2YWx1ZSBmb3IgcG9zaXRpb25pbmcgdGhlIGNvbG9yIGxlZ2VuZCAoaWYgbmVlZGVkKVxyXG4gICAgICAgIG91dC5fc2l6ZUxlZ2VuZEhlaWdodCA9IHlcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgb2YgdGhlIHBpZSBjaGFydHMnIGRpZmZlcmVudCBjb2xvdXJzXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZENvbG9yTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBjb25maWcgPSBvdXQuY29sb3JMZWdlbmRcclxuICAgICAgICAvL2NvbnRhaW5lclxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dC5sZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tcGllLWNvbG9yLWxlZ2VuZCcpXHJcblxyXG4gICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChjb25maWcudGl0bGUpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ICsgb3V0LmxlZ2VuZFNwYWNpbmcgKyBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoY29uZmlnLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICBsZXQgaSA9IDBcclxuICAgICAgICBjb25zdCBzY3MgPSBtYXAuY2F0Q29sb3JzKClcclxuICAgICAgICBmb3IgKGxldCBjb2RlIGluIHNjcykge1xyXG4gICAgICAgICAgICAvL3RoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICAgICAgY29uc3QgeSA9XHJcbiAgICAgICAgICAgICAgICBvdXQuX3NpemVMZWdlbmRIZWlnaHQgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmxlZ2VuZFNwYWNpbmcgK1xyXG4gICAgICAgICAgICAgICAgb3V0LmJveFBhZGRpbmcgK1xyXG4gICAgICAgICAgICAgICAgKGNvbmZpZy50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmJveFBhZGRpbmcgOiAwKSArXHJcbiAgICAgICAgICAgICAgICBpICogKGNvbmZpZy5zaGFwZUhlaWdodCArIGNvbmZpZy5zaGFwZVBhZGRpbmcpXHJcbiAgICAgICAgICAgIC8vdGhlIGNvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IG1hcC5jYXRDb2xvcnMoKVtjb2RlXSB8fCAnbGlnaHRncmF5J1xyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29uZmlnLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29uZmlnLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgc2NzW2NvZGVdKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMC41KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGNvZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vbGFiZWxcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZyArIGNvbmZpZy5zaGFwZVdpZHRoICsgY29uZmlnLmxhYmVsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5ICsgY29uZmlnLnNoYXBlSGVpZ2h0ICogMC41KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChtYXAuY2F0TGFiZWxzKClbY29kZV0gfHwgY29kZSlcclxuXHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChjb25maWcubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPVxyXG4gICAgICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kSGVpZ2h0ICtcclxuICAgICAgICAgICAgICAgIG91dC5sZWdlbmRTcGFjaW5nICtcclxuICAgICAgICAgICAgICAgIG91dC5ib3hQYWRkaW5nICtcclxuICAgICAgICAgICAgICAgIChjb25maWcudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgK1xyXG4gICAgICAgICAgICAgICAgaSAqIChjb25maWcuc2hhcGVIZWlnaHQgKyBjb25maWcuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29uZmlnLnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29uZmlnLnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbWFwLm5vRGF0YUZpbGxTdHlsZSgpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsICduZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vJ25vIGRhdGEnIGxhYmVsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBjb25maWcuc2hhcGVXaWR0aCArIGNvbmZpZy5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIGNvbmZpZy5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KGNvbmZpZy5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgc2VnbWVudHMgb24gbW91c2VvdmVyXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgY29kZSkge1xyXG4gICAgICAgIGNvbnN0IGFsbFNlZ21lbnRzID0gbWFwLnN2Z18uc2VsZWN0QWxsKCcucGllY2hhcnQnKS5zZWxlY3RBbGwoJ3BhdGhbY29kZV0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHNlZ21lbnRzIHRvIHdoaXRlXHJcbiAgICAgICAgYWxsU2VnbWVudHMuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgc2VnbWVudHMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTZWdtZW50cyA9IGFsbFNlZ21lbnRzLmZpbHRlcihcInBhdGhbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKVxyXG4gICAgICAgIHNlbGVjdGVkU2VnbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29sb3IgZm9yIHNlbGVjdGVkIHNlZ21lbnRzXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbGwgc2VnbWVudHMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgY29uc3QgYWxsU2VnbWVudHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJy5waWVjaGFydCcpLnNlbGVjdEFsbCgncGF0aFtjb2RlXScpXHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgZWFjaCBzZWdtZW50cydzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsU2VnbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgc3ltYm9sc0xpYnJhcnkgfSBmcm9tICcuLi9tYXB0eXBlcy9tYXAtcHJvcG9ydGlvbmFsLXN5bWJvbHMnXHJcbmltcG9ydCB7IHN5bWJvbCB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRGb250U2l6ZUZyb21DbGFzcywgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuaW1wb3J0IHsgZm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ2QzLWZvcm1hdCdcclxuaW1wb3J0IHsgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcbmltcG9ydCB7IGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQtcGF0dGVybi1maWxsJ1xyXG5cclxuLy9zZXQgbGVnZW5kIGxhYmVscyBsb2NhbGVcclxuZm9ybWF0RGVmYXVsdExvY2FsZSh7XHJcbiAgICBkZWNpbWFsOiAnLicsXHJcbiAgICB0aG91c2FuZHM6ICcgJyxcclxuICAgIGdyb3VwaW5nOiBbM10sXHJcbiAgICBjdXJyZW5jeTogWycnLCAn4oKsJ10sXHJcbn0pXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZm9yIHByb3BvcnRpb25hbCBzeW1ib2wgbWFwXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgb3V0LmFzY2VuZGluZyA9IGZhbHNlIC8vdGhlIG9yZGVyIG9mIHRoZSBsZWdlbmQgZWxlbWVudHMuIFNldCB0byBmYWxzZSB0byBpbnZlcnQuXHJcbiAgICBvdXQubGVnZW5kU3BhY2luZyA9IDM1IC8vc3BhY2luZyBiZXR3ZWVuIGNvbG9yICYgc2l6ZSBsZWdlbmRzIChpZiBhcHBsaWNhYmxlKVxyXG4gICAgb3V0LmxhYmVsRm9udFNpemUgPSAxMiAvL3RoZSBmb250IHNpemUgb2YgdGhlIGxlZ2VuZCBsYWJlbHNcclxuXHJcbiAgICBvdXQubm9EYXRhU2hhcGVXaWR0aCA9IDI1XHJcbiAgICBvdXQubm9EYXRhU2hhcGVIZWlnaHQgPSAyMFxyXG5cclxuICAgIC8vc2l6ZSBsZWdlbmQgY29uZmlnIChsZWdlbmQgaWxsdXN0cmF0aW5nIHRoZSB2YWx1ZXMgb2YgZGlmZmVyZW50IHN5bWJvbCBzaXplcylcclxuICAgIG91dC5zaXplTGVnZW5kID0ge1xyXG4gICAgICAgIHRpdGxlOiBudWxsLFxyXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDEyLFxyXG4gICAgICAgIHRpdGxlUGFkZGluZzogNSwgLy9wYWRkaW5nIGJldHdlZW4gdGl0bGUgYW5kIGxlZ2VuZCBib2R5XHJcbiAgICAgICAgdmFsdWVzOiB1bmRlZmluZWQsIC8vbWFudWFsbHkgZGVmaW5lIHJhdyBkYXRhIHZhbHVlc1xyXG4gICAgICAgIGNlbGxOYjogMywgLy9udW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxlZ2VuZFxyXG4gICAgICAgIHNoYXBlUGFkZGluZzogNSwgLy90aGUgeSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGxlZ2VuZCBzaGFwZSBlbGVtZW50c1xyXG4gICAgICAgIHNoYXBlT2Zmc2V0OiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgICBzaGFwZUZpbGw6ICd3aGl0ZScsXHJcbiAgICAgICAgc2hhcGVTdHJva2U6IG51bGwsXHJcbiAgICAgICAgbGFiZWxPZmZzZXQ6IHsgeDogMTAsIHk6IDAgfSwgLy90aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGVnZW5kIGJveCBlbGVtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IGxhYmVsXHJcbiAgICAgICAgZGVjaW1hbHM6IDAsIC8vdGhlIG51bWJlciBvZiBkZWNpbWFsIGZvciB0aGUgbGVnZW5kIGxhYmVsc1xyXG4gICAgICAgIGxhYmVsRm9ybWF0dGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgX3RvdGFsQmFyc0hlaWdodDogMCxcclxuICAgICAgICBfdG90YWxEM1N5bWJvbHNIZWlnaHQ6IDAsXHJcbiAgICAgICAgbm9EYXRhOiBmYWxzZSwgLy8gc2hvdyBubyBkYXRhIGxlZ2VuZCBpdGVtXHJcbiAgICAgICAgbm9EYXRhVGV4dDogJ05vIGRhdGEnLCAvL25vIGRhdGEgdGV4dCBsYWJlbFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbG9yIGxlZ2VuZCBjb25maWcgKGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIGRhdGEtZHJpdmVuIGNvbG91ciBjbGFzc2VzKVxyXG4gICAgb3V0LmNvbG9yTGVnZW5kID0ge1xyXG4gICAgICAgIHRpdGxlOiBudWxsLFxyXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDEyLFxyXG4gICAgICAgIHRpdGxlUGFkZGluZzogMTAsIC8vcGFkZGluZyBiZXR3ZWVuIHRpdGxlIGFuZCBsZWdlbmQgYm9keVxyXG4gICAgICAgIG1hcmdpblRvcDogMzAsIC8vIG1hcmdpbiB0b3AgKGRpc3RhbmNlIGJldHdlZW4gY29sb3IgYW5kIHNpemUgbGVnZW5kKVxyXG4gICAgICAgIHNoYXBlV2lkdGg6IDI1LCAvL3RoZSB3aWR0aCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgICAgIHNoYXBlSGVpZ2h0OiAyMCwgLy90aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzXHJcbiAgICAgICAgc2hhcGVQYWRkaW5nOiAxLCAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGxlZ2VuZCBzaGFwZSBlbGVtZW50cyBpbiB0aGUgY29sb3IgbGVnZW5kXHJcbiAgICAgICAgbGFiZWxPZmZzZXQ6IHsgeDogNSwgeTogMCB9LCAvL2Rpc3RhbmNlICh4KSBiZXR3ZWVuIGxhYmVsIHRleHQgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHNoYXBlIGVsZW1lbnRcclxuICAgICAgICBkZWNpbWFsczogMCwgLy90aGUgbnVtYmVyIG9mIGRlY2ltYWwgZm9yIHRoZSBsZWdlbmQgbGFiZWxzXHJcbiAgICAgICAgbGFiZWxGb3JtYXR0ZXI6IHVuZGVmaW5lZCwgLy8gdXNlci1kZWZpbmVkIGQzIGZvcm1hdCBmdW5jdGlvblxyXG4gICAgICAgIGxhYmVsVHlwZTogJ3RocmVzaG9sZHMnLCAvLyB0eXBlIG9mIGxhYmVscyB0byBzaG93OiB0aHJlc2hvbGRzIG9yIHJhbmdlc1xyXG4gICAgICAgIGxhYmVsczogbnVsbCwgLy8gdXNlci1kZWZpbmVkIGxhYmVscyBmb3IgZWFjaCBjbGFzc1xyXG4gICAgICAgIG5vRGF0YTogdHJ1ZSwgLy9zaG93IG5vIGRhdGFcclxuICAgICAgICBub0RhdGFUZXh0OiAnTm8gZGF0YScsIC8vbm8gZGF0YSB0ZXh0IGxhYmVsXHJcbiAgICAgICAgc2VwTGluZUxlbmd0aDogMjQsIC8vIC8vdGhlIHNlcGFyYXRpb24gbGluZSBsZW5ndGhcclxuICAgICAgICBzZXBMaW5lU3Ryb2tlOiAnYmxhY2snLCAvL3RoZSBzZXBhcmF0aW9uIGxpbmUgY29sb3JcclxuICAgICAgICBzZXBMaW5lU3Ryb2tlV2lkdGg6IDEsIC8vdGhlIHNlcGFyYXRpb24gbGluZSB3aWR0aFxyXG4gICAgICAgIHRpY2tMZW5ndGg6IDUsIC8vIHRocmVzaG9sZCB0aWNrcyBsZW5ndGggaW4gcHhcclxuICAgIH1cclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSAnY29sb3JMZWdlbmQnIHx8IGtleSA9PSAnc2l6ZUxlZ2VuZCcpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgaW4gb3V0W2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIGNvbmZpZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRba2V5XVtwXSA9IGNvbmZpZ1trZXldW3BdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jb2xvckxlZ2VuZCA9PSBmYWxzZSkgb3V0LmNvbG9yTGVnZW5kID0gZmFsc2VcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dFtrZXldID0gY29uZmlnW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvdXQudXBkYXRlQ29uZmlnKClcclxuICAgICAgICBvdXQudXBkYXRlQ29udGFpbmVyKClcclxuXHJcbiAgICAgICAgaWYgKG91dC5sZ2cubm9kZSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBvdXQubWFwXHJcbiAgICAgICAgICAgIGNvbnN0IGxnZyA9IG91dC5sZ2dcclxuXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICAgICAgbGdnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgbGVnZW5kIGJhY2tncm91bmQgYm94XHJcbiAgICAgICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgICAgICAvLyByZXNldCBoZWlnaHQgY291bnRlcnNcclxuICAgICAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsQmFyc0hlaWdodCA9IDBcclxuICAgICAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ID0gMFxyXG5cclxuICAgICAgICAgICAgLy8gbGVnZW5kIGZvciBzaXplXHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZE5vZGUgPSBsZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc2l6ZS1sZWdlbmQtY29udGFpbmVyJylcclxuICAgICAgICAgICAgaWYgKG0uY2xhc3NpZmllclNpemVfKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZFNpemVMZWdlbmQobSwgb3V0LnNpemVMZWdlbmQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbGVnZW5kIGZvciBwcyBjb2xvciB2YWx1ZXNcclxuICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGUgPSBsZ2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnY29sb3ItbGVnZW5kLWNvbnRhaW5lcicpXHJcblxyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBpdCBiZWxvdyBzaXplIGxlZ2VuZFxyXG4gICAgICAgICAgICBpZiAob3V0Ll9zaXplTGVnZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGUuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCR7b3V0Ll9zaXplTGVnZW5kTm9kZS5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodH0pYClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG0uY2xhc3NpZmllckNvbG9yXyAmJiBvdXQuY29sb3JMZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkQ29sb3JMZWdlbmQobSwgb3V0LmNvbG9yTGVnZW5kKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgcGF0dGVybiBmaWxsIGxlZ2VuZCBpdGVtcyBCRUxPVyB0aGUgbWFpbiBsZWdlbmRcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGNob3JvcGxldGggbGVnZW5kIGJveFxyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBvdXQubGdnLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgIGFwcGVuZFBhdHRlcm5GaWxsTGVnZW5kKG1hcCwgb3V0LmxnZywge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVXaWR0aDogb3V0LnNoYXBlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBzaGFwZUhlaWdodDogb3V0LnNoYXBlSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgbGFiZWxPZmZzZXQ6IG91dC5sYWJlbE9mZnNldCxcclxuICAgICAgICAgICAgICAgIGJveFBhZGRpbmc6IG91dC5ib3hQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogbGVnZW5kSGVpZ2h0ICsgb3V0LmJveFBhZGRpbmcgKyA1LCAvLyA8PCB0aGlzIHNoaWZ0cyBwYXR0ZXJuIGxlZ2VuZCBkb3duXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvL3NldCBsZWdlbmQgYm94IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIGEgbGVnZW5kIHdoaWNoIGlsbHVzdHJhdGVzIHRoZSBzdGF0aXN0aWNhbCB2YWx1ZXMgb2YgZGlmZmVyZW50IHN5bWJvbCBzaXplc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwIG1hcCBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBjb250YWluZXIgcGFyZW50IGxlZ2VuZCBvYmplY3QgZnJvbSBjb3JlL2xlZ2VuZC5qc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZFNpemVMZWdlbmQobSkge1xyXG4gICAgICAgIGlmICghbS5wc0N1c3RvbVNWR18gJiYgbS5wc1NoYXBlXyA9PSAnY2lyY2xlJykge1xyXG4gICAgICAgICAgICBidWlsZENpcmNsZUxlZ2VuZChtLCBvdXQuc2l6ZUxlZ2VuZClcclxuICAgICAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBvdXQuX3NpemVMZWdlbmROb2RlLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0ICsgMjVcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX3NpemVMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLW5vLWRhdGEtbGVnZW5kJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYClcclxuICAgICAgICAgICAgICAgIGJ1aWxkTm9EYXRhTGVnZW5kKGNvbnRhaW5lciwgb3V0LnNpemVMZWdlbmQubm9EYXRhVGV4dClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9IGVsc2UgaWYgKG0ucHNTaGFwZV8gPT0gJ3NwaWtlJykge1xyXG4gICAgICAgICAgICBidWlsZFNwaWtlTGVnZW5kKG0sIG91dC5zaXplTGVnZW5kKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZGVmaW5lIGZvcm1hdCBmb3IgbGFiZWxzXHJcbiAgICAgICAgbGV0IGxhYmVsRm9ybWF0dGVyID0gb3V0LnNpemVMZWdlbmQubGFiZWxGb3JtYXR0ZXIgfHwgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yXHJcbiAgICAgICAgLy9kcmF3IHRpdGxlXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnNpemVMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZG9tYWluID0gbS5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClcclxuICAgICAgICBsZXQgbWF4VmFsID0gZG9tYWluWzFdIC8vbWF4aW11bSB2YWx1ZSBvZiBkYXRhc2V0ICh1c2VkIGZvciBmaXJzdCBvciBsYXN0IHN5bWJvbCBieSBkZWZhdWx0KVxyXG5cclxuICAgICAgICAvLyBpZiB1c2VyIGRlZmluZXMgdmFsdWVzIGZvciBsZWdlbmQgbWFudWFsbHlcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIG91dC5zaXplTGVnZW5kLmNlbGxOYiA9IG91dC5zaXplTGVnZW5kLnZhbHVlcy5sZW5ndGhcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBsZWdlbmQgZWxlbWVudHMgZm9yIGNsYXNzZXM6IHN5bWJvbCArIGxhYmVsXHJcblxyXG4gICAgICAgIC8vIGZvciBjdXN0b20gcGF0aHNcclxuICAgICAgICBtLmN1c3RvbVN5bWJvbHMgPSB7IG5vZGVIZWlnaHRzOiAwIH0gLy8gc2F2ZSBzb21lIGN1c3RvbSBzZXR0aW5ncyBmb3IgYnVpbGRDdXN0b21TVkdJdGVtXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3V0LnNpemVMZWdlbmQuY2VsbE5iICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vZGVmaW5lIGNsYXNzIG51bWJlclxyXG4gICAgICAgICAgICBjb25zdCBjID0gb3V0LmFzY2VuZGluZyA/IG91dC5zaXplTGVnZW5kLmNlbGxOYiAtIGkgKyAxIDogaVxyXG4gICAgICAgICAgICAvL2RlZmluZSByYXcgdmFsdWVcclxuICAgICAgICAgICAgbGV0IHZhbCA9IG91dC5zaXplTGVnZW5kLnZhbHVlcyA/IG91dC5zaXplTGVnZW5kLnZhbHVlc1tjIC0gMV0gOiBtYXhWYWwgLyBjXHJcbiAgICAgICAgICAgIC8vY2FsY3VsYXRlIHNoYXBlIHNpemVcclxuICAgICAgICAgICAgbGV0IHN5bWJvbFNpemUgPSBtLmNsYXNzaWZpZXJTaXplXyh2YWwpXHJcblxyXG4gICAgICAgICAgICBpZiAobS5wc1NoYXBlXyA9PSAnYmFyJykge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRCYXJzSXRlbShtYXAsIHZhbCwgc3ltYm9sU2l6ZSwgaSwgbGFiZWxGb3JtYXR0ZXIpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobS5wc1NoYXBlXyA9PSAnY3VzdG9tJyB8fCBtLnBzQ3VzdG9tU1ZHXykge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRDdXN0b21TVkdJdGVtKG1hcCwgdmFsLCBzeW1ib2xTaXplLCBpLCBsYWJlbEZvcm1hdHRlcilcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkRDNTeW1ib2xJdGVtKG1hcCwgdmFsLCBzeW1ib2xTaXplLCBpLCBsYWJlbEZvcm1hdHRlcilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUubm9kZSgpLmdldEJCb3goKS5oZWlnaHRcclxuICAgICAgICAgICAgaWYgKG91dC5jb2xvckxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgeSArPSBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgKyA1XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcblxyXG4gICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5zaXplTGVnZW5kLm5vRGF0YVRleHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkU3Bpa2VMZWdlbmQobWFwLCBzaXplTGVnZW5kQ29uZmlnKSB7XHJcbiAgICAgICAgY29uc3Qgc3Bpa2UgPSAobGVuZ3RoLCB3aWR0aCA9IG1hcC5wc1NwaWtlV2lkdGhfKSA9PiBgTSR7LXdpZHRoIC8gMn0sMEwwLCR7LWxlbmd0aH1MJHt3aWR0aCAvIDJ9LDBgXHJcblxyXG4gICAgICAgIGxldCBtYXhTaXplID0gbWFwLmNsYXNzaWZpZXJTaXplXyhtYXAuY2xhc3NpZmllclNpemVfLmRvbWFpbigpWzFdKVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdmFsdWVzIGZvciB0aGUgbGVnZW5kXHJcbiAgICAgICAgbGV0IGxlZ2VuZFZhbHVlcyA9IG91dC5zaXplTGVnZW5kLnZhbHVlcyB8fCBtYXAuY2xhc3NpZmllclNpemVfLnRpY2tzKDQpLnNsaWNlKDEpIC8vIFVzZSB1c2VyLWRlZmluZWQgdmFsdWVzIG9yIGRlZmF1bHQgdGlja3NcclxuXHJcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBnZXRGb250U2l6ZUZyb21DbGFzcygnZW0tbGVnZW5kLWxhYmVsJykgLy8gQWRqdXN0IGZvbnQgc2l6ZVxyXG4gICAgICAgIGNvbnN0IGxhYmVsU3BhY2luZyA9IGZvbnRTaXplIC0gMiAvLyBFbnN1cmUgbGFiZWxzIGFyZSBqdXN0IGJlbG93IHRoZSBzcGlrZXNcclxuXHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gb3V0Ll9zaXplTGVnZW5kTm9kZVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLXNwaWtlLWxlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7b3V0LmJveFBhZGRpbmcgKyA1fSwwKWApXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgYCR7Zm9udFNpemV9cHhgKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKClcclxuICAgICAgICAgICAgLmRhdGEobGVnZW5kVmFsdWVzKSAvLyBOb3cgdXNlcyB1c2VyLWRlZmluZWQgdmFsdWVzIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIC5qb2luKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgdHJhbnNsYXRlKCR7NDAgKiBpICsgb3V0LmJveFBhZGRpbmd9LCR7bWF4U2l6ZSArIDV9KWApIC8vIEluY3JlYXNlIHNwYWNpbmdcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHNwaWtlc1xyXG4gICAgICAgIGxlZ2VuZFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBtYXAucHNGaWxsXylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIG1hcC5wc0ZpbGxPcGFjaXR5XylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIG1hcC5wc1N0cm9rZV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBtYXAucHNTdHJva2VXaWR0aF8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgKGQpID0+IHNwaWtlKG1hcC5jbGFzc2lmaWVyU2l6ZV8oZCkpKSAvLyBDb3JyZWN0bHkgbWFwcyB2YWx1ZXMgdG8gc3Bpa2Ugc2l6ZVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgbGFiZWxzIGRpcmVjdGx5IGJlbG93IGVhY2ggc3Bpa2VcclxuICAgICAgICBsZWdlbmRcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCBsYWJlbFNwYWNpbmcpIC8vIEVuc3VyZSB0ZXh0IGlzIHJpZ2h0IGJlbG93IHNwaWtlc1xyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4gbWFwLmNsYXNzaWZpZXJTaXplXy50aWNrRm9ybWF0KDQsICdzJykoZCkpXHJcblxyXG4gICAgICAgIC8vIPCflLkgQWRkIFwiTm8gRGF0YVwiIGl0ZW0gd2l0aCBtb3JlIHNwYWNpbmdcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0TGFiZWxZID0gbWF4U2l6ZSArIGxhYmVsU3BhY2luZyArIGZvbnRTaXplICsgNSAvLyBBZGp1c3QgcG9zaXRpb24gYmVsb3cgdGhlIGxhYmVsc1xyXG4gICAgICAgICAgICBsZXQgeCA9IG91dC5ib3hQYWRkaW5nXHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX3NpemVMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLW5vLWRhdGEtbGVnZW5kJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7bGFzdExhYmVsWX0pYClcclxuICAgICAgICAgICAgYnVpbGROb0RhdGFMZWdlbmQoY29udGFpbmVyLCBvdXQuc2l6ZUxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLydubyBkYXRhJyBsZWdlbmQgYm94XHJcbiAgICBmdW5jdGlvbiBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG5vRGF0YVRleHQpIHtcclxuICAgICAgICBsZXQgbSA9IG91dC5tYXBcclxuXHJcbiAgICAgICAgLy9hcHBlbmQgc3ltYm9sICYgc3R5bGVcclxuICAgICAgICBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIG0ubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5jb2xvckxlZ2VuZCA/IG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoIDogb3V0Lm5vRGF0YVNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuY29sb3JMZWdlbmQgPyBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgOiBvdXQubm9EYXRhU2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgJ25kJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgdW5oaWdobGlnaHRSZWdpb25zLCAnbmQnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLydubyBkYXRhJyBsYWJlbFxyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmNvbG9yTGVnZW5kID8gb3V0LmNvbG9yTGVnZW5kLnNoYXBlV2lkdGggKyBvdXQuY29sb3JMZWdlbmQubGFiZWxPZmZzZXQueCA6IG91dC5ub0RhdGFTaGFwZVdpZHRoICsgNSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuY29sb3JMZWdlbmQgPyBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgLyAyIDogb3V0Lm5vRGF0YVNoYXBlSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgLnRleHQobm9EYXRhVGV4dClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRSZWdpb25zKG1hcCwgZWNsKSB7XHJcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRoaXMgdG8gZXN0YXQgbG9naWMgb2YgbWFraW5nIGFsbCBvdGhlciBjbGFzc2VzIHRyYW5zcGFyZW50P1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3Qgc2VsID0gbWFwLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiW2VjbD0nXCIgKyBlY2wgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGVjbCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RvciA9IG91dC5nZW9fID09PSAnV09STEQnID8gJyNlbS13b3JsZHJnJyA6ICcjZW0tbnV0c3JnJ1xyXG4gICAgICAgIGlmIChtYXAuR2VvbWV0cmllcy51c2VyR2VvbWV0cmllcykgc2VsZWN0b3IgPSAnI2VtLXVzZXItcmVnaW9ucycgLy8gZm9yIHVzZXItZGVmaW5lZCBnZW9tZXRyaWVzXHJcbiAgICAgICAgY29uc3Qgc2VsID0gbWFwLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiW2VjbD0nXCIgKyBlY2wgKyBcIiddXCIpXHJcbiAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBidWlsZHMgYSBzaXplIGxlZ2VuZCBpdGVtIGZvciBwcm9wb3J0aW9uYWwgRDMgc2hhcGVzIChlLmcuIHNxdWFyZSwgdHJpYW5nbGUsIHN0YXIpXHJcbiAgICAgKiBAcGFyYW0geyp9IG0gbWFwIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ltYm9sU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgc3ltYm9sIGl0ZW1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGREM1N5bWJvbEl0ZW0obSwgdmFsdWUsIHN5bWJvbFNpemUsIGluZGV4LCBsYWJlbEZvcm1hdHRlcikge1xyXG4gICAgICAgIGxldCBzeW1ib2xIZWlnaHQgPSBvdXQubWFwLnBzU2hhcGVfID09ICd0cmlhbmdsZScgfHwgb3V0Lm1hcC5wc1NoYXBlXyA9PSAnZGlhbW9uZCcgPyBzeW1ib2xTaXplIDogc3ltYm9sU2l6ZSAvIDJcclxuICAgICAgICBpZiAob3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ID09IDApIG91dC5zaXplTGVnZW5kLl90b3RhbEQzU3ltYm9sc0hlaWdodCArPSBzeW1ib2xIZWlnaHQgKyBvdXQuYm94UGFkZGluZyAvL2FkZCBmaXJzdCBpdGVtIGhlaWdodCB0byB5XHJcbiAgICAgICAgbGV0IG1heFNpemUgPSBtLmNsYXNzaWZpZXJTaXplXyhtLmNsYXNzaWZpZXJTaXplXy5kb21haW4oKVsxXSlcclxuICAgICAgICAvLyB4IGFuZCB5IHBvc2l0aW9uIG9mIGl0ZW0gaW4gbGVnZW5kXHJcbiAgICAgICAgbGV0IHggPSBtYXhTaXplXHJcbiAgICAgICAgbGV0IHkgPVxyXG4gICAgICAgICAgICAob3V0LnNpemVMZWdlbmQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5zaXplTGVnZW5kLnRpdGxlUGFkZGluZyA6IDApICtcclxuICAgICAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ICtcclxuICAgICAgICAgICAgKG91dC5zaXplTGVnZW5kLnNoYXBlUGFkZGluZyAqIGluZGV4IC0gMSlcclxuXHJcbiAgICAgICAgb3V0LnNpemVMZWdlbmQuX3RvdGFsRDNTeW1ib2xzSGVpZ2h0ICs9IHN5bWJvbFNpemVcclxuXHJcbiAgICAgICAgLy9jb250YWluZXIgZm9yIHN5bWJvbCBhbmQgbGFiZWxcclxuICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtaXRlbScpXHJcblxyXG4gICAgICAgIC8vIGRyYXcgRDMgc3ltYm9sXHJcbiAgICAgICAgbGV0IHNoYXBlID0gZ2V0U2hhcGUoKVxyXG4gICAgICAgIGxldCBkID0gc2hhcGUuc2l6ZShzeW1ib2xTaXplICogc3ltYm9sU2l6ZSkoKVxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC8vIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgc2Vjb25kYXJ5IHN0YXQgdmFyaWFibGUgaXMgdXNlZCBmb3Igc3ltYm9sIGNvbG91cmluZywgdGhlbiBkb250IGNvbG91ciB0aGUgbGVnZW5kIHN5bWJvbHMgdXNpbmcgcHNGaWxsKClcclxuICAgICAgICAgICAgICAgIHJldHVybiBtLmNsYXNzaWZpZXJDb2xvcl8gPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZUZpbGwgOiBtLnBzRmlsbF9cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBtLnBzRmlsbE9wYWNpdHkoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA/IG91dC5zaXplTGVnZW5kLnNoYXBlU3Ryb2tlIDogbS5wc1N0cm9rZSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIG0ucHNTdHJva2VXaWR0aCgpKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KWBcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9sYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBsYWJlbFggPSBtYXhTaXplIC8gMiArIG91dC5zaXplTGVnZW5kLmxhYmVsT2Zmc2V0LnggKyBvdXQuYm94UGFkZGluZ1xyXG5cclxuICAgICAgICAvL2FwcGVuZCBsYWJlbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAuYXR0cigneCcsIGxhYmVsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAudGV4dChsYWJlbEZvcm1hdHRlcih2YWx1ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gbVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHsqfSBzeW1ib2xTaXplXHJcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4XHJcbiAgICAgKiBAcGFyYW0geyp9IGxhYmVsRm9ybWF0dGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ3VzdG9tU1ZHSXRlbShtLCB2YWx1ZSwgc3ltYm9sU2l6ZSwgaW5kZXgsIGxhYmVsRm9ybWF0dGVyKSB7XHJcbiAgICAgICAgbGV0IHggPSBvdXQuYm94UGFkZGluZyAvL3NldCBYIG9mZnNldFxyXG4gICAgICAgIGxldCB5XHJcblxyXG4gICAgICAgIC8vZmlyc3QgaXRlbVxyXG4gICAgICAgIGlmICghbS5jdXN0b21TeW1ib2xzLnByZXZTeW1iKSB7XHJcbiAgICAgICAgICAgIHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LnNpemVMZWdlbmQudGl0bGVQYWRkaW5nIDogMCkgKyAyMFxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMuaW5pdGlhbFRyYW5zbGF0ZVkgPSB5XHJcbiAgICAgICAgICAgIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGUgPSBzeW1ib2xTaXplXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2ZvbGxvd2luZyBpdGVtc1xyXG4gICAgICAgIGlmIChtLmN1c3RvbVN5bWJvbHMucHJldlN5bWIpIHtcclxuICAgICAgICAgICAgbGV0IHByZXZOb2RlID0gbS5jdXN0b21TeW1ib2xzLnByZXZTeW1iLm5vZGUoKVxyXG4gICAgICAgICAgICBsZXQgYmJveCA9IHByZXZOb2RlLmdldEJCb3goKVxyXG4gICAgICAgICAgICBtLmN1c3RvbVN5bWJvbHMubm9kZUhlaWdodHMgPSBtLmN1c3RvbVN5bWJvbHMubm9kZUhlaWdodHMgKyBiYm94LmhlaWdodCAqIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGVcclxuICAgICAgICAgICAgeSA9IG0uY3VzdG9tU3ltYm9scy5pbml0aWFsVHJhbnNsYXRlWSArIG0uY3VzdG9tU3ltYm9scy5ub2RlSGVpZ2h0cyArIG91dC5zaXplTGVnZW5kLnNoYXBlUGFkZGluZyAqIChpbmRleCAtIDEpXHJcbiAgICAgICAgICAgIG0uY3VzdG9tU3ltYm9scy5wcmV2U2NhbGUgPSBzeW1ib2xTaXplXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnRhaW5lciBmb3Igc3ltYm9sIGFuZCBsYWJlbFxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKS5hdHRyKCdjbGFzcycsICdlbS1zaXplLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy8gZHJhdyBzdGFuZGFyZCBzeW1ib2xcclxuICAgICAgICBtLmN1c3RvbVN5bWJvbHMucHJldlN5bWIgPSBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tc2l6ZS1sZWdlbmQtc3ltYm9sJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHNlY29uZGFyeSBzdGF0IHZhcmlhYmxlIGlzIHVzZWQgZm9yIHN5bWJvbCBjb2xvdXJpbmcsIHRoZW4gZG9udCBjb2xvdXIgdGhlIGxlZ2VuZCBzeW1ib2xzIHVzaW5nIHBzRmlsbCgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5jbGFzc2lmaWVyQ29sb3JfID8gb3V0LnNpemVMZWdlbmQuc2hhcGVGaWxsIDogbS5wc0ZpbGxfXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgbS5wc0ZpbGxPcGFjaXR5KCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA6IG0ucHNTdHJva2UoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBtLnBzU3Ryb2tlV2lkdGgoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuaHRtbChvdXQubWFwLnBzQ3VzdG9tU1ZHXylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLnBzQ3VzdG9tU1ZHXykgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KSBzY2FsZSgke3N5bWJvbFNpemV9KWBcclxuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC54fSwke291dC5zaXplTGVnZW5kLnNoYXBlT2Zmc2V0Lnl9KWBcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9sYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBsYWJlbFggPSB4ICsgbS5jbGFzc2lmaWVyU2l6ZV8obS5jbGFzc2lmaWVyU2l6ZV8uZG9tYWluKClbMF0pICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueFxyXG4gICAgICAgIGxldCBsYWJlbFkgPSBvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55IC8gMiArIDEgLy95ICsgb3V0LnNpemVMZWdlbmQubGFiZWxPZmZzZXQueVxyXG5cclxuICAgICAgICAvL2FwcGVuZCBsYWJlbFxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy8gfnZlcnRpY2FsIGNlbnRlcmluZ1xyXG4gICAgICAgICAgICAuYXR0cigneCcsIGxhYmVsWClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBsYWJlbFkpXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsRm9ybWF0dGVyKHZhbHVlKSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogQHBhcmFtIHsqfSBtXHJcbiAgICAgKiBAcGFyYW0geyp9IHN5bWJvbFNpemVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnVpbGRCYXJzSXRlbShtLCB2YWx1ZSwgc3ltYm9sU2l6ZSwgaW5kZXgsIGxhYmVsRm9ybWF0dGVyKSB7XHJcbiAgICAgICAgLy8gZm9yIHZlcnRpY2FsIGJhcnMgd2UgZG9udCB1c2UgYSBkeW5hbWljIFggb2Zmc2V0IGJlY2F1c2UgYWxsIGJhcnMgaGF2ZSB0aGUgc2FtZSB3aWR0aFxyXG4gICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuICAgICAgICAvL3dlIGFsc28gZG9udCBuZWVkIHRoZSB5IG9mZnNldFxyXG4gICAgICAgIGxldCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnNpemVMZWdlbmQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5zaXplTGVnZW5kLnRpdGxlUGFkZGluZyA6IDApICsgb3V0LnNpemVMZWdlbmQuX3RvdGFsQmFyc0hlaWdodCArIDEwXHJcblxyXG4gICAgICAgIG91dC5zaXplTGVnZW5kLl90b3RhbEJhcnNIZWlnaHQgKz0gc3ltYm9sU2l6ZSArIDEwXHJcblxyXG4gICAgICAgIC8vc2V0IHNoYXBlIHNpemUgYW5kIGRlZmluZSAnZCcgYXR0cmlidXRlXHJcbiAgICAgICAgbGV0IHNoYXBlID0gZ2V0U2hhcGUoKVxyXG4gICAgICAgIGxldCBkID0gc2hhcGUuc2l6ZShzeW1ib2xTaXplICogc3ltYm9sU2l6ZSkoKVxyXG5cclxuICAgICAgICAvL2NvbnRhaW5lciBmb3Igc3ltYm9sIGFuZCBsYWJlbFxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9zaXplTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKS5hdHRyKCdjbGFzcycsICdlbS1zaXplLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy8gZHJhdyBiYXIgc3ltYm9sXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHNlY29uZGFyeSBzdGF0IHZhcmlhYmxlIGlzIHVzZWQgZm9yIHN5bWJvbCBjb2xvdXJpbmcsIHRoZW4gZG9udCBjb2xvdXIgdGhlIGxlZ2VuZCBzeW1ib2xzIHVzaW5nIHBzRmlsbCgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbS5jbGFzc2lmaWVyQ29sb3JfID8gb3V0LnNpemVMZWdlbmQuc2hhcGVGaWxsIDogbS5wc0ZpbGxfXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgbS5wc0ZpbGxPcGFjaXR5KCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgb3V0LnNpemVMZWdlbmQuc2hhcGVTdHJva2UgPyBvdXQuc2l6ZUxlZ2VuZC5zaGFwZVN0cm9rZSA6IG0ucHNTdHJva2UoKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBtLnBzU3Ryb2tlV2lkdGgoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5wc0N1c3RvbVNWR18pIHJldHVybiBgdHJhbnNsYXRlKCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueH0sJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55fSkgc2NhbGUoJHtzeW1ib2xTaXplfSlgXHJcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBgdHJhbnNsYXRlKCR7b3V0LnNpemVMZWdlbmQuc2hhcGVPZmZzZXQueH0sJHtvdXQuc2l6ZUxlZ2VuZC5zaGFwZU9mZnNldC55fSlgXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgLy9sYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBsYWJlbFggPSB4ICsgb3V0Lm1hcC5wc0JhcldpZHRoXyArIG91dC5zaXplTGVnZW5kLmxhYmVsT2Zmc2V0LnhcclxuICAgICAgICBsZXQgbGFiZWxZID0gc3ltYm9sU2l6ZSAvIDIgKyBvdXQuc2l6ZUxlZ2VuZC5sYWJlbE9mZnNldC55XHJcblxyXG4gICAgICAgIC8vYXBwZW5kIGxhYmVsXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbGFiZWxYKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGxhYmVsWSlcclxuICAgICAgICAgICAgLnRleHQobGFiZWxGb3JtYXR0ZXIodmFsdWUpKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIGJ1aWxkcyBhIG5lc3RlZCBjaXJjbGUgbGVnZW5kIGZvciBwcm9wb3J0aW9uYWwgY2lyY2xlc1xyXG4gICAgICogQHBhcmFtIHsqfSBtIG1hcFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWlsZENpcmNsZUxlZ2VuZChtKSB7XHJcbiAgICAgICAgLy9hc3NpZ24gZGVmYXVsdCBjaXJjbGUgcmFkaXVzZXMgaWYgbm9uZSBzcGVjaWZpZWQgYnkgdXNlclxyXG4gICAgICAgIGxldCBkb21haW4gPSBtLmNsYXNzaWZpZXJTaXplXy5kb21haW4oKVxyXG4gICAgICAgIGlmICghb3V0LnNpemVMZWdlbmQudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgbGVnZW5kIHZhbHVlc1xyXG4gICAgICAgICAgICBvdXQuX3NpemVMZWdlbmRWYWx1ZXMgPSBbTWF0aC5mbG9vcihkb21haW5bMV0pLCBNYXRoLmZsb29yKGRvbWFpblsxXSAvIDIpLCBNYXRoLmZsb29yKGRvbWFpblswXSldXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdXNlciBkZWZpbmVkIGxlZ2VuZCB2YWx1ZXNcclxuICAgICAgICAgICAgb3V0Ll9zaXplTGVnZW5kVmFsdWVzID0gb3V0LnNpemVMZWdlbmQudmFsdWVzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgdGl0bGVcclxuICAgICAgICBpZiAoIW91dC5zaXplTGVnZW5kLnRpdGxlICYmIG91dC50aXRsZSkgb3V0LnNpemVMZWdlbmQudGl0bGUgPSBvdXQudGl0bGUgLy9pZiB1bnNwZWNpZmllZCwgc2V0IHNpemUgbGVnZW5kIHRpdGxlIGFzIHJvb3QgbGVnZW5kIHRpdGxlXHJcbiAgICAgICAgaWYgKG91dC5zaXplTGVnZW5kLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG91dC5fc2l6ZUxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuYm94UGFkZGluZyArIG91dC50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQob3V0LnNpemVMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbWF4UmFkaXVzID0gbS5jbGFzc2lmaWVyU2l6ZV8obWF4KG91dC5fc2l6ZUxlZ2VuZFZhbHVlcykpIC8vbWF4aW11bSBjaXJjbGUgcmFkaXVzIHRvIGJlIHNob3duIGluIGxlZ2VuZFxyXG4gICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmcgKyBtYXhSYWRpdXNcclxuICAgICAgICBsZXQgeSA9IG91dC5ib3hQYWRkaW5nICsgbWF4UmFkaXVzICogMiArIChvdXQuc2l6ZUxlZ2VuZC50aXRsZSA/IG91dC50aXRsZUZvbnRTaXplICsgb3V0LnNpemVMZWdlbmQudGl0bGVQYWRkaW5nIDogMCkgKyAyMFxyXG5cclxuICAgICAgICBsZXQgaXRlbUNvbnRhaW5lciA9IG91dC5fc2l6ZUxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY2lyY2xlLWxlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdyaWdodCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAuZGF0YShvdXQuX3NpemVMZWdlbmRWYWx1ZXMuZmlsdGVyKChkKSA9PiBtLmNsYXNzaWZpZXJTaXplXyhkKSkpIC8vIEZpbHRlciBkYXRhIGJlZm9yZSBiaW5kaW5nXHJcbiAgICAgICAgICAgIC5qb2luKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgLy9jaXJjbGVzXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWNpcmNsZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIChkKSA9PiAtbS5jbGFzc2lmaWVyU2l6ZV8oZCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgbS5jbGFzc2lmaWVyU2l6ZV8pXHJcblxyXG4gICAgICAgIC8vbGFiZWxzXHJcbiAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gLTEgLSAyICogbS5jbGFzc2lmaWVyU2l6ZV8oZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB5XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgbWF4UmFkaXVzICsgNSlcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlU3RyaW5nKCdlbicpLnJlcGxhY2UoLywvZ2ksICcgJylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAvL2xpbmUgcG9pbnRpbmcgdG8gdG9wIG9mIGNvcnJlc3BvbmRpbmcgY2lyY2xlOlxyXG4gICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsIDIpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2dyZXknKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCAyKVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSAtMSAtIDIgKiBtLmNsYXNzaWZpZXJTaXplXyhkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgbWF4UmFkaXVzICsgNSlcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gLTEgLSAyICogbS5jbGFzc2lmaWVyU2l6ZV8oZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB5XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBhIGxlZ2VuZCBpbGx1c3RyYXRpbmcgdGhlIHN0YXRpc3RpY2FsIHZhbHVlcyBvZiBkaWZmZXJlbnQgc3ltYm9sIGNvbG91cnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG0gbWFwXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQ29sb3JMZWdlbmQobSkge1xyXG4gICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQubGFiZWxUeXBlID09PSAncmFuZ2VzJykge1xyXG4gICAgICAgICAgICBidWlsZENvbG9yUmFuZ2VzTGVnZW5kKG0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVpbGRDb2xvclRocmVzaG9sZHNMZWdlbmQobSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JUaHJlc2hvbGRzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID1cclxuICAgICAgICAgICAgbWFwLnBzVGhyZXNob2xkc18ubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyBtYXAucHNUaHJlc2hvbGRzX1xyXG4gICAgICAgICAgICAgICAgOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBtYXAucHNDbGFzc2VzXyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwLmNsYXNzaWZpZXJDb2xvcl8uaW52ZXJ0RXh0ZW50KGluZGV4KVtvdXQuYXNjZW5kaW5nID8gMCA6IDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDEpIC8vIFJlbW92ZSB0aGUgZmlyc3QgZW50cnkgYW5kIHJldHVybiB0aGUgcmVzdCBhcyBhbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRDb2xvclJhbmdlc0xlZ2VuZChtKSB7XHJcbiAgICAgICAgY29uc3QgZiA9IG91dC5jb2xvckxlZ2VuZC5sYWJlbEZvcm1hdHRlciB8fCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3JcclxuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gZ2V0Q29sb3JUaHJlc2hvbGRzKClcclxuICAgICAgICBjb25zdCBudW1iZXJPZkNsYXNzZXMgPSBtLnBzQ2xhc3Nlc19cclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQudGl0bGUpIHtcclxuICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQudGl0bGVGb250U2l6ZSArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3ApXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQuY29sb3JMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB4ID0gb3V0LmJveFBhZGRpbmdcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgeSA9XHJcbiAgICAgICAgICAgICAgICBvdXQudGl0bGVGb250U2l6ZSArXHJcbiAgICAgICAgICAgICAgICBvdXQuY29sb3JMZWdlbmQudGl0bGVQYWRkaW5nICtcclxuICAgICAgICAgICAgICAgIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3AgK1xyXG4gICAgICAgICAgICAgICAgaSAqIChvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgKyBvdXQuY29sb3JMZWdlbmQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZWNsID0gb3V0LmFzY2VuZGluZyA/IGkgOiBudW1iZXJPZkNsYXNzZXMgLSBpIC0gMVxyXG5cclxuICAgICAgICAgICAgY29uc3QgaXRlbUNvbnRhaW5lciA9IG91dC5fY29sb3JMZWdlbmROb2RlLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1pdGVtJylcclxuXHJcbiAgICAgICAgICAgIC8vIFJlY3RhbmdsZVxyXG4gICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtLnBzQ2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMob3V0Lm1hcCwgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBlY2wpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHRSZWdpb25zKG91dC5tYXApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18sIG91dC5tYXAuc3ZnSWQsIHVuaGlnaGxpZ2h0UmVnaW9ucylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gTGFiZWxcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoICsgb3V0LmNvbG9yTGVnZW5kLmxhYmVsT2Zmc2V0LngpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5jb2xvckxlZ2VuZC5sYWJlbHMpIHJldHVybiBvdXQuY29sb3JMZWdlbmQubGFiZWxzW2ldIC8vIHVzZXItZGVmaW5lZCBsYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIGA+ICR7Zih0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gMV0pfWBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhyZXNob2xkcy5sZW5ndGgpIHJldHVybiBgPCAke2YodGhyZXNob2xkc1swXSl9YFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtmKHRocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpIC0gMV0pfSAtIDwgJHtmKHRocmVzaG9sZHNbdGhyZXNob2xkcy5sZW5ndGggLSBpXSl9YFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9wdGlvbmFsbHkgYWRkIG5vLWRhdGFcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmNvbG9yTGVnZW5kLm1hcmdpblRvcCArIG51bWJlck9mQ2xhc3NlcyAqIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCArIDIwIC8vIGFkZCAyMCB0byBzZXBhcmF0ZSBpdCBmcm9tIHRoZSByZXN0XHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX2NvbG9yTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcblxyXG4gICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5jb2xvckxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZENvbG9yVGhyZXNob2xkc0xlZ2VuZChtKSB7XHJcbiAgICAgICAgLy9kZWZpbmUgZm9ybWF0IGZvciBsYWJlbHNcclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IG91dC5jb2xvckxlZ2VuZC5sYWJlbEZvcm1hdHRlciB8fCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3JcclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIGlmIChvdXQuY29sb3JMZWdlbmQudGl0bGUpIHtcclxuICAgICAgICAgICAgb3V0Ll9jb2xvckxlZ2VuZE5vZGVcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQudGl0bGVGb250U2l6ZSArIG91dC5jb2xvckxlZ2VuZC5tYXJnaW5Ub3ApXHJcbiAgICAgICAgICAgICAgICAudGV4dChvdXQuY29sb3JMZWdlbmQudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4IHBvc2l0aW9uIG9mIGNvbG9yIGxlZ2VuZCBjZWxsc1xyXG4gICAgICAgIGxldCB4ID0gb3V0LmJveFBhZGRpbmdcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBlbGVtZW50cyBmb3IgY2xhc3NlczogcmVjdGFuZ2xlICsgbGFiZWxcclxuICAgICAgICBsZXQgbnVtYmVyT2ZDbGFzc2VzID0gbS5wc0NsYXNzZXNfXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDbGFzc2VzOyBpKyspIHtcclxuICAgICAgICAgICAgLy90aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBlbGVtZW50XHJcbiAgICAgICAgICAgIGxldCB5ID0gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuY29sb3JMZWdlbmQudGl0bGVQYWRkaW5nICsgb3V0LmNvbG9yTGVnZW5kLm1hcmdpblRvcCArIGkgKiBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQgLy8gYWNjb3VudCBmb3IgdGl0bGUgKyBtYXJnaW5cclxuXHJcbiAgICAgICAgICAgIC8vdGhlIGNsYXNzIG51bWJlciwgZGVwZW5kaW5nIG9uIG9yZGVyXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IG91dC5hc2NlbmRpbmcgPyBpIDogbnVtYmVyT2ZDbGFzc2VzIC0gaSAtIDFcclxuXHJcbiAgICAgICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gb3V0Ll9jb2xvckxlZ2VuZE5vZGUuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCR7eX0pYCkuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWl0ZW0nKVxyXG5cclxuICAgICAgICAgICAgLy9hcHBlbmQgc3ltYm9sICYgc3R5bGVcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbS5wc0NsYXNzVG9GaWxsU3R5bGUoKShlY2wsIG51bWJlck9mQ2xhc3NlcykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVXaWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zKG91dC5tYXAsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1hcC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQubWFwLmluc2V0VGVtcGxhdGVzXywgb3V0Lm1hcC5zdmdJZCwgaGlnaGxpZ2h0UmVnaW9ucywgZWNsKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMsIGVjbClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9zZXBhcmF0aW9uIGxpbmVcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxlZ2VuZC1zZXBhcmF0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCAwICsgb3V0LmNvbG9yTGVnZW5kLnNlcExpbmVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgMClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHRpY2sgbGluZVxyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXRpY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIG91dC5jb2xvckxlZ2VuZC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgb3V0LmNvbG9yTGVnZW5kLnNlcExpbmVMZW5ndGggKyBvdXQuY29sb3JMZWdlbmQudGlja0xlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCAwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2xhYmVsXHJcbiAgICAgICAgICAgIGlmIChpIDwgbnVtYmVyT2ZDbGFzc2VzIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvLyB+dmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuY29sb3JMZWdlbmQuc2VwTGluZUxlbmd0aCArIG91dC5jb2xvckxlZ2VuZC50aWNrTGVuZ3RoICsgb3V0LmNvbG9yTGVnZW5kLmxhYmVsT2Zmc2V0LngpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBvdXQuY29sb3JMZWdlbmQuc2hhcGVIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5jb2xvckxlZ2VuZC5sYWJlbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3V0LmNvbG9yTGVnZW5kLmxhYmVsc1tpXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsYWJlbEZvcm1hdHRlcihtLmNsYXNzaWZpZXJDb2xvcl8uaW52ZXJ0RXh0ZW50KG91dC5hc2NlbmRpbmcgPyBlY2wgKyAxIDogZWNsIC0gMSlbb3V0LmFzY2VuZGluZyA/IDAgOiAxXSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vJ25vIGRhdGEnIGxlZ2VuZCBib3hcclxuICAgICAgICBpZiAob3V0LmNvbG9yTGVnZW5kLm5vRGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgeSA9IG91dC50aXRsZUZvbnRTaXplICsgb3V0LmNvbG9yTGVnZW5kLm1hcmdpblRvcCArIG51bWJlck9mQ2xhc3NlcyAqIG91dC5jb2xvckxlZ2VuZC5zaGFwZUhlaWdodCArIDIwIC8vIGFkZCAyMCB0byBzZXBhcmF0ZSBpdCBmcm9tIHRoZSByZXN0XHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvdXQuX2NvbG9yTGVnZW5kTm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1uby1kYXRhLWxlZ2VuZCcpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwke3l9KWApXHJcblxyXG4gICAgICAgICAgICBidWlsZE5vRGF0YUxlZ2VuZChjb250YWluZXIsIG91dC5jb2xvckxlZ2VuZC5ub0RhdGFUZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHRoZSBkMy5zeW1ib2wgb2JqZWN0IGNob3NlbiBieSB0aGUgdXNlclxyXG4gICAgICogQHJldHVybiB7ZDMuc2hhcGUgfHwgU1ZHfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRTaGFwZSgpIHtcclxuICAgICAgICBsZXQgc2hhcGVcclxuICAgICAgICBpZiAob3V0Lm1hcC5wc0N1c3RvbVNWR18pIHtcclxuICAgICAgICAgICAgc2hhcGUgPSBvdXQubWFwLnBzQ3VzdG9tU1ZHX1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0Lm1hcC5wc0N1c3RvbVNoYXBlXykge1xyXG4gICAgICAgICAgICBzaGFwZSA9IG91dC5tYXAucHNDdXN0b21TaGFwZV9cclxuICAgICAgICB9IGVsc2UgaWYgKG91dC5tYXAucHNTaGFwZV8gPT0gJ2JhcicpIHtcclxuICAgICAgICAgICAgLy9mb3IgcmVjdGFuZ2xlcywgd2UgdXNlIGEgY3VzdG9tIGQzIHN5bWJvbFxyXG4gICAgICAgICAgICBsZXQgZHJhd1JlY3RhbmdsZSA9IChjb250ZXh0LCBzaXplKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5zcXJ0KHNpemUpXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ob3V0Lm1hcC5wc0JhcldpZHRoXywgaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ob3V0Lm1hcC5wc0JhcldpZHRoXywgMClcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIDApXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2hhcGUgPSBzeW1ib2woKS50eXBlKHsgZHJhdzogZHJhd1JlY3RhbmdsZSB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBzeW1ib2xUeXBlID0gc3ltYm9sc0xpYnJhcnlbb3V0Lm1hcC5wc1NoYXBlX10gfHwgc3ltYm9sc0xpYnJhcnlbJ2NpcmNsZSddXHJcbiAgICAgICAgICAgIHNoYXBlID0gc3ltYm9sKCkudHlwZShzeW1ib2xUeXBlKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hhcGVcclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWdobGlnaHQgc2VsZWN0ZWQgcmVnaW9ucyBvbiBtb3VzZW92ZXJcclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbnMobWFwLCBlY2wpIHtcclxuICAgICAgICAvL2ZvciBwcywgdGhlIHN5bWJvbHMgYXJlIHRoZSBjaGlsZHJlbiBvZiBlYWNoIGVtLXByb3Atc3ltYm9scyBlbGVtZW50XHJcbiAgICAgICAgY29uc3QgYWxsU3ltYm9scyA9IG1hcC5zdmdfLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpLnNlbGVjdEFsbCgnW2VjbF0nKVxyXG5cclxuICAgICAgICAvLyBTZXQgYWxsIHN5bWJvbHMgdG8gd2hpdGVcclxuICAgICAgICBhbGxTeW1ib2xzLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IHNlbGVjdCh0aGlzLmNoaWxkTm9kZXNbMF0pXHJcbiAgICAgICAgICAgIHN5bWJvbC5zdHlsZSgnZmlsbCcsICd3aGl0ZScpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gSGlnaGxpZ2h0IG9ubHkgdGhlIHNlbGVjdGVkIHJlZ2lvbnMgYnkgcmVzdG9yaW5nIHRoZWlyIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTeW1ib2xzID0gYWxsU3ltYm9scy5maWx0ZXIoXCJbZWNsPSdcIiArIGVjbCArIFwiJ11cIilcclxuICAgICAgICBzZWxlY3RlZFN5bWJvbHMuZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gc2VsZWN0KHRoaXMuY2hpbGROb2Rlc1swXSlcclxuICAgICAgICAgICAgc3ltYm9sLnN0eWxlKCdmaWxsJywgc3ltYm9sLmF0dHIoJ2ZpbGxfX18nKSkgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvciBmb3Igc2VsZWN0ZWQgcmVnaW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHJlZ2lvbnMgdG8gdGhlaXIgb3JpZ2luYWwgY29sb3JzIG9uIG1vdXNlb3V0XHJcbiAgICBmdW5jdGlvbiB1bmhpZ2hsaWdodFJlZ2lvbnMobWFwKSB7XHJcbiAgICAgICAgLy9mb3IgcHMsIHRoZSBzeW1ib2xzIGFyZSB0aGUgY2hpbGRyZW4gb2YgZWFjaCBlbS1wcm9wLXN5bWJvbHMgZWxlbWVudFxyXG4gICAgICAgIGNvbnN0IGFsbFN5bWJvbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJyNlbS1wcm9wLXN5bWJvbHMnKS5zZWxlY3RBbGwoJ1tlY2xdJylcclxuXHJcbiAgICAgICAgLy8gUmVzdG9yZSBlYWNoIHJlZ2lvbidzIG9yaWdpbmFsIGNvbG9yIGZyb20gdGhlIGZpbGxfX18gYXR0cmlidXRlXHJcbiAgICAgICAgYWxsU3ltYm9scy5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICBzeW1ib2wuc3R5bGUoJ2ZpbGwnLCBzeW1ib2wuYXR0cignZmlsbF9fXycpKSAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbG9yIGZvciBzZWxlY3RlZCByZWdpb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnXHJcbmltcG9ydCAqIGFzIExlZ2VuZCBmcm9tICcuL2xlZ2VuZCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0TGVnZW5kUmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBmb3IgY2hvcm9wbGV0aCBtYXBzXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVnZW5kID0gZnVuY3Rpb24gKG1hcCwgY29uZmlnKSB7XHJcbiAgICAvL2J1aWxkIGdlbmVyaWMgbGVnZW5kIG9iamVjdCBmb3IgdGhlIG1hcFxyXG4gICAgY29uc3Qgb3V0ID0gTGVnZW5kLmxlZ2VuZChtYXApXHJcblxyXG4gICAgLy90aGUgd2lkdGggb2YgdGhlIGxlZ2VuZCBib3ggZWxlbWVudHNcclxuICAgIG91dC5zaGFwZVdpZHRoID0gMjVcclxuICAgIC8vdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlSGVpZ2h0ID0gMjBcclxuICAgIC8vdGhlIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgbGVnZW5kIGJveCBlbGVtZW50c1xyXG4gICAgb3V0LnNoYXBlUGFkZGluZyA9IDVcclxuICAgIC8vdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGVnZW5kIGxhYmVsXHJcbiAgICBvdXQubGFiZWxGb250U2l6ZSA9IDEyXHJcbiAgICAvL3RoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsZWdlbmQgYm94IGVsZW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbGFiZWxcclxuICAgIG91dC5sYWJlbE9mZnNldCA9IDVcclxuICAgIC8vc2hvdyBubyBkYXRhXHJcbiAgICBvdXQubm9EYXRhID0gdHJ1ZVxyXG4gICAgLy9ubyBkYXRhIGxhYmVsIHRleHRcclxuICAgIG91dC5ub0RhdGFUZXh0ID0gJ05vIGRhdGEnXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZykgZm9yIChsZXQga2V5IGluIGNvbmZpZykgb3V0W2tleV0gPSBjb25maWdba2V5XVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC51cGRhdGVDb25maWcoKVxyXG4gICAgICAgIG91dC51cGRhdGVDb250YWluZXIoKVxyXG5cclxuICAgICAgICBjb25zdCBtID0gb3V0Lm1hcFxyXG4gICAgICAgIGNvbnN0IHN2Z01hcCA9IG0uc3ZnKClcclxuICAgICAgICBjb25zdCBsZ2cgPSBvdXQubGdnXHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBsZ2cuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveFxyXG4gICAgICAgIG91dC5tYWtlQmFja2dyb3VuZEJveCgpXHJcblxyXG4gICAgICAgIC8vZHJhdyB0aXRsZVxyXG4gICAgICAgIGlmIChvdXQudGl0bGUpIHtcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnbmQtdGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC50aXRsZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBsZWdlbmQgZWxlbWVudHMgZm9yIGNsYXNzZXM6IHJlY3RhbmdsZSArIGxhYmVsXHJcbiAgICAgICAgbGV0IGkgPSAwXHJcbiAgICAgICAgY29uc3Qgc2NzID0gbS5jYXRDb2xvcnMoKVxyXG4gICAgICAgIGZvciAobGV0IGNvZGUgaW4gc2NzKSB7XHJcbiAgICAgICAgICAgIC8vdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCB5ID0gb3V0LmJveFBhZGRpbmcgKyAob3V0LnRpdGxlID8gb3V0LnRpdGxlRm9udFNpemUgKyBvdXQuYm94UGFkZGluZyA6IDApICsgaSAqIChvdXQuc2hhcGVIZWlnaHQgKyBvdXQuc2hhcGVQYWRkaW5nKVxyXG5cclxuICAgICAgICAgICAgLy90aGUgY29sb3JcclxuICAgICAgICAgICAgY29uc3QgY29sID0gbS5jYXRDb2xvcnMoKVtjb2RlXSB8fCAnbGlnaHRncmF5J1xyXG5cclxuICAgICAgICAgICAgLy9yZWN0YW5nbGVcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLXJlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBvdXQuYm94UGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zaGFwZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG91dC5zaGFwZUhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHNjc1tjb2RlXSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDAuNSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5yYWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCBoaWdobGlnaHRSZWdpb25zLCBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0UmVnaW9ucyhvdXQubWFwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQubWFwLmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5tYXAuaW5zZXRUZW1wbGF0ZXNfLCBvdXQubWFwLnN2Z0lkLCB1bmhpZ2hsaWdodFJlZ2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vbGFiZWxcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG0uY2F0TGFiZWxzKClbY29kZV0gfHwgY29kZSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Z01hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXR0ZXJuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInJlY3RbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBtLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IG0uY2F0Q29sb3JzKClbY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuICAgICAgICAgICAgICAgICAgICBzdmdNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJyZWN0W2NvZGU9J1wiICsgY29kZSArIFwiJ11cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY29sKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8nbm8gZGF0YScgbGVnZW5kIGJveFxyXG4gICAgICAgIGlmIChvdXQubm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBvdXQuYm94UGFkZGluZyArIChvdXQudGl0bGUgPyBvdXQudGl0bGVGb250U2l6ZSArIG91dC5ib3hQYWRkaW5nIDogMCkgKyBpICogKG91dC5zaGFwZUhlaWdodCArIG91dC5zaGFwZVBhZGRpbmcpXHJcblxyXG4gICAgICAgICAgICAvL3JlY3RhbmdsZVxyXG4gICAgICAgICAgICBsZ2cuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtcmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIG91dC5ib3hQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3V0LnNoYXBlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgb3V0LnNoYXBlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbS5ub0RhdGFGaWxsU3R5bGUoKSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Z01hcC5zZWxlY3QoJyNlbS1udXRzcmcnKS5zZWxlY3RBbGwoXCJbbmQ9J25kJ11cIikuc3R5bGUoJ2ZpbGwnLCBtLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnLCBtLmhvdmVyQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHN2Z01hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcjZW0tbnV0c3JnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5ub0RhdGFGaWxsU3R5bGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbCcsIG0ubm9EYXRhRmlsbFN0eWxlKCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8nbm8gZGF0YScgbGFiZWxcclxuICAgICAgICAgICAgbGdnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgb3V0LmJveFBhZGRpbmcgKyBvdXQuc2hhcGVXaWR0aCArIG91dC5sYWJlbE9mZnNldClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeSArIG91dC5zaGFwZUhlaWdodCAqIDAuNSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KG91dC5ub0RhdGFUZXh0KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnTWFwLnNlbGVjdCgnI2VtLW51dHNyZycpLnNlbGVjdEFsbChcIltuZD0nbmQnXVwiKS5zdHlsZSgnZmlsbCcsIG0uaG92ZXJDb2xvcigpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc3ZnTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyNlbS1udXRzcmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiW25kPSduZCddXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm5vRGF0YUZpbGxTdHlsZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgb3V0LnNldEJveERpbWVuc2lvbigpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9ucyhtYXAsIGNvZGUpIHtcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKCdwYXR0ZXJuJykuc2VsZWN0QWxsKCdyZWN0Jyk7XHJcbiAgICBcclxuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIGNvbG9ycyBpZiBub3QgYWxyZWFkeSBzdG9yZWRcclxuICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IHNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCFlbC5hdHRyKCdkYXRhLW9yaWdpbmFsLWZpbGwnKSkge1xyXG4gICAgICAgICAgICAgICAgZWwuYXR0cignZGF0YS1vcmlnaW5hbC1maWxsJywgZWwuc3R5bGUoJ2ZpbGwnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuc3R5bGUoJ2ZpbGwnLCAnd2hpdGUnKTsgLy8gU2V0IGFsbCByZWdpb25zIHRvIHdoaXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICBcclxuICAgICAgICAvLyBIaWdobGlnaHQgb25seSB0aGUgc2VsZWN0ZWQgcmVnaW9ucyBieSByZXN0b3JpbmcgdGhlaXIgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJlZ2lvbnMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoXCJwYXR0ZXJuXCIpLnNlbGVjdEFsbChcInJlY3RbY29kZT0nXCIgKyBjb2RlICsgXCInXVwiKTtcclxuICAgICAgICBzZWxlY3RlZFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBlbC5zdHlsZSgnZmlsbCcsIGVsLmF0dHIoJ2RhdGEtb3JpZ2luYWwtZmlsbCcpKTsgLy8gUmVzdG9yZSBvcmlnaW5hbCBmaWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHVuaGlnaGxpZ2h0UmVnaW9ucyhtYXApIHtcclxuICAgICAgICBjb25zdCBhbGxSZWdpb25zID0gbWFwLnN2Z18uc2VsZWN0QWxsKCdwYXR0ZXJuJykuc2VsZWN0QWxsKCdyZWN0Jyk7XHJcbiAgICBcclxuICAgICAgICAvLyBSZXN0b3JlIGVhY2ggcmVnaW9uJ3Mgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgc3RvcmVkIGF0dHJpYnV0ZVxyXG4gICAgICAgIGFsbFJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsID0gc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZpbGwgPSBlbC5hdHRyKCdkYXRhLW9yaWdpbmFsLWZpbGwnKTtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRmlsbCkge1xyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUoJ2ZpbGwnLCBvcmlnaW5hbEZpbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGdldEZvbnRTaXplRnJvbUNsYXNzIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBBIGV1cm9zdGF0LW1hcCBsZWdlbmQuIFRoaXMgaXMgYW4gYWJzdHJhY3QgbWV0aG9kLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxlZ2VuZCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIC8vYnVpbGQgbGVnZW5kIG9iamVjdFxyXG4gICAgY29uc3Qgb3V0ID0ge31cclxuXHJcbiAgICAvL2xpbmsgbWFwIHRvIGxlZ2VuZFxyXG4gICAgb3V0Lm1hcCA9IG1hcFxyXG5cclxuICAgIC8vdGhlIFNWRyB3aGVyZSB0byBtYWtlIHRoZSBsZWdlbmRcclxuICAgIG91dC5zdmdJZCA9ICdsZWdlbmRfJyArIE1hdGgucm91bmQoMTBlMTUgKiBNYXRoLnJhbmRvbSgpKVxyXG4gICAgb3V0LnN2ZyA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LmxnZyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vdGhlIGxlZ2VuZCBlbGVtZW50IHBvc2l0aW9uLCBpbiBjYXNlIGl0IGlzIGVtYmVkZWQgd2l0aGluIHRoZSBtYXAgU1ZHXHJcbiAgICBvdXQueCA9IHVuZGVmaW5lZFxyXG4gICAgb3V0LnkgPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3RoZSBsZWdlbmQgYm94XHJcbiAgICBvdXQuYm94UGFkZGluZyA9IDdcclxuICAgIG91dC5ib3hPcGFjaXR5ID0gMC43XHJcblxyXG4gICAgLy9sZWdlbmQgdGl0bGVcclxuICAgIG91dC50aXRsZSA9ICcnXHJcbiAgICAvLyB3ZSBub3cgdXNlIENTUyBpbnN0ZWFkIG9mIGlubGluZSBzdHlsZXNcclxuICAgIG91dC50aXRsZUZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC10aXRsZScpXHJcbiAgICAvLyB3ZSBub3cgdXNlIENTUyBpbnN0ZWFkIG9mIGlubGluZSBzdHlsZXNcclxuICAgIG91dC5sYWJlbEZvbnRTaXplID0gZ2V0Rm9udFNpemVGcm9tQ2xhc3MoJ2VtLWxlZ2VuZC1sYWJlbCcpXHJcblxyXG4gICAgLyoqIEJ1aWxkIGxlZ2VuZC4gKi9cclxuICAgIG91dC5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3NldCBTVkcgZWxlbWVudCBhbmQgYWRkIG1haW4gZHJhd2luZyBncm91cFxyXG4gICAgICAgIG91dC5zdmcgPSBzZWxlY3QoJyMnICsgb3V0LnN2Z0lkKVxyXG4gICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGxlZ2VuZChzKVxyXG4gICAgICAgIG91dC5zdmcuc2VsZWN0QWxsKCcjZW0tbGVnZW5kLScgKyBvdXQuc3ZnSWQpLnJlbW92ZSgpXHJcbiAgICAgICAgLy8gYXBwZW5kIG5ldyBsZWdlbmQgZ3JvdXBcclxuICAgICAgICBvdXQubGdnID0gb3V0LnN2Z1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2VtLWxlZ2VuZC0nICsgb3V0LnN2Z0lkKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGVnZW5kJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgbGVnZW5kIGVsZW1lbnQuXHJcbiAgICAgKiBUaGlzIGlzIGFuIGFic3RyYWN0IG1ldGhvZCB0byBiZSBkZWZpbmVkIGZvciBlYWNoIHNwZWNpZmljIGxlZ2VuZC5cclxuICAgICAqL1xyXG4gICAgb3V0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTGVnZW5kIHVwZGF0ZSBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBvdXQudXBkYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IG91dC5tYXBcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBvdXQubGdnXHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9jaGVjayBpZiBwcm92aWRlZCBleHRlcm5hbCBzdmdJZCBoYXMgY2hhbmdlZFxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZFNWRyA9IG91dC5zdmdcclxuICAgICAgICBpZiAobGVnZW5kU1ZHLmF0dHIoJ2lkJykgIT09IG1hcC5sZWdlbmRfLnN2Z0lkKSB7XHJcbiAgICAgICAgICAgIG91dC5idWlsZCgpIC8vIHNldHMgbmV3IHN2ZyBhbmQgbGdnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG91dC51cGRhdGVDb25maWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwID0gb3V0Lm1hcFxyXG4gICAgICAgIC8vIFVwZGF0ZSBsZWdlbmQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAobWFwLmxlZ2VuZF8pIHtcclxuICAgICAgICAgICAgZGVlcE1lcmdlRXhpc3RpbmdLZXlzKG91dCwgbWFwLmxlZ2VuZF8pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3BzXHJcbiAgICAgICAgLy8gLy8gdXBkYXRlIGxlZ2VuZCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIC8vIGlmIChtLmxlZ2VuZF8pXHJcbiAgICAgICAgLy8gICAgIGZvciAobGV0IGtleSBpbiBtLmxlZ2VuZF8pIHtcclxuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkgPT0gJ2NvbG9yTGVnZW5kJyB8fCBrZXkgPT0gJ3NpemVMZWdlbmQnKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBvdXRba2V5XSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIGVhY2ggcHJvcGVydHkgaW4gc2l6ZSBhbmQgY29sb3IgbGVnZW5kIG0ubGVnZW5kX1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBpZiAobS5sZWdlbmRfW2tleV1bcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgb3V0W2tleV1bcF0gPSBtLmxlZ2VuZF9ba2V5XVtwXVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBvdXRba2V5XSA9IG0ubGVnZW5kX1trZXldXHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0l0IHBlcmZvcm1zIGEgc2hhbGxvdyBjb3B5IOKAlCBuZXN0ZWQgb2JqZWN0cyB3aWxsIGJlIGNvcGllZCBieSByZWZlcmVuY2UsIG5vdCBkdXBsaWNhdGVkLlxyXG4gICAgLy9JdCBtb2RpZmllcyB0aGUgdGFyZ2V0IG9iamVjdCAob3V0KSBpbiBwbGFjZS5cclxuICAgIC8vVXNlZnVsIGZvciBtZXJnaW5nIG9iamVjdHMgb3IgZXh0ZW5kaW5nIGV4aXN0aW5nIG9uZXMuXHJcbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2VFeGlzdGluZ0tleXModGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMgPSB7fSwgc2VlbiA9IG5ldyBXZWFrU2V0KCksIGRlcHRoID0gMCkge1xyXG4gICAgICAgIGNvbnN0IE1BWF9ERVBUSCA9IG9wdGlvbnMubWF4RGVwdGggfHwgMTAwXHJcblxyXG4gICAgICAgIGlmIChzZWVuLmhhcyh0YXJnZXQpKSByZXR1cm4gdGFyZ2V0XHJcbiAgICAgICAgc2Vlbi5hZGQodGFyZ2V0KVxyXG5cclxuICAgICAgICBpZiAoZGVwdGggPiBNQVhfREVQVEgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBNYXggcmVjdXJzaW9uIGRlcHRoICgke01BWF9ERVBUSH0pIHJlYWNoZWQuYClcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0YXJnZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlVmFsID0gc291cmNlW2tleV1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbCA9IHRhcmdldFtrZXldXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZ1bmN0aW9uczogb3ZlcndyaXRlIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgcGxhaW4gb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVZhbCkgJiYgaXNQbGFpbk9iamVjdCh0YXJnZXRWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcE1lcmdlRXhpc3RpbmdLZXlzKHRhcmdldFZhbCwgc291cmNlVmFsLCBvcHRpb25zLCBzZWVuLCBkZXB0aCArIDEpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhcnJheXM6IG92ZXJ3cml0ZSAob3IgbWVyZ2UgaWYgb3B0aW9uIHNldClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VWYWwpICYmIEFycmF5LmlzQXJyYXkodGFyZ2V0VmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gb3B0aW9ucy5tZXJnZUFycmF5cyA/IFsuLi5uZXcgU2V0KFsuLi50YXJnZXRWYWwsIC4uLnNvdXJjZVZhbF0pXSA6IFsuLi5zb3VyY2VWYWxdXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBEYXRlc1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWwgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgRGF0ZShzb3VyY2VWYWwuZ2V0VGltZSgpKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUmVnRXhwXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbmV3IFJlZ0V4cChzb3VyY2VWYWwpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBNYXAgYW5kIFNldFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWwgaW5zdGFuY2VvZiBNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBNYXAoc291cmNlVmFsKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWwgaW5zdGFuY2VvZiBTZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ldyBTZXQoc291cmNlVmFsKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVyd3JpdGUgcHJpbWl0aXZlcyBhbmQgb3RoZXIgdHlwZXNcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhlbHBlciB0byBjaGVjayBmb3IgcGxhaW4gb2JqZWN0c1xyXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEcmF3IGxlZ2VuZCBiYWNrZ3JvdW5kIGJveCAqL1xyXG4gICAgb3V0Lm1ha2VCYWNrZ3JvdW5kQm94ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG91dC5sZ2cuYXBwZW5kKCdyZWN0JykuYXR0cignaWQnLCAnbGVnZW5kQlInKS5hdHRyKCdjbGFzcycsICdlbS1sZWdlbmQtYmFja2dyb3VuZCcpLnN0eWxlKCdvcGFjaXR5Jywgb3V0LmJveE9wYWNpdHkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNldCBsZWdlbmQgYm94IGRpbWVuc2lvbnMsIGVuc3VyaW5nIGl0IGhhcyBzdWl0YWJsZSBkaW1lbnNpb25zIHRvIGZpdCB0byBhbGwgbGVnZW5kIGdyYXBoaWMgZWxlbWVudHMgKi9cclxuICAgIG91dC5zZXRCb3hEaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG91dC5sZ2cubm9kZSgpKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGxlZ2VuZCBlbGVtZW50cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgY29uc3QgYmIgPSBvdXQubGdnLm5vZGUoKS5nZXRCQm94KHsgc3Ryb2tlOiB0cnVlIH0pXHJcbiAgICAgICAgICAgIC8vYXBwbHkgdG8gbGVnZW5kIGJveCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBvdXQuYm94UGFkZGluZ1xyXG4gICAgICAgICAgICBvdXQuc3ZnXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcjbGVnZW5kQlInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBiYi54IC0gcClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYmIueSAtIHApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBiYi53aWR0aCArIDIgKiBwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGJiLmhlaWdodCArIDIgKiBwKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuIiwiaW1wb3J0IHsgc2VsZWN0LCBzdHlsZSB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgc2NhbGVPcmRpbmFsIH0gZnJvbSAnZDMtc2NhbGUnXHJcbmltcG9ydCB7IHNjaGVtZVNldDMgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgQ2F0ZWdvcmljYWxMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1jYXRlZ29yaWNhbCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIGdldFJlZ2lvbnNTZWxlY3RvciwgZ2V0VGV4dENvbG9yRm9yQmFja2dyb3VuZCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCB7IGFwcGx5UGF0dGVybkZpbGwgfSBmcm9tICcuLi9jb3JlL3BhdHRlcm4tZmlsbCdcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY2F0ZWdvcmljYWwgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIGZhbHNlLCAnY3QnKVxyXG5cclxuICAgIC8qKiBGaWxsIHN0eWxlIGZvciBlYWNoIGNhdGVnb3J5L2NsYXNzLiBFeC46IHsgdXJiOiBcIiNmZGI0NjJcIiwgaW50OiBcIiNmZmZmYjNcIiwgcnVyOiBcIiNjY2ViYzVcIiB9ICovXHJcbiAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUZXh0IGxhYmVsIGZvciBlYWNoIGNhdGVnb3J5L2NsYXNzLiBFeC46IHsgXCJ1cmJcIjogXCJVcmJhblwiLCBcImludFwiOiBcIkludGVybWVkaWF0ZVwiLCBcInJ1clwiOiBcIlJ1cmFsXCIgfSAqL1xyXG4gICAgb3V0LmNsYXNzVG9UZXh0XyA9IHVuZGVmaW5lZFxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSB0b29sdGlwVGV4dEZ1bkNhdFxyXG5cclxuICAgIC8vdGhlIGNsYXNzaWZpZXI6IGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbJ2NsYXNzVG9GaWxsU3R5bGVfJywgJ2NsYXNzVG9UZXh0XycsICdub0RhdGFGaWxsU3R5bGVfJywgJ3Rvb2x0aXBUZXh0XycsICdjbGFzc2lmaWVyXyddLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbJ2NsYXNzVG9GaWxsU3R5bGUnLCAnY2xhc3NUb1RleHQnLCAnbm9EYXRhRmlsbFN0eWxlJywgJ3Rvb2x0aXBUZXh0JywgJ2NsYXNzaWZpZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcCA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICAvL2dldCBkb21haW4gKHVuaXF1ZSB2YWx1ZXMpXHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gb3V0LnN0YXREYXRhKCkuZ2V0VW5pcXVlVmFsdWVzKClcclxuXHJcbiAgICAgICAgLy9nZXQgcmFuZ2UgWzAsMSwyLDMsLi4uLGRvbWFpbi5sZW5ndGgtMV1cclxuICAgICAgICBjb25zdCByYW5nZSA9IFsuLi5BcnJheShkb21haW4ubGVuZ3RoKS5rZXlzKCldXHJcblxyXG4gICAgICAgIC8vbWFrZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgLy9vbmx5IHVzZSB1c2VyLWRlZmluZSBjbGFzc2VzXHJcbiAgICAgICAgY29uc3QgY3RmcyA9IG91dC5jbGFzc1RvRmlsbFN0eWxlXyA/IG91dC5jbGFzc1RvRmlsbFN0eWxlKCkgOiB1bmRlZmluZWRcclxuICAgICAgICBpZiAoY3Rmcykge1xyXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gT2JqZWN0LmtleXMoY3RmcylcclxuICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoXHJcbiAgICAgICAgICAgICAgICBzY2FsZU9yZGluYWwoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oY2F0ZWdvcmllcykgLy8gT25seSBjbGFzc2lmeSBrbm93biBjYXRlZ29yaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKGNhdGVnb3JpZXMubWFwKChfLCBpKSA9PiBpKSkgLy8gQXNzaWduIG51bWVyaWNhbCBjbGFzc2VzXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2UgYWxsIHVuaXF1ZSB2YWx1ZXMgaWYgbm8gdXNlci1kZWZpbmVkIGNsYXNzZXMgZXhpc3RcclxuICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVPcmRpbmFsKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgY2xhc3NpZmllciBhbmQgc2V0ICdlY2wnIGF0dHJpYnV0ZSB0byByZWdpb25zIGJhc2VkIG9uIHZhbHVlXHJcbiAgICAgICAgY29uc3QgY2xhc3NpZnlSZWdpb25zID0gKHJlZ2lvbnMpID0+IHtcclxuICAgICAgICAgICAgcmVnaW9ucy5hdHRyKCdlY2wnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAnOicpIHJldHVybiAnbmQnIC8vIE5vIGRhdGFcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlzTmFOKHYpID8gdiA6ICt2IC8vIENvbnZlcnQgbnVtYmVycywga2VlcCBzdHJpbmdzIGFzIGlzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8g8J+UuSBFbnN1cmUgb25seSBrbm93biB2YWx1ZXMgYXJlIGNsYXNzaWZpZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzaWZpZXJEb21haW4gPSBvdXQuY2xhc3NpZmllcigpLmRvbWFpbigpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNsYXNzaWZpZXJEb21haW4uaW5jbHVkZXModmFsdWUpKSByZXR1cm4gLy8gU2tpcCB1bmtub3duIHZhbHVlc1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NpZmllcigpKHZhbHVlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcikpXHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBtaXhlZCBOVVRTIGxldmVsLCBzZXBhcmF0aW5nIE5VVFMgbGV2ZWwgMFxyXG4gICAgICAgIGlmIChtYXAubnV0c0xldmVsXyA9PT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICBjb25zdCBudXRzMFJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobnV0czBSZWdpb25zKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm8gY29sb3Igc3BlY2lmaWVkLCB1c2Ugc29tZSBkZWZhdWx0IGNvbG9yc1xyXG4gICAgICAgIGlmICghb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdGZzID0ge31cclxuICAgICAgICAgICAgY29uc3QgZG9tID0gb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5sZW5ndGg7IGkrKykgY3Rmc1tkb21baV1dID0gc2NoZW1lU2V0M1tpICUgMTJdXHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGN0ZnMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseVN0eWxlVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVUb01hcChtYXApIHtcclxuICAgICAgICAvLyBBcHBseSBjb2xvciBhbmQgZXZlbnRzIHRvIHJlZ2lvbnMgaWYgU1ZHIGV4aXN0c1xyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdHJhbnNpdGlvbiBhbmQgc2V0IGluaXRpYWwgZmlsbCBjb2xvcnMgd2l0aCBkYXRhLWRyaXZlbiBsb2dpY1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24ob3V0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgcmVnaW9uc0ZpbGxGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICByZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBhZGRNb3VzZUV2ZW50c1RvUmVnaW9ucyhtYXAsIHJlZ2lvbnMpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBmb250IGNvbG9yIGZvciBncmlkIGNhcnRvZ3JhbXMgKGNvbnRyYXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcuZW0tZ3JpZC10ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29sb3IgPSBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKGNlbGxDb2xvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgdHJhbnNpdGlvbiB0byByZWdpb25zOicsIGVycilcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBhZGRpdGlvbmFsIHNldHRpbmdzIGZvciBtaXhlZCBOVVRTIGxldmVsIHZpZXdcclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYWJlbHMgZm9yIHN0YXRpc3RpY2FsIHZhbHVlcyBpZiByZXF1aXJlZFxyXG4gICAgICAgICAgICBpZiAob3V0LmxhYmVsc18pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXy52YWx1ZXMpIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMobWFwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2FkZCBoYXRjaGluZyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKG91dC5wYXR0ZXJuRmlsbF8pIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5UGF0dGVybkZpbGwobWFwLCBvdXQucGF0dGVybkZpbGxfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gbWl4aW5nIGRpZmZlcmVudCBOVVRTIGxldmVscyAoZS5nLiBzaG93aW5nIE5VVFMgMSBhbmQgTlVUUyAyIGRhdGEgc2ltdWx0YW5lb3VzbHkpXHJcbiAgICBjb25zdCBzdHlsZU1peGVkTlVUUyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBtYXAuc3ZnKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbChnZXRSZWdpb25zU2VsZWN0b3IobWFwKSlcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWNsIHx8IGx2bCA9PT0gJzAnID8gJ2Jsb2NrJyA6ICdub25lJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHNlbC5zdHlsZSgnc3Ryb2tlJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBlY2wgJiYgbHZsICE9PSAnMCcgPyBzdHJva2UgfHwgJyM3NzcnIDogbnVsbFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVjbCAmJiBsdmwgIT09ICcwJyA/IHN0cm9rZVdpZHRoIHx8IDAuMiA6IG51bGxcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWdpb25zRmlsbEZ1bmN0aW9uID0gZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgY29uc3QgZWNsID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbCcpIC8vICd0aGlzJyByZWZlcnMgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcclxuICAgICAgICBpZiAob3V0Lkdlb21ldHJpZXMudXNlckdlb21ldHJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKVxyXG4gICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmNsYXNzVG9GaWxsU3R5bGVfW291dC5jbGFzc2lmaWVyKCkuZG9tYWluKClbZWNsXV1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3V0Lmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIG91dC5jbnRyZ0ZpbGxTdHlsZV9cclxuICAgICAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV9bb3V0LmNsYXNzaWZpZXIoKS5kb21haW4oKVtlY2xdXVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGxTdHlsZSB8fCBvdXQuY250cmdGaWxsU3R5bGVfXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOVVRTIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudHJ5SWQgPSByZy5wcm9wZXJ0aWVzLmlkLnNsaWNlKDAsIDIpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICBpZiAoZWNsID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jbGFzc1RvRmlsbFN0eWxlX1tvdXQuY2xhc3NpZmllcigpLmRvbWFpbigpW2VjbF1dXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMgPSBmdW5jdGlvbiAobWFwLCByZWdpb25zKSB7XHJcbiAgICAgICAgLy8gU2V0IHVwIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKSAvLyBBcHBseSBoaWdobGlnaHQgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBzZWwuYXR0cignZmlsbF9fXycpKSAvLyBSZXZlcnQgdG8gb3JpZ2luYWwgY29sb3JcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQ2F0ZWdvcmljYWxMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKipcclxuICogU3BlY2lmaWMgZnVuY3Rpb24gZm9yIHRvb2x0aXAgdGV4dC5cclxuICpcclxuICogQHBhcmFtIHsqfSByZyBUaGUgcmVnaW9uIHRvIHNob3cgaW5mb3JtYXRpb24gb24uXHJcbiAqIEBwYXJhbSB7Kn0gbWFwIFRoZSBtYXAgZWxlbWVudFxyXG4gKi9cclxuY29uc3QgdG9vbHRpcFRleHRGdW5DYXQgPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgY29uc3QgYnVmID0gW11cclxuICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj4nICsgcmcucHJvcGVydGllcy5uYSArICcgKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPC9kaXY+JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCI+JyArIHJnLnByb3BlcnRpZXMubmEgKyAnPC9kaXY+JylcclxuICAgIH1cclxuICAgIC8vZ2V0IHN0YXQgdmFsdWVcclxuICAgIGNvbnN0IHN2ID0gbWFwLnN0YXREYXRhKCkuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAvL2Nhc2Ugd2hlbiBubyBkYXRhIGF2YWlsYWJsZVxyXG4gICAgaWYgKCFzdiB8fCAoc3YudmFsdWUgIT0gMCAmJiAhc3YudmFsdWUpKSB7XHJcbiAgICAgICAgYnVmLnB1c2gobWFwLm5vRGF0YVRleHRfKVxyXG4gICAgICAgIHJldHVybiBidWYuam9pbignJylcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbCA9IHN2LnZhbHVlXHJcbiAgICBpZiAobWFwLmNsYXNzVG9UZXh0Xykge1xyXG4gICAgICAgIGNvbnN0IGxibCA9IG1hcC5jbGFzc1RvVGV4dF9bdmFsXVxyXG4gICAgICAgIC8vZGlzcGxheSBsYWJlbCBhbmQgdmFsdWVcclxuICAgICAgICBidWYucHVzaChgXHJcbiAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiPlxyXG4gICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgPHRib2R5PlxyXG4gICAgPHRyPlxyXG4gICAgPHRkPlxyXG4gICAgJHtsYmwgPyBsYmwgOiB2YWx9XHJcbiAgICA8L3RkPlxyXG4gICAgPC90cj5cclxuICAgIDwvdGJvZHk+XHJcbiAgICA8L3RhYmxlPlxyXG4gICAgPC9kaXY+XHJcbmApXHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG4gICAgfVxyXG4gICAgLy9kaXNwbGF5IGp1c3QgdmFsdWVcclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0XCI+XHJcbiAgICA8dGFibGUgY2xhc3M9XCJudXRzLXRhYmxlXCI+XHJcbiAgICA8dGJvZHk+XHJcbiAgICA8dHI+XHJcbiAgICA8dGQ+XHJcbiAgICAke3ZhbH1cclxuICAgIDwvdGQ+XHJcbiAgICA8L3RyPlxyXG4gICAgPC90Ym9keT5cclxuICAgIDwvdGFibGU+XHJcbiAgICA8L2Rpdj5cclxuYClcclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVSZ2IgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBCaXZhcmlhdGVMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1jaG9yb3BsZXRoLWJpdmFyaWF0ZSdcclxuaW1wb3J0IHsgZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MsIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciwgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBiaXZhcmlhdGUgY2hvcm9wbGV0aCBtYXAuXHJcbiAqIFNlZTogaHR0cHM6Ly9naXN0Ym9rLnVjZ2lzLm9yZy9ib2stdG9waWNzL211bHRpdmFyaWF0ZS1tYXBwaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgZmFsc2UsICdjaGJpJylcclxuXHJcbiAgICAvL251bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgY2xhc3NpZmljYXRpb24uIFNhbWUgZm9yIGJvdGggdmFyaWFibGVzLlxyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSAzXHJcbiAgICAvL3N0ZXZlbnMuZ3JlZW5ibHVlXHJcbiAgICAvL1RPRE8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZGl2ZXJnaW5nIGNvbG9yIHJhbXBzID9cclxuICAgIG91dC5zdGFydENvbG9yXyA9ICcjZThlOGU4J1xyXG4gICAgb3V0LmNvbG9yMV8gPSAnIzczYWU4MCdcclxuICAgIG91dC5jb2xvcjJfID0gJyM2YzgzYjUnXHJcbiAgICBvdXQuZW5kQ29sb3JfID0gJyMyYTVhNWInXHJcbiAgICAvL2EgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvcnMgZm9yIHRoZSBjbGFzc2VzIGksalxyXG4gICAgb3V0LmNsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyOiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybiBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyMV8gPSB1bmRlZmluZWRcclxuICAgIG91dC5jbGFzc2lmaWVyMl8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHRvb2x0aXBUZXh0RnVuQml2XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ3N0YXJ0Q29sb3JfJyxcclxuICAgICAgICAnY29sb3IxXycsXHJcbiAgICAgICAgJ2NvbG9yMl8nLFxyXG4gICAgICAgICdlbmRDb2xvcl8nLFxyXG4gICAgICAgICdjbGFzc1RvRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyMV8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyMl8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgWydudW1iZXJPZkNsYXNzZXMnLCAnc3RhcnRDb2xvcicsICdjb2xvcjEnLCAnY29sb3IyJywgJ2VuZENvbG9yJywgJ2NsYXNzVG9GaWxsU3R5bGUnLCAnbm9EYXRhRmlsbFN0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9zZXQgY2xhc3NpZmllcnNcclxuICAgICAgICBjb25zdCBzZXR1cENsYXNzaWZpZXJzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RhdDEgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgICAgICBsZXQgc3RhdDIgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0QXJyYXkoKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBbLi4uQXJyYXkob3V0Lm51bWJlck9mQ2xhc3NlcygpKS5rZXlzKCldXHJcbiAgICAgICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIxXykgb3V0LmNsYXNzaWZpZXIxKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDEpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICAgICAgaWYgKCFvdXQuY2xhc3NpZmllcjJfKSBvdXQuY2xhc3NpZmllcjIoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihzdGF0MikucmFuZ2UocmFuZ2UpKVxyXG5cclxuICAgICAgICAgICAgLy9kZWZpbmUgYml2YXJpYXRlIHNjYWxlXHJcbiAgICAgICAgICAgIGlmICghb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBzY2FsZUJpdmFyaWF0ZShvdXQubnVtYmVyT2ZDbGFzc2VzKCksIG91dC5zdGFydENvbG9yKCksIG91dC5jb2xvcjEoKSwgb3V0LmNvbG9yMigpLCBvdXQuZW5kQ29sb3IoKSlcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKHNjYWxlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjbGFzc2lmeVJlZ2lvbnMgPSAocmVnaW9ucykgPT4ge1xyXG4gICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmcucHJvcGVydGllcy5pZC5sZW5ndGggPT0gNCkgY29uc29sZS5sb2cocmcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIyXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignbmQnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdjEgPSBvdXQuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YyID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YxIHx8ICFzdjIpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2ID0gc3YxLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBzdjIudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgc2V0dXBDbGFzc2lmaWVycygpXHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNsYXNzaWZpY2F0aW9uIGFuZCBhc3NpZ24gJ2VjbCcgYXR0cmlidXRlIGJhc2VkIG9uIG1hcCB0eXBlXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGNsYXNzaWZ5UmVnaW9ucyhtYXAuc3ZnKCkuc2VsZWN0QWxsKHNlbGVjdG9yKSlcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtaXhlZCBOVVRTIGxldmVsLCBzZXBhcmF0aW5nIE5VVFMgbGV2ZWwgMFxyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG51dHMwUmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoJ3BhdGguZW0tbnV0c3JnMCcpXHJcbiAgICAgICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobnV0czBSZWdpb25zKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgc3R5bGUgdG8gaW5zZXRzXHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0c1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlTdHlsZVRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseVN0eWxlVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vYXBwbHkgc3R5bGUgdG8gbnV0cyByZWdpb25zXHJcblxyXG4gICAgICAgIC8vIHNldCBjb2xvdXIgb2YgcmVnaW9uc1xyXG4gICAgICAgIGlmIChtYXAuc3ZnKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wxID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDEnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDIgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMicpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlY2wxICYmICFlY2wyKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJykgLy8gR0lTQ08tMjY3OCAtIGxhY2sgb2YgZGF0YSBubyBsb25nZXIgbWVhbnMgbm8gZGF0YSwgaW5zdGVhZCBpdCBpcyBleHBsaWNpdGx5IHNldCB1c2luZyAnOicuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVjbDIgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gb3V0LmNsYXNzVG9GaWxsU3R5bGUoKSgrZWNsMSwgK2VjbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMobWFwLCByZWdpb25zKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZvbnQgY29sb3IgZm9yIGdyaWQgY2FydG9ncmFtcyAoY29udHJhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZ3JpZENhcnRvZ3JhbV8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbG9yID0gc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQoY2VsbENvbG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXQubnV0c0xldmVsXyA9PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU1peGVkTlVUUyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiBtaXhpbmcgZGlmZmVyZW50IE5VVFMgbGV2ZWxzIChlLmcuIHNob3dpbmcgTlVUUyAxIGFuZCBOVVRTIDIgZGF0YSBzaW11bHRhbmVvdXNseSlcclxuICAgIGNvbnN0IHN0eWxlTWl4ZWROVVRTID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIG1hcC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBzZWwuYXR0cignZWNsMScpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gc2VsLmF0dHIoJ2VjbDInKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGRpc3BsYXkgdmlzaWJpbGl0eXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVjbDEgfHwgZWNsMiB8fCBsdmwgPT09ICcwJ1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHN0eWxlcyBlZmZpY2llbnRseVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdkaXNwbGF5JywgaXNWaXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJylcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGVjbDEgfHwgZWNsMikgJiYgbHZsICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpIHx8ICcjNzc3J1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKSB8fCAwLjJcclxuICAgICAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ3N0cm9rZScsIHN0cm9rZSkuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zID0gZnVuY3Rpb24gKG1hcCwgcmVnaW9ucykge1xyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmlsbCA9IHNlbC5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJpdmFyaWF0ZUxlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmNvbnN0IHNjYWxlQml2YXJpYXRlID0gZnVuY3Rpb24gKG51bWJlck9mQ2xhc3Nlcywgc3RhcnRDb2xvciwgY29sb3IxLCBjb2xvcjIsIGVuZENvbG9yKSB7XHJcbiAgICAvL2NvbG9yIHJhbXBzLCBieSByb3dcclxuICAgIGNvbnN0IGNzID0gW11cclxuICAgIC8vaW50ZXJwb2xhdGUgZnJvbSBmaXJzdCBhbmQgbGFzdCBjb2x1bW5zXHJcbiAgICBjb25zdCByYW1wUzEgPSBpbnRlcnBvbGF0ZVJnYihzdGFydENvbG9yLCBjb2xvcjEpXHJcbiAgICBjb25zdCByYW1wMkUgPSBpbnRlcnBvbGF0ZVJnYihjb2xvcjIsIGVuZENvbG9yKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHQgPSBpIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpXHJcbiAgICAgICAgY29uc3QgY29sRnVuID0gaW50ZXJwb2xhdGVSZ2IocmFtcFMxKHQpLCByYW1wMkUodCkpXHJcbiAgICAgICAgY29uc3Qgcm93ID0gW11cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bWJlck9mQ2xhc3NlczsgaisrKSByb3cucHVzaChjb2xGdW4oaiAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSkpXHJcbiAgICAgICAgY3MucHVzaChyb3cpXHJcbiAgICB9XHJcbiAgICAvL1RPRE8gY29tcHV0ZSBvdGhlciBtYXRyaXggYmFzZWQgb24gcm93cywgYW5kIGF2ZXJhZ2UgYm90aD9cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbDEsIGVjbDIpIHtcclxuICAgICAgICByZXR1cm4gY3NbZWNsMV1bZWNsMl1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNwZWNpZmljIGZ1bmN0aW9uIGZvciB0b29sdGlwIHRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcmcgVGhlIHJlZ2lvbiB0byBzaG93IGluZm9ybWF0aW9uIG9uLlxyXG4gKiBAcGFyYW0geyp9IG1hcCBUaGUgbWFwIGVsZW1lbnRcclxuICovXHJcbmNvbnN0IHRvb2x0aXBUZXh0RnVuQml2ID0gZnVuY3Rpb24gKHJnLCBtYXApIHtcclxuICAgIGNvbnN0IGJ1ZiA9IFtdXHJcbiAgICAvL3JlZ2lvbiBuYW1lXHJcbiAgICBjb25zdCByZWdpb25OYW1lID0gcmcucHJvcGVydGllcy5uYSB8fCByZy5wcm9wZXJ0aWVzLm5hbWVcclxuICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgLy9uYW1lIGFuZCBjb2RlXHJcbiAgICAgICAgYnVmLnB1c2goJzxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIiA+JyArIHJlZ2lvbk5hbWUgKyAnICgnICsgcmcucHJvcGVydGllcy5pZCArICcpIDwvZGl2PicpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vcmVnaW9uIG5hbWVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiID4nICsgcmVnaW9uTmFtZSArICc8L2Rpdj4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhdCAxIHZhbHVlXHJcbiAgICBjb25zdCBzdjEgPSBtYXAuc3RhdERhdGEoJ3YxJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICBjb25zdCB1bml0MSA9IG1hcC5zdGF0RGF0YSgndjEnKS51bml0VGV4dCgpXHJcbiAgICAvL3N0YXQgMiB2YWx1ZVxyXG4gICAgY29uc3Qgc3YyID0gbWFwLnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDIgPSBtYXAuc3RhdERhdGEoJ3YyJykudW5pdFRleHQoKVxyXG5cclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiIHN0eWxlPVwiYmFja2dyb3VuZDogI2ZmZmZmZjtjb2xvcjogIzE3MWEyMjtwYWRkaW5nOiA0cHg7Zm9udC1zaXplOjE1cHg7XCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgIDx0Ym9keT5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICR7c3YxICYmIHN2MS52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpIDogJyd9ICR7dW5pdDEgJiYgc3YxICYmIHN2MS52YWx1ZSA/IHVuaXQxIDogJyd9XHJcbiAgICAgICAgJHshc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICR7c3YyICYmIHN2Mi52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjIudmFsdWUpIDogJyd9ICR7dW5pdDIgJiYgc3YyICYmIHN2Mi52YWx1ZSA/IHVuaXQyIDogJyd9XHJcbiAgICAgICAgJHshc3YyIHx8IChzdjIudmFsdWUgIT0gMCAmJiAhc3YyLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHNjYWxlUXVhbnRpbGUgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVSZ2IgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBUcml2YXJpYXRlTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aC10cml2YXJpYXRlJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yLCBleGVjdXRlRm9yQWxsSW5zZXRzLCBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgsIGdldFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgdHJpdmFyaWF0ZSBjaG9yb3BsZXRoIG1hcC5cclxuICogU2VlOiBodHRwczovL2dpc3Rib2sudWNnaXMub3JnL2Jvay10b3BpY3MvbXVsdGl2YXJpYXRlLW1hcHBpbmdcclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCBmYWxzZSwgJ2NodHJpJylcclxuXHJcbiAgICAvL251bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgY2xhc3NpZmljYXRpb24uIFNhbWUgZm9yIGJvdGggdmFyaWFibGVzLlxyXG4gICAgb3V0Lm51bWJlck9mQ2xhc3Nlc18gPSAzXHJcbiAgICAvL3N0ZXZlbnMuZ3JlZW5ibHVlXHJcbiAgICAvL1RPRE8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZGl2ZXJnaW5nIGNvbG9yIHJhbXBzID9cclxuICAgIG91dC5zdGFydENvbG9yXyA9ICcjZThlOGU4J1xyXG4gICAgb3V0LmNvbG9yMV8gPSAnIzA5RjhGRidcclxuICAgIG91dC5jb2xvcjJfID0gJyNGNUQzMDAnXHJcbiAgICBvdXQuY29sb3IzXyA9ICcjRkYxNDkzJ1xyXG4gICAgb3V0LmVuZENvbG9yXyA9ICcjMmE1YTViJ1xyXG4gICAgLy9hIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3JzIGZvciB0aGUgY2xhc3NlcyBpLGpcclxuICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlXyA9IHVuZGVmaW5lZFxyXG4gICAgLy90aGUgY2xhc3NpZmllcjogYSBmdW5jdGlvbiB3aGljaCByZXR1cm4gYSBjbGFzcyBudW1iZXIgZnJvbSBhIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllcjFfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllcjJfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllcjNfID0gdW5kZWZpbmVkXHJcbiAgICAvL3NwZWNpZmljIHRvb2x0aXAgdGV4dCBmdW5jdGlvblxyXG4gICAgb3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbiA9IHRvb2x0aXBUZXh0RnVuY3Rpb25Ucml2YXJpYXRlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ3N0YXJ0Q29sb3JfJyxcclxuICAgICAgICAnY29sb3IxXycsXHJcbiAgICAgICAgJ2NvbG9yMl8nLFxyXG4gICAgICAgICdjb2xvcjNfJyxcclxuICAgICAgICAnZW5kQ29sb3JfJyxcclxuICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjFfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjJfJyxcclxuICAgICAgICAnY2xhc3NpZmllcjNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFsnbnVtYmVyT2ZDbGFzc2VzJywgJ3N0YXJ0Q29sb3InLCAnY29sb3IxJywgJ2NvbG9yMicsICdjb2xvcjMnLCAnZW5kQ29sb3InLCAnY2xhc3NUb0ZpbGxTdHlsZScsICdub0RhdGFGaWxsU3R5bGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1trZXldICE9IHVuZGVmaW5lZCkgb3V0W2tleV0oY29uZmlnW2tleV0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZUNsYXNzaWZpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IGNsYXNzaWZpY2F0aW9uIHRvIGFsbCBpbnNldHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgbWFpbiBtYXAncyBTVkdcclxuICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICBleGVjdXRlRm9yQWxsSW5zZXRzKG91dC5pbnNldFRlbXBsYXRlc18sIG91dC5zdmdJZF8sIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IHRvIG1haW4gbWFwXHJcbiAgICAgICAgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG91dClcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChtYXApIHtcclxuICAgICAgICAvL3NldCBjbGFzc2lmaWVyc1xyXG4gICAgICAgIGxldCBzdGF0MSA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXRBcnJheSgpXHJcbiAgICAgICAgbGV0IHN0YXQyID0gb3V0LnN0YXREYXRhKCd2MicpLmdldEFycmF5KClcclxuICAgICAgICBsZXQgc3RhdDMgPSBvdXQuc3RhdERhdGEoJ3YzJykuZ2V0QXJyYXkoKVxyXG5cclxuICAgICAgICBjb25zdCByYW5nZSA9IFsuLi5BcnJheSg3KS5rZXlzKCldXHJcbiAgICAgICAgaWYgKCFvdXQuY2xhc3NpZmllcjFfKSBvdXQuY2xhc3NpZmllcjEoc2NhbGVRdWFudGlsZSgpLmRvbWFpbihzdGF0MSkucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgIGlmICghb3V0LmNsYXNzaWZpZXIyXykgb3V0LmNsYXNzaWZpZXIyKHNjYWxlUXVhbnRpbGUoKS5kb21haW4oc3RhdDIpLnJhbmdlKHJhbmdlKSlcclxuICAgICAgICBpZiAoIW91dC5jbGFzc2lmaWVyM18pIG91dC5jbGFzc2lmaWVyMyhzY2FsZVF1YW50aWxlKCkuZG9tYWluKHN0YXQzKS5yYW5nZShyYW5nZSkpXHJcblxyXG4gICAgICAgIC8vYXNzaWduIGNsYXNzIHRvIG51dHMgcmVnaW9ucywgYmFzZWQgb24gdGhlaXIgdmFsdWVcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDEnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIyXygrdilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZWNsMycsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MycpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyM18oK3YpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3JlZ2lvbkNsYXNzJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMSA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wxJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wyID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDInKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDMgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMycpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnIHx8IGVjbDIgPT09ICduZCcgfHwgZWNsMyA9PT0gJ25kJykgcmV0dXJuICduZCcgLy8gSGFuZGxlICdubyBkYXRhJ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoZSBjbGFzc2lmaWVyIHJlc3VsdHMgaW50byBhIHNpbmdsZSBjbGFzcyAoMS03KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmICFlY2wyICYmICFlY2wzKSByZXR1cm4gMSAvLyBvbmx5IHZhcmlhYmxlIDEgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsMSAmJiBlY2wyICYmICFlY2wzKSByZXR1cm4gMiAvLyBvbmx5IHZhcmlhYmxlIDIgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsMSAmJiAhZWNsMiAmJiBlY2wzKSByZXR1cm4gMyAvLyBvbmx5IHZhcmlhYmxlIDMgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmIGVjbDIgJiYgIWVjbDMpIHJldHVybiA0IC8vIHZhcmlhYmxlcyAxICYgMiBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVjbDEgJiYgIWVjbDIgJiYgZWNsMykgcmV0dXJuIDUgLy8gdmFyaWFibGVzIDEgJiAzIHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgZWNsMiAmJiBlY2wzKSByZXR1cm4gNiAvLyB2YXJpYWJsZXMgMiAmIDMgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxICYmIGVjbDIgJiYgZWNsMykgcmV0dXJuIDcgLy8gYWxsIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIC5hdHRyKCduZCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAvLyAgICAgY29uc3Qgc3YxID0gb3V0LnN0YXREYXRhKCd2MScpLmdldChyZy5wcm9wZXJ0aWVzLmlkKSB8fCBvdXQuc3RhdERhdGEoKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgLy8gICAgIGNvbnN0IHN2MiA9IG91dC5zdGF0RGF0YSgndjInKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgLy8gICAgIGlmICghc3YxIHx8ICFzdjIpIHJldHVyblxyXG4gICAgICAgICAgICAvLyAgICAgbGV0IHYgPSBzdjEudmFsdWVcclxuICAgICAgICAgICAgLy8gICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgLy8gICAgIHYgPSBzdjIudmFsdWVcclxuICAgICAgICAgICAgLy8gICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiAnJ1xyXG4gICAgICAgICAgICAvLyB9KVxyXG5cclxuICAgICAgICAgICAgLy93aGVuIG1peGluZyBOVVRTLCBsZXZlbCAwIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0IChjbGFzcyBudXRzcmcwKVxyXG4gICAgICAgICAgICBpZiAobWFwLm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5lbS1udXRzcmcwJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIxXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wyJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjJfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDMnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YzJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyM18oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kZWZpbmUgdHJpdmFyaWF0ZSBzY2FsZVxyXG4gICAgICAgICAgICBpZiAoIW91dC5jbGFzc1RvRmlsbFN0eWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVUcml2YXJpYXRlKG91dC5jb2xvcjEoKSwgb3V0LmNvbG9yMigpLCBvdXQuY29sb3IzKCkpXHJcbiAgICAgICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShzY2FsZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy93aGVuIG1peGluZyBOVVRTLCBsZXZlbCAwIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0ICh1c2luZyBjbGFzcyBudXRzcmcwKVxyXG4gICAgICAgICAgICBpZiAob3V0Lm51dHNMZXZlbF8gPT0gJ21peGVkJykge1xyXG4gICAgICAgICAgICAgICAgbWFwLnN2Z19cclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdlY2wxJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gb3V0LnN0YXREYXRhKCd2MicpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN2KSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiAhPSAwICYmICF2KSB8fCB2ID09ICc6JykgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICtvdXQuY2xhc3NpZmllcjFfKCt2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2VjbDInLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBvdXQuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc3YudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9IDAgJiYgIXYpIHx8IHYgPT0gJzonKSByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gK291dC5jbGFzc2lmaWVyMl8oK3YpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZWNsMycsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IG91dC5zdGF0RGF0YSgndjMnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdikgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzdi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgIT0gMCAmJiAhdikgfHwgdiA9PSAnOicpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArb3V0LmNsYXNzaWZpZXIzXygrdilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNjYWxlVHJpdmFyaWF0ZSA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMiwgY29sb3IzKSB7XHJcbiAgICAgICAgLy8gQmxlbmRpbmcgcHJpbWFyeSBjb2xvcnMgYW5kIHRoZWlyIG92ZXJsYXBzXHJcbiAgICAgICAgY29uc3Qgb3ZlcmxhcENvbG9ycyA9IFtcclxuICAgICAgICAgICAgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcjEsIGNvbG9yMl0pLCAvLyBDbGFzcyA0IChPdmVybGFwIG9mIGNvbG9yMSBhbmQgY29sb3IyKVxyXG4gICAgICAgICAgICBtdWx0aXBseUJsZW5kTXVsdGlwbGVIZXgoW2NvbG9yMiwgY29sb3IzXSksIC8vIENsYXNzIDUgKE92ZXJsYXAgb2YgY29sb3IyIGFuZCBjb2xvcjMpXHJcbiAgICAgICAgICAgIG11bHRpcGx5QmxlbmRNdWx0aXBsZUhleChbY29sb3IxLCBjb2xvcjNdKSwgLy8gQ2xhc3MgNiAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgbXVsdGlwbHlCbGVuZE11bHRpcGxlSGV4KFtjb2xvcjEsIGNvbG9yMiwgY29sb3IzXSksIC8vIENsYXNzIDcgKE92ZXJsYXAgb2YgYWxsIHRocmVlKVxyXG4gICAgICAgIF1cclxuXHJcbiAgICAgICAgLy8gQ2xhc3MtdG8tY29sb3IgbWFwcGluZ1xyXG4gICAgICAgIGNvbnN0IGNsYXNzQ29sb3JzID0gW1xyXG4gICAgICAgICAgICBjb2xvcjEsIC8vIENsYXNzIDEgKEZpcnN0IGNvbG9yKVxyXG4gICAgICAgICAgICBjb2xvcjIsIC8vIENsYXNzIDIgKFNlY29uZCBjb2xvcilcclxuICAgICAgICAgICAgY29sb3IzLCAvLyBDbGFzcyAzIChUaGlyZCBjb2xvcilcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1swXSwgLy8gQ2xhc3MgNCAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMilcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1sxXSwgLy8gQ2xhc3MgNSAoT3ZlcmxhcCBvZiBjb2xvcjIgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1syXSwgLy8gQ2xhc3MgNiAoT3ZlcmxhcCBvZiBjb2xvcjEgYW5kIGNvbG9yMylcclxuICAgICAgICAgICAgb3ZlcmxhcENvbG9yc1szXSwgLy8gQ2xhc3MgNyAoT3ZlcmxhcCBvZiBhbGwgdGhyZWUpXHJcbiAgICAgICAgXVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gZnVuY3Rpb24gdG8gZ2V0IGNvbG9yIGJhc2VkIG9uIHJlZ2lvbidzIGNsYXNzICgxIHRvIDcpXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc0luZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc0luZGV4ID49IDEgJiYgY2xhc3NJbmRleCA8PSA3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NDb2xvcnNbY2xhc3NJbmRleCAtIDFdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAvLyBSZXR1cm4gbnVsbCBvciBhIGRlZmF1bHQgY29sb3IgaWYgdGhlIGNsYXNzSW5kZXggaXMgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBzdHlsZSB0byBpbnNldHNcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseVN0eWxlVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5U3R5bGVUb01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlVG9NYXAobWFwKSB7XHJcbiAgICAgICAgLy9hcHBseSBzdHlsZSB0byBudXRzIHJlZ2lvbnNcclxuXHJcbiAgICAgICAgLy8gc2V0IGNvbG91ciBvZiByZWdpb25zXHJcbiAgICAgICAgaWYgKG1hcC5zdmcoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuICAgICAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKG91dC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjbDEgPSBzZWxlY3QodGhpcykuYXR0cignZWNsMScpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNsMiA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wyJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wzID0gc2VsZWN0KHRoaXMpLmF0dHIoJ2VjbDMnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wxID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wyID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlY2wzID09PSAnbmQnKSByZXR1cm4gb3V0Lm5vRGF0YUZpbGxTdHlsZSgpIHx8ICdncmF5J1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVjbDEgJiYgIWVjbDIgJiYgIWVjbDMpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKSAvLyBHSVNDTy0yNjc4IC0gbGFjayBvZiBkYXRhIG5vIGxvbmdlciBtZWFucyBubyBkYXRhLCBpbnN0ZWFkIGl0IGlzIGV4cGxpY2l0bHkgc2V0IHVzaW5nICc6Jy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlZ2lvbkNsYXNzID0gc2VsZWN0KHRoaXMpLmF0dHIoJ3JlZ2lvbkNsYXNzJylcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8ocmVnaW9uQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGdldENTU1Byb3BlcnR5RnJvbUNsYXNzKCdlbS1udXRzcmcnLCAnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb2xvciBmb3IgZWFjaCByZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgbWFwLmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAgICAgaWYgKG91dC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlTWl4ZWROVVRTKG1hcClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LmdldExlZ2VuZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBUcml2YXJpYXRlTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuY29uc3Qgc3R5bGVNaXhlZE5VVFMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICBtYXAuc3ZnKClcclxuICAgICAgICAuc2VsZWN0QWxsKGdldFJlZ2lvbnNTZWxlY3RvcihtYXApKVxyXG4gICAgICAgIC5zdHlsZSgnZGlzcGxheScsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBlY2wgPSBzZWwuYXR0cignZWNsJylcclxuICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50cnlJZCA9IHJnLnByb3BlcnRpZXMuaWQuc2xpY2UoMCwgMilcclxuICAgICAgICAgICAgcmV0dXJuIGVjbCB8fCBsdmwgPT09ICcwJyA/ICdibG9jaycgOiAnbm9uZSdcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgIGNvbnN0IGVjbCA9IHNlbC5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpXHJcbiAgICAgICAgICAgIHJldHVybiBlY2wgJiYgbHZsICE9PSAnMCcgPyBzdHJva2UgfHwgJyM3NzcnIDogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICBjb25zdCBsdmwgPSBzZWwuYXR0cignbHZsJylcclxuICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc2VsLnN0eWxlKCdzdHJva2Utd2lkdGgnKVxyXG4gICAgICAgICAgICByZXR1cm4gZWNsICYmIGx2bCAhPT0gJzAnID8gc3Ryb2tlV2lkdGggfHwgMC4yIDogbnVsbFxyXG4gICAgICAgIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcGVjaWZpYyBmdW5jdGlvbiBmb3IgdG9vbHRpcCB0ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHJnIFRoZSByZWdpb24gdG8gc2hvdyBpbmZvcm1hdGlvbiBvbi5cclxuICogQHBhcmFtIHsqfSBtYXAgVGhlIG1hcCBlbGVtZW50XHJcbiAqL1xyXG5jb25zdCB0b29sdGlwVGV4dEZ1bmN0aW9uVHJpdmFyaWF0ZSA9IGZ1bmN0aW9uIChyZywgbWFwKSB7XHJcbiAgICBjb25zdCBidWYgPSBbXVxyXG4gICAgLy9yZWdpb24gbmFtZVxyXG4gICAgaWYgKHJnLnByb3BlcnRpZXMuaWQpIHtcclxuICAgICAgICAvL25hbWUgYW5kIGNvZGVcclxuICAgICAgICBidWYucHVzaCgnPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiID4nICsgcmcucHJvcGVydGllcy5uYSArICcgKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPC9kaXY+JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtYmFyXCIgPicgKyByZy5wcm9wZXJ0aWVzLm5hICsgJzwvZGl2PicpXHJcbiAgICB9XHJcblxyXG4gICAgLy9zdGF0IDEgdmFsdWVcclxuICAgIGNvbnN0IHN2MSA9IG1hcC5zdGF0RGF0YSgndjEnKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgIGNvbnN0IHVuaXQxID0gbWFwLnN0YXREYXRhKCd2MScpLnVuaXRUZXh0KClcclxuICAgIC8vc3RhdCAyIHZhbHVlXHJcbiAgICBjb25zdCBzdjIgPSBtYXAuc3RhdERhdGEoJ3YyJykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICBjb25zdCB1bml0MiA9IG1hcC5zdGF0RGF0YSgndjInKS51bml0VGV4dCgpXHJcbiAgICAvL3N0YXQgMyB2YWx1ZVxyXG4gICAgY29uc3Qgc3YzID0gbWFwLnN0YXREYXRhKCd2MycpLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgY29uc3QgdW5pdDMgPSBtYXAuc3RhdERhdGEoJ3YyJykudW5pdFRleHQoKVxyXG5cclxuICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXN0YXQtdmlzLXRvb2x0aXAtdGV4dFwiIHN0eWxlPVwiYmFja2dyb3VuZDogI2ZmZmZmZjtjb2xvcjogIzE3MWEyMjtwYWRkaW5nOiA0cHg7Zm9udC1zaXplOjE1cHg7XCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgIDx0Ym9keT5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgIFZhcmlhYmxlIDE6ICR7c3YxICYmIHN2MS52YWx1ZSA/IHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvcihzdjEudmFsdWUpIDogJyd9ICR7dW5pdDEgJiYgc3YxICYmIHN2MS52YWx1ZSA/IHVuaXQxIDogJyd9XHJcbiAgICAgICAgJHshc3YxIHx8IChzdjEudmFsdWUgIT0gMCAmJiAhc3YxLnZhbHVlKSA/IG1hcC5ub0RhdGFUZXh0XyA6ICcnfVxyXG4gICAgICAgIDwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgICAgICA8dHI+XHJcbiAgICAgICAgPHRkPlxyXG4gICAgICAgICBWYXJpYWJsZSAyOiAke3N2MiAmJiBzdjIudmFsdWUgPyBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YyLnZhbHVlKSA6ICcnfSAke3VuaXQyICYmIHN2MiAmJiBzdjIudmFsdWUgPyB1bml0MiA6ICcnfVxyXG4gICAgICAgICR7IXN2MiB8fCAoc3YyLnZhbHVlICE9IDAgJiYgIXN2Mi52YWx1ZSkgPyBtYXAubm9EYXRhVGV4dF8gOiAnJ31cclxuICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICAgICAgPHRyPlxyXG4gICAgICAgIDx0ZD5cclxuICAgICAgICAgVmFyaWFibGUgMzogJHtzdjMgJiYgc3YzLnZhbHVlID8gc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2My52YWx1ZSkgOiAnJ30gJHt1bml0MyAmJiBzdjMgJiYgc3YzLnZhbHVlID8gdW5pdDMgOiAnJ31cclxuICAgICAgICAkeyFzdjMgfHwgKHN2My52YWx1ZSAhPSAwICYmICFzdjMudmFsdWUpID8gbWFwLm5vRGF0YVRleHRfIDogJyd9XHJcbiAgICAgICAgPC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGApXHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2NhbGVRdWFudGlsZSwgc2NhbGVRdWFudGl6ZSwgc2NhbGVUaHJlc2hvbGQgfSBmcm9tICdkMy1zY2FsZSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVZbEduQnUgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCB7IHBpZWNld2lzZSwgaW50ZXJwb2xhdGVMYWIgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBDaG9yb3BsZXRoTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtY2hvcm9wbGV0aCdcclxuaW1wb3J0IHsgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kLCBzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5pbXBvcnQgeyBqZW5rcywgY2ttZWFucyB9IGZyb20gJ3NpbXBsZS1zdGF0aXN0aWNzJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCB7IGFwcGx5UGF0dGVybkZpbGwgfSBmcm9tICcuLi9jb3JlL3BhdHRlcm4tZmlsbCdcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY2hyb3JvcGxldGggbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIGZhbHNlLCAnY2gnKVxyXG5cclxuICAgIC8vdGhlIG51bWJlciBvZiBjbGFzc2VzXHJcbiAgICBvdXQubnVtYmVyT2ZDbGFzc2VzXyA9IDdcclxuICAgIC8vdGhlIGNsYXNzaWZpY2F0aW9uIG1ldGhvZFxyXG4gICAgb3V0LmNsYXNzaWZpY2F0aW9uTWV0aG9kXyA9ICdxdWFudGlsZScgLy8gb3I6IGVxdWludGVyLCB0aHJlc2hvbGRcclxuICAgIC8vdGhlIHRocmVzaG9sZCwgd2hlbiB0aGUgY2xhc3NpZmljYXRpb24gbWV0aG9kIGlzICd0aHJlc2hvbGQnXHJcbiAgICBvdXQudGhyZXNob2xkc18gPSBbMF1cclxuICAgIC8vY29sb3JzIHRvIHVzZSBmb3IgY2xhc3Nlc1xyXG4gICAgb3V0LmNvbG9yc18gPSBudWxsXHJcbiAgICAvL3doZW4gY29tcHV0ZWQgYXV0b21hdGljYWxseSwgZW5zdXJlIHRoZSB0aHJlc2hvbGQgYXJlIG5pY2Ugcm91bmRlZCB2YWx1ZXNcclxuICAgIG91dC5tYWtlQ2xhc3NpZk5pY2VfID0gdHJ1ZVxyXG4gICAgLy90aGUgY29sb3IgZnVuY3Rpb24gWzAsMV0gLT4gY29sb3JcclxuICAgIGxldCBldXJvc3RhdE11bHRpaHVlID0gWycjRkZFQjk5JywgJyNEMUU5QjAnLCAnIzhERDZCOScsICcjNThDMUMwJywgJyMzNzkyQjYnLCAnIzEzNDg5MScsICcjMWQyYjZmJ11cclxuICAgIG91dC5jb2xvckZ1bmN0aW9uXyA9ICh0KSA9PiBwaWVjZXdpc2UoaW50ZXJwb2xhdGVMYWIsIGV1cm9zdGF0TXVsdGlodWUpKE1hdGgubWluKE1hdGgubWF4KDAsIHQpLCAxKSkgLy8gZGVmYXVsdFxyXG4gICAgLy9hIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3IgZnJvbSB0aGUgY2xhc3MgaVxyXG4gICAgb3V0LmNsYXNzVG9GaWxsU3R5bGVfID0gdW5kZWZpbmVkXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyOiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybiBhIGNsYXNzIG51bWJlciBmcm9tIGEgc3RhdCB2YWx1ZS5cclxuICAgIG91dC5jbGFzc2lmaWVyXyA9IHVuZGVmaW5lZFxyXG4gICAgLy8gc2V0IHRvb2x0aXAgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBjaG9yb3BsZXRoVG9vbHRpcEZ1bmN0aW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzXycsXHJcbiAgICAgICAgJ2NsYXNzaWZpY2F0aW9uTWV0aG9kXycsXHJcbiAgICAgICAgJ3RocmVzaG9sZHNfJyxcclxuICAgICAgICAnbWFrZUNsYXNzaWZOaWNlXycsXHJcbiAgICAgICAgJ2NvbG9yRnVuY3Rpb25fJyxcclxuICAgICAgICAnY2xhc3NUb0ZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdub0RhdGFGaWxsU3R5bGVfJyxcclxuICAgICAgICAnY2xhc3NpZmllcl8nLFxyXG4gICAgICAgICdjb2xvcnNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIG9mIHNvbWUgc3BlY2lhbCBnZXR0ZXJzL3NldHRlcnNcclxuICAgIG91dC5jb2xvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5jb2xvckZ1bmN0aW9uX1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdXQuY29sb3JGdW5jdGlvbl8gPSB2XHJcbiAgICAgICAgLy8gdXBkYXRlIGNsYXNzIHN0eWxlIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uXykge1xyXG4gICAgICAgICAgICAvLyBpZiBkb3QgZGVuc2l0eVxyXG4gICAgICAgICAgICBvdXQuY2xhc3NUb0ZpbGxTdHlsZShnZXRGaWxsUGF0dGVybkxlZ2VuZCgpKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGdldENvbG9yTGVnZW5kKG91dC5jb2xvckZ1bmN0aW9uKCksIG91dC5jb2xvcnNfKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG4gICAgb3V0LnRocmVzaG9sZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnRocmVzaG9sZHNfXHJcbiAgICAgICAgb3V0LnRocmVzaG9sZHNfID0gdlxyXG4gICAgICAgIG91dC5udW1iZXJPZkNsYXNzZXModi5sZW5ndGggKyAxKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuICAgIG91dC5maWx0ZXJzRGVmaW5pdGlvbkZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl9cclxuICAgICAgICBvdXQuZmlsdGVyc0RlZmluaXRpb25GdW5jdGlvbl8gPSB2XHJcbiAgICAgICAgaWYgKG91dC5zdmcoKSkgb3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fKG91dC5zdmcoKSwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnbnVtYmVyT2ZDbGFzc2VzJyxcclxuICAgICAgICAgICAgJ2NsYXNzaWZpY2F0aW9uTWV0aG9kJyxcclxuICAgICAgICAgICAgJ3RocmVzaG9sZCcsXHJcbiAgICAgICAgICAgICdtYWtlQ2xhc3NpZk5pY2UnLFxyXG4gICAgICAgICAgICAnY29sb3JGdW5jdGlvbicsXHJcbiAgICAgICAgICAgICdjbGFzc1RvRmlsbFN0eWxlJyxcclxuICAgICAgICAgICAgJ25vRGF0YUZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdjb2xvcnNfJyxcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgY2xhc3NpZmljYXRpb24gdG8gYWxsIGluc2V0cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBtYWluIG1hcCdzIFNWR1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlDbGFzc2lmaWNhdGlvblRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHJhbmdlIFswLCAxLCAyLCAuLi4sIG5iLTFdXHJcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVSYW5nZSA9IChuYikgPT4gWy4uLkFycmF5KG5iKS5rZXlzKCldXHJcblxyXG4gICAgICAgIC8vIENvbmZpZ3VyZSBjbGFzc2lmaWVyIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBjbGFzc2lmaWNhdGlvbiBtZXRob2RcclxuICAgICAgICBjb25zdCBzZXR1cENsYXNzaWZpZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG91dC5zdGF0RGF0YSgpLmdldEFycmF5KClcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZW5lcmF0ZVJhbmdlKG91dC5udW1iZXJPZkNsYXNzZXNfKVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChvdXQuY2xhc3NpZmljYXRpb25NZXRob2RfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFudGlsZSc6IHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuY2xhc3NpZmllcihzY2FsZVF1YW50aWxlKCkuZG9tYWluKGRhdGFBcnJheSkucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcXVhbC1pbnRlcnZhbCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcXVpbnRlcic6IHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuY2xhc3NpZmllcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVRdWFudGl6ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFttaW4oZGF0YUFycmF5KSwgbWF4KGRhdGFBcnJheSldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHJhbmdlKVxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lm1ha2VDbGFzc2lmTmljZV8pIG91dC5jbGFzc2lmaWVyKCkubmljZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RocmVzaG9sZCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQubnVtYmVyT2ZDbGFzc2VzKG91dC50aHJlc2hvbGRzXy5sZW5ndGggKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyKHNjYWxlVGhyZXNob2xkKCkuZG9tYWluKG91dC50aHJlc2hvbGRzXykucmFuZ2UoZ2VuZXJhdGVSYW5nZShvdXQubnVtYmVyT2ZDbGFzc2VzXykpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdqZW5rcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqZW5rc0JyZWFrcyA9IGplbmtzKGRhdGFBcnJheSwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pIC8vIENhbGN1bGF0ZSBicmVha3MgZm9yIEplbmtzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gamVua3NCcmVha3Muc2xpY2UoMSwgLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVUaHJlc2hvbGQoKS5kb21haW4oZG9tYWluKS5yYW5nZShyYW5nZSkpIC8vIFVzZSBKZW5rcyBicmVha3MgaW4gc2NhbGVcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2ttZWFucyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY2ttZWFucyBicmVha3MsIGV4dHJhY3RpbmcgdGhlIG1heGltdW0gdmFsdWUgZnJvbSBlYWNoIGNsdXN0ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBja21lYW5zQnJlYWtzID0gY2ttZWFucyhkYXRhQXJyYXksIG91dC5udW1iZXJPZkNsYXNzZXNfKS5tYXAoKGNsdXN0ZXIpID0+IGNsdXN0ZXIucG9wKCkpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgZG9tYWluIGZvciBzY2FsZVRocmVzaG9sZCBleGNsdWRpbmcgdGhlIGxhc3QgdmFsdWUsIGFzIGl0IHNlcnZlcyBhcyB0aGUgdXBwZXIgYm91bmRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBja21lYW5zQnJlYWtzLnNsaWNlKDAsIC0xKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGNrbWVhbnMgYnJlYWtzIGluIHRoZSBzY2FsZVRocmVzaG9sZCBhbmQgc2V0IHRoZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXIoc2NhbGVUaHJlc2hvbGQoKS5kb21haW4oZG9tYWluKS5yYW5nZShyYW5nZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwbHkgY2xhc3NpZmllciBhbmQgc2V0ICdlY2wnIGF0dHJpYnV0ZSB0byByZWdpb25zIGJhc2VkIG9uIHZhbHVlXHJcbiAgICAgICAgY29uc3QgY2xhc3NpZnlSZWdpb25zID0gKHJlZ2lvbnMpID0+IHtcclxuICAgICAgICAgICAgcmVnaW9ucy5hdHRyKCdlY2wnLCAocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lvbkRhdGEgPSBvdXQuc3RhdERhdGEoKS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGlmICghcmVnaW9uRGF0YSkgcmV0dXJuIC8vIExhY2sgb2YgZGF0YSBpcyBoYW5kbGVkIGV4cGxpY2l0bHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVnaW9uRGF0YS52YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnOicgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiAnbmQnXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/ICtvdXQuY2xhc3NpZmllcl8odmFsdWUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIGNsYXNzaWZpZXJcclxuICAgICAgICBzZXR1cENsYXNzaWZpZXIoKVxyXG5cclxuICAgICAgICAvLyBBcHBseSBjbGFzc2lmaWNhdGlvbiBhbmQgYXNzaWduICdlY2wnIGF0dHJpYnV0ZSBiYXNlZCBvbiBtYXAgdHlwZVxyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0b3IgPSBnZXRSZWdpb25zU2VsZWN0b3IobWFwKVxyXG4gICAgICAgICAgICBjbGFzc2lmeVJlZ2lvbnMobWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcikpXHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgbWl4ZWQgTlVUUyBsZXZlbCwgc2VwYXJhdGluZyBOVVRTIGxldmVsIDBcclxuICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09PSAnbWl4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBudXRzMFJlZ2lvbnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdwYXRoLmVtLW51dHNyZzAnKVxyXG4gICAgICAgICAgICAgICAgY2xhc3NpZnlSZWdpb25zKG51dHMwUmVnaW9ucylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGFwcGx5IHN0eWxlIHRvIGluc2V0c1xyXG4gICAgICAgIGlmIChvdXQuaW5zZXRUZW1wbGF0ZXNfKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVGb3JBbGxJbnNldHMob3V0Lmluc2V0VGVtcGxhdGVzXywgb3V0LnN2Z0lkXywgYXBwbHlTdHlsZVRvTWFwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseVN0eWxlVG9NYXAob3V0KVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vIERlZmluZSBmdW5jdGlvbiB0byBnZXQgYSBjbGFzcycgY29sb3JcclxuICAgICAgICBpZiAob3V0LmZpbHRlcnNEZWZpbml0aW9uRnVuY3Rpb25fKSB7XHJcbiAgICAgICAgICAgIC8vIERvdCBkZW5zaXR5IHN0eWxlXHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGdldEZpbGxQYXR0ZXJuTGVnZW5kKCkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ29sb3IgbGVnZW5kIHN0eWxlXHJcbiAgICAgICAgICAgIG91dC5jbGFzc1RvRmlsbFN0eWxlKGdldENvbG9yTGVnZW5kKG91dC5jb2xvckZ1bmN0aW9uKCksIG91dC5jb2xvcnNfKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IGNvbG9yIGFuZCBldmVudHMgdG8gcmVnaW9ucyBpZiBTVkcgZXhpc3RzXHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcClcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9ucyA9IG1hcC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSB0cmFuc2l0aW9uIGFuZCBzZXQgaW5pdGlhbCBmaWxsIGNvbG9ycyB3aXRoIGRhdGEtZHJpdmVuIGxvZ2ljXHJcbiAgICAgICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCByZWdpb25zRmlsbEZ1bmN0aW9uKVxyXG4gICAgICAgICAgICAgICAgLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGNvbG9yIGZvciBlYWNoIHJlZ2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbnMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIHNlbC5zdHlsZSgnZmlsbCcpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHVwIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZE1vdXNlRXZlbnRzVG9SZWdpb25zKG1hcCwgcmVnaW9ucylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZvbnQgY29sb3IgZm9yIGdyaWQgY2FydG9ncmFtcyAoY29udHJhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5ncmlkQ2FydG9ncmFtXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuc3ZnKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5lbS1ncmlkLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb2xvciA9IHNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQoY2VsbENvbG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKCdFcnJvciBhcHBseWluZyB0cmFuc2l0aW9uIHRvIHJlZ2lvbnM6JywgZXJyKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGFkZGl0aW9uYWwgc2V0dGluZ3MgZm9yIG1peGVkIE5VVFMgbGV2ZWwgdmlld1xyXG4gICAgICAgICAgICBpZiAob3V0Lm51dHNMZXZlbF8gPT09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlTWl4ZWROVVRTKG1hcClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGxhYmVscyBmb3Igc3RhdGlzdGljYWwgdmFsdWVzIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIGlmIChvdXQubGFiZWxzXykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5sYWJlbHNfLnZhbHVlcykgb3V0LnVwZGF0ZVZhbHVlc0xhYmVscyhtYXApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vYWRkIGhhdGNoaW5nIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZiAob3V0LnBhdHRlcm5GaWxsXykge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlQYXR0ZXJuRmlsbChtYXAsIG91dC5wYXR0ZXJuRmlsbF8pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQ2hvcm9wbGV0aExlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICAvLyB3aGVuIG1peGluZyBkaWZmZXJlbnQgTlVUUyBsZXZlbHMgKGUuZy4gc2hvd2luZyBOVVRTIDEgYW5kIE5VVFMgMiBkYXRhIHNpbXVsdGFuZW91c2x5KVxyXG4gICAgY29uc3Qgc3R5bGVNaXhlZE5VVFMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgbWFwLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoZ2V0UmVnaW9uc1NlbGVjdG9yKG1hcCkpXHJcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlbS1jbnRyZycpKSByZXR1cm4gLy8gU2tpcCBjb3VudHJ5IHJlZ2lvbnNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZWNsID0gc2VsLmF0dHIoJ2VjbCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsdmwgPSBzZWwuYXR0cignbHZsJylcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZGlzcGxheSB2aXNpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBlY2wgfHwgbHZsID09PSAnMCdcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBzdHlsZXMgZWZmaWNpZW50bHlcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZGlzcGxheScsIGlzVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZScpXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVjbCAmJiBsdmwgIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHNlbC5zdHlsZSgnc3Ryb2tlJykgfHwgJyM3NzcnXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBzZWwuc3R5bGUoJ3N0cm9rZS13aWR0aCcpIHx8IDAuMlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnc3Ryb2tlJywgc3Ryb2tlKS5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVnaW9uc0ZpbGxGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgIGNvbnN0IGVjbCA9IHNlbGVjdCh0aGlzKS5hdHRyKCdlY2wnKSAvLyAndGhpcycgcmVmZXJzIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XHJcbiAgICAgICAgaWYgKG91dC5HZW9tZXRyaWVzLnVzZXJHZW9tZXRyaWVzKSB7XHJcbiAgICAgICAgICAgIGlmICghZWNsKSByZXR1cm4gZ2V0Q1NTUHJvcGVydHlGcm9tQ2xhc3MoJ2VtLW51dHNyZycsICdmaWxsJylcclxuICAgICAgICAgICAgaWYgKGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgcmV0dXJuIG91dC5jbGFzc1RvRmlsbFN0eWxlKCkoZWNsLCBvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3V0Lmdlb18gPT09ICdXT1JMRCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHRlbXBsYXRlIGxvZ2ljXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVjbCkgcmV0dXJuIG91dC5jbnRyZ0ZpbGxTdHlsZV9cclxuICAgICAgICAgICAgICAgIGlmIChlY2wgPT09ICduZCcpIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBvdXQuY2xhc3NUb0ZpbGxTdHlsZV8oZWNsLCBvdXQubnVtYmVyT2ZDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxsU3R5bGUgfHwgb3V0LmNudHJnRmlsbFN0eWxlX1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTlVUUyB0ZW1wbGF0ZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRyeUlkID0gcmcucHJvcGVydGllcy5pZC5zbGljZSgwLCAyKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlY2wpIHJldHVybiBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcygnZW0tbnV0c3JnJywgJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgaWYgKGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGUoKSB8fCAnZ3JheSdcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2xhc3NUb0ZpbGxTdHlsZSgpKGVjbCwgb3V0Lm51bWJlck9mQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkTW91c2VFdmVudHNUb1JlZ2lvbnMgPSBmdW5jdGlvbiAobWFwLCByZWdpb25zKSB7XHJcbiAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuc3R5bGUoJ2ZpbGwnLCBtYXAuaG92ZXJDb2xvcl8pIC8vIEFwcGx5IGhpZ2hsaWdodCBjb2xvclxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpIC8vIFJldmVydCB0byBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbi8vYnVpbGQgYSBjb2xvciBsZWdlbmQgb2JqZWN0XHJcbmV4cG9ydCBjb25zdCBnZXRDb2xvckxlZ2VuZCA9IGZ1bmN0aW9uIChjb2xvckZ1bmN0aW9uLCBjb2xvckFycmF5KSB7XHJcbiAgICBjb2xvckZ1bmN0aW9uID0gY29sb3JGdW5jdGlvbiB8fCBpbnRlcnBvbGF0ZVlsR25CdVxyXG4gICAgaWYgKGNvbG9yQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckFycmF5W2VjbF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb24oZWNsIC8gKG51bWJlck9mQ2xhc3NlcyAtIDEpKVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQnVpbGQgYSBmaWxsIHBhdHRlcm4gbGVnZW5kIG9iamVjdCB7IG5kOlwid2hpdGVcIiwgMDpcInVybCgjcGF0dGVybl8wKVwiLCAxOlwidXJsKCNwYXR0ZXJuXzEpXCIsIC4uLiB9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RmlsbFBhdHRlcm5MZWdlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCkge1xyXG4gICAgICAgIHJldHVybiAndXJsKCNwYXR0ZXJuXycgKyBlY2wgKyAnKSdcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgY2hvcm9wbGV0aFRvb2x0aXBGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZWdpb24sIG1hcCkge1xyXG4gICAgY29uc3QgYnVmID0gW11cclxuXHJcbiAgICAvLyBIZWFkZXIgd2l0aCByZWdpb24gbmFtZSBhbmQgSURcclxuICAgIGNvbnN0IHJlZ2lvbk5hbWUgPSByZWdpb24ucHJvcGVydGllcy5uYSB8fCByZWdpb24ucHJvcGVydGllcy5uYW1lXHJcbiAgICBjb25zdCByZWdpb25JZCA9IHJlZ2lvbi5wcm9wZXJ0aWVzLmlkXHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPlxyXG4gICAgICAgICAgICA8Yj4ke3JlZ2lvbk5hbWV9PC9iPiR7cmVnaW9uSWQgPyBgICgke3JlZ2lvbklkfSlgIDogJyd9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIC8vIFJldHJpZXZlIHJlZ2lvbidzIGRhdGEgdmFsdWUgYW5kIHVuaXRcclxuICAgIGNvbnN0IHN0YXREYXRhID0gbWFwLnN0YXREYXRhKClcclxuICAgIGNvbnN0IHN2ID0gc3RhdERhdGEuZ2V0KHJlZ2lvbklkKVxyXG4gICAgY29uc3QgdW5pdCA9IHN0YXREYXRhLnVuaXRUZXh0KCkgfHwgJydcclxuXHJcbiAgICAvLyBObyBkYXRhIGNhc2VcclxuICAgIGlmICghc3YgfHwgKHN2LnZhbHVlICE9PSAwICYmICFzdi52YWx1ZSkgfHwgc3YudmFsdWUgPT09ICc6Jykge1xyXG4gICAgICAgIGJ1Zi5wdXNoKGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLXRleHQgbm8tZGF0YVwiPlxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwibnV0cy10YWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD4ke21hcC5ub0RhdGFUZXh0X308L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIGApXHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERhdGEgZGlzcGxheVxyXG4gICAgYnVmLnB1c2goYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0XCI+XHJcbiAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cIm51dHMtdGFibGVcIj5cclxuICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPiR7c3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yKHN2LnZhbHVlKX0gJHt1bml0fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIC8vIE9wdGlvbmFsIHN0YXR1cyBmbGFnXHJcbiAgICBjb25zdCBzdGF0dXNGbGFnID0gc3Yuc3RhdHVzXHJcbiAgICBpZiAoc3RhdHVzRmxhZyAmJiBtYXAudG9vbHRpcF8uc2hvd0ZsYWdzKSB7XHJcbiAgICAgICAgY29uc3QgZmxhZ1RleHQgPSBtYXAudG9vbHRpcF8uc2hvd0ZsYWdzID09PSAnc2hvcnQnID8gc3RhdHVzRmxhZyA6IGZsYWdzW3N0YXR1c0ZsYWddIHx8IHN0YXR1c0ZsYWdcclxuICAgICAgICBidWYucHVzaChgIDxzcGFuIGNsYXNzPVwic3RhdHVzLWZsYWdcIj4ke2ZsYWdUZXh0fTwvc3Bhbj5gKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCIvLyBJbXBvcnQgcmVxdWlyZWQgRDMgbW9kdWxlc1xyXG4vLyBpbXBvcnQgeyBzYW5rZXksIHNhbmtleUxpbmtIb3Jpem9udGFsIH0gZnJvbSAnZDMtc2Fua2V5J1xyXG5pbXBvcnQgeyBsaW5rSG9yaXpvbnRhbCB9IGZyb20gJ2QzLXNoYXBlJ1xyXG5pbXBvcnQgeyBzdW0sIG1heCB9IGZyb20gJ2QzLWFycmF5J1xyXG5pbXBvcnQgeyBzY2FsZUxpbmVhciB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIEZsb3dMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1mbG93J1xyXG5pbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5pbXBvcnQgeyBnZXRSZWdpb25zU2VsZWN0b3IgfSBmcm9tICcuLi9jb3JlL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmbG93IG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCB0cnVlLCAnZmxvdycpXHJcbiAgICBvdXQuc3Ryb2tlV2lkdGhTY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgIG91dC5sYWJlbE9mZnNldFggPSAxNVxyXG4gICAgb3V0LmxhYmVsT2Zmc2V0WSA9IDVcclxuICAgIG91dC5sYWJlbEZvcm1hdHRlciA9IChkKSA9PiBmb3JtYXQoJy4ycycpKGQpXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gZmxvd01hcFRvb2x0aXBGdW5jdGlvblxyXG4gICAgb3V0LmZsb3dDb2xvcl8gPSAnIzcyYmI2ZidcclxuICAgIG91dC5mbG93T3ZlcmxheUNvbG9yc18gPSBbJyNiYmQ3ZWUnLCAnI2M3ZTNjNiddIC8vIGV4cG9ydGVyLCBpbXBvcnRlcnNcclxuICAgIG91dC5mbG93TWF4V2lkdGhfID0gMzBcclxuICAgIG91dC5mbG93TWluV2lkdGhfID0gMVxyXG4gICAgb3V0LmZsb3dBcnJvd3NfID0gdHJ1ZVxyXG4gICAgb3V0LmZsb3dPdXRsaW5lc18gPSB0cnVlXHJcbiAgICBvdXQuZmxvd1RhcmdldE9mZnNldF8gPSAxIC8vIERlZmF1bHQgdG8gbm9ybWFsIG9mZnNldCBiZWhhdmlvclxyXG4gICAgb3V0LmZsb3dHcmFkaWVudF8gPSB0cnVlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmbG93bWFwLXNwZWNpZmljIHNldHRlcnMvZ2V0dGVyc1xyXG4gICAgICovXHJcbiAgICA7W1xyXG4gICAgICAgICdmbG93R3JhcGhfJyxcclxuICAgICAgICAnZmxvd0NvbG9yXycsXHJcbiAgICAgICAgJ2Zsb3dPdmVybGF5Q29sb3JzXycsXHJcbiAgICAgICAgJ2Zsb3dBcnJvd3NfJyxcclxuICAgICAgICAnZmxvd1RhcmdldE9mZnNldF8nLFxyXG4gICAgICAgICdmbG93TWF4V2lkdGhfJyxcclxuICAgICAgICAnZmxvd01pbldpZHRoXycsXHJcbiAgICAgICAgJ2Zsb3dPdXRsaW5lc18nLFxyXG4gICAgICAgICdmbG93R3JhZGllbnRfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHR5cGU6IFwiRmVhdHVyZVwiXHJcbiAgICAgICAgLy8gcHJvcGVydGllczogT2JqZWN0IHtpZDogXCJFU1wiLCBuYTogXCJFc3Bhw7FhXCJ9XHJcbiAgICAgICAgLy8gZ2VvbWV0cnk6IE9iamVjdCB7dHlwZTogXCJNdWx0aVBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IEFycmF5KDcpfVxyXG4gICAgICAgIC8vIHNvdXJjZTogXCJGUlwiXHJcbiAgICAgICAgLy8gdGFyZ2V0OiBcIkVTXCJcclxuICAgICAgICAvLyB2YWx1ZTogNDU0MjIzMjcuNTZcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHN0cm9rZSB3aWR0aCBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBvdXQuZmxvd0dyYXBoXy5saW5rc1xyXG4gICAgICAgIG91dC5zdHJva2VXaWR0aFNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFswLCBtYXgoZGF0YSwgKGQpID0+IGQudmFsdWUpXSlcclxuICAgICAgICAgICAgLnJhbmdlKFtvdXQuZmxvd01pbldpZHRoXywgb3V0LmZsb3dNYXhXaWR0aF9dKVxyXG5cclxuICAgICAgICBjcmVhdGVGbG93TWFwU1ZHKG91dC5mbG93R3JhcGhfKVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7fVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9UT0RPOiBkZWZpbmUgbGVnZW5kXHJcbiAgICAgICAgcmV0dXJuIEZsb3dMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG1hcCB3aXRoIFNhbmtleSBkaWFncmFtIGFuZCBvdGhlciBlbGVtZW50c1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGFuZCBkYXRhIGZvciB0aGUgbWFwXHJcbiAgICAgKiBleGFtcGxlR3JhcGggPSB7XHJcbiAgICAgICAgICAgICAgICBub2RlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6ICdGUicsIHg6IDY4MS4xODUxODAwNzU5MjYzLCB5OiAyMzAuMzExMjQ3NjM2NDg1ODMgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IGlkOiAnREUnLCB4OiA4MjQuNTQzNzc4MjE1NDQ4OSwgeTogMTIzLjcwMzAyNjQ5MDMyMTk5IH0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgbGlua3M6IFtcclxuICAgICAgICAgICAgICAgICAgICB7IHNvdXJjZTogJ0ZSJywgdGFyZ2V0OiAnREUnLCB2YWx1ZTogODIwMTgzNjkuNzIgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvd01hcFNWRyhncmFwaCkge1xyXG4gICAgICAgIGNvbnN0IHN2ZyA9IG91dC5zdmdfXHJcblxyXG4gICAgICAgIC8vIGlmIG5vZGVzIGluIHRoZSBncmFwaCBkb250IGhhdmUgY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHRoZW4gdXNlIG51dHMyanNvbiBjZW50cm9pZHMgaW5zdGVhZFxyXG4gICAgICAgIGFkZENvb3JkaW5hdGVzVG9HcmFwaChncmFwaClcclxuXHJcbiAgICAgICAgdmFyIHsgbm9kZXMsIGxpbmtzIH0gPSBzYW5rZXkoZ3JhcGgpXHJcblxyXG4gICAgICAgIC8vIERlZmluZSBtYXJrZXIgYW5kIGdyYWRpZW50IElEc1xyXG4gICAgICAgIGNvbnN0IGRlZnMgPSBzdmcuYXBwZW5kKCdkZWZzJylcclxuICAgICAgICBjb25zdCBhcnJvd0lkID0gZ2VuZXJhdGVVbmlxdWVJZCgnYXJyb3cnKVxyXG4gICAgICAgIGNvbnN0IGFycm93T3V0bGluZUlkID0gZ2VuZXJhdGVVbmlxdWVJZCgnYXJyb3ctb3V0bGluZScpXHJcbiAgICAgICAgY29uc3QgZ3JhZGllbnRJZHMgPSBsaW5rcy5tYXAoKCkgPT4gZ2VuZXJhdGVVbmlxdWVJZCgnZ3JhZGllbnQnKSlcclxuXHJcbiAgICAgICAgLy8gQWRkIGFycm93IG1hcmtlcnNcclxuICAgICAgICBpZiAob3V0LmZsb3dBcnJvd3NfKSB7XHJcbiAgICAgICAgICAgIGFkZEFycm93TWFya2VyKGRlZnMsIGFycm93SWQsIG91dC5mbG93Q29sb3JfKVxyXG4gICAgICAgICAgICBhZGRBcnJvd01hcmtlcihkZWZzLCBhcnJvd091dGxpbmVJZCwgJyNmZmZmZmYnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGZsb3cgZ3JhZGllbnRzXHJcbiAgICAgICAgaWYgKG91dC5mbG93R3JhZGllbnRfKSB7XHJcbiAgICAgICAgICAgIGFkZEZsb3dHcmFkaWVudHMoZGVmcywgZ3JhZGllbnRJZHMsIGxpbmtzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVmaW5lIG91ciBjb250YWluZXIgU1ZHXHJcbiAgICAgICAgY29uc3Qgem9vbUdyb3VwID0gc2VsZWN0KCcjZW0tem9vbS1ncm91cC0nICsgb3V0LnN2Z0lkXylcclxuICAgICAgICBjb25zdCBzYW5rZXlDb250YWluZXIgPSB6b29tR3JvdXAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1jb250YWluZXInKVxyXG5cclxuICAgICAgICAvLyBBZGQgZ2VvZ3JhcGhpY2FsIGxheWVyc1xyXG4gICAgICAgIGFkZE92ZXJsYXlQb2x5Z29ucyhzYW5rZXlDb250YWluZXIsIGdyYXBoKVxyXG5cclxuICAgICAgICAvLyBBZGQgU2Fua2V5IGZsb3dzXHJcbiAgICAgICAgYWRkU2Fua2V5Rmxvd3Moc2Fua2V5Q29udGFpbmVyLCBsaW5rcywgYXJyb3dJZCwgYXJyb3dPdXRsaW5lSWQsIGdyYWRpZW50SWRzKVxyXG5cclxuICAgICAgICAvLyBBZGQgYWRkaXRpb25hbCBub2RlcyAoZmlsbCBnYXBzKVxyXG4gICAgICAgIGFkZEZpbGxHYXBzKHNhbmtleUNvbnRhaW5lciwgbm9kZXMpXHJcblxyXG4gICAgICAgIC8vIEFkZCBsYWJlbHMgdG8gbm9kZXNcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18pIGFkZExhYmVscyhzYW5rZXlDb250YWluZXIsIG5vZGVzKVxyXG5cclxuICAgICAgICByZXR1cm4gc3ZnLm5vZGUoKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBnZW9ncmFwaGljYWwgbGF5ZXJzIChyZWdpb25zLCBQT0kgb3ZlcmxheSwgYm9yZGVycylcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdmcgLSBEMyBzZWxlY3Rpb24gb2YgU1ZHIGNvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRPdmVybGF5UG9seWdvbnMoc3ZnLCBncmFwaCkge1xyXG4gICAgICAgIGNvbnN0IGltcG9ydGVySWRzID0gW11cclxuICAgICAgICBjb25zdCBleHBvcnRlcklkcyA9IFtdXHJcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBvdXQuR2VvbWV0cmllcy5nZXRSZWdpb25GZWF0dXJlcygpXHJcbiAgICAgICAgaWYgKGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBmZWF0dXJlcy5maW5kKChmZWF0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gZmVhdHVyZS5wcm9wZXJ0aWVzLmlkKSByZXR1cm4gZmVhdHVyZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0ltcG9ydGVyID0gZ3JhcGgubGlua3Muc29tZSgobGluaykgPT4gbGluay5zb3VyY2UgPT0gbm9kZS5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbXBvcnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlcklkcy5wdXNoKG5vZGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZXJJZHMucHVzaChub2RlLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignY291bGQgbm90IGZpbmQgZ2VvbWV0cnkgZm9yJywgbm9kZS5pZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vdXBkYXRlIGV4aXN0aW5nIHJlZ2lvbiBmaWxsc1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihvdXQpXHJcbiAgICAgICAgICAgIGNvbnN0IGFsbFJlZ2lvbnMgPSBvdXQuc3ZnXy5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblxyXG4gICAgICAgICAgICBhbGxSZWdpb25zLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJywgKHJlZ2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlcklkcy5pbmNsdWRlcyhyZWdpb24ucHJvcGVydGllcy5pZCkpIHJldHVybiBvdXQuZmxvd092ZXJsYXlDb2xvcnNfWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9ydGVySWRzLmluY2x1ZGVzKHJlZ2lvbi5wcm9wZXJ0aWVzLmlkKSkgcmV0dXJuIG91dC5mbG93T3ZlcmxheUNvbG9yc19bMV1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIG5vZGVzIGluIHRoZSBncmFwaCBkb250IGhhdmUgY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHRoZW4gdXNlIG51dHMyanNvbiBjZW50cm9pZHMgaW5zdGVhZFxyXG4gICAgZnVuY3Rpb24gYWRkQ29vcmRpbmF0ZXNUb0dyYXBoKGdyYXBoKSB7XHJcbiAgICAgICAgZ3JhcGgubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUueCAmJiAhbm9kZS55ICYmIG91dC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gb3V0Lkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcy5maW5kKChmZWF0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gZmVhdHVyZS5wcm9wZXJ0aWVzLmlkKSByZXR1cm4gZmVhdHVyZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2VudHJvaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Db29yZHMgPSBvdXQuX3Byb2plY3Rpb24oW2NlbnRyb2lkLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBjZW50cm9pZC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0gc2NyZWVuQ29vcmRzWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS55ID0gc2NyZWVuQ29vcmRzWzFdXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2NvdWxkIG5vdCBmaW5kIGNvb3JkaW5hdGVzIGZvcicsIG5vZGUuaWQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBjZW50cm9pZHMgZGF0YSwgY2FsY3VsYXRlIG9uIHRoZSBmbHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gb3V0Lkdlb21ldHJpZXMuZ2V0UmVnaW9uRmVhdHVyZXMoKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSBmZWF0dXJlLnByb3BlcnRpZXMuaWQpIHJldHVybiBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJvaWQgPSBmZWF0dXJlLnByb3BlcnRpZXMuY2VudHJvaWQgfHwgb3V0Ll9wYXRoRnVuY3Rpb24uY2VudHJvaWQoZmVhdHVyZSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbkNvb3JkcyA9IG91dC5fcHJvamVjdGlvbihbY2VudHJvaWRbMF0sIGNlbnRyb2lkWzFdXSlcclxuICAgICAgICAgICAgICAgIG5vZGUueCA9IHNjcmVlbkNvb3Jkc1swXVxyXG4gICAgICAgICAgICAgICAgbm9kZS55ID0gc2NyZWVuQ29vcmRzWzFdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGdyYXBoKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIERPTSBJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCAtIFByZWZpeCBmb3IgdGhlIElEXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBVbmlxdWUgSURcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVVbmlxdWVJZChwcmVmaXgpIHtcclxuICAgICAgICByZXR1cm4gYCR7cHJlZml4fS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGFycm93IG1hcmtlciB0byB0aGUgZGVmcyBzZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAtIEQzIHNlbGVjdGlvbiBvZiBkZWZzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBNYXJrZXIgSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIEZpbGwgY29sb3Igb2YgdGhlIG1hcmtlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRBcnJvd01hcmtlcihkZWZzLCBpZCwgY29sb3IpIHtcclxuICAgICAgICBkZWZzLmFwcGVuZCgnbWFya2VyJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgaWQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCA3KVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCA3KVxyXG4gICAgICAgICAgICAuYXR0cigncmVmWCcsIDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZZJywgMS41KVxyXG4gICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMCBxMCwxLDAuNSwxLjUgcS0wLjUsMC41LC0wLjUsMS41IHEwLjc1LC0wLjc1LDIsLTEuNSBxLTEuMjUsLTAuNzUsLTIsLTEuNVonKVxyXG5cclxuICAgICAgICAvLyBhZGQgYSBjb3B5IGZvciBtb3VzZW92ZXIgd2l0aCBob3ZlcmVkIGNvbG9yXHJcbiAgICAgICAgZGVmcy5hcHBlbmQoJ21hcmtlcicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGlkICsgJ21vdXNlb3ZlcicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCA3KVxyXG4gICAgICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCA3KVxyXG4gICAgICAgICAgICAuYXR0cigncmVmWCcsIDEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyZWZZJywgMS41KVxyXG4gICAgICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBvdXQuaG92ZXJDb2xvcl8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgJ00wLDAgcTAsMSwwLjUsMS41IHEtMC41LDAuNSwtMC41LDEuNSBxMC43NSwtMC43NSwyLC0xLjUgcS0xLjI1LC0wLjc1LC0yLC0xLjVaJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgbGluZWFyIGdyYWRpZW50IGRlZmluaXRpb25zIGZvciBmbG93IGxpbmtzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAtIEQzIHNlbGVjdGlvbiBvZiBkZWZzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBncmFkaWVudElkcyAtIEFycmF5IG9mIGdyYWRpZW50IElEc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlua3MgLSBTYW5rZXkgbGlua3MgZGF0YVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGRGbG93R3JhZGllbnRzKGRlZnMsIGdyYWRpZW50SWRzLCBsaW5rcykge1xyXG4gICAgICAgIGRlZnMuc2VsZWN0QWxsKCdsaW5lYXJHcmFkaWVudCcpXHJcbiAgICAgICAgICAgIC5kYXRhKGxpbmtzKVxyXG4gICAgICAgICAgICAuam9pbignbGluZWFyR3JhZGllbnQnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAoXywgaSkgPT4gZ3JhZGllbnRJZHNbaV0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgKGQpID0+IGQuc291cmNlLngxKVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCAoZCkgPT4gZC50YXJnZXQueDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIChkKSA9PiBkLnkwKVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCAoZCkgPT4gZC55MSlcclxuICAgICAgICAgICAgLmNhbGwoKGcpID0+IGcuYXBwZW5kKCdzdG9wJykuYXR0cignb2Zmc2V0JywgJzUlJykuYXR0cignc3RvcC1jb2xvcicsIG91dC5mbG93T3ZlcmxheUNvbG9yc19bMF0pKVxyXG4gICAgICAgICAgICAuY2FsbCgoZykgPT4gZy5hcHBlbmQoJ3N0b3AnKS5hdHRyKCdvZmZzZXQnLCAnNTAlJykuYXR0cignc3RvcC1jb2xvcicsIG91dC5mbG93Q29sb3JfKSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgU2Fua2V5IGZsb3dzIChsaW5rcyB3aXRoIG1hcmtlcnMgYW5kIGdyYWRpZW50cylcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdmcgLSBEMyBzZWxlY3Rpb24gb2YgU1ZHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5rcyAtIFNhbmtleSBsaW5rcyBkYXRhXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJyb3dJZCAtIEFycm93IG1hcmtlciBJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFycm93T3V0bGluZUlkIC0gQXJyb3cgb3V0bGluZSBtYXJrZXIgSURcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdyYWRpZW50SWRzIC0gR3JhZGllbnQgSURzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZFNhbmtleUZsb3dzKHN2ZywgbGlua3MsIGFycm93SWQsIGFycm93T3V0bGluZUlkLCBncmFkaWVudElkcykge1xyXG4gICAgICAgIGNvbnN0IGZsb3dzR3JvdXAgPSBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvd3MtZ3JvdXAnKVxyXG4gICAgICAgIGNvbnN0IGZsb3dzID0gZmxvd3NHcm91cC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdlbS1mbG93LWZsb3dzJylcclxuICAgICAgICBjb25zdCBvdXRsaW5lcyA9IGZsb3dzR3JvdXAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1vdXRsaW5lcycpXHJcblxyXG4gICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmssIGkpID0+IHtcclxuICAgICAgICAgICAgLy8gT3V0bGluZSBwYXRoXHJcbiAgICAgICAgICAgIGlmIChvdXQuZmxvd091dGxpbmVzXykge1xyXG4gICAgICAgICAgICAgICAgb3V0bGluZXNcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsIHNhbmtleUxpbmtIb3Jpem9udGFsKCkobGluaykpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjZmZmZmZmJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1saW5rLW91dGxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBsaW5rLndpZHRoICsgMS41KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXItZW5kJywgYHVybCgjJHthcnJvd091dGxpbmVJZH0pYClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFpbiBwYXRoXHJcbiAgICAgICAgICAgIGZsb3dzXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgc2Fua2V5TGlua0hvcml6b250YWwoKShsaW5rKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWZsb3ctbGluaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgb3V0LmZsb3dHcmFkaWVudF8gPyBgdXJsKCMke2dyYWRpZW50SWRzW2ldfSlgIDogb3V0LmZsb3dDb2xvcl8pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgbGluay53aWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdtYXJrZXItZW5kJywgb3V0LmZsb3dBcnJvd3NfID8gYHVybCgjJHthcnJvd0lkfSlgIDogJycpXHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgaG92ZXIgZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG92ZXJlZENvbG9yID0gb3V0LmhvdmVyQ29sb3JfXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgc3Ryb2tlIGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ3N0cm9rZScsIGhvdmVyZWRDb2xvcilcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXJrZXItZW5kIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5mbG93QXJyb3dzXykgc2VsZWN0KHRoaXMpLmF0dHIoJ21hcmtlci1lbmQnLCBgdXJsKCMke2Fycm93SWQgKyAnbW91c2VvdmVyJ30pYClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9vbHRpcCBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihsaW5rLCBvdXQpKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIHN0cm9rZSBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuZmxvd0dyYWRpZW50Xykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignc3Ryb2tlJywgYHVybCgjJHtncmFkaWVudElkc1tpXX0pYClcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuYXR0cignc3Ryb2tlJywgb3V0LmZsb3dDb2xvcl8pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIG1hcmtlci1lbmQgdG8gdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5mbG93QXJyb3dzXykgc2VsZWN0KHRoaXMpLmF0dHIoJ21hcmtlci1lbmQnLCBgdXJsKCMke2Fycm93SWR9KWApXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvb2x0aXAgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyByZWN0YW5nbGVzIHRvIGZpbGwgZ2FwcyBsZWZ0IGJ5IFNhbmtleSBsaW5rc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiBTVkdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIC0gU2Fua2V5IG5vZGVzIGRhdGFcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkRmlsbEdhcHMoc3ZnLCBub2Rlcykge1xyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tZmxvdy1maWxsLWluLWdhcHMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcclxuICAgICAgICAgICAgLmRhdGEobm9kZXMpXHJcbiAgICAgICAgICAgIC5qb2luKCdyZWN0JylcclxuICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4gZC5kZXB0aCAmJiBkLmhlaWdodClcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCkgPT4gZC54MCAtIDAuNSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gZC55MClcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkKSA9PiBkLnkxIC0gZC55MClcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBvdXQuZmxvd0NvbG9yXylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBsYWJlbHMgZm9yIGRhdGEgcG9pbnRzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyAtIEQzIHNlbGVjdGlvbiBvZiB0aGUgU1ZHIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZExhYmVscyhzdmcsIG5vZGVzKSB7XHJcbiAgICAgICAgLy8gRmlsdGVyIHRoZSBub2Rlc1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTm9kZXMgPSBub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUudGFyZ2V0TGlua3MgJiYgbm9kZS5zb3VyY2VMaW5rcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWZsb3ctbGFiZWxzJylcclxuXHJcbiAgICAgICAgLy8gQWRkIGhhbG8gZWZmZWN0XHJcbiAgICAgICAgaWYgKG91dC5sYWJlbHNfPy5zaGFkb3dzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsc1NoYWRvd0dyb3VwID0gY29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWZsb3ctbGFiZWwtc2hhZG93JylcclxuICAgICAgICAgICAgbGFiZWxzU2hhZG93R3JvdXBcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoZmlsdGVyZWROb2RlcylcclxuICAgICAgICAgICAgICAgIC5qb2luKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIChkKSA9PiAoZC54ID4gZC50YXJnZXRMaW5rc1swXS5zb3VyY2UueCA/ICdzdGFydCcgOiAnZW5kJykpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiAoZC54ID4gZC50YXJnZXRMaW5rc1swXS5zb3VyY2UueCA/IGQueCArIG91dC5sYWJlbE9mZnNldFggOiBkLnggLSBvdXQubGFiZWxPZmZzZXRYKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+IGQueSArIG91dC5sYWJlbE9mZnNldFkpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoZCkgPT4gb3V0LmxhYmVsRm9ybWF0dGVyKGQudmFsdWUpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGxhYmVsc1xyXG4gICAgICAgIGNvbnN0IGxhYmVsc0dyb3VwID0gY29udGFpbmVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2VtLWZsb3ctbGFiZWwnKVxyXG4gICAgICAgIC8vYWRkIGJhY2tncm91bmRcclxuICAgICAgICAvLyBBZGQgYmFja2dyb3VuZCByZWN0YW5nbGVzIGFuZCB0ZXh0XHJcbiAgICAgICAgY29uc3QgbGFiZWxFbGVtZW50cyA9IGxhYmVsc0dyb3VwXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKSAvLyBVc2UgYSBncm91cCBmb3IgZWFjaCBsYWJlbCB0byBjb21iaW5lIHJlY3QgYW5kIHRleHRcclxuICAgICAgICAgICAgLmRhdGEoZmlsdGVyZWROb2RlcylcclxuICAgICAgICAgICAgLmpvaW4oJ2cnKSAvLyBBcHBlbmQgYSBncm91cCBmb3IgZWFjaCBsYWJlbFxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IGB0cmFuc2xhdGUoJHtkLnh9LCAke2QueX0pYCkgLy8gUG9zaXRpb24gZ3JvdXAgYXQgdGhlIG5vZGVcclxuXHJcbiAgICAgICAgLy8gQWRkIHRleHQgZmlyc3QgdG8gY2FsY3VsYXRlIGl0cyBzaXplXHJcbiAgICAgICAgbGFiZWxFbGVtZW50c1xyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWxhYmVsLXRleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAoZCkgPT4gKGQueCA+IGQudGFyZ2V0TGlua3NbMF0uc291cmNlLnggPyAnc3RhcnQnIDogJ2VuZCcpKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiAoZC54ID4gZC50YXJnZXRMaW5rc1swXS5zb3VyY2UueCA/IG91dC5sYWJlbE9mZnNldFggOiAtb3V0LmxhYmVsT2Zmc2V0WCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5Jywgb3V0LmxhYmVsT2Zmc2V0WSlcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IG91dC5sYWJlbEZvcm1hdHRlcihkLnZhbHVlKSlcclxuXHJcbiAgICAgICAgLy8gQWRkIGJhY2tncm91bmQgcmVjdGFuZ2xlcyBhZnRlciB0ZXh0IGlzIHJlbmRlcmVkXHJcblxyXG4gICAgICAgIGlmIChvdXQubGFiZWxzXy5iYWNrZ3JvdW5kcykge1xyXG4gICAgICAgICAgICBsYWJlbEVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBzZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJib3ggPSB0ZXh0RWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpIC8vIEdldCBib3VuZGluZyBib3ggb2YgdGhlIHRleHRcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nWCA9IDUgLy8gSG9yaXpvbnRhbCBwYWRkaW5nXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nWSA9IDIgLy8gVmVydGljYWwgcGFkZGluZ1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCByZWN0YW5nbGUgY2VudGVyZWQgYmVoaW5kIHRoZSB0ZXh0XHJcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KCdyZWN0JywgJ3RleHQnKSAvLyBJbnNlcnQgcmVjdCBiZWZvcmUgdGV4dCBpbiBET01cclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tbGFiZWwtYmFja2dyb3VuZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBiYm94LnggLSBwYWRkaW5nWClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGJib3gueSAtIHBhZGRpbmdZKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGJib3gud2lkdGggKyAyICogcGFkZGluZ1gpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGJib3guaGVpZ2h0ICsgMiAqIHBhZGRpbmdZKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGdW5jdGlvbiB0byBhcHBlbmQgYSByZWN0YW5nbGUgYmVoaW5kIHRoZSBsYWJlbFxyXG4gICAgZnVuY3Rpb24gYXBwZW5kTGFiZWxSZWN0KGxhYmVsVGV4dCwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSA1IC8vIEFkZCBzb21lIHBhZGRpbmcgYXJvdW5kIHRoZSB0ZXh0XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSAyIC8vIEFkZCBzb21lIHBhZGRpbmcgYXJvdW5kIHRoZSB0ZXh0XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSB0ZXh0IGVsZW1lbnQgdG8gZ2V0IHRoZSBzaXplXHJcbiAgICAgICAgY29uc3QgYmJveCA9IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykgLy8gTWFrZSB0aGUgdGVtcG9yYXJ5IHRleHQgaW52aXNpYmxlXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsVGV4dCkgLy8gU2V0IHRoZSBsYWJlbCB0ZXh0IHRvIGdldCBpdHMgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgIC5ub2RlKClcclxuICAgICAgICAgICAgLmdldEJCb3goKSAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGV4dFxyXG5cclxuICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gYmJveC53aWR0aFxyXG4gICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gYmJveC5oZWlnaHRcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgdGV4dCBlbGVtZW50IGFmdGVyIGdldHRpbmcgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3QoJ3RleHRbdmlzaWJpbGl0eT1cImhpZGRlblwiXScpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZSB0byBiZSBjZW50ZXJlZCBvbiB0aGUgdGV4dFxyXG4gICAgICAgIGNvbnN0IHggPSAtbGFiZWxXaWR0aCAvIDIgLSBwYWRkaW5nWCAvLyBDZW50ZXIgdGhlIHJlY3QgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgY29uc3QgeSA9IC1sYWJlbEhlaWdodCAvIDIgLSBwYWRkaW5nWSAvLyBDZW50ZXIgdGhlIHJlY3QgdmVydGljYWxseVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgcmVjdGFuZ2xlIHdpdGggcGFkZGluZ1xyXG4gICAgICAgIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB4KSAvLyBQb3NpdGlvbiByZWN0IGhvcml6b250YWxseVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHkpIC8vIFBvc2l0aW9uIHJlY3QgdmVydGljYWxseVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBsYWJlbFdpZHRoICsgMiAqIHBhZGRpbmdYKSAvLyBXaWR0aCBvZiB0aGUgcmVjdCB3aXRoIHBhZGRpbmdcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGxhYmVsSGVpZ2h0ICsgMiAqIHBhZGRpbmdZKSAvLyBIZWlnaHQgb2YgdGhlIHJlY3Qgd2l0aCBwYWRkaW5nXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlbS1sYWJlbC1iYWNrZ3JvdW5kJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBGcm9tIHRoaXMgcG9pbnQgb24gYWxsIGNvZGUgaXMgcmVsYXRlZCB3aXRoIHNwYXRpYWwgc2Fua2V5LiBBZG9wdGVkIGZyb20gdGhpcyBub3RlYm9vazogaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BiYXlyZS9kZWNvbnN0cnVjdGVkLXNhbmtleS1kaWFncmFtXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0Bqb2V3ZGF2aWVzL2Zsb3ctbWFwLW9mLWV1cm9wZVxyXG4gICAgZnVuY3Rpb24gY2xvbmUoeyBub2RlcywgbGlua3MgfSkge1xyXG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBub2Rlcy5tYXAoKGQpID0+IE9iamVjdC5hc3NpZ24oe30sIGQpKSwgbGlua3M6IGxpbmtzLm1hcCgoZCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgZCkpIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYW5rZXkoeyBub2RlcywgbGlua3MgfSkge1xyXG4gICAgICAgIGNvbnN0IGdyYXBoID0gY2xvbmUoeyBub2RlcywgbGlua3MgfSlcclxuICAgICAgICBjb21wdXRlTm9kZUxpbmtzKGdyYXBoKVxyXG4gICAgICAgIGNvbXB1dGVOb2RlVmFsdWVzKGdyYXBoKVxyXG4gICAgICAgIGNvbXB1dGVOb2RlRGVwdGhzKGdyYXBoKVxyXG4gICAgICAgIGNvbXB1dGVOb2RlSGVpZ2h0cyhncmFwaClcclxuICAgICAgICBjb21wdXRlTm9kZUJyZWFkdGhzKGdyYXBoKVxyXG4gICAgICAgIGNvbXB1dGVMaW5rQnJlYWR0aHMoZ3JhcGgpXHJcbiAgICAgICAgcmV0dXJuIGdyYXBoXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVMaW5rcyh7IG5vZGVzLCBsaW5rcyB9KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBbaSwgbm9kZV0gb2Ygbm9kZXMuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuaW5kZXggPSBpXHJcbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MgPSBbXVxyXG4gICAgICAgICAgICBub2RlLnRhcmdldExpbmtzID0gW11cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZUJ5SWQgPSBuZXcgTWFwKG5vZGVzLm1hcCgoZCwgaSkgPT4gW2lkKGQsIGksIG5vZGVzKSwgZF0pKVxyXG4gICAgICAgIGZvciAoY29uc3QgW2ksIGxpbmtdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBsaW5rLmluZGV4ID0gaVxyXG4gICAgICAgICAgICBsZXQgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGlua1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHNvdXJjZSA9IGxpbmsuc291cmNlID0gZmluZChub2RlQnlJZCwgc291cmNlKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHRhcmdldCA9IGxpbmsudGFyZ2V0ID0gZmluZChub2RlQnlJZCwgdGFyZ2V0KVxyXG4gICAgICAgICAgICBzb3VyY2Uuc291cmNlTGlua3MucHVzaChsaW5rKVxyXG4gICAgICAgICAgICB0YXJnZXQudGFyZ2V0TGlua3MucHVzaChsaW5rKVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiAobGlua1NvcnQgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vICAgICBmb3IgKGNvbnN0IHsgc291cmNlTGlua3MsIHRhcmdldExpbmtzIH0gb2Ygbm9kZXMpIHtcclxuICAgICAgICAvLyAgICAgICAgIHNvdXJjZUxpbmtzLnNvcnQobGlua1NvcnQpXHJcbiAgICAgICAgLy8gICAgICAgICB0YXJnZXRMaW5rcy5zb3J0KGxpbmtTb3J0KVxyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmQobm9kZUJ5SWQsIGlkKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVCeUlkLmdldChpZClcclxuICAgICAgICBpZiAoIW5vZGUpIHRocm93IG5ldyBFcnJvcignbWlzc2luZzogJyArIGlkKVxyXG4gICAgICAgIHJldHVybiBub2RlXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVEZXB0aHMoeyBub2RlcyB9KSB7XHJcbiAgICAgICAgY29uc3QgbiA9IG5vZGVzLmxlbmd0aFxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gbmV3IFNldChub2RlcylcclxuICAgICAgICBsZXQgbmV4dCA9IG5ldyBTZXQoKVxyXG4gICAgICAgIGxldCB4ID0gMFxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50LnNpemUpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZGVwdGggPSB4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0IH0gb2Ygbm9kZS5zb3VyY2VMaW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKHRhcmdldClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKyt4ID4gbikgdGhyb3cgbmV3IEVycm9yKCdjaXJjdWxhciBsaW5rJylcclxuICAgICAgICAgICAgY3VycmVudCA9IG5leHRcclxuICAgICAgICAgICAgbmV4dCA9IG5ldyBTZXQoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUhlaWdodHMoeyBub2RlcyB9KSB7XHJcbiAgICAgICAgY29uc3QgbiA9IG5vZGVzLmxlbmd0aFxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gbmV3IFNldChub2RlcylcclxuICAgICAgICBsZXQgbmV4dCA9IG5ldyBTZXQoKVxyXG4gICAgICAgIGxldCB4ID0gMFxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50LnNpemUpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0geFxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHNvdXJjZSB9IG9mIG5vZGUudGFyZ2V0TGlua3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmFkZChzb3VyY2UpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCsreCA+IG4pIHRocm93IG5ldyBFcnJvcignY2lyY3VsYXIgbGluaycpXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0XHJcbiAgICAgICAgICAgIG5leHQgPSBuZXcgU2V0KClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVCcmVhZHRocyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBsaW5rIHdpZHRoc1xyXG4gICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzLmZvckVhY2goKGxpbmspID0+IChsaW5rLndpZHRoID0gb3V0LnN0cm9rZVdpZHRoU2NhbGUobGluay52YWx1ZSkpKVxyXG4gICAgICAgICAgICBub2RlLnRhcmdldExpbmtzLmZvckVhY2goKGxpbmspID0+IChsaW5rLndpZHRoID0gb3V0LnN0cm9rZVdpZHRoU2NhbGUobGluay52YWx1ZSkpKVxyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRvdGFsIHNwYWNlIG5lZWRlZCBieSBsaW5rc1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbExpbmtXaWR0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgc3VtKG5vZGUuc291cmNlTGlua3MsIChkKSA9PiBkLndpZHRoKSxcclxuICAgICAgICAgICAgICAgIHN1bShub2RlLnRhcmdldExpbmtzLCAoZCkgPT4gZC53aWR0aClcclxuICAgICAgICAgICAgKVxyXG5cclxuICAgICAgICAgICAgbm9kZS54MCA9IG5vZGUueDEgPSBub2RlLnhcclxuICAgICAgICAgICAgbm9kZS55MCA9IG5vZGUueSAtIHRvdGFsTGlua1dpZHRoIC8gMlxyXG4gICAgICAgICAgICBub2RlLnkxID0gbm9kZS55ICsgdG90YWxMaW5rV2lkdGggLyAyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW9yZGVyTGlua3Mobm9kZXMpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUxpbmtCcmVhZHRocyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgbGV0IHkwID0gbm9kZS55MFxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2Ygbm9kZS5zb3VyY2VMaW5rcykge1xyXG4gICAgICAgICAgICAgICAgbGluay55MCA9IHkwICsgbGluay53aWR0aCAvIDJcclxuICAgICAgICAgICAgICAgIHkwICs9IGxpbmsud2lkdGhcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHkxID0gbm9kZS55MFxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2Ygbm9kZS50YXJnZXRMaW5rcykge1xyXG4gICAgICAgICAgICAgICAgbGluay55MSA9IHkxICsgbGluay53aWR0aCAvIDJcclxuICAgICAgICAgICAgICAgIHkxICs9IGxpbmsud2lkdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBHcm91cCBub2RlcyBieSBkZXB0aCBhbmQgc3RhY2sgdmVydGljYWxseVxyXG4gICAgZnVuY3Rpb24gc3RhY2tOb2RlWXMobm9kZXMpIHtcclxuICAgICAgICBjb25zdCBieURlcHRoID0gbmV3IE1hcCgpXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghYnlEZXB0aC5oYXMobm9kZS5kZXB0aCkpIGJ5RGVwdGguc2V0KG5vZGUuZGVwdGgsIFtdKVxyXG4gICAgICAgICAgICBieURlcHRoLmdldChub2RlLmRlcHRoKS5wdXNoKG5vZGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtkZXB0aCwgZ3JvdXBdIG9mIGJ5RGVwdGguZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIC8vIFNvcnQgYnkgdmFsdWUgb3IgaWQgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XHJcbiAgICAgICAgICAgIGdyb3VwLnNvcnQoKGEsIGIpID0+IGIudmFsdWUgLSBhLnZhbHVlKVxyXG5cclxuICAgICAgICAgICAgbGV0IHkgPSAxMDAgLy8gc3RhcnRpbmcgeSBwb3NpdGlvblxyXG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gNVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVIZWlnaHQgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgICAgICAgICBzdW0obm9kZS5zb3VyY2VMaW5rcywgKGQpID0+IGQud2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1bShub2RlLnRhcmdldExpbmtzLCAoZCkgPT4gZC53aWR0aClcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIG5vZGUueSA9IHkgKyBub2RlSGVpZ2h0IC8gMlxyXG4gICAgICAgICAgICAgICAgeSArPSBub2RlSGVpZ2h0ICsgcGFkZGluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhvcml6b250YWxTb3VyY2UoZCkge1xyXG4gICAgICAgIHJldHVybiBbZC5zb3VyY2UueDEsIGQueTBdXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaG9yaXpvbnRhbFRhcmdldChkKSB7XHJcbiAgICAgICAgcmV0dXJuIFtkLnRhcmdldC54MCwgZC55MV1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZVZhbHVlcyh7IG5vZGVzIH0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgc3VtKG5vZGUuc291cmNlTGlua3MsIChkKSA9PiBkLnZhbHVlKSxcclxuICAgICAgICAgICAgICAgIHN1bShub2RlLnRhcmdldExpbmtzLCAoZCkgPT4gZC52YWx1ZSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW9yZGVyTGlua3Mobm9kZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgc291cmNlTGlua3MsIHRhcmdldExpbmtzIH0gb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgc291cmNlTGlua3Muc29ydChhc2NlbmRpbmdUYXJnZXRZKVxyXG4gICAgICAgICAgICB0YXJnZXRMaW5rcy5zb3J0KGFzY2VuZGluZ1NvdXJjZVkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFzY2VuZGluZ1RhcmdldFkgPSAoYSwgYikgPT4gYS50YXJnZXQueSAtIGIudGFyZ2V0LnlcclxuICAgIGNvbnN0IGFzY2VuZGluZ1NvdXJjZVkgPSAoYSwgYikgPT4gYS5zb3VyY2UueSAtIGIuc291cmNlLnlcclxuXHJcbiAgICBjb25zdCBpZCA9IChkKSA9PiBkLmlkIC8vIHVzZWQgaW4gc2Fua2V5IGltcG9ydFxyXG5cclxuICAgIGNvbnN0IHNhbmtleUxpbmtIb3Jpem9udGFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsaW5rSG9yaXpvbnRhbCgpLnNvdXJjZShob3Jpem9udGFsU291cmNlKS50YXJnZXQoaG9yaXpvbnRhbFRhcmdldClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbmNvbnN0IGZsb3dNYXBUb29sdGlwRnVuY3Rpb24gPSBmdW5jdGlvbiAobGluaywgbWFwKSB7XHJcbiAgICBjb25zdCBidWYgPSBbXVxyXG5cclxuICAgIC8vIEhlYWRlciB3aXRoIHJlZ2lvbiBuYW1lIGFuZCBJRFxyXG4gICAgY29uc3QgdGl0bGUgPSBgJHtsaW5rLnNvdXJjZS5uYW1lIHx8IGxpbmsuc291cmNlLmlkfSB0byAke2xpbmsudGFyZ2V0Lm5hbWUgfHwgbGluay50YXJnZXQuaWR9YFxyXG4gICAgYnVmLnB1c2goYFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC1iYXJcIj5cclxuICAgICAgICAgICAgPGI+JHt0aXRsZX08L2I+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIC8vIFZhbHVlXHJcbiAgICBidWYucHVzaChgPGRpdiBjbGFzcz0nZXN0YXQtdmlzLXRvb2x0aXAtdGV4dCc+XHJcbiAgICAgICAgJHtsaW5rLnZhbHVlfVxyXG4gICAgICAgIDwvZGl2PmApXHJcblxyXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG59XHJcbiIsImltcG9ydCB7IHNjYWxlU3FydCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBzZWxlY3QsIHNlbGVjdEFsbCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgYXJjLCBwaWUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgZXh0ZW50LCBzdW0gfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgaW50ZXJwb2xhdGVPclJkLCBzY2hlbWVDYXRlZ29yeTEwIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJ1xyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIFBpZWNoYXJ0TGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtcGllY2hhcnRzJ1xyXG5pbXBvcnQgeyBleGVjdXRlRm9yQWxsSW5zZXRzLCBnZXRSZWdpb25zU2VsZWN0b3IsIHNwYWNlQXNUaG91c2FuZFNlcGFyYXRvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb3BvcnRpb25hbCBwaWUgY2hhcnQgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIHRydWUsICdwaWUnKVxyXG5cclxuICAgIC8vIHBpZSBjaGFydHNcclxuICAgIG91dC5waWVNaW5SYWRpdXNfID0gNVxyXG4gICAgb3V0LnBpZU1heFJhZGl1c18gPSAxNVxyXG4gICAgb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXNfID0gMFxyXG4gICAgb3V0LnBpZVN0cm9rZUZpbGxfID0gJ3doaXRlJ1xyXG4gICAgb3V0LnBpZVN0cm9rZVdpZHRoXyA9IDAuM1xyXG5cclxuICAgIC8vdG9vbHRpcCBwaWUgY2hhcnRcclxuICAgIG91dC50b29sdGlwUGllUmFkaXVzXyA9IDQwXHJcbiAgICBvdXQudG9vbHRpcFBpZUlubmVyUmFkaXVzXyA9IDBcclxuXHJcbiAgICAvL2NvbG9ycyAtIGluZGV4ZWQgYnkgY2F0ZWdvcnkgY29kZVxyXG4gICAgb3V0LmNhdENvbG9yc18gPSB1bmRlZmluZWRcclxuICAgIC8vbGFiZWxzIC0gaW5kZXhlZCBieSBjYXRlZ29yeSBjb2RlXHJcbiAgICBvdXQuY2F0TGFiZWxzXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vICdvdGhlcicgc2VjdGlvbiBvZiB0aGUgcGllIGNoYXJ0IGZvciB3aGVuICdvdXQudG90YWxDb2RlXycgaXMgZGVmaW5lZCB3aXRoIHN0YXRQaWUoKVxyXG4gICAgb3V0LnBpZU90aGVyQ29sb3JfID0gJyNGRkNDODAnXHJcbiAgICBvdXQucGllT3RoZXJUZXh0XyA9ICdPdGhlcidcclxuXHJcbiAgICAvL3Nob3cgcGllY2hhcnRzIG9ubHkgd2hlbiBkYXRhIGZvciBhbGwgY2F0ZWdvcmllcyBpcyBjb21wbGV0ZS5cclxuICAgIC8vT3RoZXJ3aXNlLCBjb25zaWRlciB0aGUgcmVnaW9ucyBhcyBiZWluZyB3aXRoIG5vIGRhdGEgYXQgYWxsLlxyXG4gICAgb3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlXyA9IGZhbHNlXHJcblxyXG4gICAgb3V0LnNpemVDbGFzc2lmaWVyXyA9IG51bGwgLy9kMyBzY2FsZSBmb3Igc2NhbGluZyBwaWUgc2l6ZXNcclxuICAgIG91dC5zdGF0UGllXyA9IG51bGxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7W1xyXG4gICAgICAgICdjYXRDb2xvcnNfJyxcclxuICAgICAgICAnY2F0TGFiZWxzXycsXHJcbiAgICAgICAgJ3Nob3dPbmx5V2hlbkNvbXBsZXRlXycsXHJcbiAgICAgICAgJ25vRGF0YUZpbGxTdHlsZV8nLFxyXG4gICAgICAgICdwaWVNYXhSYWRpdXNfJyxcclxuICAgICAgICAncGllTWluUmFkaXVzXycsXHJcbiAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXNfJyxcclxuICAgICAgICAncGllT3RoZXJDb2xvcl8nLFxyXG4gICAgICAgICdwaWVPdGhlclRleHRfJyxcclxuICAgICAgICAncGllU3Ryb2tlRmlsbF8nLFxyXG4gICAgICAgICdwaWVTdHJva2VXaWR0aF8nLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcclxuICAgICAgICBvdXRbYXR0LnN1YnN0cmluZygwLCBhdHQubGVuZ3RoIC0gMSldID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0W2F0dF1cclxuICAgICAgICAgICAgb3V0W2F0dF0gPSB2XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vb3ZlcnJpZGUgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGNvbmZpZyB2YWx1ZXNcclxuICAgIGlmIChjb25maWcpXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnY2F0Q29sb3JzJyxcclxuICAgICAgICAgICAgJ2NhdExhYmVscycsXHJcbiAgICAgICAgICAgICdzaG93T25seVdoZW5Db21wbGV0ZScsXHJcbiAgICAgICAgICAgICdub0RhdGFGaWxsU3R5bGUnLFxyXG4gICAgICAgICAgICAncGllTWF4UmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZU1pblJhZGl1cycsXHJcbiAgICAgICAgICAgICdwaWVDaGFydElubmVyUmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZU90aGVyQ29sb3InLFxyXG4gICAgICAgICAgICAncGllT3RoZXJUZXh0JyxcclxuICAgICAgICAgICAgJ3BpZVN0cm9rZUZpbGwnLFxyXG4gICAgICAgICAgICAncGllU3Ryb2tlV2lkdGgnLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLyoqIFRoZSBjb2RlcyBvZiB0aGUgY2F0ZWdvcmllcyB0byBjb25zaWRlciBmb3IgdGhlIGNvbXBvc2l0aW9uLiAqL1xyXG4gICAgb3V0LnN0YXRDb2Rlc18gPSB1bmRlZmluZWRcclxuICAgIC8qKiBUaGUgY29kZSBvZiB0aGUgXCJ0b3RhbFwiIGNhdGVnb3J5IGluIHRoZSBldXJvc3RhdCBkYXRhYmFzZSAqL1xyXG4gICAgb3V0LnRvdGFsQ29kZV9fID0gdW5kZWZpbmVkXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRlZmluZSBhIHBpZSBjaGFydCBtYXAgZWFzaWx5LCB3aXRob3V0IHJlcGV0aXRpb24gb2YgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBPbmx5IGZvciBldXJvYmFzZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0IEEgcGF0dGVybiBmb3IgdGhlIHN0YXQgZGF0YSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaW0gVGhlIGRpbWVuc2lvbiAoZGVmaW5lZCBpbiBldXJvc3RhdCBSRVNUIEFQSSkgb2YgdGhlIGNvbXBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29kZXMgVGhlIGNhdGVnb3J5IGNvZGVzIG9mIHRoZSBjb21wb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxzIE9wdGlvbmFsOiBUaGUgbGFiZWxzIGZvciB0aGUgY2F0ZWdvcnkgY29kZXNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBPcHRpb25hbDogVGhlIGNvbG9ycyBmb3IgdGhlIGNhdGVnb3J5XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdENvZGUgT3B0aW9uYWw6IFRoZSBjYXRlZ29yeSBjb2RlIG9mIHRoZSB0b3RhbCAodXNlZCB0byBjYWxjdWxhdGUgdG90YWwgJiBcIm90aGVyXCIgdmFsdWVzIGlmIGNvZGVzIGFycmF5IGRvbnQgcmVwcmVzZW50IGFsbCBwb3NzaWJsZSBjYXRlZ29yaWVzKVxyXG4gICAgICovXHJcbiAgICBvdXQuc3RhdFBpZSA9IGZ1bmN0aW9uIChzdGF0LCBkaW0sIGNvZGVzLCBsYWJlbHMsIGNvbG9ycywgdENvZGUpIHtcclxuICAgICAgICAvL2FkZCBvbmUgZGF0YXNldCAoc3RhdCkgY29uZmlnIGZvciBlYWNoIGNhdGVnb3J5IChjb2RlKVxyXG4gICAgICAgIHN0YXQuZmlsdGVycyA9IHN0YXQuZmlsdGVycyB8fCB7fVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9jYXRlZ29yeSBjb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBjb2Rlc1tpXVxyXG4gICAgICAgICAgICBzdGF0LmZpbHRlcnNbZGltXSA9IGNvZGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHtcclxuICAgICAgICAgICAgICAgIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2NfLmZpbHRlcnMgPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdC5maWx0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBzY18uZmlsdGVyc1trZXldID0gc3RhdC5maWx0ZXJzW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQuc3RhdChjb2RlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgcmV0cmlldmUgYW5kIGFzc2lnbiBjb2xvclxyXG4gICAgICAgICAgICBpZiAoY29sb3JzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzXyA9IG91dC5jYXRDb2xvcnNfIHx8IHt9XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0Q29sb3JzX1tjb2RlXSA9IGNvbG9yc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgc3BlY2lmaWVkLCByZXRyaWV2ZSBhbmQgYXNzaWduIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChsYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfID0gb3V0LmNhdExhYmVsc18gfHwge31cclxuICAgICAgICAgICAgICAgIG91dC5jYXRMYWJlbHNfW2NvZGVdID0gbGFiZWxzW2ldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IG91dC5zdGF0Q29kZXNfXHJcbiAgICAgICAgb3V0LnN0YXRDb2Rlc18gPSBjb2Rlc1xyXG5cclxuICAgICAgICAvL3NldCBvdXQudG90YWxDb2RlX1xyXG4gICAgICAgIGlmICh0Q29kZSkge1xyXG4gICAgICAgICAgICBvdXQudG90YWxDb2RlXyA9IHRDb2RlXHJcbiAgICAgICAgICAgIHN0YXQuZmlsdGVyc1tkaW1dID0gdENvZGVcclxuICAgICAgICAgICAgY29uc3Qgc2NfID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQpIHNjX1trZXldID0gc3RhdFtrZXldXHJcbiAgICAgICAgICAgIHNjXy5maWx0ZXJzID0ge31cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHN0YXQuZmlsdGVycykgc2NfLmZpbHRlcnNba2V5XSA9IHN0YXQuZmlsdGVyc1trZXldXHJcbiAgICAgICAgICAgIG91dC5zdGF0KHRDb2RlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL3doZW4gdG90YWwgY29kZSBpcyB1c2VkLCBhbiAnb3RoZXInIHNlY3Rpb24gaXMgYWRkZWQgdG8gdGhlIHBpZVxyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzX1snb3RoZXInXSA9IG91dC5waWVPdGhlckNvbG9yX1xyXG4gICAgICAgICAgICBvdXQuY2F0TGFiZWxzX1snb3RoZXInXSA9IG91dC5waWVPdGhlclRleHRfXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVDbGFzc2lmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgLy9pZiBub3QgcHJvdmlkZWQsIGdldCBsaXN0IG9mIHN0YXQgY29kZXMgZnJvbSB0aGUgbWFwIHN0YXQgZGF0YVxyXG4gICAgICAgIGlmICghb3V0LnN0YXRDb2Rlc18pIHtcclxuICAgICAgICAgICAgLy9nZXQgbGlzdCBvZiBzdGF0IGNvZGVzLlxyXG4gICAgICAgICAgICBvdXQuc3RhdENvZGVzXyA9IE9iamVjdC5rZXlzKG91dC5zdGF0RGF0YV8pXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIFwiZGVmYXVsdFwiLCBpZiBwcmVzZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3V0LnN0YXRDb2Rlc18uaW5kZXhPZignZGVmYXVsdCcpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSBvdXQuc3RhdENvZGVzXy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RlZmluZSBzaXplIHNjYWxpbmcgZnVuY3Rpb25cclxuICAgICAgICBsZXQgZG9tYWluID0gZ2V0RGF0YXNldE1heE1pbigpXHJcbiAgICAgICAgaWYgKCFpc05hTihkb21haW5bMF0pKSB7XHJcbiAgICAgICAgICAgIG91dC5zaXplQ2xhc3NpZmllcl8gPSBzY2FsZVNxcnQoKS5kb21haW4oZG9tYWluKS5yYW5nZShbb3V0LnBpZU1pblJhZGl1c18sIG91dC5waWVNYXhSYWRpdXNfXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgb3V0LnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgYnVpbGQgZGVmYXVsdCBjb2xvciByYW1wXHJcbiAgICAgICAgaWYgKCFvdXQuY2F0Q29sb3JzXykge1xyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzKHt9KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5zdGF0Q29kZXNfLmxlbmd0aDsgaSsrKSBvdXQuY2F0Q29sb3JzX1tvdXQuc3RhdENvZGVzX1tpXV0gPSBzY2hlbWVDYXRlZ29yeTEwW2kgJSAxMF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgaW5pdGlhbGlzZSBjYXRlZ29yeSBsYWJlbHNcclxuICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcblxyXG4gICAgICAgIC8vYnVpbGQgYW5kIGFzc2lnbiBwaWUgY2hhcnRzIHRvIHRoZSByZWdpb25zXHJcbiAgICAgICAgLy9jb2xsZWN0IG51dHMgaWRzIGZyb20gZyBlbGVtZW50cy4gVE9ETzogZmluZCBiZXR0ZXIgd2F5IG9mIHNoYXJpbmcgcmVnaW9ucyB3aXRoIHBpZXNcclxuICAgICAgICBsZXQgcmVnaW9uRmVhdHVyZXMgPSBbXVxyXG4gICAgICAgIGlmIChvdXQuc3ZnXykge1xyXG4gICAgICAgICAgICBsZXQgcyA9IG91dC5zdmdfLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ltID0gcy5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAgICAgc3ltLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXBpZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbkZlYXR1cmVzLnB1c2gocmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncGllXycgKyByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgcmVnaW9uIGhvdmVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihvdXQpXHJcbiAgICAgICAgICAgICAgICBsZXQgcmVnaW9ucyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgICByZWdpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdGaWxsID0gc2VsLmF0dHIoJ2ZpbGxfX18nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGFkZFBpZUNoYXJ0c1RvTWFwKHJlZ2lvbkZlYXR1cmVzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNvbXB1dGUgY29tcG9zaXRpb24gZm9yIHJlZ2lvbiBpZCwgZm9yIGVhY2ggY2F0ZWdvcnkuXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGgsIGZvciBlYWNoIGNhdGVnb3J5LCB0aGUgc2hhcmUgWzAsMV0gb2YgdGhlIGNhdGVnb3J5LlxyXG4gICAgICogQHBhcmFtIHsqfSBpZFxyXG4gICAgICovXHJcbiAgICBjb25zdCBnZXRDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGxldCBjb21wID0ge30sXHJcbiAgICAgICAgICAgIHN1bSA9IDBcclxuICAgICAgICAvL2dldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5LiBDb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL3JldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuc3RhdENvZGVzX1tpXVxyXG4gICAgICAgICAgICBjb25zdCBzID0gb3V0LnN0YXREYXRhKHNjKS5nZXQoaWQpXHJcblxyXG4gICAgICAgICAgICAvL2Nhc2Ugd2hlbiBzb21lIGRhdGEgaXMgbWlzc2luZ1xyXG4gICAgICAgICAgICBpZiAoIXMgfHwgKHMudmFsdWUgIT0gMCAmJiAhcy52YWx1ZSkgfHwgaXNOYU4ocy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZWxzZSBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21wW3NjXSA9IHMudmFsdWVcclxuICAgICAgICAgICAgc3VtICs9IHMudmFsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdoZW4gb3V0LnRvdGFsQ29kZV8gaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIHN1bSBpbnN0ZWFkIG9mIHRoZSBzdW0gb2YgdGhlIHNwZWNpZmllZCBjYXRlZ29yaWVzLlxyXG4gICAgICAgIGlmIChvdXQudG90YWxDb2RlXykge1xyXG4gICAgICAgICAgICBsZXQgcyA9IG91dC5zdGF0RGF0YShvdXQudG90YWxDb2RlXykuZ2V0KGlkKVxyXG4gICAgICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICAgICAgc3VtID0gcy52YWx1ZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VtID09IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jYXNlIHdoZW4gbm8gZGF0YVxyXG4gICAgICAgIGlmIChzdW0gPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL2NvbXB1dGUgcmF0aW9zXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb21wW291dC5zdGF0Q29kZXNfW2ldXSAvPSBzdW1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYWRkIFwib3RoZXJcIiBjYXRlZ29yeSB3aGVuIG91dC50b3RhbENvZGVfIGlzIHVzZWRcclxuICAgICAgICBpZiAob3V0LnRvdGFsQ29kZV8pIHtcclxuICAgICAgICAgICAgbGV0IHRvdGFsUGVyYyA9IDBcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbXApIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsUGVyYyA9IHRvdGFsUGVyYyArIGNvbXBba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbXBbJ290aGVyJ10gPSAxIC0gdG90YWxQZXJjXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGdldERhdGFzZXRNYXhNaW5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXRzIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHRvdGFsIG9mIGFsbCBkaW1lbnNpb25zIGNvbWJpbmVkIGZvciBlYWNoIHJlZ2lvbi4gVXNlZCB0byBkZWZpbmUgdGhlIGRvbWFpbiBvZiB0aGUgcGllIHNpemUgc2NhbGluZyBmdW5jdGlvbi5cclxuICAgICAqIEByZXR1cm5zIFttaW4sbWF4XVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXREYXRhc2V0TWF4TWluKCkge1xyXG4gICAgICAgIGxldCB0b3RhbHMgPSBbXVxyXG4gICAgICAgIGxldCBzZWwgPSBvdXQuc3ZnKCkuc2VsZWN0QWxsKCcjZW0tcHJvcC1zeW1ib2xzJykuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykuZGF0YSgpXHJcblxyXG4gICAgICAgIHNlbC5mb3JFYWNoKChyZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaWQgPSByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGdldFJlZ2lvblRvdGFsKGlkKVxyXG4gICAgICAgICAgICBpZiAodG90YWwpIHtcclxuICAgICAgICAgICAgICAgIHRvdGFscy5wdXNoKHRvdGFsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IG1pbm1heCA9IGV4dGVudCh0b3RhbHMpXHJcbiAgICAgICAgcmV0dXJuIG1pbm1heFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFic29sdXRlIHRvdGFsIHZhbHVlIG9mIGNvbWJpbmVkIHN0YXRpc3RpY2FsIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyByZWdpb24uIEUuZyB0b3RhbCBsaXZlc3RvY2tcclxuICAgICAqIEBwYXJhbSB7Kn0gaWQgbnV0cyByZWdpb24gaWRcclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0UmVnaW9uVG90YWwgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBsZXQgc3VtID0gMFxyXG4gICAgICAgIGxldCBzXHJcbiAgICAgICAgaWYgKG91dC50b3RhbENvZGVfKSB7XHJcbiAgICAgICAgICAgIC8vd2hlbiB0b3RhbCBpcyBhIHN0YXQgY29kZVxyXG4gICAgICAgICAgICBzID0gb3V0LnN0YXREYXRhKG91dC50b3RhbENvZGVfKS5nZXQoaWQpXHJcbiAgICAgICAgICAgIC8vY2FzZSB3aGVuIHNvbWUgZGF0YSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zaG93T25seVdoZW5Db21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2dldCBzdGF0IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5LiBDb21wdXRlIHRoZSBzdW0uXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0LnN0YXRDb2Rlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vcmV0cmlldmUgY29kZSBhbmQgc3RhdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2MgPSBvdXQuc3RhdENvZGVzX1tpXVxyXG4gICAgICAgICAgICAgICAgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KGlkKVxyXG4gICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gc29tZSBkYXRhIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPSAwICYmICFzLnZhbHVlKSB8fCBpc05hTihzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN1bSArPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2FzZSB3aGVuIG5vIGRhdGFcclxuICAgICAgICBpZiAoc3VtID09IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gc3VtXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkUGllQ2hhcnRzVG9NYXAocmVnaW9uRmVhdHVyZXMpIHtcclxuICAgICAgICByZWdpb25GZWF0dXJlcy5mb3JFYWNoKChyZWdpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uSWQgPSByZWdpb24ucHJvcGVydGllcy5pZFxyXG4gICAgICAgICAgICAvL3ByZXBhcmUgZGF0YSBmb3IgcGllIGNoYXJ0XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXVxyXG4gICAgICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmVnaW9uSWQpXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXApIGRhdGEucHVzaCh7IGNvZGU6IGtleSwgdmFsdWU6IGNvbXBba2V5XSB9KVxyXG5cclxuICAgICAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICAgICAgLy8gY2FuIGJlIG1vcmUgdGhhbiBvbmUgY2VudGVyIHBvaW50IGZvciBlYWNoIG51dHMgSUQgKGUuZy4gTWFsdGEgd2hlbiBpbmNsdWRlZCBpbiBpbnNldHMpXHJcbiAgICAgICAgICAgIGxldCBub2RlcyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoJyNwaWVfJyArIHJlZ2lvbklkKVxyXG5cclxuICAgICAgICAgICAgLy8gZGVmaW5lIHJhZGl1c1xyXG4gICAgICAgICAgICBjb25zdCByID0gb3V0LnNpemVDbGFzc2lmaWVyXyhnZXRSZWdpb25Ub3RhbChyZWdpb25JZCkpXHJcbiAgICAgICAgICAgIGNvbnN0IGlyID0gb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXNfXHJcblxyXG4gICAgICAgICAgICAvL21ha2UgcGllIGNoYXJ0LiBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9waWUtY2hhcnRcclxuICAgICAgICAgICAgY29uc3QgcGllXyA9IHBpZSgpXHJcbiAgICAgICAgICAgICAgICAuc29ydChudWxsKVxyXG4gICAgICAgICAgICAgICAgLnZhbHVlKChkKSA9PiBkLnZhbHVlKVxyXG4gICAgICAgICAgICBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgb3V0LnBpZVN0cm9rZUZpbGxfKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIG91dC5waWVTdHJva2VXaWR0aF8gKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BpZWNoYXJ0JylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocGllXyhkYXRhKSlcclxuICAgICAgICAgICAgICAgIC5qb2luKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jYXRDb2xvcnNfW2QuZGF0YS5jb2RlXSB8fCAnbGlnaHRncmF5J1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsX19fJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0LmNhdENvbG9yc19bZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NvZGUnLCAoZCkgPT4gZC5kYXRhLmNvZGUpIC8vZm9yIG1vdXNlb3ZlciBsZWdlbmQgaGlnaGxpZ2h0aW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGFyYygpLmlubmVyUmFkaXVzKGlyKS5vdXRlclJhZGl1cyhyKSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYSB0aGljayBzdHJva2Ugd2lkdGggdG8gdGhlIHBhcmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gc2VsZWN0KHNlbC5ub2RlKCkucGFyZW50Tm9kZSlcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKS5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJykgLy8gU2V0IHN0cm9rZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZWdpb24sIG91dCkpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdHJva2VcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBzZWxlY3Qoc2VsLm5vZGUoKS5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgb3V0LnBpZVN0cm9rZVdpZHRoXykuc3R5bGUoJ3N0cm9rZScsIG91dC5waWVTdHJva2VGaWxsXykgLy8gU2V0IHN0cm9rZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW91dCgpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gUGllY2hhcnRMZWdlbmQubGVnZW5kXHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBmdW5jdGlvbiAocmcsIG1hcCkge1xyXG4gICAgICAgIC8vZ2V0IHRvb2x0aXBcclxuICAgICAgICBjb25zdCB0cCA9IHNlbGVjdCgnI3Rvb2x0aXBfZXVyb3N0YXQnKVxyXG5cclxuICAgICAgICAvL2NsZWFyXHJcbiAgICAgICAgdHAuaHRtbCgnJylcclxuICAgICAgICB0cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICBpZiAocmcucHJvcGVydGllcy5pZCkge1xyXG4gICAgICAgICAgICAvL25hbWUgYW5kIGNvZGVcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VzdGF0LXZpcy10b29sdGlwLWJhcicpXHJcbiAgICAgICAgICAgICAgICAuaHRtbChyZy5wcm9wZXJ0aWVzLm5hICsgJyAoJyArIHJnLnByb3BlcnRpZXMuaWQgKyAnKScpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VzdGF0LXZpcy10b29sdGlwLWJhcicpLmh0bWwocmcucHJvcGVydGllcy5uYSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBkYXRhIGZvciBwaWUgY2hhcnRcclxuICAgICAgICBjb25zdCBkYXRhID0gW11cclxuICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wKSBkYXRhLnB1c2goeyBjb2RlOiBrZXksIHZhbHVlOiBjb21wW2tleV0gfSlcclxuXHJcbiAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKS5odG1sKG91dC5ub0RhdGFUZXh0KCkpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICAvLyBzZXQgdGhlIGRpbWVuc2lvbnMgYW5kIG1hcmdpbnMgb2YgdGhlIGdyYXBoXHJcbiAgICAgICAgbGV0IHdpZHRoID0gMTUwXHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDE1MFxyXG4gICAgICAgIGxldCBtYXJnaW4gPSAyNVxyXG5cclxuICAgICAgICAvLyBUaGUgcmFkaXVzIG9mIHRoZSBwaWVwbG90IGlzIGhhbGYgdGhlIHdpZHRoIG9yIGhhbGYgdGhlIGhlaWdodCAoc21hbGxlc3Qgb25lKS4gSSBzdWJ0cmFjdCBhIGJpdCBvZiBtYXJnaW4uXHJcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIC0gbWFyZ2luXHJcblxyXG4gICAgICAgIC8vd2lkdGggPSB0cC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0cC5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtcGllY2hhcnQtY29udGFpbmVyJylcclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXJcclxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtcGllY2hhcnQtc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdib3gnLCBgMCwgMCwgJHt3aWR0aH0sICR7aGVpZ2h0fWApXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0IC0gbWFyZ2luIC8gMilcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB3aWR0aCAvIDIgKyAnLCcgKyBoZWlnaHQgLyAyICsgJyknKVxyXG5cclxuICAgICAgICAvL21ha2UgcGllIGNoYXJ0LiBTZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9waWUtY2hhcnRcclxuICAgICAgICBjb25zdCBwaWVfID0gcGllKClcclxuICAgICAgICAgICAgLnNvcnQobnVsbClcclxuICAgICAgICAgICAgLnZhbHVlKChkKSA9PiBkLnZhbHVlKVxyXG5cclxuICAgICAgICBjb25zdCBpbm5lckFyYyA9IGFyYygpXHJcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKSAvLyBUaGlzIGlzIHRoZSBzaXplIG9mIHRoZSBkb251dCBob2xlXHJcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgKiAwLjgpXHJcblxyXG4gICAgICAgIC8vIEFub3RoZXIgYXJjIHRoYXQgd29uJ3QgYmUgZHJhd24uIEp1c3QgZm9yIGxhYmVscyBwb3NpdGlvbmluZ1xyXG4gICAgICAgIGNvbnN0IG91dGVyQXJjID0gYXJjKClcclxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuXHJcbiAgICAgICAgY29uc3QgcGllRGF0YSA9IHBpZV8oZGF0YSlcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCdhbGxTbGljZXMnKVxyXG4gICAgICAgICAgICAuZGF0YShwaWVEYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBpbm5lckFyYylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQuY2F0Q29sb3JzKClbZC5kYXRhLmNvZGVdIHx8ICdsaWdodGdyYXknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjcpXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgcG9seWxpbmVzIGJldHdlZW4gY2hhcnQgYW5kIGxhYmVsczpcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCdhbGxQb2x5bGluZXMnKVxyXG4gICAgICAgICAgICAuZGF0YShwaWVEYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwb2x5bGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxyXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLmRhdGEudmFsdWUgPiAwLjAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQSA9IGlubmVyQXJjLmNlbnRyb2lkKGQpIC8vIGxpbmUgaW5zZXJ0aW9uIGluIHRoZSBzbGljZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc0IgPSBvdXRlckFyYy5jZW50cm9pZChkKSAvLyBsaW5lIGJyZWFrOiB3ZSB1c2UgdGhlIG90aGVyIGFyYyBnZW5lcmF0b3IgdGhhdCBoYXMgYmVlbiBidWlsdCBvbmx5IGZvciB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpIC8vIExhYmVsIHBvc2l0aW9uID0gYWxtb3N0IHRoZSBzYW1lIGFzIHBvc0JcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWRhbmdsZSA9IGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDIgLy8gd2UgbmVlZCB0aGUgYW5nbGUgdG8gc2VlIGlmIHRoZSBYIHBvc2l0aW9uIHdpbGwgYmUgYXQgdGhlIGV4dHJlbWUgcmlnaHQgb3IgZXh0cmVtZSBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zQ1swXSA9IHJhZGl1cyAqIDAuOTUgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKSAvLyBtdWx0aXBseSBieSAxIG9yIC0xIHRvIHB1dCBpdCBvbiB0aGUgcmlnaHQgb3Igb24gdGhlIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Bvc0EsIHBvc0IsIHBvc0NdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbGFiZWxzOlxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJ2FsbExhYmVscycpXHJcbiAgICAgICAgICAgIC5kYXRhKHBpZURhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuZGF0YS52YWx1ZSA+IDAuMDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IChkLmRhdGEudmFsdWUgKiAxMDApLnRvRml4ZWQoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4obikpIHJldHVybiBuICsgJyUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpXHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgICAgICBwb3NbMF0gPSByYWRpdXMgKiAwLjk5ICogKG1pZGFuZ2xlIDwgTWF0aC5QSSA/IDEgOiAtMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3MgKyAnKSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkYW5nbGUgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG5cclxuICAgICAgICAvLyBhZGQgcmVnaW9uIHZhbHVlcyB0byB0b29sdGlwXHJcbiAgICAgICAgbGV0IGJyZWFrZG93bkRpdiA9IHRwLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnZW0tdG9vbHRpcC1waWVjaGFydC1icmVha2Rvd24nKVxyXG5cclxuICAgICAgICAvLyBzaG93IHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuc3RhdENvZGVzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBjb2RlIGFuZCBzdGF0IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IHNjID0gb3V0LnN0YXRDb2Rlc19baV1cclxuICAgICAgICAgICAgY29uc3QgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzIGFuZCBzLnZhbHVlIGFyZSB2YWxpZCAoaGFuZGxlIG51bGwsIHVuZGVmaW5lZCwgb3IgMClcclxuICAgICAgICAgICAgaWYgKHMgJiYgcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHMudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdHJpbmcgPSBgPHN0cm9uZz4ke291dC5jYXRMYWJlbHNfW3NjXX08L3N0cm9uZz46ICR7cy52YWx1ZS50b0ZpeGVkKCl9PGJyPmBcclxuICAgICAgICAgICAgICAgIGJyZWFrZG93bkRpdi5odG1sKGJyZWFrZG93bkRpdi5odG1sKCkgKyBzdHJpbmcpIC8vIHNhZmVseSB1cGRhdGUgdGhlIEhUTUxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd3JpdGUgdG90YWwgKGhhbmRsZSBudWxsLCB1bmRlZmluZWQsIG9yIDAgdmFsdWVzIGZvciB0b3RhbClcclxuICAgICAgICBsZXQgdG90YWwgPSBnZXRSZWdpb25Ub3RhbChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgIGlmICh0b3RhbCAhPT0gdW5kZWZpbmVkICYmIHRvdGFsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGJyZWFrZG93bkRpdi5odG1sKGJyZWFrZG93bkRpdi5odG1sKCkgKyBgPHN0cm9uZz5Ub3RhbDwvc3Ryb25nPjogJHt0b3RhbC50b0ZpeGVkKCl9PGJyPmApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCJpbXBvcnQgeyBzY2FsZVNxcnQsIHNjYWxlTGluZWFyLCBzY2FsZVF1YW50aWxlLCBzY2FsZVF1YW50aXplLCBzY2FsZVRocmVzaG9sZCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBleHRlbnQgfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5pbXBvcnQgeyBpbnRlcnBvbGF0ZU9yUmQgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbmltcG9ydCB7IGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VNYW55Qm9keSwgZm9yY2VDZW50ZXIsIGZvcmNlQ29sbGlkZSwgZm9yY2VYLCBmb3JjZVkgfSBmcm9tICdkMy1mb3JjZSdcclxuaW1wb3J0ICogYXMgU3RhdE1hcCBmcm9tICcuLi9jb3JlL3N0YXQtbWFwJ1xyXG5pbXBvcnQgKiBhcyBQcm9wb3J0aW9uYWxTeW1ib2xMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2xlZ2VuZC1wcm9wb3J0aW9uYWwtc3ltYm9scydcclxuaW1wb3J0IHsgc3ltYm9sLCBzeW1ib2xDaXJjbGUsIHN5bWJvbERpYW1vbmQsIHN5bWJvbFN0YXIsIHN5bWJvbENyb3NzLCBzeW1ib2xTcXVhcmUsIHN5bWJvbFRyaWFuZ2xlLCBzeW1ib2xXeWUgfSBmcm9tICdkMy1zaGFwZSdcclxuaW1wb3J0IHsgc3BhY2VBc1Rob3VzYW5kU2VwYXJhdG9yLCBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgZXhlY3V0ZUZvckFsbEluc2V0cywgZ2V0UmVnaW9uc1NlbGVjdG9yLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuaW1wb3J0IHsgYXBwbHlQYXR0ZXJuRmlsbCB9IGZyb20gJy4uL2NvcmUvcGF0dGVybi1maWxsJ1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9wb3J0aW9uYWwgc3ltYm9sIG1hcC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb25maWdcclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAvL2NyZWF0ZSBtYXAgb2JqZWN0IHRvIHJldHVybiwgdXNpbmcgdGhlIHRlbXBsYXRlXHJcbiAgICBjb25zdCBvdXQgPSBTdGF0TWFwLnN0YXRNYXAoY29uZmlnLCB0cnVlLCAncHMnKVxyXG5cclxuICAgIC8vc2hhcGVcclxuICAgIG91dC5wc1NoYXBlXyA9ICdjaXJjbGUnIC8vIGFjY2VwdGVkIHZhbHVlczogY2lyY2xlLCBiYXIsIHNxdWFyZSwgc3RhciwgZGlhbW9uZCwgd3llLCBjcm9zc1xyXG4gICAgb3V0LnBzQ3VzdG9tU2hhcGVfIC8vIHNlZSBodHRwOi8vdXNpbmctZDNqcy5jb20vMDVfMTBfc3ltYm9scy5odG1sI2hfNjZpSVE1c0pJVFxyXG4gICAgb3V0LnBzQ3VzdG9tU1ZHXyAvLyBzZWUgaHR0cDovL2JsLm9ja3Mub3JnL2plc3NpaGFtZWwvOTY0ODQ5NVxyXG4gICAgb3V0LnBzU3Bpa2VXaWR0aF8gPSA3IC8vICdzcGlrZScgc2hhcGUgd2lkdGhzXHJcbiAgICBvdXQucHNPZmZzZXRfID0geyB4OiAwLCB5OiAwIH1cclxuXHJcbiAgICAvL3NpemVcclxuICAgIG91dC5wc01heFNpemVfID0gMzAgLy8gbWF4IHN5bWJvbCBzaXplXHJcbiAgICBvdXQucHNNaW5TaXplXyA9IDUgLy8gbWluIHN5bWJvbCBzaXplXHJcbiAgICBvdXQucHNCYXJXaWR0aF8gPSAxMCAvL2ZvciB2ZXJ0aWNhbCBiYXJzXHJcbiAgICBvdXQucHNNYXhWYWx1ZV8gPSB1bmRlZmluZWQgLy8gYWxsb3cgdGhlIHVzZXIgdG8gbWFudWFsbHkgZGVmaW5lIHRoZSBkb21haW4gb2YgdGhlIHNpemluZyBzY2FsZS4gRS5nLiBpZiB0aGUgdXNlciB3YW50cyB0byB1c2UgdGhlIHNhbWUgc2NhbGUgYWNyb3NzIGRpZmZlcmVudCBtYXBzLlxyXG4gICAgb3V0LnBzTWluVmFsdWVfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQucHNTaXplU2NhbGVfID0gdW5kZWZpbmVkIC8vICdzcXJ0JyBvciAnbGluZWFyJ1xyXG5cclxuICAgIC8vY29sb3VyXHJcbiAgICBvdXQucHNGaWxsXyA9ICcjMmQ1MGEwJyAvL3NhbWUgZmlsbCBmb3IgYWxsIHN5bWJvbHMgd2hlbiBubyB2aXN1YWwgdmFyaWFibGUgKHNldERhdGEoKSkgZm9yICdjb2xvcicgaXMgc3BlY2lmaWVkXHJcbiAgICBvdXQucHNGaWxsT3BhY2l0eV8gPSAxXHJcbiAgICBvdXQucHNTdHJva2VfID0gJyNmZmZmZmYnXHJcbiAgICBvdXQucHNTdHJva2VXaWR0aF8gPSAwLjJcclxuICAgIG91dC5wc0NsYXNzZXNfID0gNSAvLyBudW1iZXIgb2YgY2xhc3NlcyB0byB1c2UgZm9yIGNvbG91cmluZ1xyXG4gICAgb3V0LnBzQ29sb3JzXyA9IG51bGwgLy9jb2xvdXJzIHRvIHVzZSBmb3IgdGhyZXNob2xkIGNvbG91cmluZ1xyXG4gICAgb3V0LnBzQ29sb3JGdW5fID0gaW50ZXJwb2xhdGVPclJkXHJcbiAgICBvdXQucHNDbGFzc1RvRmlsbFN0eWxlXyA9IHVuZGVmaW5lZCAvL2EgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBmcm9tIHRoZSBjbGFzcyBpXHJcblxyXG4gICAgLy90aGUgdGhyZXNob2xkLCB3aGVuIHRoZSBjbGFzc2lmaWNhdGlvbiBtZXRob2QgaXMgJ3RocmVzaG9sZCdcclxuICAgIG91dC5wc1RocmVzaG9sZHNfID0gWzBdXHJcbiAgICAvL3RoZSBjbGFzc2lmaWNhdGlvbiBtZXRob2RcclxuICAgIG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9ICdxdWFudGlsZScgLy8gb3I6IGVxdWludGVyLCB0aHJlc2hvbGRcclxuICAgIC8vd2hlbiBjb21wdXRlZCBhdXRvbWF0aWNhbGx5LCBlbnN1cmUgdGhlIHRocmVzaG9sZCBhcmUgbmljZSByb3VuZGVkIHZhbHVlc1xyXG4gICAgb3V0Lm1ha2VDbGFzc2lmTmljZV8gPSB0cnVlXHJcbiAgICAvL1xyXG4gICAgLy90aGUgY2xhc3NpZmllcjogYSBmdW5jdGlvbiB3aGljaCByZXR1cm4gdGhlIHN5bWJvbCBzaXplL2NvbG9yIGZyb20gdGhlIHN0YXQgdmFsdWUuXHJcbiAgICBvdXQuY2xhc3NpZmllclNpemVfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuY2xhc3NpZmllckNvbG9yXyA9IHVuZGVmaW5lZFxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSB0b29sdGlwVGV4dEZ1blBzXHJcblxyXG4gICAgLy9kb3JsaW5nIGNhcnRvZ3JhbVxyXG4gICAgb3V0LmRvcmxpbmdfID0gZmFsc2VcclxuICAgIG91dC5kb3JsaW5nU3RyZW5ndGhfID0geyB4OiAxLCB5OiAxIH1cclxuICAgIG91dC5kb3JsaW5nSXRlcmF0aW9uc18gPSAxXHJcbiAgICBvdXQucHNDb2RlTGFiZWxzXyA9IGZhbHNlIC8vIHNob3cgY291bnRyeSBjb2RlcyBpbiBzeW1ib2xzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbml0aW9uIG9mIGdldHRlcnMvc2V0dGVycyBmb3IgYWxsIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogRWFjaCBtZXRob2QgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm46XHJcbiAgICAgKiAgLSBUaGVyZSBpcyBhIHNpbmdsZSBtZXRob2QgYXMgZ2V0dGVyL3NldHRlciBvZiBlYWNoIGF0dHJpYnV0ZS4gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgdGhlIGF0dHJpYnV0ZSBuYW1lLCB3aXRob3V0IHRoZSB0cmFpbGluZyBcIl9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgKiAgLSBUbyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgbWV0aG9kIHdpdGhvdXQgYXJndW1lbnQuXHJcbiAgICAgKiAgLSBUbyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCB0aGUgc2FtZSBtZXRob2Qgd2l0aCB0aGUgbmV3IHZhbHVlIGFzIHNpbmdsZSBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgO1tcclxuICAgICAgICAncHNNYXhTaXplXycsXHJcbiAgICAgICAgJ3BzTWluU2l6ZV8nLFxyXG4gICAgICAgICdwc01heFZhbHVlXycsXHJcbiAgICAgICAgJ3BzTWluVmFsdWVfJyxcclxuICAgICAgICAncHNGaWxsXycsXHJcbiAgICAgICAgJ3BzRmlsbE9wYWNpdHlfJyxcclxuICAgICAgICAncHNTdHJva2VfJyxcclxuICAgICAgICAncHNTdHJva2VXaWR0aF8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyU2l6ZV8nLFxyXG4gICAgICAgICdjbGFzc2lmaWVyQ29sb3JfJyxcclxuICAgICAgICAncHNTaGFwZV8nLFxyXG4gICAgICAgICdwc0N1c3RvbVNoYXBlXycsXHJcbiAgICAgICAgJ3BzQmFyV2lkdGhfJyxcclxuICAgICAgICAncHNDbGFzc1RvRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ3BzQ29sb3JGdW5fJyxcclxuICAgICAgICAncHNTaXplU2NhbGVfJyxcclxuICAgICAgICAnbm9EYXRhRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ3BzVGhyZXNob2xkc18nLFxyXG4gICAgICAgICdwc0NvbG9yc18nLFxyXG4gICAgICAgICdwc0N1c3RvbVNWR18nLFxyXG4gICAgICAgICdwc09mZnNldF8nLFxyXG4gICAgICAgICdwc0NsYXNzaWZpY2F0aW9uTWV0aG9kXycsXHJcbiAgICAgICAgJ3BzQ2xhc3Nlc18nLFxyXG4gICAgICAgICdkb3JsaW5nXycsXHJcbiAgICAgICAgJ2RvcmxpbmdTdHJlbmd0aF8nLFxyXG4gICAgICAgICdwc1NwaWtlV2lkdGhfJyxcclxuICAgICAgICAncHNDb2RlTGFiZWxzXycsXHJcbiAgICAgICAgJ2RvcmxpbmdJdGVyYXRpb25zXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdwc01heFNpemUnLFxyXG4gICAgICAgICAgICAncHNNaW5TaXplJyxcclxuICAgICAgICAgICAgJ3BzRmlsbCcsXHJcbiAgICAgICAgICAgICdwc0ZpbGxPcGFjaXR5JyxcclxuICAgICAgICAgICAgJ3BzU3Ryb2tlJyxcclxuICAgICAgICAgICAgJ3BzU3Ryb2tlV2lkdGgnLFxyXG4gICAgICAgICAgICAnY2xhc3NpZmllclNpemUnLFxyXG4gICAgICAgICAgICAnY2xhc3NpZmllckNvbG9yJyxcclxuICAgICAgICAgICAgJ3BzU2hhcGUnLFxyXG4gICAgICAgICAgICAncHNDdXN0b21TaGFwZScsXHJcbiAgICAgICAgICAgICdwc0JhcldpZHRoJyxcclxuICAgICAgICAgICAgJ3BzQ2xhc3NUb0ZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdwc0NvbG9yRnVuJyxcclxuICAgICAgICAgICAgJ25vRGF0YUZpbGxTdHlsZScsXHJcbiAgICAgICAgICAgICdwc1RocmVzaG9sZCcsXHJcbiAgICAgICAgICAgICdwc0NvbG9ycycsXHJcbiAgICAgICAgICAgICdwc0N1c3RvbVNWRycsXHJcbiAgICAgICAgICAgICdwc09mZnNldCcsXHJcbiAgICAgICAgICAgICdwc0NsYXNzaWZpY2F0aW9uTWV0aG9kJyxcclxuICAgICAgICAgICAgJ3BzQ2xhc3NlcycsXHJcbiAgICAgICAgICAgICdkb3JsaW5nSXRlcmF0aW9uc18nLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBvZiBzb21lIHNwZWNpYWwgZ2V0dGVycy9zZXR0ZXJzXHJcbiAgICBvdXQucHNDb2xvckZ1biA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0LnBzQ29sb3JGdW5fXHJcbiAgICAgICAgb3V0LnBzQ29sb3JGdW5fID0gdlxyXG4gICAgICAgIG91dC5wc0NsYXNzVG9GaWxsU3R5bGVfID0gZ2V0Q29sb3JMZWdlbmQob3V0LnBzQ29sb3JGdW5fLCBvdXQucHNDb2xvcnNfKVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuICAgIG91dC5wc1RocmVzaG9sZHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dC5wc1RocmVzaG9sZHNfXHJcbiAgICAgICAgb3V0LnBzVGhyZXNob2xkc18gPSB2XHJcbiAgICAgICAgb3V0LnBzQ2xhc3Nlcyh2Lmxlbmd0aCArIDEpXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9kZWZpbmUgY2xhc3NpZmllcnMgZm9yIHNpemluZyBhbmQgY29sb3VyaW5nIChvdXQuY2xhc3NpZmllclNpemVfICYgb3V0LmNsYXNzaWZpZXJDb2xvcl8pXHJcbiAgICAgICAgZGVmaW5lQ2xhc3NpZmllcnMoKVxyXG5cclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIG1haW4gbWFwJ3MgU1ZHXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZXhlY3V0ZUZvckFsbEluc2V0cyhvdXQuaW5zZXRUZW1wbGF0ZXNfLCBvdXQuc3ZnSWRfLCBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBseSB0byBtYWluIG1hcFxyXG4gICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChvdXQpXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhc3NpZ25zIGEgY29sb3IgdG8gZWFjaCBzeW1ib2wsIGJhc2VkIG9uIHRoZWlyIHN0YXRpc3RpY2FsIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBseUNsYXNzaWZpY2F0aW9uVG9NYXAobWFwKSB7XHJcbiAgICAgICAgaWYgKG1hcC5zdmdfKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXQuY2xhc3NpZmllckNvbG9yXykge1xyXG4gICAgICAgICAgICAgICAgLy9hc3NpZ24gY29sb3IgY2xhc3MgdG8gZWFjaCBzeW1ib2wsIGJhc2VkIG9uIHRoZWlyIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGUgc3ltYm9sIHBhdGggaGFzbnQgYmVlbiBhcHBlbmRlZC4gT25seSB0aGUgcGFyZW50IGcgZWxlbWVudCAoLmVtLWNlbnRyb2lkKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JEYXRhID0gbWFwLnN0YXREYXRhKCdjb2xvcicpXHJcbiAgICAgICAgICAgICAgICBtYXAuc3ZnXy5zZWxlY3RBbGwoJy5lbS1jZW50cm9pZCcpLmF0dHIoJ2VjbCcsIGZ1bmN0aW9uIChyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gY29sb3JEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3YpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICduZCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHN2LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ICE9PSAwICYmICF2KSB8fCB2ID09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgYyA9ICtvdXQuY2xhc3NpZmllckNvbG9yXygrdilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBkZWZpbmVzIGNsYXNzaWZpZXIgZnVuY3Rpb25zIChvdXQuY2xhc3NpZmllckNvbG9yIGFuZCBvdXQuY2xhc3NpZmllclNpemUpIGZvciBib3RoIHN5bWJvbCBzaXplIGFuZCBjb2xvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWZpbmVDbGFzc2lmaWVycygpIHtcclxuICAgICAgICAvLyBzZXQgZGVmYXVsdCBzY2FsZVxyXG4gICAgICAgIGlmICghb3V0LnBzU2l6ZVNjYWxlXykge1xyXG4gICAgICAgICAgICBpZiAob3V0LnBzU2hhcGVfID09ICdzcGlrZScpIHtcclxuICAgICAgICAgICAgICAgIG91dC5wc1NpemVTY2FsZV8gPSAnbGluZWFyJ1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0LnBzU2l6ZVNjYWxlXyA9ICdzcXJ0J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NpbXBseSByZXR1cm4gdGhlIGFycmF5IFswLDEsMiwzLC4uLixuYi0xXVxyXG4gICAgICAgIGNvbnN0IGdldEEgPSBmdW5jdGlvbiAobmIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsuLi5BcnJheShuYikua2V5cygpXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXNlIHNpemUgZGF0YXNldFxyXG4gICAgICAgIGxldCByYXdEYXRhID0gb3V0LnN0YXREYXRhKCdzaXplJykuZ2V0QXJyYXkoKSB8fCBvdXQuc3RhdERhdGEoKS5nZXRBcnJheSgpXHJcbiAgICAgICAgbGV0IGRhdGEgPSByYXdEYXRhLmZpbHRlcigoZCkgPT4gdHlwZW9mIGQgPT09ICdudW1iZXInICYmICFpc05hTihkKSAmJiBpc0Zpbml0ZShkKSlcclxuICAgICAgICBsZXQgW21pblZhbCwgbWF4VmFsXSA9IGV4dGVudChkYXRhKVxyXG4gICAgICAgIGxldCBtaW4gPSBvdXQucHNNaW5WYWx1ZV8gPz8gbWluVmFsXHJcbiAgICAgICAgbGV0IG1heCA9IG91dC5wc01heFZhbHVlXyA/PyBtYXhWYWxcclxuICAgICAgICBsZXQgc2l6ZURvbWFpbiA9IGRhdGEgPyBbbWluLCBtYXhdIDogW291dC5zdGF0RGF0YSgpLmdldE1pbigpLCBvdXQuc3RhdERhdGEoKS5nZXRNYXgoKV1cclxuXHJcbiAgICAgICAgbGV0IHNjYWxlID0gb3V0LnBzU2l6ZVNjYWxlXyA9PSAnc3FydCcgPyBzY2FsZVNxcnQgOiBzY2FsZUxpbmVhclxyXG4gICAgICAgIG91dC5jbGFzc2lmaWVyU2l6ZShzY2FsZSgpLmRvbWFpbihzaXplRG9tYWluKS5yYW5nZShbb3V0LnBzTWluU2l6ZV8sIG91dC5wc01heFNpemVfXSkpXHJcblxyXG4gICAgICAgIC8vIGNvbG91clxyXG4gICAgICAgIGlmIChvdXQuc3RhdERhdGEoJ2NvbG9yJykuZ2V0QXJyYXkoKSkge1xyXG4gICAgICAgICAgICAvL3VzZSBzdWl0YWJsZSBjbGFzc2lmaWNhdGlvbiB0eXBlIGZvciBjb2xvdXJpbmdcclxuICAgICAgICAgICAgaWYgKG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9PT0gJ3F1YW50aWxlJykge1xyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpbGUtc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBvdXQuc3RhdERhdGEoJ2NvbG9yJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRBKG91dC5wc0NsYXNzZXNfKVxyXG4gICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXJDb2xvcihzY2FsZVF1YW50aWxlKCkuZG9tYWluKGRvbWFpbikucmFuZ2UocmFuZ2UpKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dC5wc0NsYXNzaWZpY2F0aW9uTWV0aG9kXyA9PT0gJ2VxdWludGVyJykge1xyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjcXVhbnRpemUtc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBvdXQuc3RhdERhdGEoJ2NvbG9yJykuZ2V0QXJyYXkoKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRBKG91dC5wc0NsYXNzZXNfKVxyXG4gICAgICAgICAgICAgICAgb3V0LmNsYXNzaWZpZXJDb2xvcihcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZVF1YW50aXplKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbbWluKGRvbWFpbiksIG1heChkb21haW4pXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHJhbmdlKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5tYWtlQ2xhc3NpZk5pY2VfKSBvdXQuY2xhc3NpZmllckNvbG9yKCkubmljZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzQ2xhc3NpZmljYXRpb25NZXRob2RfID09PSAndGhyZXNob2xkJykge1xyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUjdGhyZXNob2xkLXNjYWxlc1xyXG4gICAgICAgICAgICAgICAgb3V0LnBzQ2xhc3NlcyhvdXQucHNUaHJlc2hvbGRzKCkubGVuZ3RoICsgMSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0QShvdXQucHNDbGFzc2VzXylcclxuICAgICAgICAgICAgICAgIG91dC5jbGFzc2lmaWVyQ29sb3Ioc2NhbGVUaHJlc2hvbGQoKS5kb21haW4ob3V0LnBzVGhyZXNob2xkcygpKS5yYW5nZShyYW5nZSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHByb3BvcnRpb25hbCBzeW1ib2wgc3R5bGluZyB0byBhIG1hcCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcFxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVRvTWFwKG1hcCkge1xyXG4gICAgICAgIC8vc2VlIGh0dHBzOi8vYmwub2Nrcy5vcmcvbWJvc3RvY2svNDM0MjA0NSBhbmQgaHR0cHM6Ly9ib3N0Lm9ja3Mub3JnL21pa2UvYnViYmxlLW1hcC9cclxuICAgICAgICAvL2RlZmluZSBzdHlsZSBwZXIgY2xhc3NcclxuICAgICAgICBpZiAoIW91dC5wc0NsYXNzVG9GaWxsU3R5bGUoKSkgb3V0LnBzQ2xhc3NUb0ZpbGxTdHlsZShnZXRDb2xvckxlZ2VuZChvdXQucHNDb2xvckZ1bl8sIG91dC5wc0NvbG9yc18pKVxyXG5cclxuICAgICAgICAvLyBpZiBzaXplIGRhdGFzZXQgbm90IGRlZmluZWQgdGhlbiB1c2UgZGVmYXVsdFxyXG4gICAgICAgIGxldCBzaXplRGF0YSA9IG1hcC5zdGF0RGF0YSgnc2l6ZScpLmdldEFycmF5KCkgPyBtYXAuc3RhdERhdGEoJ3NpemUnKSA6IG1hcC5zdGF0RGF0YSgpXHJcblxyXG4gICAgICAgIGlmIChtYXAuc3ZnXykge1xyXG4gICAgICAgICAgICAvL2NsZWFyIHByZXZpb3VzIGNlbnRyb2lkc1xyXG4gICAgICAgICAgICBsZXQgcHJldlN5bWJvbHMgPSBtYXAuc3ZnXy5zZWxlY3RBbGwoJzpub3QoI2VtLWluc2V0cy1ncm91cCkgZy5lbS1jZW50cm9pZCA+IConKVxyXG4gICAgICAgICAgICBwcmV2U3ltYm9scy5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgLy8gJ3NtYWxsJyBjZW50cm9pZHMgb24gdG9wIG9mIGJpZyBvbmVzXHJcbiAgICAgICAgICAgIHVwZGF0ZVN5bWJvbHNEcmF3T3JkZXIobWFwKVxyXG5cclxuICAgICAgICAgICAgLy8gYXBwZW5kIHN5bWJvbHMgdG8gY2VudHJvaWRzXHJcbiAgICAgICAgICAgIGxldCBzeW1iXHJcbiAgICAgICAgICAgIGlmIChvdXQucHNDdXN0b21TVkdfKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kQ3VzdG9tU3ltYm9sc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzU2hhcGVfID09ICdiYXInKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kQmFyc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzU2hhcGVfID09ICdjaXJjbGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1iID0gYXBwZW5kQ2lyY2xlc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0LnBzU2hhcGVfID09ICdzcGlrZScpIHtcclxuICAgICAgICAgICAgICAgIHN5bWIgPSBhcHBlbmRTcGlrZXNUb01hcChtYXAsIHNpemVEYXRhKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2lyY2xlLCBjcm9zcywgc3RhciwgdHJpYW5nbGUsIGRpYW1vbmQsIHNxdWFyZSwgd3llIG9yIGN1c3RvbVxyXG4gICAgICAgICAgICAgICAgc3ltYiA9IGFwcGVuZEQzU3ltYm9sc1RvTWFwKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRvcmxpbmcgY2FydG9ncmFtXHJcbiAgICAgICAgICAgIGlmIChvdXQuZG9ybGluZ18pIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5RG9ybGluZ0ZvcmNlKG1hcCwgc2l6ZURhdGEpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnNpbXVsYXRpb24pIHN0b3BTaW11bGF0aW9uKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXBwZW5kTGFiZWxzVG9TeW1ib2xzKG1hcCwgc2l6ZURhdGEpXHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgc3R5bGUgb2Ygc3ltYm9sc1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFJlZ2lvbnNTZWxlY3RvcihtYXApXHJcbiAgICAgICAgICAgIGxldCByZWdpb25zID0gbWFwLnN2ZygpLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXAuZ2VvXyAhPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5udXRzTGV2ZWxfID09ICdtaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRTeW1ib2xzVG9NaXhlZE5VVFMobWFwLCBzaXplRGF0YSwgcmVnaW9ucylcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhcHBseSAnbmQnIGNsYXNzIHRvIG5vIGRhdGEgcmVnaW9ucyBmb3IgbGVnZW5kIGl0ZW0gaG92ZXJcclxuICAgICAgICAgICAgICAgIHJlZ2lvbnMuYXR0cignZWNsJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICghc3YudmFsdWUgJiYgc3YgIT09IDAgJiYgc3YudmFsdWUgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PIElOUFVUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbmknXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdiAmJiBzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3YudmFsdWUgPT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEQVRBIE5PVCBBVkFJTEFCTEUgKG5vIGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25kJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2V0U3ltYm9sU3R5bGVzKHN5bWIpXHJcblxyXG4gICAgICAgICAgICBhZGRNb3VzZUV2ZW50cyhtYXApXHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgbGFiZWxzIGZvciBzdGF0aXN0aWNhbCB2YWx1ZXMgaWYgcmVxdWlyZWRcclxuICAgICAgICAgICAgaWYgKG91dC5sYWJlbHNfPy52YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIG91dC51cGRhdGVWYWx1ZXNMYWJlbHMobWFwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2FkZCBoYXRjaGluZyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKG91dC5wYXR0ZXJuRmlsbF8pIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5UGF0dGVybkZpbGwobWFwLCBvdXQucGF0dGVybkZpbGxfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXBcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBlbmRMYWJlbHNUb1N5bWJvbHMgPSBmdW5jdGlvbiAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIGxldCBzeW1ib2xDb250YWluZXJzID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcbiAgICAgICAgLy9jb3VudHJ5IGNvZGUgbGFiZWxzXHJcbiAgICAgICAgaWYgKG91dC5wc0NvZGVMYWJlbHNfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50cnlDb2RlTGFiZWwgPSBzeW1ib2xDb250YWluZXJzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bT8udmFsdWUgIT09ICc6JyAmJiBkYXR1bT8udmFsdWUgIT0gbnVsbCAvLyBJZ25vcmUgYCc6J2AsIGBudWxsYCwgYW5kIGB1bmRlZmluZWRgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZW0tY2lyY2xlLWNvZGUtbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtPy52YWx1ZSA9PT0gJzonID8gJycgOiBkLnByb3BlcnRpZXMuaWQgLy8gSGlkZSB0ZXh0IGlmIHZhbHVlIGlzICc6J1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpemUgYWRqdXN0bWVudCBmYWN0b3IgZGVwZW5kcyBvbiBzeW1ib2wgdHlwZSwgYW5kIHdoZXRoZXIgc3RhdCB2YWx1ZXMgYXJlIGFsc28gYWRkZWQgdG8gdGhlIGNpcmNsZXNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gb3V0LmxhYmVsc18/LnZhbHVlcyAmJiBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKT8udmFsdWUgPyAwLjggOiAwLjlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0LnBzU2hhcGVfID09PSAnc3F1YXJlJykgZmFjdG9yID0gZmFjdG9yIC0gMC40XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3JhZGl1cyAqIGZhY3Rvcn1weGBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGdldFRleHRDb2xvckZvckJhY2tncm91bmQob3V0LnBzRmlsbF8pKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgKGQpID0+IChvdXQubGFiZWxzXz8udmFsdWVzICYmIHNpemVEYXRhLmdldChkLnByb3BlcnRpZXMuaWQpPy52YWx1ZSA/ICctMC4zZW0nIDogJzAnKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc3RhdCBsYWJlbHNcclxuICAgICAgICBpZiAob3V0LmxhYmVsc18/LnZhbHVlcykge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0TGFiZWxzID0gc3ltYm9sQ29udGFpbmVyc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0/LnZhbHVlICE9PSAnOicgJiYgZGF0dW0/LnZhbHVlICE9IG51bGwgLy8gSWdub3JlIGAnOidgLCBgbnVsbGAsIGFuZCBgdW5kZWZpbmVkYFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNpcmNsZS1zdGF0LWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXR1bT8udmFsdWUpIHJldHVybiBkYXR1bS52YWx1ZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtyYWRpdXMgKiAwLjR9cHhgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBnZXRUZXh0Q29sb3JGb3JCYWNrZ3JvdW5kKG91dC5wc0ZpbGxfKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIChkKSA9PiAob3V0LnBzQ29kZUxhYmVsc18gPyAnMC42ZW0nIDogJzAnKSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkTW91c2VFdmVudHMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgbGV0IHN5bWJvbHMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICBzeW1ib2xzXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUsIHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICAgICAgc2VsLmF0dHIoJ2ZpbGxfX18nLCBzZWwuc3R5bGUoJ2ZpbGwnKSlcclxuICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG91dC5ob3ZlckNvbG9yXylcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW1vdmUoZSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcy5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGwgPSBzZWwuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIG5ld0ZpbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBzZXRzIGNvbG9yL3N0cm9rZS9vcGFjaXR5IHN0eWxlcyBvZiBhbGwgc3ltYm9sc1xyXG4gICAgICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IHN5bWIgc3ltYm9scyBkMyBzZWxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0U3ltYm9sU3R5bGVzKHN5bWIpIHtcclxuICAgICAgICBzeW1iLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBvdXQucHNGaWxsT3BhY2l0eSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIG91dC5wc1N0cm9rZSgpKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIG91dC5wc1N0cm9rZVdpZHRoKCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuY2xhc3NpZmllckNvbG9yXykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZm9yIHBzLCBlY2wgYXR0cmlidXRlIGJlbG9uZ3MgdG8gdGhlIHBhcmVudCBnLmVtLWNlbnRyb2lkIG5vZGUgY3JlYXRlZCBpbiBtYXAtdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2wgPSBzZWxlY3QodGhpcy5wYXJlbnROb2RlKS5hdHRyKCdlY2wnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWNsIHx8IGVjbCA9PT0gJ25kJykgcmV0dXJuIG91dC5ub0RhdGFGaWxsU3R5bGVfIHx8ICdncmF5J1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IG91dC5wc0NsYXNzVG9GaWxsU3R5bGVfKGVjbCwgb3V0LnBzQ2xhc3Nlc18pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQucHNGaWxsX1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbF9fXycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxsID0gc2VsZWN0KHRoaXMpLnN0eWxlKCdmaWxsJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxsIC8vIHNhdmUgZm9yIGxlZ2VuZCBtb3VzZW92ZXJcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSBkcmF3IG9yZGVyIG9mIHRoZSBzeW1ib2xzIGFjY29yZGluZyB0byB0aGVpciBkYXRhIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHsqfSBtYXAgbWFwIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bWJvbHNEcmF3T3JkZXIobWFwKSB7XHJcbiAgICAgICAgY29uc3QgZ2NwID0gbWFwLnN2Z18uc2VsZWN0KCcjZW0tcHJvcC1zeW1ib2xzJylcclxuICAgICAgICBjb25zdCBzaXplRGF0YSA9IG1hcC5zdGF0RGF0YSgnc2l6ZScpPy5nZXRBcnJheT8uKCkgPyBtYXAuc3RhdERhdGEoJ3NpemUnKSA6IG1hcC5zdGF0RGF0YSgpXHJcblxyXG4gICAgICAgIC8vIDEuIEZpbHRlciBhbmQgc29ydCBmZWF0dXJlcyB3aXRoIGRhdGFcclxuICAgICAgICBpZiAobWFwLkdlb21ldHJpZXMuY2VudHJvaWRGZWF0dXJlcykge1xyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWQgPSBtYXAuR2VvbWV0cmllcy5jZW50cm9pZEZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNpemVEYXRhLmdldD8uKGYucHJvcGVydGllcy5pZCk/LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgIT0gbnVsbCAmJiB2ICE9PSAnOidcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplRGF0YS5nZXQoYi5wcm9wZXJ0aWVzLmlkKS52YWx1ZSAtIHNpemVEYXRhLmdldChhLnByb3BlcnRpZXMuaWQpLnZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gMi4gQ2xlYXIgYW5kIHJlYmluZFxyXG4gICAgICAgICAgICBnY3Auc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgICAgIGdjcC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoc29ydGVkLCAoZCkgPT4gZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiAncHMnICsgZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiBgdHJhbnNsYXRlKCR7ZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzBdLnRvRml4ZWQoMyl9LCR7ZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzFdLnRvRml4ZWQoMyl9KWApXHJcblxyXG4gICAgICAgICAgICAvLyAzLiBhZGQgdGhlIGVjbCBhdHRyaWJ1dGUgYmFjayB0byB0aGUgbmV3bHkgY3JlYXRlZCBnIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGFwcGx5Q2xhc3NpZmljYXRpb25Ub01hcChtYXApIC8vXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGVuZFNwaWtlc1RvTWFwKG1hcCwgc2l6ZURhdGEpIHtcclxuICAgICAgICAvL1RoZSBzcGlrZSBmdW5jdGlvbiBjcmVhdGVzIGEgdHJpYW5ndWxhciBwYXRoIG9mIHRoZSBnaXZlbiBsZW5ndGggKGhlaWdodCkgd2l0aCBhIGJhc2Ugd2lkdGggb2YgNyBwaXhlbHMuXHJcbiAgICAgICAgY29uc3Qgc3Bpa2UgPSAobGVuZ3RoLCB3aWR0aCA9IG91dC5wc1NwaWtlV2lkdGhfKSA9PiBgTSR7LXdpZHRoIC8gMn0sMEwwLCR7LWxlbmd0aH1MJHt3aWR0aCAvIDJ9LDBgXHJcbiAgICAgICAgbGV0IHN5bWJvbENvbnRhaW5lcnMgPSBtYXAuc3ZnKCkuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGNpcmNsZXMgdG8gZWFjaCBzeW1ib2wgY29udGFpbmVyXHJcbiAgICAgICAgY29uc3Qgc3Bpa2VzID0gc3ltYm9sQ29udGFpbmVyc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXR1bSA/IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpIDogMFxyXG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSBzcGlrZSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkKSA9PiBkLmNvbG9yIHx8ICdzdGVlbGJsdWUnKSAvLyBBZGp1c3QgY29sb3IgYXMgbmVlZGVkXHJcbiAgICAgICAgICAgIC8vLmF0dHIoJ2ZpbGwnLCBtYXAucHNGaWxsXylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIG1hcC5wc0ZpbGxPcGFjaXR5XylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIG1hcC5wc1N0cm9rZV8pXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBtYXAucHNTdHJva2VXaWR0aF8pXHJcblxyXG4gICAgICAgIHJldHVybiBzcGlrZXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIDxjaXJjbGU+IGVsZW1lbnRzIGZvciBlYWNoIHJlZ2lvbiBpbiB0aGUgbWFwIFNWR1xyXG4gICAgICogQHBhcmFtIHsqfSBtYXAgbWFwIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0geyp9IHNpemVEYXRhIHN0YXRpc3RpY2FsIGRhdGEgZm9yIHNpemUgZS5nLiBtYXAuc3RhdERhdGEoJ3NpemUnKVxyXG4gICAgICogQHJldHVybiB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwZW5kQ2lyY2xlc1RvTWFwKG1hcCwgc2l6ZURhdGEpIHtcclxuICAgICAgICAvLyBBcHBlbmQgY2lyY2xlcyB0byBlYWNoIHN5bWJvbCBjb250YWluZXJcclxuICAgICAgICBjb25zdCBjaXJjbGVzID0gbWFwXHJcbiAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGQucHJvcGVydGllcy5pZCA9PSAnREUnKSBjb25zb2xlLmxvZyhkYXR1bSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bSAmJiBkYXR1bS52YWx1ZSAhPT0gJzonICYmIGRhdHVtLnZhbHVlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gc2l6ZURhdGEuZ2V0KGQucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oZGF0dW0udmFsdWUpXHJcbiAgICAgICAgICAgICAgICBpZiAocmFkaXVzIDwgMCkgY29uc29sZS5lcnJvcignTmVnYXRpdmUgcmFkaXVzIGZvciBjaXJjbGU6JywgZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHJhZGl1cykpIGNvbnNvbGUuZXJyb3IoJ05hTiByYWRpdXMgZm9yIGNpcmNsZTonLCBkLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFkaXVzXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBjaXJjbGVzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlEb3JsaW5nRm9yY2UobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIGxldCBzeW1ib2xDb250YWluZXJzID0gbWFwLnN2ZygpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpXHJcblxyXG4gICAgICAgIGlmIChvdXQuc2ltdWxhdGlvbikge1xyXG4gICAgICAgICAgICBzdG9wU2ltdWxhdGlvbigpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBmb3JjZSBzaW11bGF0aW9uXHJcbiAgICAgICAgY29uc29sZS5sb2coJ25ldyBkb3JsaW5nIHNpbXVsYXRpb24nKVxyXG4gICAgICAgIG91dC5zaW11bGF0aW9uID0gZm9yY2VTaW11bGF0aW9uKG1hcC5HZW9tZXRyaWVzLmNlbnRyb2lkRmVhdHVyZXMpXHJcbiAgICAgICAgICAgIC5mb3JjZShcclxuICAgICAgICAgICAgICAgICd4JyxcclxuICAgICAgICAgICAgICAgIGZvcmNlWCgoZCkgPT4gZC5wcm9wZXJ0aWVzLmNlbnRyb2lkWzBdKS5zdHJlbmd0aChvdXQuZG9ybGluZ1N0cmVuZ3RoXy54KSAvLyBTdHJvbmdlciBwdWxsIHRvIG9yaWdpbmFsIHhcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuZm9yY2UoXHJcbiAgICAgICAgICAgICAgICAneScsXHJcbiAgICAgICAgICAgICAgICBmb3JjZVkoKGQpID0+IGQucHJvcGVydGllcy5jZW50cm9pZFsxXSkuc3RyZW5ndGgob3V0LmRvcmxpbmdTdHJlbmd0aF8ueSkgLy8gU3Ryb25nZXIgcHVsbCB0byBvcmlnaW5hbCB5XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmZvcmNlKFxyXG4gICAgICAgICAgICAgICAgJ2NvbGxpZGUnLFxyXG4gICAgICAgICAgICAgICAgZm9yY2VDb2xsaWRlKChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0dW0gPSBzaXplRGF0YS5nZXQoZC5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gZGF0dW0gPyBvdXQuY2xhc3NpZmllclNpemVfKGRhdHVtLnZhbHVlKSA6IDBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5wc1NoYXBlXyA9PT0gJ3NxdWFyZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzaXplIC8gMikgKiBNYXRoLlNRUlQyIC8vIEFkanVzdCBmb3IgZGlhZ29uYWwgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgLy8gRGVmYXVsdCBmb3IgY2lyY2xlc1xyXG4gICAgICAgICAgICAgICAgfSkuaXRlcmF0aW9ucyhvdXQuZG9ybGluZ0l0ZXJhdGlvbnNfKSAvLyBNb3JlIGl0ZXJhdGlvbnMgdG8gaW1wcm92ZSBjb2xsaXNpb24gaGFuZGxpbmdcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAvLy5hbHBoYVRhcmdldCgwLjMpIC8vIEhlbHBzIGtlZXAgY2VudHJvaWRzIGFuY2hvcmVkXHJcbiAgICAgICAgICAgIC5vbigndGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBlbGVtZW50cyB3aXRoIHRoZSBuZXcgcG9zaXRpb25zIGFuZCByYWRpaVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sQ29udGFpbmVycy5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAvL291dC5zaW11bGF0aW9uLmFscGhhKDEpLnJlc3RhcnQoKSAvLyBFbnN1cmVzIHNpbXVsYXRpb24gc3RhcnRzIHdpdGggZnVsbCBzdHJlbmd0aFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0b3BTaW11bGF0aW9uKCkge1xyXG4gICAgICAgIG91dC5zaW11bGF0aW9uLnN0b3AoKSAvLyBTdG9wcyB0aGUgaW50ZXJuYWwgdGljayBsb29wXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24ub24oJ3RpY2snLCBudWxsKSAvLyBSZW1vdmUgdGljayBldmVudCBsaXN0ZW5lclxyXG4gICAgICAgIG91dC5zaW11bGF0aW9uLm9uKCdlbmQnLCBudWxsKSAvLyBSZW1vdmUgZW5kIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgb3V0LnNpbXVsYXRpb24gPSBudWxsIC8vIFJlbW92ZSByZWZlcmVuY2VcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIDxwYXRoPiBlbGVtZW50cyBjb250YWluaW5nIHN5bWJvbHMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBtYXAgU1ZHXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGEgZS5nLiBtYXAuc3RhdERhdGEoJ3NpemUnKVxyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwZW5kRDNTeW1ib2xzVG9NYXAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBtYXBcclxuICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cuZW0tY2VudHJvaWQnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc3YgJiYgc3YudmFsdWUgIT09ICc6JykgcmV0dXJuIHJnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBzaXplXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNpemVEYXRhKSByZXR1cm5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gc2l6ZURhdGEuZ2V0KHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc3YgIT0gMCAmJiAhc3YpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBvdXQuY2xhc3NpZmllclNpemVfKCtzdi52YWx1ZSkgfHwgMFxyXG5cclxuICAgICAgICAgICAgICAgIC8vYXBwbHkgc2l6ZSB0byBzaGFwZVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5wc0N1c3RvbVNoYXBlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQucHNDdXN0b21TaGFwZV8uc2l6ZShzaXplICogc2l6ZSkoKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xUeXBlID0gc3ltYm9sc0xpYnJhcnlbb3V0LnBzU2hhcGVfXSB8fCBzeW1ib2xzTGlicmFyeVsnY2lyY2xlJ11cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnR5cGUoc3ltYm9sVHlwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNpemUoc2l6ZSAqIHNpemUpKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBlbmRzIDxyZWN0PiBlbGVtZW50cyBjb250YWluaW5nIGJhcnMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBtYXAgU1ZHXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gc2l6ZURhdGEgZS5nLiBtYXAuc3RhdERhdGEoJ3NpemUnKVxyXG4gICAgICogQHJldHVybiB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXBwZW5kQmFyc1RvTWFwKG1hcCwgc2l6ZURhdGEpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBtYXBcclxuICAgICAgICAgICAgICAgIC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnI2VtLXByb3Atc3ltYm9scycpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdiAmJiBzdi52YWx1ZSAhPT0gJzonKSByZXR1cm4gcmdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBvdXQucHNCYXJXaWR0aF8pXHJcbiAgICAgICAgICAgICAgICAvL2ZvciB2ZXJ0aWNhbCBiYXJzIHdlIHNjYWxlIHRoZSBoZWlnaHQgYXR0cmlidXRlIHVzaW5nIHRoZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN2IHx8ICFzdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IG91dC5jbGFzc2lmaWVyU2l6ZV8oK3N2LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYlJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHstdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgLyAyfWAgKyBgLCAtJHt0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyl9KWBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIHRvIHVzZSB0cmFuc2l0aW9ucyB3ZSBuZWVkIHRvIHJlZmFjdG9yIHRoZSBkcmF3aW5nIGZ1bmN0aW9ucyB0byBwcm9taXNlcyBlLmcuIGFwcGVuZEJhcnNUb01hcCgpLnRoZW4oKCk9Pnt9KVxyXG4gICAgICAgICAgICAvL3RoaXMgaXMgYmVjYXVzZSAuYXR0cignZmlsbF9fXycsIGZ1bmN0aW9uICgpIHtzZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwnKX0pIGRvZXNudCB3b3JrIHVubGVzcyB5b3UgZXhlY3V0ZSBpdCBhZnRlciB0aGUgdHJhbnNpdGlvbiBlbmRzLlxyXG4gICAgICAgICAgICAvLyBlLmcuXHJcbiAgICAgICAgICAgIC8vIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLy8gLmR1cmF0aW9uKG91dC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgLy8gLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKHJnKSB7fSlcclxuICAgICAgICAgICAgLy8gLmVuZCgpXHJcbiAgICAgICAgICAgIC8vIC50aGVuKClcclxuICAgICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQXBwZW5kcyBjdXN0b20gU1ZHIHN5bWJvbHMgZm9yIGVhY2ggcmVnaW9uIGluIHRoZSBtYXBcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAgICAgKiBAcGFyYW0geyp9IHNpemVEYXRhXHJcbiAgICAgKiBAcmV0dXJuIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRDdXN0b21TeW1ib2xzVG9NYXAobWFwLCBzaXplRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBtYXBcclxuICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJyNlbS1wcm9wLXN5bWJvbHMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdnLmVtLWNlbnRyb2lkJylcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKHN2ICYmIHN2LnZhbHVlICE9PSAnOicpIHJldHVybiByZ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncHMnKVxyXG4gICAgICAgICAgICAuaHRtbChvdXQucHNDdXN0b21TVkdfKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBzaXplXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBvdXQuY2xhc3NpZmllclNpemVfKCtzdi52YWx1ZSlcclxuICAgICAgICAgICAgICAgIGlmIChzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtvdXQucHNPZmZzZXRfLnggKiBzaXplfSwke291dC5wc09mZnNldF8ueSAqIHNpemV9KSBzY2FsZSgke3NpemV9KWBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBhZGRzIHByb3BvcnRpb25hbCBzeW1ib2xzIHRvIGVhY2ggcmVnaW9ucyBpbiBhIG1hcCB3aXRoIG1peGVkIE5VVFMgbGV2ZWxzIChJTUFHRSlcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwXHJcbiAgICAgKiBAcGFyYW0geyp9IHNpemVEYXRhXHJcbiAgICAgKiBAcGFyYW0geyp9IHJlZ2lvbnNcclxuICAgICAqIEByZXR1cm4geyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZFN5bWJvbHNUb01peGVkTlVUUyhtYXAsIHNpemVEYXRhLCByZWdpb25zKSB7XHJcbiAgICAgICAgLy8gdG9nZ2xlIGRpc3BsYXkgb2YgbWl4ZWQgTlVUUyBsZXZlbHNcclxuICAgICAgICByZWdpb25zLnN0eWxlKCdkaXNwbGF5JywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlbS1jbnRyZycpKSByZXR1cm4gLy8gU2tpcCBjb3VudHJ5IHJlZ2lvbnNcclxuICAgICAgICAgICAgY29uc3Qgc3YgPSBzaXplRGF0YS5nZXQocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICAgICAgaWYgKCFzdiB8fCAoIXN2LnZhbHVlICYmIHN2ICE9PSAwICYmIHN2LnZhbHVlICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gc3ltYm9sIGZvciBubyBkYXRhXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwLmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdibG9jaydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIG51dHMgYm9yZGVyIHN0cm9rZVxyXG4gICAgICAgIHJlZ2lvbnNcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbiAocmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbHZsID0gc2VsLmF0dHIoJ2x2bCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJva2UgPSBzZWwuc3R5bGUoJ3N0cm9rZScpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdiB8fCAhc3YudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGx2bCAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJva2UgfHwgJyM3NzcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gbnV0cyBib3JkZXIgc3Ryb2tlIHdpZHRoXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24gKHJnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGx2bCA9IHNlbC5hdHRyKCdsdmwnKVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBzZWwuc3R5bGUoJ3N0cm9rZS13aWR0aCcpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IHNpemVEYXRhLmdldChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdiB8fCAhc3YudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0Lmdlb18gPT0gJ1dPUkxEJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsdmwgIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Ryb2tlV2lkdGggfHwgJyM3NzcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwbHkgdG8gbWFpbiBtYXBcclxuICAgICAgICBhcHBseVN0eWxlVG9NYXAob3V0KVxyXG5cclxuICAgICAgICAvLyBhcHBseSBzdHlsZSB0byBpbnNldHNcclxuICAgICAgICAvLyBhcHBseSBjbGFzc2lmaWNhdGlvbiB0byBhbGwgaW5zZXRzXHJcbiAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc18pIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBnZW8gaW4gb3V0Lmluc2V0VGVtcGxhdGVzXykge1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2V0cyB3aXRoIHNhbWUgZ2VvIHRoYXQgZG8gbm90IHNoYXJlIHRoZSBzYW1lIHBhcmVudCBpbnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiAyIGRpZmZlcmVudCBpbnNldHMgd2l0aCB0aGUgc2FtZSBnZW8uIEUuZy4gMyBpbnNldHMgZm9yIFBUMjBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dW2ldLmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXVtjXS5zdmdJZF8gIT09IG91dC5zdmdJZF8pIGFwcGx5U3R5bGVUb01hcChvdXQuaW5zZXRUZW1wbGF0ZXNfW2dlb11baV1bY10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dW2ldLnN2Z0lkXyAhPT0gb3V0LnN2Z0lkXykgYXBwbHlTdHlsZVRvTWFwKG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXVtpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5pcXVlIGluc2V0IGdlb19cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Lmluc2V0VGVtcGxhdGVzX1tnZW9dLnN2Z0lkXyAhPT0gb3V0LnN2Z0lkXykgYXBwbHlTdHlsZVRvTWFwKG91dC5pbnNldFRlbXBsYXRlc19bZ2VvXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb3BvcnRpb25hbFN5bWJvbExlZ2VuZC5sZWdlbmRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0XHJcbn1cclxuXHJcbi8vYnVpbGQgYSBjb2xvciBsZWdlbmQgb2JqZWN0XHJcbmV4cG9ydCBjb25zdCBnZXRDb2xvckxlZ2VuZCA9IGZ1bmN0aW9uIChjb2xvckZ1biwgY29sb3JBcnJheSkge1xyXG4gICAgY29sb3JGdW4gPSBjb2xvckZ1biB8fCBpbnRlcnBvbGF0ZU9yUmRcclxuICAgIGlmIChjb2xvckFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3JBcnJheVtlY2xdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlY2wsIG51bWJlck9mQ2xhc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBjb2xvckZ1bihlY2wgLyAobnVtYmVyT2ZDbGFzc2VzIC0gMSkpXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gZ2l2ZSBhIGQzIHN5bWJvbCBmcm9tIGEgc2hhcGUgbmFtZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN5bWJvbHNMaWJyYXJ5ID0ge1xyXG4gICAgY3Jvc3M6IHN5bWJvbENyb3NzLFxyXG4gICAgc3F1YXJlOiBzeW1ib2xTcXVhcmUsXHJcbiAgICBkaWFtb25kOiBzeW1ib2xEaWFtb25kLFxyXG4gICAgdHJpYW5nbGU6IHN5bWJvbFRyaWFuZ2xlLFxyXG4gICAgc3Rhcjogc3ltYm9sU3RhcixcclxuICAgIHd5ZTogc3ltYm9sV3llLFxyXG4gICAgY2lyY2xlOiBzeW1ib2xDaXJjbGUsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTcGVjaWZpYyBmdW5jdGlvbiBmb3IgdG9vbHRpcCB0ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHJnIFRoZSByZWdpb24gdG8gc2hvdyBpbmZvcm1hdGlvbiBvbi5cclxuICogQHBhcmFtIHsqfSBtYXAgVGhlIG1hcCBlbGVtZW50XHJcbiAqL1xyXG5jb25zdCB0b29sdGlwVGV4dEZ1blBzID0gZnVuY3Rpb24gKHJlZ2lvbiwgbWFwKSB7XHJcbiAgICBjb25zdCBidWYgPSBbXVxyXG5cclxuICAgIC8vIEhlYWRlciB3aXRoIHJlZ2lvbiBuYW1lIGFuZCBJRFxyXG4gICAgY29uc3QgcmVnaW9uTmFtZSA9IHJlZ2lvbi5wcm9wZXJ0aWVzLm5hXHJcbiAgICBjb25zdCByZWdpb25JZCA9IHJlZ2lvbi5wcm9wZXJ0aWVzLmlkXHJcbiAgICBidWYucHVzaChgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPlxyXG4gICAgICAgICAgICA8Yj4ke3JlZ2lvbk5hbWV9PC9iPiR7cmVnaW9uSWQgPyBgICgke3JlZ2lvbklkfSlgIDogJyd9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIC8vc3RhdCAxIHZhbHVlXHJcbiAgICBjb25zdCB2MSA9IG1hcC5zdGF0RGF0YSgnc2l6ZScpLmdldEFycmF5KCkgPyBtYXAuc3RhdERhdGEoJ3NpemUnKSA6IG1hcC5zdGF0RGF0YSgpXHJcbiAgICBjb25zdCBzdjEgPSB2MS5nZXQocmVnaW9uLnByb3BlcnRpZXMuaWQpXHJcbiAgICBpZiAoIXN2MSB8fCAoc3YxLnZhbHVlICE9IDAgJiYgIXN2MS52YWx1ZSkpIHtcclxuICAgICAgICBidWYucHVzaChtYXAubm9EYXRhVGV4dF8pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vdW5pdCAxXHJcbiAgICAgICAgY29uc3QgdW5pdDEgPSB2MS51bml0VGV4dCgpXHJcbiAgICAgICAgYnVmLnB1c2goYDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0XCI+JHtzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YxLnZhbHVlKX0gJHt1bml0MSA/IHVuaXQxIDogJyAnfTwvZGl2PmApXHJcbiAgICB9XHJcblxyXG4gICAgLy9zdGF0IDIgdmFsdWVcclxuICAgIGlmIChtYXAuc3RhdERhdGEoJ2NvbG9yJykuZ2V0QXJyYXkoKSkge1xyXG4gICAgICAgIGNvbnN0IHN2MiA9IG1hcC5zdGF0RGF0YSgnY29sb3InKS5nZXQocmVnaW9uLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgaWYgKCFzdjIgfHwgKHN2Mi52YWx1ZSAhPSAwICYmICFzdjIudmFsdWUpKSBidWYucHVzaChtYXAubm9EYXRhVGV4dF8pXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vc3RhdCAyXHJcbiAgICAgICAgICAgIGNvbnN0IHVuaXQyID0gbWFwLnN0YXREYXRhKCdjb2xvcicpLnVuaXRUZXh0KClcclxuICAgICAgICAgICAgYnVmLnB1c2goYDxkaXYgY2xhc3M9XCJlc3RhdC12aXMtdG9vbHRpcC10ZXh0XCI+JHtzcGFjZUFzVGhvdXNhbmRTZXBhcmF0b3Ioc3YyLnZhbHVlKX0gJHt1bml0MiA/IHVuaXQyIDogJyAnfTwvZGl2PmApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBidWYuam9pbignJylcclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QsIGNyZWF0ZSB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlU3FydCB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5pbXBvcnQgeyBsaW5lLCBhcmVhIH0gZnJvbSAnZDMtc2hhcGUnXHJcbmltcG9ydCB7IGV4dGVudCwgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgYXhpc0JvdHRvbSwgYXhpc0xlZnQsIGF4aXNSaWdodCB9IGZyb20gJ2QzLWF4aXMnXHJcbmltcG9ydCAqIGFzIFN0YXRNYXAgZnJvbSAnLi4vY29yZS9zdGF0LW1hcCdcclxuaW1wb3J0ICogYXMgbGdjaCBmcm9tICcuLi9sZWdlbmQvbGVnZW5kLWNob3JvcGxldGgnXHJcbmltcG9ydCB7IGdldFJlZ2lvbnNTZWxlY3RvciB9IGZyb20gJy4uL2NvcmUvdXRpbHMnXHJcbmltcG9ydCAqIGFzIFN0YXRpc3RpY2FsRGF0YSBmcm9tICcuLi9jb3JlL3N0YXQtZGF0YSdcclxuLyoqXHJcbiAqIFJldHVybnMgYSBzcGFya2xpbmUgbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIC8vY3JlYXRlIG1hcCBvYmplY3QgdG8gcmV0dXJuLCB1c2luZyB0aGUgdGVtcGxhdGVcclxuICAgIGNvbnN0IG91dCA9IFN0YXRNYXAuc3RhdE1hcChjb25maWcsIHRydWUsICdzcGFyaycpXHJcblxyXG4gICAgb3V0LnNwYXJrTGluZUNvbG9yXyA9ICdibGFjaydcclxuICAgIG91dC5zcGFya0FyZWFDb2xvcl8gPSAnIzQxYWZhYSdcclxuICAgIG91dC5zcGFya0xpbmVXaWR0aF8gPSAzMFxyXG4gICAgb3V0LnNwYXJrTGluZUhlaWdodF8gPSAyMFxyXG4gICAgb3V0LnNwYXJrTGluZVN0cm9rZVdpZHRoXyA9IDAuNFxyXG4gICAgb3V0LnNwYXJrTGluZU9wYWNpdHlfID0gMC42XHJcbiAgICBvdXQuc3BhcmtUeXBlXyA9ICdsaW5lJ1xyXG4gICAgb3V0LnNwYXJrTGluZUNpcmNsZVJhZGl1c18gPSAwXHJcbiAgICBvdXQuc3BhcmtUb29sdGlwQ2hhcnRfID0ge1xyXG4gICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgICAgaGVpZ2h0OiA1MCxcclxuICAgICAgICBtYXJnaW46IHsgbGVmdDogNjAsIHJpZ2h0OiA0MCwgdG9wOiA0MCwgYm90dG9tOiA0MCB9LFxyXG4gICAgICAgIGNpcmNsZVJhZGl1czogMS41LFxyXG4gICAgfVxyXG5cclxuICAgIC8vc2hvdyBzcGFya2xpbmVzIG9ubHkgd2hlbiBkYXRhIGZvciBhbGwgZGF0ZXMgaXMgY29tcGxldGUuXHJcbiAgICAvL090aGVyd2lzZSwgY29uc2lkZXIgdGhlIHJlZ2lvbnMgYXMgYmVpbmcgd2l0aCBubyBkYXRhIGF0IGFsbC5cclxuICAgIG91dC5zaG93T25seVdoZW5Db21wbGV0ZV8gPSBmYWxzZVxyXG4gICAgb3V0LnNwYXJrTGluZUNoYXJ0RnVuY3Rpb25fID0gdW5kZWZpbmVkXHJcblxyXG4gICAgb3V0LnN0YXRTcGFya18gPSBudWxsXHJcbiAgICBvdXQuc3BhcmtIZWlnaHRDbGFzc2lmaWVyXyA9IG51bGxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluaXRpb24gb2YgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBFYWNoIG1ldGhvZCBmb2xsb3cgdGhlIHNhbWUgcGF0dGVybjpcclxuICAgICAqICAtIFRoZXJlIGlzIGEgc2luZ2xlIG1ldGhvZCBhcyBnZXR0ZXIvc2V0dGVyIG9mIGVhY2ggYXR0cmlidXRlLiBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGUgYXR0cmlidXRlIG5hbWUsIHdpdGhvdXQgdGhlIHRyYWlsaW5nIFwiX1wiIGNoYXJhY3Rlci5cclxuICAgICAqICAtIFRvIGdldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBtZXRob2Qgd2l0aG91dCBhcmd1bWVudC5cclxuICAgICAqICAtIFRvIHNldCB0aGUgYXR0cmlidXRlIHZhbHVlLCBjYWxsIHRoZSBzYW1lIG1ldGhvZCB3aXRoIHRoZSBuZXcgdmFsdWUgYXMgc2luZ2xlIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICA7W1xyXG4gICAgICAgICdzcGFya0xpbmVDb2xvcl8nLFxyXG4gICAgICAgICdzaG93T25seVdoZW5Db21wbGV0ZV8nLFxyXG4gICAgICAgICdzcGFya1R5cGVfJyxcclxuICAgICAgICAnc3BhcmtMaW5lV2lkdGhfJyxcclxuICAgICAgICAnc3BhcmtMaW5lSGVpZ2h0XycsXHJcbiAgICAgICAgJ3NwYXJrTGluZVN0cm9rZVdpZHRoXycsXHJcbiAgICAgICAgJ3NwYXJrTGluZU9wYWNpdHlfJyxcclxuICAgICAgICAnc3BhcmtMaW5lQ2lyY2xlUmFkaXVzXycsXHJcbiAgICAgICAgJ3NwYXJrTGluZUFyZWFDb2xvcl8nLFxyXG4gICAgICAgICdzcGFya1Rvb2x0aXBDaGFydF8nLFxyXG4gICAgICAgICdzcGFya0xpbmVDaGFydEZ1bmN0aW9uXycsXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKGF0dCkge1xyXG4gICAgICAgIG91dFthdHQuc3Vic3RyaW5nKDAsIGF0dC5sZW5ndGggLSAxKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRbYXR0XVxyXG4gICAgICAgICAgICBvdXRbYXR0XSA9IHZcclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9vdmVycmlkZSBhdHRyaWJ1dGUgdmFsdWVzIHdpdGggY29uZmlnIHZhbHVlc1xyXG4gICAgaWYgKGNvbmZpZylcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVDb2xvcicsXHJcbiAgICAgICAgICAgICdzaG93T25seVdoZW5Db21wbGV0ZScsXHJcbiAgICAgICAgICAgICdzcGFya1R5cGUnLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lV2lkdGgnLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lSGVpZ2h0JyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZVN0cm9rZVdpZHRoJyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZU9wYWNpdHknLFxyXG4gICAgICAgICAgICAnc3BhcmtMaW5lQ2lyY2xlUmFkaXVzXycsXHJcbiAgICAgICAgICAgICdzcGFya0xpbmVBcmVhQ29sb3InLFxyXG4gICAgICAgICAgICAnc3BhcmtUb29sdGlwQ2hhcnRfJyxcclxuICAgICAgICAgICAgJ3NwYXJrTGluZUNoYXJ0RnVuY3Rpb25fJyxcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW2tleV0gIT0gdW5kZWZpbmVkKSBvdXRba2V5XShjb25maWdba2V5XSlcclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vIEFsbG93IHVzZXJzIG1hbnVhbGx5IGFkZCBzcGFya2xpbmUgZGF0YVxyXG4gICAgb3V0LnNwYXJrbGluZURhdGFfID0gdW5kZWZpbmVkXHJcbiAgICBvdXQuc3BhcmtsaW5lRGF0YSA9IGZ1bmN0aW9uIChkYXRhT2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgZGF0ZXMgPSBPYmplY3Qua2V5cyhkYXRhT2JqZWN0W09iamVjdC5rZXlzKGRhdGFPYmplY3QpWzBdXSlcclxuICAgICAgICBvdXQuX3N0YXREYXRlcyA9IGRhdGVzXHJcblxyXG4gICAgICAgIGRhdGVzLmZvckVhY2goKGRhdGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdERhdGEgPSBTdGF0aXN0aWNhbERhdGEuc3RhdERhdGEoKVxyXG4gICAgICAgICAgICBjb25zdCBwZXJEYXRlVmFsdWVzID0ge31cclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVnaW9uSWQgaW4gZGF0YU9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaW9uVmFsdWVzID0gZGF0YU9iamVjdFtyZWdpb25JZF1cclxuICAgICAgICAgICAgICAgIHBlckRhdGVWYWx1ZXNbcmVnaW9uSWRdID0gcmVnaW9uVmFsdWVzW2RhdGVdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXREYXRhLnNldERhdGEocGVyRGF0ZVZhbHVlcylcclxuICAgICAgICAgICAgb3V0LnN0YXREYXRhKGRhdGUsIHN0YXREYXRhKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdG8gZGVmaW5lIGEgc3BhcmtsaW5lIG1hcCBlYXNpbHksIHdpdGhvdXQgcmVwZXRpdGlvbiBvZiBpbmZvcm1hdGlvbi5cclxuICAgICAqIE9ubHkgZm9yIGV1cm9iYXNlIGRhdGEgc291cmNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHN0YXQgQSBwYXR0ZXJuIGZvciB0aGUgc3RhdCBkYXRhIHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0ZXMgVGhlIGRhdGVzIG9mIHRoZSBjb21wb3NpdGlvbiAodGltZSBwYXJhbWV0ZXIpXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsYWJlbHMgT3B0aW9uYWw6IFRoZSBsYWJlbHMgZm9yIHRoZSBkYXRlc1xyXG4gICAgICovXHJcbiAgICBvdXQuc3RhdFNwYXJrID0gZnVuY3Rpb24gKHN0YXQsIGRhdGVzLCBsYWJlbHMpIHtcclxuICAgICAgICAvL2FkZCBvbmUgZGF0YXNldCBjb25maWcgZm9yIGVhY2ggY2F0ZWdvcnlcclxuICAgICAgICBzdGF0LmZpbHRlcnMgPSBzdGF0LmZpbHRlcnMgfHwge31cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vY2F0ZWdvcnkgY29kZVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZGF0ZXNbaV1cclxuICAgICAgICAgICAgc3RhdC5maWx0ZXJzLnRpbWUgPSBkYXRlXHJcbiAgICAgICAgICAgIGNvbnN0IHNjXyA9IHt9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0KSBzY19ba2V5XSA9IHN0YXRba2V5XVxyXG4gICAgICAgICAgICBzY18uZmlsdGVycyA9IHt9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0LmZpbHRlcnMpIHNjXy5maWx0ZXJzW2tleV0gPSBzdGF0LmZpbHRlcnNba2V5XVxyXG4gICAgICAgICAgICBvdXQuc3RhdChkYXRlLCBzY18pXHJcblxyXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgcmV0cmlldmUgYW5kIGFzc2lnbiBsYWJlbFxyXG4gICAgICAgICAgICBpZiAobGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0TGFiZWxzX1tkYXRlXSA9IGxhYmVsc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NldCBzdGF0Q29kZXNcclxuICAgICAgICBvdXQuX3N0YXREYXRlcyA9IGRhdGVzXHJcblxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGNvZGVzIG9mIHRoZSBjYXRlZ29yaWVzIHRvIGNvbnNpZGVyIGZvciB0aGUgY29tcG9zaXRpb24uICovXHJcbiAgICBvdXQuX3N0YXREYXRlcyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY29tcHV0ZSBjb21wb3NpdGlvbiBmb3IgcmVnaW9uIGlkLCBmb3IgZWFjaCBkYXRlLlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoLCBmb3IgZWFjaCBkYXRlLCBpdHMgc3RhdGlzdGljYWwgdmFsdWUgZm9yIHRoZSByZWdpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gaWRcclxuICAgICAqIEByZXR1cm5zIFt7ZGF0ZSx2YWx1ZX1dXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldENvbXBvc2l0aW9uID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgbGV0IGNvbXAgPSBbXSxcclxuICAgICAgICAgICAgc3VtID0gMFxyXG5cclxuICAgICAgICAvLyBHZXQgc3RhdCB2YWx1ZSBmb3IgZWFjaCBjYXRlZ29yeSBhbmQgY29tcHV0ZSB0aGUgc3VtLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Ll9zdGF0RGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gUmV0cmlldmUgY29kZSBhbmQgc3RhdCB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlID0gb3V0Ll9zdGF0RGF0ZXNbaV1cclxuICAgICAgICAgICAgY29uc3QgcyA9IG91dC5zdGF0RGF0YShkYXRlKS5nZXQoaWQpXHJcblxyXG4gICAgICAgICAgICAvLyBDYXNlIHdoZW4gc29tZSBkYXRhIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgaWYgKCFzIHx8IChzLnZhbHVlICE9IDAgJiYgIXMudmFsdWUpIHx8IGlzTmFOKHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlKCkpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGVsc2UgY29udGludWVcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29tcC5wdXNoKHsgZGF0ZTogZGF0ZSwgdmFsdWU6IHMudmFsdWUgfSlcclxuICAgICAgICAgICAgc3VtICs9IHMudmFsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhc2Ugd2hlbiBubyBkYXRhXHJcbiAgICAgICAgaWYgKHN1bSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB5ZWFyLW9uLXllYXIgcGVyY2VudGFnZSBjaGFuZ2VcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGNvbXBbaSAtIDFdLnZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGNvbXBbaV0udmFsdWVcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlIGNoYW5nZSBmcm9tIHByZXZpb3VzIHZhbHVlXHJcbiAgICAgICAgICAgIGNvbXBbaV0ucGVyY2VudGFnZUNoYW5nZSA9IHByZXZpb3VzVmFsdWUgPT09IDAgPyAwLjAwMSA6ICgoY3VycmVudFZhbHVlIC0gcHJldmlvdXNWYWx1ZSkgLyBwcmV2aW91c1ZhbHVlKSAqIDEwMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGZpcnN0IGRhdGEgcG9pbnQgZG9lc24ndCBoYXZlIGEgcHJldmlvdXMgdmFsdWUgdG8gY29tcGFyZSB3aXRoXHJcbiAgICAgICAgLy9jb21wWzBdLnBlcmNlbnRhZ2VDaGFuZ2UgPSAwLjAwMSAvLyBvciB5b3UgY2FuIGxlYXZlIGl0IHVuZGVmaW5lZCBvciBudWxsLCBkZXBlbmRpbmcgb24gaG93IHlvdSB3YW50IHRvIGhhbmRsZSBpdFxyXG5cclxuICAgICAgICByZXR1cm4gY29tcFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9pZiBub3QgcHJvdmlkZWQsIGdldCBsaXN0IG9mIHN0YXQgY29kZXMgZnJvbSB0aGUgbWFwIHN0YXQgZGF0YVxyXG4gICAgICAgIGlmICghb3V0Ll9zdGF0RGF0ZXMpIHtcclxuICAgICAgICAgICAgLy9nZXQgbGlzdCBvZiBzdGF0IGNvZGVzLlxyXG4gICAgICAgICAgICBvdXQuX3N0YXREYXRlcyA9IE9iamVjdC5rZXlzKG91dC5zdGF0RGF0YV8pXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIFwiZGVmYXVsdFwiLCBpZiBwcmVzZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3V0Ll9zdGF0RGF0ZXMuaW5kZXhPZignZGVmYXVsdCcpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSBvdXQuX3N0YXREYXRlcy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkZWZpbmUgc2l6ZSBzY2FsaW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBkb21haW4gY29ycmVjdGx5IGZvciB0aGUgbG9nIHNjYWxlXHJcbiAgICAgICAgb3V0LmRvbWFpbiA9IGdldERhdGFzZXRNYXhNaW4oKSAvLyBBdm9pZCAwIGZvciBsb2cgc2NhbGVcclxuXHJcbiAgICAgICAgLy8gZm9yIGFyZWEgY2hhcnRzXHJcbiAgICAgICAgb3V0LndpZHRoQ2xhc3NpZmllcl8gPSBzY2FsZVNxcnQoKS5kb21haW4ob3V0LmRvbWFpbikucmFuZ2UoWzAsIG91dC5zcGFya0xpbmVXaWR0aF9dKVxyXG4gICAgICAgIG91dC5oZWlnaHRDbGFzc2lmaWVyXyA9IHNjYWxlU3FydCgpLmRvbWFpbihvdXQuZG9tYWluKS5yYW5nZShbMCwgb3V0LnNwYXJrTGluZUhlaWdodF9dKVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2J1aWxkIGFuZCBhc3NpZ24gcGllIGNoYXJ0cyB0byB0aGUgcmVnaW9uc1xyXG4gICAgICAgIC8vY29sbGVjdCBudXRzIGlkcyBmcm9tIGcgZWxlbWVudHMuIFRPRE86IGZpbmQgYmV0dGVyIHdheSBvZiBnZXR0aW5nIElEc1xyXG4gICAgICAgIGxldCBudXRzSWRzID0gW11cclxuICAgICAgICBsZXQgcyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoJyNlbS1wcm9wLXN5bWJvbHMnKVxyXG4gICAgICAgIGxldCBzeW0gPSBzLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpLmF0dHIoJ2lkJywgKHJnKSA9PiB7XHJcbiAgICAgICAgICAgIG51dHNJZHMucHVzaChyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICByZXR1cm4gJ3NwYXJrXycgKyByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gc2V0IHJlZ2lvbiBob3ZlciBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG91dClcclxuICAgICAgICBsZXQgcmVnaW9ucyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldENvbXBvc2l0aW9uKHJnLnByb3BlcnRpZXMuaWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5hdHRyKCdmaWxsX19fJywgc2VsLnN0eWxlKCdmaWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgb3V0LmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQuX3Rvb2x0aXApIG91dC5fdG9vbHRpcC5tb3VzZW92ZXIob3V0LnRvb2x0aXBfLnRleHRGdW5jdGlvbihyZywgb3V0KSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSwgcmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBnZXRDb21wb3NpdGlvbihyZy5wcm9wZXJ0aWVzLmlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2Vtb3ZlKGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBzZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RmlsbCA9IHNlbC5zdHlsZSgnZmlsbCcpXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmlsbCA9IHNlbC5hdHRyKCdmaWxsX19fJylcclxuICAgICAgICAgICAgICAgIGlmIChuZXdGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgc2VsLmF0dHIoJ2ZpbGxfX18nKSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ll90b29sdGlwKSBvdXQuX3Rvb2x0aXAubW91c2VvdXQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBhZGRTcGFya0xpbmVzVG9NYXAobnV0c0lkcylcclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkU3BhcmtMaW5lc1RvTWFwKGlkcykge1xyXG4gICAgICAgIGlkcy5mb3JFYWNoKChudXRzaWQpID0+IHtcclxuICAgICAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBzcGFya2xpbmVcclxuICAgICAgICAgICAgLy8gY2FuIGJlIG1vcmUgdGhhbiBvbmUgY2VudGVyIHBvaW50IGZvciBlYWNoIG51dHMgSUQgKGUuZy4gTWFsdGEgd2hlbiBpbmNsdWRlZCBpbiBpbnNldHMpXHJcbiAgICAgICAgICAgIGxldCBub2RlID0gb3V0LnN2ZygpLnNlbGVjdCgnI3NwYXJrXycgKyBudXRzaWQpXHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gZ2V0Q29tcG9zaXRpb24obnV0c2lkKVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVNwYXJrTGluZUNoYXJ0KG5vZGUsIGRhdGEsIG91dC5zcGFya0xpbmVXaWR0aF8sIG91dC5zcGFya0xpbmVIZWlnaHRfKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTcGFya0xpbmVDaGFydChub2RlLCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBpc0ZvclRvb2x0aXAgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIGNhbGwgY3VzdG9tIHVzZXIgZnVuY3Rpb24gdG8gZHJhdyB0aGUgc3BhcmtsaW5lXHJcbiAgICAgICAgaWYgKG91dC5zcGFya0xpbmVDaGFydEZ1bmN0aW9uXyAmJiBvdXQuc3BhcmtMaW5lQ2hhcnRGdW5jdGlvbl8gIT09IGNyZWF0ZVNwYXJrTGluZUNoYXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuc3BhcmtMaW5lQ2hhcnRGdW5jdGlvbl8obm9kZSwgZGF0YSwgd2lkdGgsIGhlaWdodCwgaXNGb3JUb29sdGlwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeFNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFswLCBvdXQuX3N0YXREYXRlcy5sZW5ndGggLSAxXSlcclxuICAgICAgICAgICAgLnJhbmdlKFswLjUsIHdpZHRoIC0gMC41XSlcclxuXHJcbiAgICAgICAgY29uc3QgbWluVmFsdWUgPSBtaW4oZGF0YS5tYXAoKGQpID0+IGQudmFsdWUpKSB8fCAwXHJcbiAgICAgICAgY29uc3QgbWF4VmFsdWUgPSBtYXgoZGF0YS5tYXAoKGQpID0+IGQudmFsdWUpKSB8fCAxXHJcblxyXG4gICAgICAgIGNvbnN0IHlTY2FsZSA9IHNjYWxlTGluZWFyKCkuZG9tYWluKFttaW5WYWx1ZSwgbWF4VmFsdWVdKS5yYW5nZShbaGVpZ2h0LCAwXSlcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGVkRGF0YSA9IGRhdGEubWFwKChkLCBpKSA9PiAoe1xyXG4gICAgICAgICAgICAuLi5kLFxyXG4gICAgICAgICAgICBzY2FsZWRYVmFsdWU6IHhTY2FsZShpKSxcclxuICAgICAgICAgICAgc2NhbGVkWVZhbHVlOiB5U2NhbGUoZC52YWx1ZSksXHJcbiAgICAgICAgfSkpXHJcblxyXG4gICAgICAgIGNvbnN0IHplcm9ZID0geVNjYWxlKDApXHJcblxyXG4gICAgICAgIGlmIChpc0ZvclRvb2x0aXApIHtcclxuICAgICAgICAgICAgLy8gWC1heGlzIGF0IGJvdHRvbVxyXG4gICAgICAgICAgICBub2RlLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYXhpcy14JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7aGVpZ2h0fSlgKVxyXG4gICAgICAgICAgICAgICAgLmNhbGwoXHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0JvdHRvbSh4U2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrcyhvdXQuX3N0YXREYXRlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KChkLCBpKSA9PiBvdXQuX3N0YXREYXRlc1tpXSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgJy0uOGVtJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMTVlbScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgtNjUpJylcclxuXHJcbiAgICAgICAgICAgIC8vIFktYXhpcyB3aXRoIHJhdyB2YWx1ZSBsYWJlbHNcclxuICAgICAgICAgICAgbm9kZS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdheGlzLXknKS5jYWxsKGF4aXNMZWZ0KHlTY2FsZSkudGlja3MoNSkpXHJcblxyXG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIHplcm8gcmVmZXJlbmNlIGxpbmUg4oaSIG9ubHkgaWYgbWluIDwgMCBhbmQgbWF4ID4gMFxyXG4gICAgICAgICAgICBpZiAobWluVmFsdWUgPCAwICYmIG1heFZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgemVyb1kpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgemVyb1kpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdncmF5JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICcyLDInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBsaW5lR2VuZXJhdG9yID0gbGluZSgpXHJcbiAgICAgICAgICAgIC54KChkKSA9PiBkLnNjYWxlZFhWYWx1ZSlcclxuICAgICAgICAgICAgLnkoKGQpID0+IGQuc2NhbGVkWVZhbHVlKVxyXG5cclxuICAgICAgICBpZiAob3V0LnNwYXJrVHlwZV8gPT09ICdhcmVhJykge1xyXG4gICAgICAgICAgICBub2RlLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0dW0oc2NhbGVkRGF0YSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgdHlwZW9mIG91dC5zcGFya0FyZWFDb2xvcl8gPT09ICdmdW5jdGlvbicgPyAoZCwgaSkgPT4gb3V0LnNwYXJrQXJlYUNvbG9yXyhkLCBpKSA6IG91dC5zcGFya0FyZWFDb2xvcl8pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBvdXQuc3BhcmtMaW5lT3BhY2l0eV8pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgMC4zKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAgICAgJ2QnLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZWEoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAueCgoZCkgPT4gZC5zY2FsZWRYVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC55MCh6ZXJvWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnkxKChkKSA9PiBkLnNjYWxlZFlWYWx1ZSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vZGUuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKHNjYWxlZERhdGEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIG91dC5zcGFya0xpbmVPcGFjaXR5XylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIHR5cGVvZiBvdXQuc3BhcmtMaW5lQ29sb3JfID09PSAnZnVuY3Rpb24nID8gKGQsIGkpID0+IG91dC5zcGFya0xpbmVDb2xvcl8oZCwgaSkgOiBvdXQuc3BhcmtMaW5lQ29sb3JfKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnLFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8gPT09ICdmdW5jdGlvbicgPyAoZCwgaSkgPT4gb3V0LnNwYXJrTGluZVN0cm9rZVdpZHRoXyhkLCBpKSA6IG91dC5zcGFya0xpbmVTdHJva2VXaWR0aF8gKyAncHgnXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBsaW5lR2VuZXJhdG9yKVxyXG5cclxuICAgICAgICBub2RlLnNlbGVjdEFsbCgnY2lyY2xlJylcclxuICAgICAgICAgICAgLmRhdGEoc2NhbGVkRGF0YSlcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgKGQpID0+IGQuc2NhbGVkWFZhbHVlKVxyXG4gICAgICAgICAgICAuYXR0cignY3knLCAoZCkgPT4gZC5zY2FsZWRZVmFsdWUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgb3V0LnNwYXJrTGluZUNpcmNsZVJhZGl1c18pXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3JlZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICB9XHJcblxyXG4gICAgLy9zcGVjaWZpYyB0b29sdGlwIHRleHQgZnVuY3Rpb25cclxuICAgIG91dC50b29sdGlwXy50ZXh0RnVuY3Rpb24gPSBmdW5jdGlvbiAocmVnaW9uLCBtYXApIHtcclxuICAgICAgICBjb25zdCBidWYgPSBbXVxyXG5cclxuICAgICAgICBjb25zdCByZWdpb25OYW1lID0gcmVnaW9uLnByb3BlcnRpZXMubmFcclxuICAgICAgICBjb25zdCByZWdpb25JZCA9IHJlZ2lvbi5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgYnVmLnB1c2goYFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVzdGF0LXZpcy10b29sdGlwLWJhclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxiPiR7cmVnaW9uTmFtZX08L2I+JHtyZWdpb25JZCA/IGAgKCR7cmVnaW9uSWR9KWAgOiAnJ31cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICBgKVxyXG5cclxuICAgICAgICBjb25zdCBjaGFydEhlaWdodCA9IG91dC5zcGFya1Rvb2x0aXBDaGFydF8uaGVpZ2h0XHJcbiAgICAgICAgY29uc3QgY2hhcnRXaWR0aCA9IG91dC5zcGFya1Rvb2x0aXBDaGFydF8ud2lkdGhcclxuICAgICAgICBjb25zdCBtYXJnaW4gPSBvdXQuc3BhcmtUb29sdGlwQ2hhcnRfLm1hcmdpblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRDb21wb3NpdGlvbihyZWdpb24ucHJvcGVydGllcy5pZClcclxuXHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gVG90YWwgU1ZHIHNpemUgKGluY2x1ZGluZyBtYXJnaW5zKVxyXG4gICAgICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gY2hhcnRXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gY2hhcnRIZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGRldGFjaGVkIGRpdlxyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBjcmVhdGUoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VtLXRvb2x0aXAtY2hhcnQtY29udGFpbmVyJylcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBTVkcgd2l0aCBmdWxsIHNpemVcclxuICAgICAgICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyLmFwcGVuZCgnc3ZnJykuYXR0cignY2xhc3MnLCAnZW0tdG9vbHRpcC1jaGFydC1zdmcnKS5hdHRyKCd3aWR0aCcsIHRvdGFsV2lkdGgpLmF0dHIoJ2hlaWdodCcsIHRvdGFsSGVpZ2h0KVxyXG5cclxuICAgICAgICAgICAgLy8gSW5uZXIgZ3JvdXAgd2hlcmUgY2hhcnQgaXMgZHJhd25cclxuICAgICAgICAgICAgY29uc3QgZyA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCAke21hcmdpbi50b3B9KWApXHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIHNwYXJrbGluZSBkcmF3aW5nIG9uIHRoZSBpbm5lciBhcmVhIG9ubHlcclxuICAgICAgICAgICAgY3JlYXRlU3BhcmtMaW5lQ2hhcnQoZywgZGF0YSwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIHRydWUpXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcmVzdWx0IHRvIHRvb2x0aXAgYnVmZmVyXHJcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGNvbnRhaW5lci5ub2RlKCkub3V0ZXJIVE1MKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIGdldERhdGFzZXRNYXhNaW5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXRzIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHZhbHVlcyBvZiBhbGwgZGF0ZXMgZm9yIGVhY2ggcmVnaW9uLiBVc2VkIHRvIGRlZmluZSB0aGUgZG9tYWluIG9mIHRoZSBzcGFya2xpbmUgWSBheGlzLlxyXG4gICAgICogQHJldHVybnMgW21pbixtYXhdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldERhdGFzZXRNYXhNaW4oKSB7XHJcbiAgICAgICAgY29uc3QgbWF4cyA9IFtdXHJcbiAgICAgICAgY29uc3Qgc2VsID0gb3V0LnN2ZygpLnNlbGVjdEFsbCgnI2VtLXByb3Atc3ltYm9scycpLnNlbGVjdEFsbCgnZy5lbS1jZW50cm9pZCcpLmRhdGEoKVxyXG5cclxuICAgICAgICBzZWwuZm9yRWFjaCgocmcpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSByZy5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbk1heCA9IGdldFJlZ2lvbk1heChpZClcclxuICAgICAgICAgICAgaWYgKHJlZ2lvbk1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhzLnB1c2gocmVnaW9uTWF4KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgaWYgKG1heHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbMCwgMV0gLy8gZmFsbGJhY2sgaWYgbm8gZGF0YSBmb3VuZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGV4dGVudChtYXhzKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFic29sdXRlIHRvdGFsIHZhbHVlIG9mIGNvbWJpbmVkIHN0YXRpc3RpY2FsIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyByZWdpb24uIEUuZyB0b3RhbCBsaXZlc3RvY2tcclxuICAgICAqIEBwYXJhbSB7Kn0gaWQgbnV0cyByZWdpb24gaWRcclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0UmVnaW9uTWF4ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgbGV0IG1heCA9IDBcclxuXHJcbiAgICAgICAgLy8gZ2V0IHN0YXQgdmFsdWUgZm9yIGVhY2ggZGF0ZSBhbmQgZmluZCB0aGUgbWF4XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQuX3N0YXREYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRlID0gb3V0Ll9zdGF0RGF0ZXNbaV1cclxuICAgICAgICAgICAgY29uc3Qgc3RhdERhdGEgPSBvdXQuc3RhdERhdGEoZGF0ZSlcclxuXHJcbiAgICAgICAgICAgIGlmICghc3RhdERhdGEgfHwgdHlwZW9mIHN0YXREYXRhLmdldCAhPT0gJ2Z1bmN0aW9uJykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzdGF0RGF0YS5nZXQoaWQpXHJcbiAgICAgICAgICAgIGlmICghcyB8fCAocy52YWx1ZSAhPT0gMCAmJiAhcy52YWx1ZSkgfHwgaXNOYU4ocy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdXQuc2hvd09ubHlXaGVuQ29tcGxldGUoKSkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHMudmFsdWUgPiBtYXgpIG1heCA9IHMudmFsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXggPT09IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gbWF4XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ab3ZlcnJpZGVcclxuICAgIG91dC5nZXRMZWdlbmRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL1RPRE8gZGVmaW5lIGxlZ2VuZFxyXG4gICAgICAgIHJldHVybiBsZ2NoLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRcclxufVxyXG5cclxuLy9idWlsZCBhIGNvbG9yIGxlZ2VuZCBvYmplY3RcclxuZXhwb3J0IGNvbnN0IGdldENvbG9yTGVnZW5kID0gZnVuY3Rpb24gKGNvbG9yRnVuKSB7XHJcbiAgICBjb2xvckZ1biA9IGNvbG9yRnVuIHx8IGludGVycG9sYXRlWWxPclJkXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjbCwgbnVtYmVyT2ZDbGFzc2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yRnVuKGVjbCAvIChudW1iZXJPZkNsYXNzZXMgLSAxKSlcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IGFyYywgcGllIH0gZnJvbSAnZDMtc2hhcGUnXHJcbmltcG9ydCB7IHNjaGVtZUNhdGVnb3J5MTAgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnXHJcbi8vc2NoZW1lU2V0MyBzY2hlbWVEYXJrMiBzY2hlbWVQYXN0ZWwxIHNjaGVtZVRhYmxlYXUxMFxyXG5pbXBvcnQgKiBhcyBTdGF0TWFwIGZyb20gJy4uL2NvcmUvc3RhdC1tYXAnXHJcbmltcG9ydCAqIGFzIFN0cmlwZUNvbXBvc2l0aW9uTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9sZWdlbmQtc3RyaXBlLWNvbXBvc2l0aW9uJ1xyXG5pbXBvcnQgeyBnZXRDU1NQcm9wZXJ0eUZyb21DbGFzcywgZ2V0UmVnaW9uc1NlbGVjdG9yIH0gZnJvbSAnLi4vY29yZS91dGlscydcclxuLyoqXHJcbiAqIFJldHVybiBhIHN0cmlwZSBjb21wb3NpdGlvbiBtYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29uZmlnXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFwID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgLy9jcmVhdGUgbWFwIG9iamVjdCB0byByZXR1cm4sIHVzaW5nIHRoZSB0ZW1wbGF0ZVxyXG4gICAgY29uc3Qgb3V0ID0gU3RhdE1hcC5zdGF0TWFwKGNvbmZpZywgZmFsc2UsICdzY29tcCcpXHJcblxyXG4gICAgLy93aWR0aCBvZiB0aGUgc3RyaXBlcyBzZXJpZVxyXG4gICAgb3V0LnN0cmlwZVdpZHRoXyA9IDUwXHJcbiAgICAvL29yaWVudGF0aW9uIC0gdmVydGljYWwgYnkgZGVmYXVsdFxyXG4gICAgb3V0LnN0cmlwZU9yaWVudGF0aW9uXyA9IDBcclxuXHJcbiAgICAvL2NvbG9ycyAtIGluZGV4ZWQgYnkgY2F0ZWdvcnkgY29kZVxyXG4gICAgb3V0LmNhdENvbG9yc18gPSB1bmRlZmluZWRcclxuICAgIC8vbGFiZWxzIC0gaW5kZXhlZCBieSBjYXRlZ29yeSBjb2RlXHJcbiAgICBvdXQuY2F0TGFiZWxzXyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vc2hvdyBzdHJpcGVzIG9ubHkgd2hlbiBkYXRhIGZvciBhbGwgY2F0ZWdvcmllcyBpcyBjb21wbGV0ZS5cclxuICAgIC8vT3RoZXJ3aXNlLCBjb25zaWRlciB0aGUgcmVnaW9ucyBhcyBiZWluZyB3aXRoIG5vIGRhdGEgYXQgYWxsLlxyXG4gICAgb3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlXyA9IGZhbHNlXHJcblxyXG4gICAgLy90b29sdGlwIHBpZSBjaGFydFxyXG4gICAgb3V0LnBpZUNoYXJ0UmFkaXVzXyA9IDQwXHJcbiAgICBvdXQucGllQ2hhcnRJbm5lclJhZGl1c18gPSAxNVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pdGlvbiBvZiBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBwcmV2aW91c2x5IGRlZmluZWQgYXR0cmlidXRlcy5cclxuICAgICAqIEVhY2ggbWV0aG9kIGZvbGxvdyB0aGUgc2FtZSBwYXR0ZXJuOlxyXG4gICAgICogIC0gVGhlcmUgaXMgYSBzaW5nbGUgbWV0aG9kIGFzIGdldHRlci9zZXR0ZXIgb2YgZWFjaCBhdHRyaWJ1dGUuIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIHRoZSBhdHRyaWJ1dGUgbmFtZSwgd2l0aG91dCB0aGUgdHJhaWxpbmcgXCJfXCIgY2hhcmFjdGVyLlxyXG4gICAgICogIC0gVG8gZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIG1ldGhvZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICogIC0gVG8gc2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUsIGNhbGwgdGhlIHNhbWUgbWV0aG9kIHdpdGggdGhlIG5ldyB2YWx1ZSBhcyBzaW5nbGUgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIDtbXHJcbiAgICAgICAgJ3N0cmlwZVdpZHRoXycsXHJcbiAgICAgICAgJ3N0cmlwZU9yaWVudGF0aW9uXycsXHJcbiAgICAgICAgJ2NhdENvbG9yc18nLFxyXG4gICAgICAgICdjYXRMYWJlbHNfJyxcclxuICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGVfJyxcclxuICAgICAgICAnbm9EYXRhRmlsbFN0eWxlXycsXHJcbiAgICAgICAgJ3BpZUNoYXJ0UmFkaXVzXycsXHJcbiAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXNfJyxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoYXR0KSB7XHJcbiAgICAgICAgb3V0W2F0dC5zdWJzdHJpbmcoMCwgYXR0Lmxlbmd0aCAtIDEpXSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dFthdHRdXHJcbiAgICAgICAgICAgIG91dFthdHRdID0gdlxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvL292ZXJyaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2l0aCBjb25maWcgdmFsdWVzXHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ3N0cmlwZVdpZHRoJyxcclxuICAgICAgICAgICAgJ3N0cmlwZU9yaWVudGF0aW9uJyxcclxuICAgICAgICAgICAgJ2NhdENvbG9ycycsXHJcbiAgICAgICAgICAgICdjYXRMYWJlbHMnLFxyXG4gICAgICAgICAgICAnc2hvd09ubHlXaGVuQ29tcGxldGUnLFxyXG4gICAgICAgICAgICAnbm9EYXRhRmlsbFN0eWxlJyxcclxuICAgICAgICAgICAgJ3BpZUNoYXJ0UmFkaXVzJyxcclxuICAgICAgICAgICAgJ3BpZUNoYXJ0SW5uZXJSYWRpdXMnLFxyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSB1bmRlZmluZWQpIG91dFtrZXldKGNvbmZpZ1trZXldKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRlZmluZSBhIHN0cmlwZSBtYXAgZWFzaWx5LCB3aXRob3V0IHJlcGV0aXRpb24gb2YgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBPbmx5IGZvciBldXJvYmFzZSBkYXRhIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0IEEgcGF0dGVybiBmb3IgdGhlIHN0YXQgZGF0YSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaW0gVGhlIGRpbWVuc2lvbiBvZiB0aGUgY29tcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2RlcyBUaGUgY2F0ZWdvcnkgY29kZXMgb2YgdGhlIGNvbXBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsYWJlbHMgT3B0aW9uYWw6IFRoZSBsYWJlbHMgZm9yIHRoZSBjYXRlZ29yeSBjb2Rlc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sb3JzIE9wdGlvbmFsOiBUaGUgY29sb3JzIGZvciB0aGUgY2F0ZWdvcnlcclxuICAgICAqL1xyXG4gICAgb3V0LnN0YXRDb21wID0gZnVuY3Rpb24gKHN0YXQsIGRpbSwgY29kZXMsIGxhYmVscywgY29sb3JzKSB7XHJcbiAgICAgICAgLy9hZGQgb25lIGRhdGFzZXQgY29uZmlnIGZvciBlYWNoIGNhdGVnb3J5XHJcbiAgICAgICAgc3RhdC5maWx0ZXJzID0gc3RhdC5maWx0ZXJzIHx8IHt9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL2NhdGVnb3J5IGNvZGVcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGNvZGVzW2ldXHJcbiAgICAgICAgICAgIHN0YXQuZmlsdGVyc1tkaW1dID0gY29kZVxyXG4gICAgICAgICAgICBjb25zdCBzY18gPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdCkgc2NfW2tleV0gPSBzdGF0W2tleV1cclxuICAgICAgICAgICAgc2NfLmZpbHRlcnMgPSB7fVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc3RhdC5maWx0ZXJzKSBzY18uZmlsdGVyc1trZXldID0gc3RhdC5maWx0ZXJzW2tleV1cclxuICAgICAgICAgICAgb3V0LnN0YXQoY29kZSwgc2NfKVxyXG5cclxuICAgICAgICAgICAgLy9pZiBzcGVjaWZpZWQsIHJldHJpZXZlIGFuZCBhc3NpZ24gY29sb3JcclxuICAgICAgICAgICAgaWYgKGNvbG9ycykge1xyXG4gICAgICAgICAgICAgICAgb3V0LmNhdENvbG9yc18gPSBvdXQuY2F0Q29sb3JzXyB8fCB7fVxyXG4gICAgICAgICAgICAgICAgb3V0LmNhdENvbG9yc19bY29kZV0gPSBjb2xvcnNbaV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgcmV0cmlldmUgYW5kIGFzc2lnbiBsYWJlbFxyXG4gICAgICAgICAgICBpZiAobGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcbiAgICAgICAgICAgICAgICBvdXQuY2F0TGFiZWxzX1tjb2RlXSA9IGxhYmVsc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NldCBzdGF0Q29kZXNcclxuICAgICAgICBzdGF0Q29kZXMgPSBjb2Rlc1xyXG5cclxuICAgICAgICByZXR1cm4gb3V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBjb2RlcyBvZiB0aGUgY2F0ZWdvcmllcyB0byBjb25zaWRlciBmb3IgdGhlIGNvbXBvc2l0aW9uLiAqL1xyXG4gICAgbGV0IHN0YXRDb2RlcyA9IHVuZGVmaW5lZFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY29tcHV0ZSBjb21wb3NpdGlvbiBmb3IgcmVnaW9uIGlkLCBmb3IgZWFjaCBjYXRlZ29yeS5cclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCwgZm9yIGVhY2ggY2F0ZWdvcnksIHRoZSBzaGFyZSBbMCwxXSBvZiB0aGUgY2F0ZWdvcnkuXHJcbiAgICAgKiBAcGFyYW0geyp9IGlkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldENvbXBvc2l0aW9uID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgbGV0IGNvbXAgPSB7fSxcclxuICAgICAgICAgICAgc3VtID0gMFxyXG4gICAgICAgIC8vZ2V0IHN0YXQgdmFsdWUgZm9yIGVhY2ggY2F0ZWdvcnkuIENvbXB1dGUgdGhlIHN1bS5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRDb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL3JldHJpZXZlIGNvZGUgYW5kIHN0YXQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3Qgc2MgPSBzdGF0Q29kZXNbaV1cclxuICAgICAgICAgICAgY29uc3QgcyA9IG91dC5zdGF0RGF0YShzYykuZ2V0KGlkKVxyXG5cclxuICAgICAgICAgICAgLy9jYXNlIHdoZW4gc29tZSBkYXRhIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgaWYgKCFzIHx8IChzLnZhbHVlICE9IDAgJiYgIXMudmFsdWUpIHx8IGlzTmFOKHMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3V0LnNob3dPbmx5V2hlbkNvbXBsZXRlKCkpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGVsc2UgY29udGludWVcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29tcFtzY10gPSBzLnZhbHVlXHJcbiAgICAgICAgICAgIHN1bSArPSBzLnZhbHVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2Nhc2Ugd2hlbiBubyBkYXRhXHJcbiAgICAgICAgaWYgKHN1bSA9PSAwKSByZXR1cm4gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSByYXRpb3NcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRDb2Rlcy5sZW5ndGg7IGkrKykgY29tcFtzdGF0Q29kZXNbaV1dIC89IHN1bVxyXG5cclxuICAgICAgICByZXR1cm4gY29tcFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlQ2xhc3NpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9pZiBub3QgcHJvdmlkZWQsIGdldCBsaXN0IG9mIHN0YXQgY29kZXMgZnJvbSB0aGUgbWFwIHN0YXQgZGF0YVxyXG4gICAgICAgIGlmICghc3RhdENvZGVzKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGxpc3Qgb2Ygc3RhdCBjb2Rlcy5cclxuICAgICAgICAgICAgc3RhdENvZGVzID0gT2JqZWN0LmtleXMob3V0LnN0YXREYXRhXylcclxuICAgICAgICAgICAgLy9yZW1vdmUgXCJkZWZhdWx0XCIsIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdGF0Q29kZXMuaW5kZXhPZignZGVmYXVsdCcpXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSBzdGF0Q29kZXMuc3BsaWNlKGluZGV4LCAxKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9pZiBub3Qgc3BlY2lmaWVkLCBidWlsZCBkZWZhdWx0IGNvbG9yIHJhbXBcclxuICAgICAgICBpZiAoIW91dC5jYXRDb2xvcnMoKSkge1xyXG4gICAgICAgICAgICBvdXQuY2F0Q29sb3JzKHt9KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRDb2Rlcy5sZW5ndGg7IGkrKykgb3V0LmNhdENvbG9ycygpW3N0YXRDb2Rlc1tpXV0gPSBzY2hlbWVDYXRlZ29yeTEwW2kgJSAxMF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgbm90IHNwZWNpZmllZCwgaW5pdGlhbGlzZSBjYXRlZ29yeSBsYWJlbHNcclxuICAgICAgICBvdXQuY2F0TGFiZWxzXyA9IG91dC5jYXRMYWJlbHNfIHx8IHt9XHJcblxyXG4gICAgICAgIC8vYnVpbGQgYW5kIGFzc2lnbiB0ZXh0dXJlIHRvIHRoZSByZWdpb25zXHJcbiAgICAgICAgb3V0LnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoZ2V0UmVnaW9uc1NlbGVjdG9yKG91dCkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZW0tY250cmcnKSkgcmV0dXJuIC8vIFNraXAgY291bnRyeSByZWdpb25zXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGQucHJvcGVydGllcy5pZFxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBjb21wb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRpb24gPSBnZXRDb21wb3NpdGlvbihpZClcclxuXHJcbiAgICAgICAgICAgICAgICAvL2Nhc2Ugd2hlbiBubyBvciBtaXNzaW5nIGRhdGFcclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9zaXRpb24pIHJldHVybiBvdXQubm9EYXRhRmlsbFN0eWxlKCkgfHwgJ2dyYXknXHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHN0cmlwZSBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ID0gb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgLnN2ZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0dGVybicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3BhdHRlcm5fJyArIGlkKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgJzAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJzAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zdHJpcGVXaWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwYXR0ZXJuVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKVxyXG4gICAgICAgICAgICAgICAgLy91c2Ugb3JpZW50YXRpb24sIGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5zdHJpcGVPcmllbnRhdGlvbigpKSBwYXR0LmF0dHIoJ3BhdHRlcm5UcmFuc2Zvcm0nLCAncm90YXRlKCcgKyBvdXQuc3RyaXBlT3JpZW50YXRpb24oKSArICcpJylcclxuXHJcbiAgICAgICAgICAgICAgICAvL2JhY2tncm91bmRcclxuICAgICAgICAgICAgICAgIHBhdHQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG91dC5zdHJpcGVXaWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICdsaWdodGdyYXknKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFrZSBzdHJpcGVzLCBvbmUgcGVyIGNhdGVnb3J5XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IDBcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgaW4gY29tcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2dldCBzdHJpcGUgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkeCA9IGNvbXBvc2l0aW9uW2NvZGVdXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkeCkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBkeCAqPSBvdXQuc3RyaXBlV2lkdGgoKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dldCBzdHJpcGUgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBvdXQuY2F0Q29sb3JzKClbY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgc3RyaXBlIHRvIHBhdHRlcm46IGEgdGhpbiByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgICAgICBwYXR0LmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjb2RlJywgY29kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY29sKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RyYW5zaXRpb24gYWxvbmcgeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihvdXQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGR4KVxyXG4gICAgICAgICAgICAgICAgICAgIHggKz0gZHhcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBwYXR0ZXJuIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd1cmwoI3BhdHRlcm5fJyArIGlkICsgJyknXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCduZCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWdldENvbXBvc2l0aW9uKGQucHJvcGVydGllcy5pZCkgPyAnbmQnIDogJydcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gc2V0IHJlZ2lvbiBob3ZlciBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0UmVnaW9uc1NlbGVjdG9yKG91dClcclxuICAgICAgICBsZXQgcmVnaW9ucyA9IG91dC5zdmcoKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgICAgcmVnaW9uc1xyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzZWwuYXR0cignZmlsbF9fXycsIHNlbC5zdHlsZSgnZmlsbCcpKVxyXG4gICAgICAgICAgICAgICAgc2VsLnN0eWxlKCdmaWxsJywgb3V0LmhvdmVyQ29sb3JfKVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3ZlcihvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uKHJnLCBvdXQpKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlLCByZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlbW92ZShlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEZpbGwgPSBzZWwuc3R5bGUoJ2ZpbGwnKVxyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpbGwgPSBzZWwuYXR0cignZmlsbF9fXycpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbC5zdHlsZSgnZmlsbCcsIHNlbC5hdHRyKCdmaWxsX19fJykpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5fdG9vbHRpcCkgb3V0Ll90b29sdGlwLm1vdXNlb3V0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgfVxyXG5cclxuICAgIC8vQG92ZXJyaWRlXHJcbiAgICBvdXQuZ2V0TGVnZW5kQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmlwZUNvbXBvc2l0aW9uTGVnZW5kLmxlZ2VuZFxyXG4gICAgfVxyXG5cclxuICAgIC8vc3BlY2lmaWMgdG9vbHRpcCB0ZXh0IGZ1bmN0aW9uXHJcbiAgICBvdXQudG9vbHRpcF8udGV4dEZ1bmN0aW9uID0gZnVuY3Rpb24gKHJnLCBtYXApIHtcclxuICAgICAgICAvL2dldCB0b29sdGlwXHJcbiAgICAgICAgY29uc3QgdHAgPSBzZWxlY3QoJyN0b29sdGlwX2V1cm9zdGF0JylcclxuXHJcbiAgICAgICAgLy9jbGVhclxyXG4gICAgICAgIHRwLmh0bWwoJycpXHJcbiAgICAgICAgdHAuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy93cml0ZSByZWdpb24gbmFtZVxyXG4gICAgICAgIGNvbnN0IHJlZ2lvbk5hbWUgPSByZy5wcm9wZXJ0aWVzLm5hIHx8IHJnLnByb3BlcnRpZXMubmFtZVxyXG4gICAgICAgIGlmIChyZy5wcm9wZXJ0aWVzLmlkKSB7XHJcbiAgICAgICAgICAgIC8vbmFtZSBhbmQgY29kZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmh0bWwoJzxiPicgKyByZWdpb25OYW1lICsgJzwvYj4gKCcgKyByZy5wcm9wZXJ0aWVzLmlkICsgJykgPGJyPicpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9yZWdpb24gbmFtZVxyXG4gICAgICAgICAgICB0cC5hcHBlbmQoJ2RpdicpLmh0bWwoJzxiPicgKyByZWdpb25OYW1lICsgJzwvYj48YnI+JylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBkYXRhIGZvciBwaWUgY2hhcnRcclxuICAgICAgICBjb25zdCBkYXRhID0gW11cclxuICAgICAgICBjb25zdCBjb21wID0gZ2V0Q29tcG9zaXRpb24ocmcucHJvcGVydGllcy5pZClcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wKSBkYXRhLnB1c2goeyBjb2RlOiBrZXksIHZhbHVlOiBjb21wW2tleV0gfSlcclxuXHJcbiAgICAgICAgLy9jYXNlIG9mIHJlZ2lvbnMgd2l0aCBubyBkYXRhXHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdHAuYXBwZW5kKCdkaXYnKS5odG1sKG91dC5ub0RhdGFUZXh0KCkpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgc3ZnIGZvciBwaWUgY2hhcnRcclxuICAgICAgICBjb25zdCByID0gb3V0LnBpZUNoYXJ0UmFkaXVzKCksXHJcbiAgICAgICAgICAgIGlyID0gb3V0LnBpZUNoYXJ0SW5uZXJSYWRpdXMoKVxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IHRwXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgWy1yLCAtciwgMiAqIHIsIDIgKiByXSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMiAqIHIpXHJcblxyXG4gICAgICAgIC8vbWFrZSBwaWUgY2hhcnQuIFNlZSBodHRwczovL29ic2VydmFibGVocS5jb20vQGQzL3BpZS1jaGFydFxyXG4gICAgICAgIGNvbnN0IHBpZV8gPSBwaWUoKVxyXG4gICAgICAgICAgICAuc29ydChudWxsKVxyXG4gICAgICAgICAgICAudmFsdWUoKGQpID0+IGQudmFsdWUpXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZGFya2dyYXknKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdGEocGllXyhkYXRhKSlcclxuICAgICAgICAgICAgLmpvaW4oJ3BhdGgnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5jYXRDb2xvcnMoKVtkLmRhdGEuY29kZV0gfHwgJ2xpZ2h0Z3JheSdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBhcmMoKS5pbm5lclJhZGl1cyhpcikub3V0ZXJSYWRpdXMocikpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFxyXG59XHJcbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRvb2x0aXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICBjb25maWcgPSBjb25maWcgfHwge31cclxuICAgIGNvbmZpZy5jb250YWluZXJJZCA9IGNvbmZpZy5jb250YWluZXJJZCB8fCAnbWFwJ1xyXG4gICAgY29uZmlnLmRpdiA9IGNvbmZpZy5kaXYgfHwgJ3Rvb2x0aXBfZXVyb3N0YXQnXHJcbiAgICBjb25maWcubWF4V2lkdGggPSBjb25maWcubWF4V2lkdGggfHwgJzIwMHB4J1xyXG4gICAgY29uZmlnLmZvbnRTaXplID0gY29uZmlnLmZvbnRTaXplIHx8ICcxNHB4J1xyXG4gICAgY29uZmlnLmJhY2tncm91bmQgPSBjb25maWcuYmFja2dyb3VuZCB8fCAnd2hpdGUnXHJcbiAgICBjb25maWcucGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nIHx8ICcwcHgnXHJcbiAgICBjb25maWcuYm9yZGVyID0gY29uZmlnLmJvcmRlciB8fCAnMHB4J1xyXG4gICAgY29uZmlnLmJvcmRlclJhZGl1cyA9IGNvbmZpZy5ib3JkZXJSYWRpdXMgfHwgJzBweCdcclxuICAgIGNvbmZpZy5ib3hTaGFkb3cgPSBjb25maWcuYm94U2hhZG93IHx8ICcwcHggMHB4IDBweCBncmV5J1xyXG5cclxuICAgIGNvbmZpZy50cmFuc2l0aW9uRHVyYXRpb24gPSBjb25maWcudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDBcclxuICAgIGNvbmZpZy54T2Zmc2V0ID0gY29uZmlnLnhPZmZzZXQgfHwgMzBcclxuICAgIGNvbmZpZy55T2Zmc2V0ID0gY29uZmlnLnlPZmZzZXQgfHwgMjBcclxuXHJcbiAgICBsZXQgdG9vbHRpcFxyXG5cclxuICAgIGZ1bmN0aW9uIG15KCkge1xyXG4gICAgICAgIHRvb2x0aXAgPSBzZWxlY3QoJyMnICsgY29uZmlnLmRpdilcclxuICAgICAgICBpZiAodG9vbHRpcC5lbXB0eSgpKSB0b29sdGlwID0gc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKS5hdHRyKCdpZCcsIGNvbmZpZy5kaXYpXHJcblxyXG4gICAgICAgIHRvb2x0aXAuYXR0cignY2xhc3MnLCAndG9vbHRpcC1ldXJvc3RhdCcpXHJcbiAgICB9XHJcblxyXG4gICAgbXkubW91c2VvdmVyID0gZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgICBpZiAoaHRtbCkgdG9vbHRpcC5odG1sKGh0bWwpXHJcbiAgICAgICAgbGV0IHggPSBldmVudC5wYWdlWFxyXG4gICAgICAgIGxldCB5ID0gZXZlbnQucGFnZVlcclxuICAgICAgICBteS5lbnN1cmVUb29sdGlwT25TY3JlZW4oeCwgeSlcclxuICAgIH1cclxuXHJcbiAgICBteS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBsZXQgeCA9IGV2ZW50LnBhZ2VYXHJcbiAgICAgICAgbGV0IHkgPSBldmVudC5wYWdlWVxyXG4gICAgICAgIHRoaXMuZW5zdXJlVG9vbHRpcE9uU2NyZWVuKHgsIHkpXHJcbiAgICB9XHJcblxyXG4gICAgbXkubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdG9vbHRpcC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICB9XHJcblxyXG4gICAgbXkuc3R5bGUgPSBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHJldHVybiB0b29sdGlwLnN0eWxlKGspXHJcbiAgICAgICAgdG9vbHRpcC5zdHlsZShrLCB2KVxyXG4gICAgICAgIHJldHVybiBteVxyXG4gICAgfVxyXG5cclxuICAgIG15LmF0dHIgPSBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHJldHVybiB0b29sdGlwLmF0dHIoaylcclxuICAgICAgICB0b29sdGlwLmF0dHIoaywgdilcclxuICAgICAgICByZXR1cm4gbXlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBlbnN1cmVUb29sdGlwT25TY3JlZW5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBQcmV2ZW50cyB0aGUgdG9vbHRpcCBmcm9tIG92ZXJmbG93aW5nIG9mZiBzY3JlZW5cclxuICAgICAqL1xyXG4gICAgbXkuZW5zdXJlVG9vbHRpcE9uU2NyZWVuID0gZnVuY3Rpb24gKGV2ZW50WCwgZXZlbnRZKSB7XHJcbiAgICAgICAgdG9vbHRpcC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgbGV0IG5vZGUgPSB0b29sdGlwLm5vZGUoKVxyXG5cclxuICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBldmVudFggKyBjb25maWcueE9mZnNldCArICdweCdcclxuICAgICAgICBub2RlLnN0eWxlLnRvcCA9IGV2ZW50WSAtIGNvbmZpZy55T2Zmc2V0ICsgJ3B4J1xyXG5cclxuICAgICAgICBsZXQgcGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29uZmlnLmNvbnRhaW5lcklkKVxyXG4gICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIC8vIGdldCB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXHJcbiAgICAgICAgbGV0IHBhcmVudFdpZHRoID0gcmVjdC53aWR0aFxyXG4gICAgICAgIGxldCBwYXJlbnRIZWlnaHQgPSByZWN0LmhlaWdodFxyXG5cclxuICAgICAgICAvL3RvbyBmYXIgcmlnaHRcclxuICAgICAgICAvL3Rha2luZyBpbnRvIGFjY291bnQgb2ZmIHNjcmVlbiBzcGFjZSBidXQgc2hvdWxkbnQgYmVcclxuICAgICAgICBpZiAobm9kZS5vZmZzZXRMZWZ0ID4gcmVjdC5sZWZ0ICsgcGFyZW50V2lkdGggLSBub2RlLmNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gZXZlbnRYIC0gbm9kZS5jbGllbnRXaWR0aCAtIGNvbmZpZy54T2Zmc2V0XHJcbiAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG1vdXNlIGNvdmVycyB0b29sdGlwXHJcbiAgICAgICAgICAgIGlmIChub2RlLm9mZnNldExlZnQgKyBub2RlLmNsaWVudFdpZHRoID4gZXZlbnRYKSB7XHJcbiAgICAgICAgICAgICAgICAvL21vdmUgdG9vbHRpcCBsZWZ0IHNvIGl0IGRvZXNudCBjb3ZlciBtb3VzZVxyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQyID0gZXZlbnRYIC0gbm9kZS5jbGllbnRXaWR0aCAtIGNvbmZpZy54T2Zmc2V0XHJcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0MiArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBub2RlLnN0eWxlLnRvcCA9IG5vZGUub2Zmc2V0VG9wICsgY29uZmlnLnlPZmZzZXQgKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RvbyBmYXIgZG93blxyXG4gICAgICAgIGlmIChub2RlLm9mZnNldFRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ID4gcmVjdC50b3AgKyBwYXJlbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgPSBub2RlLm9mZnNldFRvcCAtIG5vZGUuY2xpZW50SGVpZ2h0ICsgJ3B4J1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBteSgpXHJcbiAgICByZXR1cm4gbXlcclxufVxyXG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxudmFyIHRvcCA9IDEsXG4gICAgcmlnaHQgPSAyLFxuICAgIGJvdHRvbSA9IDMsXG4gICAgbGVmdCA9IDQsXG4gICAgZXBzaWxvbiA9IDFlLTY7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVgoeCkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsMClcIjtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlWSh5KSB7XG4gIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgeSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBudW1iZXIoc2NhbGUpIHtcbiAgcmV0dXJuIGQgPT4gK3NjYWxlKGQpO1xufVxuXG5mdW5jdGlvbiBjZW50ZXIoc2NhbGUsIG9mZnNldCkge1xuICBvZmZzZXQgPSBNYXRoLm1heCgwLCBzY2FsZS5iYW5kd2lkdGgoKSAtIG9mZnNldCAqIDIpIC8gMjtcbiAgaWYgKHNjYWxlLnJvdW5kKCkpIG9mZnNldCA9IE1hdGgucm91bmQob2Zmc2V0KTtcbiAgcmV0dXJuIGQgPT4gK3NjYWxlKGQpICsgb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBlbnRlcmluZygpIHtcbiAgcmV0dXJuICF0aGlzLl9fYXhpcztcbn1cblxuZnVuY3Rpb24gYXhpcyhvcmllbnQsIHNjYWxlKSB7XG4gIHZhciB0aWNrQXJndW1lbnRzID0gW10sXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXQgPSBudWxsLFxuICAgICAgdGlja1NpemVJbm5lciA9IDYsXG4gICAgICB0aWNrU2l6ZU91dGVyID0gNixcbiAgICAgIHRpY2tQYWRkaW5nID0gMyxcbiAgICAgIG9mZnNldCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxID8gMCA6IDAuNSxcbiAgICAgIGsgPSBvcmllbnQgPT09IHRvcCB8fCBvcmllbnQgPT09IGxlZnQgPyAtMSA6IDEsXG4gICAgICB4ID0gb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PT0gcmlnaHQgPyBcInhcIiA6IFwieVwiLFxuICAgICAgdHJhbnNmb3JtID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBib3R0b20gPyB0cmFuc2xhdGVYIDogdHJhbnNsYXRlWTtcblxuICBmdW5jdGlvbiBheGlzKGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWVzID0gdGlja1ZhbHVlcyA9PSBudWxsID8gKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpIDogdGlja1ZhbHVlcyxcbiAgICAgICAgZm9ybWF0ID0gdGlja0Zvcm1hdCA9PSBudWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IGlkZW50aXR5KSA6IHRpY2tGb3JtYXQsXG4gICAgICAgIHNwYWNpbmcgPSBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCAwKSArIHRpY2tQYWRkaW5nLFxuICAgICAgICByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICAgIHJhbmdlMCA9ICtyYW5nZVswXSArIG9mZnNldCxcbiAgICAgICAgcmFuZ2UxID0gK3JhbmdlW3JhbmdlLmxlbmd0aCAtIDFdICsgb2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbiA9IChzY2FsZS5iYW5kd2lkdGggPyBjZW50ZXIgOiBudW1iZXIpKHNjYWxlLmNvcHkoKSwgb2Zmc2V0KSxcbiAgICAgICAgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dCxcbiAgICAgICAgcGF0aCA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoW251bGxdKSxcbiAgICAgICAgdGljayA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHZhbHVlcywgc2NhbGUpLm9yZGVyKCksXG4gICAgICAgIHRpY2tFeGl0ID0gdGljay5leGl0KCksXG4gICAgICAgIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIiksXG4gICAgICAgIGxpbmUgPSB0aWNrLnNlbGVjdChcImxpbmVcIiksXG4gICAgICAgIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XG5cbiAgICBwYXRoID0gcGF0aC5tZXJnZShwYXRoLmVudGVyKCkuaW5zZXJ0KFwicGF0aFwiLCBcIi50aWNrXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJjdXJyZW50Q29sb3JcIikpO1xuXG4gICAgdGljayA9IHRpY2subWVyZ2UodGlja0VudGVyKTtcblxuICAgIGxpbmUgPSBsaW5lLm1lcmdlKHRpY2tFbnRlci5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpXG4gICAgICAgIC5hdHRyKHggKyBcIjJcIiwgayAqIHRpY2tTaXplSW5uZXIpKTtcblxuICAgIHRleHQgPSB0ZXh0Lm1lcmdlKHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcImN1cnJlbnRDb2xvclwiKVxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBvcmllbnQgPT09IHRvcCA/IFwiMGVtXCIgOiBvcmllbnQgPT09IGJvdHRvbSA/IFwiMC43MWVtXCIgOiBcIjAuMzJlbVwiKSk7XG5cbiAgICBpZiAoY29udGV4dCAhPT0gc2VsZWN0aW9uKSB7XG4gICAgICBwYXRoID0gcGF0aC50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgdGljayA9IHRpY2sudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICB0ZXh0ID0gdGV4dC50cmFuc2l0aW9uKGNvbnRleHQpO1xuXG4gICAgICB0aWNrRXhpdCA9IHRpY2tFeGl0LnRyYW5zaXRpb24oY29udGV4dClcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBpc0Zpbml0ZShkID0gcG9zaXRpb24oZCkpID8gdHJhbnNmb3JtKGQgKyBvZmZzZXQpIDogdGhpcy5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7IH0pO1xuXG4gICAgICB0aWNrRW50ZXJcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHZhciBwID0gdGhpcy5wYXJlbnROb2RlLl9fYXhpczsgcmV0dXJuIHRyYW5zZm9ybSgocCAmJiBpc0Zpbml0ZShwID0gcChkKSkgPyBwIDogcG9zaXRpb24oZCkpICsgb2Zmc2V0KTsgfSk7XG4gICAgfVxuXG4gICAgdGlja0V4aXQucmVtb3ZlKCk7XG5cbiAgICBwYXRoXG4gICAgICAgIC5hdHRyKFwiZFwiLCBvcmllbnQgPT09IGxlZnQgfHwgb3JpZW50ID09PSByaWdodFxuICAgICAgICAgICAgPyAodGlja1NpemVPdXRlciA/IFwiTVwiICsgayAqIHRpY2tTaXplT3V0ZXIgKyBcIixcIiArIHJhbmdlMCArIFwiSFwiICsgb2Zmc2V0ICsgXCJWXCIgKyByYW5nZTEgKyBcIkhcIiArIGsgKiB0aWNrU2l6ZU91dGVyIDogXCJNXCIgKyBvZmZzZXQgKyBcIixcIiArIHJhbmdlMCArIFwiVlwiICsgcmFuZ2UxKVxuICAgICAgICAgICAgOiAodGlja1NpemVPdXRlciA/IFwiTVwiICsgcmFuZ2UwICsgXCIsXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiVlwiICsgb2Zmc2V0ICsgXCJIXCIgKyByYW5nZTEgKyBcIlZcIiArIGsgKiB0aWNrU2l6ZU91dGVyIDogXCJNXCIgKyByYW5nZTAgKyBcIixcIiArIG9mZnNldCArIFwiSFwiICsgcmFuZ2UxKSk7XG5cbiAgICB0aWNrXG4gICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiB0cmFuc2Zvcm0ocG9zaXRpb24oZCkgKyBvZmZzZXQpOyB9KTtcblxuICAgIGxpbmVcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcik7XG5cbiAgICB0ZXh0XG4gICAgICAgIC5hdHRyKHgsIGsgKiBzcGFjaW5nKVxuICAgICAgICAudGV4dChmb3JtYXQpO1xuXG4gICAgc2VsZWN0aW9uLmZpbHRlcihlbnRlcmluZylcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLCAxMClcbiAgICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLCBcInNhbnMtc2VyaWZcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBvcmllbnQgPT09IHJpZ2h0ID8gXCJzdGFydFwiIDogb3JpZW50ID09PSBsZWZ0ID8gXCJlbmRcIiA6IFwibWlkZGxlXCIpO1xuXG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLl9fYXhpcyA9IHBvc2l0aW9uOyB9KTtcbiAgfVxuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUgPSBfLCBheGlzKSA6IHNjYWxlO1xuICB9O1xuXG4gIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlja0FyZ3VtZW50cyA9IEFycmF5LmZyb20oYXJndW1lbnRzKSwgYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tBcmd1bWVudHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0FyZ3VtZW50cyA9IF8gPT0gbnVsbCA/IFtdIDogQXJyYXkuZnJvbShfKSwgYXhpcykgOiB0aWNrQXJndW1lbnRzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tWYWx1ZXMgPSBfID09IG51bGwgPyBudWxsIDogQXJyYXkuZnJvbShfKSwgYXhpcykgOiB0aWNrVmFsdWVzICYmIHRpY2tWYWx1ZXMuc2xpY2UoKTtcbiAgfTtcblxuICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0Zvcm1hdCA9IF8sIGF4aXMpIDogdGlja0Zvcm1hdDtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSB0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVJbm5lcjtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVJbm5lciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZU91dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplT3V0ZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZU91dGVyO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1BhZGRpbmcgPSArXywgYXhpcykgOiB0aWNrUGFkZGluZztcbiAgfTtcblxuICBheGlzLm9mZnNldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvZmZzZXQgPSArXywgYXhpcykgOiBvZmZzZXQ7XG4gIH07XG5cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzVG9wKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKHRvcCwgc2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXhpc1JpZ2h0KHNjYWxlKSB7XG4gIHJldHVybiBheGlzKHJpZ2h0LCBzY2FsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheGlzQm90dG9tKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGJvdHRvbSwgc2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXhpc0xlZnQoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXMobGVmdCwgc2NhbGUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG5leHBvcnQgdmFyIGRhcmtlciA9IDAuNztcbmV4cG9ydCB2YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXG4gICAgcmVOID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT8oPzpcXFxcZCpcXFxcLik/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4ID0gL14jKFswLTlhLWZdezMsOH0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChgXnJnYlxcXFwoJHtyZUl9LCR7cmVJfSwke3JlSX1cXFxcKSRgKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKGBecmdiXFxcXCgke3JlUH0sJHtyZVB9LCR7cmVQfVxcXFwpJGApLFxuICAgIHJlUmdiYUludGVnZXIgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHtyZUl9LCR7cmVJfSwke3JlSX0sJHtyZU59XFxcXCkkYCksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoYF5yZ2JhXFxcXCgke3JlUH0sJHtyZVB9LCR7cmVQfSwke3JlTn1cXFxcKSRgKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKGBeaHNsXFxcXCgke3JlTn0sJHtyZVB9LCR7cmVQfVxcXFwpJGApLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKGBeaHNsYVxcXFwoJHtyZU59LCR7cmVQfSwke3JlUH0sJHtyZU59XFxcXCkkYCk7XG5cbnZhciBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgYXF1YTogMHgwMGZmZmYsXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICBhenVyZTogMHhmMGZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkYyxcbiAgYmlzcXVlOiAweGZmZTRjNCxcbiAgYmxhY2s6IDB4MDAwMDAwLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2QsXG4gIGJsdWU6IDB4MDAwMGZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgYnJvd246IDB4YTUyYTJhLFxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICBjaGFydHJldXNlOiAweDdmZmYwMCxcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgY29yYWw6IDB4ZmY3ZjUwLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWQsXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgY3JpbXNvbjogMHhkYzE0M2MsXG4gIGN5YW46IDB4MDBmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGIsXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgZGFya2dyZXk6IDB4YTlhOWE5LFxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICBkYXJrcmVkOiAweDhiMDAwMCxcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxuICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjIsXG4gIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyLFxuICBmdWNoc2lhOiAweGZmMDBmZixcbiAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwLFxuICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICBncmF5OiAweDgwODA4MCxcbiAgZ3JlZW46IDB4MDA4MDAwLFxuICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gIGdyZXk6IDB4ODA4MDgwLFxuICBob25leWRldzogMHhmMGZmZjAsXG4gIGhvdHBpbms6IDB4ZmY2OWI0LFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjLFxuICBpbmRpZ286IDB4NGIwMDgyLFxuICBpdm9yeTogMHhmZmZmZjAsXG4gIGtoYWtpOiAweGYwZTY4YyxcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgbGF3bmdyZWVuOiAweDdjZmMwMCxcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODAsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgbGlnaHRncmF5OiAweGQzZDNkMyxcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gIGxpZ2h0cGluazogMHhmZmI2YzEsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmEsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGUsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgbGltZTogMHgwMGZmMDAsXG4gIGxpbWVncmVlbjogMHgzMmNkMzIsXG4gIGxpbmVuOiAweGZhZjBlNixcbiAgbWFnZW50YTogMHhmZjAwZmYsXG4gIG1hcm9vbjogMHg4MDAwMDAsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkMyxcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODUsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTEsXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICBuYXZ5OiAweDAwMDA4MCxcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gIG9saXZlOiAweDgwODAwMCxcbiAgb2xpdmVkcmFiOiAweDZiOGUyMyxcbiAgb3JhbmdlOiAweGZmYTUwMCxcbiAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgb3JjaGlkOiAweGRhNzBkNixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gIHBlYWNocHVmZjogMHhmZmRhYjksXG4gIHBlcnU6IDB4Y2Q4NTNmLFxuICBwaW5rOiAweGZmYzBjYixcbiAgcGx1bTogMHhkZGEwZGQsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICBwdXJwbGU6IDB4ODAwMDgwLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OSxcbiAgcmVkOiAweGZmMDAwMCxcbiAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgcm95YWxibHVlOiAweDQxNjllMSxcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICBzYWxtb246IDB4ZmE4MDcyLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MCxcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gIHNpZW5uYTogMHhhMDUyMmQsXG4gIHNpbHZlcjogMHhjMGMwYzAsXG4gIHNreWJsdWU6IDB4ODdjZWViLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICBzbm93OiAweGZmZmFmYSxcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICB0YW46IDB4ZDJiNDhjLFxuICB0ZWFsOiAweDAwODA4MCxcbiAgdGhpc3RsZTogMHhkOGJmZDgsXG4gIHRvbWF0bzogMHhmZjYzNDcsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gIHZpb2xldDogMHhlZTgyZWUsXG4gIHdoZWF0OiAweGY1ZGViMyxcbiAgd2hpdGU6IDB4ZmZmZmZmLFxuICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgeWVsbG93OiAweGZmZmYwMCxcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG59O1xuXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XG4gIGNvcHkoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGNvbG9yX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBjb2xvcl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhleDg6IGNvbG9yX2Zvcm1hdEhleDgsXG4gIGZvcm1hdEhzbDogY29sb3JfZm9ybWF0SHNsLFxuICBmb3JtYXRSZ2I6IGNvbG9yX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IGNvbG9yX2Zvcm1hdFJnYlxufSk7XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleDgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleDgoKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0SHNsKCkge1xuICByZXR1cm4gaHNsQ29udmVydCh0aGlzKS5mb3JtYXRIc2woKTtcbn1cblxuZnVuY3Rpb24gY29sb3JfZm9ybWF0UmdiKCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRSZ2IoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gIHZhciBtLCBsO1xuICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAobSA9IHJlSGV4LmV4ZWMoZm9ybWF0KSkgPyAobCA9IG1bMV0ubGVuZ3RoLCBtID0gcGFyc2VJbnQobVsxXSwgMTYpLCBsID09PSA2ID8gcmdibihtKSAvLyAjZmYwMDAwXG4gICAgICA6IGwgPT09IDMgPyBuZXcgUmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpIC8vICNmMDBcbiAgICAgIDogbCA9PT0gOCA/IHJnYmEobSA+PiAyNCAmIDB4ZmYsIG0gPj4gMTYgJiAweGZmLCBtID4+IDggJiAweGZmLCAobSAmIDB4ZmYpIC8gMHhmZikgLy8gI2ZmMDAwMDAwXG4gICAgICA6IGwgPT09IDQgPyByZ2JhKChtID4+IDEyICYgMHhmKSB8IChtID4+IDggJiAweGYwKSwgKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKCgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZikpIC8gMHhmZikgLy8gI2YwMDBcbiAgICAgIDogbnVsbCkgLy8gaW52YWxpZCBoZXhcbiAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcbiAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgMSkgLy8gcmdiKDEwMCUsIDAlLCAwJSlcbiAgICAgIDogKG0gPSByZVJnYmFJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pIC8vIHJnYmEoMjU1LCAwLCAwLCAxKVxuICAgICAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcbiAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgMSkgLy8gaHNsKDEyMCwgNTAlLCA1MCUpXG4gICAgICA6IChtID0gcmVIc2xhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCBtWzRdKSAvLyBoc2xhKDEyMCwgNTAlLCA1MCUsIDEpXG4gICAgICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICA6IGZvcm1hdCA9PT0gXCJ0cmFuc3BhcmVudFwiID8gbmV3IFJnYihOYU4sIE5hTiwgTmFOLCAwKVxuICAgICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiByZ2JuKG4pIHtcbiAgcmV0dXJuIG5ldyBSZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmLCAxKTtcbn1cblxuZnVuY3Rpb24gcmdiYShyLCBnLCBiLCBhKSB7XG4gIGlmIChhIDw9IDApIHIgPSBnID0gYiA9IE5hTjtcbiAgcmV0dXJuIG5ldyBSZ2IociwgZywgYiwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5yID0gK3I7XG4gIHRoaXMuZyA9ICtnO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShSZ2IsIHJnYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNsYW1wKCkge1xuICAgIHJldHVybiBuZXcgUmdiKGNsYW1waSh0aGlzLnIpLCBjbGFtcGkodGhpcy5nKSwgY2xhbXBpKHRoaXMuYiksIGNsYW1wYSh0aGlzLm9wYWNpdHkpKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuICgtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5nICYmIHRoaXMuZyA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogcmdiX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiByZ2JfZm9ybWF0SGV4LFxuICBmb3JtYXRIZXg4OiByZ2JfZm9ybWF0SGV4OCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gYCMke2hleCh0aGlzLnIpfSR7aGV4KHRoaXMuZyl9JHtoZXgodGhpcy5iKX1gO1xufVxuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4OCgpIHtcbiAgcmV0dXJuIGAjJHtoZXgodGhpcy5yKX0ke2hleCh0aGlzLmcpfSR7aGV4KHRoaXMuYil9JHtoZXgoKGlzTmFOKHRoaXMub3BhY2l0eSkgPyAxIDogdGhpcy5vcGFjaXR5KSAqIDI1NSl9YDtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdFJnYigpIHtcbiAgY29uc3QgYSA9IGNsYW1wYSh0aGlzLm9wYWNpdHkpO1xuICByZXR1cm4gYCR7YSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwifSR7Y2xhbXBpKHRoaXMucil9LCAke2NsYW1waSh0aGlzLmcpfSwgJHtjbGFtcGkodGhpcy5iKX0ke2EgPT09IDEgPyBcIilcIiA6IGAsICR7YX0pYH1gO1xufVxuXG5mdW5jdGlvbiBjbGFtcGEob3BhY2l0eSkge1xuICByZXR1cm4gaXNOYU4ob3BhY2l0eSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgb3BhY2l0eSkpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGkodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xufVxuXG5mdW5jdGlvbiBoZXgodmFsdWUpIHtcbiAgdmFsdWUgPSBjbGFtcGkodmFsdWUpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBjbGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IEhzbChjbGFtcGgodGhpcy5oKSwgY2xhbXB0KHRoaXMucyksIGNsYW1wdCh0aGlzLmwpLCBjbGFtcGEodGhpcy5vcGFjaXR5KSk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBmb3JtYXRIc2woKSB7XG4gICAgY29uc3QgYSA9IGNsYW1wYSh0aGlzLm9wYWNpdHkpO1xuICAgIHJldHVybiBgJHthID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCJ9JHtjbGFtcGgodGhpcy5oKX0sICR7Y2xhbXB0KHRoaXMucykgKiAxMDB9JSwgJHtjbGFtcHQodGhpcy5sKSAqIDEwMH0lJHthID09PSAxID8gXCIpXCIgOiBgLCAke2F9KWB9YDtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiBjbGFtcGgodmFsdWUpIHtcbiAgdmFsdWUgPSAodmFsdWUgfHwgMCkgJSAzNjA7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyB2YWx1ZSArIDM2MCA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjbGFtcHQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbHVlIHx8IDApKTtcbn1cblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG4gIHJldHVybiBwcm90b3R5cGU7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcbmltcG9ydCB7Q29sb3IsIHJnYkNvbnZlcnQsIFJnYn0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmltcG9ydCB7ZGVncmVlcywgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG4vLyBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL2xhYi1hbmQtcmdiXG5jb25zdCBLID0gMTgsXG4gICAgWG4gPSAwLjk2NDIyLFxuICAgIFluID0gMSxcbiAgICBabiA9IDAuODI1MjEsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIGhjbDJsYWIobyk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSByZ2IybHJnYihvLnIpLFxuICAgICAgZyA9IHJnYjJscmdiKG8uZyksXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIyMjUwNDUgKiByICsgMC43MTY4Nzg2ICogZyArIDAuMDYwNjE2OSAqIGIpIC8gWW4pLCB4LCB6O1xuICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB4ID0geiA9IHk7IGVsc2Uge1xuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xuICAgIHogPSB4eXoybGFiKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZyArIDAuNzE0MTczMyAqIGIpIC8gWm4pO1xuICB9XG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXkobCwgb3BhY2l0eSkge1xuICByZXR1cm4gbmV3IExhYihsLCAwLCAwLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2IoKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwIDwgby5sICYmIG8ubCA8IDEwMCA/IDAgOiBOYU4sIG8ubCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBNYXRoLmF0YW4yKG8uYiwgby5hKSAqIGRlZ3JlZXM7XG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmZ1bmN0aW9uIGhjbDJsYWIobykge1xuICBpZiAoaXNOYU4oby5oKSkgcmV0dXJuIG5ldyBMYWIoby5sLCAwLCAwLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IG8uaCAqIHJhZGlhbnM7XG4gIHJldHVybiBuZXcgTGFiKG8ubCwgTWF0aC5jb3MoaCkgKiBvLmMsIE1hdGguc2luKGgpICogby5jLCBvLm9wYWNpdHkpO1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHJldHVybiBoY2wybGFiKHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG4iLCJleHBvcnQgY29uc3QgcmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgY29uc3QgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogKCkgPT4ge319O1xuXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykgfHwgL1tcXHMuXS8udGVzdCh0KSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsImltcG9ydCB7c2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgbm9ldmVudCwge25vbnBhc3NpdmVjYXB0dXJlfSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIG5vbnBhc3NpdmVjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHllc2RyYWcodmlldywgbm9jbGljaykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XG4gIGlmIChub2NsaWNrKSB7XG4gICAgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG4iLCIvLyBUaGVzZSBhcmUgdHlwaWNhbGx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBub2V2ZW50IHRvIGVuc3VyZSB0aGF0IHdlIGNhblxuLy8gcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50LlxuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmUgPSB7cGFzc2l2ZTogZmFsc2V9O1xuZXhwb3J0IGNvbnN0IG5vbnBhc3NpdmVjYXB0dXJlID0ge2NhcHR1cmU6IHRydWUsIHBhc3NpdmU6IGZhbHNlfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiaW1wb3J0IGRzdiBmcm9tIFwiLi9kc3YuanNcIjtcblxudmFyIGNzdiA9IGRzdihcIixcIik7XG5cbmV4cG9ydCB2YXIgY3N2UGFyc2UgPSBjc3YucGFyc2U7XG5leHBvcnQgdmFyIGNzdlBhcnNlUm93cyA9IGNzdi5wYXJzZVJvd3M7XG5leHBvcnQgdmFyIGNzdkZvcm1hdCA9IGNzdi5mb3JtYXQ7XG5leHBvcnQgdmFyIGNzdkZvcm1hdEJvZHkgPSBjc3YuZm9ybWF0Qm9keTtcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Um93cyA9IGNzdi5mb3JtYXRSb3dzO1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRSb3cgPSBjc3YuZm9ybWF0Um93O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRWYWx1ZSA9IGNzdi5mb3JtYXRWYWx1ZTtcbiIsInZhciBFT0wgPSB7fSxcbiAgICBFT0YgPSB7fSxcbiAgICBRVU9URSA9IDM0LFxuICAgIE5FV0xJTkUgPSAxMCxcbiAgICBSRVRVUk4gPSAxMztcblxuZnVuY3Rpb24gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpIHtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgY29sdW1ucy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXSB8fCBcXFwiXFxcIlwiO1xuICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbn1cblxuZnVuY3Rpb24gY3VzdG9tQ29udmVydGVyKGNvbHVtbnMsIGYpIHtcbiAgdmFyIG9iamVjdCA9IG9iamVjdENvbnZlcnRlcihjb2x1bW5zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgIHJldHVybiBmKG9iamVjdChyb3cpLCBpLCBjb2x1bW5zKTtcbiAgfTtcbn1cblxuLy8gQ29tcHV0ZSB1bmlxdWUgY29sdW1ucyBpbiBvcmRlciBvZiBkaXNjb3ZlcnkuXG5mdW5jdGlvbiBpbmZlckNvbHVtbnMocm93cykge1xuICB2YXIgY29sdW1uU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGNvbHVtbnMgPSBbXTtcblxuICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgZm9yICh2YXIgY29sdW1uIGluIHJvdykge1xuICAgICAgaWYgKCEoY29sdW1uIGluIGNvbHVtblNldCkpIHtcbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtblNldFtjb2x1bW5dID0gY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb2x1bW5zO1xufVxuXG5mdW5jdGlvbiBwYWQodmFsdWUsIHdpZHRoKSB7XG4gIHZhciBzID0gdmFsdWUgKyBcIlwiLCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbigwKSArIHMgOiBzO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRZZWFyKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgPCAwID8gXCItXCIgKyBwYWQoLXllYXIsIDYpXG4gICAgOiB5ZWFyID4gOTk5OSA/IFwiK1wiICsgcGFkKHllYXIsIDYpXG4gICAgOiBwYWQoeWVhciwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCksXG4gICAgICBtaW51dGVzID0gZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICBzZWNvbmRzID0gZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBcIkludmFsaWQgRGF0ZVwiXG4gICAgICA6IGZvcm1hdFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0KSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gICAgICArIChtaWxsaXNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCIuXCIgKyBwYWQobWlsbGlzZWNvbmRzLCAzKSArIFwiWlwiXG4gICAgICA6IHNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCJaXCJcbiAgICAgIDogbWludXRlcyB8fCBob3VycyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCJaXCJcbiAgICAgIDogXCJcIik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSxcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgIGNvbHVtbnMgPSByb3csIGNvbnZlcnQgPSBmID8gY3VzdG9tQ29udmVydGVyKHJvdywgZikgOiBvYmplY3RDb252ZXJ0ZXIocm93KTtcbiAgICB9KTtcbiAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICB0LCAvLyBjdXJyZW50IHRva2VuXG4gICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cblxuICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTikgLS1OO1xuXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICBpZiAoZW9mKSByZXR1cm4gRU9GO1xuICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG5cbiAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgIHZhciBpLCBqID0gSSwgYztcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKTtcbiAgICAgICAgaWYgKChpID0gSSkgPj0gTikgZW9mID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkgLSAxKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lLlxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICB2YXIgcm93ID0gW107XG4gICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikgcm93LnB1c2godCksIHQgPSB0b2tlbigpO1xuICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3dzKHJvd3MpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIlxuICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGZvcm1hdERhdGUodmFsdWUpXG4gICAgICAgIDogcmVGb3JtYXQudGVzdCh2YWx1ZSArPSBcIlwiKSA/IFwiXFxcIlwiICsgdmFsdWUucmVwbGFjZSgvXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiXG4gICAgICAgIDogdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRCb2R5OiBmb3JtYXRCb2R5LFxuICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3MsXG4gICAgZm9ybWF0Um93OiBmb3JtYXRSb3csXG4gICAgZm9ybWF0VmFsdWU6IGZvcm1hdFZhbHVlXG4gIH07XG59XG4iLCJpbXBvcnQgZHN2IGZyb20gXCIuL2Rzdi5qc1wiO1xuXG52YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG5leHBvcnQgdmFyIHRzdlBhcnNlID0gdHN2LnBhcnNlO1xuZXhwb3J0IHZhciB0c3ZQYXJzZVJvd3MgPSB0c3YucGFyc2VSb3dzO1xuZXhwb3J0IHZhciB0c3ZGb3JtYXQgPSB0c3YuZm9ybWF0O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRCb2R5ID0gdHN2LmZvcm1hdEJvZHk7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFJvd3MgPSB0c3YuZm9ybWF0Um93cztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Um93ID0gdHN2LmZvcm1hdFJvdztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0VmFsdWUgPSB0c3YuZm9ybWF0VmFsdWU7XG4iLCJleHBvcnQgZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbn1cbiIsImltcG9ydCB7Y3N2UGFyc2UsIGRzdkZvcm1hdCwgdHN2UGFyc2V9IGZyb20gXCJkMy1kc3ZcIjtcbmltcG9ydCB0ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcblxuZnVuY3Rpb24gZHN2UGFyc2UocGFyc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpbml0LCByb3cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgaW5pdCA9PT0gXCJmdW5jdGlvblwiKSByb3cgPSBpbml0LCBpbml0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcGFyc2UocmVzcG9uc2UsIHJvdyk7XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRzdihkZWxpbWl0ZXIsIGlucHV0LCBpbml0LCByb3cpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgdmFyIGZvcm1hdCA9IGRzdkZvcm1hdChkZWxpbWl0ZXIpO1xuICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHJldHVybiBmb3JtYXQucGFyc2UocmVzcG9uc2UsIHJvdyk7XG4gIH0pO1xufVxuXG5leHBvcnQgdmFyIGNzdiA9IGRzdlBhcnNlKGNzdlBhcnNlKTtcbmV4cG9ydCB2YXIgdHN2ID0gZHN2UGFyc2UodHN2UGFyc2UpO1xuIiwiZnVuY3Rpb24gcmVzcG9uc2VKc29uKHJlc3BvbnNlKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDUpIHJldHVybjtcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlSnNvbik7XG59XG4iLCJmdW5jdGlvbiByZXNwb25zZVRleHQocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBmZXRjaChpbnB1dCwgaW5pdCkudGhlbihyZXNwb25zZVRleHQpO1xufVxuIiwiaW1wb3J0IHtxdWFkdHJlZX0gZnJvbSBcImQzLXF1YWR0cmVlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBqaWdnbGUgZnJvbSBcIi4vamlnZ2xlLmpzXCI7XG5cbmZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZC54ICsgZC52eDtcbn1cblxuZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnkgKyBkLnZ5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgcmFkaWksXG4gICAgICByYW5kb20sXG4gICAgICBzdHJlbmd0aCA9IDEsXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudChyYWRpdXMgPT0gbnVsbCA/IDEgOiArcmFkaXVzKTtcblxuICBmdW5jdGlvbiBmb3JjZSgpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgeGksXG4gICAgICAgIHlpLFxuICAgICAgICByaSxcbiAgICAgICAgcmkyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIHRyZWUgPSBxdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihwcmVwYXJlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICByaSA9IHJhZGlpW25vZGUuaW5kZXhdLCByaTIgPSByaSAqIHJpO1xuICAgICAgICB4aSA9IG5vZGUueCArIG5vZGUudng7XG4gICAgICAgIHlpID0gbm9kZS55ICsgbm9kZS52eTtcbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIHZhciBkYXRhID0gcXVhZC5kYXRhLCByaiA9IHF1YWQuciwgciA9IHJpICsgcmo7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pbmRleCA+IG5vZGUuaW5kZXgpIHtcbiAgICAgICAgICB2YXIgeCA9IHhpIC0gZGF0YS54IC0gZGF0YS52eCxcbiAgICAgICAgICAgICAgeSA9IHlpIC0gZGF0YS55IC0gZGF0YS52eSxcbiAgICAgICAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgICAgaWYgKGwgPCByICogcikge1xuICAgICAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUocmFuZG9tKSwgbCArPSB4ICogeDtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geSAqIHk7XG4gICAgICAgICAgICBsID0gKHIgLSAobCA9IE1hdGguc3FydChsKSkpIC8gbCAqIHN0cmVuZ3RoO1xuICAgICAgICAgICAgbm9kZS52eCArPSAoeCAqPSBsKSAqIChyID0gKHJqICo9IHJqKSAvIChyaTIgKyByaikpO1xuICAgICAgICAgICAgbm9kZS52eSArPSAoeSAqPSBsKSAqIHI7XG4gICAgICAgICAgICBkYXRhLnZ4IC09IHggKiAociA9IDEgLSByKTtcbiAgICAgICAgICAgIGRhdGEudnkgLT0geSAqIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4MCA+IHhpICsgciB8fCB4MSA8IHhpIC0gciB8fCB5MCA+IHlpICsgciB8fCB5MSA8IHlpIC0gcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlKHF1YWQpIHtcbiAgICBpZiAocXVhZC5kYXRhKSByZXR1cm4gcXVhZC5yID0gcmFkaWlbcXVhZC5kYXRhLmluZGV4XTtcbiAgICBmb3IgKHZhciBpID0gcXVhZC5yID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKHF1YWRbaV0gJiYgcXVhZFtpXS5yID4gcXVhZC5yKSB7XG4gICAgICAgIHF1YWQuciA9IHF1YWRbaV0ucjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICByYWRpaSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHJhZGlpW25vZGUuaW5kZXhdID0gK3JhZGl1cyhub2RlLCBpLCBub2Rlcyk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oX25vZGVzLCBfcmFuZG9tKSB7XG4gICAgbm9kZXMgPSBfbm9kZXM7XG4gICAgcmFuZG9tID0gX3JhbmRvbTtcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHJhZGl1cztcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmRvbSkge1xuICByZXR1cm4gKHJhbmRvbSgpIC0gMC41KSAqIDFlLTY7XG59XG4iLCIvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvciNQYXJhbWV0ZXJzX2luX2NvbW1vbl91c2VcbmNvbnN0IGEgPSAxNjY0NTI1O1xuY29uc3QgYyA9IDEwMTM5MDQyMjM7XG5jb25zdCBtID0gNDI5NDk2NzI5NjsgLy8gMl4zMlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgbGV0IHMgPSAxO1xuICByZXR1cm4gKCkgPT4gKHMgPSAoYSAqIHMgKyBjKSAlIG0pIC8gbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lcn0gZnJvbSBcImQzLXRpbWVyXCI7XG5pbXBvcnQgbGNnIGZyb20gXCIuL2xjZy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLng7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueTtcbn1cblxudmFyIGluaXRpYWxSYWRpdXMgPSAxMCxcbiAgICBpbml0aWFsQW5nbGUgPSBNYXRoLlBJICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2Rlcykge1xuICB2YXIgc2ltdWxhdGlvbixcbiAgICAgIGFscGhhID0gMSxcbiAgICAgIGFscGhhTWluID0gMC4wMDEsXG4gICAgICBhbHBoYURlY2F5ID0gMSAtIE1hdGgucG93KGFscGhhTWluLCAxIC8gMzAwKSxcbiAgICAgIGFscGhhVGFyZ2V0ID0gMCxcbiAgICAgIHZlbG9jaXR5RGVjYXkgPSAwLjYsXG4gICAgICBmb3JjZXMgPSBuZXcgTWFwKCksXG4gICAgICBzdGVwcGVyID0gdGltZXIoc3RlcCksXG4gICAgICBldmVudCA9IGRpc3BhdGNoKFwidGlja1wiLCBcImVuZFwiKSxcbiAgICAgIHJhbmRvbSA9IGxjZygpO1xuXG4gIGlmIChub2RlcyA9PSBudWxsKSBub2RlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgdGljaygpO1xuICAgIGV2ZW50LmNhbGwoXCJ0aWNrXCIsIHNpbXVsYXRpb24pO1xuICAgIGlmIChhbHBoYSA8IGFscGhhTWluKSB7XG4gICAgICBzdGVwcGVyLnN0b3AoKTtcbiAgICAgIGV2ZW50LmNhbGwoXCJlbmRcIiwgc2ltdWxhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGljayhpdGVyYXRpb25zKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG5cbiAgICBpZiAoaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkKSBpdGVyYXRpb25zID0gMTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICBhbHBoYSArPSAoYWxwaGFUYXJnZXQgLSBhbHBoYSkgKiBhbHBoYURlY2F5O1xuXG4gICAgICBmb3JjZXMuZm9yRWFjaChmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBmb3JjZShhbHBoYSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmZ4ID09IG51bGwpIG5vZGUueCArPSBub2RlLnZ4ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS54ID0gbm9kZS5meCwgbm9kZS52eCA9IDA7XG4gICAgICAgIGlmIChub2RlLmZ5ID09IG51bGwpIG5vZGUueSArPSBub2RlLnZ5ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS55ID0gbm9kZS5meSwgbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbXVsYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZXMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS5pbmRleCA9IGk7XG4gICAgICBpZiAobm9kZS5meCAhPSBudWxsKSBub2RlLnggPSBub2RlLmZ4O1xuICAgICAgaWYgKG5vZGUuZnkgIT0gbnVsbCkgbm9kZS55ID0gbm9kZS5meTtcbiAgICAgIGlmIChpc05hTihub2RlLngpIHx8IGlzTmFOKG5vZGUueSkpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGluaXRpYWxSYWRpdXMgKiBNYXRoLnNxcnQoMC41ICsgaSksIGFuZ2xlID0gaSAqIGluaXRpYWxBbmdsZTtcbiAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYU4obm9kZS52eCkgfHwgaXNOYU4obm9kZS52eSkpIHtcbiAgICAgICAgbm9kZS52eCA9IG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVGb3JjZShmb3JjZSkge1xuICAgIGlmIChmb3JjZS5pbml0aWFsaXplKSBmb3JjZS5pbml0aWFsaXplKG5vZGVzLCByYW5kb20pO1xuICAgIHJldHVybiBmb3JjZTtcbiAgfVxuXG4gIGluaXRpYWxpemVOb2RlcygpO1xuXG4gIHJldHVybiBzaW11bGF0aW9uID0ge1xuICAgIHRpY2s6IHRpY2ssXG5cbiAgICByZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnJlc3RhcnQoc3RlcCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIuc3RvcCgpLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBub2RlczogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZXMgPSBfLCBpbml0aWFsaXplTm9kZXMoKSwgZm9yY2VzLmZvckVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiBub2RlcztcbiAgICB9LFxuXG4gICAgYWxwaGE6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGE7XG4gICAgfSxcblxuICAgIGFscGhhTWluOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYU1pbiA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhTWluO1xuICAgIH0sXG5cbiAgICBhbHBoYURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYURlY2F5ID0gK18sIHNpbXVsYXRpb24pIDogK2FscGhhRGVjYXk7XG4gICAgfSxcblxuICAgIGFscGhhVGFyZ2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYVRhcmdldCA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhVGFyZ2V0O1xuICAgIH0sXG5cbiAgICB2ZWxvY2l0eURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2ZWxvY2l0eURlY2F5ID0gMSAtIF8sIHNpbXVsYXRpb24pIDogMSAtIHZlbG9jaXR5RGVjYXk7XG4gICAgfSxcblxuICAgIHJhbmRvbVNvdXJjZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZG9tID0gXywgZm9yY2VzLmZvckVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiByYW5kb207XG4gICAgfSxcblxuICAgIGZvcmNlOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoKF8gPT0gbnVsbCA/IGZvcmNlcy5kZWxldGUobmFtZSkgOiBmb3JjZXMuc2V0KG5hbWUsIGluaXRpYWxpemVGb3JjZShfKSkpLCBzaW11bGF0aW9uKSA6IGZvcmNlcy5nZXQobmFtZSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgZHgsXG4gICAgICAgICAgZHksXG4gICAgICAgICAgZDIsXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBjbG9zZXN0O1xuXG4gICAgICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICAgICAgZWxzZSByYWRpdXMgKj0gcmFkaXVzO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgZHggPSB4IC0gbm9kZS54O1xuICAgICAgICBkeSA9IHkgLSBub2RlLnk7XG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMiA8IHJhZGl1cykgY2xvc2VzdCA9IG5vZGUsIHJhZGl1cyA9IGQyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IChldmVudC5vbihuYW1lLCBfKSwgc2ltdWxhdGlvbikgOiBldmVudC5vbihuYW1lKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB4ejtcblxuICBpZiAodHlwZW9mIHggIT09IFwiZnVuY3Rpb25cIikgeCA9IGNvbnN0YW50KHggPT0gbnVsbCA/IDAgOiAreCk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ4ICs9ICh4eltpXSAtIG5vZGUueCkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeHogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeHpbaV0gPSAreChub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih5KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHl6O1xuXG4gIGlmICh0eXBlb2YgeSAhPT0gXCJmdW5jdGlvblwiKSB5ID0gY29uc3RhbnQoeSA9PSBudWxsID8gMCA6ICt5KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnkgKz0gKHl6W2ldIC0gbm9kZS55KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB5eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih5eltpXSA9ICt5KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGZvcm1hdExvY2FsZSBmcm9tIFwiLi9sb2NhbGUuanNcIjtcblxudmFyIGxvY2FsZTtcbmV4cG9ydCB2YXIgZm9ybWF0O1xuZXhwb3J0IHZhciBmb3JtYXRQcmVmaXg7XG5cbmRlZmF1bHRMb2NhbGUoe1xuICB0aG91c2FuZHM6IFwiLFwiLFxuICBncm91cGluZzogWzNdLFxuICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG4gIHJldHVybiBsb2NhbGU7XG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbFBhcnRzKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBNYXRoLmFicyh4ID0gTWF0aC5yb3VuZCh4KSkgPj0gMWUyMVxuICAgICAgPyB4LnRvTG9jYWxlU3RyaW5nKFwiZW5cIikucmVwbGFjZSgvLC9nLCBcIlwiKVxuICAgICAgOiB4LnRvU3RyaW5nKDEwKTtcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4vLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbFBhcnRzKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKSB7XG4gIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgcmV0dXJuIFtcbiAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICt4LnNsaWNlKGkgKyAxKVxuICBdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgIHQgPSBbXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG51bWVyYWxzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bMC05XS9nLCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gbnVtZXJhbHNbK2ldO1xuICAgIH0pO1xuICB9O1xufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IHZhciBwcmVmaXhFeHBvbmVudDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbFBhcnRzKHgsIE1hdGgubWF4KDAsIHAgKyBpIC0gMSkpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xufVxuIiwiLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt+XVt0eXBlXVxudmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLSggXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC5cXGQrKT8ofik/KFthLXolXSk/JC9pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcbiAgdmFyIG1hdGNoO1xuICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcih7XG4gICAgZmlsbDogbWF0Y2hbMV0sXG4gICAgYWxpZ246IG1hdGNoWzJdLFxuICAgIHNpZ246IG1hdGNoWzNdLFxuICAgIHN5bWJvbDogbWF0Y2hbNF0sXG4gICAgemVybzogbWF0Y2hbNV0sXG4gICAgd2lkdGg6IG1hdGNoWzZdLFxuICAgIGNvbW1hOiBtYXRjaFs3XSxcbiAgICBwcmVjaXNpb246IG1hdGNoWzhdICYmIG1hdGNoWzhdLnNsaWNlKDEpLFxuICAgIHRyaW06IG1hdGNoWzldLFxuICAgIHR5cGU6IG1hdGNoWzEwXVxuICB9KTtcbn1cblxuZm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZSA9IEZvcm1hdFNwZWNpZmllci5wcm90b3R5cGU7IC8vIGluc3RhbmNlb2ZcblxuZXhwb3J0IGZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgdGhpcy5maWxsID0gc3BlY2lmaWVyLmZpbGwgPT09IHVuZGVmaW5lZCA/IFwiIFwiIDogc3BlY2lmaWVyLmZpbGwgKyBcIlwiO1xuICB0aGlzLmFsaWduID0gc3BlY2lmaWVyLmFsaWduID09PSB1bmRlZmluZWQgPyBcIj5cIiA6IHNwZWNpZmllci5hbGlnbiArIFwiXCI7XG4gIHRoaXMuc2lnbiA9IHNwZWNpZmllci5zaWduID09PSB1bmRlZmluZWQgPyBcIi1cIiA6IHNwZWNpZmllci5zaWduICsgXCJcIjtcbiAgdGhpcy5zeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnN5bWJvbCArIFwiXCI7XG4gIHRoaXMuemVybyA9ICEhc3BlY2lmaWVyLnplcm87XG4gIHRoaXMud2lkdGggPSBzcGVjaWZpZXIud2lkdGggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIud2lkdGg7XG4gIHRoaXMuY29tbWEgPSAhIXNwZWNpZmllci5jb21tYTtcbiAgdGhpcy5wcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLnByZWNpc2lvbjtcbiAgdGhpcy50cmltID0gISFzcGVjaWZpZXIudHJpbTtcbiAgdGhpcy50eXBlID0gc3BlY2lmaWVyLnR5cGUgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIudHlwZSArIFwiXCI7XG59XG5cbkZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgKyB0aGlzLmFsaWduXG4gICAgICArIHRoaXMuc2lnblxuICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICsgKHRoaXMudHJpbSA/IFwiflwiIDogXCJcIilcbiAgICAgICsgdGhpcy50eXBlO1xufTtcbiIsIi8vIFRyaW1zIGluc2lnbmlmaWNhbnQgemVyb3MsIGUuZy4sIHJlcGxhY2VzIDEuMjAwMGsgd2l0aCAxLjJrLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocykge1xuICBvdXQ6IGZvciAodmFyIG4gPSBzLmxlbmd0aCwgaSA9IDEsIGkwID0gLTEsIGkxOyBpIDwgbjsgKytpKSB7XG4gICAgc3dpdGNoIChzW2ldKSB7XG4gICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICBjYXNlIFwiMFwiOiBpZiAoaTAgPT09IDApIGkwID0gaTsgaTEgPSBpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGlmICghK3NbaV0pIGJyZWFrIG91dDsgaWYgKGkwID4gMCkgaTAgPSAwOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkwID4gMCA/IHMuc2xpY2UoMCwgaTApICsgcy5zbGljZShpMSArIDEpIDogcztcbn1cbiIsImltcG9ydCBmb3JtYXREZWNpbWFsIGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcbmltcG9ydCBmb3JtYXRQcmVmaXhBdXRvIGZyb20gXCIuL2Zvcm1hdFByZWZpeEF1dG8uanNcIjtcbmltcG9ydCBmb3JtYXRSb3VuZGVkIGZyb20gXCIuL2Zvcm1hdFJvdW5kZWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBcIiVcIjogKHgsIHApID0+ICh4ICogMTAwKS50b0ZpeGVkKHApLFxuICBcImJcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMiksXG4gIFwiY1wiOiAoeCkgPT4geCArIFwiXCIsXG4gIFwiZFwiOiBmb3JtYXREZWNpbWFsLFxuICBcImVcIjogKHgsIHApID0+IHgudG9FeHBvbmVudGlhbChwKSxcbiAgXCJmXCI6ICh4LCBwKSA9PiB4LnRvRml4ZWQocCksXG4gIFwiZ1wiOiAoeCwgcCkgPT4geC50b1ByZWNpc2lvbihwKSxcbiAgXCJvXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDgpLFxuICBcInBcIjogKHgsIHApID0+IGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCksXG4gIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgXCJYXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLFxuICBcInhcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuaW1wb3J0IGZvcm1hdEdyb3VwIGZyb20gXCIuL2Zvcm1hdEdyb3VwLmpzXCI7XG5pbXBvcnQgZm9ybWF0TnVtZXJhbHMgZnJvbSBcIi4vZm9ybWF0TnVtZXJhbHMuanNcIjtcbmltcG9ydCBmb3JtYXRTcGVjaWZpZXIgZnJvbSBcIi4vZm9ybWF0U3BlY2lmaWVyLmpzXCI7XG5pbXBvcnQgZm9ybWF0VHJpbSBmcm9tIFwiLi9mb3JtYXRUcmltLmpzXCI7XG5pbXBvcnQgZm9ybWF0VHlwZXMgZnJvbSBcIi4vZm9ybWF0VHlwZXMuanNcIjtcbmltcG9ydCB7cHJlZml4RXhwb25lbnR9IGZyb20gXCIuL2Zvcm1hdFByZWZpeEF1dG8uanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG52YXIgbWFwID0gQXJyYXkucHJvdG90eXBlLm1hcCxcbiAgICBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGxvY2FsZSkge1xuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgPT09IHVuZGVmaW5lZCB8fCBsb2NhbGUudGhvdXNhbmRzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdEdyb3VwKG1hcC5jYWxsKGxvY2FsZS5ncm91cGluZywgTnVtYmVyKSwgbG9jYWxlLnRob3VzYW5kcyArIFwiXCIpLFxuICAgICAgY3VycmVuY3lQcmVmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMF0gKyBcIlwiLFxuICAgICAgY3VycmVuY3lTdWZmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMV0gKyBcIlwiLFxuICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsID09PSB1bmRlZmluZWQgPyBcIi5cIiA6IGxvY2FsZS5kZWNpbWFsICsgXCJcIixcbiAgICAgIG51bWVyYWxzID0gbG9jYWxlLm51bWVyYWxzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdE51bWVyYWxzKG1hcC5jYWxsKGxvY2FsZS5udW1lcmFscywgU3RyaW5nKSksXG4gICAgICBwZXJjZW50ID0gbG9jYWxlLnBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IFwiJVwiIDogbG9jYWxlLnBlcmNlbnQgKyBcIlwiLFxuICAgICAgbWludXMgPSBsb2NhbGUubWludXMgPT09IHVuZGVmaW5lZCA/IFwi4oiSXCIgOiBsb2NhbGUubWludXMgKyBcIlwiLFxuICAgICAgbmFuID0gbG9jYWxlLm5hbiA9PT0gdW5kZWZpbmVkID8gXCJOYU5cIiA6IGxvY2FsZS5uYW4gKyBcIlwiO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIpIHtcbiAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICB0cmltID0gc3BlY2lmaWVyLnRyaW0sXG4gICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIFRoZSBcIlwiIHR5cGUsIGFuZCBhbnkgaW52YWxpZCB0eXBlLCBpcyBhbiBhbGlhcyBmb3IgXCIuMTJ+Z1wiLlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgJiYgKHByZWNpc2lvbiA9IDEyKSwgdHJpbSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVByZWZpeCA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5U3VmZml4IDogL1slcF0vLnRlc3QodHlwZSkgPyBwZXJjZW50IDogXCJcIjtcblxuICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICBtYXliZVN1ZmZpeCA9IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IDZcbiAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgdmFsdWVTdWZmaXggPSBzdWZmaXgsXG4gICAgICAgICAgaSwgbiwgYztcblxuICAgICAgaWYgKHR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzaWduLiAtMCBpcyBub3QgbGVzcyB0aGFuIDAsIGJ1dCAxIC8gLTAgaXMhXG4gICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gdmFsdWUgPCAwIHx8IDEgLyB2YWx1ZSA8IDA7XG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICB2YWx1ZSA9IGlzTmFOKHZhbHVlKSA/IG5hbiA6IGZvcm1hdFR5cGUoTWF0aC5hYnModmFsdWUpLCBwcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIFRyaW0gaW5zaWduaWZpY2FudCB6ZXJvcy5cbiAgICAgICAgaWYgKHRyaW0pIHZhbHVlID0gZm9ybWF0VHJpbSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gSWYgYSBuZWdhdGl2ZSB2YWx1ZSByb3VuZHMgdG8gemVybyBhZnRlciBmb3JtYXR0aW5nLCBhbmQgbm8gZXhwbGljaXQgcG9zaXRpdmUgc2lnbiBpcyByZXF1ZXN0ZWQsIGhpZGUgdGhlIHNpZ24uXG4gICAgICAgIGlmICh2YWx1ZU5lZ2F0aXZlICYmICt2YWx1ZSA9PT0gMCAmJiBzaWduICE9PSBcIitcIikgdmFsdWVOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IG1pbnVzKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArIHZhbHVlU3VmZml4ICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI9XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJeXCI6IHZhbHVlID0gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHZhbHVlID0gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudW1lcmFscyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3BlY2lmaWVyICsgXCJcIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgdmFyIGYgPSBuZXdGb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzLFxuICAgICAgICBrID0gTWF0aC5wb3coMTAsIC1lKSxcbiAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmKGsgKiB2YWx1ZSkgKyBwcmVmaXg7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBuZXdGb3JtYXQsXG4gICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgfTtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGVwLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXAsIG1heCkge1xuICBzdGVwID0gTWF0aC5hYnMoc3RlcCksIG1heCA9IE1hdGguYWJzKG1heCkgLSBzdGVwO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQobWF4KSAtIGV4cG9uZW50KHN0ZXApKSArIDE7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIChpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXkgOiBnZW5lcmljQXJyYXkpKGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJpY0FycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYSksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxuICAgICAgICB2MSA9IHZhbHVlc1tpXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbaSArIDFdLFxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxuICAgICAgICB2MyA9IGkgPCBuIC0gMSA/IHZhbHVlc1tpICsgMl0gOiAyICogdjIgLSB2MTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jhc2lzfSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIHQgKiBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XG4gIHJldHVybiBhID0gTWF0aC5wb3coYSwgeSksIGIgPSBNYXRoLnBvdyhiLCB5KSAtIGEsIHkgPSAxIC8geSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhhICsgdCAqIGIsIHkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVlKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICogKDEgLSB0KSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cbiIsImltcG9ydCB7bGFiIGFzIGNvbG9yTGFifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIoc3RhcnQsIGVuZCkge1xuICB2YXIgbCA9IGNvbG9yKChzdGFydCA9IGNvbG9yTGFiKHN0YXJ0KSkubCwgKGVuZCA9IGNvbG9yTGFiKGVuZCkpLmwpLFxuICAgICAgYSA9IGNvbG9yKHN0YXJ0LmEsIGVuZC5hKSxcbiAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgIHN0YXJ0LmEgPSBhKHQpO1xuICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICBpZiAoIWIpIGIgPSBbXTtcbiAgdmFyIG4gPSBhID8gTWF0aC5taW4oYi5sZW5ndGgsIGEubGVuZ3RoKSA6IDAsXG4gICAgICBjID0gYi5zbGljZSgpLFxuICAgICAgaTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjW2ldID0gYVtpXSAqICgxIC0gdCkgKyBiW2ldICogdDtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoeCkge1xuICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmICEoeCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cbiIsImltcG9ydCB2YWx1ZSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0ge30sXG4gICAgICBjID0ge30sXG4gICAgICBrO1xuXG4gIGlmIChhID09PSBudWxsIHx8IHR5cGVvZiBhICE9PSBcIm9iamVjdFwiKSBhID0ge307XG4gIGlmIChiID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKSBiID0ge307XG5cbiAgZm9yIChrIGluIGIpIHtcbiAgICBpZiAoayBpbiBhKSB7XG4gICAgICBpW2tdID0gdmFsdWUoYVtrXSwgYltrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNba10gPSBiW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuIiwiaW1wb3J0IHtkZWZhdWx0IGFzIHZhbHVlfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHZhbHVlcyA9IGludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSA9IHZhbHVlO1xuICB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMSwgdiA9IHZhbHVlc1swXSwgSSA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBJW2ldID0gaW50ZXJwb2xhdGUodiwgdiA9IHZhbHVlc1srK2ldKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKj0gbikpKTtcbiAgICByZXR1cm4gSVtpXSh0IC0gaSk7XG4gIH07XG59XG4iLCJpbXBvcnQge3JnYiBhcyBjb2xvclJnYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgYmFzaXMgZnJvbSBcIi4vYmFzaXMuanNcIjtcbmltcG9ydCBiYXNpc0Nsb3NlZCBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuaW1wb3J0IG5vZ2FtbWEsIHtnYW1tYX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcbiAgdmFyIGNvbG9yID0gZ2FtbWEoeSk7XG5cbiAgZnVuY3Rpb24gcmdiKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGNvbG9yKChzdGFydCA9IGNvbG9yUmdiKHN0YXJ0KSkuciwgKGVuZCA9IGNvbG9yUmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3Ioc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYjtcbn0pKDEpO1xuXG5mdW5jdGlvbiByZ2JTcGxpbmUoc3BsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICB2YXIgbiA9IGNvbG9ycy5sZW5ndGgsXG4gICAgICAgIHIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGksIGNvbG9yO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbG9yID0gY29sb3JSZ2IoY29sb3JzW2ldKTtcbiAgICAgIHJbaV0gPSBjb2xvci5yIHx8IDA7XG4gICAgICBnW2ldID0gY29sb3IuZyB8fCAwO1xuICAgICAgYltpXSA9IGNvbG9yLmIgfHwgMDtcbiAgICB9XG4gICAgciA9IHNwbGluZShyKTtcbiAgICBnID0gc3BsaW5lKGcpO1xuICAgIGIgPSBzcGxpbmUoYik7XG4gICAgY29sb3Iub3BhY2l0eSA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbG9yLnIgPSByKHQpO1xuICAgICAgY29sb3IuZyA9IGcodCk7XG4gICAgICBjb2xvci5iID0gYih0KTtcbiAgICAgIHJldHVybiBjb2xvciArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyk7XG5leHBvcnQgdmFyIHJnYkJhc2lzQ2xvc2VkID0gcmdiU3BsaW5lKGJhc2lzQ2xvc2VkKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSAqICgxIC0gdCkgKyBiICogdCk7XG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLFxuICAgIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYmkgPSByZUEubGFzdEluZGV4ID0gcmVCLmxhc3RJbmRleCA9IDAsIC8vIHNjYW4gaW5kZXggZm9yIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcbiAgICAgIGJtLCAvLyBjdXJyZW50IG1hdGNoIGluIGJcbiAgICAgIGJzLCAvLyBzdHJpbmcgcHJlY2VkaW5nIGN1cnJlbnQgbnVtYmVyIGluIGIsIGlmIGFueVxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXG4gICAgICBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuXG4gIC8vIENvZXJjZSBpbnB1dHMgdG8gc3RyaW5ncy5cbiAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG5cbiAgLy8gSW50ZXJwb2xhdGUgcGFpcnMgb2YgbnVtYmVycyBpbiBhICYgYi5cbiAgd2hpbGUgKChhbSA9IHJlQS5leGVjKGEpKVxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7IC8vIGEgc3RyaW5nIHByZWNlZGVzIHRoZSBuZXh0IG51bWJlciBpbiBiXG4gICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBibTtcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgIHEucHVzaCh7aTogaSwgeDogbnVtYmVyKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufVxuIiwidmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgc2NhbGVYLCBzY2FsZVksIHNrZXdYO1xuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XG4gIGlmIChza2V3WCA9IGEgKiBjICsgYiAqIGQpIGMgLT0gYSAqIHNrZXdYLCBkIC09IGIgKiBza2V3WDtcbiAgaWYgKHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSkgYyAvPSBzY2FsZVksIGQgLz0gc2NhbGVZLCBza2V3WCAvPSBzY2FsZVk7XG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRlWDogZSxcbiAgICB0cmFuc2xhdGVZOiBmLFxuICAgIHJvdGF0ZTogTWF0aC5hdGFuMihiLCBhKSAqIGRlZ3JlZXMsXG4gICAgc2tld1g6IE1hdGguYXRhbihza2V3WCkgKiBkZWdyZWVzLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXIuanNcIjtcbmltcG9ydCB7cGFyc2VDc3MsIHBhcnNlU3ZnfSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZUNzcywgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuIiwiaW1wb3J0IGRlY29tcG9zZSwge2lkZW50aXR5fSBmcm9tIFwiLi9kZWNvbXBvc2UuanNcIjtcblxudmFyIHN2Z05vZGU7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDc3ModmFsdWUpIHtcbiAgY29uc3QgbSA9IG5ldyAodHlwZW9mIERPTU1hdHJpeCA9PT0gXCJmdW5jdGlvblwiID8gRE9NTWF0cml4IDogV2ViS2l0Q1NTTWF0cml4KSh2YWx1ZSArIFwiXCIpO1xuICByZXR1cm4gbS5pc0lkZW50aXR5ID8gaWRlbnRpdHkgOiBkZWNvbXBvc2UobS5hLCBtLmIsIG0uYywgbS5kLCBtLmUsIG0uZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gZGVjb21wb3NlKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgcmdiIGZyb20gXCIuL3JnYi5qc1wiO1xuaW1wb3J0IHtnZW5lcmljQXJyYXl9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgZGF0ZSBmcm9tIFwiLi9kYXRlLmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuaW1wb3J0IG9iamVjdCBmcm9tIFwiLi9vYmplY3QuanNcIjtcbmltcG9ydCBzdHJpbmcgZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIHQgPSB0eXBlb2YgYiwgYztcbiAgcmV0dXJuIGIgPT0gbnVsbCB8fCB0ID09PSBcImJvb2xlYW5cIiA/IGNvbnN0YW50KGIpXG4gICAgICA6ICh0ID09PSBcIm51bWJlclwiID8gbnVtYmVyXG4gICAgICA6IHQgPT09IFwic3RyaW5nXCIgPyAoKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIHJnYikgOiBzdHJpbmcpXG4gICAgICA6IGIgaW5zdGFuY2VvZiBjb2xvciA/IHJnYlxuICAgICAgOiBiIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVcbiAgICAgIDogaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5XG4gICAgICA6IEFycmF5LmlzQXJyYXkoYikgPyBnZW5lcmljQXJyYXlcbiAgICAgIDogdHlwZW9mIGIudmFsdWVPZiAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiLnRvU3RyaW5nICE9PSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4oYikgPyBvYmplY3RcbiAgICAgIDogbnVtYmVyKShhLCBiKTtcbn1cbiIsInZhciBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gem9vbVJobyhyaG8sIHJobzIsIHJobzQpIHtcblxuICAvLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4gIC8vIHAxID0gW3V4MSwgdXkxLCB3MV1cbiAgZnVuY3Rpb24gem9vbShwMCwgcDEpIHtcbiAgICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLFxuICAgICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgICBkeSA9IHV5MSAtIHV5MCxcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgICAgaSxcbiAgICAgICAgUztcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICAgIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHQgKiBkeCxcbiAgICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpLmR1cmF0aW9uID0gUyAqIDEwMDAgKiByaG8gLyBNYXRoLlNRUlQyO1xuXG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICB6b29tLnJobyA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgXzEgPSBNYXRoLm1heCgxZS0zLCArXyksIF8yID0gXzEgKiBfMSwgXzQgPSBfMiAqIF8yO1xuICAgIHJldHVybiB6b29tUmhvKF8xLCBfMiwgXzQpO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufSkoTWF0aC5TUVJUMiwgMiwgNCk7XG4iLCJjb25zdCBwaSA9IE1hdGguUEksXG4gICAgdGF1ID0gMiAqIHBpLFxuICAgIGVwc2lsb24gPSAxZS02LFxuICAgIHRhdUVwc2lsb24gPSB0YXUgLSBlcHNpbG9uO1xuXG5mdW5jdGlvbiBhcHBlbmQoc3RyaW5ncykge1xuICB0aGlzLl8gKz0gc3RyaW5nc1swXTtcbiAgZm9yIChsZXQgaSA9IDEsIG4gPSBzdHJpbmdzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHRoaXMuXyArPSBhcmd1bWVudHNbaV0gKyBzdHJpbmdzW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFJvdW5kKGRpZ2l0cykge1xuICBsZXQgZCA9IE1hdGguZmxvb3IoZGlnaXRzKTtcbiAgaWYgKCEoZCA+PSAwKSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpZ2l0czogJHtkaWdpdHN9YCk7XG4gIGlmIChkID4gMTUpIHJldHVybiBhcHBlbmQ7XG4gIGNvbnN0IGsgPSAxMCAqKiBkO1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5ncykge1xuICAgIHRoaXMuXyArPSBzdHJpbmdzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxLCBuID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHRoaXMuXyArPSBNYXRoLnJvdW5kKGFyZ3VtZW50c1tpXSAqIGspIC8gayArIHN0cmluZ3NbaV07XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKGRpZ2l0cykge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICAgIHRoaXMuXyA9IFwiXCI7XG4gICAgdGhpcy5fYXBwZW5kID0gZGlnaXRzID09IG51bGwgPyBhcHBlbmQgOiBhcHBlbmRSb3VuZChkaWdpdHMpO1xuICB9XG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fYXBwZW5kYFpgO1xuICAgIH1cbiAgfVxuICBsaW5lVG8oeCwgeSkge1xuICAgIHRoaXMuX2FwcGVuZGBMJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBxdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuX2FwcGVuZGBRJHsreDF9LCR7K3kxfSwke3RoaXMuX3gxID0gK3h9LCR7dGhpcy5feTEgPSAreX1gO1xuICB9XG4gIGJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgQyR7K3gxfSwkeyt5MX0sJHsreDJ9LCR7K3kyfSwke3RoaXMuX3gxID0gK3h9LCR7dGhpcy5feTEgPSAreX1gO1xuICB9XG4gIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBuZWdhdGl2ZSByYWRpdXM6ICR7cn1gKTtcblxuICAgIGxldCB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gxID0geDF9LCR7dGhpcy5feTEgPSB5MX1gO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDAseTApPyBEbyBub3RoaW5nLlxuICAgIGVsc2UgaWYgKCEobDAxXzIgPiBlcHNpbG9uKSk7XG5cbiAgICAvLyBPciwgYXJlICh4MCx5MCksICh4MSx5MSkgYW5kICh4Mix5MikgY29sbGluZWFyP1xuICAgIC8vIEVxdWl2YWxlbnRseSwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgyLHkyKT9cbiAgICAvLyBPciwgaXMgdGhlIHJhZGl1cyB6ZXJvPyBMaW5lIHRvICh4MSx5MSkuXG4gICAgZWxzZSBpZiAoIShNYXRoLmFicyh5MDEgKiB4MjEgLSB5MjEgKiB4MDEpID4gZXBzaWxvbikgfHwgIXIpIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBMJHt0aGlzLl94MSA9IHgxfSwke3RoaXMuX3kxID0geTF9YDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgbGV0IHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl9hcHBlbmRgTCR7eDEgKyB0MDEgKiB4MDF9LCR7eTEgKyB0MDEgKiB5MDF9YDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYXBwZW5kYEEke3J9LCR7cn0sMCwwLCR7Kyh5MDEgKiB4MjAgPiB4MDEgKiB5MjApfSwke3RoaXMuX3gxID0geDEgKyB0MjEgKiB4MjF9LCR7dGhpcy5feTEgPSB5MSArIHQyMSAqIHkyMX1gO1xuICAgIH1cbiAgfVxuICBhcmMoeCwgeSwgciwgYTAsIGExLCBjY3cpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyLCBjY3cgPSAhIWNjdztcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBuZWdhdGl2ZSByYWRpdXM6ICR7cn1gKTtcblxuICAgIGxldCBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgwLHkwKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBNJHt4MH0sJHt5MH1gO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fYXBwZW5kYEwke3gwfSwke3kwfWA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgZW1wdHk/IFdl4oCZcmUgZG9uZS5cbiAgICBpZiAoIXIpIHJldHVybjtcblxuICAgIC8vIERvZXMgdGhlIGFuZ2xlIGdvIHRoZSB3cm9uZyB3YXk/IEZsaXAgdGhlIGRpcmVjdGlvbi5cbiAgICBpZiAoZGEgPCAwKSBkYSA9IGRhICUgdGF1ICsgdGF1O1xuXG4gICAgLy8gSXMgdGhpcyBhIGNvbXBsZXRlIGNpcmNsZT8gRHJhdyB0d28gYXJjcyB0byBjb21wbGV0ZSB0aGUgY2lyY2xlLlxuICAgIGlmIChkYSA+IHRhdUVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsMSwke2N3fSwke3ggLSBkeH0sJHt5IC0gZHl9QSR7cn0sJHtyfSwwLDEsJHtjd30sJHt0aGlzLl94MSA9IHgwfSwke3RoaXMuX3kxID0geTB9YDtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fYXBwZW5kYEEke3J9LCR7cn0sMCwkeysoZGEgPj0gcGkpfSwke2N3fSwke3RoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSl9LCR7dGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKX1gO1xuICAgIH1cbiAgfVxuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl9hcHBlbmRgTSR7dGhpcy5feDAgPSB0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kwID0gdGhpcy5feTEgPSAreX1oJHt3ID0gK3d9diR7K2h9aCR7LXd9WmA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG4vLyBBbGxvdyBpbnN0YW5jZW9mIGQzLnBhdGhcbnBhdGgucHJvdG90eXBlID0gUGF0aC5wcm90b3R5cGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoUm91bmQoZGlnaXRzID0gMykge1xuICByZXR1cm4gbmV3IFBhdGgoK2RpZ2l0cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGNvbnN0IHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpLFxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCk7XG4gIHJldHVybiBhZGQodGhpcy5jb3Zlcih4LCB5KSwgeCwgeSwgZCk7XG59XG5cbmZ1bmN0aW9uIGFkZCh0cmVlLCB4LCB5LCBkKSB7XG4gIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIHRyZWU7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdHJlZS5fcm9vdCxcbiAgICAgIGxlYWYgPSB7ZGF0YTogZH0sXG4gICAgICB4MCA9IHRyZWUuX3gwLFxuICAgICAgeTAgPSB0cmVlLl95MCxcbiAgICAgIHgxID0gdHJlZS5feDEsXG4gICAgICB5MSA9IHRyZWUuX3kxLFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHhwLFxuICAgICAgeXAsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gRmluZCB0aGUgZXhpc3RpbmcgbGVhZiBmb3IgdGhlIG5ldyBwb2ludCwgb3IgYWRkIGl0LlxuICB3aGlsZSAobm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbiAgfVxuXG4gIC8vIElzIHRoZSBuZXcgcG9pbnQgaXMgZXhhY3RseSBjb2luY2lkZW50IHdpdGggdGhlIGV4aXN0aW5nIHBvaW50P1xuICB4cCA9ICt0cmVlLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgeXAgPSArdHJlZS5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIGlmICh4ID09PSB4cCAmJiB5ID09PSB5cCkgcmV0dXJuIGxlYWYubmV4dCA9IG5vZGUsIHBhcmVudCA/IHBhcmVudFtpXSA9IGxlYWYgOiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBPdGhlcndpc2UsIHNwbGl0IHRoZSBsZWFmIG5vZGUgdW50aWwgdGhlIG9sZCBhbmQgbmV3IHBvaW50IGFyZSBzZXBhcmF0ZWQuXG4gIGRvIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQgPyBwYXJlbnRbaV0gPSBuZXcgQXJyYXkoNCkgOiB0cmVlLl9yb290ID0gbmV3IEFycmF5KDQpO1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICB9IHdoaWxlICgoaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHQpID09PSAoaiA9ICh5cCA+PSB5bSkgPDwgMSB8ICh4cCA+PSB4bSkpKTtcbiAgcmV0dXJuIHBhcmVudFtqXSA9IG5vZGUsIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRBbGwoZGF0YSkge1xuICB2YXIgZCwgaSwgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHl6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeDAgPSBJbmZpbml0eSxcbiAgICAgIHkwID0gSW5maW5pdHksXG4gICAgICB4MSA9IC1JbmZpbml0eSxcbiAgICAgIHkxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQgPSBkYXRhW2ldKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSBjb250aW51ZTtcbiAgICB4eltpXSA9IHg7XG4gICAgeXpbaV0gPSB5O1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdlcmUgbm8gKHZhbGlkKSBwb2ludHMsIGFib3J0LlxuICBpZiAoeDAgPiB4MSB8fCB5MCA+IHkxKSByZXR1cm4gdGhpcztcblxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXG4gIHRoaXMuY292ZXIoeDAsIHkwKS5jb3Zlcih4MSwgeTEpO1xuXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGFkZCh0aGlzLCB4eltpXSwgeXpbaV0sIGRhdGFbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIGlmIChpc05hTih4ID0gK3gpIHx8IGlzTmFOKHkgPSAreSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MTtcblxuICAvLyBJZiB0aGUgcXVhZHRyZWUgaGFzIG5vIGV4dGVudCwgaW5pdGlhbGl6ZSB0aGVtLlxuICAvLyBJbnRlZ2VyIGV4dGVudCBhcmUgbmVjZXNzYXJ5IHNvIHRoYXQgaWYgd2UgbGF0ZXIgZG91YmxlIHRoZSBleHRlbnQsXG4gIC8vIHRoZSBleGlzdGluZyBxdWFkcmFudCBib3VuZGFyaWVzIGRvbuKAmXQgY2hhbmdlIGR1ZSB0byBmbG9hdGluZyBwb2ludCBlcnJvciFcbiAgaWYgKGlzTmFOKHgwKSkge1xuICAgIHgxID0gKHgwID0gTWF0aC5mbG9vcih4KSkgKyAxO1xuICAgIHkxID0gKHkwID0gTWF0aC5mbG9vcih5KSkgKyAxO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkb3VibGUgcmVwZWF0ZWRseSB0byBjb3Zlci5cbiAgZWxzZSB7XG4gICAgdmFyIHogPSB4MSAtIHgwIHx8IDEsXG4gICAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAoeDAgPiB4IHx8IHggPj0geDEgfHwgeTAgPiB5IHx8IHkgPj0geTEpIHtcbiAgICAgIGkgPSAoeSA8IHkwKSA8PCAxIHwgKHggPCB4MCk7XG4gICAgICBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQsIHogKj0gMjtcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6IHgxID0geDAgKyB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogeDAgPSB4MSAtIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAyOiB4MSA9IHgwICsgeiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHgwID0geDEgLSB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5sZW5ndGgpIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gZGF0YS5wdXNoKG5vZGUuZGF0YSk7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuY292ZXIoK19bMF1bMF0sICtfWzBdWzFdKS5jb3ZlcigrX1sxXVswXSwgK19bMV1bMV0pXG4gICAgICA6IGlzTmFOKHRoaXMuX3gwKSA/IHVuZGVmaW5lZCA6IFtbdGhpcy5feDAsIHRoaXMuX3kwXSwgW3RoaXMuX3gxLCB0aGlzLl95MV1dO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeDMgPSB0aGlzLl94MSxcbiAgICAgIHkzID0gdGhpcy5feTEsXG4gICAgICBxdWFkcyA9IFtdLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBxLFxuICAgICAgaTtcblxuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB4MCwgeTAsIHgzLCB5MykpO1xuICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICBlbHNlIHtcbiAgICB4MCA9IHggLSByYWRpdXMsIHkwID0geSAtIHJhZGl1cztcbiAgICB4MyA9IHggKyByYWRpdXMsIHkzID0geSArIHJhZGl1cztcbiAgICByYWRpdXMgKj0gcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuXG4gICAgLy8gU3RvcCBzZWFyY2hpbmcgaWYgdGhpcyBxdWFkcmFudCBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh5MSA9IHEueTApID4geTNcbiAgICAgICAgfHwgKHgyID0gcS54MSkgPCB4MFxuICAgICAgICB8fCAoeTIgPSBxLnkxKSA8IHkwKSBjb250aW51ZTtcblxuICAgIC8vIEJpc2VjdCB0aGUgY3VycmVudCBxdWFkcmFudC5cbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgeW0gPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgICBxdWFkcy5wdXNoKFxuICAgICAgICBuZXcgUXVhZChub2RlWzNdLCB4bSwgeW0sIHgyLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMl0sIHgxLCB5bSwgeG0sIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsxXSwgeG0sIHkxLCB4MiwgeW0pLFxuICAgICAgICBuZXcgUXVhZChub2RlWzBdLCB4MSwgeTEsIHhtLCB5bSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFZpc2l0IHRoZSBjbG9zZXN0IHF1YWRyYW50IGZpcnN0LlxuICAgICAgaWYgKGkgPSAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xuICAgICAgICBxID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV0gPSBxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZpc2l0IHRoaXMgcG9pbnQuIChWaXNpdGluZyBjb2luY2lkZW50IHBvaW50cyBpc27igJl0IG5lY2Vzc2FyeSEpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZHggPSB4IC0gK3RoaXMuX3guY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGR5ID0geSAtICt0aGlzLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHJhZGl1cyA9IGQyKTtcbiAgICAgICAgeDAgPSB4IC0gZCwgeTAgPSB5IC0gZDtcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZDtcbiAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy55MCA9IHkwO1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbn1cbiIsImltcG9ydCB0cmVlX2FkZCwge2FkZEFsbCBhcyB0cmVlX2FkZEFsbH0gZnJvbSBcIi4vYWRkLmpzXCI7XG5pbXBvcnQgdHJlZV9jb3ZlciBmcm9tIFwiLi9jb3Zlci5qc1wiO1xuaW1wb3J0IHRyZWVfZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgdHJlZV9leHRlbnQgZnJvbSBcIi4vZXh0ZW50LmpzXCI7XG5pbXBvcnQgdHJlZV9maW5kIGZyb20gXCIuL2ZpbmQuanNcIjtcbmltcG9ydCB0cmVlX3JlbW92ZSwge3JlbW92ZUFsbCBhcyB0cmVlX3JlbW92ZUFsbH0gZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJlZV9yb290IGZyb20gXCIuL3Jvb3QuanNcIjtcbmltcG9ydCB0cmVlX3NpemUgZnJvbSBcIi4vc2l6ZS5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXQgZnJvbSBcIi4vdmlzaXQuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0QWZ0ZXIgZnJvbSBcIi4vdmlzaXRBZnRlci5qc1wiO1xuaW1wb3J0IHRyZWVfeCwge2RlZmF1bHRYfSBmcm9tIFwiLi94LmpzXCI7XG5pbXBvcnQgdHJlZV95LCB7ZGVmYXVsdFl9IGZyb20gXCIuL3kuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhZHRyZWUobm9kZXMsIHgsIHkpIHtcbiAgdmFyIHRyZWUgPSBuZXcgUXVhZHRyZWUoeCA9PSBudWxsID8gZGVmYXVsdFggOiB4LCB5ID09IG51bGwgPyBkZWZhdWx0WSA6IHksIE5hTiwgTmFOLCBOYU4sIE5hTik7XG4gIHJldHVybiBub2RlcyA9PSBudWxsID8gdHJlZSA6IHRyZWUuYWRkQWxsKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gUXVhZHRyZWUoeCwgeSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5feCA9IHg7XG4gIHRoaXMuX3kgPSB5O1xuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICB0aGlzLl9yb290ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBsZWFmX2NvcHkobGVhZikge1xuICB2YXIgY29weSA9IHtkYXRhOiBsZWFmLmRhdGF9LCBuZXh0ID0gY29weTtcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciB0cmVlUHJvdG8gPSBxdWFkdHJlZS5wcm90b3R5cGUgPSBRdWFkdHJlZS5wcm90b3R5cGU7XG5cbnRyZWVQcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3B5ID0gbmV3IFF1YWR0cmVlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgbm9kZXMsXG4gICAgICBjaGlsZDtcblxuICBpZiAoIW5vZGUpIHJldHVybiBjb3B5O1xuXG4gIGlmICghbm9kZS5sZW5ndGgpIHJldHVybiBjb3B5Ll9yb290ID0gbGVhZl9jb3B5KG5vZGUpLCBjb3B5O1xuXG4gIG5vZGVzID0gW3tzb3VyY2U6IG5vZGUsIHRhcmdldDogY29weS5fcm9vdCA9IG5ldyBBcnJheSg0KX1dO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGUuc291cmNlW2ldKSB7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGgpIG5vZGVzLnB1c2goe3NvdXJjZTogY2hpbGQsIHRhcmdldDogbm9kZS50YXJnZXRbaV0gPSBuZXcgQXJyYXkoNCl9KTtcbiAgICAgICAgZWxzZSBub2RlLnRhcmdldFtpXSA9IGxlYWZfY29weShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG50cmVlUHJvdG8uYWRkID0gdHJlZV9hZGQ7XG50cmVlUHJvdG8uYWRkQWxsID0gdHJlZV9hZGRBbGw7XG50cmVlUHJvdG8uY292ZXIgPSB0cmVlX2NvdmVyO1xudHJlZVByb3RvLmRhdGEgPSB0cmVlX2RhdGE7XG50cmVlUHJvdG8uZXh0ZW50ID0gdHJlZV9leHRlbnQ7XG50cmVlUHJvdG8uZmluZCA9IHRyZWVfZmluZDtcbnRyZWVQcm90by5yZW1vdmUgPSB0cmVlX3JlbW92ZTtcbnRyZWVQcm90by5yZW1vdmVBbGwgPSB0cmVlX3JlbW92ZUFsbDtcbnRyZWVQcm90by5yb290ID0gdHJlZV9yb290O1xudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XG50cmVlUHJvdG8udmlzaXQgPSB0cmVlX3Zpc2l0O1xudHJlZVByb3RvLnZpc2l0QWZ0ZXIgPSB0cmVlX3Zpc2l0QWZ0ZXI7XG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcbnRyZWVQcm90by55ID0gdHJlZV95O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHJldGFpbmVyLFxuICAgICAgcHJldmlvdXMsXG4gICAgICBuZXh0LFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoIShwYXJlbnQgPSBub2RlLCBub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiAzXSB8fCBwYXJlbnRbKGkgKyAyKSAmIDNdIHx8IHBhcmVudFsoaSArIDMpICYgM10pIHJldGFpbmVyID0gcGFyZW50LCBqID0gaTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHBvaW50IHRvIHJlbW92ZS5cbiAgd2hpbGUgKG5vZGUuZGF0YSAhPT0gZCkgaWYgKCEocHJldmlvdXMgPSBub2RlLCBub2RlID0gbm9kZS5uZXh0KSkgcmV0dXJuIHRoaXM7XG4gIGlmIChuZXh0ID0gbm9kZS5uZXh0KSBkZWxldGUgbm9kZS5uZXh0O1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb2luY2lkZW50IHBvaW50cywgcmVtb3ZlIGp1c3QgdGhlIHBvaW50LlxuICBpZiAocHJldmlvdXMpIHJldHVybiAobmV4dCA/IHByZXZpb3VzLm5leHQgPSBuZXh0IDogZGVsZXRlIHByZXZpb3VzLm5leHQpLCB0aGlzO1xuXG4gIC8vIElmIHRoaXMgaXMgdGhlIHJvb3QgcG9pbnQsIHJlbW92ZSBpdC5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiB0aGlzLl9yb290ID0gbmV4dCwgdGhpcztcblxuICAvLyBSZW1vdmUgdGhpcyBsZWFmLlxuICBuZXh0ID8gcGFyZW50W2ldID0gbmV4dCA6IGRlbGV0ZSBwYXJlbnRbaV07XG5cbiAgLy8gSWYgdGhlIHBhcmVudCBub3cgY29udGFpbnMgZXhhY3RseSBvbmUgbGVhZiwgY29sbGFwc2Ugc3VwZXJmbHVvdXMgcGFyZW50cy5cbiAgaWYgKChub2RlID0gcGFyZW50WzBdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzNdKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFszXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFswXSlcbiAgICAgICYmICFub2RlLmxlbmd0aCkge1xuICAgIGlmIChyZXRhaW5lcikgcmV0YWluZXJbal0gPSBub2RlO1xuICAgIGVsc2UgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbChkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHRoaXMucmVtb3ZlKGRhdGFbaV0pO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcm9vdDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvICsrc2l6ZTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIHEsIG5vZGUgPSB0aGlzLl9yb290LCBjaGlsZCwgeDAsIHkwLCB4MSwgeTE7XG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICBpZiAoIWNhbGxiYWNrKG5vZGUgPSBxLm5vZGUsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSkgJiYgbm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgcXVhZHMucHVzaChuZXcgUXVhZCh0aGlzLl9yb290LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgdmFyIG5vZGUgPSBxLm5vZGU7XG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgIH1cbiAgICBuZXh0LnB1c2gocSk7XG4gIH1cbiAgd2hpbGUgKHEgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLngxLCBxLnkxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xuICByZXR1cm4gZFsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gXywgdGhpcykgOiB0aGlzLl95O1xufVxuIiwiaW1wb3J0IGNvbG9ycyBmcm9tIFwiLi4vY29sb3JzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9ycyhcIjhkZDNjN2ZmZmZiM2JlYmFkYWZiODA3MjgwYjFkM2ZkYjQ2MmIzZGU2OWZjY2RlNWQ5ZDlkOWJjODBiZGNjZWJjNWZmZWQ2ZlwiKTtcbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4uL2NvbG9ycy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjb2xvcnMoXCIxZjc3YjRmZjdmMGUyY2EwMmNkNjI3Mjg5NDY3YmQ4YzU2NGJlMzc3YzI3ZjdmN2ZiY2JkMjIxN2JlY2ZcIik7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgdmFyIG4gPSBzcGVjaWZpZXIubGVuZ3RoIC8gNiB8IDAsIGNvbG9ycyA9IG5ldyBBcnJheShuKSwgaSA9IDA7XG4gIHdoaWxlIChpIDwgbikgY29sb3JzW2ldID0gXCIjXCIgKyBzcGVjaWZpZXIuc2xpY2UoaSAqIDYsICsraSAqIDYpO1xuICByZXR1cm4gY29sb3JzO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVJnYkJhc2lzfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgc2NoZW1lID0+IGludGVycG9sYXRlUmdiQmFzaXMoc2NoZW1lW3NjaGVtZS5sZW5ndGggLSAxXSk7XG4iLCJpbXBvcnQgY29sb3JzIGZyb20gXCIuLi9jb2xvcnMuanNcIjtcbmltcG9ydCByYW1wIGZyb20gXCIuLi9yYW1wLmpzXCI7XG5cbmV4cG9ydCB2YXIgc2NoZW1lID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmZWU4YzhmZGJiODRlMzRhMzNcIixcbiAgXCJmZWYwZDlmZGNjOGFmYzhkNTlkNzMwMWZcIixcbiAgXCJmZWYwZDlmZGNjOGFmYzhkNTllMzRhMzNiMzAwMDBcIixcbiAgXCJmZWYwZDlmZGQ0OWVmZGJiODRmYzhkNTllMzRhMzNiMzAwMDBcIixcbiAgXCJmZWYwZDlmZGQ0OWVmZGJiODRmYzhkNTllZjY1NDhkNzMwMWY5OTAwMDBcIixcbiAgXCJmZmY3ZWNmZWU4YzhmZGQ0OWVmZGJiODRmYzhkNTllZjY1NDhkNzMwMWY5OTAwMDBcIixcbiAgXCJmZmY3ZWNmZWU4YzhmZGQ0OWVmZGJiODRmYzhkNTllZjY1NDhkNzMwMWZiMzAwMDA3ZjAwMDBcIlxuKS5tYXAoY29sb3JzKTtcblxuZXhwb3J0IGRlZmF1bHQgcmFtcChzY2hlbWUpO1xuIiwiaW1wb3J0IGNvbG9ycyBmcm9tIFwiLi4vY29sb3JzLmpzXCI7XG5pbXBvcnQgcmFtcCBmcm9tIFwiLi4vcmFtcC5qc1wiO1xuXG5leHBvcnQgdmFyIHNjaGVtZSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWRmOGIxN2ZjZGJiMmM3ZmI4XCIsXG4gIFwiZmZmZmNjYTFkYWI0NDFiNmM0MjI1ZWE4XCIsXG4gIFwiZmZmZmNjYTFkYWI0NDFiNmM0MmM3ZmI4MjUzNDk0XCIsXG4gIFwiZmZmZmNjYzdlOWI0N2ZjZGJiNDFiNmM0MmM3ZmI4MjUzNDk0XCIsXG4gIFwiZmZmZmNjYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MGMyYzg0XCIsXG4gIFwiZmZmZmQ5ZWRmOGIxYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MGMyYzg0XCIsXG4gIFwiZmZmZmQ5ZWRmOGIxYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MjUzNDk0MDgxZDU4XCJcbikubWFwKGNvbG9ycyk7XG5cbmV4cG9ydCBkZWZhdWx0IHJhbXAoc2NoZW1lKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID09IG51bGwgfHwgYiA9PSBudWxsID8gTmFOIDogYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuaW1wb3J0IGJpc2VjdG9yIGZyb20gXCIuL2Jpc2VjdG9yLmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG5jb25zdCBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuZXhwb3J0IGNvbnN0IGJpc2VjdFJpZ2h0ID0gYXNjZW5kaW5nQmlzZWN0LnJpZ2h0O1xuZXhwb3J0IGNvbnN0IGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcbmV4cG9ydCBjb25zdCBiaXNlY3RDZW50ZXIgPSBiaXNlY3RvcihudW1iZXIpLmNlbnRlcjtcbmV4cG9ydCBkZWZhdWx0IGJpc2VjdFJpZ2h0O1xuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmlzZWN0b3IoZikge1xuICBsZXQgY29tcGFyZTEsIGNvbXBhcmUyLCBkZWx0YTtcblxuICAvLyBJZiBhbiBhY2Nlc3NvciBpcyBzcGVjaWZpZWQsIHByb21vdGUgaXQgdG8gYSBjb21wYXJhdG9yLiBJbiB0aGlzIGNhc2Ugd2VcbiAgLy8gY2FuIHRlc3Qgd2hldGhlciB0aGUgc2VhcmNoIHZhbHVlIGlzIChzZWxmLSkgY29tcGFyYWJsZS4gV2UgY2Fu4oCZdCBkbyB0aGlzXG4gIC8vIGZvciBhIGNvbXBhcmF0b3IgKGV4Y2VwdCBmb3Igc3BlY2lmaWMsIGtub3duIGNvbXBhcmF0b3JzKSBiZWNhdXNlIHdlIGNhbuKAmXRcbiAgLy8gdGVsbCBpZiB0aGUgY29tcGFyYXRvciBpcyBzeW1tZXRyaWMsIGFuZCBhbiBhc3ltbWV0cmljIGNvbXBhcmF0b3IgY2Fu4oCZdCBiZVxuICAvLyB1c2VkIHRvIHRlc3Qgd2hldGhlciBhIHNpbmdsZSB2YWx1ZSBpcyBjb21wYXJhYmxlLlxuICBpZiAoZi5sZW5ndGggIT09IDIpIHtcbiAgICBjb21wYXJlMSA9IGFzY2VuZGluZztcbiAgICBjb21wYXJlMiA9IChkLCB4KSA9PiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgZGVsdGEgPSAoZCwgeCkgPT4gZihkKSAtIHg7XG4gIH0gZWxzZSB7XG4gICAgY29tcGFyZTEgPSBmID09PSBhc2NlbmRpbmcgfHwgZiA9PT0gZGVzY2VuZGluZyA/IGYgOiB6ZXJvO1xuICAgIGNvbXBhcmUyID0gZjtcbiAgICBkZWx0YSA9IGY7XG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvID0gMCwgaGkgPSBhLmxlbmd0aCkge1xuICAgIGlmIChsbyA8IGhpKSB7XG4gICAgICBpZiAoY29tcGFyZTEoeCwgeCkgIT09IDApIHJldHVybiBoaTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH0gd2hpbGUgKGxvIDwgaGkpO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiByaWdodChhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBpZiAobG8gPCBoaSkge1xuICAgICAgaWYgKGNvbXBhcmUxKHgsIHgpICE9PSAwKSByZXR1cm4gaGk7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPD0gMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGhpID0gbWlkO1xuICAgICAgfSB3aGlsZSAobG8gPCBoaSk7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRlcihhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTtcbiAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgY2VudGVyLCByaWdodH07XG59XG5cbmZ1bmN0aW9uIHplcm8oKSB7XG4gIHJldHVybiAwO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID09IG51bGwgfHwgYiA9PSBudWxsID8gTmFOXG4gICAgOiBiIDwgYSA/IC0xXG4gICAgOiBiID4gYSA/IDFcbiAgICA6IGIgPj0gYSA/IDBcbiAgICA6IE5hTjtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyZWF0ZXN0KHZhbHVlcywgY29tcGFyZSA9IGFzY2VuZGluZykge1xuICBsZXQgbWF4O1xuICBsZXQgZGVmaW5lZCA9IGZhbHNlO1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgbWF4VmFsdWU7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb21wYXJlKGVsZW1lbnQpO1xuICAgICAgaWYgKGRlZmluZWRcbiAgICAgICAgICA/IGFzY2VuZGluZyh2YWx1ZSwgbWF4VmFsdWUpID4gMFxuICAgICAgICAgIDogYXNjZW5kaW5nKHZhbHVlLCB2YWx1ZSkgPT09IDApIHtcbiAgICAgICAgbWF4ID0gZWxlbWVudDtcbiAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoZGVmaW5lZFxuICAgICAgICAgID8gY29tcGFyZSh2YWx1ZSwgbWF4KSA+IDBcbiAgICAgICAgICA6IGNvbXBhcmUodmFsdWUsIHZhbHVlKSA9PT0gMCkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtYXg7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXhJbmRleCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1heDtcbiAgbGV0IG1heEluZGV4ID0gLTE7XG4gIGxldCBpbmRleCA9IC0xO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZSwgbWF4SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZSwgbWF4SW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluSW5kZXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGxldCBtaW5JbmRleCA9IC0xO1xuICBsZXQgaW5kZXggPSAtMTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWUsIG1pbkluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWUsIG1pbkluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5JbmRleDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG51bWJlcih4KSB7XG4gIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogbnVtYmVycyh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGVybXV0ZShzb3VyY2UsIGtleXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oa2V5cywga2V5ID0+IHNvdXJjZVtrZXldKTtcbn1cbiIsImltcG9ydCBtYXggZnJvbSBcIi4vbWF4LmpzXCI7XG5pbXBvcnQgbWF4SW5kZXggZnJvbSBcIi4vbWF4SW5kZXguanNcIjtcbmltcG9ydCBtaW4gZnJvbSBcIi4vbWluLmpzXCI7XG5pbXBvcnQgbWluSW5kZXggZnJvbSBcIi4vbWluSW5kZXguanNcIjtcbmltcG9ydCBxdWlja3NlbGVjdCBmcm9tIFwiLi9xdWlja3NlbGVjdC5qc1wiO1xuaW1wb3J0IG51bWJlciwge251bWJlcnN9IGZyb20gXCIuL251bWJlci5qc1wiO1xuaW1wb3J0IHthc2NlbmRpbmdEZWZpbmVkfSBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgZ3JlYXRlc3QgZnJvbSBcIi4vZ3JlYXRlc3QuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSk7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSB8fCBpc05hTihwID0gK3ApKSByZXR1cm47XG4gIGlmIChwIDw9IDAgfHwgbiA8IDIpIHJldHVybiBtaW4odmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuIG1heCh2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9IG1heChxdWlja3NlbGVjdCh2YWx1ZXMsIGkwKS5zdWJhcnJheSgwLCBpMCArIDEpKSxcbiAgICAgIHZhbHVlMSA9IG1pbih2YWx1ZXMuc3ViYXJyYXkoaTAgKyAxKSk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQodmFsdWVzLCBwLCB2YWx1ZW9mID0gbnVtYmVyKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSB8fCBpc05hTihwID0gK3ApKSByZXR1cm47XG4gIGlmIChwIDw9IDAgfHwgbiA8IDIpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbMF0sIDAsIHZhbHVlcyk7XG4gIGlmIChwID49IDEpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbbiAtIDFdLCBuIC0gMSwgdmFsdWVzKTtcbiAgdmFyIG4sXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXG4gICAgICBpMCA9IE1hdGguZmxvb3IoaSksXG4gICAgICB2YWx1ZTAgPSArdmFsdWVvZih2YWx1ZXNbaTBdLCBpMCwgdmFsdWVzKSxcbiAgICAgIHZhbHVlMSA9ICt2YWx1ZW9mKHZhbHVlc1tpMCArIDFdLCBpMCArIDEsIHZhbHVlcyk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpbGVJbmRleCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKGlzTmFOKHAgPSArcCkpIHJldHVybjtcbiAgbnVtYmVycyA9IEZsb2F0NjRBcnJheS5mcm9tKHZhbHVlcywgKF8sIGkpID0+IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpO1xuICBpZiAocCA8PSAwKSByZXR1cm4gbWluSW5kZXgobnVtYmVycyk7XG4gIGlmIChwID49IDEpIHJldHVybiBtYXhJbmRleChudW1iZXJzKTtcbiAgdmFyIG51bWJlcnMsXG4gICAgICBpbmRleCA9IFVpbnQzMkFycmF5LmZyb20odmFsdWVzLCAoXywgaSkgPT4gaSksXG4gICAgICBqID0gbnVtYmVycy5sZW5ndGggLSAxLFxuICAgICAgaSA9IE1hdGguZmxvb3IoaiAqIHApO1xuICBxdWlja3NlbGVjdChpbmRleCwgaSwgMCwgaiwgKGksIGopID0+IGFzY2VuZGluZ0RlZmluZWQobnVtYmVyc1tpXSwgbnVtYmVyc1tqXSkpO1xuICBpID0gZ3JlYXRlc3QoaW5kZXguc3ViYXJyYXkoMCwgaSArIDEpLCAoaSkgPT4gbnVtYmVyc1tpXSk7XG4gIHJldHVybiBpID49IDAgPyBpIDogLTE7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZ0RlZmluZWQsIGNvbXBhcmVEZWZpbmVkfSBmcm9tIFwiLi9zb3J0LmpzXCI7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3F1aWNrc2VsZWN0XG4vLyBJU0MgbGljZW5zZSwgQ29weXJpZ2h0IDIwMTggVmxhZGltaXIgQWdhZm9ua2luLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyYXksIGssIGxlZnQgPSAwLCByaWdodCA9IEluZmluaXR5LCBjb21wYXJlKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBsZWZ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBsZWZ0KSk7XG4gIHJpZ2h0ID0gTWF0aC5mbG9vcihNYXRoLm1pbihhcnJheS5sZW5ndGggLSAxLCByaWdodCkpO1xuXG4gIGlmICghKGxlZnQgPD0gayAmJiBrIDw9IHJpZ2h0KSkgcmV0dXJuIGFycmF5O1xuXG4gIGNvbXBhcmUgPSBjb21wYXJlID09PSB1bmRlZmluZWQgPyBhc2NlbmRpbmdEZWZpbmVkIDogY29tcGFyZURlZmluZWQoY29tcGFyZSk7XG5cbiAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICBxdWlja3NlbGVjdChhcnJheSwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBhcnJheVtrXTtcbiAgICBsZXQgaSA9IGxlZnQ7XG4gICAgbGV0IGogPSByaWdodDtcblxuICAgIHN3YXAoYXJyYXksIGxlZnQsIGspO1xuICAgIGlmIChjb21wYXJlKGFycmF5W3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFycmF5LCBsZWZ0LCByaWdodCk7XG5cbiAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgIHN3YXAoYXJyYXksIGksIGopLCArK2ksIC0tajtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2ldLCB0KSA8IDApICsraTtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2pdLCB0KSA+IDApIC0tajtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFyZShhcnJheVtsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyYXksIGxlZnQsIGopO1xuICAgIGVsc2UgKytqLCBzd2FwKGFycmF5LCBqLCByaWdodCk7XG5cbiAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gc3dhcChhcnJheSwgaSwgaikge1xuICBjb25zdCB0ID0gYXJyYXlbaV07XG4gIGFycmF5W2ldID0gYXJyYXlbal07XG4gIGFycmF5W2pdID0gdDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIHN0YXJ0ID0gK3N0YXJ0LCBzdG9wID0gK3N0b3AsIHN0ZXAgPSAobiA9IGFyZ3VtZW50cy5sZW5ndGgpIDwgMiA/IChzdG9wID0gc3RhcnQsIHN0YXJ0ID0gMCwgMSkgOiBuIDwgMyA/IDEgOiArc3RlcDtcblxuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKSB8IDAsXG4gICAgICByYW5nZSA9IG5ldyBBcnJheShuKTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIHJhbmdlW2ldID0gc3RhcnQgKyBpICogc3RlcDtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgcGVybXV0ZSBmcm9tIFwiLi9wZXJtdXRlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvcnQodmFsdWVzLCAuLi5GKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbHVlcyBpcyBub3QgaXRlcmFibGVcIik7XG4gIHZhbHVlcyA9IEFycmF5LmZyb20odmFsdWVzKTtcbiAgbGV0IFtmXSA9IEY7XG4gIGlmICgoZiAmJiBmLmxlbmd0aCAhPT0gMikgfHwgRi5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgaW5kZXggPSBVaW50MzJBcnJheS5mcm9tKHZhbHVlcywgKGQsIGkpID0+IGkpO1xuICAgIGlmIChGLmxlbmd0aCA+IDEpIHtcbiAgICAgIEYgPSBGLm1hcChmID0+IHZhbHVlcy5tYXAoZikpO1xuICAgICAgaW5kZXguc29ydCgoaSwgaikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgRikge1xuICAgICAgICAgIGNvbnN0IGMgPSBhc2NlbmRpbmdEZWZpbmVkKGZbaV0sIGZbal0pO1xuICAgICAgICAgIGlmIChjKSByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSB2YWx1ZXMubWFwKGYpO1xuICAgICAgaW5kZXguc29ydCgoaSwgaikgPT4gYXNjZW5kaW5nRGVmaW5lZChmW2ldLCBmW2pdKSk7XG4gICAgfVxuICAgIHJldHVybiBwZXJtdXRlKHZhbHVlcywgaW5kZXgpO1xuICB9XG4gIHJldHVybiB2YWx1ZXMuc29ydChjb21wYXJlRGVmaW5lZChmKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlRGVmaW5lZChjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIGlmIChjb21wYXJlID09PSBhc2NlbmRpbmcpIHJldHVybiBhc2NlbmRpbmdEZWZpbmVkO1xuICBpZiAodHlwZW9mIGNvbXBhcmUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbXBhcmUgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gIHJldHVybiAoYSwgYikgPT4ge1xuICAgIGNvbnN0IHggPSBjb21wYXJlKGEsIGIpO1xuICAgIGlmICh4IHx8IHggPT09IDApIHJldHVybiB4O1xuICAgIHJldHVybiAoY29tcGFyZShiLCBiKSA9PT0gMCkgLSAoY29tcGFyZShhLCBhKSA9PT0gMCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2NlbmRpbmdEZWZpbmVkKGEsIGIpIHtcbiAgcmV0dXJuIChhID09IG51bGwgfHwgIShhID49IGEpKSAtIChiID09IG51bGwgfHwgIShiID49IGIpKSB8fCAoYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDApO1xufVxuIiwiY29uc3QgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmZ1bmN0aW9uIHRpY2tTcGVjKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBjb25zdCBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChzdGVwKSksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpLFxuICAgICAgZmFjdG9yID0gZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxO1xuICBsZXQgaTEsIGkyLCBpbmM7XG4gIGlmIChwb3dlciA8IDApIHtcbiAgICBpbmMgPSBNYXRoLnBvdygxMCwgLXBvd2VyKSAvIGZhY3RvcjtcbiAgICBpMSA9IE1hdGgucm91bmQoc3RhcnQgKiBpbmMpO1xuICAgIGkyID0gTWF0aC5yb3VuZChzdG9wICogaW5jKTtcbiAgICBpZiAoaTEgLyBpbmMgPCBzdGFydCkgKytpMTtcbiAgICBpZiAoaTIgLyBpbmMgPiBzdG9wKSAtLWkyO1xuICAgIGluYyA9IC1pbmM7XG4gIH0gZWxzZSB7XG4gICAgaW5jID0gTWF0aC5wb3coMTAsIHBvd2VyKSAqIGZhY3RvcjtcbiAgICBpMSA9IE1hdGgucm91bmQoc3RhcnQgLyBpbmMpO1xuICAgIGkyID0gTWF0aC5yb3VuZChzdG9wIC8gaW5jKTtcbiAgICBpZiAoaTEgKiBpbmMgPCBzdGFydCkgKytpMTtcbiAgICBpZiAoaTIgKiBpbmMgPiBzdG9wKSAtLWkyO1xuICB9XG4gIGlmIChpMiA8IGkxICYmIDAuNSA8PSBjb3VudCAmJiBjb3VudCA8IDIpIHJldHVybiB0aWNrU3BlYyhzdGFydCwgc3RvcCwgY291bnQgKiAyKTtcbiAgcmV0dXJuIFtpMSwgaTIsIGluY107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKCEoY291bnQgPiAwKSkgcmV0dXJuIFtdO1xuICBpZiAoc3RhcnQgPT09IHN0b3ApIHJldHVybiBbc3RhcnRdO1xuICBjb25zdCByZXZlcnNlID0gc3RvcCA8IHN0YXJ0LCBbaTEsIGkyLCBpbmNdID0gcmV2ZXJzZSA/IHRpY2tTcGVjKHN0b3AsIHN0YXJ0LCBjb3VudCkgOiB0aWNrU3BlYyhzdGFydCwgc3RvcCwgY291bnQpO1xuICBpZiAoIShpMiA+PSBpMSkpIHJldHVybiBbXTtcbiAgY29uc3QgbiA9IGkyIC0gaTEgKyAxLCB0aWNrcyA9IG5ldyBBcnJheShuKTtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAoaW5jIDwgMCkgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRpY2tzW2ldID0gKGkyIC0gaSkgLyAtaW5jO1xuICAgIGVsc2UgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRpY2tzW2ldID0gKGkyIC0gaSkgKiBpbmM7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGluYyA8IDApIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB0aWNrc1tpXSA9IChpMSArIGkpIC8gLWluYztcbiAgICBlbHNlIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB0aWNrc1tpXSA9IChpMSArIGkpICogaW5jO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHN0b3AgPSArc3RvcCwgc3RhcnQgPSArc3RhcnQsIGNvdW50ID0gK2NvdW50O1xuICByZXR1cm4gdGlja1NwZWMoc3RhcnQsIHN0b3AsIGNvdW50KVsyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgY29uc3QgcmV2ZXJzZSA9IHN0b3AgPCBzdGFydCwgaW5jID0gcmV2ZXJzZSA/IHRpY2tJbmNyZW1lbnQoc3RvcCwgc3RhcnQsIGNvdW50KSA6IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgcmV0dXJuIChyZXZlcnNlID8gLTEgOiAxKSAqIChpbmMgPCAwID8gMSAvIC1pbmMgOiBpbmMpO1xufVxuIiwiaW1wb3J0IHtyYW5nZSBhcyBzZXF1ZW5jZX0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuaW1wb3J0IG9yZGluYWwgZnJvbSBcIi4vb3JkaW5hbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiYW5kKCkge1xuICB2YXIgc2NhbGUgPSBvcmRpbmFsKCkudW5rbm93bih1bmRlZmluZWQpLFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgb3JkaW5hbFJhbmdlID0gc2NhbGUucmFuZ2UsXG4gICAgICByMCA9IDAsXG4gICAgICByMSA9IDEsXG4gICAgICBzdGVwLFxuICAgICAgYmFuZHdpZHRoLFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgYWxpZ24gPSAwLjU7XG5cbiAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IGRvbWFpbigpLmxlbmd0aCxcbiAgICAgICAgcmV2ZXJzZSA9IHIxIDwgcjAsXG4gICAgICAgIHN0YXJ0ID0gcmV2ZXJzZSA/IHIxIDogcjAsXG4gICAgICAgIHN0b3AgPSByZXZlcnNlID8gcjAgOiByMTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXF1ZW5jZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3IwLCByMV0gPSBfLCByMCA9ICtyMCwgcjEgPSArcjEsIHJlc2NhbGUoKSkgOiBbcjAsIHIxXTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBbcjAsIHIxXSA9IF8sIHIwID0gK3IwLCByMSA9ICtyMSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIHBhZGRpbmdPdXRlciA9ICtfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9ICtfLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKGRvbWFpbigpLCBbcjAsIHIxXSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShyZXNjYWxlKCksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uc3RhbnRzKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZSBhcyBpbnRlcnBvbGF0ZVZhbHVlLCBpbnRlcnBvbGF0ZU51bWJlciwgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbnZhciB1bml0ID0gWzAsIDFdO1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKGEsIGIpIHtcbiAgcmV0dXJuIChiIC09IChhID0gK2EpKVxuICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAoeCAtIGEpIC8gYjsgfVxuICAgICAgOiBjb25zdGFudChpc05hTihiKSA/IE5hTiA6IDAuNSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wZXIoYSwgYikge1xuICB2YXIgdDtcbiAgaWYgKGEgPiBiKSB0ID0gYSwgYSA9IGIsIGIgPSB0O1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgeCkpOyB9O1xufVxuXG4vLyBub3JtYWxpemUoYSwgYikoeCkgdGFrZXMgYSBkb21haW4gdmFsdWUgeCBpbiBbYSxiXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgdCBpbiBbMCwxXS5cbi8vIGludGVycG9sYXRlKGEsIGIpKHQpIHRha2VzIGEgcGFyYW1ldGVyIHQgaW4gWzAsMV0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmFuZ2UgdmFsdWUgeCBpbiBbYSxiXS5cbmZ1bmN0aW9uIGJpbWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBkMCA9IGRvbWFpblswXSwgZDEgPSBkb21haW5bMV0sIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV07XG4gIGlmIChkMSA8IGQwKSBkMCA9IG5vcm1hbGl6ZShkMSwgZDApLCByMCA9IGludGVycG9sYXRlKHIxLCByMCk7XG4gIGVsc2UgZDAgPSBub3JtYWxpemUoZDAsIGQxKSwgcjAgPSBpbnRlcnBvbGF0ZShyMCwgcjEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gcjAoZDAoeCkpOyB9O1xufVxuXG5mdW5jdGlvbiBwb2x5bWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBqID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSAtIDEsXG4gICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgIGkgPSAtMTtcblxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgd2hpbGUgKCsraSA8IGopIHtcbiAgICBkW2ldID0gbm9ybWFsaXplKGRvbWFpbltpXSwgZG9tYWluW2kgKyAxXSk7XG4gICAgcltpXSA9IGludGVycG9sYXRlKHJhbmdlW2ldLCByYW5nZVtpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaSA9IGJpc2VjdChkb21haW4sIHgsIDEsIGopIC0gMTtcbiAgICByZXR1cm4gcltpXShkW2ldKHgpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgZG9tYWluID0gdW5pdCxcbiAgICAgIHJhbmdlID0gdW5pdCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHVudHJhbnNmb3JtLFxuICAgICAgdW5rbm93bixcbiAgICAgIGNsYW1wID0gaWRlbnRpdHksXG4gICAgICBwaWVjZXdpc2UsXG4gICAgICBvdXRwdXQsXG4gICAgICBpbnB1dDtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKTtcbiAgICBpZiAoY2xhbXAgIT09IGlkZW50aXR5KSBjbGFtcCA9IGNsYW1wZXIoZG9tYWluWzBdLCBkb21haW5bbiAtIDFdKTtcbiAgICBwaWVjZXdpc2UgPSBuID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UoZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCByYW5nZSwgaW50ZXJwb2xhdGUpKSkodHJhbnNmb3JtKGNsYW1wKHgpKSk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIGNsYW1wKHVudHJhbnNmb3JtKChpbnB1dCB8fCAoaW5wdXQgPSBwaWVjZXdpc2UocmFuZ2UsIGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgaW50ZXJwb2xhdGVOdW1iZXIpKSkoeSkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gQXJyYXkuZnJvbShfLCBudW1iZXIpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IEFycmF5LmZyb20oXyksIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gXyA/IHRydWUgOiBpZGVudGl0eSwgcmVzY2FsZSgpKSA6IGNsYW1wICE9PSBpZGVudGl0eTtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHJlc2NhbGUoKSkgOiBpbnRlcnBvbGF0ZTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0LCB1KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdW50cmFuc2Zvcm0gPSB1O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRpbnVvdXMoKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcigpKGlkZW50aXR5LCBpZGVudGl0eSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaW5pdFJhbmdlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMucmFuZ2UoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5yYW5nZShyYW5nZSkuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEludGVycG9sYXRvcihkb21haW4sIGludGVycG9sYXRvcikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMToge1xuICAgICAgaWYgKHR5cGVvZiBkb21haW4gPT09IFwiZnVuY3Rpb25cIikgdGhpcy5pbnRlcnBvbGF0b3IoZG9tYWluKTtcbiAgICAgIGVsc2UgdGhpcy5yYW5nZShkb21haW4pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRoaXMuZG9tYWluKGRvbWFpbik7XG4gICAgICBpZiAodHlwZW9mIGludGVycG9sYXRvciA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmludGVycG9sYXRvcihpbnRlcnBvbGF0b3IpO1xuICAgICAgZWxzZSB0aGlzLnJhbmdlKGludGVycG9sYXRvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJpbXBvcnQge3RpY2tzLCB0aWNrSW5jcmVtZW50fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weX0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcbmltcG9ydCB0aWNrRm9ybWF0IGZyb20gXCIuL3RpY2tGb3JtYXQuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xuICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgdmFyIGkwID0gMDtcbiAgICB2YXIgaTEgPSBkLmxlbmd0aCAtIDE7XG4gICAgdmFyIHN0YXJ0ID0gZFtpMF07XG4gICAgdmFyIHN0b3AgPSBkW2kxXTtcbiAgICB2YXIgcHJlc3RlcDtcbiAgICB2YXIgc3RlcDtcbiAgICB2YXIgbWF4SXRlciA9IDEwO1xuXG4gICAgaWYgKHN0b3AgPCBzdGFydCkge1xuICAgICAgc3RlcCA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBzdGVwO1xuICAgICAgc3RlcCA9IGkwLCBpMCA9IGkxLCBpMSA9IHN0ZXA7XG4gICAgfVxuICAgIFxuICAgIHdoaWxlIChtYXhJdGVyLS0gPiAwKSB7XG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgICAgaWYgKHN0ZXAgPT09IHByZXN0ZXApIHtcbiAgICAgICAgZFtpMF0gPSBzdGFydFxuICAgICAgICBkW2kxXSA9IHN0b3BcbiAgICAgICAgcmV0dXJuIGRvbWFpbihkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcmVzdGVwID0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5lYXIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBudW1iZXIoeCkge1xuICByZXR1cm4gK3g7XG59XG4iLCJpbXBvcnQge0ludGVybk1hcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgY29uc3QgaW1wbGljaXQgPSBTeW1ib2woXCJpbXBsaWNpdFwiKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkaW5hbCgpIHtcbiAgdmFyIGluZGV4ID0gbmV3IEludGVybk1hcCgpLFxuICAgICAgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdW5rbm93biA9IGltcGxpY2l0O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKGQpIHtcbiAgICBsZXQgaSA9IGluZGV4LmdldChkKTtcbiAgICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGQsIGkgPSBkb21haW4ucHVzaChkKSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VbaSAlIHJhbmdlLmxlbmd0aF07XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW10sIGluZGV4ID0gbmV3IEludGVybk1hcCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgXykge1xuICAgICAgaWYgKGluZGV4Lmhhcyh2YWx1ZSkpIGNvbnRpbnVlO1xuICAgICAgaW5kZXguc2V0KHZhbHVlLCBkb21haW4ucHVzaCh2YWx1ZSkgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbChkb21haW4sIHJhbmdlKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQge2NvcHksIGlkZW50aXR5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUG93KGV4cG9uZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBleHBvbmVudCkgOiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxcnQoeCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5zcXJ0KC14KSA6IE1hdGguc3FydCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3F1YXJlKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLXggKiB4IDogeCAqIHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgZXhwb25lbnQgPSAxO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcmV0dXJuIGV4cG9uZW50ID09PSAxID8gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSlcbiAgICAgICAgOiBleHBvbmVudCA9PT0gMC41ID8gdHJhbnNmb3JtKHRyYW5zZm9ybVNxcnQsIHRyYW5zZm9ybVNxdWFyZSlcbiAgICAgICAgOiB0cmFuc2Zvcm0odHJhbnNmb3JtUG93KGV4cG9uZW50KSwgdHJhbnNmb3JtUG93KDEgLyBleHBvbmVudCkpO1xuICB9XG5cbiAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXhwb25lbnQgPSArXywgcmVzY2FsZSgpKSA6IGV4cG9uZW50O1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHBvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCgpIHtcbiAgcmV0dXJuIHBvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZywgYmlzZWN0LCBxdWFudGlsZVNvcnRlZCBhcyB0aHJlc2hvbGR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUoKSB7XG4gIHZhciBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB0aHJlc2hvbGRzID0gW10sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gTWF0aC5tYXgoMSwgcmFuZ2UubGVuZ3RoKTtcbiAgICB0aHJlc2hvbGRzID0gbmV3IEFycmF5KG4gLSAxKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGhyZXNob2xkc1tpIC0gMV0gPSB0aHJlc2hvbGQoZG9tYWluLCBpIC8gbik7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiByYW5nZVtiaXNlY3QodGhyZXNob2xkcywgeCldO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dIDogW1xuICAgICAgaSA+IDAgPyB0aHJlc2hvbGRzW2kgLSAxXSA6IGRvbWFpblswXSxcbiAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgXTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yIChsZXQgZCBvZiBfKSBpZiAoZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIG4gPSAxLFxuICAgICAgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgeCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3gwLCB4MV0gPSBfLCB4MCA9ICt4MCwgeDEgPSAreDEsIHJlc2NhbGUoKSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gKHJhbmdlID0gQXJyYXkuZnJvbShfKSkubGVuZ3RoIC0gMSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dXG4gICAgICAgIDogaSA8IDEgPyBbeDAsIGRvbWFpblswXV1cbiAgICAgICAgOiBpID49IG4gPyBbZG9tYWluW24gLSAxXSwgeDFdXG4gICAgICAgIDogW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUudGhyZXNob2xkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aXplKClcbiAgICAgICAgLmRvbWFpbihbeDAsIHgxXSlcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGxpbmVhcmlzaChzY2FsZSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bixcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHggPD0geCA/IHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXSA6IHVua25vd247XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gQXJyYXkuZnJvbShfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7dGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXQsIGZvcm1hdFByZWZpeCwgZm9ybWF0U3BlY2lmaWVyLCBwcmVjaXNpb25GaXhlZCwgcHJlY2lzaW9uUHJlZml4LCBwcmVjaXNpb25Sb3VuZH0gZnJvbSBcImQzLWZvcm1hdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aWNrRm9ybWF0KHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbn1cbiIsIi8vIEdpdmVuIHNvbWV0aGluZyBhcnJheSBsaWtlIChvciBudWxsKSwgcmV0dXJucyBzb21ldGhpbmcgdGhhdCBpcyBzdHJpY3RseSBhblxuLy8gYXJyYXkuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBhcnJheS1saWtlIG9iamVjdHMgcGFzc2VkIHRvIGQzLnNlbGVjdEFsbFxuLy8gb3Igc2VsZWN0aW9uLnNlbGVjdEFsbCBhcmUgY29udmVydGVkIGludG8gcHJvcGVyIGFycmF5cyB3aGVuIGNyZWF0aW5nIGFcbi8vIHNlbGVjdGlvbjsgd2UgZG9u4oCZdCBldmVyIHdhbnQgdG8gY3JlYXRlIGEgc2VsZWN0aW9uIGJhY2tlZCBieSBhIGxpdmVcbi8vIEhUTUxDb2xsZWN0aW9uIG9yIE5vZGVMaXN0LiBIb3dldmVyLCBub3RlIHRoYXQgc2VsZWN0aW9uLnNlbGVjdEFsbCB3aWxsIHVzZSBhXG4vLyBzdGF0aWMgTm9kZUxpc3QgYXMgYSBncm91cCwgc2luY2UgaXQgc2FmZWx5IGRlcml2ZWQgZnJvbSBxdWVyeVNlbGVjdG9yQWxsLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJyYXkoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gW10gOiBBcnJheS5pc0FycmF5KHgpID8geCA6IEFycmF5LmZyb20oeCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdChjcmVhdG9yKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuL25hbWVzcGFjZS5qc1wiO1xuaW1wb3J0IHt4aHRtbH0gZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICA/IGNyZWF0b3JGaXhlZFxuICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRNYXRjaGVyKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbiIsImltcG9ydCBuYW1lc3BhY2VzIGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xuICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbn1cbiIsImV4cG9ydCB2YXIgeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCwgbm9kZSkge1xuICBldmVudCA9IHNvdXJjZUV2ZW50KGV2ZW50KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG4gICAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICAgIH1cbiAgICBpZiAobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV07XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9uLCByb290fSBmcm9tIFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFthcnJheShzZWxlY3RvcildLCByb290KTtcbn1cbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuLi9uYW1lc3BhY2UuanNcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGUoZnVsbG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufVxuIiwiZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lU2hhbGxvdygpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUoZmFsc2UpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVEZWVwKCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZSh0cnVlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVlcCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZGVlcCA/IHNlbGVjdGlvbl9jbG9uZURlZXAgOiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHtFbnRlck5vZGV9IGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4uL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGJpbmRJbmRleChwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG5vZGUsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAvLyBQdXQgYW55IG51bGwgbm9kZXMgaW50byBlbnRlci5cbiAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cbiAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gIHZhciBpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVCeUtleVZhbHVlID0gbmV3IE1hcCxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkgKyBcIlwiO1xuICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmhhcyhrZXlWYWx1ZSkpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpICsgXCJcIjtcbiAgICBpZiAobm9kZSA9IG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZSkpIHtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIG5vZGVCeUtleVZhbHVlLmRlbGV0ZShrZXlWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBhbnkgcmVtYWluaW5nIG5vZGVzIHRoYXQgd2VyZSBub3QgYm91bmQgdG8gZGF0YSB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlc1tpXSkgPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0dW0obm9kZSkge1xuICByZXR1cm4gbm9kZS5fX2RhdGFfXztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBBcnJheS5mcm9tKHRoaXMsIGRhdHVtKTtcblxuICB2YXIgYmluZCA9IGtleSA/IGJpbmRLZXkgOiBiaW5kSW5kZXgsXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gY29uc3RhbnQodmFsdWUpO1xuXG4gIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICBncm91cCA9IGdyb3Vwc1tqXSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGEgPSBhcnJheWxpa2UodmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbi8vIEdpdmVuIHNvbWUgZGF0YSwgdGhpcyByZXR1cm5zIGFuIGFycmF5LWxpa2UgdmlldyBvZiBpdDogYW4gb2JqZWN0IHRoYXRcbi8vIGV4cG9zZXMgYSBsZW5ndGggcHJvcGVydHkgYW5kIGFsbG93cyBudW1lcmljIGluZGV4aW5nLiBOb3RlIHRoYXQgdW5saWtlXG4vLyBzZWxlY3RBbGwsIHRoaXMgaXNu4oCZdCB3b3JyaWVkIGFib3V0IOKAnGxpdmXigJ0gY29sbGVjdGlvbnMgYmVjYXVzZSB0aGUgcmVzdWx0aW5nXG4vLyBhcnJheSB3aWxsIG9ubHkgYmUgdXNlZCBicmllZmx5IHdoaWxlIGRhdGEgaXMgYmVpbmcgYm91bmQuIChJdCBpcyBwb3NzaWJsZSB0b1xuLy8gY2F1c2UgdGhlIGRhdGEgdG8gY2hhbmdlIHdoaWxlIGl0ZXJhdGluZyBieSB1c2luZyBhIGtleSBmdW5jdGlvbiwgYnV0IHBsZWFzZVxuLy8gZG9u4oCZdDsgd2XigJlkIHJhdGhlciBhdm9pZCBhIGdyYXR1aXRvdXMgY29weS4pXG5mdW5jdGlvbiBhcnJheWxpa2UoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiBkYXRhXG4gICAgPyBkYXRhIC8vIEFycmF5LCBUeXBlZEFycmF5LCBOb2RlTGlzdCwgYXJyYXktbGlrZVxuICAgIDogQXJyYXkuZnJvbShkYXRhKTsgLy8gTWFwLCBTZXQsIGl0ZXJhYmxlLCBzdHJpbmcsIG9yIGFueXRoaW5nIGVsc2Vcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSlcbiAgICAgIDogdGhpcy5ub2RlKCkuX19kYXRhX187XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KG5vZGUsIHR5cGUsIHBhcmFtcykge1xuICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXG4gICAgICBldmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gICAgZWxzZSBldmVudC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ29uc3RhbnQodHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGRpc3BhdGNoRnVuY3Rpb25cbiAgICAgIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjay5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMubm9kZSgpO1xufVxuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IHBhcmVudC5vd25lckRvY3VtZW50O1xuICB0aGlzLm5hbWVzcGFjZVVSSSA9IHBhcmVudC5uYW1lc3BhY2VVUkk7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19kYXRhX18gPSBkYXR1bTtcbn1cblxuRW50ZXJOb2RlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZCwgbmV4dCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7IH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbn07XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBtYXRjaGVyIGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICA6IGh0bWxDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59XG4iLCJpbXBvcnQgc2VsZWN0aW9uX3NlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RDaGlsZCBmcm9tIFwiLi9zZWxlY3RDaGlsZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RDaGlsZHJlbiBmcm9tIFwiLi9zZWxlY3RDaGlsZHJlbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9maWx0ZXIgZnJvbSBcIi4vZmlsdGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lbnRlciBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9leGl0IGZyb20gXCIuL2V4aXQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fam9pbiBmcm9tIFwiLi9qb2luLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX29yZGVyIGZyb20gXCIuL29yZGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NvcnQgZnJvbSBcIi4vc29ydC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jYWxsIGZyb20gXCIuL2NhbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbm9kZXMgZnJvbSBcIi4vbm9kZXMuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbm9kZSBmcm9tIFwiLi9ub2RlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NpemUgZnJvbSBcIi4vc2l6ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lbXB0eSBmcm9tIFwiLi9lbXB0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9lYWNoIGZyb20gXCIuL2VhY2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3N0eWxlIGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3Byb3BlcnR5IGZyb20gXCIuL3Byb3BlcnR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NsYXNzZWQgZnJvbSBcIi4vY2xhc3NlZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faHRtbCBmcm9tIFwiLi9odG1sLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JhaXNlIGZyb20gXCIuL3JhaXNlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2xvd2VyIGZyb20gXCIuL2xvd2VyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2FwcGVuZCBmcm9tIFwiLi9hcHBlbmQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faW5zZXJ0IGZyb20gXCIuL2luc2VydC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2Nsb25lIGZyb20gXCIuL2Nsb25lLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2RhdHVtIGZyb20gXCIuL2RhdHVtLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2Rpc3BhdGNoIGZyb20gXCIuL2Rpc3BhdGNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2l0ZXJhdG9yIGZyb20gXCIuL2l0ZXJhdG9yLmpzXCI7XG5cbmV4cG9ydCB2YXIgcm9vdCA9IFtudWxsXTtcblxuZXhwb3J0IGZ1bmN0aW9uIFNlbGVjdGlvbihncm91cHMsIHBhcmVudHMpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCByb290KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9zZWxlY3RDaGlsZHJlbixcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIGpvaW46IHNlbGVjdGlvbl9qb2luLFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHNlbGVjdGlvbl9zZWxlY3Rpb24sXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gIHNvcnQ6IHNlbGVjdGlvbl9zb3J0LFxuICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX25vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fZWFjaCxcbiAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gIHByb3BlcnR5OiBzZWxlY3Rpb25fcHJvcGVydHksXG4gIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgaHRtbDogc2VsZWN0aW9uX2h0bWwsXG4gIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gIGFwcGVuZDogc2VsZWN0aW9uX2FwcGVuZCxcbiAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gIGNsb25lOiBzZWxlY3Rpb25fY2xvbmUsXG4gIGRhdHVtOiBzZWxlY3Rpb25fZGF0dW0sXG4gIG9uOiBzZWxlY3Rpb25fb24sXG4gIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2gsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25faXRlcmF0b3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlbGVjdGlvbjtcbiIsImltcG9ydCBjcmVhdG9yIGZyb20gXCIuLi9jcmVhdG9yLmpzXCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpLFxuICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBzZWxlY3RvcihiZWZvcmUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiooKSB7XG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB5aWVsZCBub2RlO1xuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgaWYgKHR5cGVvZiBvbmVudGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlbnRlciA9IG9uZW50ZXIoZW50ZXIpO1xuICAgIGlmIChlbnRlcikgZW50ZXIgPSBlbnRlci5zZWxlY3Rpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBlbnRlciA9IGVudGVyLmFwcGVuZChvbmVudGVyICsgXCJcIik7XG4gIH1cbiAgaWYgKG9udXBkYXRlICE9IG51bGwpIHtcbiAgICB1cGRhdGUgPSBvbnVwZGF0ZSh1cGRhdGUpO1xuICAgIGlmICh1cGRhdGUpIHVwZGF0ZSA9IHVwZGF0ZS5zZWxlY3Rpb24oKTtcbiAgfVxuICBpZiAob25leGl0ID09IG51bGwpIGV4aXQucmVtb3ZlKCk7IGVsc2Ugb25leGl0KGV4aXQpO1xuICByZXR1cm4gZW50ZXIgJiYgdXBkYXRlID8gZW50ZXIubWVyZ2UodXBkYXRlKS5vcmRlcigpIDogdXBkYXRlO1xufVxuIiwiZnVuY3Rpb24gbG93ZXIoKSB7XG4gIGlmICh0aGlzLnByZXZpb3VzU2libGluZykgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKGxvd2VyKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBjb250ZXh0LnNlbGVjdGlvbiA/IGNvbnRleHQuc2VsZWN0aW9uKCkgOiBjb250ZXh0O1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xufVxuIiwiZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQsIHRoaXMuX19kYXRhX18pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uO1xuICAgIGlmICghb24pIHJldHVybjtcbiAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAobyA9IG9uW2pdLCAoIXR5cGVuYW1lLnR5cGUgfHwgby50eXBlID09PSB0eXBlbmFtZS50eXBlKSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uWysraV0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKytpKSBvbi5sZW5ndGggPSBpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BZGQodHlwZW5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb24sIG8sIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKHZhbHVlKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLm9wdGlvbnMgPSBvcHRpb25zKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgb3B0aW9uczogb3B0aW9uc307XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuIiwiZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2VsZWN0b3IgZnJvbSBcIi4uL3NlbGVjdG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgYXJyYXkgZnJvbSBcIi4uL2FycmF5LmpzXCI7XG5pbXBvcnQgc2VsZWN0b3JBbGwgZnJvbSBcIi4uL3NlbGVjdG9yQWxsLmpzXCI7XG5cbmZ1bmN0aW9uIGFycmF5QWxsKHNlbGVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFycmF5KHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ID09PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IGFycmF5QWxsKHNlbGVjdCk7XG4gIGVsc2Ugc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzdWJncm91cHMucHVzaChzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCBwYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmluZCA9IEFycmF5LnByb3RvdHlwZS5maW5kO1xuXG5mdW5jdGlvbiBjaGlsZEZpbmQobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaW5kLmNhbGwodGhpcy5jaGlsZHJlbiwgbWF0Y2gpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjaGlsZEZpcnN0KCkge1xuICByZXR1cm4gdGhpcy5maXJzdEVsZW1lbnRDaGlsZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KG1hdGNoID09IG51bGwgPyBjaGlsZEZpcnN0XG4gICAgICA6IGNoaWxkRmluZCh0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyO1xuXG5mdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuRmlsdGVyKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcy5jaGlsZHJlbiwgbWF0Y2gpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3RBbGwobWF0Y2ggPT0gbnVsbCA/IGNoaWxkcmVuXG4gICAgICA6IGNoaWxkcmVuRmlsdGVyKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcykgKytzaXplOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiBzaXplO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyZShhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzb3J0Z3JvdXAgPSBzb3J0Z3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzb3J0Z3JvdXBzLCB0aGlzLl9wYXJlbnRzKS5vcmRlcigpO1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih1cGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSh1cGRhdGUubGVuZ3RoKTtcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgIDogc3R5bGVDb25zdGFudCkobmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKVxuICAgICAgOiBzdHlsZVZhbHVlKHRoaXMubm9kZSgpLCBuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0eWxlVmFsdWUobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpXG4gICAgICB8fCBkZWZhdWx0Vmlldyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG59XG4iLCJmdW5jdGlvbiB0ZXh0UmVtb3ZlKCkge1xuICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHRleHRGdW5jdGlvblxuICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufVxuIiwiZnVuY3Rpb24gbm9uZSgpIHt9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gbm9uZSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9O1xufVxuIiwiZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBlbXB0eSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgbGV0IHNvdXJjZUV2ZW50O1xuICB3aGlsZSAoc291cmNlRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudCkgZXZlbnQgPSBzb3VyY2VFdmVudDtcbiAgcmV0dXJuIGV2ZW50O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIC8vIG5vZGUgaXMgYSBOb2RlXG4gICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICB8fCBub2RlLmRlZmF1bHRWaWV3OyAvLyBub2RlIGlzIGEgRG9jdW1lbnRcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHthYnMsIGFjb3MsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgbWF4LCBtaW4sIHBpLCBzaW4sIHNxcnQsIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuXG5mdW5jdGlvbiBhcmNJbm5lclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLmlubmVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNPdXRlclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLm91dGVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNTdGFydEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjRW5kQW5nbGUoZCkge1xuICByZXR1cm4gZC5lbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjUGFkQW5nbGUoZCkge1xuICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlOyAvLyBOb3RlOiBvcHRpb25hbCFcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgeDEwID0geDEgLSB4MCwgeTEwID0geTEgLSB5MCxcbiAgICAgIHgzMiA9IHgzIC0geDIsIHkzMiA9IHkzIC0geTIsXG4gICAgICB0ID0geTMyICogeDEwIC0geDMyICogeTEwO1xuICBpZiAodCAqIHQgPCBlcHNpbG9uKSByZXR1cm47XG4gIHQgPSAoeDMyICogKHkwIC0geTIpIC0geTMyICogKHgwIC0geDIpKSAvIHQ7XG4gIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xufVxuXG4vLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtTGluZUludGVyc2VjdGlvbi5odG1sXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICB2YXIgeDAxID0geDAgLSB4MSxcbiAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIHNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSxcbiAgICAgIG94ID0gbG8gKiB5MDEsXG4gICAgICBveSA9IC1sbyAqIHgwMSxcbiAgICAgIHgxMSA9IHgwICsgb3gsXG4gICAgICB5MTEgPSB5MCArIG95LFxuICAgICAgeDEwID0geDEgKyBveCxcbiAgICAgIHkxMCA9IHkxICsgb3ksXG4gICAgICB4MDAgPSAoeDExICsgeDEwKSAvIDIsXG4gICAgICB5MDAgPSAoeTExICsgeTEwKSAvIDIsXG4gICAgICBkeCA9IHgxMCAtIHgxMSxcbiAgICAgIGR5ID0geTEwIC0geTExLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIHIgPSByMSAtIHJjLFxuICAgICAgRCA9IHgxMSAqIHkxMCAtIHgxMCAqIHkxMSxcbiAgICAgIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIHNxcnQobWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLFxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLFxuICAgICAgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxuICAgICAgZHgwID0gY3gwIC0geDAwLFxuICAgICAgZHkwID0gY3kwIC0geTAwLFxuICAgICAgZHgxID0gY3gxIC0geDAwLFxuICAgICAgZHkxID0gY3kxIC0geTAwO1xuXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcblxuICByZXR1cm4ge1xuICAgIGN4OiBjeDAsXG4gICAgY3k6IGN5MCxcbiAgICB4MDE6IC1veCxcbiAgICB5MDE6IC1veSxcbiAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcbiAgICB5MTE6IGN5MCAqIChyMSAvIHIgLSAxKVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gY29uc3RhbnQoMCksXG4gICAgICBwYWRSYWRpdXMgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGFyY0VuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgcGF0aCA9IHdpdGhQYXRoKGFyYyk7XG5cbiAgZnVuY3Rpb24gYXJjKCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIHIsXG4gICAgICAgIHIwID0gK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIxID0gK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGRhID0gYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgIGVsc2UgaWYgKGRhID4gdGF1IC0gZXBzaWxvbikge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MoYTApLCByMSAqIHNpbihhMCkpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwLCBhMSwgIWN3KTtcbiAgICAgIGlmIChyMCA+IGVwc2lsb24pIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocjAgKiBjb3MoYTEpLCByMCAqIHNpbihhMSkpO1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEsIGEwLCBjdyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjdWxhciBvciBhbm51bGFyIHNlY3Rvcj9cbiAgICBlbHNlIHtcbiAgICAgIHZhciBhMDEgPSBhMCxcbiAgICAgICAgICBhMTEgPSBhMSxcbiAgICAgICAgICBhMDAgPSBhMCxcbiAgICAgICAgICBhMTAgPSBhMSxcbiAgICAgICAgICBkYTAgPSBkYSxcbiAgICAgICAgICBkYTEgPSBkYSxcbiAgICAgICAgICBhcCA9IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLyAyLFxuICAgICAgICAgIHJwID0gKGFwID4gZXBzaWxvbikgJiYgKHBhZFJhZGl1cyA/ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNxcnQocjAgKiByMCArIHIxICogcjEpKSxcbiAgICAgICAgICByYyA9IG1pbihhYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICAgIHJjMCA9IHJjLFxuICAgICAgICAgIHJjMSA9IHJjLFxuICAgICAgICAgIHQwLFxuICAgICAgICAgIHQxO1xuXG4gICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cbiAgICAgIGlmIChycCA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHAwID0gYXNpbihycCAvIHIwICogc2luKGFwKSksXG4gICAgICAgICAgICBwMSA9IGFzaW4ocnAgLyByMSAqIHNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbikgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICBlbHNlIGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MDEgPSByMSAqIGNvcyhhMDEpLFxuICAgICAgICAgIHkwMSA9IHIxICogc2luKGEwMSksXG4gICAgICAgICAgeDEwID0gcjAgKiBjb3MoYTEwKSxcbiAgICAgICAgICB5MTAgPSByMCAqIHNpbihhMTApO1xuXG4gICAgICAvLyBBcHBseSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBpZiAocmMgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciB4MTEgPSByMSAqIGNvcyhhMTEpLFxuICAgICAgICAgICAgeTExID0gcjEgKiBzaW4oYTExKSxcbiAgICAgICAgICAgIHgwMCA9IHIwICogY29zKGEwMCksXG4gICAgICAgICAgICB5MDAgPSByMCAqIHNpbihhMDApLFxuICAgICAgICAgICAgb2M7XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIGNvcm5lciByYWRpdXMgYWNjb3JkaW5nIHRvIHRoZSBzZWN0b3IgYW5nbGUuIElmIHRoaXNcbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGZhaWxzLCBpdOKAmXMgcHJvYmFibHkgYmVjYXVzZSB0aGUgYXJjIGlzIHRvbyBzbWFsbCwgc29cbiAgICAgICAgLy8gZGlzYWJsZSB0aGUgY29ybmVyIHJhZGl1cyBlbnRpcmVseS5cbiAgICAgICAgaWYgKGRhIDwgcGkpIHtcbiAgICAgICAgICBpZiAob2MgPSBpbnRlcnNlY3QoeDAxLCB5MDEsIHgwMCwgeTAwLCB4MTEsIHkxMSwgeDEwLCB5MTApKSB7XG4gICAgICAgICAgICB2YXIgYXggPSB4MDEgLSBvY1swXSxcbiAgICAgICAgICAgICAgICBheSA9IHkwMSAtIG9jWzFdLFxuICAgICAgICAgICAgICAgIGJ4ID0geDExIC0gb2NbMF0sXG4gICAgICAgICAgICAgICAgYnkgPSB5MTEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgICBrYyA9IDEgLyBzaW4oYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKHNxcnQoYXggKiBheCArIGF5ICogYXkpICogc3FydChieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLFxuICAgICAgICAgICAgICAgIGxjID0gc3FydChvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgICByYzAgPSBtaW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICAgIHJjMSA9IG1pbihyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYzAgPSByYzEgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIG91dGVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpLCBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAxLCBhMTEsICFjdyk7XG5cbiAgICAgIC8vIElzIHRoZXJlIG5vIGlubmVyIHJpbmcsIGFuZCBpdOKAmXMgYSBjaXJjdWxhciBzZWN0b3I/XG4gICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XG4gICAgICBpZiAoIShyMCA+IGVwc2lsb24pIHx8ICEoZGEwID4gZXBzaWxvbikpIGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBpbm5lciByaW5nIChvciBwb2ludCkgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDEwLCB5MTAsIHgxMSwgeTExLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgwMSwgeTAxLCB4MDAsIHkwMCwgcjAsIC1yYzAsIGN3KTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMwIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCBjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzAsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBpbm5lciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMixcbiAgICAgICAgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIHBpIC8gMjtcbiAgICByZXR1cm4gW2NvcyhhKSAqIHIsIHNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9jdXJ2ZS9saW5lYXIuanNcIjtcbmltcG9ydCBsaW5lIGZyb20gXCIuL2xpbmUuanNcIjtcbmltcG9ydCB7d2l0aFBhdGh9IGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4MCwgeTAsIHkxKSB7XG4gIHZhciB4MSA9IG51bGwsXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsLFxuICAgICAgcGF0aCA9IHdpdGhQYXRoKGFyZWEpO1xuXG4gIHgwID0gdHlwZW9mIHgwID09PSBcImZ1bmN0aW9uXCIgPyB4MCA6ICh4MCA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WCA6IGNvbnN0YW50KCt4MCk7XG4gIHkwID0gdHlwZW9mIHkwID09PSBcImZ1bmN0aW9uXCIgPyB5MCA6ICh5MCA9PT0gdW5kZWZpbmVkKSA/IGNvbnN0YW50KDApIDogY29uc3RhbnQoK3kwKTtcbiAgeTEgPSB0eXBlb2YgeTEgPT09IFwiZnVuY3Rpb25cIiA/IHkxIDogKHkxID09PSB1bmRlZmluZWQpID8gcG9pbnRZIDogY29uc3RhbnQoK3kxKTtcblxuICBmdW5jdGlvbiBhcmVhKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgbiA9IChkYXRhID0gYXJyYXkoZGF0YSkpLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHtcbiAgICAgICAgICBqID0gaTtcbiAgICAgICAgICBvdXRwdXQuYXJlYVN0YXJ0KCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgweltrXSwgeTB6W2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQuYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIHtcbiAgICAgICAgeDB6W2ldID0gK3gwKGQsIGksIGRhdGEpLCB5MHpbaV0gPSAreTAoZCwgaSwgZGF0YSk7XG4gICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICByZXR1cm4gbGluZSgpLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpLmNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgxO1xuICB9O1xuXG4gIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTE7XG4gIH07XG5cbiAgYXJlYS5saW5lWDAgPVxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTApO1xuICB9O1xuXG4gIGFyZWEubGluZVkxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gIH07XG5cbiAgYXJlYS5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGFyZWEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBhcmVhLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJlYTtcbn1cbiIsImV4cG9ydCB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4geFxuICAgID8geCAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oeCk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb25zdGFudCgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCBwb2ludFJhZGlhbCBmcm9tIFwiLi4vcG9pbnRSYWRpYWwuanNcIjtcblxuY2xhc3MgQnVtcCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHgpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl94ID0geDtcbiAgfVxuICBhcmVhU3RhcnQoKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH1cbiAgYXJlYUVuZCgpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9XG4gIGxpbmVTdGFydCgpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH1cbiAgbGluZUVuZCgpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9XG4gIHBvaW50KHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBpZiAodGhpcy5fbGluZSkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIGVsc2UgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX3gpIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh0aGlzLl94MCA9ICh0aGlzLl94MCArIHgpIC8gMiwgdGhpcy5feTAsIHRoaXMuX3gwLCB5LCB4LCB5KTtcbiAgICAgICAgZWxzZSB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8odGhpcy5feDAsIHRoaXMuX3kwID0gKHRoaXMuX3kwICsgeSkgLyAyLCB4LCB0aGlzLl95MCwgeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94MCA9IHgsIHRoaXMuX3kwID0geTtcbiAgfVxufVxuXG5jbGFzcyBCdW1wUmFkaWFsIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB9XG4gIGxpbmVTdGFydCgpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH1cbiAgbGluZUVuZCgpIHt9XG4gIHBvaW50KHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAodGhpcy5fcG9pbnQgPT09IDApIHtcbiAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcDAgPSBwb2ludFJhZGlhbCh0aGlzLl94MCwgdGhpcy5feTApO1xuICAgICAgY29uc3QgcDEgPSBwb2ludFJhZGlhbCh0aGlzLl94MCwgdGhpcy5feTAgPSAodGhpcy5feTAgKyB5KSAvIDIpO1xuICAgICAgY29uc3QgcDIgPSBwb2ludFJhZGlhbCh4LCB0aGlzLl95MCk7XG4gICAgICBjb25zdCBwMyA9IHBvaW50UmFkaWFsKHgsIHkpO1xuICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oLi4ucDApO1xuICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKC4uLnAxLCAuLi5wMiwgLi4ucDMpO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHgsIHRoaXMuX3kwID0geTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVtcFgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJ1bXAoY29udGV4dCwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidW1wWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQnVtcChjb250ZXh0LCBmYWxzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidW1wUmFkaWFsKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCdW1wUmFkaWFsKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gTGluZWFyKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhci5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgZGVmYXVsdDogdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhcihjb250ZXh0KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICByZXR1cm4gZDtcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyLmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChsaW5lKTtcblxuICB4ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAoeCA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WCA6IGNvbnN0YW50KHgpO1xuICB5ID0gdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkgOiAoeSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WSA6IGNvbnN0YW50KHkpO1xuXG4gIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gKGRhdGEgPSBhcnJheShkYXRhKSkubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXI7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkgb3V0cHV0LnBvaW50KCt4KGQsIGksIGRhdGEpLCAreShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeDtcbiAgfTtcblxuICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHk7XG4gIH07XG5cbiAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGxpbmUpIDogZGVmaW5lZDtcbiAgfTtcblxuICBsaW5lLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGxpbmUpIDogY3VydmU7XG4gIH07XG5cbiAgbGluZS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmU7XG59XG4iLCJpbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQge2J1bXBYLCBidW1wWSwgYnVtcFJhZGlhbH0gZnJvbSBcIi4vY3VydmUvYnVtcC5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50LmpzXCI7XG5cbmZ1bmN0aW9uIGxpbmtTb3VyY2UoZCkge1xuICByZXR1cm4gZC5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGxpbmtUYXJnZXQoZCkge1xuICByZXR1cm4gZC50YXJnZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rKGN1cnZlKSB7XG4gIGxldCBzb3VyY2UgPSBsaW5rU291cmNlLFxuICAgICAgdGFyZ2V0ID0gbGlua1RhcmdldCxcbiAgICAgIHggPSBwb2ludFgsXG4gICAgICB5ID0gcG9pbnRZLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBvdXRwdXQgPSBudWxsLFxuICAgICAgcGF0aCA9IHdpdGhQYXRoKGxpbmspO1xuXG4gIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgbGV0IGJ1ZmZlcjtcbiAgICBjb25zdCBhcmd2ID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNvbnN0IHMgPSBzb3VyY2UuYXBwbHkodGhpcywgYXJndik7XG4gICAgY29uc3QgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICBhcmd2WzBdID0gcywgb3V0cHV0LnBvaW50KCt4LmFwcGx5KHRoaXMsIGFyZ3YpLCAreS5hcHBseSh0aGlzLCBhcmd2KSk7XG4gICAgYXJndlswXSA9IHQsIG91dHB1dC5wb2ludCgreC5hcHBseSh0aGlzLCBhcmd2KSwgK3kuYXBwbHkodGhpcywgYXJndikpO1xuICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmsuc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvdXJjZSA9IF8sIGxpbmspIDogc291cmNlO1xuICB9O1xuXG4gIGxpbmsudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIGxpbmspIDogdGFyZ2V0O1xuICB9O1xuXG4gIGxpbmsueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeDtcbiAgfTtcblxuICBsaW5rLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHk7XG4gIH07XG5cbiAgbGluay5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5rKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbms7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rSG9yaXpvbnRhbCgpIHtcbiAgcmV0dXJuIGxpbmsoYnVtcFgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlua1ZlcnRpY2FsKCkge1xuICByZXR1cm4gbGluayhidW1wWSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rUmFkaWFsKCkge1xuICBjb25zdCBsID0gbGluayhidW1wUmFkaWFsKTtcbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG4gIHJldHVybiBsO1xufVxuIiwiZXhwb3J0IGNvbnN0IGFicyA9IE1hdGguYWJzO1xuZXhwb3J0IGNvbnN0IGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCBjb25zdCBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCBjb25zdCBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCBjb25zdCBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCBjb25zdCBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG5leHBvcnQgY29uc3QgZXBzaWxvbiA9IDFlLTEyO1xuZXhwb3J0IGNvbnN0IHBpID0gTWF0aC5QSTtcbmV4cG9ydCBjb25zdCBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgY29uc3QgdGF1ID0gMiAqIHBpO1xuXG5leHBvcnQgZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoUGF0aChzaGFwZSkge1xuICBsZXQgZGlnaXRzID0gMztcblxuICBzaGFwZS5kaWdpdHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGlnaXRzO1xuICAgIGlmIChfID09IG51bGwpIHtcbiAgICAgIGRpZ2l0cyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGQgPSBNYXRoLmZsb29yKF8pO1xuICAgICAgaWYgKCEoZCA+PSAwKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGludmFsaWQgZGlnaXRzOiAke199YCk7XG4gICAgICBkaWdpdHMgPSBkO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cbiAgcmV0dXJuICgpID0+IG5ldyBQYXRoKGRpZ2l0cyk7XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGRlc2NlbmRpbmcgZnJvbSBcIi4vZGVzY2VuZGluZy5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQge3RhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gaWRlbnRpdHksXG4gICAgICBzb3J0VmFsdWVzID0gZGVzY2VuZGluZyxcbiAgICAgIHNvcnQgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGNvbnN0YW50KDApLFxuICAgICAgZW5kQW5nbGUgPSBjb25zdGFudCh0YXUpLFxuICAgICAgcGFkQW5nbGUgPSBjb25zdGFudCgwKTtcblxuICBmdW5jdGlvbiBwaWUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gKGRhdGEgPSBhcnJheShkYXRhKSkubGVuZ3RoLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBpbmRleCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYXJjcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYTAgPSArc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBkYSA9IE1hdGgubWluKHRhdSwgTWF0aC5tYXgoLXRhdSwgZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGEwKSksXG4gICAgICAgIGExLFxuICAgICAgICBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICB2O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh2ID0gYXJjc1tpbmRleFtpXSA9IGldID0gK3ZhbHVlKGRhdGFbaV0sIGksIGRhdGEpKSA+IDApIHtcbiAgICAgICAgc3VtICs9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWxseSBzb3J0IHRoZSBhcmNzIGJ5IHByZXZpb3VzbHktY29tcHV0ZWQgdmFsdWVzIG9yIGJ5IGRhdGEuXG4gICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0VmFsdWVzKGFyY3NbaV0sIGFyY3Nbal0pOyB9KTtcbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhcmNzISBUaGV5IGFyZSBzdG9yZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEncyBvcmRlci5cbiAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcbiAgICAgIGogPSBpbmRleFtpXSwgdiA9IGFyY3Nbal0sIGExID0gYTAgKyAodiA+IDAgPyB2ICogayA6IDApICsgcGEsIGFyY3Nbal0gPSB7XG4gICAgICAgIGRhdGE6IGRhdGFbal0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyY3M7XG4gIH1cblxuICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHZhbHVlO1xuICB9O1xuXG4gIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRWYWx1ZXMgPSBfLCBzb3J0ID0gbnVsbCwgcGllKSA6IHNvcnRWYWx1ZXM7XG4gIH07XG5cbiAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNvcnRWYWx1ZXMgPSBudWxsLCBwaWUpIDogc29ydDtcbiAgfTtcblxuICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBwYWRBbmdsZTtcbiAgfTtcblxuICByZXR1cm4gcGllO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIFsoeSA9ICt5KSAqIE1hdGguY29zKHggLT0gTWF0aC5QSSAvIDIpLCB5ICogTWF0aC5zaW4oeCldO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQgYXN0ZXJpc2sgZnJvbSBcIi4vc3ltYm9sL2FzdGVyaXNrLmpzXCI7XG5pbXBvcnQgY2lyY2xlIGZyb20gXCIuL3N5bWJvbC9jaXJjbGUuanNcIjtcbmltcG9ydCBjcm9zcyBmcm9tIFwiLi9zeW1ib2wvY3Jvc3MuanNcIjtcbmltcG9ydCBkaWFtb25kIGZyb20gXCIuL3N5bWJvbC9kaWFtb25kLmpzXCI7XG5pbXBvcnQgZGlhbW9uZDIgZnJvbSBcIi4vc3ltYm9sL2RpYW1vbmQyLmpzXCI7XG5pbXBvcnQgcGx1cyBmcm9tIFwiLi9zeW1ib2wvcGx1cy5qc1wiO1xuaW1wb3J0IHNxdWFyZSBmcm9tIFwiLi9zeW1ib2wvc3F1YXJlLmpzXCI7XG5pbXBvcnQgc3F1YXJlMiBmcm9tIFwiLi9zeW1ib2wvc3F1YXJlMi5qc1wiO1xuaW1wb3J0IHN0YXIgZnJvbSBcIi4vc3ltYm9sL3N0YXIuanNcIjtcbmltcG9ydCB0cmlhbmdsZSBmcm9tIFwiLi9zeW1ib2wvdHJpYW5nbGUuanNcIjtcbmltcG9ydCB0cmlhbmdsZTIgZnJvbSBcIi4vc3ltYm9sL3RyaWFuZ2xlMi5qc1wiO1xuaW1wb3J0IHd5ZSBmcm9tIFwiLi9zeW1ib2wvd3llLmpzXCI7XG5pbXBvcnQgdGltZXMgZnJvbSBcIi4vc3ltYm9sL3RpbWVzLmpzXCI7XG5cbi8vIFRoZXNlIHN5bWJvbHMgYXJlIGRlc2lnbmVkIHRvIGJlIGZpbGxlZC5cbmV4cG9ydCBjb25zdCBzeW1ib2xzRmlsbCA9IFtcbiAgY2lyY2xlLFxuICBjcm9zcyxcbiAgZGlhbW9uZCxcbiAgc3F1YXJlLFxuICBzdGFyLFxuICB0cmlhbmdsZSxcbiAgd3llXG5dO1xuXG4vLyBUaGVzZSBzeW1ib2xzIGFyZSBkZXNpZ25lZCB0byBiZSBzdHJva2VkICh3aXRoIGEgd2lkdGggb2YgMS41cHggYW5kIHJvdW5kIGNhcHMpLlxuZXhwb3J0IGNvbnN0IHN5bWJvbHNTdHJva2UgPSBbXG4gIGNpcmNsZSxcbiAgcGx1cyxcbiAgdGltZXMsXG4gIHRyaWFuZ2xlMixcbiAgYXN0ZXJpc2ssXG4gIHNxdWFyZTIsXG4gIGRpYW1vbmQyXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTeW1ib2wodHlwZSwgc2l6ZSkge1xuICBsZXQgY29udGV4dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgoc3ltYm9sKTtcblxuICB0eXBlID0gdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IHR5cGUgOiBjb25zdGFudCh0eXBlIHx8IGNpcmNsZSk7XG4gIHNpemUgPSB0eXBlb2Ygc2l6ZSA9PT0gXCJmdW5jdGlvblwiID8gc2l6ZSA6IGNvbnN0YW50KHNpemUgPT09IHVuZGVmaW5lZCA/IDY0IDogK3NpemUpO1xuXG4gIGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICBsZXQgYnVmZmVyO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgfTtcblxuICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN5bWJvbCkgOiBzaXplO1xuICB9O1xuXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHN5bWJvbDtcbn1cbiIsImltcG9ydCB7bWluLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5jb25zdCBzcXJ0MyA9IHNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSArIG1pbihzaXplIC8gMjgsIDAuNzUpKSAqIDAuNTk0MzY7XG4gICAgY29uc3QgdCA9IHIgLyAyO1xuICAgIGNvbnN0IHUgPSB0ICogc3FydDM7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgcik7XG4gICAgY29udGV4dC5saW5lVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubW92ZVRvKC11LCAtdCk7XG4gICAgY29udGV4dC5saW5lVG8odSwgdCk7XG4gICAgY29udGV4dC5tb3ZlVG8oLXUsIHQpO1xuICAgIGNvbnRleHQubGluZVRvKHUsIC10KTtcbiAgfVxufTtcbiIsImltcG9ydCB7cGksIHNxcnQsIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICBjb250ZXh0Lm1vdmVUbygtMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmNvbnN0IHRhbjMwID0gc3FydCgxIC8gMyk7XG5jb25zdCB0YW4zMF8yID0gdGFuMzAgKiAyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHkgPSBzcXJ0KHNpemUgLyB0YW4zMF8yKTtcbiAgICBjb25zdCB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplKSAqIDAuNjI2MjU7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAwKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHttaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAtIG1pbihzaXplIC8gNywgMikpICogMC44NzU1OTtcbiAgICBjb250ZXh0Lm1vdmVUbygtciwgMCk7XG4gICAgY29udGV4dC5saW5lVG8ociwgMCk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgcik7XG4gICAgY29udGV4dC5saW5lVG8oMCwgLXIpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHcgPSBzcXJ0KHNpemUpO1xuICAgIGNvbnN0IHggPSAtdyAvIDI7XG4gICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXcoY29udGV4dCwgc2l6ZSkge1xuICAgIGNvbnN0IHIgPSBzcXJ0KHNpemUpICogMC40NDMxO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtzaW4sIGNvcywgc3FydCwgcGksIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuY29uc3Qga2EgPSAwLjg5MDgxMzA5MTUyOTI4NTIyODEwO1xuY29uc3Qga3IgPSBzaW4ocGkgLyAxMCkgLyBzaW4oNyAqIHBpIC8gMTApO1xuY29uc3Qga3ggPSBzaW4odGF1IC8gMTApICoga3I7XG5jb25zdCBreSA9IC1jb3ModGF1IC8gMTApICoga3I7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAqIGthKTtcbiAgICBjb25zdCB4ID0ga3ggKiByO1xuICAgIGNvbnN0IHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICBjb25zdCBhID0gdGF1ICogaSAvIDU7XG4gICAgICBjb25zdCBjID0gY29zKGEpO1xuICAgICAgY29uc3QgcyA9IHNpbihhKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMgKiByLCAtYyAqIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge21pbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCByID0gc3FydChzaXplIC0gbWluKHNpemUgLyA2LCAxLjcpKSAqIDAuNjE4OTtcbiAgICBjb250ZXh0Lm1vdmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubW92ZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmNvbnN0IHNxcnQzID0gc3FydCgzKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCB5ID0gLXNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCB5ICogMik7XG4gICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmNvbnN0IHNxcnQzID0gc3FydCgzKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICBjb25zdCBzID0gc3FydChzaXplKSAqIDAuNjgyNDtcbiAgICBjb25zdCB0ID0gcyAgLyAyO1xuICAgIGNvbnN0IHUgPSAocyAqIHNxcnQzKSAvIDI7IC8vIGNvcyhNYXRoLlBJIC8gNilcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAtcyk7XG4gICAgY29udGV4dC5saW5lVG8odSwgdCk7XG4gICAgY29udGV4dC5saW5lVG8oLXUsIHQpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmNvbnN0IGMgPSAtMC41O1xuY29uc3QgcyA9IHNxcnQoMykgLyAyO1xuY29uc3QgayA9IDEgLyBzcXJ0KDEyKTtcbmNvbnN0IGEgPSAoayAvIDIgKyAxKSAqIDM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdyhjb250ZXh0LCBzaXplKSB7XG4gICAgY29uc3QgciA9IHNxcnQoc2l6ZSAvIGEpO1xuICAgIGNvbnN0IHgwID0gciAvIDIsIHkwID0gciAqIGs7XG4gICAgY29uc3QgeDEgPSB4MCwgeTEgPSByICogayArIHI7XG4gICAgY29uc3QgeDIgPSAteDEsIHkyID0geTE7XG4gICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwIC0gcyAqIHkwLCBzICogeDAgKyBjICogeTApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSAtIHMgKiB5MSwgcyAqIHgxICsgYyAqIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgLSBzICogeTIsIHMgKiB4MiArIGMgKiB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwICsgcyAqIHkwLCBjICogeTAgLSBzICogeDApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSArIHMgKiB5MSwgYyAqIHkxIC0gcyAqIHgxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgKyBzICogeTIsIGMgKiB5MiAtIHMgKiB4Mik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7VGltZXJ9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgZGVsYXkgPSBkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheTtcbiAgdC5yZXN0YXJ0KGVsYXBzZWQgPT4ge1xuICAgIHQuc3RvcCgpO1xuICAgIGNhbGxiYWNrKGVsYXBzZWQgKyBkZWxheSk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iLCJ2YXIgZnJhbWUgPSAwLCAvLyBpcyBhbiBhbmltYXRpb24gZnJhbWUgcGVuZGluZz9cbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XG4gICAgaW50ZXJ2YWwgPSAwLCAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG4gICAgcG9rZURlbGF5ID0gMTAwMCwgLy8gaG93IGZyZXF1ZW50bHkgd2UgY2hlY2sgZm9yIGNsb2NrIHNrZXdcbiAgICB0YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGNsb2NrTm93IHx8IChzZXRGcmFtZShjbGVhck5vdyksIGNsb2NrTm93ID0gY2xvY2subm93KCkgKyBjbG9ja1NrZXcpO1xufVxuXG5mdW5jdGlvbiBjbGVhck5vdygpIHtcbiAgY2xvY2tOb3cgPSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVGltZXIoKSB7XG4gIHRoaXMuX2NhbGwgPVxuICB0aGlzLl90aW1lID1cbiAgdGhpcy5fbmV4dCA9IG51bGw7XG59XG5cblRpbWVyLnByb3RvdHlwZSA9IHRpbWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRpbWVyLFxuICByZXN0YXJ0OiBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB0aW1lID0gKHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWUpICsgKGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5KTtcbiAgICBpZiAoIXRoaXMuX25leHQgJiYgdGFza1RhaWwgIT09IHRoaXMpIHtcbiAgICAgIGlmICh0YXNrVGFpbCkgdGFza1RhaWwuX25leHQgPSB0aGlzO1xuICAgICAgZWxzZSB0YXNrSGVhZCA9IHRoaXM7XG4gICAgICB0YXNrVGFpbCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2NhbGwgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBzbGVlcCgpO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2FsbCkge1xuICAgICAgdGhpcy5fY2FsbCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lID0gSW5maW5pdHk7XG4gICAgICBzbGVlcCgpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXJGbHVzaCgpIHtcbiAgbm93KCk7IC8vIEdldCB0aGUgY3VycmVudCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxuICB2YXIgdCA9IHRhc2tIZWFkLCBlO1xuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKHVuZGVmaW5lZCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQge1NDSEVEVUxFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGk7XG5cbiAgaWYgKHNjaGVkdWxlcykge1xuICAgIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oW1tub2RlXV0sIHJvb3QsIG5hbWUsICtpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGFjdGl2ZX0gZnJvbSBcIi4vYWN0aXZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJydXB0fSBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbiIsImltcG9ydCB7U1RBUlRJTkcsIEVORElORywgRU5ERUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGVtcHR5ID0gdHJ1ZSxcbiAgICAgIGk7XG5cbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcblxuICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuXG4gIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5uYW1lICE9PSBuYW1lKSB7IGVtcHR5ID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgYWN0aXZlID0gc2NoZWR1bGUuc3RhdGUgPiBTVEFSVElORyAmJiBzY2hlZHVsZS5zdGF0ZSA8IEVORElORztcbiAgICBzY2hlZHVsZS5zdGF0ZSA9IEVOREVEO1xuICAgIHNjaGVkdWxlLnRpbWVyLnN0b3AoKTtcbiAgICBzY2hlZHVsZS5vbi5jYWxsKGFjdGl2ZSA/IFwiaW50ZXJydXB0XCIgOiBcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzY2hlZHVsZS5pbmRleCwgc2NoZWR1bGUuZ3JvdXApO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gIH1cblxuICBpZiAoZW1wdHkpIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ludGVycnVwdCBmcm9tIFwiLi9pbnRlcnJ1cHQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdHJhbnNpdGlvbiBmcm9tIFwiLi90cmFuc2l0aW9uLmpzXCI7XG5cbnNlbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJydXB0ID0gc2VsZWN0aW9uX2ludGVycnVwdDtcbnNlbGVjdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbiA9IHNlbGVjdGlvbl90cmFuc2l0aW9uO1xuIiwiaW1wb3J0IGludGVycnVwdCBmcm9tIFwiLi4vaW50ZXJydXB0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICBpbnRlcnJ1cHQodGhpcywgbmFtZSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4uL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHtlYXNlQ3ViaWNJbk91dH0gZnJvbSBcImQzLWVhc2VcIjtcbmltcG9ydCB7bm93fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGRlZmF1bHRUaW1pbmcgPSB7XG4gIHRpbWU6IG51bGwsIC8vIFNldCBvbiB1c2UuXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogMjUwLFxuICBlYXNlOiBlYXNlQ3ViaWNJbk91dFxufTtcblxuZnVuY3Rpb24gaW5oZXJpdChub2RlLCBpZCkge1xuICB2YXIgdGltaW5nO1xuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xuICAgIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyYW5zaXRpb24gJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aW1pbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGlkLFxuICAgICAgdGltaW5nO1xuXG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xuICAgIGlkID0gbmFtZS5faWQsIG5hbWUgPSBuYW1lLl9uYW1lO1xuICB9IGVsc2Uge1xuICAgIGlkID0gbmV3SWQoKSwgKHRpbWluZyA9IGRlZmF1bHRUaW1pbmcpLnRpbWUgPSBub3coKSwgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpLCBncm91cCwgdGltaW5nIHx8IGluaGVyaXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtU3ZnIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKSwgaSA9IGZ1bGxuYW1lID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKShmdWxsbmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcImF0dHIuXCIgKyBuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHZhbHVlID09IG51bGwgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKShmdWxsbmFtZSlcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKGZ1bGxuYW1lLCBpLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlKG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCBpLmNhbGwodGhpcywgdCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGVOUyhmdWxsbmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGtleSA9IFwiYXR0ci5cIiArIG5hbWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIChmdWxsbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBpbml0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVsYXlDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkZWxheUZ1bmN0aW9uXG4gICAgICAgICAgOiBkZWxheUNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kZWxheTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkdXJhdGlvbkZ1bmN0aW9uXG4gICAgICAgICAgOiBkdXJhdGlvbkNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kdXJhdGlvbjtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGVhc2VDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKGVhc2VDb25zdGFudChpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5lYXNlO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGVhc2VWYXJ5aW5nKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0eXBlb2YgdiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLmVhY2goZWFzZVZhcnlpbmcodGhpcy5faWQsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBvbjAsIG9uMSwgdGhhdCA9IHRoaXMsIGlkID0gdGhhdC5faWQsIHNpemUgPSB0aGF0LnNpemUoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBjYW5jZWwgPSB7dmFsdWU6IHJlamVjdH0sXG4gICAgICAgIGVuZCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7IGlmICgtLXNpemUgPT09IDApIHJlc29sdmUoKTsgfX07XG5cbiAgICB0aGF0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgICBpZiAob24gIT09IG9uMCkge1xuICAgICAgICBvbjEgPSAob24wID0gb24pLmNvcHkoKTtcbiAgICAgICAgb24xLl8uY2FuY2VsLnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uaW50ZXJydXB0LnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uZW5kLnB1c2goZW5kKTtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGUub24gPSBvbjE7XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgc2VsZWN0aW9uIHdhcyBlbXB0eSwgcmVzb2x2ZSBlbmQgaW1tZWRpYXRlbHlcbiAgICBpZiAoc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7bWF0Y2hlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0clR3ZWVuIGZyb20gXCIuL2F0dHJUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZGVsYXkgZnJvbSBcIi4vZGVsYXkuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2R1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlIGZyb20gXCIuL2Vhc2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nIGZyb20gXCIuL2Vhc2VWYXJ5aW5nLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9maWx0ZXIgZnJvbSBcIi4vZmlsdGVyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdCBmcm9tIFwiLi9zZWxlY3QuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3NlbGVjdGlvbiBmcm9tIFwiLi9zZWxlY3Rpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlIGZyb20gXCIuL3N0eWxlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZVR3ZWVuIGZyb20gXCIuL3N0eWxlVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dFR3ZWVuIGZyb20gXCIuL3RleHRUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHJhbnNpdGlvbiBmcm9tIFwiLi90cmFuc2l0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90d2VlbiBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZW5kIGZyb20gXCIuL2VuZC5qc1wiO1xuXG52YXIgaWQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNpdGlvbihncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9pZCA9IGlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2l0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdGlvbigpLnRyYW5zaXRpb24obmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdJZCgpIHtcbiAgcmV0dXJuICsraWQ7XG59XG5cbnZhciBzZWxlY3Rpb25fcHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZTtcblxuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB0cmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zaXRpb24sXG4gIHNlbGVjdDogdHJhbnNpdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogdHJhbnNpdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZHJlbixcbiAgZmlsdGVyOiB0cmFuc2l0aW9uX2ZpbHRlcixcbiAgbWVyZ2U6IHRyYW5zaXRpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25fdHJhbnNpdGlvbixcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiB0cmFuc2l0aW9uX29uLFxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXG4gIGF0dHJUd2VlbjogdHJhbnNpdGlvbl9hdHRyVHdlZW4sXG4gIHN0eWxlOiB0cmFuc2l0aW9uX3N0eWxlLFxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXG4gIHRleHQ6IHRyYW5zaXRpb25fdGV4dCxcbiAgdGV4dFR3ZWVuOiB0cmFuc2l0aW9uX3RleHRUd2VlbixcbiAgcmVtb3ZlOiB0cmFuc2l0aW9uX3JlbW92ZSxcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXG4gIGRlbGF5OiB0cmFuc2l0aW9uX2RlbGF5LFxuICBkdXJhdGlvbjogdHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlLFxuICBlYXNlVmFyeWluZzogdHJhbnNpdGlvbl9lYXNlVmFyeWluZyxcbiAgZW5kOiB0cmFuc2l0aW9uX2VuZCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXVxufTtcbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZU51bWJlciwgaW50ZXJwb2xhdGVSZ2IsIGludGVycG9sYXRlU3RyaW5nfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYztcbiAgcmV0dXJuICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiA/IGludGVycG9sYXRlTnVtYmVyXG4gICAgICA6IGIgaW5zdGFuY2VvZiBjb2xvciA/IGludGVycG9sYXRlUmdiXG4gICAgICA6IChjID0gY29sb3IoYikpID8gKGIgPSBjLCBpbnRlcnBvbGF0ZVJnYilcbiAgICAgIDogaW50ZXJwb2xhdGVTdHJpbmcpKGEsIGIpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uLl9pZCAhPT0gdGhpcy5faWQpIHRocm93IG5ldyBFcnJvcjtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gdHJhbnNpdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0LCBpbml0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBzdGFydChuYW1lKSB7XG4gIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gIXQgfHwgdCA9PT0gXCJzdGFydFwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9uMCwgb24xLCBzaXQgPSBzdGFydChuYW1lKSA/IGluaXQgOiBzZXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzaXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDJcbiAgICAgID8gZ2V0KHRoaXMubm9kZSgpLCBpZCkub24ub24obmFtZSlcbiAgICAgIDogdGhpcy5lYWNoKG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmVGdW5jdGlvbihpZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX190cmFuc2l0aW9uKSBpZiAoK2kgIT09IGlkKSByZXR1cm47XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub24oXCJlbmQucmVtb3ZlXCIsIHJlbW92ZUZ1bmN0aW9uKHRoaXMuX2lkKSk7XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7dGltZXIsIHRpbWVvdXR9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZW1wdHlPbiA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJjYW5jZWxcIiwgXCJpbnRlcnJ1cHRcIik7XG52YXIgZW1wdHlUd2VlbiA9IFtdO1xuXG5leHBvcnQgdmFyIENSRUFURUQgPSAwO1xuZXhwb3J0IHZhciBTQ0hFRFVMRUQgPSAxO1xuZXhwb3J0IHZhciBTVEFSVElORyA9IDI7XG5leHBvcnQgdmFyIFNUQVJURUQgPSAzO1xuZXhwb3J0IHZhciBSVU5OSU5HID0gNDtcbmV4cG9ydCB2YXIgRU5ESU5HID0gNTtcbmV4cG9ydCB2YXIgRU5ERUQgPSA2O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lLCBpZCwgaW5kZXgsIGdyb3VwLCB0aW1pbmcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtcbiAgZWxzZSBpZiAoaWQgaW4gc2NoZWR1bGVzKSByZXR1cm47XG4gIGNyZWF0ZShub2RlLCBpZCwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgaW5kZXg6IGluZGV4LCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgb246IGVtcHR5T24sXG4gICAgdHdlZW46IGVtcHR5VHdlZW4sXG4gICAgdGltZTogdGltaW5nLnRpbWUsXG4gICAgZGVsYXk6IHRpbWluZy5kZWxheSxcbiAgICBkdXJhdGlvbjogdGltaW5nLmR1cmF0aW9uLFxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBDUkVBVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzY2hlZHVsZWRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBTVEFSVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBydW5uaW5nXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGUgfHwgIShzY2hlZHVsZSA9IHNjaGVkdWxlW2lkXSkpIHRocm93IG5ldyBFcnJvcihcInRyYW5zaXRpb24gbm90IGZvdW5kXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShub2RlLCBpZCwgc2VsZikge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICB0d2VlbjtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzZWxmIHRpbWVyIHdoZW4gdGhlIHRyYW5zaXRpb24gaXMgY3JlYXRlZC5cbiAgLy8gTm90ZSB0aGUgYWN0dWFsIGRlbGF5IGlzIG5vdCBrbm93biB1bnRpbCB0aGUgZmlyc3QgY2FsbGJhY2shXG4gIHNjaGVkdWxlc1tpZF0gPSBzZWxmO1xuICBzZWxmLnRpbWVyID0gdGltZXIoc2NoZWR1bGUsIDAsIHNlbGYudGltZSk7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgIHNlbGYuc3RhdGUgPSBTQ0hFRFVMRUQ7XG4gICAgc2VsZi50aW1lci5yZXN0YXJ0KHN0YXJ0LCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuXG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgZGVsYXkgaXMgbGVzcyB0aGFuIG91ciBmaXJzdCBzbGVlcCwgc3RhcnQgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHNlbGYuZGVsYXkgPD0gZWxhcHNlZCkgc3RhcnQoZWxhcHNlZCAtIHNlbGYuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgIHZhciBpLCBqLCBuLCBvO1xuXG4gICAgLy8gSWYgdGhlIHN0YXRlIGlzIG5vdCBTQ0hFRFVMRUQsIHRoZW4gd2UgcHJldmlvdXNseSBlcnJvcmVkIG9uIHN0YXJ0LlxuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTQ0hFRFVMRUQpIHJldHVybiBzdG9wKCk7XG5cbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBvID0gc2NoZWR1bGVzW2ldO1xuICAgICAgaWYgKG8ubmFtZSAhPT0gc2VsZi5uYW1lKSBjb250aW51ZTtcblxuICAgICAgLy8gV2hpbGUgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgc3RhcnRpbmcgdHJhbnNpdGlvbiBkdXJpbmcgdGhpcyBmcmFtZSxcbiAgICAgIC8vIGRlZmVyIHN0YXJ0aW5nIGFuIGludGVycnVwdGluZyB0cmFuc2l0aW9uIHVudGlsIHRoYXQgdHJhbnNpdGlvbiBoYXMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcbiAgICAgIGlmIChvLnN0YXRlID09PSBTVEFSVEVEKSByZXR1cm4gdGltZW91dChzdGFydCk7XG5cbiAgICAgIC8vIEludGVycnVwdCB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGlmIGFueS5cbiAgICAgIGlmIChvLnN0YXRlID09PSBSVU5OSU5HKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGFueSBwcmUtZW1wdGVkIHRyYW5zaXRpb25zLlxuICAgICAgZWxzZSBpZiAoK2kgPCBpZCkge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmZXIgdGhlIGZpcnN0IHRpY2sgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lOyBzZWUgZDMvZDMjMTU3Ni5cbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIHNjaGVkdWxlZCBiZWZvcmUgdGhlIHN0YXJ0IGV2ZW50OyBzZWUgZDMvZDMtdHJhbnNpdGlvbiMxNiFcbiAgICAvLyBBc3N1bWluZyB0aGlzIGlzIHN1Y2Nlc3NmdWwsIHN1YnNlcXVlbnQgY2FsbGJhY2tzIGdvIHN0cmFpZ2h0IHRvIHRpY2suXG4gICAgdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBTVEFSVEVEKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBSVU5OSU5HO1xuICAgICAgICBzZWxmLnRpbWVyLnJlc3RhcnQodGljaywgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcbiAgICAgICAgdGljayhlbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERpc3BhdGNoIHRoZSBzdGFydCBldmVudC5cbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgdHdlZW4gYXJlIGluaXRpYWxpemVkLlxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVElORztcbiAgICBzZWxmLm9uLmNhbGwoXCJzdGFydFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU1RBUlRJTkcpIHJldHVybjsgLy8gaW50ZXJydXB0ZWRcbiAgICBzZWxmLnN0YXRlID0gU1RBUlRFRDtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHR3ZWVuLCBkZWxldGluZyBudWxsIHR3ZWVuLlxuICAgIHR3ZWVuID0gbmV3IEFycmF5KG4gPSBzZWxmLnR3ZWVuLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgaiA9IC0xOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobyA9IHNlbGYudHdlZW5baV0udmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKSkge1xuICAgICAgICB0d2VlblsrK2pdID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgdHdlZW4ubGVuZ3RoID0gaiArIDE7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICB2YXIgdCA9IGVsYXBzZWQgPCBzZWxmLmR1cmF0aW9uID8gc2VsZi5lYXNlLmNhbGwobnVsbCwgZWxhcHNlZCAvIHNlbGYuZHVyYXRpb24pIDogKHNlbGYudGltZXIucmVzdGFydChzdG9wKSwgc2VsZi5zdGF0ZSA9IEVORElORywgMSksXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IHR3ZWVuLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB0d2VlbltpXS5jYWxsKG5vZGUsIHQpO1xuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBlbmQgZXZlbnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IEVORElORykge1xuICAgICAgc2VsZi5vbi5jYWxsKFwiZW5kXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgICAgc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgc2VsZi5zdGF0ZSA9IEVOREVEO1xuICAgIHNlbGYudGltZXIuc3RvcCgpO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaWRdO1xuICAgIGZvciAodmFyIGkgaW4gc2NoZWR1bGVzKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG4gIH1cbn1cbiIsImltcG9ydCB7c2VsZWN0b3J9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIHNjaGVkdWxlKHN1Ymdyb3VwW2ldLCBuYW1lLCBpZCwgaSwgc3ViZ3JvdXAsIGdldChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0b3JBbGx9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbiA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSwgY2hpbGQsIGluaGVyaXQgPSBnZXQobm9kZSwgaWQpLCBrID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgayA8IGw7ICsraykge1xuICAgICAgICAgIGlmIChjaGlsZCA9IGNoaWxkcmVuW2tdKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShjaGlsZCwgbmFtZSwgaWQsIGssIGNoaWxkcmVuLCBpbmhlcml0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcblxudmFyIFNlbGVjdGlvbiA9IHNlbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9ncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3N0eWxlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZU51bGwobmFtZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICBzdHJpbmcxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgc3RyaW5nMTAgPSBzdHJpbmcxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpLFxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSxcbiAgICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSBzdHJpbmcxID0gdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlTWF5YmVSZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIG9uMCwgb24xLCBsaXN0ZW5lcjAsIGtleSA9IFwic3R5bGUuXCIgKyBuYW1lLCBldmVudCA9IFwiZW5kLlwiICsga2V5LCByZW1vdmU7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uLFxuICAgICAgICBsaXN0ZW5lciA9IHNjaGVkdWxlLnZhbHVlW2tleV0gPT0gbnVsbCA/IHJlbW92ZSB8fCAocmVtb3ZlID0gc3R5bGVSZW1vdmUobmFtZSkpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wIHx8IGxpc3RlbmVyMCAhPT0gbGlzdGVuZXIpIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24oZXZlbnQsIGxpc3RlbmVyMCA9IGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGkgPSAobmFtZSArPSBcIlwiKSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVOdWxsKG5hbWUsIGkpKVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgc3R5bGVSZW1vdmUobmFtZSkpXG4gICAgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlRnVuY3Rpb24obmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUpKSlcbiAgICAgIC5lYWNoKHN0eWxlTWF5YmVSZW1vdmUodGhpcy5faWQsIG5hbWUpKVxuICAgIDogdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVDb25zdGFudChuYW1lLCBpLCB2YWx1ZSksIHByaW9yaXR5KVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgbnVsbCk7XG59XG4iLCJmdW5jdGlvbiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBpLmNhbGwodGhpcywgdCksIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIHQsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0ID0gKGkwID0gaSkgJiYgc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBrZXkgPSBcInN0eWxlLlwiICsgKG5hbWUgKz0gXCJcIik7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSk7XG59XG4iLCJpbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWUxID09IG51bGwgPyBcIlwiIDogdmFsdWUxO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdGhpcy50d2VlbihcInRleHRcIiwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gdGV4dEZ1bmN0aW9uKHR3ZWVuVmFsdWUodGhpcywgXCJ0ZXh0XCIsIHZhbHVlKSlcbiAgICAgIDogdGV4dENvbnN0YW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiKSk7XG59XG4iLCJmdW5jdGlvbiB0ZXh0SW50ZXJwb2xhdGUoaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBpLmNhbGwodGhpcywgdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRUd2Vlbih2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIHRleHRJbnRlcnBvbGF0ZShpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGtleSA9IFwidGV4dFwiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgdGV4dFR3ZWVuKHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQwID0gdGhpcy5faWQsXG4gICAgICBpZDEgPSBuZXdJZCgpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHZhciBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkMCk7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkMSwgaSwgZ3JvdXAsIHtcbiAgICAgICAgICB0aW1lOiBpbmhlcml0LnRpbWUgKyBpbmhlcml0LmRlbGF5ICsgaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQxKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjEgPSB0d2VlbjEuc2xpY2UoKTtcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHR3ZWVuRnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gKHR3ZWVuMCA9IHR3ZWVuKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgdCA9IHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9LCBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xW2ldID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IG4pIHR3ZWVuMS5wdXNoKHQpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICBuYW1lICs9IFwiXCI7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0KHRoaXMubm9kZSgpLCBpZCkudHdlZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2Vlbi5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodCA9IHR3ZWVuW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGwgPyB0d2VlblJlbW92ZSA6IHR3ZWVuRnVuY3Rpb24pKGlkLCBuYW1lLCB2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHdlZW5WYWx1ZSh0cmFuc2l0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0cmFuc2l0aW9uLl9pZDtcblxuICB0cmFuc2l0aW9uLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKTtcbiAgICAoc2NoZWR1bGUudmFsdWUgfHwgKHNjaGVkdWxlLnZhbHVlID0ge30pKVtuYW1lXSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIGdldChub2RlLCBpZCkudmFsdWVbbmFtZV07XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBab29tRXZlbnQodHlwZSwge1xuICBzb3VyY2VFdmVudCxcbiAgdGFyZ2V0LFxuICB0cmFuc2Zvcm0sXG4gIGRpc3BhdGNoXG59KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICB0eXBlOiB7dmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgc291cmNlRXZlbnQ6IHt2YWx1ZTogc291cmNlRXZlbnQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdGFyZ2V0OiB7dmFsdWU6IHRhcmdldCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0cmFuc2Zvcm06IHt2YWx1ZTogdHJhbnNmb3JtLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIF86IHt2YWx1ZTogZGlzcGF0Y2h9XG4gIH0pO1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIHpvb219IGZyb20gXCIuL3pvb20uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tVHJhbnNmb3JtLCBpZGVudGl0eSBhcyB6b29tSWRlbnRpdHksIFRyYW5zZm9ybSBhcyBab29tVHJhbnNmb3JtfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbiIsImV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm0oaywgeCwgeSkge1xuICB0aGlzLmsgPSBrO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNmb3JtLFxuICBzY2FsZTogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrID09PSAxID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rICogaywgdGhpcy54LCB0aGlzLnkpO1xuICB9LFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9PT0gMCAmIHkgPT09IDAgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmssIHRoaXMueCArIHRoaXMuayAqIHgsIHRoaXMueSArIHRoaXMuayAqIHkpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gW3BvaW50WzBdICogdGhpcy5rICsgdGhpcy54LCBwb2ludFsxXSAqIHRoaXMuayArIHRoaXMueV07XG4gIH0sXG4gIGFwcGx5WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4ICogdGhpcy5rICsgdGhpcy54O1xuICB9LFxuICBhcHBseVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geSAqIHRoaXMuayArIHRoaXMueTtcbiAgfSxcbiAgaW52ZXJ0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiBbKGxvY2F0aW9uWzBdIC0gdGhpcy54KSAvIHRoaXMuaywgKGxvY2F0aW9uWzFdIC0gdGhpcy55KSAvIHRoaXMua107XG4gIH0sXG4gIGludmVydFg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHggLSB0aGlzLngpIC8gdGhpcy5rO1xuICB9LFxuICBpbnZlcnRZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuICh5IC0gdGhpcy55KSAvIHRoaXMuaztcbiAgfSxcbiAgcmVzY2FsZVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geC5jb3B5KCkuZG9tYWluKHgucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRYLCB0aGlzKS5tYXAoeC5pbnZlcnQsIHgpKTtcbiAgfSxcbiAgcmVzY2FsZVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geS5jb3B5KCkuZG9tYWluKHkucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRZLCB0aGlzKS5tYXAoeS5pbnZlcnQsIHkpKTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMueCArIFwiLFwiICsgdGhpcy55ICsgXCIpIHNjYWxlKFwiICsgdGhpcy5rICsgXCIpXCI7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgaWRlbnRpdHkgPSBuZXcgVHJhbnNmb3JtKDEsIDAsIDApO1xuXG50cmFuc2Zvcm0ucHJvdG90eXBlID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUpIHtcbiAgd2hpbGUgKCFub2RlLl9fem9vbSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybiBpZGVudGl0eTtcbiAgcmV0dXJuIG5vZGUuX196b29tO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge2RyYWdEaXNhYmxlLCBkcmFnRW5hYmxlfSBmcm9tIFwiZDMtZHJhZ1wiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZVpvb219IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzZWxlY3QsIHBvaW50ZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7aW50ZXJydXB0fSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgWm9vbUV2ZW50IGZyb20gXCIuL2V2ZW50LmpzXCI7XG5pbXBvcnQge1RyYW5zZm9ybSwgaWRlbnRpdHl9IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IG5vZXZlbnQsIHtub3Byb3BhZ2F0aW9ufSBmcm9tIFwiLi9ub2V2ZW50LmpzXCI7XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuLy8gZXhjZXB0IGZvciBwaW5jaC10by16b29tLCB3aGljaCBpcyBzZW50IGFzIGEgd2hlZWwrY3RybEtleSBldmVudFxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcihldmVudCkge1xuICByZXR1cm4gKCFldmVudC5jdHJsS2V5IHx8IGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpICYmICFldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFeHRlbnQoKSB7XG4gIHZhciBlID0gdGhpcztcbiAgaWYgKGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgZSA9IGUub3duZXJTVkdFbGVtZW50IHx8IGU7XG4gICAgaWYgKGUuaGFzQXR0cmlidXRlKFwidmlld0JveFwiKSkge1xuICAgICAgZSA9IGUudmlld0JveC5iYXNlVmFsO1xuICAgICAgcmV0dXJuIFtbZS54LCBlLnldLCBbZS54ICsgZS53aWR0aCwgZS55ICsgZS5oZWlnaHRdXTtcbiAgICB9XG4gICAgcmV0dXJuIFtbMCwgMF0sIFtlLndpZHRoLmJhc2VWYWwudmFsdWUsIGUuaGVpZ2h0LmJhc2VWYWwudmFsdWVdXTtcbiAgfVxuICByZXR1cm4gW1swLCAwXSwgW2UuY2xpZW50V2lkdGgsIGUuY2xpZW50SGVpZ2h0XV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2Zvcm0oKSB7XG4gIHJldHVybiB0aGlzLl9fem9vbSB8fCBpZGVudGl0eTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdoZWVsRGVsdGEoZXZlbnQpIHtcbiAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKiAoZXZlbnQuY3RybEtleSA/IDEwIDogMSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb25zdHJhaW4odHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICB2YXIgZHgwID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzBdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVswXSxcbiAgICAgIGR4MSA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMF0sXG4gICAgICBkeTAgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMF1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzFdLFxuICAgICAgZHkxID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzFdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVsxXTtcbiAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGUoXG4gICAgZHgxID4gZHgwID8gKGR4MCArIGR4MSkgLyAyIDogTWF0aC5taW4oMCwgZHgwKSB8fCBNYXRoLm1heCgwLCBkeDEpLFxuICAgIGR5MSA+IGR5MCA/IChkeTAgKyBkeTEpIC8gMiA6IE1hdGgubWluKDAsIGR5MCkgfHwgTWF0aC5tYXgoMCwgZHkxKVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBleHRlbnQgPSBkZWZhdWx0RXh0ZW50LFxuICAgICAgY29uc3RyYWluID0gZGVmYXVsdENvbnN0cmFpbixcbiAgICAgIHdoZWVsRGVsdGEgPSBkZWZhdWx0V2hlZWxEZWx0YSxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBzY2FsZUV4dGVudCA9IFswLCBJbmZpbml0eV0sXG4gICAgICB0cmFuc2xhdGVFeHRlbnQgPSBbWy1JbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCBJbmZpbml0eV1dLFxuICAgICAgZHVyYXRpb24gPSAyNTAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlWm9vbSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJ6b29tXCIsIFwiZW5kXCIpLFxuICAgICAgdG91Y2hzdGFydGluZyxcbiAgICAgIHRvdWNoZmlyc3QsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIHRvdWNoRGVsYXkgPSA1MDAsXG4gICAgICB3aGVlbERlbGF5ID0gMTUwLFxuICAgICAgY2xpY2tEaXN0YW5jZTIgPSAwLFxuICAgICAgdGFwRGlzdGFuY2UgPSAxMDtcblxuICBmdW5jdGlvbiB6b29tKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSlcbiAgICAgICAgLm9uKFwid2hlZWwuem9vbVwiLCB3aGVlbGVkLCB7cGFzc2l2ZTogZmFsc2V9KVxuICAgICAgICAub24oXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZWRvd25lZClcbiAgICAgICAgLm9uKFwiZGJsY2xpY2suem9vbVwiLCBkYmxjbGlja2VkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS56b29tXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLnpvb20gdG91Y2hjYW5jZWwuem9vbVwiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgem9vbS50cmFuc2Zvcm0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBjb2xsZWN0aW9uLnNlbGVjdGlvbiA/IGNvbGxlY3Rpb24uc2VsZWN0aW9uKCkgOiBjb2xsZWN0aW9uO1xuICAgIHNlbGVjdGlvbi5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKTtcbiAgICBpZiAoY29sbGVjdGlvbiAhPT0gc2VsZWN0aW9uKSB7XG4gICAgICBzY2hlZHVsZShjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAuZXZlbnQoZXZlbnQpXG4gICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSlcbiAgICAgICAgICAuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgem9vbS5zY2FsZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20uc2NhbGVUbyhzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGswID0gdGhpcy5fX3pvb20uayxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGswICogazE7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20uc2NhbGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcCxcbiAgICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW4odGhpcy5fX3pvb20udHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHlcbiAgICAgICksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIG51bGwsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHA7XG4gICAgICByZXR1cm4gY29uc3RyYWluKGlkZW50aXR5LnRyYW5zbGF0ZShwMFswXSwgcDBbMV0pLnNjYWxlKHQuaykudHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8gLXguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC14LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8gLXkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC15XG4gICAgICApLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIGspIHtcbiAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBrKSk7XG4gICAgcmV0dXJuIGsgPT09IHRyYW5zZm9ybS5rID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybShrLCB0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgcDAsIHAxKSB7XG4gICAgdmFyIHggPSBwMFswXSAtIHAxWzBdICogdHJhbnNmb3JtLmssIHkgPSBwMFsxXSAtIHAxWzFdICogdHJhbnNmb3JtLms7XG4gICAgcmV0dXJuIHggPT09IHRyYW5zZm9ybS54ICYmIHkgPT09IHRyYW5zZm9ybS55ID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybSh0cmFuc2Zvcm0uaywgeCwgeSk7XG4gIH1cblxuICBmdW5jdGlvbiBjZW50cm9pZChleHRlbnQpIHtcbiAgICByZXR1cm4gWygrZXh0ZW50WzBdWzBdICsgK2V4dGVudFsxXVswXSkgLyAyLCAoK2V4dGVudFswXVsxXSArICtleHRlbnRbMV1bMV0pIC8gMl07XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZSh0cmFuc2l0aW9uLCB0cmFuc2Zvcm0sIHBvaW50LCBldmVudCkge1xuICAgIHRyYW5zaXRpb25cbiAgICAgICAgLm9uKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmV2ZW50KGV2ZW50KS5zdGFydCgpOyB9KVxuICAgICAgICAub24oXCJpbnRlcnJ1cHQuem9vbSBlbmQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmV2ZW50KGV2ZW50KS5lbmQoKTsgfSlcbiAgICAgICAgLnR3ZWVuKFwiem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGcgPSBnZXN0dXJlKHRoYXQsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgICAgICAgZSA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKSxcbiAgICAgICAgICAgICAgcCA9IHBvaW50ID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwb2ludCA9PT0gXCJmdW5jdGlvblwiID8gcG9pbnQuYXBwbHkodGhhdCwgYXJncykgOiBwb2ludCxcbiAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KGVbMV1bMF0gLSBlWzBdWzBdLCBlWzFdWzFdIC0gZVswXVsxXSksXG4gICAgICAgICAgICAgIGEgPSB0aGF0Ll9fem9vbSxcbiAgICAgICAgICAgICAgYiA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGF0LCBhcmdzKSA6IHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgaSA9IGludGVycG9sYXRlKGEuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYS5rKSwgYi5pbnZlcnQocCkuY29uY2F0KHcgLyBiLmspKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHQgPSBiOyAvLyBBdm9pZCByb3VuZGluZyBlcnJvciBvbiBlbmQuXG4gICAgICAgICAgICBlbHNlIHsgdmFyIGwgPSBpKHQpLCBrID0gdyAvIGxbMl07IHQgPSBuZXcgVHJhbnNmb3JtKGssIHBbMF0gLSBsWzBdICogaywgcFsxXSAtIGxbMV0gKiBrKTsgfVxuICAgICAgICAgICAgZy56b29tKG51bGwsIHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VzdHVyZSh0aGF0LCBhcmdzLCBjbGVhbikge1xuICAgIHJldHVybiAoIWNsZWFuICYmIHRoYXQuX196b29taW5nKSB8fCBuZXcgR2VzdHVyZSh0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdlc3R1cmUodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgdGhpcy5zb3VyY2VFdmVudCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgdGhpcy50YXBzID0gMDtcbiAgfVxuXG4gIEdlc3R1cmUucHJvdG90eXBlID0ge1xuICAgIGV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50KSB0aGlzLnNvdXJjZUV2ZW50ID0gZXZlbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgrK3RoaXMuYWN0aXZlID09PSAxKSB7XG4gICAgICAgIHRoaXMudGhhdC5fX3pvb21pbmcgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24oa2V5LCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0aGlzLm1vdXNlICYmIGtleSAhPT0gXCJtb3VzZVwiKSB0aGlzLm1vdXNlWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLm1vdXNlWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMCAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDBbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gwWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMSAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDFbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gxWzBdKTtcbiAgICAgIHRoaXMudGhhdC5fX3pvb20gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLmVtaXQoXCJ6b29tXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGhhdC5fX3pvb21pbmc7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGQgPSBzZWxlY3QodGhpcy50aGF0KS5kYXR1bSgpO1xuICAgICAgbGlzdGVuZXJzLmNhbGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoaXMudGhhdCxcbiAgICAgICAgbmV3IFpvb21FdmVudCh0eXBlLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IHRoaXMuc291cmNlRXZlbnQsXG4gICAgICAgICAgdGFyZ2V0OiB6b29tLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnRoYXQuX196b29tLFxuICAgICAgICAgIGRpc3BhdGNoOiBsaXN0ZW5lcnNcbiAgICAgICAgfSksXG4gICAgICAgIGRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdoZWVsZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCB0LmsgKiBNYXRoLnBvdygyLCB3aGVlbERlbHRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50KTtcblxuICAgIC8vIElmIHRoZSBtb3VzZSBpcyBpbiB0aGUgc2FtZSBsb2NhdGlvbiBhcyBiZWZvcmUsIHJldXNlIGl0LlxuICAgIC8vIElmIHRoZXJlIHdlcmUgcmVjZW50IHdoZWVsIGV2ZW50cywgcmVzZXQgdGhlIHdoZWVsIGlkbGUgdGltZW91dC5cbiAgICBpZiAoZy53aGVlbCkge1xuICAgICAgaWYgKGcubW91c2VbMF1bMF0gIT09IHBbMF0gfHwgZy5tb3VzZVswXVsxXSAhPT0gcFsxXSkge1xuICAgICAgICBnLm1vdXNlWzFdID0gdC5pbnZlcnQoZy5tb3VzZVswXSA9IHApO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGcud2hlZWwpO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2hlZWwgZXZlbnQgd29u4oCZdCB0cmlnZ2VyIGEgdHJhbnNmb3JtIGNoYW5nZSwgaWdub3JlIGl0LlxuICAgIGVsc2UgaWYgKHQuayA9PT0gaykgcmV0dXJuO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBjYXB0dXJlIHRoZSBtb3VzZSBwb2ludCBhbmQgbG9jYXRpb24gYXQgdGhlIHN0YXJ0LlxuICAgIGVsc2Uge1xuICAgICAgZy5tb3VzZSA9IFtwLCB0LmludmVydChwKV07XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZy53aGVlbCA9IHNldFRpbWVvdXQod2hlZWxpZGxlZCwgd2hlZWxEZWxheSk7XG4gICAgZy56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0LCBrKSwgZy5tb3VzZVswXSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcblxuICAgIGZ1bmN0aW9uIHdoZWVsaWRsZWQoKSB7XG4gICAgICBnLndoZWVsID0gbnVsbDtcbiAgICAgIGcuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCB0cnVlKS5ldmVudChldmVudCksXG4gICAgICAgIHYgPSBzZWxlY3QoZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZW1vdmVkLCB0cnVlKS5vbihcIm1vdXNldXAuem9vbVwiLCBtb3VzZXVwcGVkLCB0cnVlKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLFxuICAgICAgICB4MCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHkwID0gZXZlbnQuY2xpZW50WTtcblxuICAgIGRyYWdEaXNhYmxlKGV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGcubW91c2UgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApXTtcbiAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgZy5zdGFydCgpO1xuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlZChldmVudCkge1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBpZiAoIWcubW92ZWQpIHtcbiAgICAgICAgdmFyIGR4ID0gZXZlbnQuY2xpZW50WCAtIHgwLCBkeSA9IGV2ZW50LmNsaWVudFkgLSB5MDtcbiAgICAgICAgZy5tb3ZlZCA9IGR4ICogZHggKyBkeSAqIGR5ID4gY2xpY2tEaXN0YW5jZTI7XG4gICAgICB9XG4gICAgICBnLmV2ZW50KGV2ZW50KVxuICAgICAgIC56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShnLnRoYXQuX196b29tLCBnLm1vdXNlWzBdID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cHBlZChldmVudCkge1xuICAgICAgdi5vbihcIm1vdXNlbW92ZS56b29tIG1vdXNldXAuem9vbVwiLCBudWxsKTtcbiAgICAgIGRyYWdFbmFibGUoZXZlbnQudmlldywgZy5tb3ZlZCk7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGcuZXZlbnQoZXZlbnQpLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRibGNsaWNrZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgIHAwID0gcG9pbnRlcihldmVudC5jaGFuZ2VkVG91Y2hlcyA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQsIHRoaXMpLFxuICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgIGsxID0gdDAuayAqIChldmVudC5zaGlmdEtleSA/IDAuNSA6IDIpLFxuICAgICAgICB0MSA9IGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3MpLCB0cmFuc2xhdGVFeHRlbnQpO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgaWYgKGR1cmF0aW9uID4gMCkgc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChzY2hlZHVsZSwgdDEsIHAwLCBldmVudCk7XG4gICAgZWxzZSBzZWxlY3QodGhpcykuY2FsbCh6b29tLnRyYW5zZm9ybSwgdDEsIHAwLCBldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA9PT0gbikuZXZlbnQoZXZlbnQpLFxuICAgICAgICBzdGFydGVkLCBpLCB0LCBwO1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgcCA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCksIHQuaWRlbnRpZmllcl07XG4gICAgICBpZiAoIWcudG91Y2gwKSBnLnRvdWNoMCA9IHAsIHN0YXJ0ZWQgPSB0cnVlLCBnLnRhcHMgPSAxICsgISF0b3VjaHN0YXJ0aW5nO1xuICAgICAgZWxzZSBpZiAoIWcudG91Y2gxICYmIGcudG91Y2gwWzJdICE9PSBwWzJdKSBnLnRvdWNoMSA9IHAsIGcudGFwcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRvdWNoc3RhcnRpbmcpIHRvdWNoc3RhcnRpbmcgPSBjbGVhclRpbWVvdXQodG91Y2hzdGFydGluZyk7XG5cbiAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgaWYgKGcudGFwcyA8IDIpIHRvdWNoZmlyc3QgPSBwWzBdLCB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQsIHAsIGw7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDBbMF0gPSBwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xuICAgIH1cbiAgICB0ID0gZy50aGF0Ll9fem9vbTtcbiAgICBpZiAoZy50b3VjaDEpIHtcbiAgICAgIHZhciBwMCA9IGcudG91Y2gwWzBdLCBsMCA9IGcudG91Y2gwWzFdLFxuICAgICAgICAgIHAxID0gZy50b3VjaDFbMF0sIGwxID0gZy50b3VjaDFbMV0sXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcbiAgICAgICAgICBkbCA9IChkbCA9IGwxWzBdIC0gbDBbMF0pICogZGwgKyAoZGwgPSBsMVsxXSAtIGwwWzFdKSAqIGRsO1xuICAgICAgdCA9IHNjYWxlKHQsIE1hdGguc3FydChkcCAvIGRsKSk7XG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xuICAgICAgbCA9IFsobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xuICAgIGVsc2UgcmV0dXJuO1xuXG4gICAgZy56b29tKFwidG91Y2hcIiwgY29uc3RyYWluKHRyYW5zbGF0ZSh0LCBwLCBsKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV07XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gxO1xuICAgIH1cbiAgICBpZiAoZy50b3VjaDEgJiYgIWcudG91Y2gwKSBnLnRvdWNoMCA9IGcudG91Y2gxLCBkZWxldGUgZy50b3VjaDE7XG4gICAgaWYgKGcudG91Y2gwKSBnLnRvdWNoMFsxXSA9IHRoaXMuX196b29tLmludmVydChnLnRvdWNoMFswXSk7XG4gICAgZWxzZSB7XG4gICAgICBnLmVuZCgpO1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYSBkYmx0YXAsIHJlcm91dGUgdG8gdGhlIChvcHRpb25hbCkgZGJsY2xpY2suem9vbSBoYW5kbGVyLlxuICAgICAgaWYgKGcudGFwcyA9PT0gMikge1xuICAgICAgICB0ID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgICAgaWYgKE1hdGguaHlwb3QodG91Y2hmaXJzdFswXSAtIHRbMF0sIHRvdWNoZmlyc3RbMV0gLSB0WzFdKSA8IHRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHAgPSBzZWxlY3QodGhpcykub24oXCJkYmxjbGljay56b29tXCIpO1xuICAgICAgICAgIGlmIChwKSBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB6b29tLndoZWVsRGVsdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAod2hlZWxEZWx0YSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB6b29tKSA6IHdoZWVsRGVsdGE7XG4gIH07XG5cbiAgem9vbS5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IGZpbHRlcjtcbiAgfTtcblxuICB6b29tLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIHpvb20uZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCB6b29tKSA6IGV4dGVudDtcbiAgfTtcblxuICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlRXh0ZW50WzBdID0gK19bMF0sIHNjYWxlRXh0ZW50WzFdID0gK19bMV0sIHpvb20pIDogW3NjYWxlRXh0ZW50WzBdLCBzY2FsZUV4dGVudFsxXV07XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNsYXRlRXh0ZW50WzBdWzBdID0gK19bMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVswXSA9ICtfWzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV0gPSArX1swXVsxXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdID0gK19bMV1bMV0sIHpvb20pIDogW1t0cmFuc2xhdGVFeHRlbnRbMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXV0sIFt0cmFuc2xhdGVFeHRlbnRbMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXV1dO1xuICB9O1xuXG4gIHpvb20uY29uc3RyYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnN0cmFpbiA9IF8sIHpvb20pIDogY29uc3RyYWluO1xuICB9O1xuXG4gIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHVyYXRpb24gPSArXywgem9vbSkgOiBkdXJhdGlvbjtcbiAgfTtcblxuICB6b29tLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgem9vbSkgOiBpbnRlcnBvbGF0ZTtcbiAgfTtcblxuICB6b29tLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IHpvb20gOiB2YWx1ZTtcbiAgfTtcblxuICB6b29tLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIHpvb20pIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICB6b29tLnRhcERpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcERpc3RhbmNlID0gK18sIHpvb20pIDogdGFwRGlzdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59XG4iLCJleHBvcnQgY2xhc3MgSW50ZXJuTWFwIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IoZW50cmllcywga2V5ID0ga2V5b2YpIHtcbiAgICBzdXBlcigpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtfaW50ZXJuOiB7dmFsdWU6IG5ldyBNYXAoKX0sIF9rZXk6IHt2YWx1ZToga2V5fX0pO1xuICAgIGlmIChlbnRyaWVzICE9IG51bGwpIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMpIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0KGludGVybl9nZXQodGhpcywga2V5KSk7XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiBzdXBlci5oYXMoaW50ZXJuX2dldCh0aGlzLCBrZXkpKTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5zZXQoaW50ZXJuX3NldCh0aGlzLCBrZXkpLCB2YWx1ZSk7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIHJldHVybiBzdXBlci5kZWxldGUoaW50ZXJuX2RlbGV0ZSh0aGlzLCBrZXkpKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW50ZXJuU2V0IGV4dGVuZHMgU2V0IHtcbiAgY29uc3RydWN0b3IodmFsdWVzLCBrZXkgPSBrZXlvZikge1xuICAgIHN1cGVyKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge19pbnRlcm46IHt2YWx1ZTogbmV3IE1hcCgpfSwgX2tleToge3ZhbHVlOiBrZXl9fSk7XG4gICAgaWYgKHZhbHVlcyAhPSBudWxsKSBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykgdGhpcy5hZGQodmFsdWUpO1xuICB9XG4gIGhhcyh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5oYXMoaW50ZXJuX2dldCh0aGlzLCB2YWx1ZSkpO1xuICB9XG4gIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5hZGQoaW50ZXJuX3NldCh0aGlzLCB2YWx1ZSkpO1xuICB9XG4gIGRlbGV0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5kZWxldGUoaW50ZXJuX2RlbGV0ZSh0aGlzLCB2YWx1ZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybl9nZXQoe19pbnRlcm4sIF9rZXl9LCB2YWx1ZSkge1xuICBjb25zdCBrZXkgPSBfa2V5KHZhbHVlKTtcbiAgcmV0dXJuIF9pbnRlcm4uaGFzKGtleSkgPyBfaW50ZXJuLmdldChrZXkpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGludGVybl9zZXQoe19pbnRlcm4sIF9rZXl9LCB2YWx1ZSkge1xuICBjb25zdCBrZXkgPSBfa2V5KHZhbHVlKTtcbiAgaWYgKF9pbnRlcm4uaGFzKGtleSkpIHJldHVybiBfaW50ZXJuLmdldChrZXkpO1xuICBfaW50ZXJuLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5fZGVsZXRlKHtfaW50ZXJuLCBfa2V5fSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5ID0gX2tleSh2YWx1ZSk7XG4gIGlmIChfaW50ZXJuLmhhcyhrZXkpKSB7XG4gICAgdmFsdWUgPSBfaW50ZXJuLmdldChrZXkpO1xuICAgIF9pbnRlcm4uZGVsZXRlKGtleSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBrZXlvZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG59XG4iLCIvLyBqc29uc3RhdC10b29sa2l0IHYxLjMuMSBDb3B5cmlnaHQgMjAyMSBYYXZpZXIgQmFkb3NhIGh0dHBzOi8vanNvbnN0YXQuY29tXG5mdW5jdGlvbiB0KGUpe3ZhciBuLGkscixsLHM9ZnVuY3Rpb24odCxlKXt2YXIgbixpPVtdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1bdF0pLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09ZSlyZXR1cm4gdDtpZigxPT09dC5sZW5ndGgpe2ZvcihuPTA7bjxlO24rKylpLnB1c2godFswXSk7cmV0dXJuIGl9fWZvcihuPTA7bjxlO24rKyl7dmFyIHI9dm9pZCAwPT09dFtuXT9udWxsOnRbbl07aS5wdXNoKHIpfXJldHVybiBpfTtpZih0aGlzLmxlbmd0aD0wLHRoaXMuaWQ9W10sbnVsbCE9ZSlzd2l0Y2godGhpcy5jbGFzcz1lLmNsYXNzfHxcImJ1bmRsZVwiLHRoaXMuY2xhc3Mpe2Nhc2VcImJ1bmRsZVwiOnZhciBhPVtdLG89MDtpZih0aGlzLmVycm9yPW51bGwsdGhpcy5sZW5ndGg9MCxudWxsPT09ZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUpcmV0dXJuIHZvaWQodGhpcy5jbGFzcz1udWxsKTtpZihlLmhhc093blByb3BlcnR5KFwiZXJyb3JcIikpcmV0dXJuIHZvaWQodGhpcy5lcnJvcj1lLmVycm9yKTtpZihcImRhdGFzZXRcIj09PWUuY2xhc3N8fFwiY29sbGVjdGlvblwiPT09ZS5jbGFzc3x8XCJkaW1lbnNpb25cIj09PWUuY2xhc3MpcmV0dXJuIG5ldyB0KGUpO2ZvcihpIGluIGUpbysrLGEucHVzaChpKTt0aGlzLl9fdHJlZV9fPWUsdGhpcy5sZW5ndGg9byx0aGlzLmlkPWE7YnJlYWs7Y2FzZVwiZGF0YXNldFwiOmUuaGFzT3duUHJvcGVydHkoXCJfX3RyZWVfX1wiKT90aGlzLl9fdHJlZV9fPW49ZS5fX3RyZWVfXzp0aGlzLl9fdHJlZV9fPW49ZSx0aGlzLmxhYmVsPW4ubGFiZWx8fG51bGwsdGhpcy5ub3RlPW4ubm90ZXx8bnVsbCx0aGlzLmxpbms9bi5saW5rfHxudWxsLHRoaXMuaHJlZj1uLmhyZWZ8fG51bGwsdGhpcy51cGRhdGVkPW4udXBkYXRlZHx8bnVsbCx0aGlzLnNvdXJjZT1uLnNvdXJjZXx8bnVsbCx0aGlzLmV4dGVuc2lvbj1uLmV4dGVuc2lvbnx8bnVsbDt2YXIgdSxoPTAsZj1uLnNpemV8fG4uZGltZW5zaW9uJiZuLmRpbWVuc2lvbi5zaXplO2lmKHRoaXMuc2l6ZT1mLHRoaXMudmFsdWU9bi5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpJiZudWxsIT09bi52YWx1ZSYmMCE9PW4udmFsdWUubGVuZ3RoP24udmFsdWU6e30sQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSloPXRoaXMudmFsdWUubGVuZ3RoO2Vsc2V7dmFyIGM9MTtmb3IodT1mLmxlbmd0aDt1LS07KWMqPWZbdV07aD1jfWlmKHRoaXMudmFsdWU9cyh0aGlzLnZhbHVlLGgpLHRoaXMuc3RhdHVzPW4uaGFzT3duUHJvcGVydHkoXCJzdGF0dXNcIik/cyhuLnN0YXR1cyxoKTpudWxsLG4uaGFzT3duUHJvcGVydHkoXCJkaW1lbnNpb25cIikpe3ZhciBkPW4uZGltZW5zaW9uLHY9bi5yb2xlfHwhbi52ZXJzaW9uJiZkLnJvbGV8fG51bGwscD1uLmlkfHxkLmlkLHk9Zi5sZW5ndGgsZz1mdW5jdGlvbih0KXt2Lmhhc093blByb3BlcnR5KHQpfHwodlt0XT1udWxsKX07aWYoIUFycmF5LmlzQXJyYXkocCl8fCFBcnJheS5pc0FycmF5KGYpfHxwLmxlbmd0aCE9eSlyZXR1cm47aWYodGhpcy5sZW5ndGg9eSx0aGlzLmlkPXAsdiYmKGcoXCJ0aW1lXCIpLGcoXCJnZW9cIiksZyhcIm1ldHJpY1wiKSxnKFwiY2xhc3NpZmljYXRpb25cIikpLHYmJm51bGw9PT12LmNsYXNzaWZpY2F0aW9uKXt2YXIgYj1bXSxfPVtcInRpbWVcIixcImdlb1wiLFwibWV0cmljXCJdLG09ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5sZW5ndGg7bi0tOylpZih0PT09ZVtuXSlyZXR1cm4hMDtyZXR1cm4hMX07Zm9yKHU9MDt1PDM7dSsrKXt2YXIgeD12W19bdV1dO251bGwhPT14JiYoYj1iLmNvbmNhdCh4KSl9Zm9yKHYuY2xhc3NpZmljYXRpb249W10sdT0wO3U8eTt1KyspbShwW3VdLGIpfHx2LmNsYXNzaWZpY2F0aW9uLnB1c2gocFt1XSk7MD09PXYuY2xhc3NpZmljYXRpb24ubGVuZ3RoJiYodi5jbGFzc2lmaWNhdGlvbj1udWxsKX10aGlzLnJvbGU9dix0aGlzLm49aDtmb3IodmFyIHc9MCxPPXRoaXMubGVuZ3RoO3c8Tzt3KyspaWYoZFtwW3ddXS5jYXRlZ29yeS5oYXNPd25Qcm9wZXJ0eShcImluZGV4XCIpKXtpZihBcnJheS5pc0FycmF5KGRbcFt3XV0uY2F0ZWdvcnkuaW5kZXgpKXt2YXIgQT17fSxrPWRbcFt3XV0uY2F0ZWdvcnkuaW5kZXg7Zm9yKHI9ay5sZW5ndGgsbD0wO2w8cjtsKyspQVtrW2xdXT1sO2RbcFt3XV0uY2F0ZWdvcnkuaW5kZXg9QX19ZWxzZXt2YXIgRD0wO2ZvcihpIGluIGRbcFt3XV0uY2F0ZWdvcnkuaW5kZXg9e30sZFtwW3ddXS5jYXRlZ29yeS5sYWJlbClkW3Bbd11dLmNhdGVnb3J5LmluZGV4W2ldPUQrK319ZWxzZSB0aGlzLmxlbmd0aD0wO2JyZWFrO2Nhc2VcImRpbWVuc2lvblwiOmlmKCFlLmhhc093blByb3BlcnR5KFwiX190cmVlX19cIikpcmV0dXJuIG5ldyB0KHt2ZXJzaW9uOlwiMi4wXCIsY2xhc3M6XCJkYXRhc2V0XCIsZGltZW5zaW9uOntkOmV9LGlkOltcImRcIl0sc2l6ZTpbZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwPT09dC5pbmRleD90LmxhYmVsOnQuaW5kZXg7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5sZW5ndGg6T2JqZWN0LmtleXMoZSkubGVuZ3RofShlLmNhdGVnb3J5KV0sdmFsdWU6W251bGxdfSkuRGltZW5zaW9uKDApO3ZhciBqPVtdLFA9KG49ZS5fX3RyZWVfXykuY2F0ZWdvcnk7aWYoIW4uaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeVwiKSlyZXR1cm47aWYoIVAuaGFzT3duUHJvcGVydHkoXCJsYWJlbFwiKSlmb3IoaSBpbiBQLmxhYmVsPXt9LFAuaW5kZXgpUC5sYWJlbFtpXT1pO2ZvcihpIGluIFAuaW5kZXgpaltQLmluZGV4W2ldXT1pO3RoaXMuX190cmVlX189bix0aGlzLmxhYmVsPW4ubGFiZWx8fG51bGwsdGhpcy5ub3RlPW4ubm90ZXx8bnVsbCx0aGlzLmxpbms9bi5saW5rfHxudWxsLHRoaXMuaHJlZj1uLmhyZWZ8fG51bGwsdGhpcy5pZD1qLHRoaXMubGVuZ3RoPWoubGVuZ3RoLHRoaXMucm9sZT1lLnJvbGUsdGhpcy5oaWVyYXJjaHk9UC5oYXNPd25Qcm9wZXJ0eShcImNoaWxkXCIpLHRoaXMuZXh0ZW5zaW9uPW4uZXh0ZW5zaW9ufHxudWxsO2JyZWFrO2Nhc2VcImNhdGVnb3J5XCI6dmFyIEU9ZS5jaGlsZDt0aGlzLmlkPUUsdGhpcy5sZW5ndGg9bnVsbD09PUU/MDpFLmxlbmd0aCx0aGlzLmluZGV4PWUuaW5kZXgsdGhpcy5sYWJlbD1lLmxhYmVsLHRoaXMubm90ZT1lLm5vdGV8fG51bGwsdGhpcy51bml0PWUudW5pdCx0aGlzLmNvb3JkaW5hdGVzPWUuY29vcmQ7YnJlYWs7Y2FzZVwiY29sbGVjdGlvblwiOmlmKHRoaXMubGVuZ3RoPTAsdGhpcy5sYWJlbD1lLmxhYmVsfHxudWxsLHRoaXMubm90ZT1lLm5vdGV8fG51bGwsdGhpcy5saW5rPWUubGlua3x8bnVsbCx0aGlzLmhyZWY9ZS5ocmVmfHxudWxsLHRoaXMudXBkYXRlZD1lLnVwZGF0ZWR8fG51bGwsdGhpcy5zb3VyY2U9ZS5zb3VyY2V8fG51bGwsdGhpcy5leHRlbnNpb249ZS5leHRlbnNpb258fG51bGwsbnVsbCE9PXRoaXMubGluayYmZS5saW5rLml0ZW0pe3ZhciB6PWUubGluay5pdGVtO2lmKHRoaXMubGVuZ3RoPUFycmF5LmlzQXJyYXkoeik/ei5sZW5ndGg6MCx0aGlzLmxlbmd0aClmb3IobD0wO2w8dGhpcy5sZW5ndGg7bCsrKXRoaXMuaWRbbF09eltsXS5ocmVmfX19ZnVuY3Rpb24gZSh0KXtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IodC5zdGF0dXMrXCIgXCIrdC5zdGF0dXNUZXh0KTtyZXR1cm4gdC5qc29uKCl9dC5wcm90b3R5cGUuSXRlbT1mdW5jdGlvbih0KXtpZihudWxsPT09dGhpc3x8XCJjb2xsZWN0aW9uXCIhPT10aGlzLmNsYXNzfHwhdGhpcy5sZW5ndGgpcmV0dXJuIG51bGw7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIHQ+dGhpcy5sZW5ndGh8fHQ8MD9udWxsOnRoaXMubGluay5pdGVtW3RdO3ZhciBlLG49W107aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpe2lmKCF0LmNsYXNzJiYhdC5mb2xsb3cpcmV0dXJuIG51bGw7dC5jbGFzcyYmKGU9XCJkYXRhc2V0XCI9PT10LmNsYXNzJiZcImJvb2xlYW5cIj09dHlwZW9mIHQuZW1iZWRkZWQ/ITA9PT10LmVtYmVkZGVkP2Z1bmN0aW9uKHQsZSxpKXt2YXIgcj10LmxpbmsuaXRlbVtlXTtpLmNsYXNzPT09ci5jbGFzcyYmci5pZCYmci5zaXplJiZyLmRpbWVuc2lvbiYmbi5wdXNoKHIpfTpmdW5jdGlvbih0LGUsaSl7dmFyIHI9dC5saW5rLml0ZW1bZV07aS5jbGFzcyE9PXIuY2xhc3N8fHIuaWQmJnIuc2l6ZSYmci5kaW1lbnNpb258fG4ucHVzaChyKX06ZnVuY3Rpb24odCxlLGkpe2kuY2xhc3M9PT10LmxpbmsuaXRlbVtlXS5jbGFzcyYmbi5wdXNoKHQubGluay5pdGVtW2VdKX0pfWVsc2UgZT1mdW5jdGlvbih0LGUpe24ucHVzaCh0LmxpbmsuaXRlbVtlXSl9O2Zvcih2YXIgaT0wO2k8dGhpcy5sZW5ndGg7aSsrKWUodGhpcyxpLHQpO3JldHVybiBufSx0LnByb3RvdHlwZS5EYXRhc2V0PWZ1bmN0aW9uKGUpe2lmKG51bGw9PT10aGlzKXJldHVybiBudWxsO2lmKFwiZGF0YXNldFwiPT09dGhpcy5jbGFzcylyZXR1cm4gdm9pZCAwIT09ZT90aGlzOlt0aGlzXTt2YXIgbixpPVtdLHI9MDtpZihcImNvbGxlY3Rpb25cIj09PXRoaXMuY2xhc3Mpe3ZhciBsPXRoaXMuSXRlbSh7Y2xhc3M6XCJkYXRhc2V0XCIsZW1iZWRkZWQ6ITB9KTtpZih2b2lkIDA9PT1lKXtmb3Iobj1sLmxlbmd0aDtyPG47cisrKWkucHVzaChuZXcgdChsW3JdKSk7cmV0dXJuIGl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGUmJmU+PTAmJmU8bC5sZW5ndGgpcmV0dXJuIG5ldyB0KGxbZV0pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKWZvcihuPWwubGVuZ3RoO3I8bjtyKyspaWYobFtyXS5ocmVmPT09ZSlyZXR1cm4gbmV3IHQobFtyXSk7cmV0dXJuIG51bGx9aWYoXCJidW5kbGVcIiE9PXRoaXMuY2xhc3MpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09ZSl7Zm9yKG49dGhpcy5pZC5sZW5ndGg7cjxuO3IrKylpLnB1c2godGhpcy5EYXRhc2V0KHRoaXMuaWRbcl0pKTtyZXR1cm4gaX1pZihcIm51bWJlclwiPT10eXBlb2YgZSl7dmFyIHM9dGhpcy5pZFtlXTtyZXR1cm4gdm9pZCAwIT09cz90aGlzLkRhdGFzZXQocyk6bnVsbH12YXIgYT10aGlzLl9fdHJlZV9fW2VdO3JldHVybiB2b2lkIDA9PT1hP251bGw6bmV3IHQoe2NsYXNzOlwiZGF0YXNldFwiLF9fdHJlZV9fOmF9KX0sdC5wcm90b3R5cGUuRGltZW5zaW9uPWZ1bmN0aW9uKGUsbil7bj1cImJvb2xlYW5cIiE9dHlwZW9mIG58fG47dmFyIGkscj1bXSxsPXRoaXMuaWQubGVuZ3RoLHM9ZnVuY3Rpb24odCxlKXtpZihudWxsIT09dClmb3IodmFyIG4gaW4gdClmb3IodmFyIGk9bnVsbCE9PXRbbl0/dFtuXS5sZW5ndGg6MDtpLS07KWlmKHRbbl1baV09PT1lKXJldHVybiBuO3JldHVybiBudWxsfTtpZihudWxsPT09dGhpc3x8XCJkYXRhc2V0XCIhPT10aGlzLmNsYXNzKXJldHVybiBudWxsO2lmKHZvaWQgMD09PWUpe2ZvcihpPTA7aTxsO2krKylyLnB1c2godGhpcy5EaW1lbnNpb24odGhpcy5pZFtpXSkpO3JldHVybiByfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXt2YXIgYT10aGlzLmlkW2VdO3JldHVybiB2b2lkIDAhPT1hP3RoaXMuRGltZW5zaW9uKGEsbik6bnVsbH12YXIgbz10aGlzLnJvbGU7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpe2lmKGUuaGFzT3duUHJvcGVydHkoXCJyb2xlXCIpKXtmb3IoaT0wO2k8bDtpKyspe3ZhciB1PXRoaXMuaWRbaV07cyhvLHUpPT09ZS5yb2xlJiZyLnB1c2godGhpcy5EaW1lbnNpb24odSxuKSl9cmV0dXJuIHZvaWQgMD09PXJbMF0/bnVsbDpyfXJldHVybiBudWxsfXZhciBoPXRoaXMuX190cmVlX18uZGltZW5zaW9uO2lmKHZvaWQgMD09PWgpcmV0dXJuIG51bGw7dmFyIGY9aFtlXTtyZXR1cm4gdm9pZCAwPT09Zj9udWxsOm4/bmV3IHQoe2NsYXNzOlwiZGltZW5zaW9uXCIsX190cmVlX186Zixyb2xlOnMobyxlKX0pOmZ1bmN0aW9uKHQsZSl7dmFyIG49W107Zm9yKHZhciBpIGluIHQpblt0W2ldXT1lW2ldO3JldHVybiBufShmLmNhdGVnb3J5LmluZGV4LGYuY2F0ZWdvcnkubGFiZWwpfSx0LnByb3RvdHlwZS5DYXRlZ29yeT1mdW5jdGlvbihlKXtpZihudWxsPT09dGhpc3x8XCJkaW1lbnNpb25cIiE9PXRoaXMuY2xhc3MpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09ZSl7Zm9yKHZhciBuPVtdLGk9MCxyPXRoaXMuaWQubGVuZ3RoO2k8cjtpKyspbi5wdXNoKHRoaXMuQ2F0ZWdvcnkodGhpcy5pZFtpXSkpO3JldHVybiBufWlmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXt2YXIgbD10aGlzLmlkW2VdO3JldHVybiB2b2lkIDAhPT1sP3RoaXMuQ2F0ZWdvcnkobCk6bnVsbH12YXIgcz10aGlzLl9fdHJlZV9fLmNhdGVnb3J5O2lmKHZvaWQgMD09PXMpcmV0dXJuIG51bGw7dmFyIGE9cy5pbmRleFtlXTtpZih2b2lkIDA9PT1hKXJldHVybiBudWxsO3ZhciBvPXMudW5pdCYmcy51bml0W2VdfHxudWxsLHU9cy5jb29yZGluYXRlcyYmcy5jb29yZGluYXRlc1tlXXx8bnVsbCxoPXMuY2hpbGQmJnMuY2hpbGRbZV18fG51bGwsZj1zLm5vdGUmJnMubm90ZVtlXXx8bnVsbDtyZXR1cm4gbmV3IHQoe2NsYXNzOlwiY2F0ZWdvcnlcIixpbmRleDphLGxhYmVsOnMubGFiZWxbZV0sbm90ZTpmLGNoaWxkOmgsdW5pdDpvLGNvb3JkOnV9KX0sdC5wcm90b3R5cGUuRGljZT1mdW5jdGlvbihlLG4saSl7dmFyIHIsbCxzLGEsbz1mdW5jdGlvbih0LGUpe3JldHVybiB0Lmhhc093blByb3BlcnR5KGUpJiYhIXRbZV19O2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3MpcmV0dXJuIG51bGw7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpcmV0dXJuIHRoaXM7XCJvYmplY3RcIiE9dHlwZW9mIG4/KFwiYm9vbGVhblwiPT10eXBlb2YgbiYmITA9PT1uJiYocj0hMCksXCJib29sZWFuXCI9PXR5cGVvZiBpJiYhMD09PWl8fChpPSExKSk6KHI9byhuLFwiY2xvbmVcIiksaT1vKG4sXCJkcm9wXCIpLGw9byhuLFwic3RyaW5naWZ5XCIpLHM9byhuLFwib3ZhbHVlXCIpLGE9byhuLFwib3N0YXR1c1wiKSk7dmFyIHUsaD1yP25ldyB0KEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcykpKTp0aGlzLGY9aC5zdGF0dXMsYz1bXSxkPVtdLHY9ZnVuY3Rpb24odCxlKXt2YXIgbixpLHIsbD0obj10LGk9ZSxyPXt9LFwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuW2ldKT8obltpXS5mb3JFYWNoKChmdW5jdGlvbih0LGUpe251bGwhPT10JiYocltTdHJpbmcoZSldPXQpfSkpLHIpOm5baV0pO2RlbGV0ZSB0W2VdLHRbZV09bH07QXJyYXkuaXNBcnJheShlKSYmKGU9ZnVuY3Rpb24odCl7dmFyIGU9e307cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZVt0WzBdXT10WzFdfSkpLGV9KGUpKSxudWxsPT09ZSYmKGU9e30pO3ZhciBwPU9iamVjdC5rZXlzKGUpO3JldHVybiBwLmxlbmd0aD4wJiYocC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj1lW3RdO0FycmF5LmlzQXJyYXkobil8fChlW3RdPVtuXSksMD09PWVbdF0ubGVuZ3RoJiZkZWxldGUgZVt0XX0pKSxpJiYoZT1mdW5jdGlvbih0KXt2YXIgZT17fTtyZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaChuPT5lW25dPWguRGltZW5zaW9uKG4pLmlkLmZpbHRlcihlPT4tMT09PXRbbl0uaW5kZXhPZihlKSkpLGV9KGUpKSxoLnRvVGFibGUoe3R5cGU6XCJhcnJvYmpcIixjb250ZW50OlwiaWRcIixzdGF0dXM6ITB9KS5mb3JFYWNoKChmdW5jdGlvbih0LG4pe3ZhciBpPVtdO3AuZm9yRWFjaCgoZnVuY3Rpb24obil7dmFyIHI9ZVtuXSxsPVtdO3IuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bC5wdXNoKHRbbl09PT1lKX0pKSxpLnB1c2goLTEhPT1sLmluZGV4T2YoITApKX0pKSwtMT09PWkuaW5kZXhPZighMSkmJihjLnB1c2godC52YWx1ZSksZC5wdXNoKHQuc3RhdHVzKSl9KSkscC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj1oLkRpbWVuc2lvbih0KS5pZCxpPTAscj17fTtoLnNpemVbaC5pZC5pbmRleE9mKHQpXT1lW3RdLmxlbmd0aCxuLmZvckVhY2goKGZ1bmN0aW9uKG4pey0xIT09ZVt0XS5pbmRleE9mKG4pJiYocltuXT1pLGkrKyl9KSksaC5fX3RyZWVfXy5kaW1lbnNpb25bdF0uY2F0ZWdvcnkuaW5kZXg9cn0pKSxoLm49Yy5sZW5ndGgsaC52YWx1ZT1oLl9fdHJlZV9fLnZhbHVlPWMsaC5zdGF0dXM9aC5fX3RyZWVfXy5zdGF0dXM9bnVsbCE9PWY/ZDpudWxsKSxsPygodT1oLl9fdHJlZV9fKS5oYXNPd25Qcm9wZXJ0eShcImlkXCIpfHwodS52ZXJzaW9uPVwiMi4wXCIsdS5oYXNPd25Qcm9wZXJ0eShcImNsYXNzXCIpfHwodS5jbGFzcz1cImRhdGFzZXRcIiksdS5pZD11LmRpbWVuc2lvbi5pZCx1LnNpemU9dS5kaW1lbnNpb24uc2l6ZSxkZWxldGUgdS5kaW1lbnNpb24uaWQsZGVsZXRlIHUuZGltZW5zaW9uLnNpemUsdS5kaW1lbnNpb24uaGFzT3duUHJvcGVydHkoXCJyb2xlXCIpJiYodS5yb2xlPXUuZGltZW5zaW9uLnJvbGUsZGVsZXRlIHUuZGltZW5zaW9uLnJvbGUpKSx1Lmhhc093blByb3BlcnR5KFwic3RhdHVzXCIpJiYtMSE9PVtcIm51bGxcIixcInt9XCIsXCJbXVwiXS5pbmRleE9mKEpTT04uc3RyaW5naWZ5KHUuc3RhdHVzKSkmJmRlbGV0ZSB1LnN0YXR1cyx1Lmhhc093blByb3BlcnR5KFwicm9sZVwiKSYmKGRlbGV0ZSB1LnJvbGUuY2xhc3NpZmljYXRpb24sW1wiZ2VvXCIsXCJ0aW1lXCIsXCJtZXRyaWNcIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7bnVsbD09PXUucm9sZVt0XSYmZGVsZXRlIHUucm9sZVt0XX0pKSkscyYmdih1LFwidmFsdWVcIiksYSYmdS5oYXNPd25Qcm9wZXJ0eShcInN0YXR1c1wiKSYmdih1LFwic3RhdHVzXCIpLEpTT04uc3RyaW5naWZ5KHUpKTpofSx0LnByb3RvdHlwZS5TbGljZT1mdW5jdGlvbih0KXtpZihudWxsPT09dGhpc3x8XCJkYXRhc2V0XCIhPT10aGlzLmNsYXNzKXJldHVybiBudWxsO2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXM7aWYoIUFycmF5LmlzQXJyYXkodCkpe3ZhciBlLG49W107Zm9yKGUgaW4gdCluLnB1c2goW2UsdFtlXV0pO3Q9bn1yZXR1cm4gdGhpcy5EaWNlKHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm5bdFswXSxbdFsxXV1dfSkpKX0sdC5wcm90b3R5cGUuRGF0YT1mdW5jdGlvbih0LGUpe3ZhciBuLGkscj1bXSxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KWlmKHQuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIGV9O2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3MpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09dCl7Zm9yKGk9dGhpcy52YWx1ZS5sZW5ndGgsbj0wO248aTtuKyspci5wdXNoKHRoaXMuRGF0YShuKSk7cmV0dXJuIHJ9aWYoXCJib29sZWFuXCIhPXR5cGVvZiBlJiYoZT0hMCksXCJudW1iZXJcIj09dHlwZW9mIHQpe3ZhciBzPXRoaXMudmFsdWVbdF07cmV0dXJuIHZvaWQgMD09PXM/bnVsbDplP3t2YWx1ZTpzLHN0YXR1czp0aGlzLnN0YXR1cz90aGlzLnN0YXR1c1t0XTpudWxsfTpzfXZhciBhPVwib2JqZWN0XCIsbz10aGlzLl9fdHJlZV9fLHU9by5zaXplfHxvLmRpbWVuc2lvbiYmby5kaW1lbnNpb24uc2l6ZSxoPXUubGVuZ3RoO2lmKEFycmF5LmlzQXJyYXkodCkpe2lmKCFBcnJheS5pc0FycmF5KHRbMF0pKXtpZih0aGlzLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiBudWxsO3ZhciBmPTEsYz0wLGQ9W10sdj1bXTtmb3Iobj0wO248aDtuKyspaWYodm9pZCAwIT09dFtuXSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHRbbl18fHRbbl0+PXVbbl0pcmV0dXJuIG51bGw7Yys9KGYqPW4+MD91W2gtbl06MSkqdFtoLW4tMV19ZWxzZSBkLnB1c2gobiksdi5wdXNoKHVbbl0pO2lmKGQubGVuZ3RoPjEpcmV0dXJuIG51bGw7aWYoMT09PWQubGVuZ3RoKXtmb3IodmFyIHA9MCx5PXZbMF07cDx5O3ArKyl7dmFyIGc9W107Zm9yKG49MDtuPGg7bisrKW4hPT1kWzBdP2cucHVzaCh0W25dKTpnLnB1c2gocCk7ci5wdXNoKHRoaXMuRGF0YShnLGUpKX1yZXR1cm4gcn1yZXR1cm4gZT97dmFsdWU6dGhpcy52YWx1ZVtjXSxzdGF0dXM6dGhpcy5zdGF0dXM/dGhpcy5zdGF0dXNbY106bnVsbH06dGhpcy52YWx1ZVtjXX1hPVwiYXJyYXlcIn12YXIgYj1mdW5jdGlvbih0LGUsbil7dmFyIGkscj1bXSxzPXt9LGE9dC5kaW1lbnNpb24sbz10LmlkfHxhLmlkLHU9dC5zaXplfHxhJiZhLnNpemU7aWYoXCJhcnJheVwiPT09bil7Zm9yKGk9ZS5sZW5ndGg7aS0tOylzW2VbaV1bMF1dPWVbaV1bMV07ZT1zfWZvcih2YXIgaD0wLGY9by5sZW5ndGg7aDxmO2grKyl7dmFyIGM9b1toXSxkPWVbY107ci5wdXNoKFwic3RyaW5nXCI9PXR5cGVvZiBkP2Q6MT09PXVbaF0/bChhW2NdLmNhdGVnb3J5LmluZGV4KTpudWxsKX1yZXR1cm4gcn0obyx0LGEpLF89W10sbT1vLmRpbWVuc2lvbix4PW8uaWR8fG0uaWQ7Zm9yKG49MCxpPWIubGVuZ3RoO248aTtuKyspXy5wdXNoKG1beFtuXV0uY2F0ZWdvcnkuaW5kZXhbYltuXV0pO3JldHVybiB0aGlzLkRhdGEoXyxlKX0sdC5wcm90b3R5cGUudG9UYWJsZT1mdW5jdGlvbih0LGUpe2lmKG51bGw9PT10aGlzfHxcImRhdGFzZXRcIiE9PXRoaXMuY2xhc3MpcmV0dXJuIG51bGw7MT09YXJndW1lbnRzLmxlbmd0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKGU9dCx0PW51bGwpLFwiYXJyb2JqXCI9PT0odD10fHx7ZmllbGQ6XCJsYWJlbFwiLGNvbnRlbnQ6XCJsYWJlbFwiLHZsYWJlbDpcIlZhbHVlXCIsc2xhYmVsOlwiU3RhdHVzXCIsdHlwZTpcImFycmF5XCIsc3RhdHVzOiExLHVuaXQ6ITEsYnk6bnVsbCxwcmVmaXg6XCJcIixkcm9wOltdLG1ldGE6ITEsY29tbWE6ITEsYnlsYWJlbDohMX0pLnR5cGUmJnZvaWQgMD09PXQuZmllbGQmJih0LmZpZWxkPVwiaWRcIik7dmFyIG4saSxyLGwscyxhPXRoaXMuX190cmVlX18sbz0hMD09PXQuc3RhdHVzO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpe249dGhpcy50b1RhYmxlKHQpO3ZhciB1PVtdLGg9XCJhcnJheVwiIT09dC50eXBlPzA6MTtmb3Iocz0oUz1cIm9iamVjdFwiIT09dC50eXBlP24uc2xpY2UoaCk6bi5yb3dzLnNsaWNlKDApKS5sZW5ndGgsaT0wO2k8cztpKyspe3ZhciBmPWUuY2FsbCh0aGlzLFNbaV0saSk7dm9pZCAwIT09ZiYmdS5wdXNoKGYpfXJldHVyblwib2JqZWN0XCI9PT10LnR5cGU/e2NvbHM6bi5jb2xzLHJvd3M6dX06KFwiYXJyYXlcIj09PXQudHlwZSYmdS51bnNoaWZ0KG5bMF0pLHUpfWlmKFwiYXJyb2JqXCI9PT10LnR5cGUpe3ZhciBjPVtdLGQ9YS5yb2xlJiZhLnJvbGUubWV0cmljLHY9ZnVuY3Rpb24oKXt9LHA9e30seT10aGlzLGc9eS5pZCxiPXQuYnkmJi0xIT09Zy5pbmRleE9mKHQuYnkpP3QuYnk6bnVsbCxfPSEwPT09dC5tZXRhLG09dm9pZCAwIT09dC5kcm9wJiZBcnJheS5pc0FycmF5KHQuZHJvcCk/dC5kcm9wOltdLHg9ITA9PT10LmNvbW1hLHc9ITA9PT10LmJ5bGFiZWwsTz1mdW5jdGlvbihlKXtpZihfKXt2YXIgbj17fTtyZXR1cm4gZy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT15LkRpbWVuc2lvbih0KTtuW3RdPXtsYWJlbDplLmxhYmVsLHJvbGU6ZS5yb2xlLGNhdGVnb3JpZXM6e2lkOmUuaWQsbGFiZWw6eS5EaW1lbnNpb24odCwhMSl9fX0pKSx7bWV0YTp7bGFiZWw6eS5sYWJlbCxzb3VyY2U6eS5zb3VyY2UsdXBkYXRlZDp5LnVwZGF0ZWQsaWQ6ZyxzdGF0dXM6byx1bml0OnQudW5pdCxieTpiLGJ5bGFiZWw6dyxkcm9wOm51bGwhPT1iJiZtLmxlbmd0aD4wP206bnVsbCxwcmVmaXg6bnVsbCE9PWI/VHx8XCJcIjpudWxsLGNvbW1hOngsZGltZW5zaW9uczpufSxkYXRhOmV9fXJldHVybiBlfTtiJiYodC5maWVsZD1cImlkXCIpO3ZhciBBPShuPXRoaXMudG9UYWJsZSh7ZmllbGQ6dC5maWVsZCx2bGFiZWw6dC52bGFiZWwsc2xhYmVsOnQuc2xhYmVsLGNvbnRlbnQ6dC5jb250ZW50LHN0YXR1czpvfSkpLnNoaWZ0KCk7aWYobnVsbD09PWImJnQudW5pdCYmZCl7aWYoXCJpZFwiIT09dC5jb250ZW50KWZvcih2YXIgaz1kLmxlbmd0aDtrLS07KXt2YXIgRD10aGlzLkRpbWVuc2lvbihkW2tdKTtwW2Rba11dPXt9O2Zvcih2YXIgaj1ELmxlbmd0aDtqLS07KXBbZFtrXV1bRC5DYXRlZ29yeShqKS5sYWJlbF09RC5pZFtqXX12PWZ1bmN0aW9uKGUsbil7aWYoLTEhPT1kLmluZGV4T2YoZSkpe3ZhciBpPWEuZGltZW5zaW9uW2VdLmNhdGVnb3J5O2kudW5pdD9QLnVuaXQ9aS51bml0W1wiaWRcIiE9PXQuY29udGVudD9wW2VdW25dOm5dOlAudW5pdD1udWxsfX0sdC51bml0PSEwfWVsc2UgdC51bml0PSExO2ZvcihzPW4ubGVuZ3RoLGk9MDtpPHM7aSsrKXt2YXIgUD17fTtmb3Iocj1uW2ldLmxlbmd0aDtyLS07KVBbQVtyXV09bltpXVtyXSx2KEFbcl0sbltpXVtyXSk7Yy5wdXNoKFApfWlmKHgmJmMuZm9yRWFjaCgoZnVuY3Rpb24odCl7bnVsbCE9PXQudmFsdWUmJih0LnZhbHVlPShcIlwiK3QudmFsdWUpLnJlcGxhY2UoXCIuXCIsXCIsXCIpKX0pKSxudWxsIT09Yil7dmFyIEUsej17fSxTPVtdLEM9e30sVD12b2lkIDAhPT10LnByZWZpeD90LnByZWZpeDpcIlwiO20uZm9yRWFjaCgoZnVuY3Rpb24odCxlKXsoIXkuRGltZW5zaW9uKHQpfHx5LkRpbWVuc2lvbih0KS5sZW5ndGg+MSkmJihtW2VdPVwiXCIpfSkpO3ZhciBKPWcuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdCE9PWImJi0xPT09bS5pbmRleE9mKHQpfSkpLE49eS5EaW1lbnNpb24oYiksVj1mdW5jdGlvbih0LGUpe3ZhciBuPVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe24ucHVzaCh0W2VdKX0pKSxuLmpvaW4oXCJcXHRcIil9LEk9ZnVuY3Rpb24odCxlKXt2YXIgbj17fTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlKXtuW2VdPXRbZV19KSksbn07Zm9yKHZhciBxIGluXCJpZFwiIT09dC5jb250ZW50P3c/RT1mdW5jdGlvbih0LGUsbil7dFtlXVtUK25bYl1dPW4udmFsdWV9OihOLkNhdGVnb3J5KCkuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtDW3QubGFiZWxdPU4uaWRbZV19KSksRT1mdW5jdGlvbih0LGUsbil7dFtlXVtUK0NbbltiXV1dPW4udmFsdWV9KTpFPWZ1bmN0aW9uKHQsZSxuKXt0W2VdW1QrbltiXV09bi52YWx1ZX0sYy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1WKHQsSik7dm9pZCAwPT09eltlXSYmKHpbZV09SSh0LEopKSxFKHosZSx0LGIpfSkpLHopUy5wdXNoKHpbcV0pO3JldHVybiBvPSExLE8oUyl9cmV0dXJuIE8oYyl9dmFyIEIsRixHLEgsSz1cImlkXCI9PT10LmZpZWxkO2lmKFwib2JqZWN0XCI9PT10LnR5cGUpe3ZhciBMPVwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLnZhbHVlWzBdfHxudWxsPT09dGhpcy52YWx1ZVswXT9cIm51bWJlclwiOlwic3RyaW5nXCI7Qj1mdW5jdGlvbih0LGUpe3ZhciBuPUsmJnR8fGV8fHQ7ZXQucHVzaCh7aWQ6dCxsYWJlbDpuLHR5cGU6XCJzdHJpbmdcIn0pfSxGPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT0oSz9cInZhbHVlXCI6dCl8fFwiVmFsdWVcIixyPShLP1wic3RhdHVzXCI6ZSl8fFwiU3RhdHVzXCI7biYmZXQucHVzaCh7aWQ6XCJzdGF0dXNcIixsYWJlbDpyLHR5cGU6XCJzdHJpbmdcIn0pLGV0LnB1c2goe2lkOlwidmFsdWVcIixsYWJlbDppLHR5cGU6TH0pfSxHPWZ1bmN0aW9uKHQpe3Z0LnB1c2goe3Y6dH0pfSxIPWZ1bmN0aW9uKHQpe3Z0LnB1c2goe3Y6dH0pLG50LnB1c2goe2M6dnR9KX19ZWxzZSBCPWZ1bmN0aW9uKHQsZSl7dmFyIG49SyYmdHx8ZXx8dDtldC5wdXNoKG4pfSxGPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT0oSz9cInZhbHVlXCI6dCl8fFwiVmFsdWVcIixyPShLP1wic3RhdHVzXCI6ZSl8fFwiU3RhdHVzXCI7biYmZXQucHVzaChyKSxldC5wdXNoKGkpLHR0LnB1c2goZXQpfSxHPWZ1bmN0aW9uKHQpe3Z0LnB1c2godCl9LEg9ZnVuY3Rpb24odCl7dnQucHVzaCh0KSx0dC5wdXNoKHZ0KX07dmFyIE09YS5kaW1lbnNpb24sUT1hLmlkfHxNLmlkLFI9YS5zaXplfHxNLnNpemUsVT1RLmxlbmd0aDtpZihVIT1SLmxlbmd0aClyZXR1cm4hMTt2YXIgVz1bXSxYPTEsWT0oaz0xLFtdKSxaPVtdLCQ9W10sdHQ9W10sZXQ9W10sbnQ9W107Zm9yKGk9MDtpPFU7aSsrKXt2YXIgaXQ9UVtpXSxydD1NW2l0XS5sYWJlbDtCKGl0LHJ0KSxYKj1SW2ldLGsqPVJbaV07dmFyIGx0PVtdO2ZvcihyPTA7cjxSW2ldO3IrKylmb3IodmFyIHN0IGluIE1bUVtpXV0uY2F0ZWdvcnkuaW5kZXgpaWYoTVtRW2ldXS5jYXRlZ29yeS5pbmRleFtzdF09PT1yKXt2YXIgYXQ9XCJpZFwiIT09dC5jb250ZW50JiZNW1FbaV1dLmNhdGVnb3J5LmxhYmVsP01bUVtpXV0uY2F0ZWdvcnkubGFiZWxbc3RdOnN0O2x0LnB1c2goYXQpfVcucHVzaChsdCksWS5wdXNoKGspfWZvcihGKHQudmxhYmVsLHQuc2xhYmVsLG8pLHM9Vy5sZW5ndGgsaT0wO2k8cztpKyspe2Zvcih2YXIgb3Q9W10sdXQ9MCxodD1XW2ldLmxlbmd0aDt1dDxodDt1dCsrKWZvcih2YXIgZnQ9MDtmdDxYL1lbaV07ZnQrKylvdC5wdXNoKFdbaV1bdXRdKTtaLnB1c2gob3QpfWZvcihzPVoubGVuZ3RoLGk9MDtpPHM7aSsrKXt2YXIgY3Q9W10sZHQ9MDtmb3IobD0wO2w8WDtsKyspY3QucHVzaChaW2ldW2R0XSksKytkdD09PVpbaV0ubGVuZ3RoJiYoZHQ9MCk7JC5wdXNoKGN0KX1mb3IobD0wO2w8WDtsKyspe3ZhciB2dD1bXTtzPVoubGVuZ3RoO2Zvcih2YXIgcHQ9MDtwdDxzO3B0KyspRygkW3B0XVtsXSk7byYmRyh0aGlzLnN0YXR1cz90aGlzLnN0YXR1c1tsXTpudWxsKSxIKHRoaXMudmFsdWVbbF0pfXJldHVyblwib2JqZWN0XCI9PT10LnR5cGU/e2NvbHM6ZXQscm93czpudH06dHR9LHQucHJvdG90eXBlLm5vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX3RyZWVfX30sdC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGFzc307ZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obixpKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2Ygbj9uZXcgdChuKTpcInZlcnNpb25cIj09PW4/XCIxLjMuMVwiOmZldGNoP2ZldGNoKG4saSkudGhlbihlKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9KSk6dm9pZCAwfVxuIiwiLyoqXG4gKiBbU2ltcGxlIGxpbmVhciByZWdyZXNzaW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpbXBsZV9saW5lYXJfcmVncmVzc2lvbilcbiAqIGlzIGEgc2ltcGxlIHdheSB0byBmaW5kIGEgZml0dGVkIGxpbmVcbiAqIGJldHdlZW4gYSBzZXQgb2YgY29vcmRpbmF0ZXMuIFRoaXMgYWxnb3JpdGhtIGZpbmRzIHRoZSBzbG9wZSBhbmQgeS1pbnRlcmNlcHQgb2YgYSByZWdyZXNzaW9uIGxpbmVcbiAqIHVzaW5nIHRoZSBsZWFzdCBzdW0gb2Ygc3F1YXJlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBkYXRhIGFuIGFycmF5IG9mIHR3by1lbGVtZW50IG9mIGFycmF5cyxcbiAqIGxpa2UgYFtbMCwgMV0sIFsyLCAzXV1gXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBzbG9wZSBhbmQgaW50ZXJzZWN0IG9mIHJlZ3Jlc3Npb24gbGluZVxuICogQGV4YW1wbGVcbiAqIGxpbmVhclJlZ3Jlc3Npb24oW1swLCAwXSwgWzEsIDFdXSk7IC8vID0+IHsgbTogMSwgYjogMCB9XG4gKi9cbmZ1bmN0aW9uIGxpbmVhclJlZ3Jlc3Npb24oZGF0YSkge1xuICAgIHZhciBtO1xuICAgIHZhciBiO1xuXG4gICAgLy8gU3RvcmUgZGF0YSBsZW5ndGggaW4gYSBsb2NhbCB2YXJpYWJsZSB0byByZWR1Y2VcbiAgICAvLyByZXBlYXRlZCBvYmplY3QgcHJvcGVydHkgbG9va3Vwc1xuICAgIHZhciBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAvL2lmIHRoZXJlJ3Mgb25seSBvbmUgcG9pbnQsIGFyYml0cmFyaWx5IGNob29zZSBhIHNsb3BlIG9mIDBcbiAgICAvL2FuZCBhIHktaW50ZXJjZXB0IG9mIHdoYXRldmVyIHRoZSB5IG9mIHRoZSBpbml0aWFsIHBvaW50IGlzXG4gICAgaWYgKGRhdGFMZW5ndGggPT09IDEpIHtcbiAgICAgICAgbSA9IDA7XG4gICAgICAgIGIgPSBkYXRhWzBdWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgb3VyIHN1bXMgYW5kIHNjb3BlIHRoZSBgbWAgYW5kIGBiYFxuICAgICAgICAvLyB2YXJpYWJsZXMgdGhhdCBkZWZpbmUgdGhlIGxpbmUuXG4gICAgICAgIHZhciBzdW1YID0gMDtcbiAgICAgICAgdmFyIHN1bVkgPSAwO1xuICAgICAgICB2YXIgc3VtWFggPSAwO1xuICAgICAgICB2YXIgc3VtWFkgPSAwO1xuXG4gICAgICAgIC8vIFVzZSBsb2NhbCB2YXJpYWJsZXMgdG8gZ3JhYiBwb2ludCB2YWx1ZXNcbiAgICAgICAgLy8gd2l0aCBtaW5pbWFsIG9iamVjdCBwcm9wZXJ0eSBsb29rdXBzXG4gICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIHZhciB5O1xuXG4gICAgICAgIC8vIEdhdGhlciB0aGUgc3VtIG9mIGFsbCB4IHZhbHVlcywgdGhlIHN1bSBvZiBhbGxcbiAgICAgICAgLy8geSB2YWx1ZXMsIGFuZCB0aGUgc3VtIG9mIHheMiBhbmQgKHgqeSkgZm9yIGVhY2hcbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIG1hdGggbm90YXRpb24sIHRoZXNlIHdvdWxkIGJlIFNTX3gsIFNTX3ksIFNTX3h4LCBhbmQgU1NfeHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHggPSBwb2ludFswXTtcbiAgICAgICAgICAgIHkgPSBwb2ludFsxXTtcblxuICAgICAgICAgICAgc3VtWCArPSB4O1xuICAgICAgICAgICAgc3VtWSArPSB5O1xuXG4gICAgICAgICAgICBzdW1YWCArPSB4ICogeDtcbiAgICAgICAgICAgIHN1bVhZICs9IHggKiB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYG1gIGlzIHRoZSBzbG9wZSBvZiB0aGUgcmVncmVzc2lvbiBsaW5lXG4gICAgICAgIG0gPVxuICAgICAgICAgICAgKGRhdGFMZW5ndGggKiBzdW1YWSAtIHN1bVggKiBzdW1ZKSAvXG4gICAgICAgICAgICAoZGF0YUxlbmd0aCAqIHN1bVhYIC0gc3VtWCAqIHN1bVgpO1xuXG4gICAgICAgIC8vIGBiYCBpcyB0aGUgeS1pbnRlcmNlcHQgb2YgdGhlIGxpbmUuXG4gICAgICAgIGIgPSBzdW1ZIC8gZGF0YUxlbmd0aCAtIChtICogc3VtWCkgLyBkYXRhTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBib3RoIHZhbHVlcyBhcyBhbiBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbTogbSxcbiAgICAgICAgYjogYlxuICAgIH07XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIG91dHB1dCBvZiBgbGluZWFyUmVncmVzc2lvbmA6IGFuIG9iamVjdFxuICogd2l0aCBgbWAgYW5kIGBiYCB2YWx1ZXMgaW5kaWNhdGluZyBzbG9wZSBhbmQgaW50ZXJjZXB0LFxuICogcmVzcGVjdGl2ZWx5LCBnZW5lcmF0ZSBhIGxpbmUgZnVuY3Rpb24gdGhhdCB0cmFuc2xhdGVzXG4gKiB4IHZhbHVlcyBpbnRvIHkgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYiBvYmplY3Qgd2l0aCBgbWAgYW5kIGBiYCBtZW1iZXJzLCByZXByZXNlbnRpbmdcbiAqIHNsb3BlIGFuZCBpbnRlcnNlY3Qgb2YgZGVzaXJlZCBsaW5lXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IG1ldGhvZCB0aGF0IGNvbXB1dGVzIHktdmFsdWUgYXQgYW55IGdpdmVuXG4gKiB4LXZhbHVlIG9uIHRoZSBsaW5lLlxuICogQGV4YW1wbGVcbiAqIHZhciBsID0gbGluZWFyUmVncmVzc2lvbkxpbmUobGluZWFyUmVncmVzc2lvbihbWzAsIDBdLCBbMSwgMV1dKSk7XG4gKiBsKDApIC8vID0gMFxuICogbCgyKSAvLyA9IDJcbiAqIGxpbmVhclJlZ3Jlc3Npb25MaW5lKHsgYjogMCwgbTogMSB9KSgxKTsgLy8gPT4gMVxuICogbGluZWFyUmVncmVzc2lvbkxpbmUoeyBiOiAxLCBtOiAxIH0pKDEpOyAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGxpbmVhclJlZ3Jlc3Npb25MaW5lKG1iIC8qOiB7IGI6IG51bWJlciwgbTogbnVtYmVyIH0qLykge1xuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgYSBgeWAgdmFsdWUgZm9yIGVhY2hcbiAgICAvLyB4IHZhbHVlIGl0IGlzIGdpdmVuLCBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIGBiYCBhbmQgYGFgXG4gICAgLy8gdGhhdCB3ZSBqdXN0IGNvbXB1dGVkLlxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbWIuYiArIG1iLm0gKiB4O1xuICAgIH07XG59XG5cbi8qKlxuICogT3VyIGRlZmF1bHQgc3VtIGlzIHRoZSBbS2FoYW4tQmFidXNrYSBhbGdvcml0aG1dKGh0dHBzOi8vcGRmcy5zZW1hbnRpY3NjaG9sYXIub3JnLzE3NjAvN2Q0NjdjZGExZDAyNzdhZDI3MmRlYjIxMTM1MzMxMzFkYzA5LnBkZikuXG4gKiBUaGlzIG1ldGhvZCBpcyBhbiBpbXByb3ZlbWVudCBvdmVyIHRoZSBjbGFzc2ljYWxcbiAqIFtLYWhhbiBzdW1tYXRpb24gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYWhhbl9zdW1tYXRpb25fYWxnb3JpdGhtKS5cbiAqIEl0IGFpbXMgYXQgY29tcHV0aW5nIHRoZSBzdW0gb2YgYSBsaXN0IG9mIG51bWJlcnMgd2hpbGUgY29ycmVjdGluZyBmb3JcbiAqIGZsb2F0aW5nLXBvaW50IGVycm9ycy4gVHJhZGl0aW9uYWxseSwgc3VtcyBhcmUgY2FsY3VsYXRlZCBhcyBtYW55XG4gKiBzdWNjZXNzaXZlIGFkZGl0aW9ucywgZWFjaCBvbmUgd2l0aCBpdHMgb3duIGZsb2F0aW5nLXBvaW50IHJvdW5kb2ZmLiBUaGVzZVxuICogbG9zc2VzIGluIHByZWNpc2lvbiBhZGQgdXAgYXMgdGhlIG51bWJlciBvZiBudW1iZXJzIGluY3JlYXNlcy4gVGhpcyBhbHRlcm5hdGl2ZVxuICogYWxnb3JpdGhtIGlzIG1vcmUgYWNjdXJhdGUgdGhhbiB0aGUgc2ltcGxlIHdheSBvZiBjYWxjdWxhdGluZyBzdW1zIGJ5IHNpbXBsZVxuICogYWRkaXRpb24uXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gc3VtIG9mIGFsbCBpbnB1dCBudW1iZXJzXG4gKiBAZXhhbXBsZVxuICogc3VtKFsxLCAyLCAzXSk7IC8vID0+IDZcbiAqL1xuZnVuY3Rpb24gc3VtKHgpIHtcbiAgICAvLyBJZiB0aGUgYXJyYXkgaXMgZW1wdHksIHdlIG5lZWRuJ3QgYm90aGVyIGNvbXB1dGluZyBpdHMgc3VtXG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemluZyB0aGUgc3VtIGFzIHRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIGFycmF5XG4gICAgdmFyIHN1bSA9IHhbMF07XG5cbiAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIHRoZSBmbG9hdGluZy1wb2ludCBlcnJvciBjb3JyZWN0aW9uXG4gICAgdmFyIGNvcnJlY3Rpb24gPSAwO1xuXG4gICAgdmFyIHRyYW5zaXRpb247XG5cbiAgICBpZiAodHlwZW9mIHN1bSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4W2ldICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2l0aW9uID0gc3VtICsgeFtpXTtcblxuICAgICAgICAvLyBIZXJlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjb3JyZWN0aW9uIGluIGEgZGlmZmVyZW50IGZhc2hpb25cbiAgICAgICAgLy8gaWYgdGhlIG5ldyBhYnNvbHV0ZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGFic29sdXRlIHN1bVxuICAgICAgICBpZiAoTWF0aC5hYnMoc3VtKSA+PSBNYXRoLmFicyh4W2ldKSkge1xuICAgICAgICAgICAgY29ycmVjdGlvbiArPSBzdW0gLSB0cmFuc2l0aW9uICsgeFtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gKz0geFtpXSAtIHRyYW5zaXRpb24gKyBzdW07XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gPSB0cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIFJldHVybmluZyB0aGUgY29ycmVjdGVkIHN1bVxuICAgIHJldHVybiBzdW0gKyBjb3JyZWN0aW9uO1xufVxuXG4vKipcbiAqIFRoZSBtZWFuLCBfYWxzbyBrbm93biBhcyBhdmVyYWdlXyxcbiAqIGlzIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBvdmVyIHRoZSBudW1iZXIgb2YgdmFsdWVzLlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBsZW5ndGggb2YgeCBpcyBsZXNzIHRoYW4gb25lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWFuXG4gKiBAZXhhbXBsZVxuICogbWVhbihbMCwgMTBdKTsgLy8gPT4gNVxuICovXG5mdW5jdGlvbiBtZWFuKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVhbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtKHgpIC8geC5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIHN1bSBvZiBkZXZpYXRpb25zIHRvIHRoZSBOdGggcG93ZXIuXG4gKiBXaGVuIG49MiBpdCdzIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zLlxuICogV2hlbiBuPTMgaXQncyB0aGUgc3VtIG9mIGN1YmVkIGRldmlhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4XG4gKiBAcGFyYW0ge251bWJlcn0gbiBwb3dlclxuICogQHJldHVybnMge251bWJlcn0gc3VtIG9mIG50aCBwb3dlciBkZXZpYXRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBpbnB1dCA9IFsxLCAyLCAzXTtcbiAqIC8vIHNpbmNlIHRoZSB2YXJpYW5jZSBvZiBhIHNldCBpcyB0aGUgbWVhbiBzcXVhcmVkXG4gKiAvLyBkZXZpYXRpb25zLCB3ZSBjYW4gY2FsY3VsYXRlIHRoYXQgd2l0aCBzdW1OdGhQb3dlckRldmlhdGlvbnM6XG4gKiBzdW1OdGhQb3dlckRldmlhdGlvbnMoaW5wdXQsIDIpIC8gaW5wdXQubGVuZ3RoO1xuICovXG5mdW5jdGlvbiBzdW1OdGhQb3dlckRldmlhdGlvbnMoeCwgbikge1xuICAgIHZhciBtZWFuVmFsdWUgPSBtZWFuKHgpO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciB0ZW1wVmFsdWU7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbjogd2hlbiBuIGlzIDIgKHdlJ3JlIGNvbXB1dGluZyBhIG51bWJlciBzcXVhcmVkKSxcbiAgICAvLyBtdWx0aXBseWluZyB0aGUgbnVtYmVyIGJ5IGl0c2VsZiBpcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHVzaW5nXG4gICAgLy8gdGhlIE1hdGgucG93IG1ldGhvZC5cbiAgICBpZiAobiA9PT0gMikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFZhbHVlID0geFtpXSAtIG1lYW5WYWx1ZTtcbiAgICAgICAgICAgIHN1bSArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IE1hdGgucG93KHhbaV0gLSBtZWFuVmFsdWUsIG4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLyoqXG4gKiBUaGUgW3ZhcmlhbmNlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhcmlhbmNlKVxuICogaXMgdGhlIHN1bSBvZiBzcXVhcmVkIGRldmlhdGlvbnMgZnJvbSB0aGUgbWVhbi5cbiAqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHZhcmlhbmNlLCBub3Qgc2FtcGxlIHZhcmlhbmNlOlxuICogc2VlIHRoZSBgc2FtcGxlVmFyaWFuY2VgIG1ldGhvZCBpZiB5b3Ugd2FudCBhIHNhbXBsZSBtZWFzdXJlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBhIHBvcHVsYXRpb24gb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhcmlhbmNlOiBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLlxuICogemVybyBpbmRpY2F0ZXMgdGhhdCBhbGwgdmFsdWVzIGFyZSBpZGVudGljYWwuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCdzIGxlbmd0aCBpcyAwXG4gKiBAZXhhbXBsZVxuICogdmFyaWFuY2UoWzEsIDIsIDMsIDQsIDUsIDZdKTsgLy8gPT4gMi45MTY2NjY2NjY2NjY2NjY1XG4gKi9cbmZ1bmN0aW9uIHZhcmlhbmNlKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgbWVhbiBvZiBzcXVhcmVkIGRldmlhdGlvbnMgYmV0d2VlbiB0aGVcbiAgICAvLyBtZWFuIHZhbHVlIGFuZCBlYWNoIHZhbHVlLlxuICAgIHJldHVybiBzdW1OdGhQb3dlckRldmlhdGlvbnMoeCwgMikgLyB4Lmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgW3N0YW5kYXJkIGRldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9kZXZpYXRpb24pXG4gKiBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhcmlhbmNlLiBUaGlzIGlzIGFsc28ga25vd24gYXMgdGhlIHBvcHVsYXRpb25cbiAqIHN0YW5kYXJkIGRldmlhdGlvbi4gSXQncyB1c2VmdWwgZm9yIG1lYXN1cmluZyB0aGUgYW1vdW50XG4gKiBvZiB2YXJpYXRpb24gb3IgZGlzcGVyc2lvbiBpbiBhIHNldCBvZiB2YWx1ZXMuXG4gKlxuICogU3RhbmRhcmQgZGV2aWF0aW9uIGlzIG9ubHkgYXBwcm9wcmlhdGUgZm9yIGZ1bGwtcG9wdWxhdGlvbiBrbm93bGVkZ2U6IGZvclxuICogc2FtcGxlcyBvZiBhIHBvcHVsYXRpb24sIHtAbGluayBzYW1wbGVTdGFuZGFyZERldmlhdGlvbn0gaXNcbiAqIG1vcmUgYXBwcm9wcmlhdGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBleGFtcGxlXG4gKiB2YXJpYW5jZShbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pOyAvLyA9PiA0XG4gKiBzdGFuZGFyZERldmlhdGlvbihbMiwgNCwgNCwgNCwgNSwgNSwgNywgOV0pOyAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkRGV2aWF0aW9uKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciB2ID0gdmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2KTtcbn1cblxuLyoqXG4gKiBUaGUgW1IgU3F1YXJlZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2VmZmljaWVudF9vZl9kZXRlcm1pbmF0aW9uKVxuICogdmFsdWUgb2YgZGF0YSBjb21wYXJlZCB3aXRoIGEgZnVuY3Rpb24gYGZgXG4gKiBpcyB0aGUgc3VtIG9mIHRoZSBzcXVhcmVkIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHByZWRpY3Rpb25cbiAqIGFuZCB0aGUgYWN0dWFsIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHggaW5wdXQgZGF0YTogdGhpcyBzaG91bGQgYmUgZG91Ymx5LW5lc3RlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiBjYWxsZWQgb24gYFtpXVswXWAgdmFsdWVzIHdpdGhpbiB0aGUgZGF0YXNldFxuICogQHJldHVybnMge251bWJlcn0gci1zcXVhcmVkIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogdmFyIHNhbXBsZXMgPSBbWzAsIDBdLCBbMSwgMV1dO1xuICogdmFyIHJlZ3Jlc3Npb25MaW5lID0gbGluZWFyUmVncmVzc2lvbkxpbmUobGluZWFyUmVncmVzc2lvbihzYW1wbGVzKSk7XG4gKiByU3F1YXJlZChzYW1wbGVzLCByZWdyZXNzaW9uTGluZSk7IC8vID0gMSB0aGlzIGxpbmUgaXMgYSBwZXJmZWN0IGZpdFxuICovXG5mdW5jdGlvbiByU3F1YXJlZCh4LCBmdW5jKSB7XG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhdmVyYWdlIHkgdmFsdWUgZm9yIHRoZSBhY3R1YWxcbiAgICAvLyBkYXRhIHNldCBpbiBvcmRlciB0byBjb21wdXRlIHRoZVxuICAgIC8vIF90b3RhbCBzdW0gb2Ygc3F1YXJlc19cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHhbaV1bMV07XG4gICAgfVxuICAgIHZhciBhdmVyYWdlID0gc3VtIC8geC5sZW5ndGg7XG5cbiAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBzdW0gb2Ygc3F1YXJlcyAtIHRoZVxuICAgIC8vIHNxdWFyZWQgZGlmZmVyZW5jZSBiZXR3ZWVuIGVhY2ggcG9pbnRcbiAgICAvLyBhbmQgdGhlIGF2ZXJhZ2Ugb2YgYWxsIHBvaW50cy5cbiAgICB2YXIgc3VtT2ZTcXVhcmVzID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtT2ZTcXVhcmVzICs9IE1hdGgucG93KGF2ZXJhZ2UgLSB4W2pdWzFdLCAyKTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5IGVzdGltYXRlIHRoZSBlcnJvcjogdGhlIHNxdWFyZWRcbiAgICAvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGVzdGltYXRlIGFuZCB0aGUgYWN0dWFsIGRhdGFcbiAgICAvLyB2YWx1ZSBhdCBlYWNoIHBvaW50LlxuICAgIHZhciBlcnIgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgeC5sZW5ndGg7IGsrKykge1xuICAgICAgICBlcnIgKz0gTWF0aC5wb3coeFtrXVsxXSAtIGZ1bmMoeFtrXVswXSksIDIpO1xuICAgIH1cblxuICAgIC8vIEFzIHRoZSBlcnJvciBncm93cyBsYXJnZXIsIGl0cyByYXRpbyB0byB0aGVcbiAgICAvLyBzdW0gb2Ygc3F1YXJlcyBpbmNyZWFzZXMgYW5kIHRoZSByIHNxdWFyZWRcbiAgICAvLyB2YWx1ZSBncm93cyBsb3dlci5cbiAgICByZXR1cm4gMSAtIGVyciAvIHN1bU9mU3F1YXJlcztcbn1cblxuLyoqXG4gKiBUaGUgW21vZGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZGVfJTI4c3RhdGlzdGljcyUyOSkgaXMgdGhlIG51bWJlclxuICogdGhhdCBhcHBlYXJzIGluIGEgbGlzdCB0aGUgaGlnaGVzdCBudW1iZXIgb2YgdGltZXMuXG4gKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgbW9kZXMgaW4gYSBsaXN0OiBpbiB0aGUgZXZlbnQgb2YgYSB0aWUsIHRoaXNcbiAqIGFsZ29yaXRobSB3aWxsIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBzZWVuIG1vZGUuXG4gKlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAgYmVjYXVzZSB0aGUgaW5wdXQgaXMgc29ydGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc29ydGVkIGEgc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtb2RlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgc29ydGVkIGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogbW9kZVNvcnRlZChbMCwgMCwgMV0pOyAvLyA9PiAwXG4gKi9cbmZ1bmN0aW9uIG1vZGVTb3J0ZWQoc29ydGVkKSB7XG4gICAgLy8gSGFuZGxlIGVkZ2UgY2FzZXM6XG4gICAgLy8gVGhlIG1vZGUgb2YgYW4gZW1wdHkgbGlzdCBpcyB1bmRlZmluZWRcbiAgICBpZiAoc29ydGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2RlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cbiAgICBpZiAoc29ydGVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc29ydGVkWzBdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgYXNzdW1lcyBpdCBpcyBkZWFsaW5nIHdpdGggYW4gYXJyYXkgb2Ygc2l6ZSA+IDEsIHNpbmNlIHNpemVcbiAgICAvLyAwIGFuZCAxIGFyZSBoYW5kbGVkIGltbWVkaWF0ZWx5LiBIZW5jZSBpdCBzdGFydHMgYXQgaW5kZXggMSBpbiB0aGVcbiAgICAvLyBhcnJheS5cbiAgICB2YXIgbGFzdCA9IHNvcnRlZFswXTtcbiAgICAvLyBzdG9yZSB0aGUgbW9kZSBhcyB3ZSBmaW5kIG5ldyBtb2Rlc1xuICAgIHZhciB2YWx1ZSA9IE51bWJlci5OYU47XG4gICAgLy8gc3RvcmUgaG93IG1hbnkgdGltZXMgd2UndmUgc2VlbiB0aGUgbW9kZVxuICAgIHZhciBtYXhTZWVuID0gMDtcbiAgICAvLyBob3cgbWFueSB0aW1lcyB0aGUgY3VycmVudCBjYW5kaWRhdGUgZm9yIHRoZSBtb2RlXG4gICAgLy8gaGFzIGJlZW4gc2VlblxuICAgIHZhciBzZWVuVGhpcyA9IDE7XG5cbiAgICAvLyBlbmQgYXQgc29ydGVkLmxlbmd0aCArIDEgdG8gZml4IHRoZSBjYXNlIGluIHdoaWNoIHRoZSBtb2RlIGlzXG4gICAgLy8gdGhlIGhpZ2hlc3QgbnVtYmVyIHRoYXQgb2NjdXJzIGluIHRoZSBzZXF1ZW5jZS4gdGhlIGxhc3QgaXRlcmF0aW9uXG4gICAgLy8gY29tcGFyZXMgc29ydGVkW2ldLCB3aGljaCBpcyB1bmRlZmluZWQsIHRvIHRoZSBoaWdoZXN0IG51bWJlclxuICAgIC8vIGluIHRoZSBzZXJpZXNcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNvcnRlZC5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgICAgLy8gd2UncmUgc2VlaW5nIGEgbmV3IG51bWJlciBwYXNzIGJ5XG4gICAgICAgIGlmIChzb3J0ZWRbaV0gIT09IGxhc3QpIHtcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IG51bWJlciBpcyB0aGUgbmV3IG1vZGUgc2luY2Ugd2Ugc2F3IGl0IG1vcmVcbiAgICAgICAgICAgIC8vIG9mdGVuIHRoYW4gdGhlIG9sZCBvbmVcbiAgICAgICAgICAgIGlmIChzZWVuVGhpcyA+IG1heFNlZW4pIHtcbiAgICAgICAgICAgICAgICBtYXhTZWVuID0gc2VlblRoaXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlblRoaXMgPSAxO1xuICAgICAgICAgICAgbGFzdCA9IHNvcnRlZFtpXTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXNuJ3QgYSBuZXcgbnVtYmVyLCBpdCdzIG9uZSBtb3JlIG9jY3VycmVuY2Ugb2ZcbiAgICAgICAgICAgIC8vIHRoZSBwb3RlbnRpYWwgbW9kZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VlblRoaXMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogU29ydCBhbiBhcnJheSBvZiBudW1iZXJzIGJ5IHRoZWlyIG51bWVyaWMgdmFsdWUsIGVuc3VyaW5nIHRoYXQgdGhlXG4gKiBhcnJheSBpcyBub3QgY2hhbmdlZCBpbiBwbGFjZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIC5zb3J0XG4gKiBpbiBKYXZhU2NyaXB0IGlzIHRvIHNvcnQgYXJyYXlzIGFzIHN0cmluZyB2YWx1ZXNcbiAqXG4gKiAgICAgWzEsIDEwLCAxMiwgMTAyLCAyMF0uc29ydCgpXG4gKiAgICAgLy8gb3V0cHV0XG4gKiAgICAgWzEsIDEwLCAxMDIsIDEyLCAyMF1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXQgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IHNvcnRlZCBhcnJheVxuICogQHByaXZhdGVcbiAqIEBleGFtcGxlXG4gKiBudW1lcmljU29ydChbMywgMiwgMV0pIC8vID0+IFsxLCAyLCAzXVxuICovXG5mdW5jdGlvbiBudW1lcmljU29ydCh4KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgeFxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBhcnJheSBpcyBub3QgY2hhbmdlZCBpbi1wbGFjZVxuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC8vIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhdCB0cmVhdHMgaW5wdXQgYXMgbnVtZXJpY1xuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICB9KVxuICAgICk7XG59XG5cbi8qKlxuICogVGhlIFttb2RlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2RlXyUyOHN0YXRpc3RpY3MlMjkpIGlzIHRoZSBudW1iZXJcbiAqIHRoYXQgYXBwZWFycyBpbiBhIGxpc3QgdGhlIGhpZ2hlc3QgbnVtYmVyIG9mIHRpbWVzLlxuICogVGhlcmUgY2FuIGJlIG11bHRpcGxlIG1vZGVzIGluIGEgbGlzdDogaW4gdGhlIGV2ZW50IG9mIGEgdGllLCB0aGlzXG4gKiBhbGdvcml0aG0gd2lsbCByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgc2VlbiBtb2RlLlxuICpcbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obiBsb2cobikpYCBiZWNhdXNlIGl0IG5lZWRzIHRvIHNvcnQgdGhlIGFycmF5IGludGVybmFsbHlcbiAqIGJlZm9yZSBydW5uaW5nIGFuIGBPKG4pYCBzZWFyY2ggdG8gZmluZCB0aGUgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1vZGVcbiAqIEBleGFtcGxlXG4gKiBtb2RlKFswLCAwLCAxXSk7IC8vID0+IDBcbiAqL1xuZnVuY3Rpb24gbW9kZSh4KSB7XG4gICAgLy8gU29ydGluZyB0aGUgYXJyYXkgbGV0cyB1cyBpdGVyYXRlIHRocm91Z2ggaXQgYmVsb3cgYW5kIGJlIHN1cmVcbiAgICAvLyB0aGF0IGV2ZXJ5IHRpbWUgd2Ugc2VlIGEgbmV3IG51bWJlciBpdCdzIG5ldyBhbmQgd2UnbGwgbmV2ZXJcbiAgICAvLyBzZWUgdGhlIHNhbWUgbnVtYmVyIHR3aWNlXG4gICAgcmV0dXJuIG1vZGVTb3J0ZWQobnVtZXJpY1NvcnQoeCkpO1xufVxuXG4vKiBnbG9iYWxzIE1hcDogZmFsc2UgKi9cblxuLyoqXG4gKiBUaGUgW21vZGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZGVfJTI4c3RhdGlzdGljcyUyOSkgaXMgdGhlIG51bWJlclxuICogdGhhdCBhcHBlYXJzIGluIGEgbGlzdCB0aGUgaGlnaGVzdCBudW1iZXIgb2YgdGltZXMuXG4gKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgbW9kZXMgaW4gYSBsaXN0OiBpbiB0aGUgZXZlbnQgb2YgYSB0aWUsIHRoaXNcbiAqIGFsZ29yaXRobSB3aWxsIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBzZWVuIG1vZGUuXG4gKlxuICogbW9kZUZhc3QgdXNlcyBhIE1hcCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiB0aGUgbW9kZSwgaW5zdGVhZCBvZiB0aGUgYXBwcm9hY2hcbiAqIHVzZWQgd2l0aCBgbW9kZWAsIGEgc29ydGVkIGFycmF5LiBBcyBhIHJlc3VsdCwgaXQgaXMgZmFzdGVyXG4gKiB0aGFuIGBtb2RlYCBhbmQgc3VwcG9ydHMgYW55IGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBjb21wYXJlZCB3aXRoIGA9PWAuXG4gKiBJdCBhbHNvIHJlcXVpcmVzIGFcbiAqIFtKYXZhU2NyaXB0IGVudmlyb25tZW50IHdpdGggc3VwcG9ydCBmb3IgTWFwXShodHRwczovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNi8jdGVzdC1NYXApLFxuICogYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgTWFwIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHggYSBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHs/Kn0gbW9kZVxuICogQHRocm93cyB7UmVmZXJlbmNlRXJyb3J9IGlmIHRoZSBKYXZhU2NyaXB0IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCBNYXBcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGlzIGVtcHR5XG4gKiBAZXhhbXBsZVxuICogbW9kZUZhc3QoWydyYWJiaXRzJywgJ3JhYmJpdHMnLCAnc3F1aXJyZWxzJ10pOyAvLyA9PiAncmFiYml0cydcbiAqL1xuZnVuY3Rpb24gbW9kZUZhc3QoeCkge1xuICAgIC8vIFRoaXMgaW5kZXggd2lsbCByZWZsZWN0IHRoZSBpbmNpZGVuY2Ugb2YgZGlmZmVyZW50IHZhbHVlcywgaW5kZXhpbmdcbiAgICAvLyB0aGVtIGxpa2VcbiAgICAvLyB7IHZhbHVlOiBjb3VudCB9XG4gICAgdmFyIGluZGV4ID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gQSBydW5uaW5nIGBtb2RlYCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBpdCBoYXMgYmVlbiBlbmNvdW50ZXJlZC5cbiAgICB2YXIgbW9kZTtcbiAgICB2YXIgbW9kZUNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q291bnQgPSBpbmRleC5nZXQoeFtpXSk7XG4gICAgICAgIGlmIChuZXdDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdDb3VudCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb3VudCA+IG1vZGVDb3VudCkge1xuICAgICAgICAgICAgbW9kZSA9IHhbaV07XG4gICAgICAgICAgICBtb2RlQ291bnQgPSBuZXdDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpbmRleC5zZXQoeFtpXSwgbmV3Q291bnQpO1xuICAgIH1cblxuICAgIGlmIChtb2RlQ291bnQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZSByZXF1aXJlcyBhdCBsYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlO1xufVxuXG4vKipcbiAqIFRoZSBtaW4gaXMgdGhlIGxvd2VzdCBudW1iZXIgaW4gdGhlIGFycmF5LlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGxlbmd0aCBvZiB4IGlzIGxlc3MgdGhhbiBvbmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1pbmltdW0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtaW4oWzEsIDUsIC0xMCwgMTAwLCAyXSk7IC8vID0+IC0xMFxuICovXG5mdW5jdGlvbiBtaW4oeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0geFswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhbaV0gPCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB4W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXB1dGVzIHRoZSBtYXhpbXVtIG51bWJlciBpbiBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1heGltdW0gdmFsdWVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQGV4YW1wbGVcbiAqIG1heChbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gNFxuICovXG5mdW5jdGlvbiBtYXgoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0geFswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhbaV0gPiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB4W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXB1dGVzIHRoZSBtaW5pbXVtICYgbWF4aW11bSBudW1iZXIgaW4gYW4gYXJyYXkuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gbWluaW11bSAmIG1heGltdW0gdmFsdWVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQGV4YW1wbGVcbiAqIGV4dGVudChbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzEsIDRdXG4gKi9cbmZ1bmN0aW9uIGV4dGVudCh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVudCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbWluID0geFswXTtcbiAgICB2YXIgbWF4ID0geFswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHhbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhbaV0gPCBtaW4pIHtcbiAgICAgICAgICAgIG1pbiA9IHhbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbi8qKlxuICogVGhlIG1pbmltdW0gaXMgdGhlIGxvd2VzdCBudW1iZXIgaW4gdGhlIGFycmF5LiBXaXRoIGEgc29ydGVkIGFycmF5LFxuICogdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIGFsd2F5cyB0aGUgc21hbGxlc3QsIHNvIHRoaXMgY2FsY3VsYXRpb25cbiAqIGNhbiBiZSBkb25lIGluIG9uZSBzdGVwLCBvciBjb25zdGFudCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gbWluaW11bSB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIG1pblNvcnRlZChbLTEwMCwgLTEwLCAxLCAyLCA1XSk7IC8vID0+IC0xMDBcbiAqL1xuZnVuY3Rpb24gbWluU29ydGVkKHgpIHtcbiAgICByZXR1cm4geFswXTtcbn1cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBpcyB0aGUgaGlnaGVzdCBudW1iZXIgaW4gdGhlIGFycmF5LiBXaXRoIGEgc29ydGVkIGFycmF5LFxuICogdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgYWx3YXlzIHRoZSBsYXJnZXN0LCBzbyB0aGlzIGNhbGN1bGF0aW9uXG4gKiBjYW4gYmUgZG9uZSBpbiBvbmUgc3RlcCwgb3IgY29uc3RhbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1heGltdW0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtYXhTb3J0ZWQoWy0xMDAsIC0xMCwgMSwgMiwgNV0pOyAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIG1heFNvcnRlZCh4KSB7XG4gICAgcmV0dXJuIHhbeC5sZW5ndGggLSAxXTtcbn1cblxuLyoqXG4gKiBUaGUgZXh0ZW50IGlzIHRoZSBsb3dlc3QgJiBoaWdoZXN0IG51bWJlciBpbiB0aGUgYXJyYXkuIFdpdGggYSBzb3J0ZWQgYXJyYXksXG4gKiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgYWx3YXlzIHRoZSBsb3dlc3Qgd2hpbGUgdGhlIGxhc3QgZWxlbWVudCBpcyBhbHdheXMgdGhlIGxhcmdlc3QsIHNvIHRoaXMgY2FsY3VsYXRpb25cbiAqIGNhbiBiZSBkb25lIGluIG9uZSBzdGVwLCBvciBjb25zdGFudCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IG1pbmltdW0gJiBtYXhpbXVtIHZhbHVlXG4gKiBAZXhhbXBsZVxuICogZXh0ZW50U29ydGVkKFstMTAwLCAtMTAsIDEsIDIsIDVdKTsgLy8gPT4gWy0xMDAsIDVdXG4gKi9cbmZ1bmN0aW9uIGV4dGVudFNvcnRlZCh4KSB7XG4gICAgcmV0dXJuIFt4WzBdLCB4W3gubGVuZ3RoIC0gMV1dO1xufVxuXG4vKipcbiAqIFRoZSBzaW1wbGUgW3N1bV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3VtbWF0aW9uKSBvZiBhbiBhcnJheVxuICogaXMgdGhlIHJlc3VsdCBvZiBhZGRpbmcgYWxsIG51bWJlcnMgdG9nZXRoZXIsIHN0YXJ0aW5nIGZyb20gemVyby5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfSBzdW0gb2YgYWxsIGlucHV0IG51bWJlcnNcbiAqIEBleGFtcGxlXG4gKiBzdW1TaW1wbGUoWzEsIDIsIDNdKTsgLy8gPT4gNlxuICovXG5mdW5jdGlvbiBzdW1TaW1wbGUoeCkge1xuICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeFtpXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0geFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBbcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvZHVjdF8obWF0aGVtYXRpY3MpKSBvZiBhbiBhcnJheVxuICogaXMgdGhlIHJlc3VsdCBvZiBtdWx0aXBseWluZyBhbGwgbnVtYmVycyB0b2dldGhlciwgc3RhcnRpbmcgdXNpbmcgb25lIGFzIHRoZSBtdWx0aXBsaWNhdGl2ZSBpZGVudGl0eS5cbiAqXG4gKiBUaGlzIHJ1bnMgaW4gYE8obilgLCBsaW5lYXIgdGltZSwgd2l0aCByZXNwZWN0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfSBwcm9kdWN0IG9mIGFsbCBpbnB1dCBudW1iZXJzXG4gKiBAZXhhbXBsZVxuICogcHJvZHVjdChbMSwgMiwgMywgNF0pOyAvLyA9PiAyNFxuICovXG5mdW5jdGlvbiBwcm9kdWN0KHgpIHtcbiAgICB2YXIgdmFsdWUgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSAqPSB4W2ldO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgcXVhbnRpbGVzOiB3aGVuIHlvdSBrbm93XG4gKiB0aGF0IHRoZSBvcmRlciBpcyBzb3J0ZWQsIHlvdSBkb24ndCBuZWVkIHRvIHJlLXNvcnQgaXQsIGFuZCB0aGUgY29tcHV0YXRpb25zXG4gKiBhcmUgZmFzdGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwIGRlc2lyZWQgcXVhbnRpbGU6IGEgbnVtYmVyIGJldHdlZW4gMCB0byAxLCBpbmNsdXNpdmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHF1YW50aWxlIHZhbHVlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcCBpeCBvdXRzaWRlIG9mIHRoZSByYW5nZSBmcm9tIDAgdG8gMVxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZVNvcnRlZChbMywgNiwgNywgOCwgOCwgOSwgMTAsIDEzLCAxNSwgMTYsIDIwXSwgMC41KTsgLy8gPT4gOVxuICovXG5mdW5jdGlvbiBxdWFudGlsZVNvcnRlZCh4LCBwKSB7XG4gICAgdmFyIGlkeCA9IHgubGVuZ3RoICogcDtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpbGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQuXCIpO1xuICAgIH0gZWxzZSBpZiAocCA8IDAgfHwgcCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpbGVzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMSkge1xuICAgICAgICAvLyBJZiBwIGlzIDEsIGRpcmVjdGx5IHJldHVybiB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgIHJldHVybiB4W3gubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMCwgZGlyZWN0bHkgcmV0dXJuIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgIHJldHVybiB4WzBdO1xuICAgIH0gZWxzZSBpZiAoaWR4ICUgMSAhPT0gMCkge1xuICAgICAgICAvLyBJZiBwIGlzIG5vdCBpbnRlZ2VyLCByZXR1cm4gdGhlIG5leHQgZWxlbWVudCBpbiBhcnJheVxuICAgICAgICByZXR1cm4geFtNYXRoLmNlaWwoaWR4KSAtIDFdO1xuICAgIH0gZWxzZSBpZiAoeC5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgIC8vIElmIHRoZSBsaXN0IGhhcyBldmVuLWxlbmd0aCwgd2UnbGwgdGFrZSB0aGUgYXZlcmFnZSBvZiB0aGlzIG51bWJlclxuICAgICAgICAvLyBhbmQgdGhlIG5leHQgdmFsdWUsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICByZXR1cm4gKHhbaWR4IC0gMV0gKyB4W2lkeF0pIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaW5hbGx5LCBpbiB0aGUgc2ltcGxlIGNhc2Ugb2YgYW4gaW50ZWdlciB2YWx1ZVxuICAgICAgICAvLyB3aXRoIGFuIG9kZC1sZW5ndGggbGlzdCwgcmV0dXJuIHRoZSB4IHZhbHVlIGF0IHRoZSBpbmRleC5cbiAgICAgICAgcmV0dXJuIHhbaWR4XTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVhcnJhbmdlIGl0ZW1zIGluIGBhcnJgIHNvIHRoYXQgYWxsIGl0ZW1zIGluIGBbbGVmdCwga11gIHJhbmdlIGFyZSB0aGUgc21hbGxlc3QuXG4gKiBUaGUgYGtgLXRoIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSBgKGsgLSBsZWZ0ICsgMSlgLXRoIHNtYWxsZXN0IHZhbHVlIGluIGBbbGVmdCwgcmlnaHRdYC5cbiAqXG4gKiBJbXBsZW1lbnRzIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zsb3lkLVJpdmVzdF9hbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFyciBpbnB1dCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGsgcGl2b3QgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVmdF0gbGVmdCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtyaWdodF0gcmlnaHQgaW5kZXhcbiAqIEByZXR1cm5zIHt2b2lkfSBtdXRhdGVzIGlucHV0IGFycmF5XG4gKiBAZXhhbXBsZVxuICogdmFyIGFyciA9IFs2NSwgMjgsIDU5LCAzMywgMjEsIDU2LCAyMiwgOTUsIDUwLCAxMiwgOTAsIDUzLCAyOCwgNzcsIDM5XTtcbiAqIHF1aWNrc2VsZWN0KGFyciwgOCk7XG4gKiAvLyA9IFszOSwgMjgsIDI4LCAzMywgMjEsIDEyLCAyMiwgNTAsIDUzLCA1NiwgNTksIDY1LCA5MCwgNzcsIDk1XVxuICovXG5mdW5jdGlvbiBxdWlja3NlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgICByaWdodCA9IHJpZ2h0IHx8IGFyci5sZW5ndGggLSAxO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICAvLyA2MDAgYW5kIDAuNSBhcmUgYXJiaXRyYXJ5IGNvbnN0YW50cyBjaG9zZW4gaW4gdGhlIG9yaWdpbmFsIHBhcGVyIHRvIG1pbmltaXplIGV4ZWN1dGlvbiB0aW1lXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoKDIgKiB6KSAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KCh6ICogcyAqIChuIC0gcykpIC8gbik7XG4gICAgICAgICAgICBpZiAobSAtIG4gLyAyIDwgMCkgeyBzZCAqPSAtMTsgfVxuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSAobSAqIHMpIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGsgKyAoKG4gLSBtKSAqIHMpIC8gbiArIHNkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChhcnJbcmlnaHRdID4gdCkgeyBzd2FwKGFyciwgbGVmdCwgcmlnaHQpOyB9XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoYXJyW2ldIDwgdCkgeyBpKys7IH1cbiAgICAgICAgICAgIHdoaWxlIChhcnJbal0gPiB0KSB7IGotLTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycltsZWZ0XSA9PT0gdCkgeyBzd2FwKGFyciwgbGVmdCwgaik7IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgeyBsZWZ0ID0gaiArIDE7IH1cbiAgICAgICAgaWYgKGsgPD0gaikgeyByaWdodCA9IGogLSAxOyB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuLyoqXG4gKiBUaGUgW3F1YW50aWxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWFudGlsZSk6XG4gKiB0aGlzIGlzIGEgcG9wdWxhdGlvbiBxdWFudGlsZSwgc2luY2Ugd2UgYXNzdW1lIHRvIGtub3cgdGhlIGVudGlyZVxuICogZGF0YXNldCBpbiB0aGlzIGxpYnJhcnkuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gKiBbUXVhbnRpbGVzIG9mIGEgUG9wdWxhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWFudGlsZSNRdWFudGlsZXNfb2ZfYV9wb3B1bGF0aW9uKVxuICogYWxnb3JpdGhtIGZyb20gd2lraXBlZGlhLlxuICpcbiAqIFNhbXBsZSBpcyBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBudW1iZXJzLFxuICogYW5kIHAgaXMgZWl0aGVyIGEgZGVjaW1hbCBudW1iZXIgZnJvbSAwIHRvIDEgb3IgYW4gYXJyYXkgb2YgZGVjaW1hbFxuICogbnVtYmVycyBmcm9tIDAgdG8gMS5cbiAqIEluIHRlcm1zIG9mIGEgay9xIHF1YW50aWxlLCBwID0gay9xIC0gaXQncyBqdXN0IGRlYWxpbmcgd2l0aCBmcmFjdGlvbnMgb3IgZGVhbGluZ1xuICogd2l0aCBkZWNpbWFsIHZhbHVlcy5cbiAqIFdoZW4gcCBpcyBhbiBhcnJheSwgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaXMgYWxzbyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBhcHByb3ByaWF0ZVxuICogcXVhbnRpbGVzIGluIGlucHV0IG9yZGVyXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj4gfCBudW1iZXJ9IHAgdGhlIGRlc2lyZWQgcXVhbnRpbGUsIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge251bWJlcn0gcXVhbnRpbGVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZShbMywgNiwgNywgOCwgOCwgOSwgMTAsIDEzLCAxNSwgMTYsIDIwXSwgMC41KTsgLy8gPT4gOVxuICovXG5mdW5jdGlvbiBxdWFudGlsZSh4LCBwKSB7XG4gICAgdmFyIGNvcHkgPSB4LnNsaWNlKCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgICAvLyByZWFycmFuZ2UgZWxlbWVudHMgc28gdGhhdCBlYWNoIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIHJlcXVlc3RlZFxuICAgICAgICAvLyBxdWFudGlsZSBpcyBvbiBhIHBsYWNlIGl0IHdvdWxkIGJlIGlmIHRoZSBhcnJheSB3YXMgZnVsbHkgc29ydGVkXG4gICAgICAgIG11bHRpUXVhbnRpbGVTZWxlY3QoY29weSwgcCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0ZWQgcXVhbnRpbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcXVhbnRpbGVTb3J0ZWQoY29weSwgcFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IHF1YW50aWxlSW5kZXgoY29weS5sZW5ndGgsIHApO1xuICAgICAgICBxdWFudGlsZVNlbGVjdChjb3B5LCBpZHgsIDAsIGNvcHkubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBxdWFudGlsZVNvcnRlZChjb3B5LCBwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlU2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoayAlIDEgPT09IDApIHtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgayA9IE1hdGguZmxvb3Ioayk7XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQpO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIGsgKyAxLCBrICsgMSwgcmlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbXVsdGlRdWFudGlsZVNlbGVjdChhcnIsIHApIHtcbiAgICB2YXIgaW5kaWNlcyA9IFswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHF1YW50aWxlSW5kZXgoYXJyLmxlbmd0aCwgcFtpXSkpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2goYXJyLmxlbmd0aCAtIDEpO1xuICAgIGluZGljZXMuc29ydChjb21wYXJlKTtcblxuICAgIHZhciBzdGFjayA9IFswLCBpbmRpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgciA9IE1hdGguY2VpbChzdGFjay5wb3AoKSk7XG4gICAgICAgIHZhciBsID0gTWF0aC5mbG9vcihzdGFjay5wb3AoKSk7XG4gICAgICAgIGlmIChyIC0gbCA8PSAxKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKChsICsgcikgLyAyKTtcbiAgICAgICAgcXVhbnRpbGVTZWxlY3QoXG4gICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICBpbmRpY2VzW21dLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihpbmRpY2VzW2xdKSxcbiAgICAgICAgICAgIE1hdGguY2VpbChpbmRpY2VzW3JdKVxuICAgICAgICApO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobCwgbSwgbSwgcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlSW5kZXgobGVuLCBwKSB7XG4gICAgdmFyIGlkeCA9IGxlbiAqIHA7XG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgLy8gSWYgcCBpcyAxLCBkaXJlY3RseSByZXR1cm4gdGhlIGxhc3QgaW5kZXhcbiAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG4gICAgfSBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgIC8vIElmIHAgaXMgMCwgZGlyZWN0bHkgcmV0dXJuIHRoZSBmaXJzdCBpbmRleFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGlkeCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gSWYgaW5kZXggaXMgbm90IGludGVnZXIsIHJldHVybiB0aGUgbmV4dCBpbmRleCBpbiBhcnJheVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGlkeCkgLSAxO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBJZiB0aGUgbGlzdCBoYXMgZXZlbi1sZW5ndGgsIHdlJ2xsIHJldHVybiB0aGUgbWlkZGxlIG9mIHR3byBpbmRpY2VzXG4gICAgICAgIC8vIGFyb3VuZCBxdWFudGlsZSB0byBpbmRpY2F0ZSB0aGF0IHdlIG5lZWQgYW4gYXZlcmFnZSB2YWx1ZSBvZiB0aGUgdHdvXG4gICAgICAgIHJldHVybiBpZHggLSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWxseSwgaW4gdGhlIHNpbXBsZSBjYXNlIG9mIGFuIGludGVnZXIgaW5kZXhcbiAgICAgICAgLy8gd2l0aCBhbiBvZGQtbGVuZ3RoIGxpc3QsIHJldHVybiB0aGUgaW5kZXhcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG59XG5cbi8qIGVzbGludCBuby1iaXR3aXNlOiAwICovXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBxdWFudGlsZSBpbiB3aGljaCBvbmUgd291bGQgZmluZCB0aGUgZ2l2ZW4gdmFsdWUgaW5cbiAqIHRoZSBnaXZlbiBhcnJheS4gV2l0aCBhIHNvcnRlZCBhcnJheSwgbGV2ZXJhZ2luZyBiaW5hcnkgc2VhcmNoLCB3ZSBjYW4gZmluZFxuICogdGhpcyBpbmZvcm1hdGlvbiBpbiBsb2dhcml0aG1pYyB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gdmFsdWUgdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZVJhbmtTb3J0ZWQoWzEsIDIsIDMsIDRdLCAzKTsgLy8gPT4gMC43NVxuICogcXVhbnRpbGVSYW5rU29ydGVkKFsxLCAyLCAzLCAzLCA0XSwgMyk7IC8vID0+IDAuN1xuICogcXVhbnRpbGVSYW5rU29ydGVkKFsxLCAyLCAzLCA0XSwgNik7IC8vID0+IDFcbiAqIHF1YW50aWxlUmFua1NvcnRlZChbMSwgMiwgMywgMywgNV0sIDQpOyAvLyA9PiAwLjhcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVSYW5rU29ydGVkKHgsIHZhbHVlKSB7XG4gICAgLy8gVmFsdWUgaXMgbGVzc2VyIHRoYW4gYW55IHZhbHVlIGluIHRoZSBhcnJheVxuICAgIGlmICh2YWx1ZSA8IHhbMF0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gVmFsdWUgaXMgZ3JlYXRlciB0aGFuIGFueSB2YWx1ZSBpbiB0aGUgYXJyYXlcbiAgICBpZiAodmFsdWUgPiB4W3gubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBsb3dlckJvdW5kKHgsIHZhbHVlKTtcblxuICAgIC8vIFZhbHVlIGlzIG5vdCBpbiB0aGUgYXJyYXlcbiAgICBpZiAoeFtsXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGwgLyB4Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBsKys7XG5cbiAgICB2YXIgdSA9IHVwcGVyQm91bmQoeCwgdmFsdWUpO1xuXG4gICAgLy8gVGhlIHZhbHVlIGV4aXN0cyBvbmx5IG9uY2UgaW4gdGhlIGFycmF5XG4gICAgaWYgKHUgPT09IGwpIHtcbiAgICAgICAgcmV0dXJuIGwgLyB4Lmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBIZXJlLCB3ZSBhcmUgYmFzaWNhbGx5IGNvbXB1dGluZyB0aGUgbWVhbiBvZiB0aGUgcmFuZ2Ugb2YgaW5kaWNlc1xuICAgIC8vIGNvbnRhaW5pbmcgb3VyIHNlYXJjaGVkIHZhbHVlLiBCdXQsIGluc3RlYWQsIG9mIGluaXRpYWxpemluZyBhblxuICAgIC8vIGFycmF5IGFuZCBsb29waW5nIG92ZXIgaXQsIHRoZXJlIGlzIGEgZGVkaWNhdGVkIG1hdGggZm9ybXVsYSB0aGF0XG4gICAgLy8gd2UgYXBwbHkgYmVsb3cgdG8gZ2V0IHRoZSByZXN1bHQuXG4gICAgdmFyIHIgPSB1IC0gbCArIDE7XG4gICAgdmFyIHN1bSA9IChyICogKHUgKyBsKSkgLyAyO1xuICAgIHZhciBtZWFuID0gc3VtIC8gcjtcblxuICAgIHJldHVybiBtZWFuIC8geC5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGxvd2VyQm91bmQoeCwgdmFsdWUpIHtcbiAgICB2YXIgbWlkID0gMDtcbiAgICB2YXIgbG8gPSAwO1xuICAgIHZhciBoaSA9IHgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuXG4gICAgICAgIGlmICh2YWx1ZSA8PSB4W21pZF0pIHtcbiAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG8gPSAtfm1pZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsbztcbn1cblxuZnVuY3Rpb24gdXBwZXJCb3VuZCh4LCB2YWx1ZSkge1xuICAgIHZhciBtaWQgPSAwO1xuICAgIHZhciBsbyA9IDA7XG4gICAgdmFyIGhpID0geC5sZW5ndGg7XG5cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG5cbiAgICAgICAgaWYgKHZhbHVlID49IHhbbWlkXSkge1xuICAgICAgICAgICAgbG8gPSAtfm1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcXVhbnRpbGUgaW4gd2hpY2ggb25lIHdvdWxkIGZpbmQgdGhlIGdpdmVuIHZhbHVlIGluXG4gKiB0aGUgZ2l2ZW4gYXJyYXkuIEl0IHdpbGwgY29weSBhbmQgc29ydCB5b3VyIGFycmF5IGJlZm9yZSBlYWNoIHJ1biwgc29cbiAqIGlmIHlvdSBrbm93IHlvdXIgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWQsIHlvdSBzaG91bGQgdXNlIGBxdWFudGlsZVJhbmtTb3J0ZWRgXG4gKiBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gdmFsdWUgdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBxdWFudGlsZVJhbmsoWzQsIDMsIDEsIDJdLCAzKTsgLy8gPT4gMC43NVxuICogcXVhbnRpbGVSYW5rKFs0LCAzLCAyLCAzLCAxXSwgMyk7IC8vID0+IDAuN1xuICogcXVhbnRpbGVSYW5rKFsyLCA0LCAxLCAzXSwgNik7IC8vID0+IDFcbiAqIHF1YW50aWxlUmFuayhbNSwgMywgMSwgMiwgM10sIDQpOyAvLyA9PiAwLjhcbiAqL1xuZnVuY3Rpb24gcXVhbnRpbGVSYW5rKHgsIHZhbHVlKSB7XG4gICAgLy8gQ2xvbmluZyBhbmQgc29ydGluZyB0aGUgYXJyYXlcbiAgICB2YXIgc29ydGVkQ29weSA9IG51bWVyaWNTb3J0KHgpO1xuXG4gICAgcmV0dXJuIHF1YW50aWxlUmFua1NvcnRlZChzb3J0ZWRDb3B5LCB2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIFtJbnRlcnF1YXJ0aWxlIHJhbmdlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVycXVhcnRpbGVfcmFuZ2UpIGlzXG4gKiBhIG1lYXN1cmUgb2Ygc3RhdGlzdGljYWwgZGlzcGVyc2lvbiwgb3IgaG93IHNjYXR0ZXJlZCwgc3ByZWFkLCBvclxuICogY29uY2VudHJhdGVkIGEgZGlzdHJpYnV0aW9uIGlzLiBJdCdzIGNvbXB1dGVkIGFzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAqIHRoZSB0aGlyZCBxdWFydGlsZSBhbmQgZmlyc3QgcXVhcnRpbGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnRlcnF1YXJ0aWxlIHJhbmdlOiB0aGUgc3BhbiBiZXR3ZWVuIGxvd2VyIGFuZCB1cHBlciBxdWFydGlsZSxcbiAqIDAuMjUgYW5kIDAuNzVcbiAqIEBleGFtcGxlXG4gKiBpbnRlcnF1YXJ0aWxlUmFuZ2UoWzAsIDEsIDIsIDNdKTsgLy8gPT4gMlxuICovXG5mdW5jdGlvbiBpbnRlcnF1YXJ0aWxlUmFuZ2UoeCkge1xuICAgIC8vIEludGVycXVhcnRpbGUgcmFuZ2UgaXMgdGhlIHNwYW4gYmV0d2VlbiB0aGUgdXBwZXIgcXVhcnRpbGUsXG4gICAgLy8gYXQgYDAuNzVgLCBhbmQgbG93ZXIgcXVhcnRpbGUsIGAwLjI1YFxuICAgIHZhciBxMSA9IHF1YW50aWxlKHgsIDAuNzUpO1xuICAgIHZhciBxMiA9IHF1YW50aWxlKHgsIDAuMjUpO1xuXG4gICAgaWYgKHR5cGVvZiBxMSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcTIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHExIC0gcTI7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBbbWVkaWFuXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lZGlhbikgaXNcbiAqIHRoZSBtaWRkbGUgbnVtYmVyIG9mIGEgbGlzdC4gVGhpcyBpcyBvZnRlbiBhIGdvb2QgaW5kaWNhdG9yIG9mICd0aGUgbWlkZGxlJ1xuICogd2hlbiB0aGVyZSBhcmUgb3V0bGllcnMgdGhhdCBza2V3IHRoZSBgbWVhbigpYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGUgbWVkaWFuIGlzbid0IG5lY2Vzc2FyaWx5IG9uZSBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIGxpc3Q6IHRoZSB2YWx1ZVxuICogY2FuIGJlIHRoZSBhdmVyYWdlIG9mIHR3byBlbGVtZW50cyBpZiB0aGUgbGlzdCBoYXMgYW4gZXZlbiBsZW5ndGhcbiAqIGFuZCB0aGUgdHdvIGNlbnRyYWwgdmFsdWVzIGFyZSBkaWZmZXJlbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBtZWRpYW4gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiBtZWRpYW4oWzEwLCAyLCA1LCAxMDAsIDIsIDFdKTsgLy8gPT4gMy41XG4gKi9cbmZ1bmN0aW9uIG1lZGlhbih4KSB7XG4gICAgcmV0dXJuICtxdWFudGlsZSh4LCAwLjUpO1xufVxuXG4vKipcbiAqIFRoZSBbTWVkaWFuIEFic29sdXRlIERldmlhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZWRpYW5fYWJzb2x1dGVfZGV2aWF0aW9uKSBpc1xuICogYSByb2J1c3QgbWVhc3VyZSBvZiBzdGF0aXN0aWNhbFxuICogZGlzcGVyc2lvbi4gSXQgaXMgbW9yZSByZXNpbGllbnQgdG8gb3V0bGllcnMgdGhhbiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBpbnB1dCBhcnJheVxuICogQHJldHVybnMge251bWJlcn0gbWVkaWFuIGFic29sdXRlIGRldmlhdGlvblxuICogQGV4YW1wbGVcbiAqIG1lZGlhbkFic29sdXRlRGV2aWF0aW9uKFsxLCAxLCAyLCAyLCA0LCA2LCA5XSk7IC8vID0+IDFcbiAqL1xuZnVuY3Rpb24gbWVkaWFuQWJzb2x1dGVEZXZpYXRpb24oeCkge1xuICAgIHZhciBtZWRpYW5WYWx1ZSA9IG1lZGlhbih4KTtcbiAgICB2YXIgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb25zID0gW107XG5cbiAgICAvLyBNYWtlIGEgbGlzdCBvZiBhYnNvbHV0ZSBkZXZpYXRpb25zIGZyb20gdGhlIG1lZGlhblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbnMucHVzaChNYXRoLmFicyh4W2ldIC0gbWVkaWFuVmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBtZWRpYW4gdmFsdWUgb2YgdGhhdCBsaXN0XG4gICAgcmV0dXJuIG1lZGlhbihtZWRpYW5BYnNvbHV0ZURldmlhdGlvbnMpO1xufVxuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5IGludG8gY2h1bmtzIG9mIGEgc3BlY2lmaWVkIHNpemUuIFRoaXMgZnVuY3Rpb25cbiAqIGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBbUEhQJ3MgYXJyYXlfY2h1bmtdKGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9mdW5jdGlvbi5hcnJheS1jaHVuay5waHApXG4gKiBmdW5jdGlvbiwgYW5kIHRodXMgd2lsbCBpbnNlcnQgc21hbGxlci1zaXplZCBjaHVua3MgYXQgdGhlIGVuZCBpZlxuICogdGhlIGlucHV0IHNpemUgaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgY2h1bmsgc2l6ZS5cbiAqXG4gKiBgeGAgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXksIGFuZCBgY2h1bmtTaXplYCBhIG51bWJlci5cbiAqIFRoZSBgeGAgYXJyYXkgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IGEgc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gY2h1bmtTaXplIHNpemUgb2YgZWFjaCBvdXRwdXQgYXJyYXkuIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSBhIGNodW5rZWQgYXJyYXlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBjaHVuayBzaXplIGlzIGxlc3MgdGhhbiAxIG9yIG5vdCBhbiBpbnRlZ2VyXG4gKiBAZXhhbXBsZVxuICogY2h1bmsoWzEsIDIsIDMsIDQsIDUsIDZdLCAyKTtcbiAqIC8vID0+IFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdXVxuICovXG5mdW5jdGlvbiBjaHVuayh4LCBjaHVua1NpemUpIHtcbiAgICAvLyBhIGxpc3Qgb2YgcmVzdWx0IGNodW5rcywgYXMgYXJyYXlzIGluIGFuIGFycmF5XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgLy8gYGNodW5rU2l6ZWAgbXVzdCBiZSB6ZXJvIG9yIGhpZ2hlciAtIG90aGVyd2lzZSB0aGUgbG9vcCBiZWxvdyxcbiAgICAvLyBpbiB3aGljaCB3ZSBjYWxsIGBzdGFydCArPSBjaHVua1NpemVgLCB3aWxsIGxvb3AgaW5maW5pdGVseS5cbiAgICAvLyBTbywgd2UnbGwgZGV0ZWN0IGFuZCB0aHJvdyBpbiB0aGF0IGNhc2UgdG8gaW5kaWNhdGVcbiAgICAvLyBpbnZhbGlkIGlucHV0LlxuICAgIGlmIChjaHVua1NpemUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rIHNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5mbG9vcihjaHVua1NpemUpICE9PSBjaHVua1NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2h1bmsgc2l6ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgfVxuXG4gICAgLy8gYHN0YXJ0YCBpcyB0aGUgaW5kZXggYXQgd2hpY2ggYC5zbGljZWAgd2lsbCBzdGFydCBzZWxlY3RpbmdcbiAgICAvLyBuZXcgYXJyYXkgZWxlbWVudHNcbiAgICBmb3IgKHZhciBzdGFydCA9IDA7IHN0YXJ0IDwgeC5sZW5ndGg7IHN0YXJ0ICs9IGNodW5rU2l6ZSkge1xuICAgICAgICAvLyBmb3IgZWFjaCBjaHVuaywgc2xpY2UgdGhhdCBwYXJ0IG9mIHRoZSBhcnJheSBhbmQgYWRkIGl0XG4gICAgICAgIC8vIHRvIHRoZSBvdXRwdXQuIFRoZSBgLnNsaWNlYCBmdW5jdGlvbiBkb2VzIG5vdCBjaGFuZ2VcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgICAgICBvdXRwdXQucHVzaCh4LnNsaWNlKHN0YXJ0LCBzdGFydCArIGNodW5rU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIFNhbXBsaW5nIHdpdGggcmVwbGFjZW1lbnQgaXMgYSB0eXBlIG9mIHNhbXBsaW5nIHRoYXQgYWxsb3dzIHRoZSBzYW1lXG4gKiBpdGVtIHRvIGJlIHBpY2tlZCBvdXQgb2YgYSBwb3B1bGF0aW9uIG1vcmUgdGhhbiBvbmNlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHggYW4gYXJyYXkgb2YgYW55IGtpbmQgb2YgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIGNvdW50IG9mIGhvdyBtYW55IGVsZW1lbnRzIHRvIHRha2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYW5kb21Tb3VyY2U9TWF0aC5yYW5kb21dIGFuIG9wdGlvbmFsIGVudHJvcHkgc291cmNlIHRoYXRcbiAqIHJldHVybnMgbnVtYmVycyBiZXR3ZWVuIDAgaW5jbHVzaXZlIGFuZCAxIGV4Y2x1c2l2ZTogdGhlIHJhbmdlIFswLCAxKVxuICogQHJldHVybiB7QXJyYXl9IG4gc2FtcGxlZCBpdGVtcyBmcm9tIHRoZSBwb3B1bGF0aW9uXG4gKiBAZXhhbXBsZVxuICogdmFyIHZhbHVlcyA9IFsxLCAyLCAzLCA0XTtcbiAqIHNhbXBsZVdpdGhSZXBsYWNlbWVudCh2YWx1ZXMsIDIpOyAvLyByZXR1cm5zIDIgcmFuZG9tIHZhbHVlcywgbGlrZSBbMiwgNF07XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVdpdGhSZXBsYWNlbWVudCh4LCBuLCByYW5kb21Tb3VyY2UpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIGEgY3VzdG9tIHJhbmRvbSBudW1iZXIgc291cmNlIGNhbiBiZSBwcm92aWRlZCBpZiB5b3Ugd2FudCB0byB1c2VcbiAgICAvLyBhIGZpeGVkIHNlZWQgb3IgYW5vdGhlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvciwgbGlrZVxuICAgIC8vIFtyYW5kb20tanNdKGh0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL3JhbmRvbS1qcylcbiAgICByYW5kb21Tb3VyY2UgPSByYW5kb21Tb3VyY2UgfHwgTWF0aC5yYW5kb207XG5cbiAgICB2YXIgbGVuZ3RoID0geC5sZW5ndGg7XG4gICAgdmFyIHNhbXBsZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcihyYW5kb21Tb3VyY2UoKSAqIGxlbmd0aCk7XG5cbiAgICAgICAgc2FtcGxlLnB1c2goeFtpbmRleF0pO1xuICAgIH1cblxuICAgIHJldHVybiBzYW1wbGU7XG59XG5cbi8qKlxuICogQSBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZSlcbiAqIGluLXBsYWNlIC0gd2hpY2ggbWVhbnMgdGhhdCBpdCAqKndpbGwgY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgb3JpZ2luYWxcbiAqIGFycmF5IGJ5IHJlZmVyZW5jZSoqLlxuICpcbiAqIFRoaXMgaXMgYW4gYWxnb3JpdGhtIHRoYXQgZ2VuZXJhdGVzIGEgcmFuZG9tIFtwZXJtdXRhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVybXV0YXRpb24pXG4gKiBvZiBhIHNldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IHNhbXBsZSBvZiBvbmUgb3IgbW9yZSBudW1iZXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmFuZG9tU291cmNlPU1hdGgucmFuZG9tXSBhbiBvcHRpb25hbCBlbnRyb3B5IHNvdXJjZSB0aGF0XG4gKiByZXR1cm5zIG51bWJlcnMgYmV0d2VlbiAwIGluY2x1c2l2ZSBhbmQgMSBleGNsdXNpdmU6IHRoZSByYW5nZSBbMCwgMSlcbiAqIEByZXR1cm5zIHtBcnJheX0geFxuICogQGV4YW1wbGVcbiAqIHZhciB4ID0gWzEsIDIsIDMsIDRdO1xuICogc2h1ZmZsZUluUGxhY2UoeCk7XG4gKiAvLyB4IGlzIHNodWZmbGVkIHRvIGEgdmFsdWUgbGlrZSBbMiwgMSwgNCwgM11cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZUluUGxhY2UoeCwgcmFuZG9tU291cmNlKSB7XG4gICAgLy8gYSBjdXN0b20gcmFuZG9tIG51bWJlciBzb3VyY2UgY2FuIGJlIHByb3ZpZGVkIGlmIHlvdSB3YW50IHRvIHVzZVxuICAgIC8vIGEgZml4ZWQgc2VlZCBvciBhbm90aGVyIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLCBsaWtlXG4gICAgLy8gW3JhbmRvbS1qc10oaHR0cHM6Ly93d3cubnBtanMub3JnL3BhY2thZ2UvcmFuZG9tLWpzKVxuICAgIHJhbmRvbVNvdXJjZSA9IHJhbmRvbVNvdXJjZSB8fCBNYXRoLnJhbmRvbTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgeCB0byBkZXRlcm1pbmVcbiAgICAvLyB3aGVuIG5vIGVsZW1lbnRzIHJlbWFpbiB0byBzaHVmZmxlLlxuICAgIHZhciBsZW5ndGggPSB4Lmxlbmd0aDtcblxuICAgIC8vIHRlbXBvcmFyeSBpcyB1c2VkIHRvIGhvbGQgYW4gaXRlbSB3aGVuIGl0IGlzIGJlaW5nXG4gICAgLy8gc3dhcHBlZCBiZXR3ZWVuIGluZGljZXMuXG4gICAgdmFyIHRlbXBvcmFyeTtcblxuICAgIC8vIFRoZSBpbmRleCB0byBzd2FwIGF0IGVhY2ggc3RhZ2UuXG4gICAgdmFyIGluZGV4O1xuXG4gICAgLy8gV2hpbGUgdGhlcmUgYXJlIHN0aWxsIGl0ZW1zIHRvIHNodWZmbGVcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjaG9vc2UgYSByYW5kb20gaW5kZXggd2l0aGluIHRoZSBzdWJzZXQgb2YgdGhlIGFycmF5XG4gICAgICAgIC8vIHRoYXQgaXMgbm90IHlldCBzaHVmZmxlZFxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IocmFuZG9tU291cmNlKCkgKiBsZW5ndGgtLSk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHZhbHVlIHRoYXQgd2UnbGwgbW92ZSB0ZW1wb3JhcmlseVxuICAgICAgICB0ZW1wb3JhcnkgPSB4W2xlbmd0aF07XG5cbiAgICAgICAgLy8gc3dhcCB0aGUgdmFsdWUgYXQgYHhbbGVuZ3RoXWAgd2l0aCBgeFtpbmRleF1gXG4gICAgICAgIHhbbGVuZ3RoXSA9IHhbaW5kZXhdO1xuICAgICAgICB4W2luZGV4XSA9IHRlbXBvcmFyeTtcbiAgICB9XG5cbiAgICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBBIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXIlRTIlODAlOTNZYXRlc19zaHVmZmxlKVxuICogaXMgYSBmYXN0IHdheSB0byBjcmVhdGUgYSByYW5kb20gcGVybXV0YXRpb24gb2YgYSBmaW5pdGUgc2V0LiBUaGlzIGlzXG4gKiBhIGZ1bmN0aW9uIGFyb3VuZCBgc2h1ZmZsZV9pbl9wbGFjZWAgdGhhdCBhZGRzIHRoZSBndWFyYW50ZWUgdGhhdFxuICogaXQgd2lsbCBub3QgbW9kaWZ5IGl0cyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IHNhbXBsZSBvZiAwIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdFxuICogcmV0dXJucyBudW1iZXJzIGJldHdlZW4gMCBpbmNsdXNpdmUgYW5kIDEgZXhjbHVzaXZlOiB0aGUgcmFuZ2UgWzAsIDEpXG4gKiBAcmV0dXJuIHtBcnJheX0gc2h1ZmZsZWQgdmVyc2lvbiBvZiBpbnB1dFxuICogQGV4YW1wbGVcbiAqIHZhciBzaHVmZmxlZCA9IHNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIHNodWZmbGVkOyAvLyA9IFsyLCAzLCAxLCA0XSBvciBhbnkgb3RoZXIgcmFuZG9tIHBlcm11dGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoeCwgcmFuZG9tU291cmNlKSB7XG4gICAgLy8gc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5IHNvIHRoYXQgaXQgaXMgbm90IG1vZGlmaWVkXG4gICAgdmFyIHNhbXBsZSA9IHguc2xpY2UoKTtcblxuICAgIC8vIGFuZCB0aGVuIHNodWZmbGUgdGhhdCBzaGFsbG93LWNvcGllZCBhcnJheSwgaW4gcGxhY2VcbiAgICByZXR1cm4gc2h1ZmZsZUluUGxhY2Uoc2FtcGxlLCByYW5kb21Tb3VyY2UpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFtzaW1wbGUgcmFuZG9tIHNhbXBsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfcmFuZG9tX3NhbXBsZSlcbiAqIGZyb20gYSBnaXZlbiBhcnJheSBvZiBgbmAgZWxlbWVudHMuXG4gKlxuICogVGhlIHNhbXBsZWQgdmFsdWVzIHdpbGwgYmUgaW4gYW55IG9yZGVyLCBub3QgbmVjZXNzYXJpbHkgdGhlIG9yZGVyXG4gKiB0aGV5IGFwcGVhciBpbiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSB4IGlucHV0IGFycmF5LiBjYW4gY29udGFpbiBhbnkgdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gY291bnQgb2YgaG93IG1hbnkgZWxlbWVudHMgdG8gdGFrZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2UgdGhhdFxuICogcmV0dXJucyBudW1iZXJzIGJldHdlZW4gMCBpbmNsdXNpdmUgYW5kIDEgZXhjbHVzaXZlOiB0aGUgcmFuZ2UgWzAsIDEpXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic2V0IG9mIG4gZWxlbWVudHMgaW4gb3JpZ2luYWwgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHZhbHVlcyA9IFsxLCAyLCA0LCA1LCA2LCA3LCA4LCA5XTtcbiAqIHNhbXBsZSh2YWx1ZXMsIDMpOyAvLyByZXR1cm5zIDMgcmFuZG9tIHZhbHVlcywgbGlrZSBbMiwgNSwgOF07XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZSh4LCBuLCByYW5kb21Tb3VyY2UpIHtcbiAgICAvLyBzaHVmZmxlIHRoZSBvcmlnaW5hbCBhcnJheSB1c2luZyBhIGZpc2hlci15YXRlcyBzaHVmZmxlXG4gICAgdmFyIHNodWZmbGVkID0gc2h1ZmZsZSh4LCByYW5kb21Tb3VyY2UpO1xuXG4gICAgLy8gYW5kIHRoZW4gcmV0dXJuIGEgc3Vic2V0IG9mIGl0IC0gdGhlIGZpcnN0IGBuYCBlbGVtZW50cy5cbiAgICByZXR1cm4gc2h1ZmZsZWQuc2xpY2UoMCwgbik7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbHVtbiB4IHJvdyBtYXRyaXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXG4gKiBAcGFyYW0ge251bWJlcn0gcm93c1xuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdHJpeFxuICogQGV4YW1wbGVcbiAqIG1ha2VNYXRyaXgoMTAsIDEwKTtcbiAqL1xuZnVuY3Rpb24gbWFrZU1hdHJpeChjb2x1bW5zLCByb3dzKSB7XG4gICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uczsgaSsrKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3dzOyBqKyspIHtcbiAgICAgICAgICAgIGNvbHVtbi5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5wdXNoKGNvbHVtbik7XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG59XG5cbi8qKlxuICogRm9yIGEgc29ydGVkIGlucHV0LCBjb3VudGluZyB0aGUgbnVtYmVyIG9mIHVuaXF1ZSB2YWx1ZXNcbiAqIGlzIHBvc3NpYmxlIGluIGNvbnN0YW50IHRpbWUgYW5kIGNvbnN0YW50IG1lbW9yeS4gVGhpcyBpc1xuICogYSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBWYWx1ZXMgYXJlIGNvbXBhcmVkIHdpdGggYD09PWAsIHNvIG9iamVjdHMgYW5kIG5vbi1wcmltaXRpdmUgb2JqZWN0c1xuICogYXJlIG5vdCBoYW5kbGVkIGluIGFueSBzcGVjaWFsIHdheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB4IGFuIGFycmF5IG9mIGFueSBraW5kIG9mIHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb3VudCBvZiB1bmlxdWUgdmFsdWVzXG4gKiBAZXhhbXBsZVxuICogdW5pcXVlQ291bnRTb3J0ZWQoWzEsIDIsIDNdKTsgLy8gPT4gM1xuICogdW5pcXVlQ291bnRTb3J0ZWQoWzEsIDEsIDFdKTsgLy8gPT4gMVxuICovXG5mdW5jdGlvbiB1bmlxdWVDb3VudFNvcnRlZCh4KSB7XG4gICAgdmFyIHVuaXF1ZVZhbHVlQ291bnQgPSAwO1xuICAgIHZhciBsYXN0U2VlblZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCB4W2ldICE9PSBsYXN0U2VlblZhbHVlKSB7XG4gICAgICAgICAgICBsYXN0U2VlblZhbHVlID0geFtpXTtcbiAgICAgICAgICAgIHVuaXF1ZVZhbHVlQ291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlVmFsdWVDb3VudDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgaW5jcmVtZW50YWxseSBjb21wdXRlZCB2YWx1ZXMgYmFzZWQgb24gdGhlIHN1bXMgYW5kIHN1bXMgb2ZcbiAqIHNxdWFyZXMgZm9yIHRoZSBkYXRhIGFycmF5XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBqXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHN1bXNPZlNxdWFyZXNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBleGFtcGxlXG4gKiBzc3EoMCwgMSwgWy0xLCAwLCAyXSwgWzEsIDEsIDVdKTtcbiAqL1xuZnVuY3Rpb24gc3NxKGosIGksIHN1bXMsIHN1bXNPZlNxdWFyZXMpIHtcbiAgICB2YXIgc2ppOyAvLyBzKGosIGkpXG4gICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHZhciBtdWppID0gKHN1bXNbaV0gLSBzdW1zW2ogLSAxXSkgLyAoaSAtIGogKyAxKTsgLy8gbXUoaiwgaSlcbiAgICAgICAgc2ppID1cbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXNbaV0gLSBzdW1zT2ZTcXVhcmVzW2ogLSAxXSAtIChpIC0gaiArIDEpICogbXVqaSAqIG11amk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2ppID0gc3Vtc09mU3F1YXJlc1tpXSAtIChzdW1zW2ldICogc3Vtc1tpXSkgLyAoaSArIDEpO1xuICAgIH1cbiAgICBpZiAoc2ppIDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHNqaTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJlY3Vyc2l2ZWx5IGRpdmlkZXMgYW5kIGNvbnF1ZXJzIGNvbXB1dGF0aW9uc1xuICogZm9yIGNsdXN0ZXIgalxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaU1pbiBNaW5pbXVtIGluZGV4IGluIGNsdXN0ZXIgdG8gYmUgY29tcHV0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpTWF4IE1heGltdW0gaW5kZXggaW4gY2x1c3RlciB0byBiZSBjb21wdXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IGNsdXN0ZXIgSW5kZXggb2YgdGhlIGNsdXN0ZXIgY3VycmVudGx5IGJlaW5nIGNvbXB1dGVkXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGJhY2t0cmFja01hdHJpeFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdW1zXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHN1bXNPZlNxdWFyZXNcbiAqL1xuZnVuY3Rpb24gZmlsbE1hdHJpeENvbHVtbihcbiAgICBpTWluLFxuICAgIGlNYXgsXG4gICAgY2x1c3RlcixcbiAgICBtYXRyaXgsXG4gICAgYmFja3RyYWNrTWF0cml4LFxuICAgIHN1bXMsXG4gICAgc3Vtc09mU3F1YXJlc1xuKSB7XG4gICAgaWYgKGlNaW4gPiBpTWF4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdGFydCBhdCBtaWRwb2ludCBiZXR3ZWVuIGlNaW4gYW5kIGlNYXhcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKGlNaW4gKyBpTWF4KSAvIDIpO1xuXG4gICAgbWF0cml4W2NsdXN0ZXJdW2ldID0gbWF0cml4W2NsdXN0ZXIgLSAxXVtpIC0gMV07XG4gICAgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2ldID0gaTtcblxuICAgIHZhciBqbG93ID0gY2x1c3RlcjsgLy8gdGhlIGxvd2VyIGVuZCBmb3IgalxuXG4gICAgaWYgKGlNaW4gPiBjbHVzdGVyKSB7XG4gICAgICAgIGpsb3cgPSBNYXRoLm1heChqbG93LCBiYWNrdHJhY2tNYXRyaXhbY2x1c3Rlcl1baU1pbiAtIDFdIHx8IDApO1xuICAgIH1cbiAgICBqbG93ID0gTWF0aC5tYXgoamxvdywgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXIgLSAxXVtpXSB8fCAwKTtcblxuICAgIHZhciBqaGlnaCA9IGkgLSAxOyAvLyB0aGUgdXBwZXIgZW5kIGZvciBqXG4gICAgaWYgKGlNYXggPCBtYXRyaXhbMF0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgamhpZ2ggPSBNYXRoLm1pbihqaGlnaCwgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2lNYXggKyAxXSB8fCAwKTtcbiAgICAgICAgLyogYzggaWdub3JlIGVuZCAqL1xuICAgIH1cblxuICAgIHZhciBzamk7XG4gICAgdmFyIHNqbG93aTtcbiAgICB2YXIgc3NxamxvdztcbiAgICB2YXIgc3NxajtcbiAgICBmb3IgKHZhciBqID0gamhpZ2g7IGogPj0gamxvdzsgLS1qKSB7XG4gICAgICAgIHNqaSA9IHNzcShqLCBpLCBzdW1zLCBzdW1zT2ZTcXVhcmVzKTtcblxuICAgICAgICBpZiAoc2ppICsgbWF0cml4W2NsdXN0ZXIgLSAxXVtqbG93IC0gMV0gPj0gbWF0cml4W2NsdXN0ZXJdW2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4YW1pbmUgdGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBjbHVzdGVyIGJvcmRlclxuICAgICAgICBzamxvd2kgPSBzc3EoamxvdywgaSwgc3Vtcywgc3Vtc09mU3F1YXJlcyk7XG5cbiAgICAgICAgc3NxamxvdyA9IHNqbG93aSArIG1hdHJpeFtjbHVzdGVyIC0gMV1bamxvdyAtIDFdO1xuXG4gICAgICAgIGlmIChzc3FqbG93IDwgbWF0cml4W2NsdXN0ZXJdW2ldKSB7XG4gICAgICAgICAgICAvLyBTaHJpbmsgdGhlIGxvd2VyIGJvdW5kXG4gICAgICAgICAgICBtYXRyaXhbY2x1c3Rlcl1baV0gPSBzc3FqbG93O1xuICAgICAgICAgICAgYmFja3RyYWNrTWF0cml4W2NsdXN0ZXJdW2ldID0gamxvdztcbiAgICAgICAgfVxuICAgICAgICBqbG93Kys7XG5cbiAgICAgICAgc3NxaiA9IHNqaSArIG1hdHJpeFtjbHVzdGVyIC0gMV1baiAtIDFdO1xuICAgICAgICBpZiAoc3NxaiA8IG1hdHJpeFtjbHVzdGVyXVtpXSkge1xuICAgICAgICAgICAgbWF0cml4W2NsdXN0ZXJdW2ldID0gc3NxajtcbiAgICAgICAgICAgIGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtpXSA9IGo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaWxsTWF0cml4Q29sdW1uKFxuICAgICAgICBpTWluLFxuICAgICAgICBpIC0gMSxcbiAgICAgICAgY2x1c3RlcixcbiAgICAgICAgbWF0cml4LFxuICAgICAgICBiYWNrdHJhY2tNYXRyaXgsXG4gICAgICAgIHN1bXMsXG4gICAgICAgIHN1bXNPZlNxdWFyZXNcbiAgICApO1xuICAgIGZpbGxNYXRyaXhDb2x1bW4oXG4gICAgICAgIGkgKyAxLFxuICAgICAgICBpTWF4LFxuICAgICAgICBjbHVzdGVyLFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIGJhY2t0cmFja01hdHJpeCxcbiAgICAgICAgc3VtcyxcbiAgICAgICAgc3Vtc09mU3F1YXJlc1xuICAgICk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIG1haW4gbWF0cmljZXMgdXNlZCBpbiBDa21lYW5zIGFuZCBraWNrc1xuICogb2ZmIHRoZSBkaXZpZGUgYW5kIGNvbnF1ZXIgY2x1c3RlciBjb21wdXRhdGlvbiBzdHJhdGVneVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhdGEgc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0cml4XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBiYWNrdHJhY2tNYXRyaXhcbiAqL1xuZnVuY3Rpb24gZmlsbE1hdHJpY2VzKGRhdGEsIG1hdHJpeCwgYmFja3RyYWNrTWF0cml4KSB7XG4gICAgdmFyIG5WYWx1ZXMgPSBtYXRyaXhbMF0ubGVuZ3RoO1xuXG4gICAgLy8gU2hpZnQgdmFsdWVzIGJ5IHRoZSBtZWRpYW4gdG8gaW1wcm92ZSBudW1lcmljIHN0YWJpbGl0eVxuICAgIHZhciBzaGlmdCA9IGRhdGFbTWF0aC5mbG9vcihuVmFsdWVzIC8gMildO1xuXG4gICAgLy8gQ3VtdWxhdGl2ZSBzdW0gYW5kIGN1bXVsYXRpdmUgc3VtIG9mIHNxdWFyZXMgZm9yIGFsbCB2YWx1ZXMgaW4gZGF0YSBhcnJheVxuICAgIHZhciBzdW1zID0gW107XG4gICAgdmFyIHN1bXNPZlNxdWFyZXMgPSBbXTtcblxuICAgIC8vIEluaXRpYWxpemUgZmlyc3QgY29sdW1uIGluIG1hdHJpeCAmIGJhY2t0cmFja01hdHJpeFxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdGVkVmFsdWUgPSAodm9pZCAwKTsgaSA8IG5WYWx1ZXM7ICsraSkge1xuICAgICAgICBzaGlmdGVkVmFsdWUgPSBkYXRhW2ldIC0gc2hpZnQ7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBzdW1zLnB1c2goc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXMucHVzaChzaGlmdGVkVmFsdWUgKiBzaGlmdGVkVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vtcy5wdXNoKHN1bXNbaSAtIDFdICsgc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXMucHVzaChcbiAgICAgICAgICAgICAgICBzdW1zT2ZTcXVhcmVzW2kgLSAxXSArIHNoaWZ0ZWRWYWx1ZSAqIHNoaWZ0ZWRWYWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZm9yIGNsdXN0ZXIgPSAwXG4gICAgICAgIG1hdHJpeFswXVtpXSA9IHNzcSgwLCBpLCBzdW1zLCBzdW1zT2ZTcXVhcmVzKTtcbiAgICAgICAgYmFja3RyYWNrTWF0cml4WzBdW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSByZXN0IG9mIHRoZSBjb2x1bW5zXG4gICAgdmFyIGlNaW47XG4gICAgZm9yICh2YXIgY2x1c3RlciA9IDE7IGNsdXN0ZXIgPCBtYXRyaXgubGVuZ3RoOyArK2NsdXN0ZXIpIHtcbiAgICAgICAgaWYgKGNsdXN0ZXIgPCBtYXRyaXgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaU1pbiA9IGNsdXN0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNvbXB1dGUgbWF0cml4W0stMV1bMF0gLi4uIG1hdHJpeFtLLTFdW04tMl1cbiAgICAgICAgICAgIGlNaW4gPSBuVmFsdWVzIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGxNYXRyaXhDb2x1bW4oXG4gICAgICAgICAgICBpTWluLFxuICAgICAgICAgICAgblZhbHVlcyAtIDEsXG4gICAgICAgICAgICBjbHVzdGVyLFxuICAgICAgICAgICAgbWF0cml4LFxuICAgICAgICAgICAgYmFja3RyYWNrTWF0cml4LFxuICAgICAgICAgICAgc3VtcyxcbiAgICAgICAgICAgIHN1bXNPZlNxdWFyZXNcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2ttZWFucyBjbHVzdGVyaW5nIGlzIGFuIGltcHJvdmVtZW50IG9uIGhldXJpc3RpYy1iYXNlZCBjbHVzdGVyaW5nXG4gKiBhcHByb2FjaGVzIGxpa2UgSmVua3MuIFRoZSBhbGdvcml0aG0gd2FzIGRldmVsb3BlZCBpblxuICogW0hhaXpob3UgV2FuZyBhbmQgTWluZ3pob3UgU29uZ10oaHR0cDovL2pvdXJuYWwuci1wcm9qZWN0Lm9yZy9hcmNoaXZlLzIwMTEtMi9SSm91cm5hbF8yMDExLTJfV2FuZytTb25nLnBkZilcbiAqIGFzIGEgW2R5bmFtaWMgcHJvZ3JhbW1pbmddKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0R5bmFtaWNfcHJvZ3JhbW1pbmcpIGFwcHJvYWNoXG4gKiB0byB0aGUgcHJvYmxlbSBvZiBjbHVzdGVyaW5nIG51bWVyaWMgZGF0YSBpbnRvIGdyb3VwcyB3aXRoIHRoZSBsZWFzdFxuICogd2l0aGluLWdyb3VwIHN1bS1vZi1zcXVhcmVkLWRldmlhdGlvbnMuXG4gKlxuICogTWluaW1pemluZyB0aGUgZGlmZmVyZW5jZSB3aXRoaW4gZ3JvdXBzIC0gd2hhdCBXYW5nICYgU29uZyByZWZlciB0byBhc1xuICogYHdpdGhpbnNzYCwgb3Igd2l0aGluIHN1bS1vZi1zcXVhcmVzLCBtZWFucyB0aGF0IGdyb3VwcyBhcmUgb3B0aW1hbGx5XG4gKiBob21vZ2Vub3VzIHdpdGhpbiBhbmQgdGhlIGRhdGEgaXMgc3BsaXQgaW50byByZXByZXNlbnRhdGl2ZSBncm91cHMuXG4gKiBUaGlzIGlzIHZlcnkgdXNlZnVsIGZvciB2aXN1YWxpemF0aW9uLCB3aGVyZSB5b3UgbWF5IHdhbnQgdG8gcmVwcmVzZW50XG4gKiBhIGNvbnRpbnVvdXMgdmFyaWFibGUgaW4gZGlzY3JldGUgY29sb3Igb3Igc3R5bGUgZ3JvdXBzLiBUaGlzIGZ1bmN0aW9uXG4gKiBjYW4gcHJvdmlkZSBncm91cHMgdGhhdCBlbXBoYXNpemUgZGlmZmVyZW5jZXMgYmV0d2VlbiBkYXRhLlxuICpcbiAqIEJlaW5nIGEgZHluYW1pYyBhcHByb2FjaCwgdGhpcyBhbGdvcml0aG0gaXMgYmFzZWQgb24gdHdvIG1hdHJpY2VzIHRoYXRcbiAqIHN0b3JlIGluY3JlbWVudGFsbHktY29tcHV0ZWQgdmFsdWVzIGZvciBzcXVhcmVkIGRldmlhdGlvbnMgYW5kIGJhY2t0cmFja2luZ1xuICogaW5kZXhlcy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIENrbWVhbnMgMy40LjYsIHdoaWNoIGludHJvZHVjZWQgYSBuZXcgZGl2aWRlXG4gKiBhbmQgY29ucXVlciBhcHByb2FjaCB0aGF0IGltcHJvdmVkIHJ1bnRpbWUgZnJvbSBPKGtuXjIpIHRvIE8oa24gbG9nKG4pKS5cbiAqXG4gKiBVbmxpa2UgdGhlIFtvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9jcmFuLnItcHJvamVjdC5vcmcvd2ViL3BhY2thZ2VzL0NrbWVhbnMuMWQuZHAvaW5kZXguaHRtbCksXG4gKiB0aGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGluY2x1ZGUgYW55IGNvZGUgdG8gYXV0b21hdGljYWxseSBkZXRlcm1pbmVcbiAqIHRoZSBvcHRpbWFsIG51bWJlciBvZiBjbHVzdGVyczogdGhpcyBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBleHBsaWNpdGx5XG4gKiBwcm92aWRlZC5cbiAqXG4gKiAjIyMgUmVmZXJlbmNlc1xuICogX0NrbWVhbnMuMWQuZHA6IE9wdGltYWwgay1tZWFucyBDbHVzdGVyaW5nIGluIE9uZSBEaW1lbnNpb24gYnkgRHluYW1pY1xuICogUHJvZ3JhbW1pbmdfIEhhaXpob3UgV2FuZyBhbmQgTWluZ3pob3UgU29uZyBJU1NOIDIwNzMtNDg1OVxuICpcbiAqIGZyb20gVGhlIFIgSm91cm5hbCBWb2wuIDMvMiwgRGVjZW1iZXIgMjAxMVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0IGRhdGEsIGFzIGFuIGFycmF5IG9mIG51bWJlciB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuQ2x1c3RlcnMgbnVtYmVyIG9mIGRlc2lyZWQgY2xhc3Nlcy4gVGhpcyBjYW5ub3QgYmVcbiAqIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbiB0aGUgZGF0YSBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY2x1c3RlcmVkIGlucHV0XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG51bWJlciBvZiByZXF1ZXN0ZWQgY2x1c3RlcnMgaXMgaGlnaGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIGRhdGFcbiAqIEBleGFtcGxlXG4gKiBja21lYW5zKFstMSwgMiwgLTEsIDIsIDQsIDUsIDYsIC0xLCAyLCAtMV0sIDMpO1xuICogLy8gVGhlIGlucHV0LCBjbHVzdGVyZWQgaW50byBncm91cHMgb2Ygc2ltaWxhciBudW1iZXJzLlxuICogLy89IFtbLTEsIC0xLCAtMSwgLTFdLCBbMiwgMiwgMl0sIFs0LCA1LCA2XV0pO1xuICovXG5mdW5jdGlvbiBja21lYW5zKHgsIG5DbHVzdGVycykge1xuICAgIGlmIChuQ2x1c3RlcnMgPiB4Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcImNhbm5vdCBnZW5lcmF0ZSBtb3JlIGNsYXNzZXMgdGhhbiB0aGVyZSBhcmUgZGF0YSB2YWx1ZXNcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBzb3J0ZWQgPSBudW1lcmljU29ydCh4KTtcbiAgICAvLyB3ZSdsbCB1c2UgdGhpcyBhcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2x1c3RlcnNcbiAgICB2YXIgdW5pcXVlQ291bnQgPSB1bmlxdWVDb3VudFNvcnRlZChzb3J0ZWQpO1xuXG4gICAgLy8gaWYgYWxsIG9mIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIGlkZW50aWNhbCwgdGhlcmUncyBvbmUgY2x1c3RlclxuICAgIC8vIHdpdGggYWxsIG9mIHRoZSBpbnB1dCBpbiBpdC5cbiAgICBpZiAodW5pcXVlQ291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtzb3J0ZWRdO1xuICAgIH1cblxuICAgIC8vIG5hbWVkICdTJyBvcmlnaW5hbGx5XG4gICAgdmFyIG1hdHJpeCA9IG1ha2VNYXRyaXgobkNsdXN0ZXJzLCBzb3J0ZWQubGVuZ3RoKTtcbiAgICAvLyBuYW1lZCAnSicgb3JpZ2luYWxseVxuICAgIHZhciBiYWNrdHJhY2tNYXRyaXggPSBtYWtlTWF0cml4KG5DbHVzdGVycywgc29ydGVkLmxlbmd0aCk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwcm9ncmFtbWluZyB3YXkgdG8gc29sdmUgdGhlIHByb2JsZW0gb2YgbWluaW1pemluZ1xuICAgIC8vIHdpdGhpbi1jbHVzdGVyIHN1bSBvZiBzcXVhcmVzLiBJdCdzIHNpbWlsYXIgdG8gbGluZWFyIHJlZ3Jlc3Npb25cbiAgICAvLyBpbiB0aGlzIHdheSwgYW5kIHRoaXMgY2FsY3VsYXRpb24gaW5jcmVtZW50YWxseSBjb21wdXRlcyB0aGVcbiAgICAvLyBzdW0gb2Ygc3F1YXJlcyB0aGF0IGFyZSBsYXRlciByZWFkLlxuICAgIGZpbGxNYXRyaWNlcyhzb3J0ZWQsIG1hdHJpeCwgYmFja3RyYWNrTWF0cml4KTtcblxuICAgIC8vIFRoZSByZWFsIHdvcmsgb2YgQ2ttZWFucyBjbHVzdGVyaW5nIGhhcHBlbnMgaW4gdGhlIG1hdHJpeCBnZW5lcmF0aW9uOlxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgbWF0cmljZXMgZW5jb2RlIGFsbCBwb3NzaWJsZSBjbHVzdGVyaW5nIGNvbWJpbmF0aW9ucywgYW5kXG4gICAgLy8gb25jZSB0aGV5J3JlIGdlbmVyYXRlZCB3ZSBjYW4gc29sdmUgZm9yIHRoZSBiZXN0IGNsdXN0ZXJpbmcgZ3JvdXBzXG4gICAgLy8gdmVyeSBxdWlja2x5LlxuICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgIHZhciBjbHVzdGVyUmlnaHQgPSBiYWNrdHJhY2tNYXRyaXhbMF0ubGVuZ3RoIC0gMTtcblxuICAgIC8vIEJhY2t0cmFjayB0aGUgY2x1c3RlcnMgZnJvbSB0aGUgZHluYW1pYyBwcm9ncmFtbWluZyBtYXRyaXguIFRoaXNcbiAgICAvLyBzdGFydHMgYXQgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXIgb2YgdGhlIG1hdHJpeCAoaWYgdGhlIHRvcC1sZWZ0IGlzIDAsIDApLFxuICAgIC8vIGFuZCBtb3ZlcyB0aGUgY2x1c3RlciB0YXJnZXQgd2l0aCB0aGUgbG9vcC5cbiAgICBmb3IgKHZhciBjbHVzdGVyID0gYmFja3RyYWNrTWF0cml4Lmxlbmd0aCAtIDE7IGNsdXN0ZXIgPj0gMDsgY2x1c3Rlci0tKSB7XG4gICAgICAgIHZhciBjbHVzdGVyTGVmdCA9IGJhY2t0cmFja01hdHJpeFtjbHVzdGVyXVtjbHVzdGVyUmlnaHRdO1xuXG4gICAgICAgIC8vIGZpbGwgdGhlIGNsdXN0ZXIgZnJvbSB0aGUgc29ydGVkIGlucHV0IGJ5IHRha2luZyBhIHNsaWNlIG9mIHRoZVxuICAgICAgICAvLyBhcnJheS4gdGhlIGJhY2t0cmFjayBtYXRyaXggbWFrZXMgdGhpcyBlYXN5IC0gaXQgc3RvcmVzIHRoZVxuICAgICAgICAvLyBpbmRleGVzIHdoZXJlIHRoZSBjbHVzdGVyIHNob3VsZCBzdGFydCBhbmQgZW5kLlxuICAgICAgICBjbHVzdGVyc1tjbHVzdGVyXSA9IHNvcnRlZC5zbGljZShjbHVzdGVyTGVmdCwgY2x1c3RlclJpZ2h0ICsgMSk7XG5cbiAgICAgICAgaWYgKGNsdXN0ZXIgPiAwKSB7XG4gICAgICAgICAgICBjbHVzdGVyUmlnaHQgPSBjbHVzdGVyTGVmdCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbi8qXG4gKiBQdWxsIEJyZWFrcyBWYWx1ZXMgZm9yIEplbmtzXG4gKlxuICogdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBqZW5rcyByZWNpcGU6IHRha2UgdGhlIGNhbGN1bGF0ZWQgbWF0cmljZXNcbiAqIGFuZCBkZXJpdmUgYW4gYXJyYXkgb2YgbiBicmVha3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gamVua3NCcmVha3MoZGF0YSwgbG93ZXJDbGFzc0xpbWl0cywgbkNsYXNzZXMpIHtcbiAgICB2YXIgayA9IGRhdGEubGVuZ3RoO1xuICAgIHZhciBrY2xhc3MgPSBbXTtcbiAgICB2YXIgY291bnROdW0gPSBuQ2xhc3NlcztcblxuICAgIC8vIHRoZSBjYWxjdWxhdGlvbiBvZiBjbGFzc2VzIHdpbGwgbmV2ZXIgaW5jbHVkZSB0aGUgdXBwZXJcbiAgICAvLyBib3VuZCwgc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IHNldCBpdFxuICAgIGtjbGFzc1tuQ2xhc3Nlc10gPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG5cbiAgICAvLyB0aGUgbG93ZXJDbGFzc0xpbWl0cyBtYXRyaXggaXMgdXNlZCBhcyBpbmRpY2VzIGludG8gaXRzZWxmXG4gICAgLy8gaGVyZTogdGhlIGBrYCB2YXJpYWJsZSBpcyByZXVzZWQgaW4gZWFjaCBpdGVyYXRpb24uXG4gICAgd2hpbGUgKGNvdW50TnVtID4gMCkge1xuICAgICAgICBrY2xhc3NbY291bnROdW0gLSAxXSA9IGRhdGFbbG93ZXJDbGFzc0xpbWl0c1trXVtjb3VudE51bV0gLSAxXTtcbiAgICAgICAgayA9IGxvd2VyQ2xhc3NMaW1pdHNba11bY291bnROdW1dIC0gMTtcbiAgICAgICAgY291bnROdW0tLTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2NsYXNzO1xufVxuXG4vKlxuICogQ29tcHV0ZSBNYXRyaWNlcyBmb3IgSmVua3NcbiAqXG4gKiBDb21wdXRlIHRoZSBtYXRyaWNlcyByZXF1aXJlZCBmb3IgSmVua3MgYnJlYWtzLiBUaGVzZSBtYXRyaWNlc1xuICogY2FuIGJlIHVzZWQgZm9yIGFueSBjbGFzc2luZyBvZiBkYXRhIHdpdGggYGNsYXNzZXMgPD0gbkNsYXNzZXNgXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gamVua3NNYXRyaWNlcyhkYXRhLCBuQ2xhc3Nlcykge1xuICAgIC8vIGluIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiwgdGhlc2UgbWF0cmljZXMgYXJlIHJlZmVycmVkIHRvXG4gICAgLy8gYXMgYExDYCBhbmQgYE9QYFxuICAgIC8vXG4gICAgLy8gKiBsb3dlckNsYXNzTGltaXRzIChMQyk6IG9wdGltYWwgbG93ZXIgY2xhc3MgbGltaXRzXG4gICAgLy8gKiB2YXJpYW5jZUNvbWJpbmF0aW9ucyAoT1ApOiBvcHRpbWFsIHZhcmlhbmNlIGNvbWJpbmF0aW9ucyBmb3IgYWxsIGNsYXNzZXNcbiAgICB2YXIgbG93ZXJDbGFzc0xpbWl0cyA9IFtdO1xuICAgIHZhciB2YXJpYW5jZUNvbWJpbmF0aW9ucyA9IFtdO1xuICAgIC8vIGxvb3AgY291bnRlcnNcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICAvLyB0aGUgdmFyaWFuY2UsIGFzIGNvbXB1dGVkIGF0IGVhY2ggc3RlcCBpbiB0aGUgY2FsY3VsYXRpb25cbiAgICB2YXIgdmFyaWFuY2UgPSAwO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBhbmQgZmlsbCBlYWNoIG1hdHJpeCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCArIDE7IGkrKykge1xuICAgICAgICB2YXIgdG1wMSA9IFtdO1xuICAgICAgICB2YXIgdG1wMiA9IFtdO1xuICAgICAgICAvLyBkZXNwaXRlIHRoZXNlIGFycmF5cyBoYXZpbmcgdGhlIHNhbWUgdmFsdWVzLCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGtlZXAgdGhlbSBzZXBhcmF0ZSBzbyB0aGF0IGNoYW5naW5nIG9uZSBkb2VzIG5vdCBjaGFuZ2VcbiAgICAgICAgLy8gdGhlIG90aGVyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBuQ2xhc3NlcyArIDE7IGorKykge1xuICAgICAgICAgICAgdG1wMS5wdXNoKDApO1xuICAgICAgICAgICAgdG1wMi5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHMucHVzaCh0bXAxKTtcbiAgICAgICAgdmFyaWFuY2VDb21iaW5hdGlvbnMucHVzaCh0bXAyKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbkNsYXNzZXMgKyAxOyBpKyspIHtcbiAgICAgICAgbG93ZXJDbGFzc0xpbWl0c1sxXVtpXSA9IDE7XG4gICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zWzFdW2ldID0gMDtcbiAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLCA5OTk5OTk5IGlzIHVzZWQgYnV0XG4gICAgICAgIC8vIHNpbmNlIEphdmFzY3JpcHQgaGFzIGBJbmZpbml0eWAsIHdlIHVzZSB0aGF0LlxuICAgICAgICBmb3IgKGogPSAyOyBqIDwgZGF0YS5sZW5ndGggKyAxOyBqKyspIHtcbiAgICAgICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zW2pdW2ldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbCA9IDI7IGwgPCBkYXRhLmxlbmd0aCArIDE7IGwrKykge1xuICAgICAgICAvLyBgU1pgIG9yaWdpbmFsbHkuIHRoaXMgaXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIHNlZW4gdGh1c1xuICAgICAgICAvLyBmYXIgd2hlbiBjYWxjdWxhdGluZyB2YXJpYW5jZS5cbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIC8vIGBaU1FgIG9yaWdpbmFsbHkuIHRoZSBzdW0gb2Ygc3F1YXJlcyBvZiB2YWx1ZXMgc2VlblxuICAgICAgICAvLyB0aHVzIGZhclxuICAgICAgICB2YXIgc3VtU3F1YXJlcyA9IDA7XG4gICAgICAgIC8vIGBXVGAgb3JpZ2luYWxseS4gVGhpcyBpcyB0aGUgbnVtYmVyIG9mXG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgLy8gYElWYCBvcmlnaW5hbGx5XG4gICAgICAgIHZhciBpNCA9IDA7XG5cbiAgICAgICAgLy8gaW4gc2V2ZXJhbCBpbnN0YW5jZXMsIHlvdSBjb3VsZCBzYXkgYE1hdGgucG93KHgsIDIpYFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGB4ICogeGAsIGJ1dCB0aGlzIGlzIHNsb3dlciBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIC8vIGludHJvZHVjZXMgYW4gdW5uZWNlc3NhcnkgY29uY2VwdC5cbiAgICAgICAgZm9yICh2YXIgbSA9IDE7IG0gPCBsICsgMTsgbSsrKSB7XG4gICAgICAgICAgICAvLyBgSUlJYCBvcmlnaW5hbGx5XG4gICAgICAgICAgICB2YXIgbG93ZXJDbGFzc0xpbWl0ID0gbCAtIG0gKyAxO1xuICAgICAgICAgICAgdmFyIHZhbCA9IGRhdGFbbG93ZXJDbGFzc0xpbWl0IC0gMV07XG5cbiAgICAgICAgICAgIC8vIGhlcmUgd2UncmUgZXN0aW1hdGluZyB2YXJpYW5jZSBmb3IgZWFjaCBwb3RlbnRpYWwgY2xhc3NpbmdcbiAgICAgICAgICAgIC8vIG9mIHRoZSBkYXRhLCBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mIGNsYXNzZXMuIGB3YFxuICAgICAgICAgICAgLy8gaXMgdGhlIG51bWJlciBvZiBkYXRhIHBvaW50cyBjb25zaWRlcmVkIHNvIGZhci5cbiAgICAgICAgICAgIHcrKztcblxuICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGN1cnJlbnQgc3VtIGFuZCBzdW0tb2Ytc3F1YXJlc1xuICAgICAgICAgICAgc3VtICs9IHZhbDtcbiAgICAgICAgICAgIHN1bVNxdWFyZXMgKz0gdmFsICogdmFsO1xuXG4gICAgICAgICAgICAvLyB0aGUgdmFyaWFuY2UgYXQgdGhpcyBwb2ludCBpbiB0aGUgc2VxdWVuY2UgaXMgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHN1bSBvZiBzcXVhcmVzIGFuZCB0aGUgdG90YWwgeCAyLCBvdmVyIHRoZSBudW1iZXJcbiAgICAgICAgICAgIC8vIG9mIHNhbXBsZXMuXG4gICAgICAgICAgICB2YXJpYW5jZSA9IHN1bVNxdWFyZXMgLSAoc3VtICogc3VtKSAvIHc7XG5cbiAgICAgICAgICAgIGk0ID0gbG93ZXJDbGFzc0xpbWl0IC0gMTtcblxuICAgICAgICAgICAgaWYgKGk0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMjsgaiA8IG5DbGFzc2VzICsgMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFkZGluZyB0aGlzIGVsZW1lbnQgdG8gYW4gZXhpc3RpbmcgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBpbmNyZWFzZSBpdHMgdmFyaWFuY2UgYmV5b25kIHRoZSBsaW1pdCwgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNsYXNzIGF0IHRoaXMgcG9pbnQsIHNldHRpbmcgdGhlIGBsb3dlckNsYXNzTGltaXRgXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zW2xdW2pdID49XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW5jZSArIHZhcmlhbmNlQ29tYmluYXRpb25zW2k0XVtqIC0gMV1cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlckNsYXNzTGltaXRzW2xdW2pdID0gbG93ZXJDbGFzc0xpbWl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFuY2VDb21iaW5hdGlvbnNbbF1bal0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlICsgdmFyaWFuY2VDb21iaW5hdGlvbnNbaTRdW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHNbbF1bMV0gPSAxO1xuICAgICAgICB2YXJpYW5jZUNvbWJpbmF0aW9uc1tsXVsxXSA9IHZhcmlhbmNlO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgdHdvIG1hdHJpY2VzLiBmb3IganVzdCBwcm92aWRpbmcgYnJlYWtzLCBvbmx5XG4gICAgLy8gYGxvd2VyQ2xhc3NMaW1pdHNgIGlzIG5lZWRlZCwgYnV0IHZhcmlhbmNlcyBjYW4gYmUgdXNlZnVsIHRvXG4gICAgLy8gZXZhbHVhdGUgZ29vZG5lc3Mgb2YgZml0LlxuICAgIHJldHVybiB7XG4gICAgICAgIGxvd2VyQ2xhc3NMaW1pdHM6IGxvd2VyQ2xhc3NMaW1pdHMsXG4gICAgICAgIHZhcmlhbmNlQ29tYmluYXRpb25zOiB2YXJpYW5jZUNvbWJpbmF0aW9uc1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlICoqW2plbmtzIG5hdHVyYWwgYnJlYWtzIG9wdGltaXphdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KZW5rc19uYXR1cmFsX2JyZWFrc19vcHRpbWl6YXRpb24pKipcbiAqIGlzIGFuIGFsZ29yaXRobSBjb21tb25seSB1c2VkIGluIGNhcnRvZ3JhcGh5IGFuZCB2aXN1YWxpemF0aW9uIHRvIGRlY2lkZVxuICogdXBvbiBncm91cGluZ3Mgb2YgZGF0YSB2YWx1ZXMgdGhhdCBtaW5pbWl6ZSB2YXJpYW5jZSB3aXRoaW4gdGhlbXNlbHZlc1xuICogYW5kIG1heGltaXplIHZhcmlhdGlvbiBiZXR3ZWVuIHRoZW1zZWx2ZXMuXG4gKlxuICogRm9yIGluc3RhbmNlLCBjYXJ0b2dyYXBoZXJzIG9mdGVuIHVzZSBqZW5rcyBpbiBvcmRlciB0byBjaG9vc2Ugd2hpY2hcbiAqIHZhbHVlcyBhcmUgYXNzaWduZWQgdG8gd2hpY2ggY29sb3JzIGluIGEgW2Nob3JvcGxldGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nob3JvcGxldGhfbWFwKVxuICogbWFwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YSBpbnB1dCBkYXRhLCBhcyBhbiBhcnJheSBvZiBudW1iZXIgdmFsdWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbkNsYXNzZXMgbnVtYmVyIG9mIGRlc2lyZWQgY2xhc3Nlc1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGFycmF5IG9mIGNsYXNzIGJyZWFrIHBvc2l0aW9uc1xuICogLy8gc3BsaXQgZGF0YSBpbnRvIDMgYnJlYWsgcG9pbnRzXG4gKiBqZW5rcyhbMSwgMiwgNCwgNSwgNywgOSwgMTAsIDIwXSwgMykgLy8gPSBbMSwgNywgMjAsIDIwXVxuICovXG5mdW5jdGlvbiBqZW5rcyhkYXRhLCBuQ2xhc3Nlcykge1xuICAgIGlmIChuQ2xhc3NlcyA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHNvcnQgZGF0YSBpbiBudW1lcmljYWwgb3JkZXIsIHNpbmNlIHRoaXMgaXMgZXhwZWN0ZWRcbiAgICAvLyBieSB0aGUgbWF0cmljZXMgZnVuY3Rpb25cbiAgICBkYXRhID0gZGF0YS5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgLy8gZ2V0IG91ciBiYXNpYyBtYXRyaWNlc1xuICAgIHZhciBtYXRyaWNlcyA9IGplbmtzTWF0cmljZXMoZGF0YSwgbkNsYXNzZXMpO1xuICAgIC8vIHdlIG9ubHkgbmVlZCBsb3dlciBjbGFzcyBsaW1pdHMgaGVyZVxuICAgIHZhciBsb3dlckNsYXNzTGltaXRzID0gbWF0cmljZXMubG93ZXJDbGFzc0xpbWl0cztcblxuICAgIC8vIGV4dHJhY3QgbkNsYXNzZXMgb3V0IG9mIHRoZSBjb21wdXRlZCBtYXRyaWNlc1xuICAgIHJldHVybiBqZW5rc0JyZWFrcyhkYXRhLCBsb3dlckNsYXNzTGltaXRzLCBuQ2xhc3Nlcyk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgeCwgdGhpcyB3aWxsIGZpbmQgdGhlIGV4dGVudCBvZiB0aGVcbiAqIHggYW5kIHJldHVybiBhbiBhcnJheSBvZiBicmVha3MgdGhhdCBjYW4gYmUgdXNlZFxuICogdG8gY2F0ZWdvcml6ZSB0aGUgeCBpbnRvIGEgbnVtYmVyIG9mIGNsYXNzZXMuIFRoZVxuICogcmV0dXJuZWQgYXJyYXkgd2lsbCBhbHdheXMgYmUgMSBsb25nZXIgdGhhbiB0aGUgbnVtYmVyIG9mXG4gKiBjbGFzc2VzIGJlY2F1c2UgaXQgaW5jbHVkZXMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGFuIGFycmF5IG9mIG51bWJlciB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuQ2xhc3NlcyBudW1iZXIgb2YgZGVzaXJlZCBjbGFzc2VzXG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gYXJyYXkgb2YgY2xhc3MgYnJlYWsgcG9zaXRpb25zXG4gKiBAZXhhbXBsZVxuICogZXF1YWxJbnRlcnZhbEJyZWFrcyhbMSwgMiwgMywgNCwgNSwgNl0sIDQpOyAvLyA9PiBbMSwgMi4yNSwgMy41LCA0Ljc1LCA2XVxuICovXG5mdW5jdGlvbiBlcXVhbEludGVydmFsQnJlYWtzKHgsIG5DbGFzc2VzKSB7XG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICB2YXIgdGhlTWluID0gbWluKHgpO1xuICAgIHZhciB0aGVNYXggPSBtYXgoeCk7XG5cbiAgICAvLyB0aGUgZmlyc3QgYnJlYWsgd2lsbCBhbHdheXMgYmUgdGhlIG1pbmltdW0gdmFsdWVcbiAgICAvLyBpbiB0aGUgeHNldFxuICAgIHZhciBicmVha3MgPSBbdGhlTWluXTtcblxuICAgIC8vIFRoZSBzaXplIG9mIGVhY2ggYnJlYWsgaXMgdGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIHhcbiAgICAvLyBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgY2xhc3NlcyByZXF1ZXN0ZWRcbiAgICB2YXIgYnJlYWtTaXplID0gKHRoZU1heCAtIHRoZU1pbikgLyBuQ2xhc3NlcztcblxuICAgIC8vIEluIHRoZSBjYXNlIG9mIG5DbGFzc2VzID0gMSwgdGhpcyBsb29wIHdvbid0IHJ1blxuICAgIC8vIGFuZCB0aGUgcmV0dXJuZWQgYnJlYWtzIHdpbGwgYmUgW21pbiwgbWF4XVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbkNsYXNzZXM7IGkrKykge1xuICAgICAgICBicmVha3MucHVzaChicmVha3NbMF0gKyBicmVha1NpemUgKiBpKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgbGFzdCBicmVhayB3aWxsIGFsd2F5cyBiZSB0aGVcbiAgICAvLyBtYXhpbXVtLlxuICAgIGJyZWFrcy5wdXNoKHRoZU1heCk7XG5cbiAgICByZXR1cm4gYnJlYWtzO1xufVxuXG4vKipcbiAqIFtTYW1wbGUgY292YXJpYW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2FtcGxlX21lYW5fYW5kX2NvdmFyaWFuY2UpIG9mIHR3byBkYXRhc2V0czpcbiAqIGhvdyBtdWNoIGRvIHRoZSB0d28gZGF0YXNldHMgbW92ZSB0b2dldGhlcj9cbiAqIHggYW5kIHkgYXJlIHR3byBkYXRhc2V0cywgcmVwcmVzZW50ZWQgYXMgYXJyYXlzIG9mIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIHR3byBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHkgYSBzYW1wbGUgb2YgdHdvIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGFuZCB5IGRvIG5vdCBoYXZlIGVxdWFsIGxlbmd0aHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IG9yIHkgaGF2ZSBsZW5ndGggb2Ygb25lIG9yIGxlc3NcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNhbXBsZSBjb3ZhcmlhbmNlXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlQ292YXJpYW5jZShbMSwgMiwgMywgNCwgNSwgNl0sIFs2LCA1LCA0LCAzLCAyLCAxXSk7IC8vID0+IC0zLjVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlQ292YXJpYW5jZSh4LCB5KSB7XG4gICAgLy8gVGhlIHR3byBkYXRhc2V0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoIHdoaWNoIG11c3QgYmUgbW9yZSB0aGFuIDFcbiAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgc2FtcGxlcyB3aXRoIGVxdWFsIGxlbmd0aHNcIik7XG4gICAgfVxuXG4gICAgaWYgKHgubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcInNhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzIGluIGVhY2ggc2FtcGxlXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIG1lYW4gb2YgZWFjaCBkYXRhc2V0IHNvIHRoYXQgd2UgY2FuIGp1ZGdlIGVhY2hcbiAgICAvLyB2YWx1ZSBvZiB0aGUgZGF0YXNldCBmYWlybHkgYXMgdGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgbWVhbi4gdGhpc1xuICAgIC8vIHdheSwgaWYgb25lIGRhdGFzZXQgaXMgWzEsIDIsIDNdIGFuZCBbMiwgMywgNF0sIHRoZWlyIGNvdmFyaWFuY2VcbiAgICAvLyBkb2VzIG5vdCBzdWZmZXIgYmVjYXVzZSBvZiB0aGUgZGlmZmVyZW5jZSBpbiBhYnNvbHV0ZSB2YWx1ZXNcbiAgICB2YXIgeG1lYW4gPSBtZWFuKHgpO1xuICAgIHZhciB5bWVhbiA9IG1lYW4oeSk7XG4gICAgdmFyIHN1bSA9IDA7XG5cbiAgICAvLyBmb3IgZWFjaCBwYWlyIG9mIHZhbHVlcywgdGhlIGNvdmFyaWFuY2UgaW5jcmVhc2VzIHdoZW4gdGhlaXJcbiAgICAvLyBkaWZmZXJlbmNlIGZyb20gdGhlIG1lYW4gaXMgYXNzb2NpYXRlZCAtIGlmIGJvdGggYXJlIHdlbGwgYWJvdmVcbiAgICAvLyBvciBpZiBib3RoIGFyZSB3ZWxsIGJlbG93XG4gICAgLy8gdGhlIG1lYW4sIHRoZSBjb3ZhcmlhbmNlIGluY3JlYXNlcyBzaWduaWZpY2FudGx5LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gKHhbaV0gLSB4bWVhbikgKiAoeVtpXSAtIHltZWFuKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIEJlc3NlbHMnIENvcnJlY3Rpb246IGFuIGFkanVzdG1lbnQgbWFkZSB0byBzYW1wbGUgc3RhdGlzdGljc1xuICAgIC8vIHRoYXQgYWxsb3dzIGZvciB0aGUgcmVkdWNlZCBkZWdyZWUgb2YgZnJlZWRvbSBlbnRhaWxlZCBpbiBjYWxjdWxhdGluZ1xuICAgIC8vIHZhbHVlcyBmcm9tIHNhbXBsZXMgcmF0aGVyIHRoYW4gY29tcGxldGUgcG9wdWxhdGlvbnMuXG4gICAgdmFyIGJlc3NlbHNDb3JyZWN0aW9uID0geC5sZW5ndGggLSAxO1xuXG4gICAgLy8gdGhlIGNvdmFyaWFuY2UgaXMgd2VpZ2h0ZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgZGF0YXNldHMuXG4gICAgcmV0dXJuIHN1bSAvIGJlc3NlbHNDb3JyZWN0aW9uO1xufVxuXG4vKipcbiAqIFRoZSBbc2FtcGxlIHZhcmlhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYW5jZSNTYW1wbGVfdmFyaWFuY2UpXG4gKiBpcyB0aGUgc3VtIG9mIHNxdWFyZWQgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWFuLiBUaGUgc2FtcGxlIHZhcmlhbmNlXG4gKiBpcyBkaXN0aW5ndWlzaGVkIGZyb20gdGhlIHZhcmlhbmNlIGJ5IHRoZSB1c2FnZSBvZiBbQmVzc2VsJ3MgQ29ycmVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVzc2VsJ3NfY29ycmVjdGlvbik6XG4gKiBpbnN0ZWFkIG9mIGRpdmlkaW5nIHRoZSBzdW0gb2Ygc3F1YXJlZCBkZXZpYXRpb25zIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGlucHV0LFxuICogaXQgaXMgZGl2aWRlZCBieSB0aGUgbGVuZ3RoIG1pbnVzIG9uZS4gVGhpcyBjb3JyZWN0cyB0aGUgYmlhcyBpbiBlc3RpbWF0aW5nXG4gKiBhIHZhbHVlIGZyb20gYSBzZXQgdGhhdCB5b3UgZG9uJ3Qga25vdyBpZiBmdWxsLlxuICpcbiAqIFJlZmVyZW5jZXM6XG4gKiAqIFtXb2xmcmFtIE1hdGhXb3JsZCBvbiBTYW1wbGUgVmFyaWFuY2VdKGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU2FtcGxlVmFyaWFuY2UuaHRtbClcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggYSBzYW1wbGUgb2YgdHdvIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIDJcbiAqIEByZXR1cm4ge251bWJlcn0gc2FtcGxlIHZhcmlhbmNlXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlVmFyaWFuY2UoWzEsIDIsIDMsIDQsIDVdKTsgLy8gPT4gMi41XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVZhcmlhbmNlKHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZVZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBkYXRhIHBvaW50c1wiKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtU3F1YXJlZERldmlhdGlvbnNWYWx1ZSA9IHN1bU50aFBvd2VyRGV2aWF0aW9ucyh4LCAyKTtcblxuICAgIC8vIHRoaXMgaXMgQmVzc2VscycgQ29ycmVjdGlvbjogYW4gYWRqdXN0bWVudCBtYWRlIHRvIHNhbXBsZSBzdGF0aXN0aWNzXG4gICAgLy8gdGhhdCBhbGxvd3MgZm9yIHRoZSByZWR1Y2VkIGRlZ3JlZSBvZiBmcmVlZG9tIGVudGFpbGVkIGluIGNhbGN1bGF0aW5nXG4gICAgLy8gdmFsdWVzIGZyb20gc2FtcGxlcyByYXRoZXIgdGhhbiBjb21wbGV0ZSBwb3B1bGF0aW9ucy5cbiAgICB2YXIgYmVzc2Vsc0NvcnJlY3Rpb24gPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICAvLyBGaW5kIHRoZSBtZWFuIHZhbHVlIG9mIHRoYXQgbGlzdFxuICAgIHJldHVybiBzdW1TcXVhcmVkRGV2aWF0aW9uc1ZhbHVlIC8gYmVzc2Vsc0NvcnJlY3Rpb247XG59XG5cbi8qKlxuICogVGhlIFtzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0YW5kYXJkX2RldmlhdGlvbiNTYW1wbGVfc3RhbmRhcmRfZGV2aWF0aW9uKVxuICogaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBzYW1wbGUgdmFyaWFuY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGlucHV0IGFycmF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oWzIsIDQsIDQsIDQsIDUsIDUsIDcsIDldKS50b0ZpeGVkKDIpO1xuICogLy8gPT4gJzIuMTQnXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpIHtcbiAgICB2YXIgc2FtcGxlVmFyaWFuY2VYID0gc2FtcGxlVmFyaWFuY2UoeCk7XG4gICAgcmV0dXJuIE1hdGguc3FydChzYW1wbGVWYXJpYW5jZVgpO1xufVxuXG4vKipcbiAqIFRoZSBbY29ycmVsYXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29ycmVsYXRpb25fYW5kX2RlcGVuZGVuY2UpIGlzXG4gKiBhIG1lYXN1cmUgb2YgaG93IGNvcnJlbGF0ZWQgdHdvIGRhdGFzZXRzIGFyZSwgYmV0d2VlbiAtMSBhbmQgMVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBmaXJzdCBpbnB1dFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5IHNlY29uZCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIGNvcnJlbGF0aW9uXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlQ29ycmVsYXRpb24oWzEsIDIsIDMsIDQsIDUsIDZdLCBbMiwgMiwgMywgNCwgNSwgNjBdKS50b0ZpeGVkKDIpO1xuICogLy8gPT4gJzAuNjknXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZUNvcnJlbGF0aW9uKHgsIHkpIHtcbiAgICB2YXIgY292ID0gc2FtcGxlQ292YXJpYW5jZSh4LCB5KTtcbiAgICB2YXIgeHN0ZCA9IHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uKHgpO1xuICAgIHZhciB5c3RkID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeSk7XG5cbiAgICByZXR1cm4gY292IC8geHN0ZCAvIHlzdGQ7XG59XG5cbi8qKlxuICogVGhlIFtyYW5rIGNvcnJlbGF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW5rX2NvcnJlbGF0aW9uKSBpc1xuICogYSBtZWFzdXJlIG9mIHRoZSBzdHJlbmd0aCBvZiBtb25vdG9uaWMgcmVsYXRpb25zaGlwIGJldHdlZW4gdHdvIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBmaXJzdCBpbnB1dFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5IHNlY29uZCBpbnB1dFxuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIHJhbmsgY29ycmVsYXRpb25cbiAqL1xuZnVuY3Rpb24gc2FtcGxlUmFua0NvcnJlbGF0aW9uKHgsIHkpIHtcbiAgICB2YXIgeEluZGV4ZXMgPSB4XG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gW3ZhbHVlLCBpbmRleF07IH0pXG4gICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocGFpcikgeyByZXR1cm4gcGFpclsxXTsgfSk7XG4gICAgdmFyIHlJbmRleGVzID0geVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuIFt2YWx1ZSwgaW5kZXhdOyB9KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhaXIpIHsgcmV0dXJuIHBhaXJbMV07IH0pO1xuXG4gICAgLy8gQXQgdGhpcyBzdGVwLCB3ZSBoYXZlIGFuIGFycmF5IG9mIGluZGV4ZXNcbiAgICAvLyB0aGF0IG1hcCBmcm9tIHNvcnRlZCBudW1iZXJzIHRvIHRoZWlyIG9yaWdpbmFsIGluZGV4ZXMuIFdlIHJldmVyc2VcbiAgICAvLyB0aGF0IHNvIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgdGhlIHNvcnRlZCBkZXN0aW5hdGlvbiBpbmRleC5cbiAgICB2YXIgeFJhbmtzID0gQXJyYXkoeEluZGV4ZXMubGVuZ3RoKTtcbiAgICB2YXIgeVJhbmtzID0gQXJyYXkoeEluZGV4ZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhSYW5rc1t4SW5kZXhlc1tpXV0gPSBpO1xuICAgICAgICB5UmFua3NbeUluZGV4ZXNbaV1dID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2FtcGxlQ29ycmVsYXRpb24oeFJhbmtzLCB5UmFua3MpO1xufVxuXG4vKipcbiAqIFtTa2V3bmVzc10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ta2V3bmVzcykgaXNcbiAqIGEgbWVhc3VyZSBvZiB0aGUgZXh0ZW50IHRvIHdoaWNoIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIG9mIGFcbiAqIHJlYWwtdmFsdWVkIHJhbmRvbSB2YXJpYWJsZSBcImxlYW5zXCIgdG8gb25lIHNpZGUgb2YgdGhlIG1lYW4uXG4gKiBUaGUgc2tld25lc3MgdmFsdWUgY2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBvciBldmVuIHVuZGVmaW5lZC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgYWRqdXN0ZWQgRmlzaGVyLVBlYXJzb24gc3RhbmRhcmRpemVkXG4gKiBtb21lbnQgY29lZmZpY2llbnQsIHdoaWNoIGlzIHRoZSB2ZXJzaW9uIGZvdW5kIGluIEV4Y2VsIGFuZCBzZXZlcmFsXG4gKiBzdGF0aXN0aWNhbCBwYWNrYWdlcyBpbmNsdWRpbmcgTWluaXRhYiwgU0FTIGFuZCBTUFNTLlxuICpcbiAqIEBzaW5jZSA0LjEuMFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIDMgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIHNrZXduZXNzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBoYXMgbGVuZ3RoIGxlc3MgdGhhbiAzXG4gKiBAZXhhbXBsZVxuICogc2FtcGxlU2tld25lc3MoWzIsIDQsIDYsIDMsIDFdKTsgLy8gPT4gMC41OTAxMjg2NTYzODQzNjVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlU2tld25lc3MoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlU2tld25lc3MgcmVxdWlyZXMgYXQgbGVhc3QgdGhyZWUgZGF0YSBwb2ludHNcIik7XG4gICAgfVxuXG4gICAgdmFyIG1lYW5WYWx1ZSA9IG1lYW4oeCk7XG4gICAgdmFyIHRlbXBWYWx1ZTtcbiAgICB2YXIgc3VtU3F1YXJlZERldmlhdGlvbnMgPSAwO1xuICAgIHZhciBzdW1DdWJlZERldmlhdGlvbnMgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlbXBWYWx1ZSA9IHhbaV0gLSBtZWFuVmFsdWU7XG4gICAgICAgIHN1bVNxdWFyZWREZXZpYXRpb25zICs9IHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZTtcbiAgICAgICAgc3VtQ3ViZWREZXZpYXRpb25zICs9IHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZSAqIHRlbXBWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIEJlc3NlbHMnIENvcnJlY3Rpb246IGFuIGFkanVzdG1lbnQgbWFkZSB0byBzYW1wbGUgc3RhdGlzdGljc1xuICAgIC8vIHRoYXQgYWxsb3dzIGZvciB0aGUgcmVkdWNlZCBkZWdyZWUgb2YgZnJlZWRvbSBlbnRhaWxlZCBpbiBjYWxjdWxhdGluZ1xuICAgIC8vIHZhbHVlcyBmcm9tIHNhbXBsZXMgcmF0aGVyIHRoYW4gY29tcGxldGUgcG9wdWxhdGlvbnMuXG4gICAgdmFyIGJlc3NlbHNDb3JyZWN0aW9uID0geC5sZW5ndGggLSAxO1xuXG4gICAgLy8gRmluZCB0aGUgbWVhbiB2YWx1ZSBvZiB0aGF0IGxpc3RcbiAgICB2YXIgdGhlU2FtcGxlU3RhbmRhcmREZXZpYXRpb24gPSBNYXRoLnNxcnQoXG4gICAgICAgIHN1bVNxdWFyZWREZXZpYXRpb25zIC8gYmVzc2Vsc0NvcnJlY3Rpb25cbiAgICApO1xuXG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICB2YXIgY3ViZWRTID0gTWF0aC5wb3codGhlU2FtcGxlU3RhbmRhcmREZXZpYXRpb24sIDMpO1xuXG4gICAgcmV0dXJuIChuICogc3VtQ3ViZWREZXZpYXRpb25zKSAvICgobiAtIDEpICogKG4gLSAyKSAqIGN1YmVkUyk7XG59XG5cbi8qKlxuICogW0t1cnRvc2lzXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0t1cnRvc2lzKSBpc1xuICogYSBtZWFzdXJlIG9mIHRoZSBoZWF2aW5lc3Mgb2YgYSBkaXN0cmlidXRpb24ncyB0YWlscyByZWxhdGl2ZSB0byBpdHNcbiAqIHZhcmlhbmNlLiBUaGUga3VydG9zaXMgdmFsdWUgY2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBvciBldmVuIHVuZGVmaW5lZC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiBGaXNoZXIncyBleGNlc3Mga3VydG9zaXMgZGVmaW5pdGlvbiBhbmQgdXNlc1xuICogdW5iaWFzZWQgbW9tZW50IGVzdGltYXRvcnMuIFRoaXMgaXMgdGhlIHZlcnNpb24gZm91bmQgaW4gRXhjZWwgYW5kIGF2YWlsYWJsZVxuICogaW4gc2V2ZXJhbCBzdGF0aXN0aWNhbCBwYWNrYWdlcywgaW5jbHVkaW5nIFNBUyBhbmQgU2NpUHkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIDQgb3IgbW9yZSBkYXRhIHBvaW50c1xuICogQHJldHVybnMge251bWJlcn0gc2FtcGxlIGt1cnRvc2lzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBoYXMgbGVuZ3RoIGxlc3MgdGhhbiA0XG4gKiBAZXhhbXBsZVxuICogc2FtcGxlS3VydG9zaXMoWzEsIDIsIDIsIDMsIDVdKTsgLy8gPT4gMS40NTU1NzY1NTk1NDYzMTIyXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZUt1cnRvc2lzKHgpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKG4gPCA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbXBsZUt1cnRvc2lzIHJlcXVpcmVzIGF0IGxlYXN0IGZvdXIgZGF0YSBwb2ludHNcIik7XG4gICAgfVxuXG4gICAgdmFyIG1lYW5WYWx1ZSA9IG1lYW4oeCk7XG4gICAgdmFyIHRlbXBWYWx1ZTtcbiAgICB2YXIgc2Vjb25kQ2VudHJhbE1vbWVudCA9IDA7XG4gICAgdmFyIGZvdXJ0aENlbnRyYWxNb21lbnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdGVtcFZhbHVlID0geFtpXSAtIG1lYW5WYWx1ZTtcbiAgICAgICAgc2Vjb25kQ2VudHJhbE1vbWVudCArPSB0ZW1wVmFsdWUgKiB0ZW1wVmFsdWU7XG4gICAgICAgIGZvdXJ0aENlbnRyYWxNb21lbnQgKz0gdGVtcFZhbHVlICogdGVtcFZhbHVlICogdGVtcFZhbHVlICogdGVtcFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgICgobiAtIDEpIC8gKChuIC0gMikgKiAobiAtIDMpKSkgKlxuICAgICAgICAoKG4gKiAobiArIDEpICogZm91cnRoQ2VudHJhbE1vbWVudCkgL1xuICAgICAgICAgICAgKHNlY29uZENlbnRyYWxNb21lbnQgKiBzZWNvbmRDZW50cmFsTW9tZW50KSAtXG4gICAgICAgICAgICAzICogKG4gLSAxKSlcbiAgICApO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIFtIZWFwJ3MgQWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwJTI3c19hbGdvcml0aG0pXG4gKiBmb3IgZ2VuZXJhdGluZyBwZXJtdXRhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgYW55IHR5cGUgb2YgZGF0YVxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYXJyYXkgb2YgcGVybXV0YXRpb25zXG4gKi9cbmZ1bmN0aW9uIHBlcm11dGF0aW9uc0hlYXAoZWxlbWVudHMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IG5ldyBBcnJheShlbGVtZW50cy5sZW5ndGgpO1xuICAgIHZhciBwZXJtdXRhdGlvbnMgPSBbZWxlbWVudHMuc2xpY2UoKV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluZGV4ZXNbaV0gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGVsZW1lbnRzLmxlbmd0aDsgKSB7XG4gICAgICAgIGlmIChpbmRleGVzW2kkMV0gPCBpJDEpIHtcbiAgICAgICAgICAgIC8vIEF0IG9kZCBpbmRleGVzLCBzd2FwIGZyb20gaW5kZXhlc1tpXSBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBvZiBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gICAgICAgICAgICB2YXIgc3dhcEZyb20gPSAwO1xuICAgICAgICAgICAgaWYgKGkkMSAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICBzd2FwRnJvbSA9IGluZGV4ZXNbaSQxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3dhcCBiZXR3ZWVuIHN3YXBGcm9tIGFuZCBpLCB1c2luZ1xuICAgICAgICAgICAgLy8gYSB0ZW1wb3JhcnkgdmFyaWFibGUgYXMgc3RvcmFnZS5cbiAgICAgICAgICAgIHZhciB0ZW1wID0gZWxlbWVudHNbc3dhcEZyb21dO1xuICAgICAgICAgICAgZWxlbWVudHNbc3dhcEZyb21dID0gZWxlbWVudHNbaSQxXTtcbiAgICAgICAgICAgIGVsZW1lbnRzW2kkMV0gPSB0ZW1wO1xuXG4gICAgICAgICAgICBwZXJtdXRhdGlvbnMucHVzaChlbGVtZW50cy5zbGljZSgpKTtcbiAgICAgICAgICAgIGluZGV4ZXNbaSQxXSsrO1xuICAgICAgICAgICAgaSQxID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ZXNbaSQxXSA9IDA7XG4gICAgICAgICAgICBpJDErKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgQ29tYmluYXRpb25zXG4gKiBDb21iaW5hdGlvbnMgYXJlIHVuaXF1ZSBzdWJzZXRzIG9mIGEgY29sbGVjdGlvbiAtIGluIHRoaXMgY2FzZSwgayB4IGZyb20gYSBjb2xsZWN0aW9uIGF0IGEgdGltZS5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmF0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSB4IGFueSB0eXBlIG9mIGRhdGFcbiAqIEBwYXJhbSB7aW50fSBrIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiBlYWNoIGdyb3VwICh3aXRob3V0IHJlcGxhY2VtZW50KVxuICogQHJldHVybnMge0FycmF5PEFycmF5Pn0gYXJyYXkgb2YgcGVybXV0YXRpb25zXG4gKiBAZXhhbXBsZVxuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7IC8vID0+IFtbMSwyXSwgWzEsM10sIFsyLDNdXVxuICovXG5cbmZ1bmN0aW9uIGNvbWJpbmF0aW9ucyh4LCBrKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHN1Ykk7XG4gICAgdmFyIGNvbWJpbmF0aW9uTGlzdCA9IFtdO1xuICAgIHZhciBzdWJzZXRDb21iaW5hdGlvbnM7XG4gICAgdmFyIG5leHQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgY29tYmluYXRpb25MaXN0LnB1c2goW3hbaV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNldENvbWJpbmF0aW9ucyA9IGNvbWJpbmF0aW9ucyh4LnNsaWNlKGkgKyAxLCB4Lmxlbmd0aCksIGsgLSAxKTtcbiAgICAgICAgICAgIGZvciAoc3ViSSA9IDA7IHN1YkkgPCBzdWJzZXRDb21iaW5hdGlvbnMubGVuZ3RoOyBzdWJJKyspIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gc3Vic2V0Q29tYmluYXRpb25zW3N1YkldO1xuICAgICAgICAgICAgICAgIG5leHQudW5zaGlmdCh4W2ldKTtcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbkxpc3QucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tYmluYXRpb25MaXN0O1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIFtDb21iaW5hdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmF0aW9uKSB3aXRoIHJlcGxhY2VtZW50XG4gKiBDb21iaW5hdGlvbnMgYXJlIHVuaXF1ZSBzdWJzZXRzIG9mIGEgY29sbGVjdGlvbiAtIGluIHRoaXMgY2FzZSwgayB4IGZyb20gYSBjb2xsZWN0aW9uIGF0IGEgdGltZS5cbiAqICdXaXRoIHJlcGxhY2VtZW50JyBtZWFucyB0aGF0IGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgY2hvc2VuIG11bHRpcGxlIHRpbWVzLlxuICogVW5saWtlIHBlcm11dGF0aW9uLCBvcmRlciBkb2Vzbid0IG1hdHRlciBmb3IgY29tYmluYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHggYW55IHR5cGUgb2YgZGF0YVxuICogQHBhcmFtIHtpbnR9IGsgdGhlIG51bWJlciBvZiBvYmplY3RzIGluIGVhY2ggZ3JvdXAgKHdpdGhvdXQgcmVwbGFjZW1lbnQpXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fSBhcnJheSBvZiBwZXJtdXRhdGlvbnNcbiAqIEBleGFtcGxlXG4gKiBjb21iaW5hdGlvbnNSZXBsYWNlbWVudChbMSwgMl0sIDIpOyAvLyA9PiBbWzEsIDFdLCBbMSwgMl0sIFsyLCAyXV1cbiAqL1xuZnVuY3Rpb24gY29tYmluYXRpb25zUmVwbGFjZW1lbnQoeCwgaykge1xuICAgIHZhciBjb21iaW5hdGlvbkxpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgcmVxdWVzdGVkIHRvIGZpbmQgb25seSBvbmUgZWxlbWVudCwgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAgICAgLy8gdG8gcmVjdXJzZToganVzdCBwdXNoIGB4W2ldYCBvbnRvIHRoZSBsaXN0IG9mIGNvbWJpbmF0aW9ucy5cbiAgICAgICAgICAgIGNvbWJpbmF0aW9uTGlzdC5wdXNoKFt4W2ldXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHJlY3Vyc2l2ZWx5IGZpbmQgY29tYmluYXRpb25zLCBnaXZlbiBgayAtIDFgLiBOb3RlIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIHJlcXVlc3QgYGsgLSAxYCwgc28gaWYgeW91IHdlcmUgbG9va2luZyBmb3Igaz0zIGNvbWJpbmF0aW9ucywgd2UncmVcbiAgICAgICAgICAgIC8vIHJlcXVlc3Rpbmcgaz0yLiBUaGlzIC0xIGdldHMgcmV2ZXJzZWQgaW4gdGhlIGZvciBsb29wIHJpZ2h0IGFmdGVyIHRoaXNcbiAgICAgICAgICAgIC8vIGNvZGUsIHNpbmNlIHdlIGNvbmNhdGVuYXRlIGB4W2ldYCBvbnRvIHRoZSBzZWxlY3RlZCBjb21iaW5hdGlvbnMsXG4gICAgICAgICAgICAvLyBicmluZ2luZyBga2AgYmFjayB1cCB0byB5b3VyIHJlcXVlc3RlZCBsZXZlbC5cbiAgICAgICAgICAgIC8vIFRoaXMgcmVjdXJzaW9uIG1heSBnbyBtYW55IGxldmVscyBkZWVwLCBzaW5jZSBpdCBvbmx5IHN0b3BzIG9uY2VcbiAgICAgICAgICAgIC8vIGs9MS5cbiAgICAgICAgICAgIHZhciBzdWJzZXRDb21iaW5hdGlvbnMgPSBjb21iaW5hdGlvbnNSZXBsYWNlbWVudChcbiAgICAgICAgICAgICAgICB4LnNsaWNlKGksIHgubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBrIC0gMVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJzZXRDb21iaW5hdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb21iaW5hdGlvbkxpc3QucHVzaChbeFtpXV0uY29uY2F0KHN1YnNldENvbWJpbmF0aW9uc1tqXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmF0aW9uTGlzdDtcbn1cblxuLyoqXG4gKiBXaGVuIGFkZGluZyBhIG5ldyB2YWx1ZSB0byBhIGxpc3QsIG9uZSBkb2VzIG5vdCBoYXZlIHRvIG5lY2Vzc2FyeVxuICogcmVjb21wdXRlIHRoZSBtZWFuIG9mIHRoZSBsaXN0IGluIGxpbmVhciB0aW1lLiBUaGV5IGNhbiBpbnN0ZWFkIHVzZVxuICogdGhpcyBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBuZXcgbWVhbiBieSBwcm92aWRpbmcgdGhlIGN1cnJlbnQgbWVhbixcbiAqIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3QgdGhhdCBwcm9kdWNlZCBpdCBhbmQgdGhlIG5ld1xuICogdmFsdWUgdG8gYWRkLlxuICpcbiAqIEBzaW5jZSAyLjUuMFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4gY3VycmVudCBtZWFuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSB0aGUgYWRkZWQgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBuZXcgbWVhblxuICpcbiAqIEBleGFtcGxlXG4gKiBhZGRUb01lYW4oMTQsIDUsIDUzKTsgLy8gPT4gMjAuNVxuICovXG5mdW5jdGlvbiBhZGRUb01lYW4obWVhbiwgbiwgbmV3VmFsdWUpIHtcbiAgICByZXR1cm4gbWVhbiArIChuZXdWYWx1ZSAtIG1lYW4pIC8gKG4gKyAxKTtcbn1cblxuLyoqXG4gKiBXaGVuIGNvbWJpbmluZyB0d28gbGlzdHMgb2YgdmFsdWVzIGZvciB3aGljaCBvbmUgYWxyZWFkeSBrbm93cyB0aGUgbWVhbnMsXG4gKiBvbmUgZG9lcyBub3QgaGF2ZSB0byBuZWNlc3NhcnkgcmVjb21wdXRlIHRoZSBtZWFuIG9mIHRoZSBjb21iaW5lZCBsaXN0cyBpblxuICogbGluZWFyIHRpbWUuIFRoZXkgY2FuIGluc3RlYWQgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgY29tYmluZWRcbiAqIG1lYW4gYnkgcHJvdmlkaW5nIHRoZSBtZWFuICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgZmlyc3QgbGlzdCBhbmQgdGhlIG1lYW5cbiAqICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgc2Vjb25kIGxpc3QuXG4gKlxuICogQHNpbmNlIDMuMC4wXG4gKiBAcGFyYW0ge251bWJlcn0gbWVhbjEgbWVhbiBvZiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4xIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4yIG1lYW4gb2YgdGhlIHNlY29uZCBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbjIgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzZWNvbmQgbGlzdFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNvbWJpbmVkIG1lYW5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29tYmluZU1lYW5zKDUsIDMsIDQsIDMpOyAvLyA9PiA0LjVcbiAqL1xuZnVuY3Rpb24gY29tYmluZU1lYW5zKG1lYW4xLCBuMSwgbWVhbjIsIG4yKSB7XG4gICAgcmV0dXJuIChtZWFuMSAqIG4xICsgbWVhbjIgKiBuMikgLyAobjEgKyBuMik7XG59XG5cbi8qKlxuICogV2hlbiBjb21iaW5pbmcgdHdvIGxpc3RzIG9mIHZhbHVlcyBmb3Igd2hpY2ggb25lIGFscmVhZHkga25vd3MgdGhlIHZhcmlhbmNlcyxcbiAqIG9uZSBkb2VzIG5vdCBoYXZlIHRvIG5lY2Vzc2FyeSByZWNvbXB1dGUgdGhlIHZhcmlhbmNlIG9mIHRoZSBjb21iaW5lZCBsaXN0c1xuICogaW4gbGluZWFyIHRpbWUuIFRoZXkgY2FuIGluc3RlYWQgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgY29tYmluZWRcbiAqIHZhcmlhbmNlIGJ5IHByb3ZpZGluZyB0aGUgdmFyaWFuY2UsIG1lYW4gJiBudW1iZXIgb2YgdmFsdWVzIG9mIHRoZSBmaXJzdCBsaXN0XG4gKiBhbmQgdGhlIHZhcmlhbmNlLCBtZWFuICYgbnVtYmVyIG9mIHZhbHVlcyBvZiB0aGUgc2Vjb25kIGxpc3QuXG4gKlxuICogQHNpbmNlIDMuMC4wXG4gKiBAcGFyYW0ge251bWJlcn0gdmFyaWFuY2UxIHZhcmlhbmNlIG9mIHRoZSBmaXJzdCBsaXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbWVhbjEgbWVhbiBvZiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4xIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IHZhcmlhbmNlMiB2YXJpYW5jZSBvZiB0aGUgc2Vjb25kIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWFuMiBtZWFuIG9mIHRoZSBzZWNvbmQgbGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IG4yIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc2Vjb25kIGxpc3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb21iaW5lZCBtZWFuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbWJpbmVWYXJpYW5jZXMoMTQgLyAzLCA1LCAzLCA4IC8gMywgNCwgMyk7IC8vID0+IDQ3IC8gMTJcbiAqL1xuZnVuY3Rpb24gY29tYmluZVZhcmlhbmNlcyh2YXJpYW5jZTEsIG1lYW4xLCBuMSwgdmFyaWFuY2UyLCBtZWFuMiwgbjIpIHtcbiAgICB2YXIgbmV3TWVhbiA9IGNvbWJpbmVNZWFucyhtZWFuMSwgbjEsIG1lYW4yLCBuMik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICAobjEgKiAodmFyaWFuY2UxICsgTWF0aC5wb3cobWVhbjEgLSBuZXdNZWFuLCAyKSkgK1xuICAgICAgICAgICAgbjIgKiAodmFyaWFuY2UyICsgTWF0aC5wb3cobWVhbjIgLSBuZXdNZWFuLCAyKSkpIC9cbiAgICAgICAgKG4xICsgbjIpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBUaGUgW0dlb21ldHJpYyBNZWFuXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9tZXRyaWNfbWVhbikgaXNcbiAqIGEgbWVhbiBmdW5jdGlvbiB0aGF0IGlzIG1vcmUgdXNlZnVsIGZvciBudW1iZXJzIGluIGRpZmZlcmVudFxuICogcmFuZ2VzLlxuICpcbiAqIFRoaXMgaXMgdGhlIG50aCByb290IG9mIHRoZSBpbnB1dCBudW1iZXJzIG11bHRpcGxpZWQgYnkgZWFjaCBvdGhlci5cbiAqXG4gKiBUaGUgZ2VvbWV0cmljIG1lYW4gaXMgb2Z0ZW4gdXNlZnVsIGZvclxuICogKipbcHJvcG9ydGlvbmFsIGdyb3d0aF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvbWV0cmljX21lYW4jUHJvcG9ydGlvbmFsX2dyb3d0aCkqKjogZ2l2ZW5cbiAqIGdyb3d0aCByYXRlcyBmb3IgbXVsdGlwbGUgeWVhcnMsIGxpa2UgXzgwJSwgMTYuNjYlIGFuZCA0Mi44NSVfLCBhIHNpbXBsZVxuICogbWVhbiB3aWxsIGluY29ycmVjdGx5IGVzdGltYXRlIGFuIGF2ZXJhZ2UgZ3Jvd3RoIHJhdGUsIHdoZXJlYXMgYSBnZW9tZXRyaWNcbiAqIG1lYW4gd2lsbCBjb3JyZWN0bHkgZXN0aW1hdGUgYSBncm93dGggcmF0ZSB0aGF0LCBvdmVyIHRob3NlIHllYXJzLFxuICogd2lsbCB5aWVsZCB0aGUgc2FtZSBlbmQgdmFsdWUuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBnZW9tZXRyaWMgbWVhblxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGNvbnRhaW5zIGEgbmVnYXRpdmUgbnVtYmVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGdyb3d0aFJhdGVzID0gWzEuODAsIDEuMTY2NjY2LCAxLjQyODU3MV07XG4gKiB2YXIgYXZlcmFnZUdyb3d0aCA9IHNzLmdlb21ldHJpY01lYW4oZ3Jvd3RoUmF0ZXMpO1xuICogdmFyIGF2ZXJhZ2VHcm93dGhSYXRlcyA9IFthdmVyYWdlR3Jvd3RoLCBhdmVyYWdlR3Jvd3RoLCBhdmVyYWdlR3Jvd3RoXTtcbiAqIHZhciBzdGFydGluZ1ZhbHVlID0gMTA7XG4gKiB2YXIgc3RhcnRpbmdWYWx1ZU1lYW4gPSAxMDtcbiAqIGdyb3d0aFJhdGVzLmZvckVhY2goZnVuY3Rpb24ocmF0ZSkge1xuICogICBzdGFydGluZ1ZhbHVlICo9IHJhdGU7XG4gKiB9KTtcbiAqIGF2ZXJhZ2VHcm93dGhSYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhdGUpIHtcbiAqICAgc3RhcnRpbmdWYWx1ZU1lYW4gKj0gcmF0ZTtcbiAqIH0pO1xuICogc3RhcnRpbmdWYWx1ZU1lYW4gPT09IHN0YXJ0aW5nVmFsdWU7XG4gKi9cbmZ1bmN0aW9uIGdlb21ldHJpY01lYW4oeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyaWNNZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIC8vIHRoZSBzdGFydGluZyB2YWx1ZS5cbiAgICB2YXIgdmFsdWUgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBnZW9tZXRyaWMgbWVhbiBpcyBvbmx5IHZhbGlkIGZvciBwb3NpdGl2ZSBudW1iZXJzXG4gICAgICAgIGlmICh4W2ldIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiZ2VvbWV0cmljTWVhbiByZXF1aXJlcyBvbmx5IG5vbi1uZWdhdGl2ZSBudW1iZXJzIGFzIGlucHV0XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBlYXRlZGx5IG11bHRpcGx5IHRoZSB2YWx1ZSBieSBlYWNoIG51bWJlclxuICAgICAgICB2YWx1ZSAqPSB4W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnBvdyh2YWx1ZSwgMSAvIHgubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBUaGUgW2xvZyBhdmVyYWdlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9tZXRyaWNfbWVhbiNSZWxhdGlvbnNoaXBfd2l0aF9sb2dhcml0aG1zKVxuICogaXMgYW4gZXF1aXZhbGVudCB3YXkgb2YgY29tcHV0aW5nIHRoZSBnZW9tZXRyaWMgbWVhbiBvZiBhbiBhcnJheSBzdWl0YWJsZSBmb3IgbGFyZ2Ugb3Igc21hbGwgcHJvZHVjdHMuXG4gKlxuICogSXQncyBmb3VuZCBieSBjYWxjdWxhdGluZyB0aGUgYXZlcmFnZSBsb2dhcml0aG0gb2YgdGhlIGVsZW1lbnRzIGFuZCBleHBvbmVudGlhdGluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBnZW9tZXRyaWMgbWVhblxuICogQHRocm93cyB7RXJyb3J9IGlmIHggaXMgZW1wdHlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB4IGNvbnRhaW5zIGEgbmVnYXRpdmUgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGxvZ0F2ZXJhZ2UoeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2dBdmVyYWdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4W2ldIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibG9nQXZlcmFnZSByZXF1aXJlcyBvbmx5IG5vbi1uZWdhdGl2ZSBudW1iZXJzIGFzIGlucHV0XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gTWF0aC5sb2coeFtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZXhwKHZhbHVlIC8geC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRoZSBbSGFybW9uaWMgTWVhbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFybW9uaWNfbWVhbikgaXNcbiAqIGEgbWVhbiBmdW5jdGlvbiB0eXBpY2FsbHkgdXNlZCB0byBmaW5kIHRoZSBhdmVyYWdlIG9mIHJhdGVzLlxuICogVGhpcyBtZWFuIGlzIGNhbGN1bGF0ZWQgYnkgdGFraW5nIHRoZSByZWNpcHJvY2FsIG9mIHRoZSBhcml0aG1ldGljIG1lYW5cbiAqIG9mIHRoZSByZWNpcHJvY2FscyBvZiB0aGUgaW5wdXQgbnVtYmVycy5cbiAqXG4gKiBUaGlzIGlzIGEgW21lYXN1cmUgb2YgY2VudHJhbCB0ZW5kZW5jeV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJhbF90ZW5kZW5jeSk6XG4gKiBhIG1ldGhvZCBvZiBmaW5kaW5nIGEgdHlwaWNhbCBvciBjZW50cmFsIHZhbHVlIG9mIGEgc2V0IG9mIG51bWJlcnMuXG4gKlxuICogVGhpcyBydW5zIGluIGBPKG4pYCwgbGluZWFyIHRpbWUsIHdpdGggcmVzcGVjdCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBoYXJtb25pYyBtZWFuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBpcyBlbXB0eVxuICogQHRocm93cyB7RXJyb3J9IGlmIHggY29udGFpbnMgYSBuZWdhdGl2ZSBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiBoYXJtb25pY01lYW4oWzIsIDNdKS50b0ZpeGVkKDIpIC8vID0+ICcyLjQwJ1xuICovXG5mdW5jdGlvbiBoYXJtb25pY01lYW4oeCkge1xuICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYXJtb25pY01lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIHJlY2lwcm9jYWxTdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBoYXJtb25pYyBtZWFuIGlzIG9ubHkgdmFsaWQgZm9yIHBvc2l0aXZlIG51bWJlcnNcbiAgICAgICAgaWYgKHhbaV0gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiaGFybW9uaWNNZWFuIHJlcXVpcmVzIG9ubHkgcG9zaXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjaXByb2NhbFN1bSArPSAxIC8geFtpXTtcbiAgICB9XG5cbiAgICAvLyBkaXZpZGUgbiBieSB0aGUgcmVjaXByb2NhbCBzdW1cbiAgICByZXR1cm4geC5sZW5ndGggLyByZWNpcHJvY2FsU3VtO1xufVxuXG4vKipcbiAqIFRoZSBtZWFuLCBfYWxzbyBrbm93biBhcyBhdmVyYWdlXyxcbiAqIGlzIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBvdmVyIHRoZSBudW1iZXIgb2YgdmFsdWVzLlxuICogVGhpcyBpcyBhIFttZWFzdXJlIG9mIGNlbnRyYWwgdGVuZGVuY3ldKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyYWxfdGVuZGVuY3kpOlxuICogYSBtZXRob2Qgb2YgZmluZGluZyBhIHR5cGljYWwgb3IgY2VudHJhbCB2YWx1ZSBvZiBhIHNldCBvZiBudW1iZXJzLlxuICpcbiAqIFRoZSBzaW1wbGUgbWVhbiB1c2VzIHRoZSBzdWNjZXNzaXZlIGFkZGl0aW9uIG1ldGhvZCBpbnRlcm5hbGx5XG4gKiB0byBjYWxjdWxhdGUgaXQncyByZXN1bHQuIEVycm9ycyBpbiBmbG9hdGluZy1wb2ludCBhZGRpdGlvbiBhcmVcbiAqIG5vdCBhY2NvdW50ZWQgZm9yLCBzbyBpZiBwcmVjaXNpb24gaXMgcmVxdWlyZWQsIHRoZSBzdGFuZGFyZCB7QGxpbmsgbWVhbn1cbiAqIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgZGF0YSBwb2ludHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbGVuZ3RoIG9mIHggaXMgbGVzcyB0aGFuIG9uZVxuICogQHJldHVybnMge251bWJlcn0gbWVhblxuICogQGV4YW1wbGVcbiAqIG1lYW4oWzAsIDEwXSk7IC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gbWVhblNpbXBsZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYW5TaW1wbGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bVNpbXBsZSh4KSAvIHgubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBbbWVkaWFuXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lZGlhbikgaXNcbiAqIHRoZSBtaWRkbGUgbnVtYmVyIG9mIGEgbGlzdC4gVGhpcyBpcyBvZnRlbiBhIGdvb2QgaW5kaWNhdG9yIG9mICd0aGUgbWlkZGxlJ1xuICogd2hlbiB0aGVyZSBhcmUgb3V0bGllcnMgdGhhdCBza2V3IHRoZSBgbWVhbigpYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBbbWVhc3VyZSBvZiBjZW50cmFsIHRlbmRlbmN5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsX3RlbmRlbmN5KTpcbiAqIGEgbWV0aG9kIG9mIGZpbmRpbmcgYSB0eXBpY2FsIG9yIGNlbnRyYWwgdmFsdWUgb2YgYSBzZXQgb2YgbnVtYmVycy5cbiAqXG4gKiBUaGUgbWVkaWFuIGlzbid0IG5lY2Vzc2FyaWx5IG9uZSBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIGxpc3Q6IHRoZSB2YWx1ZVxuICogY2FuIGJlIHRoZSBhdmVyYWdlIG9mIHR3byBlbGVtZW50cyBpZiB0aGUgbGlzdCBoYXMgYW4gZXZlbiBsZW5ndGhcbiAqIGFuZCB0aGUgdHdvIGNlbnRyYWwgdmFsdWVzIGFyZSBkaWZmZXJlbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzb3J0ZWQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG1lZGlhbiB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIG1lZGlhblNvcnRlZChbMTAsIDIsIDUsIDEwMCwgMiwgMV0pOyAvLyA9PiA1Mi41XG4gKi9cbmZ1bmN0aW9uIG1lZGlhblNvcnRlZChzb3J0ZWQpIHtcbiAgICByZXR1cm4gcXVhbnRpbGVTb3J0ZWQoc29ydGVkLCAwLjUpO1xufVxuXG4vKipcbiAqIFdoZW4gcmVtb3ZpbmcgYSB2YWx1ZSBmcm9tIGEgbGlzdCwgb25lIGRvZXMgbm90IGhhdmUgdG8gbmVjZXNzYXJ5XG4gKiByZWNvbXB1dGUgdGhlIG1lYW4gb2YgdGhlIGxpc3QgaW4gbGluZWFyIHRpbWUuIFRoZXkgY2FuIGluc3RlYWQgdXNlXG4gKiB0aGlzIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIG5ldyBtZWFuIGJ5IHByb3ZpZGluZyB0aGUgY3VycmVudCBtZWFuLFxuICogdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbGlzdCB0aGF0IHByb2R1Y2VkIGl0IGFuZCB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICpcbiAqIEBzaW5jZSAzLjAuMFxuICogQHBhcmFtIHtudW1iZXJ9IG1lYW4gY3VycmVudCBtZWFuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbmV3IG1lYW5cbiAqXG4gKiBAZXhhbXBsZVxuICogc3VidHJhY3RGcm9tTWVhbigyMC41LCA2LCA1Myk7IC8vID0+IDE0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0RnJvbU1lYW4obWVhbiwgbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gKG1lYW4gKiBuIC0gdmFsdWUpIC8gKG4gLSAxKTtcbn1cblxuLyoqXG4gKiBUaGUgUm9vdCBNZWFuIFNxdWFyZSAoUk1TKSBpc1xuICogYSBtZWFuIGZ1bmN0aW9uIHVzZWQgYXMgYSBtZWFzdXJlIG9mIHRoZSBtYWduaXR1ZGUgb2YgYSBzZXRcbiAqIG9mIG51bWJlcnMsIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgc2lnbi5cbiAqIFRoaXMgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBtZWFuIG9mIHRoZSBzcXVhcmVzIG9mIHRoZVxuICogaW5wdXQgbnVtYmVycy5cbiAqIFRoaXMgcnVucyBpbiBgTyhuKWAsIGxpbmVhciB0aW1lLCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4IGEgc2FtcGxlIG9mIG9uZSBvciBtb3JlIGRhdGEgcG9pbnRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByb290IG1lYW4gc3F1YXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgeCBpcyBlbXB0eVxuICogQGV4YW1wbGVcbiAqIHJvb3RNZWFuU3F1YXJlKFstMSwgMSwgLTEsIDFdKTsgLy8gPT4gMVxuICovXG5mdW5jdGlvbiByb290TWVhblNxdWFyZSh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJvb3RNZWFuU3F1YXJlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO1xuICAgIH1cblxuICAgIHZhciBzdW1PZlNxdWFyZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW1PZlNxdWFyZXMgKz0gTWF0aC5wb3coeFtpXSwgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChzdW1PZlNxdWFyZXMgLyB4Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogVGhlYGNvZWZmaWNpZW50IG9mIHZhcmlhdGlvbmBfIGlzIHRoZSByYXRpbyBvZiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIHRvIHRoZSBtZWFuLlxuICogLi5fYGNvZWZmaWNpZW50IG9mIHZhcmlhdGlvbmA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvZWZmaWNpZW50X29mX3ZhcmlhdGlvblxuICpcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb2VmZmljaWVudCBvZiB2YXJpYXRpb25cbiAqIEBleGFtcGxlXG4gKiBjb2VmZmljaWVudE9mVmFyaWF0aW9uKFsxLCAyLCAzLCA0XSkudG9GaXhlZCgzKTsgLy8gPT4gMC41MTZcbiAqIGNvZWZmaWNpZW50T2ZWYXJpYXRpb24oWzEsIDIsIDMsIDQsIDVdKS50b0ZpeGVkKDMpOyAvLyA9PiAwLjUyN1xuICogY29lZmZpY2llbnRPZlZhcmlhdGlvbihbLTEsIDAsIDEsIDIsIDMsIDRdKS50b0ZpeGVkKDMpOyAvLyA9PiAxLjI0N1xuICovXG5mdW5jdGlvbiBjb2VmZmljaWVudE9mVmFyaWF0aW9uKHgpIHtcbiAgICByZXR1cm4gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeCkgLyBtZWFuKHgpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdG8gY29tcHV0ZSBbYSBvbmUtc2FtcGxlIHQtdGVzdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3R1ZGVudCUyN3NfdC10ZXN0I09uZS1zYW1wbGVfdC10ZXN0KSwgY29tcGFyaW5nIHRoZSBtZWFuXG4gKiBvZiBhIHNhbXBsZSB0byBhIGtub3duIHZhbHVlLCB4LlxuICpcbiAqIGluIHRoaXMgY2FzZSwgd2UncmUgdHJ5aW5nIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogcG9wdWxhdGlvbiBtZWFuIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSB0aGF0IHdlIGtub3csIHdoaWNoIGlzIGB4YFxuICogaGVyZS4gVXN1YWxseSB0aGUgcmVzdWx0cyBoZXJlIGFyZSB1c2VkIHRvIGxvb2sgdXAgYVxuICogW3AtdmFsdWVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUC12YWx1ZSksIHdoaWNoLCBmb3JcbiAqIGEgY2VydGFpbiBsZXZlbCBvZiBzaWduaWZpY2FuY2UsIHdpbGwgbGV0IHlvdSBkZXRlcm1pbmUgdGhhdCB0aGVcbiAqIG51bGwgaHlwb3RoZXNpcyBjYW4gb3IgY2Fubm90IGJlIHJlamVjdGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geCBzYW1wbGUgb2Ygb25lIG9yIG1vcmUgbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkVmFsdWUgZXhwZWN0ZWQgdmFsdWUgb2YgdGhlIHBvcHVsYXRpb24gbWVhblxuICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAqIEBleGFtcGxlXG4gKiB0VGVzdChbMSwgMiwgMywgNCwgNSwgNl0sIDMuMzg1KS50b0ZpeGVkKDIpOyAvLyA9PiAnMC4xNidcbiAqL1xuZnVuY3Rpb24gdFRlc3QoeCwgZXhwZWN0ZWRWYWx1ZSkge1xuICAgIC8vIFRoZSBtZWFuIG9mIHRoZSBzYW1wbGVcbiAgICB2YXIgc2FtcGxlTWVhbiA9IG1lYW4oeCk7XG5cbiAgICAvLyBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBzYW1wbGVcbiAgICB2YXIgc2QgPSBzdGFuZGFyZERldmlhdGlvbih4KTtcblxuICAgIC8vIFNxdWFyZSByb290IHRoZSBsZW5ndGggb2YgdGhlIHNhbXBsZVxuICAgIHZhciByb290TiA9IE1hdGguc3FydCh4Lmxlbmd0aCk7XG5cbiAgICAvLyByZXR1cm5pbmcgdGhlIHQgdmFsdWVcbiAgICByZXR1cm4gKHNhbXBsZU1lYW4gLSBleHBlY3RlZFZhbHVlKSAvIChzZCAvIHJvb3ROKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRvIGNvbXB1dGUgW3R3byBzYW1wbGUgdC10ZXN0XShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0dWRlbnQnc190LXRlc3QpLlxuICogVGVzdHMgd2hldGhlciBcIm1lYW4oWCktbWVhbihZKSA9IGRpZmZlcmVuY2VcIiwgKFxuICogaW4gdGhlIG1vc3QgY29tbW9uIGNhc2UsIHdlIG9mdGVuIGhhdmUgYGRpZmZlcmVuY2UgPT0gMGAgdG8gdGVzdCBpZiB0d28gc2FtcGxlc1xuICogYXJlIGxpa2VseSB0byBiZSB0YWtlbiBmcm9tIHBvcHVsYXRpb25zIHdpdGggdGhlIHNhbWUgbWVhbiB2YWx1ZSkgd2l0aFxuICogbm8gcHJpb3Iga25vd2xlZGdlIG9uIHN0YW5kYXJkIGRldmlhdGlvbnMgb2YgYm90aCBzYW1wbGVzXG4gKiBvdGhlciB0aGFuIHRoZSBmYWN0IHRoYXQgdGhleSBoYXZlIHRoZSBzYW1lIHN0YW5kYXJkIGRldmlhdGlvbi5cbiAqXG4gKiBVc3VhbGx5IHRoZSByZXN1bHRzIGhlcmUgYXJlIHVzZWQgdG8gbG9vayB1cCBhXG4gKiBbcC12YWx1ZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QLXZhbHVlKSwgd2hpY2gsIGZvclxuICogYSBjZXJ0YWluIGxldmVsIG9mIHNpZ25pZmljYW5jZSwgd2lsbCBsZXQgeW91IGRldGVybWluZSB0aGF0IHRoZVxuICogbnVsbCBoeXBvdGhlc2lzIGNhbiBvciBjYW5ub3QgYmUgcmVqZWN0ZWQuXG4gKlxuICogYGRpZmZgIGNhbiBiZSBvbWl0dGVkIGlmIGl0IGVxdWFscyAwLlxuICpcbiAqIFtUaGlzIGlzIHVzZWQgdG8gcmVqZWN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeGNsdXNpb25fb2ZfdGhlX251bGxfaHlwb3RoZXNpcylcbiAqIGEgbnVsbCBoeXBvdGhlc2lzIHRoYXQgdGhlIHR3byBwb3B1bGF0aW9ucyB0aGF0IGhhdmUgYmVlbiBzYW1wbGVkIGludG9cbiAqIGBzYW1wbGVYYCBhbmQgYHNhbXBsZVlgIGFyZSBlcXVhbCB0byBlYWNoIG90aGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWCBhIHNhbXBsZSBhcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVkgYSBzYW1wbGUgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtkaWZmZXJlbmNlPTBdXG4gKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9IHRlc3QgcmVzdWx0XG4gKlxuICogQGV4YW1wbGVcbiAqIHRUZXN0VHdvU2FtcGxlKFsxLCAyLCAzLCA0XSwgWzMsIDQsIDUsIDZdLCAwKTsgLy8gPT4gLTIuMTkwODkwMjMwMDIwNjY0M1xuICovXG5mdW5jdGlvbiB0VGVzdFR3b1NhbXBsZShzYW1wbGVYLCBzYW1wbGVZLCBkaWZmZXJlbmNlKSB7XG4gICAgdmFyIG4gPSBzYW1wbGVYLmxlbmd0aDtcbiAgICB2YXIgbSA9IHNhbXBsZVkubGVuZ3RoO1xuXG4gICAgLy8gSWYgZWl0aGVyIHNhbXBsZSBkb2Vzbid0IGFjdHVhbGx5IGhhdmUgYW55IHZhbHVlcywgd2UgY2FuJ3RcbiAgICAvLyBjb21wdXRlIHRoaXMgYXQgYWxsLCBzbyB3ZSByZXR1cm4gYG51bGxgLlxuICAgIGlmICghbiB8fCAhbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IGRpZmZlcmVuY2UgKG11KSBpcyB6ZXJvXG4gICAgaWYgKCFkaWZmZXJlbmNlKSB7XG4gICAgICAgIGRpZmZlcmVuY2UgPSAwO1xuICAgIH1cblxuICAgIHZhciBtZWFuWCA9IG1lYW4oc2FtcGxlWCk7XG4gICAgdmFyIG1lYW5ZID0gbWVhbihzYW1wbGVZKTtcbiAgICB2YXIgc2FtcGxlVmFyaWFuY2VYID0gc2FtcGxlVmFyaWFuY2Uoc2FtcGxlWCk7XG4gICAgdmFyIHNhbXBsZVZhcmlhbmNlWSA9IHNhbXBsZVZhcmlhbmNlKHNhbXBsZVkpO1xuXG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgbWVhblggPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIG1lYW5ZID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBzYW1wbGVWYXJpYW5jZVggPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIHNhbXBsZVZhcmlhbmNlWSA9PT0gXCJudW1iZXJcIlxuICAgICkge1xuICAgICAgICB2YXIgd2VpZ2h0ZWRWYXJpYW5jZSA9XG4gICAgICAgICAgICAoKG4gLSAxKSAqIHNhbXBsZVZhcmlhbmNlWCArIChtIC0gMSkgKiBzYW1wbGVWYXJpYW5jZVkpIC9cbiAgICAgICAgICAgIChuICsgbSAtIDIpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobWVhblggLSBtZWFuWSAtIGRpZmZlcmVuY2UpIC9cbiAgICAgICAgICAgIE1hdGguc3FydCh3ZWlnaHRlZFZhcmlhbmNlICogKDEgLyBuICsgMSAvIG0pKVxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIFdpbGNveG9uIHJhbmsgc3VtIHN0YXRpc3RpYyBmb3IgdGhlIGZpcnN0IHNhbXBsZVxuICogd2l0aCByZXNwZWN0IHRvIHRoZSBzZWNvbmQuIFRoZSBXaWxjb3hvbiByYW5rIHN1bSB0ZXN0IGlzIGEgbm9uLXBhcmFtZXRyaWNcbiAqIGFsdGVybmF0aXZlIHRvIHRoZSB0LXRlc3Qgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGVcbiAqIFtNYW5uLVdoaXRuZXkgVSB0ZXN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYW5uJUUyJTgwJTkzV2hpdG5leV9VX3Rlc3QpLlxuICogVGhlIHN0YXRpc3RpYyBpcyBjYWxjdWxhdGVkIGJ5IHBvb2xpbmcgYWxsIHRoZSBvYnNlcnZhdGlvbnMgdG9nZXRoZXIsIHJhbmtpbmcgdGhlbSxcbiAqIGFuZCB0aGVuIHN1bW1pbmcgdGhlIHJhbmtzIGFzc29jaWF0ZWQgd2l0aCBvbmUgb2YgdGhlIHNhbXBsZXMuIElmIHRoaXMgcmFuayBzdW0gaXNcbiAqIHN1ZmZpY2llbnRseSBsYXJnZSBvciBzbWFsbCB3ZSByZWplY3QgdGhlIGh5cG90aGVzaXMgdGhhdCB0aGUgdHdvIHNhbXBsZXMgY29tZVxuICogZnJvbSB0aGUgc2FtZSBkaXN0cmlidXRpb24gaW4gZmF2b3Igb2YgdGhlIGFsdGVybmF0aXZlIHRoYXQgb25lIGlzIHNoaWZ0ZWQgd2l0aFxuICogcmVzcGVjdCB0byB0aGUgb3RoZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzYW1wbGVYIGEgc2FtcGxlIGFzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWSBhIHNhbXBsZSBhcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByYW5rIHN1bSBmb3Igc2FtcGxlWFxuICpcbiAqIEBleGFtcGxlXG4gKiB3aWxjb3hvblJhbmtTdW0oWzEsIDQsIDhdLCBbOSwgMTIsIDE1XSk7IC8vID0+IDZcbiAqL1xuZnVuY3Rpb24gd2lsY294b25SYW5rU3VtKHNhbXBsZVgsIHNhbXBsZVkpIHtcbiAgICBpZiAoIXNhbXBsZVgubGVuZ3RoIHx8ICFzYW1wbGVZLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWl0aGVyIHNhbXBsZSBjYW4gYmUgZW1wdHlcIik7XG4gICAgfVxuXG4gICAgdmFyIHBvb2xlZFNhbXBsZXMgPSBzYW1wbGVYXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICh7IGxhYmVsOiBcInhcIiwgdmFsdWU6IHggfSk7IH0pXG4gICAgICAgIC5jb25jYXQoc2FtcGxlWS5tYXAoZnVuY3Rpb24gKHkpIHsgcmV0dXJuICh7IGxhYmVsOiBcInlcIiwgdmFsdWU6IHkgfSk7IH0pKVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7IH0pO1xuXG4gICAgZm9yICh2YXIgcmFuayA9IDA7IHJhbmsgPCBwb29sZWRTYW1wbGVzLmxlbmd0aDsgcmFuaysrKSB7XG4gICAgICAgIHBvb2xlZFNhbXBsZXNbcmFua10ucmFuayA9IHJhbms7XG4gICAgfVxuXG4gICAgdmFyIHRpZWRSYW5rcyA9IFtwb29sZWRTYW1wbGVzWzBdLnJhbmtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9vbGVkU2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9vbGVkU2FtcGxlc1tpXS52YWx1ZSA9PT0gcG9vbGVkU2FtcGxlc1tpIC0gMV0udmFsdWUpIHtcbiAgICAgICAgICAgIHRpZWRSYW5rcy5wdXNoKHBvb2xlZFNhbXBsZXNbaV0ucmFuayk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gcG9vbGVkU2FtcGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVJhbmtzSW5QbGFjZShwb29sZWRTYW1wbGVzLCB0aWVkUmFua3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRpZWRSYW5rcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXBsYWNlUmFua3NJblBsYWNlKHBvb2xlZFNhbXBsZXMsIHRpZWRSYW5rcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWVkUmFua3MgPSBbcG9vbGVkU2FtcGxlc1tpXS5yYW5rXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VSYW5rc0luUGxhY2UocG9vbGVkU2FtcGxlcywgdGllZFJhbmtzKSB7XG4gICAgICAgIHZhciBhdmVyYWdlID0gKHRpZWRSYW5rc1swXSArIHRpZWRSYW5rc1t0aWVkUmFua3MubGVuZ3RoIC0gMV0pIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWVkUmFua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvb2xlZFNhbXBsZXNbdGllZFJhbmtzW2ldXS5yYW5rID0gYXZlcmFnZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByYW5rU3VtID0gMDtcblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvb2xlZFNhbXBsZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgc2FtcGxlID0gcG9vbGVkU2FtcGxlc1tpJDFdO1xuICAgICAgICBpZiAoc2FtcGxlLmxhYmVsID09PSBcInhcIikge1xuICAgICAgICAgICAgcmFua1N1bSArPSBzYW1wbGUucmFuayArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmFua1N1bTtcbn1cblxuLyoqXG4gKiBbQmF5ZXNpYW4gQ2xhc3NpZmllcl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OYWl2ZV9CYXllc19jbGFzc2lmaWVyKVxuICpcbiAqIFRoaXMgaXMgYSBuYcOvdmUgYmF5ZXNpYW4gY2xhc3NpZmllciB0aGF0IHRha2VzXG4gKiBzaW5nbHktbmVzdGVkIG9iamVjdHMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXhhbXBsZVxuICogdmFyIGJheWVzID0gbmV3IEJheWVzaWFuQ2xhc3NpZmllcigpO1xuICogYmF5ZXMudHJhaW4oe1xuICogICBzcGVjaWVzOiAnQ2F0J1xuICogfSwgJ2FuaW1hbCcpO1xuICogdmFyIHJlc3VsdCA9IGJheWVzLnNjb3JlKHtcbiAqICAgc3BlY2llczogJ0NhdCdcbiAqIH0pXG4gKiAvLyByZXN1bHRcbiAqIC8vIHtcbiAqIC8vICAgYW5pbWFsOiAxXG4gKiAvLyB9XG4gKi9cbnZhciBCYXllc2lhbkNsYXNzaWZpZXIgPSBmdW5jdGlvbiBCYXllc2lhbkNsYXNzaWZpZXIoKSB7XG4gICAgLy8gVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGFyZSBjdXJyZW50bHlcbiAgICAvLyBjbGFzc2lmaWVkIGluIHRoZSBtb2RlbFxuICAgIHRoaXMudG90YWxDb3VudCA9IDA7XG4gICAgLy8gRXZlcnkgaXRlbSBjbGFzc2lmaWVkIGluIHRoZSBtb2RlbFxuICAgIHRoaXMuZGF0YSA9IHt9O1xufTtcblxuLyoqXG4gKiBUcmFpbiB0aGUgY2xhc3NpZmllciB3aXRoIGEgbmV3IGl0ZW0sIHdoaWNoIGhhcyBhIHNpbmdsZVxuICogZGltZW5zaW9uIG9mIEphdmFzY3JpcHQgbGl0ZXJhbCBrZXlzIGFuZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gYW4gb2JqZWN0IHdpdGggc2luZ2x5LWRlZXAgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IHRoZSBjYXRlZ29yeSB0aGlzIGl0ZW0gYmVsb25ncyB0b1xuICogQHJldHVybiB7dW5kZWZpbmVkfSBhZGRzIHRoZSBpdGVtIHRvIHRoZSBjbGFzc2lmaWVyXG4gKi9cbkJheWVzaWFuQ2xhc3NpZmllci5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiB0cmFpbiAoaXRlbSwgY2F0ZWdvcnkpIHtcbiAgICAvLyBJZiB0aGUgZGF0YSBvYmplY3QgZG9lc24ndCBoYXZlIGFueSB2YWx1ZXNcbiAgICAvLyBmb3IgdGhpcyBjYXRlZ29yeSwgY3JlYXRlIGEgbmV3IG9iamVjdCBmb3IgaXQuXG4gICAgaWYgKCF0aGlzLmRhdGFbY2F0ZWdvcnldKSB7XG4gICAgICAgIHRoaXMuZGF0YVtjYXRlZ29yeV0gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBrZXkgaW4gdGhlIGl0ZW0uXG4gICAgZm9yICh2YXIgayBpbiBpdGVtKSB7XG4gICAgICAgIHZhciB2ID0gaXRlbVtrXTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbmVzdGVkIG9iamVjdCBgZGF0YVtjYXRlZ29yeV1ba11baXRlbVtrXV1gXG4gICAgICAgIC8vIHdpdGggYW4gb2JqZWN0IG9mIGtleXMgdGhhdCBlcXVhbCAwLlxuICAgICAgICBpZiAodGhpcy5kYXRhW2NhdGVnb3J5XVtrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbY2F0ZWdvcnldW2tdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YVtjYXRlZ29yeV1ba11bdl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2NhdGVnb3J5XVtrXVt2XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmQgaW5jcmVtZW50IHRoZSBrZXkgZm9yIHRoaXMga2V5L3ZhbHVlIGNvbWJpbmF0aW9uLlxuICAgICAgICB0aGlzLmRhdGFbY2F0ZWdvcnldW2tdW3ZdKys7XG4gICAgfVxuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgaXRlbXMgY2xhc3NpZmllZFxuICAgIHRoaXMudG90YWxDb3VudCsrO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNjb3JlIG9mIGhvdyB3ZWxsIHRoaXMgaXRlbSBtYXRjaGVzIGFsbFxuICogcG9zc2libGUgY2F0ZWdvcmllcyBiYXNlZCBvbiBpdHMgYXR0cmlidXRlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIGFuIGl0ZW0gaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHdpdGggdHJhaW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9mIHByb2JhYmlsaXRpZXMgdGhhdCB0aGlzIGl0ZW0gYmVsb25ncyB0byBhXG4gKiBnaXZlbiBjYXRlZ29yeS5cbiAqL1xuQmF5ZXNpYW5DbGFzc2lmaWVyLnByb3RvdHlwZS5zY29yZSA9IGZ1bmN0aW9uIHNjb3JlIChpdGVtKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhbiBlbXB0eSBhcnJheSBvZiBvZGRzIHBlciBjYXRlZ29yeS5cbiAgICB2YXIgb2RkcyA9IHt9O1xuICAgIHZhciBjYXRlZ29yeTtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBrZXkgaW4gdGhlIGl0ZW0sXG4gICAgLy8gdGhlbiBpdGVyYXRlIHRocm91Z2ggZWFjaCBjYXRlZ29yeSB0aGF0IGhhcyBiZWVuIHVzZWRcbiAgICAvLyBpbiBwcmV2aW91cyBjYWxscyB0byBgLnRyYWluKClgXG4gICAgZm9yICh2YXIgayBpbiBpdGVtKSB7XG4gICAgICAgIHZhciB2ID0gaXRlbVtrXTtcbiAgICAgICAgZm9yIChjYXRlZ29yeSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBvYmplY3QgZm9yIHN0b3Jpbmcga2V5IC0gdmFsdWUgY29tYmluYXRpb25zXG4gICAgICAgICAgICAvLyBmb3IgdGhpcyBjYXRlZ29yeS5cbiAgICAgICAgICAgIG9kZHNbY2F0ZWdvcnldID0ge307XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXRlbSBkb2Vzbid0IGV2ZW4gaGF2ZSBhIHByb3BlcnR5LCBpdCBjb3VudHMgZm9yIG5vdGhpbmcsXG4gICAgICAgICAgICAvLyBidXQgaWYgaXQgZG9lcyBoYXZlIHRoZSBwcm9wZXJ0eSB0aGF0IHdlJ3JlIGxvb2tpbmcgZm9yIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSBpdGVtIHRvIGNhdGVnb3JpemUsIGl0IGNvdW50cyBiYXNlZCBvbiBob3cgcG9wdWxhciBpdCBpc1xuICAgICAgICAgICAgLy8gdmVyc3VzIHRoZSB3aG9sZSBwb3B1bGF0aW9uLlxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtjYXRlZ29yeV1ba10pIHtcbiAgICAgICAgICAgICAgICBvZGRzW2NhdGVnb3J5XVtrICsgXCJfXCIgKyB2XSA9XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmRhdGFbY2F0ZWdvcnldW2tdW3ZdIHx8IDApIC8gdGhpcy50b3RhbENvdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZGRzW2NhdGVnb3J5XVtrICsgXCJfXCIgKyB2XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgYSBuZXcgb2JqZWN0IHRoYXQgd2lsbCBjb250YWluIHN1bXMgb2YgdGhlc2Ugb2RkcyBieSBjYXRlZ29yeVxuICAgIHZhciBvZGRzU3VtcyA9IHt9O1xuXG4gICAgZm9yIChjYXRlZ29yeSBpbiBvZGRzKSB7XG4gICAgICAgIC8vIFRhbGx5IGFsbCBvZiB0aGUgb2RkcyBmb3IgZWFjaCBjYXRlZ29yeS1jb21iaW5hdGlvbiBwYWlyIC1cbiAgICAgICAgLy8gdGhlIG5vbi1leGlzdGVuY2Ugb2YgYSBjYXRlZ29yeSBkb2VzIG5vdCBhZGQgYW55dGhpbmcgdG8gdGhlXG4gICAgICAgIC8vIHNjb3JlLlxuICAgICAgICBvZGRzU3Vtc1tjYXRlZ29yeV0gPSAwO1xuICAgICAgICBmb3IgKHZhciBjb21iaW5hdGlvbiBpbiBvZGRzW2NhdGVnb3J5XSkge1xuICAgICAgICAgICAgb2Rkc1N1bXNbY2F0ZWdvcnldICs9IG9kZHNbY2F0ZWdvcnldW2NvbWJpbmF0aW9uXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZGRzU3Vtcztcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIHNpbmdsZS1sYXllciBbUGVyY2VwdHJvbiBDbGFzc2lmaWVyXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcmNlcHRyb24pIHRoYXQgdGFrZXNcbiAqIGFycmF5cyBvZiBudW1iZXJzIGFuZCBwcmVkaWN0cyB3aGV0aGVyIHRoZXkgc2hvdWxkIGJlIGNsYXNzaWZpZWRcbiAqIGFzIGVpdGhlciAwIG9yIDEgKG5lZ2F0aXZlIG9yIHBvc2l0aXZlIGV4YW1wbGVzKS5cbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSB0aGUgbW9kZWxcbiAqIHZhciBwID0gbmV3IFBlcmNlcHRyb25Nb2RlbCgpO1xuICogLy8gVHJhaW4gdGhlIG1vZGVsIHdpdGggaW5wdXQgd2l0aCBhIGRpYWdvbmFsIGJvdW5kYXJ5LlxuICogZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAqICAgICBwLnRyYWluKFsxLCAxXSwgMSk7XG4gKiAgICAgcC50cmFpbihbMCwgMV0sIDApO1xuICogICAgIHAudHJhaW4oWzEsIDBdLCAwKTtcbiAqICAgICBwLnRyYWluKFswLCAwXSwgMCk7XG4gKiB9XG4gKiBwLnByZWRpY3QoWzAsIDBdKTsgLy8gMFxuICogcC5wcmVkaWN0KFswLCAxXSk7IC8vIDBcbiAqIHAucHJlZGljdChbMSwgMF0pOyAvLyAwXG4gKiBwLnByZWRpY3QoWzEsIDFdKTsgLy8gMVxuICovXG52YXIgUGVyY2VwdHJvbk1vZGVsID0gZnVuY3Rpb24gUGVyY2VwdHJvbk1vZGVsKCkge1xuICAgIC8vIFRoZSB3ZWlnaHRzLCBvciBjb2VmZmljaWVudHMgb2YgdGhlIG1vZGVsO1xuICAgIC8vIHdlaWdodHMgYXJlIG9ubHkgcG9wdWxhdGVkIHdoZW4gdHJhaW5pbmcgd2l0aCBkYXRhLlxuICAgIHRoaXMud2VpZ2h0cyA9IFtdO1xuICAgIC8vIFRoZSBiaWFzIHRlcm0sIG9yIGludGVyY2VwdDsgaXQgaXMgYWxzbyBhIHdlaWdodCBidXRcbiAgICAvLyBpdCdzIHN0b3JlZCBzZXBhcmF0ZWx5IGZvciBjb252ZW5pZW5jZSBhcyBpdCBpcyBhbHdheXNcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IG9uZS5cbiAgICB0aGlzLmJpYXMgPSAwO1xufTtcbi8qKlxuICogKipQcmVkaWN0Kio6IFVzZSBhbiBhcnJheSBvZiBmZWF0dXJlcyB3aXRoIHRoZSB3ZWlnaHQgYXJyYXkgYW5kIGJpYXNcbiAqIHRvIHByZWRpY3Qgd2hldGhlciBhbiBleGFtcGxlIGlzIGxhYmVsZWQgMCBvciAxLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmVhdHVyZXMgYW4gYXJyYXkgb2YgZmVhdHVyZXMgYXMgbnVtYmVyc1xuICogQHJldHVybnMge251bWJlcn0gMSBpZiB0aGUgc2NvcmUgaXMgb3ZlciAwLCBvdGhlcndpc2UgMFxuICovXG5QZXJjZXB0cm9uTW9kZWwucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiBwcmVkaWN0IChmZWF0dXJlcykge1xuICAgIC8vIE9ubHkgcHJlZGljdCBpZiBwcmV2aW91c2x5IHRyYWluZWRcbiAgICAvLyBvbiB0aGUgc2FtZSBzaXplIGZlYXR1cmUgYXJyYXkocykuXG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCAhPT0gdGhpcy53ZWlnaHRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHN1bSBvZiBmZWF0dXJlcyB0aW1lcyB3ZWlnaHRzLFxuICAgIC8vIHdpdGggdGhlIGJpYXMgYWRkZWQgKGltcGxpY2l0bHkgdGltZXMgb25lKS5cbiAgICB2YXIgc2NvcmUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNjb3JlICs9IHRoaXMud2VpZ2h0c1tpXSAqIGZlYXR1cmVzW2ldO1xuICAgIH1cbiAgICBzY29yZSArPSB0aGlzLmJpYXM7XG5cbiAgICAvLyBDbGFzc2lmeSBhcyAxIGlmIHRoZSBzY29yZSBpcyBvdmVyIDAsIG90aGVyd2lzZSAwLlxuICAgIGlmIChzY29yZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiAqKlRyYWluKiogdGhlIGNsYXNzaWZpZXIgd2l0aCBhIG5ldyBleGFtcGxlLCB3aGljaCBpc1xuICogYSBudW1lcmljIGFycmF5IG9mIGZlYXR1cmVzIGFuZCBhIDAgb3IgMSBsYWJlbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVzIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFzIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbCBlaXRoZXIgMCBvciAxXG4gKiBAcmV0dXJucyB7UGVyY2VwdHJvbk1vZGVsfSB0aGlzXG4gKi9cblBlcmNlcHRyb25Nb2RlbC5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiB0cmFpbiAoZmVhdHVyZXMsIGxhYmVsKSB7XG4gICAgLy8gUmVxdWlyZSB0aGF0IG9ubHkgbGFiZWxzIG9mIDAgb3IgMSBhcmUgY29uc2lkZXJlZC5cbiAgICBpZiAobGFiZWwgIT09IDAgJiYgbGFiZWwgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZSBsZW5ndGggb2YgdGhlIGZlYXR1cmUgYXJyYXkgZGV0ZXJtaW5lc1xuICAgIC8vIHRoZSBsZW5ndGggb2YgdGhlIHdlaWdodCBhcnJheS5cbiAgICAvLyBUaGUgcGVyY2VwdHJvbiB3aWxsIGNvbnRpbnVlIGxlYXJuaW5nIGFzIGxvbmcgYXNcbiAgICAvLyBpdCBrZWVwcyBzZWVpbmcgZmVhdHVyZSBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoLlxuICAgIC8vIFdoZW4gaXQgc2VlcyBhIG5ldyBkYXRhIHNoYXBlLCBpdCBpbml0aWFsaXplcy5cbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoICE9PSB0aGlzLndlaWdodHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IGZlYXR1cmVzO1xuICAgICAgICB0aGlzLmJpYXMgPSAxO1xuICAgIH1cbiAgICAvLyBNYWtlIGEgcHJlZGljdGlvbiBiYXNlZCBvbiBjdXJyZW50IHdlaWdodHMuXG4gICAgdmFyIHByZWRpY3Rpb24gPSB0aGlzLnByZWRpY3QoZmVhdHVyZXMpO1xuICAgIC8vIFVwZGF0ZSB0aGUgd2VpZ2h0cyBpZiB0aGUgcHJlZGljdGlvbiBpcyB3cm9uZy5cbiAgICBpZiAodHlwZW9mIHByZWRpY3Rpb24gPT09IFwibnVtYmVyXCIgJiYgcHJlZGljdGlvbiAhPT0gbGFiZWwpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gbGFiZWwgLSBwcmVkaWN0aW9uO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRzW2ldICs9IGdyYWRpZW50ICogZmVhdHVyZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaWFzICs9IGdyYWRpZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2UgdXNlIGDOtWAsIGVwc2lsb24sIGFzIGEgc3RvcHBpbmcgY3JpdGVyaW9uIHdoZW4gd2Ugd2FudCB0byBpdGVyYXRlXG4gKiB1bnRpbCB3ZSdyZSBcImNsb3NlIGVub3VnaFwiLiBFcHNpbG9uIGlzIGEgdmVyeSBzbWFsbCBudW1iZXI6IGZvclxuICogc2ltcGxlIHN0YXRpc3RpY3MsIHRoYXQgbnVtYmVyIGlzICoqMC4wMDAxKipcbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW4gY2FsY3VsYXRpb25zIGxpa2UgdGhlIGJpbm9taWFsRGlzdHJpYnV0aW9uLCBpbiB3aGljaFxuICogdGhlIHByb2Nlc3Mgb2YgZmluZGluZyBhIHZhbHVlIGlzIFtpdGVyYXRpdmVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0l0ZXJhdGl2ZV9tZXRob2QpOlxuICogaXQgcHJvZ3Jlc3NlcyB1bnRpbCBpdCBpcyBjbG9zZSBlbm91Z2guXG4gKlxuICogQmVsb3cgaXMgYW4gZXhhbXBsZSBvZiB1c2luZyBlcHNpbG9uIGluIFtncmFkaWVudCBkZXNjZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmFkaWVudF9kZXNjZW50KSxcbiAqIHdoZXJlIHdlJ3JlIHRyeWluZyB0byBmaW5kIGEgbG9jYWwgbWluaW11bSBvZiBhIGZ1bmN0aW9uJ3MgZGVyaXZhdGl2ZSxcbiAqIGdpdmVuIGJ5IHRoZSBgZkRlcml2YXRpdmVgIG1ldGhvZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRnJvbSBjYWxjdWxhdGlvbiwgd2UgZXhwZWN0IHRoYXQgdGhlIGxvY2FsIG1pbmltdW0gb2NjdXJzIGF0IHg9OS80XG4gKiB2YXIgeF9vbGQgPSAwO1xuICogLy8gVGhlIGFsZ29yaXRobSBzdGFydHMgYXQgeD02XG4gKiB2YXIgeF9uZXcgPSA2O1xuICogdmFyIHN0ZXBTaXplID0gMC4wMTtcbiAqXG4gKiBmdW5jdGlvbiBmRGVyaXZhdGl2ZSh4KSB7XG4gKiAgIHJldHVybiA0ICogTWF0aC5wb3coeCwgMykgLSA5ICogTWF0aC5wb3coeCwgMik7XG4gKiB9XG4gKlxuICogLy8gVGhlIGxvb3AgcnVucyB1bnRpbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwcmV2aW91c1xuICogLy8gdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIHNtYWxsZXIgdGhhbiBlcHNpbG9uIC0gYSByb3VnaFxuICogLy8gbWVhdXJlIG9mICdjbG9zZSBlbm91Z2gnXG4gKiB3aGlsZSAoTWF0aC5hYnMoeF9uZXcgLSB4X29sZCkgPiBzcy5lcHNpbG9uKSB7XG4gKiAgIHhfb2xkID0geF9uZXc7XG4gKiAgIHhfbmV3ID0geF9vbGQgLSBzdGVwU2l6ZSAqIGZEZXJpdmF0aXZlKHhfb2xkKTtcbiAqIH1cbiAqXG4gKiBjb25zb2xlLmxvZygnTG9jYWwgbWluaW11bSBvY2N1cnMgYXQnLCB4X25ldyk7XG4gKi9cbnZhciBlcHNpbG9uID0gMC4wMDAxO1xuXG4vKipcbiAqIEEgW0ZhY3RvcmlhbF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmFjdG9yaWFsKSwgdXN1YWxseSB3cml0dGVuIG4hLCBpcyB0aGUgcHJvZHVjdCBvZiBhbGwgcG9zaXRpdmVcbiAqIGludGVnZXJzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBuLiBPZnRlbiBmYWN0b3JpYWwgaXMgaW1wbGVtZW50ZWRcbiAqIHJlY3Vyc2l2ZWx5LCBidXQgdGhpcyBpdGVyYXRpdmUgYXBwcm9hY2ggaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXJcbiAqIGFuZCBzaW1wbGVyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIGlucHV0LCBtdXN0IGJlIGFuIGludGVnZXIgbnVtYmVyIDEgb3IgZ3JlYXRlclxuICogQHJldHVybnMge251bWJlcn0gZmFjdG9yaWFsOiBuIVxuICogQHRocm93cyB7RXJyb3J9IGlmIG4gaXMgbGVzcyB0aGFuIDAgb3Igbm90IGFuIGludGVnZXJcbiAqIEBleGFtcGxlXG4gKiBmYWN0b3JpYWwoNSk7IC8vID0+IDEyMFxuICovXG5mdW5jdGlvbiBmYWN0b3JpYWwobikge1xuICAgIC8vIGZhY3RvcmlhbCBpcyBtYXRoZW1hdGljYWxseSB1bmRlZmluZWQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcbiAgICBpZiAobiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFjdG9yaWFsIHJlcXVpcmVzIGEgbm9uLW5lZ2F0aXZlIHZhbHVlXCIpO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmZsb29yKG4pICE9PSBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhY3RvcmlhbCByZXF1aXJlcyBhbiBpbnRlZ2VyIGlucHV0XCIpO1xuICAgIH1cblxuICAgIC8vIHR5cGljYWxseSB5b3UnbGwgZXhwYW5kIHRoZSBmYWN0b3JpYWwgZnVuY3Rpb24gZ29pbmcgZG93biwgbGlrZVxuICAgIC8vIDUhID0gNSAqIDQgKiAzICogMiAqIDEuIFRoaXMgaXMgZ29pbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbixcbiAgICAvLyBjb3VudGluZyBmcm9tIDIgdXAgdG8gdGhlIG51bWJlciBpbiBxdWVzdGlvbiwgYW5kIHNpbmNlIGFueXRoaW5nXG4gICAgLy8gbXVsdGlwbGllZCBieSAxIGlzIGl0c2VsZiwgdGhlIGxvb3Agb25seSBuZWVkcyB0byBzdGFydCBhdCAyLlxuICAgIHZhciBhY2N1bXVsYXRvciA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIC8vIGZvciBlYWNoIG51bWJlciB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBudW1iZXIgYG5gLCBtdWx0aXBseVxuICAgICAgICAvLyB0aGUgYWNjdW11bGF0b3IgbXkgdGhhdCBudW1iZXIuXG4gICAgICAgIGFjY3VtdWxhdG9yICo9IGk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBbZ2FtbWEgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhbW1hX2Z1bmN0aW9uKSBvZiBhIHZhbHVlIHVzaW5nIE5lbWVzJyBhcHByb3hpbWF0aW9uLlxuICogVGhlIGdhbW1hIG9mIG4gaXMgZXF1aXZhbGVudCB0byAobi0xKSEsIGJ1dCB1bmxpa2UgdGhlIGZhY3RvcmlhbCBmdW5jdGlvbiwgZ2FtbWEgaXMgZGVmaW5lZCBmb3IgYWxsIHJlYWwgbiBleGNlcHQgemVyb1xuICogYW5kIG5lZ2F0aXZlIGludGVnZXJzICh3aGVyZSBOYU4gaXMgcmV0dXJuZWQpLiBOb3RlLCB0aGUgZ2FtbWEgZnVuY3Rpb24gaXMgYWxzbyB3ZWxsLWRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVycyxcbiAqIHRob3VnaCB0aGlzIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBkb2VzIG5vdCBoYW5kbGUgY29tcGxleCBudW1iZXJzIGFzIGlucHV0IHZhbHVlcy5cbiAqIE5lbWVzJyBhcHByb3hpbWF0aW9uIGlzIGRlZmluZWQgW2hlcmVdKGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xMDAzLjYwMjApIGFzIFRoZW9yZW0gMi4yLlxuICogTmVnYXRpdmUgdmFsdWVzIHVzZSBbRXVsZXIncyByZWZsZWN0aW9uIGZvcm11bGFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhbW1hX2Z1bmN0aW9uI1Byb3BlcnRpZXMpIGZvciBjb21wdXRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBBbnkgcmVhbCBudW1iZXIgZXhjZXB0IGZvciB6ZXJvIGFuZCBuZWdhdGl2ZSBpbnRlZ2Vycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBnYW1tYSBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGdhbW1hKDExLjUpOyAvLyAxMTg5OTQyMy4wODQwMzcwMzhcbiAqIGdhbW1hKC0xMS41KTsgLy8gMi4yOTU3NTgxMDQ4MTYwOWUtOFxuICogZ2FtbWEoNSk7IC8vIDI0XG4gKi9cbmZ1bmN0aW9uIGdhbW1hKG4pIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgICAvLyBnYW1tYSBub3QgZGVmaW5lZCBmb3IgemVybyBvciBuZWdhdGl2ZSBpbnRlZ2Vyc1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2UgZmFjdG9yaWFsIGZvciBpbnRlZ2VyIGlucHV0c1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcmlhbChuIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWNyZW1lbnQgbiwgYmVjYXVzZSBhcHByb3hpbWF0aW9uIGlzIGRlZmluZWQgZm9yIG4gLSAxXG4gICAgbi0tO1xuXG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIC8vIFVzZSBFdWxlcidzIHJlZmxlY3Rpb24gZm9ybXVsYSBmb3IgbmVnYXRpdmUgaW5wdXRzXG4gICAgICAgIC8vIHNlZTogIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhbW1hX2Z1bmN0aW9uI1Byb3BlcnRpZXNcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIC1uKSAqIGdhbW1hKC1uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTmVtZXMnIGV4cGFuc2lvbiBhcHByb3hpbWF0aW9uXG4gICAgICAgIHZhciBzZXJpZXNDb2VmZmljaWVudCA9XG4gICAgICAgICAgICBNYXRoLnBvdyhuIC8gTWF0aC5FLCBuKSAqIE1hdGguc3FydCgyICogTWF0aC5QSSAqIChuICsgMSAvIDYpKTtcblxuICAgICAgICB2YXIgc2VyaWVzRGVub20gPSBuICsgMSAvIDQ7XG5cbiAgICAgICAgdmFyIHNlcmllc0V4cGFuc2lvbiA9XG4gICAgICAgICAgICAxICtcbiAgICAgICAgICAgIDEgLyAxNDQgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgMikgLVxuICAgICAgICAgICAgMSAvIDEyOTYwIC8gTWF0aC5wb3coc2VyaWVzRGVub20sIDMpIC1cbiAgICAgICAgICAgIDI1NyAvIDIwNzM2MCAvIE1hdGgucG93KHNlcmllc0Rlbm9tLCA0KSAtXG4gICAgICAgICAgICA1MiAvIDI2MTI3MzYgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNSkgK1xuICAgICAgICAgICAgNTc0MTE3MyAvIDk0MDU4NDk2MDAgLyBNYXRoLnBvdyhzZXJpZXNEZW5vbSwgNikgK1xuICAgICAgICAgICAgMzc1MjkgLyAxODgxMTY5OTIwMCAvIE1hdGgucG93KHNlcmllc0Rlbm9tLCA3KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzQ29lZmZpY2llbnQgKiBzZXJpZXNFeHBhbnNpb247XG4gICAgfVxufVxuXG4vLyBEZWZpbmUgc2VyaWVzIGNvZWZmaWNpZW50c1xudmFyIENPRUZGSUNJRU5UUyA9IFtcbiAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLCA1Ny4xNTYyMzU2NjU4NjI5MjM1MTcsIC01OS41OTc5NjAzNTU0NzU0OTEyNDgsXG4gICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LCAtMC40OTE5MTM4MTYwOTc2MjAxOTk3OCwgMC4zMzk5NDY0OTk4NDgxMTg4ODY5OWUtNCxcbiAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LCAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLCAtMC4yMTAyNjQ0NDE3MjQxMDQ4ODMxOWUtMyxcbiAgICAwLjIxNzQzOTYxODExNTIxMjY0MzJlLTMsIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAgIDAuODQ0MTgyMjM5ODM4NTI3NDMyOTNlLTQsIC0wLjI2MTkwODM4NDAxNTgxNDA4NjdlLTQsXG4gICAgMC4zNjg5OTE4MjY1OTUzMTYyMjcwNGUtNVxuXTtcblxudmFyIGcgPSA2MDcgLyAxMjg7XG52YXIgTE9HU1FSVDJQSSA9IE1hdGgubG9nKE1hdGguc3FydCgyICogTWF0aC5QSSkpO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxvZ2FyaXRobSBvZiB0aGUgW2dhbW1hIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYW1tYV9mdW5jdGlvbikgb2YgYSB2YWx1ZSB1c2luZyBMYW5jem9zJyBhcHByb3hpbWF0aW9uLlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhcyBpbnB1dCBhbnkgcmVhbC12YWx1ZSBuIGdyZWF0ZXIgdGhhbiAwLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgZm9yIHZhbHVlcyBvZiBuIHRvbyBsYXJnZSBmb3IgdGhlIG5vcm1hbCBnYW1tYSBmdW5jdGlvbiAobiA+IDE2NSkuXG4gKiBUaGUgY29kZSBpcyBiYXNlZCBvbiBMYW5jem8ncyBHYW1tYSBhcHByb3hpbWF0aW9uLCBkZWZpbmVkIFtoZXJlXShodHRwOi8vbXkuZml0LmVkdS9+Z2FiZG8vZ2FtbWEudHh0KS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBBbnkgcmVhbCBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbG9nYXJpdGhtIG9mIGdhbW1hIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogZ2FtbWFsbig1MDApOyAvLyAyNjA1LjExNTg1MDM2MTczMzVcbiAqIGdhbW1hbG4oMi40KTsgLy8gMC4yMTY4NTkzMjI0NDg4NDA0M1xuICovXG5mdW5jdGlvbiBnYW1tYWxuKG4pIHtcbiAgICAvLyBSZXR1cm4gaW5maW5pdHkgaWYgdmFsdWUgbm90IGluIGRvbWFpblxuICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG5cbiAgICAvLyBEZWNyZW1lbnQgbiwgYmVjYXVzZSBhcHByb3hpbWF0aW9uIGlzIGRlZmluZWQgZm9yIG4gLSAxXG4gICAgbi0tO1xuXG4gICAgLy8gQ3JlYXRlIHNlcmllcyBhcHByb3hpbWF0aW9uXG4gICAgdmFyIGEgPSBDT0VGRklDSUVOVFNbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgICAgYSArPSBDT0VGRklDSUVOVFNbaV0gLyAobiArIGkpO1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBnICsgMC41ICsgbjtcblxuICAgIC8vIFJldHVybiBuYXR1cmFsIGxvZ2FyaXRobSBvZiBnYW1tYShuKVxuICAgIHJldHVybiBMT0dTUVJUMlBJICsgTWF0aC5sb2coYSkgLSB0bXAgKyAobiArIDAuNSkgKiBNYXRoLmxvZyh0bXApO1xufVxuXG4vKipcbiAqIFRoZSBbQmVybm91bGxpIGRpc3RyaWJ1dGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZXJub3VsbGlfZGlzdHJpYnV0aW9uKVxuICogaXMgdGhlIHByb2JhYmlsaXR5IGRpc2NyZXRlXG4gKiBkaXN0cmlidXRpb24gb2YgYSByYW5kb20gdmFyaWFibGUgd2hpY2ggdGFrZXMgdmFsdWUgMSB3aXRoIHN1Y2Nlc3NcbiAqIHByb2JhYmlsaXR5IGBwYCBhbmQgdmFsdWUgMCB3aXRoIGZhaWx1cmVcbiAqIHByb2JhYmlsaXR5IGBxYCA9IDEgLSBgcGAuIEl0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gcmVwcmVzZW50IHRoZVxuICogdG9zcyBvZiBhIGNvaW4sIHdoZXJlIFwiMVwiIGlzIGRlZmluZWQgdG8gbWVhbiBcImhlYWRzXCIgYW5kIFwiMFwiIGlzIGRlZmluZWRcbiAqIHRvIG1lYW4gXCJ0YWlsc1wiIChvciB2aWNlIHZlcnNhKS4gSXQgaXNcbiAqIGEgc3BlY2lhbCBjYXNlIG9mIGEgQmlub21pYWwgRGlzdHJpYnV0aW9uXG4gKiB3aGVyZSBgbmAgPSAxLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwIGlucHV0IHZhbHVlLCBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZhbHVlcyBvZiBiZXJub3VsbGkgZGlzdHJpYnV0aW9uIGF0IHRoaXMgcG9pbnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBwIGlzIG91dHNpZGUgMCBhbmQgMVxuICogQGV4YW1wbGVcbiAqIGJlcm5vdWxsaURpc3RyaWJ1dGlvbigwLjMpOyAvLyA9PiBbMC43LCAwLjNdXG4gKi9cbmZ1bmN0aW9uIGJlcm5vdWxsaURpc3RyaWJ1dGlvbihwKSAvKjogbnVtYmVyW10gKi8ge1xuICAgIC8vIENoZWNrIHRoYXQgYHBgIGlzIGEgdmFsaWQgcHJvYmFiaWxpdHkgKDAg4omkIHAg4omkIDEpXG4gICAgaWYgKHAgPCAwIHx8IHAgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiYmVybm91bGxpRGlzdHJpYnV0aW9uIHJlcXVpcmVzIHByb2JhYmlsaXR5IHRvIGJlIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmVcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBbMSAtIHAsIHBdO1xufVxuXG4vKipcbiAqIFRoZSBbQmlub21pYWwgRGlzdHJpYnV0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jpbm9taWFsX2Rpc3RyaWJ1dGlvbikgaXMgdGhlIGRpc2NyZXRlIHByb2JhYmlsaXR5XG4gKiBkaXN0cmlidXRpb24gb2YgdGhlIG51bWJlciBvZiBzdWNjZXNzZXMgaW4gYSBzZXF1ZW5jZSBvZiBuIGluZGVwZW5kZW50IHllcy9ubyBleHBlcmltZW50cywgZWFjaCBvZiB3aGljaCB5aWVsZHNcbiAqIHN1Y2Nlc3Mgd2l0aCBwcm9iYWJpbGl0eSBgcHJvYmFiaWxpdHlgLiBTdWNoIGEgc3VjY2Vzcy9mYWlsdXJlIGV4cGVyaW1lbnQgaXMgYWxzbyBjYWxsZWQgYSBCZXJub3VsbGkgZXhwZXJpbWVudCBvclxuICogQmVybm91bGxpIHRyaWFsOyB3aGVuIHRyaWFscyA9IDEsIHRoZSBCaW5vbWlhbCBEaXN0cmlidXRpb24gaXMgYSBCZXJub3VsbGkgRGlzdHJpYnV0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0cmlhbHMgbnVtYmVyIG9mIHRyaWFscyB0byBzaW11bGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHByb2JhYmlsaXR5XG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG91dHB1dFxuICovXG5mdW5jdGlvbiBiaW5vbWlhbERpc3RyaWJ1dGlvbih0cmlhbHMsIHByb2JhYmlsaXR5KSAvKjogP251bWJlcltdICovIHtcbiAgICAvLyBDaGVjayB0aGF0IGBwYCBpcyBhIHZhbGlkIHByb2JhYmlsaXR5ICgwIOKJpCBwIOKJpCAxKSxcbiAgICAvLyB0aGF0IGBuYCBpcyBhbiBpbnRlZ2VyLCBzdHJpY3RseSBwb3NpdGl2ZS5cbiAgICBpZiAocHJvYmFiaWxpdHkgPCAwIHx8IHByb2JhYmlsaXR5ID4gMSB8fCB0cmlhbHMgPD0gMCB8fCB0cmlhbHMgJSAxICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgaW5pdGlhbGl6ZSBgeGAsIHRoZSByYW5kb20gdmFyaWFibGUsIGFuZCBgYWNjdW11bGF0b3JgLCBhbiBhY2N1bXVsYXRvclxuICAgIC8vIGZvciB0aGUgY3VtdWxhdGl2ZSBkaXN0cmlidXRpb24gZnVuY3Rpb24gdG8gMC4gYGRpc3RyaWJ1dGlvbl9mdW5jdGlvbnNgXG4gICAgLy8gaXMgdGhlIG9iamVjdCB3ZSdsbCByZXR1cm4gd2l0aCB0aGUgYHByb2JhYmlsaXR5X29mX3hgIGFuZCB0aGVcbiAgICAvLyBgY3VtdWxhdGl2ZVByb2JhYmlsaXR5X29mX3hgLCBhcyB3ZWxsIGFzIHRoZSBjYWxjdWxhdGVkIG1lYW4gJlxuICAgIC8vIHZhcmlhbmNlLiBXZSBpdGVyYXRlIHVudGlsIHRoZSBgY3VtdWxhdGl2ZVByb2JhYmlsaXR5X29mX3hgIGlzXG4gICAgLy8gd2l0aGluIGBlcHNpbG9uYCBvZiAxLjAuXG4gICAgdmFyIHggPSAwO1xuICAgIHZhciBjdW11bGF0aXZlUHJvYmFiaWxpdHkgPSAwO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIHZhciBiaW5vbWlhbENvZWZmaWNpZW50ID0gMTtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGl0ZXJhdGVzIHRocm91Z2ggZWFjaCBwb3RlbnRpYWwgb3V0Y29tZSxcbiAgICAvLyB1bnRpbCB0aGUgYGN1bXVsYXRpdmVQcm9iYWJpbGl0eWAgaXMgdmVyeSBjbG9zZSB0byAxLCBhdFxuICAgIC8vIHdoaWNoIHBvaW50IHdlJ3ZlIGRlZmluZWQgdGhlIHZhc3QgbWFqb3JpdHkgb2Ygb3V0Y29tZXNcbiAgICBkbyB7XG4gICAgICAgIC8vIGEgW3Byb2JhYmlsaXR5IG1hc3MgZnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb2JhYmlsaXR5X21hc3NfZnVuY3Rpb24pXG4gICAgICAgIGNlbGxzW3hdID1cbiAgICAgICAgICAgIGJpbm9taWFsQ29lZmZpY2llbnQgKlxuICAgICAgICAgICAgTWF0aC5wb3cocHJvYmFiaWxpdHksIHgpICpcbiAgICAgICAgICAgIE1hdGgucG93KDEgLSBwcm9iYWJpbGl0eSwgdHJpYWxzIC0geCk7XG4gICAgICAgIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSArPSBjZWxsc1t4XTtcbiAgICAgICAgeCsrO1xuICAgICAgICBiaW5vbWlhbENvZWZmaWNpZW50ID0gKGJpbm9taWFsQ29lZmZpY2llbnQgKiAodHJpYWxzIC0geCArIDEpKSAvIHg7XG4gICAgICAgIC8vIHdoZW4gdGhlIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSBpcyBuZWFybHkgMSwgd2UndmUgY2FsY3VsYXRlZFxuICAgICAgICAvLyB0aGUgdXNlZnVsIHJhbmdlIG9mIHRoaXMgZGlzdHJpYnV0aW9uXG4gICAgfSB3aGlsZSAoY3VtdWxhdGl2ZVByb2JhYmlsaXR5IDwgMSAtIGVwc2lsb24pO1xuXG4gICAgcmV0dXJuIGNlbGxzO1xufVxuXG4vKipcbiAqIFRoZSBbUG9pc3NvbiBEaXN0cmlidXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9pc3Nvbl9kaXN0cmlidXRpb24pXG4gKiBpcyBhIGRpc2NyZXRlIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiB0aGF0IGV4cHJlc3NlcyB0aGUgcHJvYmFiaWxpdHlcbiAqIG9mIGEgZ2l2ZW4gbnVtYmVyIG9mIGV2ZW50cyBvY2N1cnJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbCBvZiB0aW1lXG4gKiBhbmQvb3Igc3BhY2UgaWYgdGhlc2UgZXZlbnRzIG9jY3VyIHdpdGggYSBrbm93biBhdmVyYWdlIHJhdGUgYW5kXG4gKiBpbmRlcGVuZGVudGx5IG9mIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGV2ZW50LlxuICpcbiAqIFRoZSBQb2lzc29uIERpc3RyaWJ1dGlvbiBpcyBjaGFyYWN0ZXJpemVkIGJ5IHRoZSBzdHJpY3RseSBwb3NpdGl2ZVxuICogbWVhbiBhcnJpdmFsIG9yIG9jY3VycmVuY2UgcmF0ZSwgYM67YC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGFtYmRhIGxvY2F0aW9uIHBvaXNzb24gZGlzdHJpYnV0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZhbHVlcyBvZiBwb2lzc29uIGRpc3RyaWJ1dGlvbiBhdCB0aGF0IHBvaW50XG4gKi9cbmZ1bmN0aW9uIHBvaXNzb25EaXN0cmlidXRpb24obGFtYmRhKSAvKjogP251bWJlcltdICovIHtcbiAgICAvLyBDaGVjayB0aGF0IGxhbWJkYSBpcyBzdHJpY3RseSBwb3NpdGl2ZVxuICAgIGlmIChsYW1iZGEgPD0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIG91ciBjdXJyZW50IHBsYWNlIGluIHRoZSBkaXN0cmlidXRpb25cbiAgICB2YXIgeCA9IDA7XG4gICAgLy8gYW5kIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgY3VtdWxhdGl2ZSBwcm9iYWJpbGl0eSwgaW5cbiAgICAvLyBvcmRlciB0byBrbm93IHdoZW4gdG8gc3RvcCBjYWxjdWxhdGluZyBjaGFuY2VzLlxuICAgIHZhciBjdW11bGF0aXZlUHJvYmFiaWxpdHkgPSAwO1xuICAgIC8vIHRoZSBjYWxjdWxhdGVkIGNlbGxzIHRvIGJlIHJldHVybmVkXG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgdmFyIGZhY3RvcmlhbFggPSAxO1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gaXRlcmF0ZXMgdGhyb3VnaCBlYWNoIHBvdGVudGlhbCBvdXRjb21lLFxuICAgIC8vIHVudGlsIHRoZSBgY3VtdWxhdGl2ZVByb2JhYmlsaXR5YCBpcyB2ZXJ5IGNsb3NlIHRvIDEsIGF0XG4gICAgLy8gd2hpY2ggcG9pbnQgd2UndmUgZGVmaW5lZCB0aGUgdmFzdCBtYWpvcml0eSBvZiBvdXRjb21lc1xuICAgIGRvIHtcbiAgICAgICAgLy8gYSBbcHJvYmFiaWxpdHkgbWFzcyBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvYmFiaWxpdHlfbWFzc19mdW5jdGlvbilcbiAgICAgICAgY2VsbHNbeF0gPSAoTWF0aC5leHAoLWxhbWJkYSkgKiBNYXRoLnBvdyhsYW1iZGEsIHgpKSAvIGZhY3RvcmlhbFg7XG4gICAgICAgIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSArPSBjZWxsc1t4XTtcbiAgICAgICAgeCsrO1xuICAgICAgICBmYWN0b3JpYWxYICo9IHg7XG4gICAgICAgIC8vIHdoZW4gdGhlIGN1bXVsYXRpdmVQcm9iYWJpbGl0eSBpcyBuZWFybHkgMSwgd2UndmUgY2FsY3VsYXRlZFxuICAgICAgICAvLyB0aGUgdXNlZnVsIHJhbmdlIG9mIHRoaXMgZGlzdHJpYnV0aW9uXG4gICAgfSB3aGlsZSAoY3VtdWxhdGl2ZVByb2JhYmlsaXR5IDwgMSAtIGVwc2lsb24pO1xuXG4gICAgcmV0dXJuIGNlbGxzO1xufVxuXG4vKipcbiAqICoqUGVyY2VudGFnZSBQb2ludHMgb2YgdGhlIM+HMiAoQ2hpLVNxdWFyZWQpIERpc3RyaWJ1dGlvbioqXG4gKlxuICogVGhlIFvPhzIgKENoaS1TcXVhcmVkKSBEaXN0cmlidXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hpLXNxdWFyZWRfZGlzdHJpYnV0aW9uKSBpcyB1c2VkIGluIHRoZSBjb21tb25cbiAqIGNoaS1zcXVhcmVkIHRlc3RzIGZvciBnb29kbmVzcyBvZiBmaXQgb2YgYW4gb2JzZXJ2ZWQgZGlzdHJpYnV0aW9uIHRvIGEgdGhlb3JldGljYWwgb25lLCB0aGUgaW5kZXBlbmRlbmNlIG9mIHR3b1xuICogY3JpdGVyaWEgb2YgY2xhc3NpZmljYXRpb24gb2YgcXVhbGl0YXRpdmUgZGF0YSwgYW5kIGluIGNvbmZpZGVuY2UgaW50ZXJ2YWwgZXN0aW1hdGlvbiBmb3IgYSBwb3B1bGF0aW9uIHN0YW5kYXJkXG4gKiBkZXZpYXRpb24gb2YgYSBub3JtYWwgZGlzdHJpYnV0aW9uIGZyb20gYSBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uLlxuICpcbiAqIFZhbHVlcyBmcm9tIEFwcGVuZGl4IDEsIFRhYmxlIElJSSBvZiBXaWxsaWFtIFcuIEhpbmVzICYgRG91Z2xhcyBDLiBNb250Z29tZXJ5LCBcIlByb2JhYmlsaXR5IGFuZCBTdGF0aXN0aWNzIGluXG4gKiBFbmdpbmVlcmluZyBhbmQgTWFuYWdlbWVudCBTY2llbmNlXCIsIFdpbGV5ICgxOTgwKS5cbiAqL1xudmFyIGNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZSA9IHtcbiAgICAxOiB7XG4gICAgICAgIDAuOTk1OiAwLFxuICAgICAgICAwLjk5OiAwLFxuICAgICAgICAwLjk3NTogMCxcbiAgICAgICAgMC45NTogMCxcbiAgICAgICAgMC45OiAwLjAyLFxuICAgICAgICAwLjU6IDAuNDUsXG4gICAgICAgIDAuMTogMi43MSxcbiAgICAgICAgMC4wNTogMy44NCxcbiAgICAgICAgMC4wMjU6IDUuMDIsXG4gICAgICAgIDAuMDE6IDYuNjMsXG4gICAgICAgIDAuMDA1OiA3Ljg4XG4gICAgfSxcbiAgICAyOiB7XG4gICAgICAgIDAuOTk1OiAwLjAxLFxuICAgICAgICAwLjk5OiAwLjAyLFxuICAgICAgICAwLjk3NTogMC4wNSxcbiAgICAgICAgMC45NTogMC4xLFxuICAgICAgICAwLjk6IDAuMjEsXG4gICAgICAgIDAuNTogMS4zOSxcbiAgICAgICAgMC4xOiA0LjYxLFxuICAgICAgICAwLjA1OiA1Ljk5LFxuICAgICAgICAwLjAyNTogNy4zOCxcbiAgICAgICAgMC4wMTogOS4yMSxcbiAgICAgICAgMC4wMDU6IDEwLjZcbiAgICB9LFxuICAgIDM6IHtcbiAgICAgICAgMC45OTU6IDAuMDcsXG4gICAgICAgIDAuOTk6IDAuMTEsXG4gICAgICAgIDAuOTc1OiAwLjIyLFxuICAgICAgICAwLjk1OiAwLjM1LFxuICAgICAgICAwLjk6IDAuNTgsXG4gICAgICAgIDAuNTogMi4zNyxcbiAgICAgICAgMC4xOiA2LjI1LFxuICAgICAgICAwLjA1OiA3LjgxLFxuICAgICAgICAwLjAyNTogOS4zNSxcbiAgICAgICAgMC4wMTogMTEuMzQsXG4gICAgICAgIDAuMDA1OiAxMi44NFxuICAgIH0sXG4gICAgNDoge1xuICAgICAgICAwLjk5NTogMC4yMSxcbiAgICAgICAgMC45OTogMC4zLFxuICAgICAgICAwLjk3NTogMC40OCxcbiAgICAgICAgMC45NTogMC43MSxcbiAgICAgICAgMC45OiAxLjA2LFxuICAgICAgICAwLjU6IDMuMzYsXG4gICAgICAgIDAuMTogNy43OCxcbiAgICAgICAgMC4wNTogOS40OSxcbiAgICAgICAgMC4wMjU6IDExLjE0LFxuICAgICAgICAwLjAxOiAxMy4yOCxcbiAgICAgICAgMC4wMDU6IDE0Ljg2XG4gICAgfSxcbiAgICA1OiB7XG4gICAgICAgIDAuOTk1OiAwLjQxLFxuICAgICAgICAwLjk5OiAwLjU1LFxuICAgICAgICAwLjk3NTogMC44MyxcbiAgICAgICAgMC45NTogMS4xNSxcbiAgICAgICAgMC45OiAxLjYxLFxuICAgICAgICAwLjU6IDQuMzUsXG4gICAgICAgIDAuMTogOS4yNCxcbiAgICAgICAgMC4wNTogMTEuMDcsXG4gICAgICAgIDAuMDI1OiAxMi44MyxcbiAgICAgICAgMC4wMTogMTUuMDksXG4gICAgICAgIDAuMDA1OiAxNi43NVxuICAgIH0sXG4gICAgNjoge1xuICAgICAgICAwLjk5NTogMC42OCxcbiAgICAgICAgMC45OTogMC44NyxcbiAgICAgICAgMC45NzU6IDEuMjQsXG4gICAgICAgIDAuOTU6IDEuNjQsXG4gICAgICAgIDAuOTogMi4yLFxuICAgICAgICAwLjU6IDUuMzUsXG4gICAgICAgIDAuMTogMTAuNjUsXG4gICAgICAgIDAuMDU6IDEyLjU5LFxuICAgICAgICAwLjAyNTogMTQuNDUsXG4gICAgICAgIDAuMDE6IDE2LjgxLFxuICAgICAgICAwLjAwNTogMTguNTVcbiAgICB9LFxuICAgIDc6IHtcbiAgICAgICAgMC45OTU6IDAuOTksXG4gICAgICAgIDAuOTk6IDEuMjUsXG4gICAgICAgIDAuOTc1OiAxLjY5LFxuICAgICAgICAwLjk1OiAyLjE3LFxuICAgICAgICAwLjk6IDIuODMsXG4gICAgICAgIDAuNTogNi4zNSxcbiAgICAgICAgMC4xOiAxMi4wMixcbiAgICAgICAgMC4wNTogMTQuMDcsXG4gICAgICAgIDAuMDI1OiAxNi4wMSxcbiAgICAgICAgMC4wMTogMTguNDgsXG4gICAgICAgIDAuMDA1OiAyMC4yOFxuICAgIH0sXG4gICAgODoge1xuICAgICAgICAwLjk5NTogMS4zNCxcbiAgICAgICAgMC45OTogMS42NSxcbiAgICAgICAgMC45NzU6IDIuMTgsXG4gICAgICAgIDAuOTU6IDIuNzMsXG4gICAgICAgIDAuOTogMy40OSxcbiAgICAgICAgMC41OiA3LjM0LFxuICAgICAgICAwLjE6IDEzLjM2LFxuICAgICAgICAwLjA1OiAxNS41MSxcbiAgICAgICAgMC4wMjU6IDE3LjUzLFxuICAgICAgICAwLjAxOiAyMC4wOSxcbiAgICAgICAgMC4wMDU6IDIxLjk2XG4gICAgfSxcbiAgICA5OiB7XG4gICAgICAgIDAuOTk1OiAxLjczLFxuICAgICAgICAwLjk5OiAyLjA5LFxuICAgICAgICAwLjk3NTogMi43LFxuICAgICAgICAwLjk1OiAzLjMzLFxuICAgICAgICAwLjk6IDQuMTcsXG4gICAgICAgIDAuNTogOC4zNCxcbiAgICAgICAgMC4xOiAxNC42OCxcbiAgICAgICAgMC4wNTogMTYuOTIsXG4gICAgICAgIDAuMDI1OiAxOS4wMixcbiAgICAgICAgMC4wMTogMjEuNjcsXG4gICAgICAgIDAuMDA1OiAyMy41OVxuICAgIH0sXG4gICAgMTA6IHtcbiAgICAgICAgMC45OTU6IDIuMTYsXG4gICAgICAgIDAuOTk6IDIuNTYsXG4gICAgICAgIDAuOTc1OiAzLjI1LFxuICAgICAgICAwLjk1OiAzLjk0LFxuICAgICAgICAwLjk6IDQuODcsXG4gICAgICAgIDAuNTogOS4zNCxcbiAgICAgICAgMC4xOiAxNS45OSxcbiAgICAgICAgMC4wNTogMTguMzEsXG4gICAgICAgIDAuMDI1OiAyMC40OCxcbiAgICAgICAgMC4wMTogMjMuMjEsXG4gICAgICAgIDAuMDA1OiAyNS4xOVxuICAgIH0sXG4gICAgMTE6IHtcbiAgICAgICAgMC45OTU6IDIuNixcbiAgICAgICAgMC45OTogMy4wNSxcbiAgICAgICAgMC45NzU6IDMuODIsXG4gICAgICAgIDAuOTU6IDQuNTcsXG4gICAgICAgIDAuOTogNS41OCxcbiAgICAgICAgMC41OiAxMC4zNCxcbiAgICAgICAgMC4xOiAxNy4yOCxcbiAgICAgICAgMC4wNTogMTkuNjgsXG4gICAgICAgIDAuMDI1OiAyMS45MixcbiAgICAgICAgMC4wMTogMjQuNzIsXG4gICAgICAgIDAuMDA1OiAyNi43NlxuICAgIH0sXG4gICAgMTI6IHtcbiAgICAgICAgMC45OTU6IDMuMDcsXG4gICAgICAgIDAuOTk6IDMuNTcsXG4gICAgICAgIDAuOTc1OiA0LjQsXG4gICAgICAgIDAuOTU6IDUuMjMsXG4gICAgICAgIDAuOTogNi4zLFxuICAgICAgICAwLjU6IDExLjM0LFxuICAgICAgICAwLjE6IDE4LjU1LFxuICAgICAgICAwLjA1OiAyMS4wMyxcbiAgICAgICAgMC4wMjU6IDIzLjM0LFxuICAgICAgICAwLjAxOiAyNi4yMixcbiAgICAgICAgMC4wMDU6IDI4LjNcbiAgICB9LFxuICAgIDEzOiB7XG4gICAgICAgIDAuOTk1OiAzLjU3LFxuICAgICAgICAwLjk5OiA0LjExLFxuICAgICAgICAwLjk3NTogNS4wMSxcbiAgICAgICAgMC45NTogNS44OSxcbiAgICAgICAgMC45OiA3LjA0LFxuICAgICAgICAwLjU6IDEyLjM0LFxuICAgICAgICAwLjE6IDE5LjgxLFxuICAgICAgICAwLjA1OiAyMi4zNixcbiAgICAgICAgMC4wMjU6IDI0Ljc0LFxuICAgICAgICAwLjAxOiAyNy42OSxcbiAgICAgICAgMC4wMDU6IDI5LjgyXG4gICAgfSxcbiAgICAxNDoge1xuICAgICAgICAwLjk5NTogNC4wNyxcbiAgICAgICAgMC45OTogNC42NixcbiAgICAgICAgMC45NzU6IDUuNjMsXG4gICAgICAgIDAuOTU6IDYuNTcsXG4gICAgICAgIDAuOTogNy43OSxcbiAgICAgICAgMC41OiAxMy4zNCxcbiAgICAgICAgMC4xOiAyMS4wNixcbiAgICAgICAgMC4wNTogMjMuNjgsXG4gICAgICAgIDAuMDI1OiAyNi4xMixcbiAgICAgICAgMC4wMTogMjkuMTQsXG4gICAgICAgIDAuMDA1OiAzMS4zMlxuICAgIH0sXG4gICAgMTU6IHtcbiAgICAgICAgMC45OTU6IDQuNixcbiAgICAgICAgMC45OTogNS4yMyxcbiAgICAgICAgMC45NzU6IDYuMjcsXG4gICAgICAgIDAuOTU6IDcuMjYsXG4gICAgICAgIDAuOTogOC41NSxcbiAgICAgICAgMC41OiAxNC4zNCxcbiAgICAgICAgMC4xOiAyMi4zMSxcbiAgICAgICAgMC4wNTogMjUsXG4gICAgICAgIDAuMDI1OiAyNy40OSxcbiAgICAgICAgMC4wMTogMzAuNTgsXG4gICAgICAgIDAuMDA1OiAzMi44XG4gICAgfSxcbiAgICAxNjoge1xuICAgICAgICAwLjk5NTogNS4xNCxcbiAgICAgICAgMC45OTogNS44MSxcbiAgICAgICAgMC45NzU6IDYuOTEsXG4gICAgICAgIDAuOTU6IDcuOTYsXG4gICAgICAgIDAuOTogOS4zMSxcbiAgICAgICAgMC41OiAxNS4zNCxcbiAgICAgICAgMC4xOiAyMy41NCxcbiAgICAgICAgMC4wNTogMjYuMyxcbiAgICAgICAgMC4wMjU6IDI4Ljg1LFxuICAgICAgICAwLjAxOiAzMixcbiAgICAgICAgMC4wMDU6IDM0LjI3XG4gICAgfSxcbiAgICAxNzoge1xuICAgICAgICAwLjk5NTogNS43LFxuICAgICAgICAwLjk5OiA2LjQxLFxuICAgICAgICAwLjk3NTogNy41NixcbiAgICAgICAgMC45NTogOC42NyxcbiAgICAgICAgMC45OiAxMC4wOSxcbiAgICAgICAgMC41OiAxNi4zNCxcbiAgICAgICAgMC4xOiAyNC43NyxcbiAgICAgICAgMC4wNTogMjcuNTksXG4gICAgICAgIDAuMDI1OiAzMC4xOSxcbiAgICAgICAgMC4wMTogMzMuNDEsXG4gICAgICAgIDAuMDA1OiAzNS43MlxuICAgIH0sXG4gICAgMTg6IHtcbiAgICAgICAgMC45OTU6IDYuMjYsXG4gICAgICAgIDAuOTk6IDcuMDEsXG4gICAgICAgIDAuOTc1OiA4LjIzLFxuICAgICAgICAwLjk1OiA5LjM5LFxuICAgICAgICAwLjk6IDEwLjg3LFxuICAgICAgICAwLjU6IDE3LjM0LFxuICAgICAgICAwLjE6IDI1Ljk5LFxuICAgICAgICAwLjA1OiAyOC44NyxcbiAgICAgICAgMC4wMjU6IDMxLjUzLFxuICAgICAgICAwLjAxOiAzNC44MSxcbiAgICAgICAgMC4wMDU6IDM3LjE2XG4gICAgfSxcbiAgICAxOToge1xuICAgICAgICAwLjk5NTogNi44NCxcbiAgICAgICAgMC45OTogNy42MyxcbiAgICAgICAgMC45NzU6IDguOTEsXG4gICAgICAgIDAuOTU6IDEwLjEyLFxuICAgICAgICAwLjk6IDExLjY1LFxuICAgICAgICAwLjU6IDE4LjM0LFxuICAgICAgICAwLjE6IDI3LjIsXG4gICAgICAgIDAuMDU6IDMwLjE0LFxuICAgICAgICAwLjAyNTogMzIuODUsXG4gICAgICAgIDAuMDE6IDM2LjE5LFxuICAgICAgICAwLjAwNTogMzguNThcbiAgICB9LFxuICAgIDIwOiB7XG4gICAgICAgIDAuOTk1OiA3LjQzLFxuICAgICAgICAwLjk5OiA4LjI2LFxuICAgICAgICAwLjk3NTogOS41OSxcbiAgICAgICAgMC45NTogMTAuODUsXG4gICAgICAgIDAuOTogMTIuNDQsXG4gICAgICAgIDAuNTogMTkuMzQsXG4gICAgICAgIDAuMTogMjguNDEsXG4gICAgICAgIDAuMDU6IDMxLjQxLFxuICAgICAgICAwLjAyNTogMzQuMTcsXG4gICAgICAgIDAuMDE6IDM3LjU3LFxuICAgICAgICAwLjAwNTogNDBcbiAgICB9LFxuICAgIDIxOiB7XG4gICAgICAgIDAuOTk1OiA4LjAzLFxuICAgICAgICAwLjk5OiA4LjksXG4gICAgICAgIDAuOTc1OiAxMC4yOCxcbiAgICAgICAgMC45NTogMTEuNTksXG4gICAgICAgIDAuOTogMTMuMjQsXG4gICAgICAgIDAuNTogMjAuMzQsXG4gICAgICAgIDAuMTogMjkuNjIsXG4gICAgICAgIDAuMDU6IDMyLjY3LFxuICAgICAgICAwLjAyNTogMzUuNDgsXG4gICAgICAgIDAuMDE6IDM4LjkzLFxuICAgICAgICAwLjAwNTogNDEuNFxuICAgIH0sXG4gICAgMjI6IHtcbiAgICAgICAgMC45OTU6IDguNjQsXG4gICAgICAgIDAuOTk6IDkuNTQsXG4gICAgICAgIDAuOTc1OiAxMC45OCxcbiAgICAgICAgMC45NTogMTIuMzQsXG4gICAgICAgIDAuOTogMTQuMDQsXG4gICAgICAgIDAuNTogMjEuMzQsXG4gICAgICAgIDAuMTogMzAuODEsXG4gICAgICAgIDAuMDU6IDMzLjkyLFxuICAgICAgICAwLjAyNTogMzYuNzgsXG4gICAgICAgIDAuMDE6IDQwLjI5LFxuICAgICAgICAwLjAwNTogNDIuOFxuICAgIH0sXG4gICAgMjM6IHtcbiAgICAgICAgMC45OTU6IDkuMjYsXG4gICAgICAgIDAuOTk6IDEwLjIsXG4gICAgICAgIDAuOTc1OiAxMS42OSxcbiAgICAgICAgMC45NTogMTMuMDksXG4gICAgICAgIDAuOTogMTQuODUsXG4gICAgICAgIDAuNTogMjIuMzQsXG4gICAgICAgIDAuMTogMzIuMDEsXG4gICAgICAgIDAuMDU6IDM1LjE3LFxuICAgICAgICAwLjAyNTogMzguMDgsXG4gICAgICAgIDAuMDE6IDQxLjY0LFxuICAgICAgICAwLjAwNTogNDQuMThcbiAgICB9LFxuICAgIDI0OiB7XG4gICAgICAgIDAuOTk1OiA5Ljg5LFxuICAgICAgICAwLjk5OiAxMC44NixcbiAgICAgICAgMC45NzU6IDEyLjQsXG4gICAgICAgIDAuOTU6IDEzLjg1LFxuICAgICAgICAwLjk6IDE1LjY2LFxuICAgICAgICAwLjU6IDIzLjM0LFxuICAgICAgICAwLjE6IDMzLjIsXG4gICAgICAgIDAuMDU6IDM2LjQyLFxuICAgICAgICAwLjAyNTogMzkuMzYsXG4gICAgICAgIDAuMDE6IDQyLjk4LFxuICAgICAgICAwLjAwNTogNDUuNTZcbiAgICB9LFxuICAgIDI1OiB7XG4gICAgICAgIDAuOTk1OiAxMC41MixcbiAgICAgICAgMC45OTogMTEuNTIsXG4gICAgICAgIDAuOTc1OiAxMy4xMixcbiAgICAgICAgMC45NTogMTQuNjEsXG4gICAgICAgIDAuOTogMTYuNDcsXG4gICAgICAgIDAuNTogMjQuMzQsXG4gICAgICAgIDAuMTogMzQuMjgsXG4gICAgICAgIDAuMDU6IDM3LjY1LFxuICAgICAgICAwLjAyNTogNDAuNjUsXG4gICAgICAgIDAuMDE6IDQ0LjMxLFxuICAgICAgICAwLjAwNTogNDYuOTNcbiAgICB9LFxuICAgIDI2OiB7XG4gICAgICAgIDAuOTk1OiAxMS4xNixcbiAgICAgICAgMC45OTogMTIuMixcbiAgICAgICAgMC45NzU6IDEzLjg0LFxuICAgICAgICAwLjk1OiAxNS4zOCxcbiAgICAgICAgMC45OiAxNy4yOSxcbiAgICAgICAgMC41OiAyNS4zNCxcbiAgICAgICAgMC4xOiAzNS41NixcbiAgICAgICAgMC4wNTogMzguODksXG4gICAgICAgIDAuMDI1OiA0MS45MixcbiAgICAgICAgMC4wMTogNDUuNjQsXG4gICAgICAgIDAuMDA1OiA0OC4yOVxuICAgIH0sXG4gICAgMjc6IHtcbiAgICAgICAgMC45OTU6IDExLjgxLFxuICAgICAgICAwLjk5OiAxMi44OCxcbiAgICAgICAgMC45NzU6IDE0LjU3LFxuICAgICAgICAwLjk1OiAxNi4xNSxcbiAgICAgICAgMC45OiAxOC4xMSxcbiAgICAgICAgMC41OiAyNi4zNCxcbiAgICAgICAgMC4xOiAzNi43NCxcbiAgICAgICAgMC4wNTogNDAuMTEsXG4gICAgICAgIDAuMDI1OiA0My4xOSxcbiAgICAgICAgMC4wMTogNDYuOTYsXG4gICAgICAgIDAuMDA1OiA0OS42NVxuICAgIH0sXG4gICAgMjg6IHtcbiAgICAgICAgMC45OTU6IDEyLjQ2LFxuICAgICAgICAwLjk5OiAxMy41NyxcbiAgICAgICAgMC45NzU6IDE1LjMxLFxuICAgICAgICAwLjk1OiAxNi45MyxcbiAgICAgICAgMC45OiAxOC45NCxcbiAgICAgICAgMC41OiAyNy4zNCxcbiAgICAgICAgMC4xOiAzNy45MixcbiAgICAgICAgMC4wNTogNDEuMzQsXG4gICAgICAgIDAuMDI1OiA0NC40NixcbiAgICAgICAgMC4wMTogNDguMjgsXG4gICAgICAgIDAuMDA1OiA1MC45OVxuICAgIH0sXG4gICAgMjk6IHtcbiAgICAgICAgMC45OTU6IDEzLjEyLFxuICAgICAgICAwLjk5OiAxNC4yNixcbiAgICAgICAgMC45NzU6IDE2LjA1LFxuICAgICAgICAwLjk1OiAxNy43MSxcbiAgICAgICAgMC45OiAxOS43NyxcbiAgICAgICAgMC41OiAyOC4zNCxcbiAgICAgICAgMC4xOiAzOS4wOSxcbiAgICAgICAgMC4wNTogNDIuNTYsXG4gICAgICAgIDAuMDI1OiA0NS43MixcbiAgICAgICAgMC4wMTogNDkuNTksXG4gICAgICAgIDAuMDA1OiA1Mi4zNFxuICAgIH0sXG4gICAgMzA6IHtcbiAgICAgICAgMC45OTU6IDEzLjc5LFxuICAgICAgICAwLjk5OiAxNC45NSxcbiAgICAgICAgMC45NzU6IDE2Ljc5LFxuICAgICAgICAwLjk1OiAxOC40OSxcbiAgICAgICAgMC45OiAyMC42LFxuICAgICAgICAwLjU6IDI5LjM0LFxuICAgICAgICAwLjE6IDQwLjI2LFxuICAgICAgICAwLjA1OiA0My43NyxcbiAgICAgICAgMC4wMjU6IDQ2Ljk4LFxuICAgICAgICAwLjAxOiA1MC44OSxcbiAgICAgICAgMC4wMDU6IDUzLjY3XG4gICAgfSxcbiAgICA0MDoge1xuICAgICAgICAwLjk5NTogMjAuNzEsXG4gICAgICAgIDAuOTk6IDIyLjE2LFxuICAgICAgICAwLjk3NTogMjQuNDMsXG4gICAgICAgIDAuOTU6IDI2LjUxLFxuICAgICAgICAwLjk6IDI5LjA1LFxuICAgICAgICAwLjU6IDM5LjM0LFxuICAgICAgICAwLjE6IDUxLjgxLFxuICAgICAgICAwLjA1OiA1NS43NixcbiAgICAgICAgMC4wMjU6IDU5LjM0LFxuICAgICAgICAwLjAxOiA2My42OSxcbiAgICAgICAgMC4wMDU6IDY2Ljc3XG4gICAgfSxcbiAgICA1MDoge1xuICAgICAgICAwLjk5NTogMjcuOTksXG4gICAgICAgIDAuOTk6IDI5LjcxLFxuICAgICAgICAwLjk3NTogMzIuMzYsXG4gICAgICAgIDAuOTU6IDM0Ljc2LFxuICAgICAgICAwLjk6IDM3LjY5LFxuICAgICAgICAwLjU6IDQ5LjMzLFxuICAgICAgICAwLjE6IDYzLjE3LFxuICAgICAgICAwLjA1OiA2Ny41LFxuICAgICAgICAwLjAyNTogNzEuNDIsXG4gICAgICAgIDAuMDE6IDc2LjE1LFxuICAgICAgICAwLjAwNTogNzkuNDlcbiAgICB9LFxuICAgIDYwOiB7XG4gICAgICAgIDAuOTk1OiAzNS41MyxcbiAgICAgICAgMC45OTogMzcuNDgsXG4gICAgICAgIDAuOTc1OiA0MC40OCxcbiAgICAgICAgMC45NTogNDMuMTksXG4gICAgICAgIDAuOTogNDYuNDYsXG4gICAgICAgIDAuNTogNTkuMzMsXG4gICAgICAgIDAuMTogNzQuNCxcbiAgICAgICAgMC4wNTogNzkuMDgsXG4gICAgICAgIDAuMDI1OiA4My4zLFxuICAgICAgICAwLjAxOiA4OC4zOCxcbiAgICAgICAgMC4wMDU6IDkxLjk1XG4gICAgfSxcbiAgICA3MDoge1xuICAgICAgICAwLjk5NTogNDMuMjgsXG4gICAgICAgIDAuOTk6IDQ1LjQ0LFxuICAgICAgICAwLjk3NTogNDguNzYsXG4gICAgICAgIDAuOTU6IDUxLjc0LFxuICAgICAgICAwLjk6IDU1LjMzLFxuICAgICAgICAwLjU6IDY5LjMzLFxuICAgICAgICAwLjE6IDg1LjUzLFxuICAgICAgICAwLjA1OiA5MC41MyxcbiAgICAgICAgMC4wMjU6IDk1LjAyLFxuICAgICAgICAwLjAxOiAxMDAuNDIsXG4gICAgICAgIDAuMDA1OiAxMDQuMjJcbiAgICB9LFxuICAgIDgwOiB7XG4gICAgICAgIDAuOTk1OiA1MS4xNyxcbiAgICAgICAgMC45OTogNTMuNTQsXG4gICAgICAgIDAuOTc1OiA1Ny4xNSxcbiAgICAgICAgMC45NTogNjAuMzksXG4gICAgICAgIDAuOTogNjQuMjgsXG4gICAgICAgIDAuNTogNzkuMzMsXG4gICAgICAgIDAuMTogOTYuNTgsXG4gICAgICAgIDAuMDU6IDEwMS44OCxcbiAgICAgICAgMC4wMjU6IDEwNi42MyxcbiAgICAgICAgMC4wMTogMTEyLjMzLFxuICAgICAgICAwLjAwNTogMTE2LjMyXG4gICAgfSxcbiAgICA5MDoge1xuICAgICAgICAwLjk5NTogNTkuMixcbiAgICAgICAgMC45OTogNjEuNzUsXG4gICAgICAgIDAuOTc1OiA2NS42NSxcbiAgICAgICAgMC45NTogNjkuMTMsXG4gICAgICAgIDAuOTogNzMuMjksXG4gICAgICAgIDAuNTogODkuMzMsXG4gICAgICAgIDAuMTogMTA3LjU3LFxuICAgICAgICAwLjA1OiAxMTMuMTQsXG4gICAgICAgIDAuMDI1OiAxMTguMTQsXG4gICAgICAgIDAuMDE6IDEyNC4xMixcbiAgICAgICAgMC4wMDU6IDEyOC4zXG4gICAgfSxcbiAgICAxMDA6IHtcbiAgICAgICAgMC45OTU6IDY3LjMzLFxuICAgICAgICAwLjk5OiA3MC4wNixcbiAgICAgICAgMC45NzU6IDc0LjIyLFxuICAgICAgICAwLjk1OiA3Ny45MyxcbiAgICAgICAgMC45OiA4Mi4zNixcbiAgICAgICAgMC41OiA5OS4zMyxcbiAgICAgICAgMC4xOiAxMTguNSxcbiAgICAgICAgMC4wNTogMTI0LjM0LFxuICAgICAgICAwLjAyNTogMTI5LjU2LFxuICAgICAgICAwLjAxOiAxMzUuODEsXG4gICAgICAgIDAuMDA1OiAxNDAuMTdcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSBbz4cyIChDaGktU3F1YXJlZCkgR29vZG5lc3Mtb2YtRml0IFRlc3RdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR29vZG5lc3Nfb2ZfZml0I1BlYXJzb24uMjdzX2NoaS1zcXVhcmVkX3Rlc3QpXG4gKiB1c2VzIGEgbWVhc3VyZSBvZiBnb29kbmVzcyBvZiBmaXQgd2hpY2ggaXMgdGhlIHN1bSBvZiBkaWZmZXJlbmNlcyBiZXR3ZWVuIG9ic2VydmVkIGFuZCBleHBlY3RlZCBvdXRjb21lIGZyZXF1ZW5jaWVzXG4gKiAodGhhdCBpcywgY291bnRzIG9mIG9ic2VydmF0aW9ucyksIGVhY2ggc3F1YXJlZCBhbmQgZGl2aWRlZCBieSB0aGUgbnVtYmVyIG9mIG9ic2VydmF0aW9ucyBleHBlY3RlZCBnaXZlbiB0aGVcbiAqIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uIFRoZSByZXN1bHRpbmcgz4cyIHN0YXRpc3RpYywgYGNoaVNxdWFyZWRgLCBjYW4gYmUgY29tcGFyZWQgdG8gdGhlIGNoaS1zcXVhcmVkIGRpc3RyaWJ1dGlvblxuICogdG8gZGV0ZXJtaW5lIHRoZSBnb29kbmVzcyBvZiBmaXQuIEluIG9yZGVyIHRvIGRldGVybWluZSB0aGUgZGVncmVlcyBvZiBmcmVlZG9tIG9mIHRoZSBjaGktc3F1YXJlZCBkaXN0cmlidXRpb24sIG9uZVxuICogdGFrZXMgdGhlIHRvdGFsIG51bWJlciBvZiBvYnNlcnZlZCBmcmVxdWVuY2llcyBhbmQgc3VidHJhY3RzIHRoZSBudW1iZXIgb2YgZXN0aW1hdGVkIHBhcmFtZXRlcnMuIFRoZSB0ZXN0IHN0YXRpc3RpY1xuICogZm9sbG93cywgYXBwcm94aW1hdGVseSwgYSBjaGktc3F1YXJlIGRpc3RyaWJ1dGlvbiB3aXRoIChrIOKIkiBjKSBkZWdyZWVzIG9mIGZyZWVkb20gd2hlcmUgYGtgIGlzIHRoZSBudW1iZXIgb2Ygbm9uLWVtcHR5XG4gKiBjZWxscyBhbmQgYGNgIGlzIHRoZSBudW1iZXIgb2YgZXN0aW1hdGVkIHBhcmFtZXRlcnMgZm9yIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXN0cmlidXRpb25UeXBlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcG9pbnQgaW4gYSBkaXN0cmlidXRpb246XG4gKiBmb3IgaW5zdGFuY2UsIGJpbm9taWFsLCBiZXJub3VsbGksIG9yIHBvaXNzb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaWduaWZpY2FuY2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNoaSBzcXVhcmVkIGdvb2RuZXNzIG9mIGZpdFxuICogQGV4YW1wbGVcbiAqIC8vIERhdGEgZnJvbSBQb2lzc29uIGdvb2RuZXNzLW9mLWZpdCBleGFtcGxlIDEwLTE5IGluIFdpbGxpYW0gVy4gSGluZXMgJiBEb3VnbGFzIEMuIE1vbnRnb21lcnksXG4gKiAvLyBcIlByb2JhYmlsaXR5IGFuZCBTdGF0aXN0aWNzIGluIEVuZ2luZWVyaW5nIGFuZCBNYW5hZ2VtZW50IFNjaWVuY2VcIiwgV2lsZXkgKDE5ODApLlxuICogdmFyIGRhdGExMDE5ID0gW1xuICogICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gKiAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAqICAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICogICAgIDIsIDIsIDIsIDIsIDIsIDIsIDIsIDIsIDIsXG4gKiAgICAgMywgMywgMywgM1xuICogXTtcbiAqIHNzLmNoaVNxdWFyZWRHb29kbmVzc09mRml0KGRhdGExMDE5LCBzcy5wb2lzc29uRGlzdHJpYnV0aW9uLCAwLjA1KTsgLy89IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNoaVNxdWFyZWRHb29kbmVzc09mRml0KGRhdGEsIGRpc3RyaWJ1dGlvblR5cGUsIHNpZ25pZmljYW5jZSkge1xuICAgIC8vIEVzdGltYXRlIGZyb20gdGhlIHNhbXBsZSBkYXRhLCBhIHdlaWdodGVkIG1lYW4uXG4gICAgdmFyIGlucHV0TWVhbiA9IG1lYW4oZGF0YSk7XG4gICAgLy8gQ2FsY3VsYXRlZCB2YWx1ZSBvZiB0aGUgz4cyIHN0YXRpc3RpYy5cbiAgICB2YXIgY2hpU3F1YXJlZCA9IDA7XG4gICAgLy8gTnVtYmVyIG9mIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24gcGFyYW1ldGVycyBlc3RpbWF0ZWQsIGV4cGVjdGVkIHRvIGJlIHN1cHBsaWVkIGluIHRoZSBkaXN0cmlidXRpb24gdGVzdC5cbiAgICAvLyBMb3NlIG9uZSBkZWdyZWUgb2YgZnJlZWRvbSBmb3IgZXN0aW1hdGluZyBgbGFtYmRhYCBmcm9tIHRoZSBzYW1wbGUgZGF0YS5cbiAgICB2YXIgYyA9IDE7XG4gICAgLy8gVGhlIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgLy8gR2VuZXJhdGUgdGhlIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgdmFyIGh5cG90aGVzaXplZERpc3RyaWJ1dGlvbiA9IGRpc3RyaWJ1dGlvblR5cGUoaW5wdXRNZWFuKTtcbiAgICB2YXIgb2JzZXJ2ZWRGcmVxdWVuY2llcyA9IFtdO1xuICAgIHZhciBleHBlY3RlZEZyZXF1ZW5jaWVzID0gW107XG5cbiAgICAvLyBDcmVhdGUgYW4gYXJyYXkgaG9sZGluZyBhIGhpc3RvZ3JhbSBmcm9tIHRoZSBzYW1wbGUgZGF0YSwgb2ZcbiAgICAvLyB0aGUgZm9ybSBgeyB2YWx1ZTogbnVtYmVyT2ZPY3VycmVuY2VzIH1gXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChvYnNlcnZlZEZyZXF1ZW5jaWVzW2RhdGFbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbZGF0YVtpXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVkRnJlcXVlbmNpZXNbZGF0YVtpXV0rKztcbiAgICB9XG5cbiAgICAvLyBUaGUgaGlzdG9ncmFtIHdlIGNyZWF0ZWQgbWlnaHQgYmUgc3BhcnNlIC0gdGhlcmUgbWlnaHQgYmUgZ2Fwc1xuICAgIC8vIGJldHdlZW4gdmFsdWVzLiBTbyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGhpc3RvZ3JhbSwgbWFraW5nXG4gICAgLy8gc3VyZSB0aGF0IGluc3RlYWQgb2YgdW5kZWZpbmVkLCBnYXBzIGhhdmUgMCB2YWx1ZXMuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb2JzZXJ2ZWRGcmVxdWVuY2llcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIGlmIChvYnNlcnZlZEZyZXF1ZW5jaWVzW2kkMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZWRGcmVxdWVuY2llc1tpJDFdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbiBhcnJheSBob2xkaW5nIGEgaGlzdG9ncmFtIG9mIGV4cGVjdGVkIGRhdGEgZ2l2ZW4gdGhlXG4gICAgLy8gc2FtcGxlIHNpemUgYW5kIGh5cG90aGVzaXplZCBkaXN0cmlidXRpb24uXG4gICAgZm9yICh2YXIgayBpbiBoeXBvdGhlc2l6ZWREaXN0cmlidXRpb24pIHtcbiAgICAgICAgaWYgKGsgaW4gb2JzZXJ2ZWRGcmVxdWVuY2llcykge1xuICAgICAgICAgICAgZXhwZWN0ZWRGcmVxdWVuY2llc1sra10gPSBoeXBvdGhlc2l6ZWREaXN0cmlidXRpb25ba10gKiBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdvcmtpbmcgYmFja3dhcmQgdGhyb3VnaCB0aGUgZXhwZWN0ZWQgZnJlcXVlbmNpZXMsIGNvbGxhcHNlIGNsYXNzZXNcbiAgICAvLyBpZiBsZXNzIHRoYW4gdGhyZWUgb2JzZXJ2YXRpb25zIGFyZSBleHBlY3RlZCBmb3IgYSBjbGFzcy5cbiAgICAvLyBUaGlzIHRyYW5zZm9ybWF0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIG9ic2VydmVkIGZyZXF1ZW5jaWVzIGFzIHdlbGwuXG4gICAgZm9yICh2YXIgayQxID0gZXhwZWN0ZWRGcmVxdWVuY2llcy5sZW5ndGggLSAxOyBrJDEgPj0gMDsgayQxLS0pIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkRnJlcXVlbmNpZXNbayQxXSA8IDMpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRnJlcXVlbmNpZXNbayQxIC0gMV0gKz0gZXhwZWN0ZWRGcmVxdWVuY2llc1trJDFdO1xuICAgICAgICAgICAgZXhwZWN0ZWRGcmVxdWVuY2llcy5wb3AoKTtcblxuICAgICAgICAgICAgb2JzZXJ2ZWRGcmVxdWVuY2llc1trJDEgLSAxXSArPSBvYnNlcnZlZEZyZXF1ZW5jaWVzW2skMV07XG4gICAgICAgICAgICBvYnNlcnZlZEZyZXF1ZW5jaWVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzcXVhcmVkIGRpZmZlcmVuY2VzIGJldHdlZW4gb2JzZXJ2ZWQgJiBleHBlY3RlZFxuICAgIC8vIGZyZXF1ZW5jaWVzLCBhY2N1bXVsYXRpbmcgdGhlIGBjaGlTcXVhcmVkYCBzdGF0aXN0aWMuXG4gICAgZm9yICh2YXIgayQyID0gMDsgayQyIDwgb2JzZXJ2ZWRGcmVxdWVuY2llcy5sZW5ndGg7IGskMisrKSB7XG4gICAgICAgIGNoaVNxdWFyZWQgKz1cbiAgICAgICAgICAgIE1hdGgucG93KG9ic2VydmVkRnJlcXVlbmNpZXNbayQyXSAtIGV4cGVjdGVkRnJlcXVlbmNpZXNbayQyXSwgMikgL1xuICAgICAgICAgICAgZXhwZWN0ZWRGcmVxdWVuY2llc1trJDJdO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBkZWdyZWVzIG9mIGZyZWVkb20gZm9yIHRoaXMgdGVzdCBhbmQgbG9vayBpdCB1cCBpbiB0aGVcbiAgICAvLyBgY2hpU3F1YXJlZERpc3RyaWJ1dGlvblRhYmxlYCBpbiBvcmRlciB0b1xuICAgIC8vIGFjY2VwdCBvciByZWplY3QgdGhlIGdvb2RuZXNzLW9mLWZpdCBvZiB0aGUgaHlwb3RoZXNpemVkIGRpc3RyaWJ1dGlvbi5cbiAgICAvLyBEZWdyZWVzIG9mIGZyZWVkb20sIGNhbGN1bGF0ZWQgYXMgKG51bWJlciBvZiBjbGFzcyBpbnRlcnZhbHMgLVxuICAgIC8vIG51bWJlciBvZiBoeXBvdGhlc2l6ZWQgZGlzdHJpYnV0aW9uIHBhcmFtZXRlcnMgZXN0aW1hdGVkIC0gMSlcbiAgICB2YXIgZGVncmVlc09mRnJlZWRvbSA9IG9ic2VydmVkRnJlcXVlbmNpZXMubGVuZ3RoIC0gYyAtIDE7XG4gICAgcmV0dXJuIChcbiAgICAgICAgY2hpU3F1YXJlZERpc3RyaWJ1dGlvblRhYmxlW2RlZ3JlZXNPZkZyZWVkb21dW3NpZ25pZmljYW5jZV0gPCBjaGlTcXVhcmVkXG4gICAgKTtcbn1cblxudmFyIFNRUlRfMlBJJDEgPSBNYXRoLnNxcnQoMiAqIE1hdGguUEkpO1xuXG4vKipcbiAqIFtXZWxsLWtub3duIGtlcm5lbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlcm5lbF8oc3RhdGlzdGljcykjS2VybmVsX2Z1bmN0aW9uc19pbl9jb21tb25fdXNlKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGtlcm5lbHMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIGdhdXNzaWFuIGtlcm5lbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdhdXNzaWFuOiBmdW5jdGlvbiAodSkge1xuICAgICAgICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIHUgKiB1KSAvIFNRUlRfMlBJJDE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXZWxsIGtub3duIGJhbmR3aWR0aCBzZWxlY3Rpb24gbWV0aG9kc1xuICogQHByaXZhdGVcbiAqL1xudmFyIGJhbmR3aWR0aE1ldGhvZHMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIFtcIm5vcm1hbCByZWZlcmVuY2UgZGlzdHJpYnV0aW9uXCJcbiAgICAgKiBydWxlLW9mLXRodW1iXShodHRwczovL3N0YXQuZXRoei5jaC9SLW1hbnVhbC9SLWRldmVsL2xpYnJhcnkvTUFTUy9odG1sL2JhbmR3aWR0aC5ucmQuaHRtbCksXG4gICAgICogYSBjb21tb25seSB1c2VkIHZlcnNpb24gb2YgW1NpbHZlcm1hbidzXG4gICAgICogcnVsZS1vZi10aHVtYl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2VybmVsX2RlbnNpdHlfZXN0aW1hdGlvbiNBX3J1bGUtb2YtdGh1bWJfYmFuZHdpZHRoX2VzdGltYXRvcikuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBucmQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBzID0gc2FtcGxlU3RhbmRhcmREZXZpYXRpb24oeCk7XG4gICAgICAgIHZhciBpcXIgPSBpbnRlcnF1YXJ0aWxlUmFuZ2UoeCk7XG4gICAgICAgIGlmICh0eXBlb2YgaXFyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzID0gTWF0aC5taW4ocywgaXFyIC8gMS4zNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDEuMDYgKiBzICogTWF0aC5wb3coeC5sZW5ndGgsIC0wLjIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogW0tlcm5lbCBkZW5zaXR5IGVzdGltYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlcm5lbF9kZW5zaXR5X2VzdGltYXRpb24pXG4gKiBpcyBhIHVzZWZ1bCB0b29sIGZvciwgYW1vbmcgb3RoZXIgdGhpbmdzLCBlc3RpbWF0aW5nIHRoZSBzaGFwZSBvZiB0aGVcbiAqIHVuZGVybHlpbmcgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIGZyb20gYSBzYW1wbGUuXG4gKlxuICogQG5hbWUga2VybmVsRGVuc2l0eUVzdGltYXRpb25cbiAqIEBwYXJhbSBYIHNhbXBsZSB2YWx1ZXNcbiAqIEBwYXJhbSBrZXJuZWwgVGhlIGtlcm5lbCBmdW5jdGlvbiB0byB1c2UuIElmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IHNob3VsZCByZXR1cm4gbm9uLW5lZ2F0aXZlIHZhbHVlcyBhbmQgaW50ZWdyYXRlIHRvIDEuIERlZmF1bHRzIHRvICdnYXVzc2lhbicuXG4gKiBAcGFyYW0gYmFuZHdpZHRoTWV0aG9kIFRoZSBcImJhbmR3aWR0aCBzZWxlY3Rpb25cIiBtZXRob2QgdG8gdXNlLCBvciBhIGZpeGVkIGJhbmR3aWR0aCB2YWx1ZS4gRGVmYXVsdHMgdG8gXCJucmRcIiwgdGhlIGNvbW1vbmx5LXVzZWQgW1wibm9ybWFsIHJlZmVyZW5jZSBkaXN0cmlidXRpb25cIiBydWxlLW9mLXRodW1iXShodHRwczovL3N0YXQuZXRoei5jaC9SLW1hbnVhbC9SLWRldmVsL2xpYnJhcnkvTUFTUy9odG1sL2JhbmR3aWR0aC5ucmQuaHRtbCkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEFuIGVzdGltYXRlZCBbcHJvYmFiaWxpdHkgZGVuc2l0eSBmdW5jdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvYmFiaWxpdHlfZGVuc2l0eV9mdW5jdGlvbikgZm9yIHRoZSBnaXZlbiBzYW1wbGUuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBydW5zIGluIGBPKFgubGVuZ3RoKWAuXG4gKi9cbmZ1bmN0aW9uIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uKFgsIGtlcm5lbCwgYmFuZHdpZHRoTWV0aG9kKSB7XG4gICAgdmFyIGtlcm5lbEZuO1xuICAgIGlmIChrZXJuZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWxGbiA9IGtlcm5lbHMuZ2F1c3NpYW47XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2VybmVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICgha2VybmVsc1trZXJuZWxdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24ga2VybmVsIFwiJyArIGtlcm5lbCArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGtlcm5lbEZuID0ga2VybmVsc1trZXJuZWxdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtlcm5lbEZuID0ga2VybmVsO1xuICAgIH1cblxuICAgIHZhciBiYW5kd2lkdGg7XG4gICAgaWYgKHR5cGVvZiBiYW5kd2lkdGhNZXRob2QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYmFuZHdpZHRoID0gYmFuZHdpZHRoTWV0aG9kcy5ucmQoWCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYmFuZHdpZHRoTWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghYmFuZHdpZHRoTWV0aG9kc1tiYW5kd2lkdGhNZXRob2RdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1Vua25vd24gYmFuZHdpZHRoIG1ldGhvZCBcIicgKyBiYW5kd2lkdGhNZXRob2QgKyAnXCInXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJhbmR3aWR0aCA9IGJhbmR3aWR0aE1ldGhvZHNbYmFuZHdpZHRoTWV0aG9kXShYKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBiYW5kd2lkdGggPSBiYW5kd2lkdGhNZXRob2Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBYLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0ga2VybmVsRm4oKHggLSBYW2ldKSAvIGJhbmR3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSAvIGJhbmR3aWR0aCAvIFgubGVuZ3RoO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIFtaLVNjb3JlLCBvciBTdGFuZGFyZCBTY29yZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9zY29yZSkuXG4gKlxuICogVGhlIHN0YW5kYXJkIHNjb3JlIGlzIHRoZSBudW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyBhbiBvYnNlcnZhdGlvblxuICogb3IgZGF0dW0gaXMgYWJvdmUgb3IgYmVsb3cgdGhlIG1lYW4uIFRodXMsIGEgcG9zaXRpdmUgc3RhbmRhcmQgc2NvcmVcbiAqIHJlcHJlc2VudHMgYSBkYXR1bSBhYm92ZSB0aGUgbWVhbiwgd2hpbGUgYSBuZWdhdGl2ZSBzdGFuZGFyZCBzY29yZVxuICogcmVwcmVzZW50cyBhIGRhdHVtIGJlbG93IHRoZSBtZWFuLiBJdCBpcyBhIGRpbWVuc2lvbmxlc3MgcXVhbnRpdHlcbiAqIG9idGFpbmVkIGJ5IHN1YnRyYWN0aW5nIHRoZSBwb3B1bGF0aW9uIG1lYW4gZnJvbSBhbiBpbmRpdmlkdWFsIHJhd1xuICogc2NvcmUgYW5kIHRoZW4gZGl2aWRpbmcgdGhlIGRpZmZlcmVuY2UgYnkgdGhlIHBvcHVsYXRpb24gc3RhbmRhcmRcbiAqIGRldmlhdGlvbi5cbiAqXG4gKiBUaGUgei1zY29yZSBpcyBvbmx5IGRlZmluZWQgaWYgb25lIGtub3dzIHRoZSBwb3B1bGF0aW9uIHBhcmFtZXRlcnM7XG4gKiBpZiBvbmUgb25seSBoYXMgYSBzYW1wbGUgc2V0LCB0aGVuIHRoZSBhbmFsb2dvdXMgY29tcHV0YXRpb24gd2l0aFxuICogc2FtcGxlIG1lYW4gYW5kIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24geWllbGRzIHRoZVxuICogU3R1ZGVudCdzIHQtc3RhdGlzdGljLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0gbWVhblxuICogQHBhcmFtIHtudW1iZXJ9IHN0YW5kYXJkRGV2aWF0aW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHogc2NvcmVcbiAqIEBleGFtcGxlXG4gKiB6U2NvcmUoNzgsIDgwLCA1KTsgLy8gPT4gLTAuNFxuICovXG5mdW5jdGlvbiB6U2NvcmUoeCwgbWVhbiwgc3RhbmRhcmREZXZpYXRpb24pIHtcbiAgICByZXR1cm4gKHggLSBtZWFuKSAvIHN0YW5kYXJkRGV2aWF0aW9uO1xufVxuXG52YXIgU1FSVF8yUEkgPSBNYXRoLnNxcnQoMiAqIE1hdGguUEkpO1xuXG5mdW5jdGlvbiBjdW11bGF0aXZlRGlzdHJpYnV0aW9uKHopIHtcbiAgICB2YXIgc3VtID0gejtcbiAgICB2YXIgdG1wID0gejtcblxuICAgIC8vIDE1IGl0ZXJhdGlvbnMgYXJlIGVub3VnaCBmb3IgNC1kaWdpdCBwcmVjaXNpb25cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgICAgdG1wICo9ICh6ICogeikgLyAoMiAqIGkgKyAxKTtcbiAgICAgICAgc3VtICs9IHRtcDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICAgTWF0aC5yb3VuZCgoMC41ICsgKHN1bSAvIFNRUlRfMlBJKSAqIE1hdGguZXhwKCgteiAqIHopIC8gMikpICogMWU0KSAvXG4gICAgICAgIDFlNFxuICAgICk7XG59XG5cbi8qKlxuICogQSBzdGFuZGFyZCBub3JtYWwgdGFibGUsIGFsc28gY2FsbGVkIHRoZSB1bml0IG5vcm1hbCB0YWJsZSBvciBaIHRhYmxlLFxuICogaXMgYSBtYXRoZW1hdGljYWwgdGFibGUgZm9yIHRoZSB2YWx1ZXMgb2YgzqYgKHBoaSksIHdoaWNoIGFyZSB0aGUgdmFsdWVzIG9mXG4gKiB0aGUgW2N1bXVsYXRpdmUgZGlzdHJpYnV0aW9uIGZ1bmN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ob3JtYWxfZGlzdHJpYnV0aW9uI0N1bXVsYXRpdmVfZGlzdHJpYnV0aW9uX2Z1bmN0aW9uKVxuICogb2YgdGhlIG5vcm1hbCBkaXN0cmlidXRpb24uIEl0IGlzIHVzZWQgdG8gZmluZCB0aGUgcHJvYmFiaWxpdHkgdGhhdCBhXG4gKiBzdGF0aXN0aWMgaXMgb2JzZXJ2ZWQgYmVsb3csIGFib3ZlLCBvciBiZXR3ZWVuIHZhbHVlcyBvbiB0aGUgc3RhbmRhcmRcbiAqIG5vcm1hbCBkaXN0cmlidXRpb24sIGFuZCBieSBleHRlbnNpb24sIGFueSBub3JtYWwgZGlzdHJpYnV0aW9uLlxuICovXG52YXIgc3RhbmRhcmROb3JtYWxUYWJsZSA9IFtdO1xuXG5mb3IgKHZhciB6ID0gMDsgeiA8PSAzLjA5OyB6ICs9IDAuMDEpIHtcbiAgICBzdGFuZGFyZE5vcm1hbFRhYmxlLnB1c2goY3VtdWxhdGl2ZURpc3RyaWJ1dGlvbih6KSk7XG59XG5cbi8qKlxuICogKipbQ3VtdWxhdGl2ZSBTdGFuZGFyZCBOb3JtYWwgUHJvYmFiaWxpdHldKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfbm9ybWFsX3RhYmxlKSoqXG4gKlxuICogU2luY2UgcHJvYmFiaWxpdHkgdGFibGVzIGNhbm5vdCBiZVxuICogcHJpbnRlZCBmb3IgZXZlcnkgbm9ybWFsIGRpc3RyaWJ1dGlvbiwgYXMgdGhlcmUgYXJlIGFuIGluZmluaXRlIHZhcmlldHlcbiAqIG9mIG5vcm1hbCBkaXN0cmlidXRpb25zLCBpdCBpcyBjb21tb24gcHJhY3RpY2UgdG8gY29udmVydCBhIG5vcm1hbCB0byBhXG4gKiBzdGFuZGFyZCBub3JtYWwgYW5kIHRoZW4gdXNlIHRoZSBzdGFuZGFyZCBub3JtYWwgdGFibGUgdG8gZmluZCBwcm9iYWJpbGl0aWVzLlxuICpcbiAqIFlvdSBjYW4gdXNlIGAuNSArIC41ICogZXJyb3JGdW5jdGlvbih4IC8gTWF0aC5zcXJ0KDIpKWAgdG8gY2FsY3VsYXRlIHRoZSBwcm9iYWJpbGl0eVxuICogaW5zdGVhZCBvZiBsb29raW5nIGl0IHVwIGluIGEgdGFibGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGN1bXVsYXRpdmUgc3RhbmRhcmQgbm9ybWFsIHByb2JhYmlsaXR5XG4gKi9cbmZ1bmN0aW9uIGN1bXVsYXRpdmVTdGROb3JtYWxQcm9iYWJpbGl0eSh6KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHZhbHVlLlxuICAgIHZhciBhYnNaID0gTWF0aC5hYnMoeik7XG4gICAgLy8gRWFjaCByb3cgYmVnaW5zIHdpdGggYSBkaWZmZXJlbnRcbiAgICAvLyBzaWduaWZpY2FudCBkaWdpdDogMC41LCAwLjYsIDAuNywgYW5kIHNvIG9uLiBFYWNoIHZhbHVlIGluIHRoZSB0YWJsZVxuICAgIC8vIGNvcnJlc3BvbmRzIHRvIGEgcmFuZ2Ugb2YgMC4wMSBpbiB0aGUgaW5wdXQgdmFsdWVzLCBzbyB0aGUgdmFsdWUgaXNcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IDEwMC5cbiAgICB2YXIgaW5kZXggPSBNYXRoLm1pbihcbiAgICAgICAgTWF0aC5yb3VuZChhYnNaICogMTAwKSxcbiAgICAgICAgc3RhbmRhcmROb3JtYWxUYWJsZS5sZW5ndGggLSAxXG4gICAgKTtcblxuICAgIC8vIFRoZSBpbmRleCB3ZSBjYWxjdWxhdGUgbXVzdCBiZSBpbiB0aGUgdGFibGUgYXMgYSBwb3NpdGl2ZSB2YWx1ZSxcbiAgICAvLyBidXQgd2Ugc3RpbGwgcGF5IGF0dGVudGlvbiB0byB3aGV0aGVyIHRoZSBpbnB1dCBpcyBwb3NpdGl2ZVxuICAgIC8vIG9yIG5lZ2F0aXZlLCBhbmQgZmxpcCB0aGUgb3V0cHV0IHZhbHVlIGFzIGEgbGFzdCBzdGVwLlxuICAgIGlmICh6ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YW5kYXJkTm9ybWFsVGFibGVbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGR1ZSB0byBmbG9hdGluZy1wb2ludCBhcml0aG1ldGljLCB2YWx1ZXMgaW4gdGhlIHRhYmxlIHdpdGhcbiAgICAgICAgLy8gNCBzaWduaWZpY2FudCBmaWd1cmVzIGNhbiBuZXZlcnRoZWxlc3MgZW5kIHVwIGFzIHJlcGVhdGluZ1xuICAgICAgICAvLyBmcmFjdGlvbnMgd2hlbiB0aGV5J3JlIGNvbXB1dGVkIGhlcmUuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCgxIC0gc3RhbmRhcmROb3JtYWxUYWJsZVtpbmRleF0pICogMWU0KSAvIDFlNDtcbiAgICB9XG59XG5cbi8qKlxuICogKipbTG9naXN0aWMgQ3VtdWxhdGl2ZSBEaXN0cmlidXRpb24gRnVuY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvZ2lzdGljX2Rpc3RyaWJ1dGlvbikqKlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjdW11bGF0aXZlIHN0YW5kYXJkIGxvZ2lzdGljIHByb2JhYmlsaXR5XG4gKi9cbmZ1bmN0aW9uIGN1bXVsYXRpdmVTdGRMb2dpc3RpY1Byb2JhYmlsaXR5KHgpIHtcbiAgICByZXR1cm4gMSAvIChNYXRoLmV4cCgteCkgKyAxKTtcbn1cblxuLyoqXG4gKiAqKltHYXVzc2lhbiBlcnJvciBmdW5jdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcnJvcl9mdW5jdGlvbikqKlxuICpcbiAqIFRoZSBgZXJyb3JGdW5jdGlvbih4LyhzZCAqIE1hdGguc3FydCgyKSkpYCBpcyB0aGUgcHJvYmFiaWxpdHkgdGhhdCBhIHZhbHVlIGluIGFcbiAqIG5vcm1hbCBkaXN0cmlidXRpb24gd2l0aCBzdGFuZGFyZCBkZXZpYXRpb24gc2QgaXMgd2l0aGluIHggb2YgdGhlIG1lYW4uXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbnVtZXJpY2FsIGFwcHJveGltYXRpb24gdG8gdGhlIGV4YWN0IHZhbHVlLlxuICogSXQgdXNlcyBIb3JuZXIncyBtZXRob2QgdG8gZXZhbHVhdGUgdGhlIHBvbHlub21pYWwgb2Ygz4QgKHRhdSkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn0gZXJyb3IgZXN0aW1hdGlvblxuICogQGV4YW1wbGVcbiAqIGVycm9yRnVuY3Rpb24oMSkudG9GaXhlZCgyKTsgLy8gPT4gJzAuODQnXG4gKi9cbmZ1bmN0aW9uIGVycm9yRnVuY3Rpb24oeCkge1xuICAgIHZhciB0ID0gMSAvICgxICsgMC41ICogTWF0aC5hYnMoeCkpO1xuICAgIHZhciB0YXUgPVxuICAgICAgICB0ICpcbiAgICAgICAgTWF0aC5leHAoXG4gICAgICAgICAgICAteCAqIHggK1xuICAgICAgICAgICAgICAgICgoKCgoKCgoMC4xNzA4NzI3NyAqIHQgLSAwLjgyMjE1MjIzKSAqIHQgKyAxLjQ4ODUxNTg3KSAqIHQgLVxuICAgICAgICAgICAgICAgICAgICAxLjEzNTIwMzk4KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAwLjI3ODg2ODA3KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgLVxuICAgICAgICAgICAgICAgICAgICAwLjE4NjI4ODA2KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAwLjA5Njc4NDE4KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAwLjM3NDA5MTk2KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgK1xuICAgICAgICAgICAgICAgICAgICAxLjAwMDAyMzY4KSAqXG4gICAgICAgICAgICAgICAgICAgIHQgLVxuICAgICAgICAgICAgICAgIDEuMjY1NTEyMjNcbiAgICAgICAgKTtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiAxIC0gdGF1O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0YXUgLSAxO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgSW52ZXJzZSBbR2F1c3NpYW4gZXJyb3IgZnVuY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJyb3JfZnVuY3Rpb24pXG4gKiByZXR1cm5zIGEgbnVtZXJpY2FsIGFwcHJveGltYXRpb24gdG8gdGhlIHZhbHVlIHRoYXQgd291bGQgaGF2ZSBjYXVzZWRcbiAqIGBlcnJvckZ1bmN0aW9uKClgIHRvIHJldHVybiB4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHZhbHVlIG9mIGVycm9yIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBlc3RpbWF0ZWQgaW52ZXJ0ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZUVycm9yRnVuY3Rpb24oeCkge1xuICAgIHZhciBhID0gKDggKiAoTWF0aC5QSSAtIDMpKSAvICgzICogTWF0aC5QSSAqICg0IC0gTWF0aC5QSSkpO1xuXG4gICAgdmFyIGludiA9IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3coMiAvIChNYXRoLlBJICogYSkgKyBNYXRoLmxvZygxIC0geCAqIHgpIC8gMiwgMikgLVxuICAgICAgICAgICAgICAgIE1hdGgubG9nKDEgLSB4ICogeCkgLyBhXG4gICAgICAgICkgLVxuICAgICAgICAgICAgKDIgLyAoTWF0aC5QSSAqIGEpICsgTWF0aC5sb2coMSAtIHggKiB4KSAvIDIpXG4gICAgKTtcblxuICAgIGlmICh4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGludjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLWludjtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIFtQcm9iaXRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvYml0KVxuICogaXMgdGhlIGludmVyc2Ugb2YgY3VtdWxhdGl2ZVN0ZE5vcm1hbFByb2JhYmlsaXR5KCksXG4gKiBhbmQgaXMgYWxzbyBrbm93biBhcyB0aGUgbm9ybWFsIHF1YW50aWxlIGZ1bmN0aW9uLlxuICpcbiAqIEl0IHJldHVybnMgdGhlIG51bWJlciBvZiBzdGFuZGFyZCBkZXZpYXRpb25zIGZyb20gdGhlIG1lYW5cbiAqIHdoZXJlIHRoZSBwJ3RoIHF1YW50aWxlIG9mIHZhbHVlcyBjYW4gYmUgZm91bmQgaW4gYSBub3JtYWwgZGlzdHJpYnV0aW9uLlxuICogU28sIGZvciBleGFtcGxlLCBwcm9iaXQoMC41ICsgMC42ODI3LzIpIOKJiCAxIGJlY2F1c2UgNjguMjclIG9mIHZhbHVlcyBhcmVcbiAqIG5vcm1hbGx5IGZvdW5kIHdpdGhpbiAxIHN0YW5kYXJkIGRldmlhdGlvbiBhYm92ZSBvciBiZWxvdyB0aGUgbWVhbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcFxuICogQHJldHVybnMge251bWJlcn0gcHJvYml0XG4gKi9cbmZ1bmN0aW9uIHByb2JpdChwKSB7XG4gICAgaWYgKHAgPT09IDApIHtcbiAgICAgICAgcCA9IGVwc2lsb247XG4gICAgfSBlbHNlIGlmIChwID49IDEpIHtcbiAgICAgICAgcCA9IDEgLSBlcHNpbG9uO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KDIpICogaW52ZXJzZUVycm9yRnVuY3Rpb24oMiAqIHAgLSAxKTtcbn1cblxuLyoqXG4gKiBUaGUgW0xvZ2l0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dpdClcbiAqIGlzIHRoZSBpbnZlcnNlIG9mIGN1bXVsYXRpdmVTdGRMb2dpc3RpY1Byb2JhYmlsaXR5LFxuICogYW5kIGlzIGFsc28ga25vd24gYXMgdGhlIGxvZ2lzdGljIHF1YW50aWxlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBsb2dpdFxuICovXG5mdW5jdGlvbiBsb2dpdChwKSB7XG4gICAgaWYgKHAgPD0gMCB8fCBwID49IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicCBtdXN0IGJlIHN0cmljdGx5IGJldHdlZW4gemVybyBhbmQgb25lXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5sb2cocCAvICgxIC0gcCkpO1xufVxuXG4vKipcbiAqIENvbmR1Y3RzIGEgW3Blcm11dGF0aW9uIHRlc3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jlc2FtcGxpbmdfKHN0YXRpc3RpY3MpI1Blcm11dGF0aW9uX3Rlc3RzKVxuICogdG8gZGV0ZXJtaW5lIGlmIHR3byBkYXRhIHNldHMgYXJlICpzaWduaWZpY2FudGx5KiBkaWZmZXJlbnQgZnJvbSBlYWNoIG90aGVyLCB1c2luZ1xuICogdGhlIGRpZmZlcmVuY2Ugb2YgbWVhbnMgYmV0d2VlbiB0aGUgZ3JvdXBzIGFzIHRoZSB0ZXN0IHN0YXRpc3RpYy5cbiAqIFRoZSBmdW5jdGlvbiBhbGxvd3MgZm9yIHRoZSBmb2xsb3dpbmcgaHlwb3RoZXNlczpcbiAqIC0gdHdvX3RhaWwgPSBOdWxsIGh5cG90aGVzaXM6IHRoZSB0d28gZGlzdHJpYnV0aW9ucyBhcmUgZXF1YWwuXG4gKiAtIGdyZWF0ZXIgPSBOdWxsIGh5cG90aGVzaXM6IG9ic2VydmF0aW9ucyBmcm9tIHNhbXBsZVggdGVuZCB0byBiZSBzbWFsbGVyIHRoYW4gdGhvc2UgZnJvbSBzYW1wbGVZLlxuICogLSBsZXNzID0gTnVsbCBoeXBvdGhlc2lzOiBvYnNlcnZhdGlvbnMgZnJvbSBzYW1wbGVYIHRlbmQgdG8gYmUgZ3JlYXRlciB0aGFuIHRob3NlIGZyb20gc2FtcGxlWS5cbiAqIFtMZWFybiBtb3JlIGFib3V0IG9uZS10YWlsIHZzIHR3by10YWlsIHRlc3RzLl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT25lLV9hbmRfdHdvLXRhaWxlZF90ZXN0cylcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNhbXBsZVggZmlyc3QgZGF0YXNldCAoZS5nLiB0cmVhdG1lbnQgZGF0YSlcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2FtcGxlWSBzZWNvbmQgZGF0YXNldCAoZS5nLiBjb250cm9sIGRhdGEpXG4gKiBAcGFyYW0ge3N0cmluZ30gYWx0ZXJuYXRpdmUgYWx0ZXJuYXRpdmUgaHlwb3RoZXNpcywgZWl0aGVyICd0d29fc2lkZWQnIChkZWZhdWx0KSwgJ2dyZWF0ZXInLCBvciAnbGVzcydcbiAqIEBwYXJhbSB7bnVtYmVyfSBrIG51bWJlciBvZiB2YWx1ZXMgaW4gcGVybXV0YXRpb24gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JhbmRvbVNvdXJjZT1NYXRoLnJhbmRvbV0gYW4gb3B0aW9uYWwgZW50cm9weSBzb3VyY2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHAtdmFsdWUgVGhlIHByb2JhYmlsaXR5IG9mIG9ic2VydmluZyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGdyb3VwcyAoYXMgb3IgbW9yZSBleHRyZW1lIHRoYW4gd2hhdCB3ZSBkaWQpLCBhc3N1bWluZyB0aGUgbnVsbCBoeXBvdGhlc2lzLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udHJvbCA9IFsyLCA1LCAzLCA2LCA3LCAyLCA1XTtcbiAqIHZhciB0cmVhdG1lbnQgPSBbMjAsIDUsIDEzLCAxMiwgNywgMiwgMl07XG4gKiBwZXJtdXRhdGlvblRlc3QoY29udHJvbCwgdHJlYXRtZW50KTsgLy8gfjAuMTMyNFxuICovXG5mdW5jdGlvbiBwZXJtdXRhdGlvblRlc3Qoc2FtcGxlWCwgc2FtcGxlWSwgYWx0ZXJuYXRpdmUsIGssIHJhbmRvbVNvdXJjZSkge1xuICAgIC8vIFNldCBkZWZhdWx0IGFyZ3VtZW50c1xuICAgIGlmIChrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgayA9IDEwMDAwO1xuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbHRlcm5hdGl2ZSA9IFwidHdvX3NpZGVcIjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICBhbHRlcm5hdGl2ZSAhPT0gXCJ0d29fc2lkZVwiICYmXG4gICAgICAgIGFsdGVybmF0aXZlICE9PSBcImdyZWF0ZXJcIiAmJlxuICAgICAgICBhbHRlcm5hdGl2ZSAhPT0gXCJsZXNzXCJcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJgYWx0ZXJuYXRpdmVgIG11c3QgYmUgZWl0aGVyICd0d29fc2lkZScsICdncmVhdGVyJywgb3IgJ2xlc3MnLlwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG1lYW5zIGZvciBlYWNoIHNhbXBsZVxuICAgIHZhciBtZWFuWCA9IG1lYW4oc2FtcGxlWCk7XG4gICAgdmFyIG1lYW5ZID0gbWVhbihzYW1wbGVZKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBpbml0aWFsIHRlc3Qgc3RhdGlzdGljLiBUaGlzIHdpbGwgYmUgb3VyIHBvaW50IG9mIGNvbXBhcmlzb24gd2l0aFxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgdGVzdCBzdGF0aXN0aWNzLlxuICAgIHZhciB0ZXN0U3RhdGlzdGljID0gbWVhblggLSBtZWFuWTtcblxuICAgIC8vIGNyZWF0ZSB0ZXN0LXN0YXRpc3RpYyBkaXN0cmlidXRpb25cbiAgICB2YXIgdGVzdFN0YXREc24gPSBuZXcgQXJyYXkoayk7XG5cbiAgICAvLyBjb21iaW5lIGRhdHNldHMgc28gd2UgY2FuIGVhc2lseSBzaHVmZmxlIGxhdGVyXG4gICAgdmFyIGFsbERhdGEgPSBzYW1wbGVYLmNvbmNhdChzYW1wbGVZKTtcbiAgICB2YXIgbWlkSW5kZXggPSBNYXRoLmZsb29yKGFsbERhdGEubGVuZ3RoIC8gMik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAvLyAxLiBzaHVmZmxlIGRhdGEgYXNzaWdubWVudHNcbiAgICAgICAgc2h1ZmZsZUluUGxhY2UoYWxsRGF0YSwgcmFuZG9tU291cmNlKTtcbiAgICAgICAgdmFyIHBlcm1MZWZ0ID0gYWxsRGF0YS5zbGljZSgwLCBtaWRJbmRleCk7XG4gICAgICAgIHZhciBwZXJtUmlnaHQgPSBhbGxEYXRhLnNsaWNlKG1pZEluZGV4LCBhbGxEYXRhLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMi5yZS1jYWxjdWxhdGUgdGVzdCBzdGF0aXN0aWNcbiAgICAgICAgdmFyIHBlcm1UZXN0U3RhdGlzdGljID0gbWVhbihwZXJtTGVmdCkgLSBtZWFuKHBlcm1SaWdodCk7XG5cbiAgICAgICAgLy8gMy4gc3RvcmUgdGVzdCBzdGF0aXN0aWMgdG8gYnVpbGQgdGVzdCBzdGF0aXN0aWMgZGlzdHJpYnV0aW9uXG4gICAgICAgIHRlc3RTdGF0RHNuW2ldID0gcGVybVRlc3RTdGF0aXN0aWM7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHAtdmFsdWUgZGVwZW5kaW5nIG9uIGFsdGVybmF0aXZlXG4gICAgLy8gRm9yIHRoaXMgdGVzdCwgd2UgY2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIG9mICdleHRyZW1lJyB0ZXN0IHN0YXRpc3RpY3MgKHN1YmplY3QgdG8gb3VyIGh5cG90aGVzaXMpXG4gICAgLy8gbW9yZSBpbmZvIG9uIHBlcm11dGF0aW9uIHRlc3QgcC12YWx1ZSBjYWxjdWxhdGlvbnM6IGh0dHBzOi8vb25saW5lY291cnNlcy5zY2llbmNlLnBzdS5lZHUvc3RhdDQ2NC9ub2RlLzM1XG4gICAgdmFyIG51bUV4dHJlbWVUU3RhdHMgPSAwO1xuICAgIGlmIChhbHRlcm5hdGl2ZSA9PT0gXCJ0d29fc2lkZVwiKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8PSBrOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRlc3RTdGF0RHNuW2kkMV0pID49IE1hdGguYWJzKHRlc3RTdGF0aXN0aWMpKSB7XG4gICAgICAgICAgICAgICAgbnVtRXh0cmVtZVRTdGF0cyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRlcm5hdGl2ZSA9PT0gXCJncmVhdGVyXCIpIHtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDw9IGs7IGkkMisrKSB7XG4gICAgICAgICAgICBpZiAodGVzdFN0YXREc25baSQyXSA+PSB0ZXN0U3RhdGlzdGljKSB7XG4gICAgICAgICAgICAgICAgbnVtRXh0cmVtZVRTdGF0cyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWx0ZXJuYXRpdmUgPT09ICdsZXNzJ1xuICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPD0gazsgaSQzKyspIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRlc3RTdGF0RHNuW2kkM10gPD0gdGVzdFN0YXRpc3RpYykge1xuICAgICAgICAgICAgICAgIG51bUV4dHJlbWVUU3RhdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBlbmQgKi9cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1FeHRyZW1lVFN0YXRzIC8gaztcbn1cblxuLyoqXG4gKiBbU2lnbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvbikgaXMgYSBmdW5jdGlvblxuICogdGhhdCBleHRyYWN0cyB0aGUgc2lnbiBvZiBhIHJlYWwgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggaW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNpZ24gdmFsdWUgZWl0aGVyIDEsIDAgb3IgLTFcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgdGhlIGlucHV0IGFyZ3VtZW50IHggaXMgbm90IGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBzaWduKDIpOyAvLyA9PiAxXG4gKi9cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmICh4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIG51bWJlclwiKTtcbiAgICB9XG59XG5cbi8qKlxuICogW0Jpc2VjdGlvbiBtZXRob2RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jpc2VjdGlvbl9tZXRob2QpIGlzIGEgcm9vdC1maW5kaW5nXG4gKiBtZXRob2QgdGhhdCByZXBlYXRlZGx5IGJpc2VjdHMgYW4gaW50ZXJ2YWwgdG8gZmluZCB0aGUgcm9vdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBudW1lcmljYWwgYXBwcm94aW1hdGlvbiB0byB0aGUgZXhhY3QgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBpbnB1dCBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgb2YgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBlbmQgb2YgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJdGVyYXRpb25zIC0gdGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvclRvbGVyYW5jZSAtIHRoZSBlcnJvciB0b2xlcmFuY2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGVzdGltYXRlZCByb290IHZhbHVlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEFyZ3VtZW50IGZ1bmMgbXVzdCBiZSBhIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGJpc2VjdChNYXRoLmNvcywwLDQsMTAwLDAuMDAzKTsgLy8gPT4gMS41NzIyNjU2MjVcbiAqL1xuZnVuY3Rpb24gYmlzZWN0KGZ1bmMsIHN0YXJ0LCBlbmQsIG1heEl0ZXJhdGlvbnMsIGVycm9yVG9sZXJhbmNlKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZ1bmMgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZnVuYyhvdXRwdXQpID09PSAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicygoZW5kIC0gc3RhcnQpIC8gMikgPCBlcnJvclRvbGVyYW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lnbihmdW5jKG91dHB1dCkpID09PSBzaWduKGZ1bmMoc3RhcnQpKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBvdXRwdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIGV4Y2VlZGVkXCIpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsZWZ0IEZpcnN0IE4tZGltZW5zaW9uYWwgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHJpZ2h0IFNlY29uZCBOLWRpbWVuc2lvbmFsIHBvaW50LlxuICogQHJldHVybnMge251bWJlcn0gRGlzdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGV1Y2xpZGVhbkRpc3RhbmNlKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaWZmID0gbGVmdFtpXSAtIHJpZ2h0W2ldO1xuICAgICAgICBzdW0gKz0gZGlmZiAqIGRpZmY7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBrTWVhbnNSZXR1cm5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIFRoZSBsYWJlbHMuXG4gKiBAcHJvcGVydHkge0FycmF5PEFycmF5PG51bWJlcj4+fSBjZW50cm9pZHMgVGhlIGNsdXN0ZXIgY2VudHJvaWRzLlxuICovXG5cbi8qKlxuICogUGVyZm9ybSBrLW1lYW5zIGNsdXN0ZXJpbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzIHRvIGJlIGNsdXN0ZXJlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1DbHVzdGVyIEhvdyBtYW55IGNsdXN0ZXJzIHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJhbmRvbVNvdXJjZSBBbiBvcHRpb25hbCBlbnRyb3B5IHNvdXJjZSB0aGF0IGdlbmVyYXRlcyB1bmlmb3JtIHZhbHVlcyBpbiBbMCwgMSkuXG4gKiBAcmV0dXJuIHtrTWVhbnNSZXR1cm59IExhYmVscyAoc2FtZSBsZW5ndGggYXMgZGF0YSkgYW5kIGNlbnRyb2lkcyAoc2FtZSBsZW5ndGggYXMgbnVtQ2x1c3RlcikuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IGNlbnRyb2lkcyB3aW5kIHVwIGZyaWVuZGxlc3MgKGkuZS4sIHdpdGhvdXQgYXNzb2NpYXRlZCBwb2ludHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBrTWVhbnNDbHVzdGVyKFtbMC4wLCAwLjVdLCBbMS4wLCAwLjVdXSwgMik7IC8vID0+IHtsYWJlbHM6IFswLCAxXSwgY2VudHJvaWRzOiBbWzAuMCwgMC41XSwgWzEuMCAwLjVdXX1cbiAqL1xuZnVuY3Rpb24ga01lYW5zQ2x1c3Rlcihwb2ludHMsIG51bUNsdXN0ZXIsIHJhbmRvbVNvdXJjZSkge1xuICAgIGlmICggcmFuZG9tU291cmNlID09PSB2b2lkIDAgKSByYW5kb21Tb3VyY2UgPSBNYXRoLnJhbmRvbTtcblxuICAgIHZhciBvbGRDZW50cm9pZHMgPSBudWxsO1xuICAgIHZhciBuZXdDZW50cm9pZHMgPSBzYW1wbGUocG9pbnRzLCBudW1DbHVzdGVyLCByYW5kb21Tb3VyY2UpO1xuICAgIHZhciBsYWJlbHMgPSBudWxsO1xuICAgIHZhciBjaGFuZ2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHdoaWxlIChjaGFuZ2UgIT09IDApIHtcbiAgICAgICAgbGFiZWxzID0gbGFiZWxQb2ludHMocG9pbnRzLCBuZXdDZW50cm9pZHMpO1xuICAgICAgICBvbGRDZW50cm9pZHMgPSBuZXdDZW50cm9pZHM7XG4gICAgICAgIG5ld0NlbnRyb2lkcyA9IGNhbGN1bGF0ZUNlbnRyb2lkcyhwb2ludHMsIGxhYmVscywgbnVtQ2x1c3Rlcik7XG4gICAgICAgIGNoYW5nZSA9IGNhbGN1bGF0ZUNoYW5nZShuZXdDZW50cm9pZHMsIG9sZENlbnRyb2lkcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICBjZW50cm9pZHM6IG5ld0NlbnRyb2lkc1xuICAgIH07XG59XG5cbi8qKlxuICogTGFiZWwgZWFjaCBwb2ludCBhY2NvcmRpbmcgdG8gd2hpY2ggY2VudHJvaWQgaXQgaXMgY2xvc2VzdCB0by5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIEFycmF5IG9mIFhZIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY2VudHJvaWRzIEN1cnJlbnQgY2VudHJvaWRzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gR3JvdXAgbGFiZWxzLlxuICovXG5mdW5jdGlvbiBsYWJlbFBvaW50cyhwb2ludHMsIGNlbnRyb2lkcykge1xuICAgIHJldHVybiBwb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGxhYmVsID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2VudHJvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IGV1Y2xpZGVhbkRpc3RhbmNlKHAsIGNlbnRyb2lkc1tpXSk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBjZW50cm9pZHMgZm9yIHBvaW50cyBnaXZlbiBsYWJlbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBvaW50cyBBcnJheSBvZiBYWSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGFiZWxzIFdoaWNoIGdyb3VwcyBwb2ludHMgYmVsb25nIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bUNsdXN0ZXIgTnVtYmVyIG9mIGNsdXN0ZXJzIGJlaW5nIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQ2VudHJvaWQgZm9yIGVhY2ggZ3JvdXAuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IGNlbnRyb2lkcyB3aW5kIHVwIGZyaWVuZGxlc3MgKGkuZS4sIHdpdGhvdXQgYXNzb2NpYXRlZCBwb2ludHMpLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDZW50cm9pZHMocG9pbnRzLCBsYWJlbHMsIG51bUNsdXN0ZXIpIHtcbiAgICAvLyBJbml0aWFsaXplIGFjY3VtdWxhdG9ycy5cbiAgICB2YXIgZGltZW5zaW9uID0gcG9pbnRzWzBdLmxlbmd0aDtcbiAgICB2YXIgY2VudHJvaWRzID0gbWFrZU1hdHJpeChudW1DbHVzdGVyLCBkaW1lbnNpb24pO1xuICAgIHZhciBjb3VudHMgPSBBcnJheShudW1DbHVzdGVyKS5maWxsKDApO1xuXG4gICAgLy8gQWRkIHBvaW50cyB0byBjZW50cm9pZHMnIGFjY3VtdWxhdG9ycyBhbmQgY291bnQgcG9pbnRzIHBlciBjZW50cm9pZC5cbiAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICB2YXIgY3VycmVudCA9IGNlbnRyb2lkc1tsYWJlbF07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRbal0gKz0gcG9pbnRbal07XG4gICAgICAgIH1cbiAgICAgICAgY291bnRzW2xhYmVsXSArPSAxO1xuICAgIH1cblxuICAgIC8vIFJlc2NhbGUgY2VudHJvaWRzLCBjaGVja2luZyBmb3IgYW55IHRoYXQgaGF2ZSBubyBwb2ludHMuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbnVtQ2x1c3RlcjsgaSQxKyspIHtcbiAgICAgICAgaWYgKGNvdW50c1tpJDFdID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiQ2VudHJvaWQgXCIgKyBpJDEgKyBcIiBoYXMgbm8gZnJpZW5kc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRzW2kkMV07XG4gICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGRpbWVuc2lvbjsgaiQxKyspIHtcbiAgICAgICAgICAgIGNlbnRyb2lkW2okMV0gLz0gY291bnRzW2kkMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VudHJvaWRzO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9sZCBjZW50cm9pZHMgYW5kIG5ldyBjZW50cm9pZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGxlZnQgT25lIGxpc3Qgb2YgY2VudHJvaWRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcmlnaHQgQW5vdGhlciBsaXN0IG9mIGNlbnRyb2lkcy5cbiAqIEByZXR1cm4ge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiBjZW50cm9pZHMuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNoYW5nZShsZWZ0LCByaWdodCkge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsICs9IGV1Y2xpZGVhbkRpc3RhbmNlKGxlZnRbaV0sIHJpZ2h0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgW3NpbGhvdWV0dGUgdmFsdWVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWxob3VldHRlXyhjbHVzdGVyaW5nKSlcbiAqIGZvciBjbHVzdGVyZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwb2ludHMgTi1kaW1lbnNpb25hbCBjb29yZGluYXRlcyBvZiBwb2ludHMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGxhYmVscyBMYWJlbHMgb2YgcG9pbnRzLiBUaGlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIGBwb2ludHNgLFxuICogYW5kIHZhbHVlcyBtdXN0IGxpZSBpbiBbMC4uRy0xXSwgd2hlcmUgRyBpcyB0aGUgbnVtYmVyIG9mIGdyb3Vwcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzaWxob3VldHRlIHZhbHVlIGZvciBlYWNoIHBvaW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBzaWxob3VldHRlKFtbMC4yNV0sIFswLjc1XV0sIFswLCAwXSk7IC8vID0+IFsxLjAsIDEuMF1cbiAqL1xuZnVuY3Rpb24gc2lsaG91ZXR0ZShwb2ludHMsIGxhYmVscykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoICE9PSBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgaGF2ZSBleGFjdGx5IGFzIG1hbnkgbGFiZWxzIGFzIHBvaW50c1wiKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwaW5ncyA9IGNyZWF0ZUdyb3VwcyhsYWJlbHMpO1xuICAgIHZhciBkaXN0YW5jZXMgPSBjYWxjdWxhdGVBbGxEaXN0YW5jZXMocG9pbnRzKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICBpZiAoZ3JvdXBpbmdzW2xhYmVsc1tpXV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGEgPSBtZWFuRGlzdGFuY2VGcm9tUG9pbnRUb0dyb3VwKFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdzW2xhYmVsc1tpXV0sXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGIgPSBtZWFuRGlzdGFuY2VUb05lYXJlc3RHcm91cChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGxhYmVscyxcbiAgICAgICAgICAgICAgICBncm91cGluZ3MsXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcyA9IChiIC0gYSkgLyBNYXRoLm1heChhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsb29rdXAgdGFibGUgbWFwcGluZyBncm91cCBJRHMgdG8gcG9pbnQgSURzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGxhYmVscyBMYWJlbHMgb2YgcG9pbnRzLiBUaGlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIGBwb2ludHNgLFxuICogYW5kIHZhbHVlcyBtdXN0IGxpZSBpbiBbMC4uRy0xXSwgd2hlcmUgRyBpcyB0aGUgbnVtYmVyIG9mIGdyb3Vwcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBBbiBhcnJheSBvZiBsZW5ndGggRywgZWFjaCBvZiB3aG9zZSBlbnRyaWVzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSBwb2ludHMgaW4gdGhhdCBncm91cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlR3JvdXBzKGxhYmVscykge1xuICAgIHZhciBudW1Hcm91cHMgPSAxICsgbWF4KGxhYmVscyk7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KG51bUdyb3Vwcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICBpZiAocmVzdWx0W2xhYmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRbbGFiZWxdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2xhYmVsXS5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxvb2t1cCB0YWJsZSBvZiBhbGwgaW50ZXItcG9pbnQgZGlzdGFuY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwb2ludHMgTi1kaW1lbnNpb25hbCBjb29yZGluYXRlcyBvZiBwb2ludHMuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQSBzeW1tZXRyaWMgc3F1YXJlIGFycmF5IG9mIGludGVyLXBvaW50IGRpc3RhbmNlc1xuICogKHplcm8gb24gdGhlIGRpYWdvbmFsKS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQWxsRGlzdGFuY2VzKHBvaW50cykge1xuICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBtYWtlTWF0cml4KG51bVBvaW50cywgbnVtUG9pbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV1bal0gPSBldWNsaWRlYW5EaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tqXSk7XG4gICAgICAgICAgICByZXN1bHRbal1baV0gPSByZXN1bHRbaV1bal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1lYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbGwgdGhlIHBvaW50cyBpbiB0aGVcbiAqIG5lYXJlc3QgZ3JvdXAgKGFzIGRldGVybWluZWQgYnkgd2hpY2ggcG9pbnQgaW4gYW5vdGhlciBncm91cCBpcyBjbG9zZXN0KS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHdoaWNoIFRoZSBpbmRleCBvZiB0aGlzIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGdyb3VwaW5ncyBBbiBhcnJheSB3aG9zZSBlbnRyaWVzIGFyZSBhcnJheXNcbiAqIGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHBvaW50cyBpbiB0aGF0IGdyb3VwLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGlzdGFuY2VzIEEgc3ltbWV0cmljIHNxdWFyZSBhcnJheSBvZiBpbnRlci1wb2ludFxuICogZGlzdGFuY2VzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWVhbiBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgdG8gb3RoZXJzIGluIHRoZSBuZWFyZXN0XG4gKiBncm91cC5cbiAqL1xuZnVuY3Rpb24gbWVhbkRpc3RhbmNlVG9OZWFyZXN0R3JvdXAod2hpY2gsIGxhYmVscywgZ3JvdXBpbmdzLCBkaXN0YW5jZXMpIHtcbiAgICB2YXIgbGFiZWwgPSBsYWJlbHNbd2hpY2hdO1xuICAgIHZhciByZXN1bHQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGQgPSBtZWFuRGlzdGFuY2VGcm9tUG9pbnRUb0dyb3VwKFxuICAgICAgICAgICAgICAgIHdoaWNoLFxuICAgICAgICAgICAgICAgIGdyb3VwaW5nc1tpXSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZCA8IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1lYW4gZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50IGFuZCBhbGwgdGhlIHBvaW50cyBpbiBhIGdyb3VwXG4gKiAocG9zc2libHkgaXRzIG93bikuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aGljaCBUaGUgaW5kZXggb2YgdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZ3JvdXAgVGhlIGluZGljZXMgb2YgYWxsIHRoZSBwb2ludHMgaW4gdGhlIGdyb3VwIGluXG4gKiBxdWVzdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRpc3RhbmNlcyBBIHN5bW1ldHJpYyBzcXVhcmUgYXJyYXkgb2YgaW50ZXItcG9pbnRcbiAqIGRpc3RhbmNlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1lYW4gZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIG90aGVycyBpbiB0aGVcbiAqIHNwZWNpZmllZCBncm91cC5cbiAqL1xuZnVuY3Rpb24gbWVhbkRpc3RhbmNlRnJvbVBvaW50VG9Hcm91cCh3aGljaCwgZ3JvdXAsIGRpc3RhbmNlcykge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBkaXN0YW5jZXNbd2hpY2hdW2dyb3VwW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsIC8gZ3JvdXAubGVuZ3RoO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgW3NpbGhvdWV0dGUgbWV0cmljXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWxob3VldHRlXyhjbHVzdGVyaW5nKSlcbiAqIGZvciBhIHNldCBvZiBOLWRpbWVuc2lvbmFsIHBvaW50cyBhcnJhbmdlZCBpbiBncm91cHMuIFRoZSBtZXRyaWMgaXMgdGhlIGxhcmdlc3RcbiAqIGluZGl2aWR1YWwgc2lsaG91ZXR0ZSB2YWx1ZSBmb3IgdGhlIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcG9pbnRzIE4tZGltZW5zaW9uYWwgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsYWJlbHMgTGFiZWxzIG9mIHBvaW50cy4gVGhpcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBhcyBgcG9pbnRzYCxcbiAqIGFuZCB2YWx1ZXMgbXVzdCBsaWUgaW4gWzAuLkctMV0sIHdoZXJlIEcgaXMgdGhlIG51bWJlciBvZiBncm91cHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaWxob3VldHRlIG1ldHJpYyBmb3IgdGhlIGdyb3VwaW5ncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogc2lsaG91ZXR0ZU1ldHJpYyhbWzAuMjVdLCBbMC43NV1dLCBbMCwgMF0pOyAvLyA9PiAxLjBcbiAqL1xuZnVuY3Rpb24gc2lsaG91ZXR0ZU1ldHJpYyhwb2ludHMsIGxhYmVscykge1xuICAgIHZhciB2YWx1ZXMgPSBzaWxob3VldHRlKHBvaW50cywgbGFiZWxzKTtcbiAgICByZXR1cm4gbWF4KHZhbHVlcyk7XG59XG5cbi8qKlxuICogUmVsYXRpdmUgZXJyb3IuXG4gKlxuICogVGhpcyBpcyBtb3JlIGRpZmZpY3VsdCB0byBjYWxjdWxhdGUgdGhhbiBpdCBmaXJzdCBhcHBlYXJzIFsxLDJdLiAgVGhlIHVzdWFsXG4gKiBmb3JtdWxhIGZvciB0aGUgcmVsYXRpdmUgZXJyb3IgYmV0d2VlbiBhbiBhY3R1YWwgdmFsdWUgQSBhbmQgYW4gZXhwZWN0ZWRcbiAqIHZhbHVlIEUgaXMgYHwoQS1FKS9FfGAsIGJ1dDpcbiAqXG4gKiAxLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgMCwgYW55IG90aGVyIHZhbHVlIGhhcyBpbmZpbml0ZSByZWxhdGl2ZSBlcnJvcixcbiAqICAgIHdoaWNoIGlzIGNvdW50ZXItaW50dWl0aXZlOiBpZiB0aGUgZXhwZWN0ZWQgdm9sdGFnZSBpcyAwLCBnZXR0aW5nIDEvMTB0aFxuICogICAgb2YgYSB2b2x0IGRvZXNuJ3QgZmVlbCBsaWtlIGFuIGluZmluaXRlbHkgbGFyZ2UgZXJyb3IuXG4gKlxuICogMi4gVGhpcyBmb3JtdWxhIGRvZXMgbm90IHNhdGlzZnkgdGhlIG1hdGhlbWF0aWNhbCBkZWZpbml0aW9uIG9mIGEgbWV0cmljIFszXS5cbiAqICAgIFs0XSBzb2x2ZWQgdGhpcyBwcm9ibGVtIGJ5IGRlZmluaW5nIHRoZSByZWxhdGl2ZSBlcnJvciBhcyBgfGxuKHxBL0V8KXxgLFxuICogICAgYnV0IHRoYXQgZm9ybXVsYSBvbmx5IHdvcmtzIGlmIGFsbCB2YWx1ZXMgYXJlIHBvc2l0aXZlOiBmb3IgZXhhbXBsZSwgaXRcbiAqICAgIHJlcG9ydHMgdGhlIHJlbGF0aXZlIGVycm9yIG9mIC0xMCBhbmQgMTAgYXMgMC5cbiAqXG4gKiBPdXIgaW1wbGVtZW50YXRpb24gc3RpY2tzIHdpdGggY29udmVudGlvbiBhbmQgcmV0dXJuczpcbiAqXG4gKiAtIDAgaWYgdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIGFyZSBib3RoIHplcm9cbiAqIC0gSW5maW5pdHkgaWYgdGhlIGFjdHVhbCB2YWx1ZSBpcyBub24temVybyBhbmQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIHplcm9cbiAqIC0gYHwoQS1FKS9FfGAgaW4gYWxsIG90aGVyIGNhc2VzXG4gKlxuICogWzFdIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNjc3ODUyL2hvdy10by1jYWxjdWxhdGUtcmVsYXRpdmUtZXJyb3Itd2hlbi10cnVlLXZhbHVlLWlzLXplcm9cbiAqIFsyXSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZWxhdGl2ZV9jaGFuZ2VfYW5kX2RpZmZlcmVuY2VcbiAqIFszXSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXRyaWNfKG1hdGhlbWF0aWNzKSNEZWZpbml0aW9uXG4gKiBbNF0gRi5XLkouIE9sdmVyOiBcIkEgTmV3IEFwcHJvYWNoIHRvIEVycm9yIEFyaXRobWV0aWMuXCIgU0lBTSBKb3VybmFsIG9uXG4gKiAgICAgTnVtZXJpY2FsIEFuYWx5c2lzLCAxNSgyKSwgMTk3OCwgMTAuMTEzNy8wNzE1MDI0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY3R1YWwgVGhlIGFjdHVhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCBUaGUgZXhwZWN0ZWQgdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZWxhdGl2ZSBlcnJvci5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmVFcnJvcihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgLy8gVGhlc2UgbGluZXMgYXJlIGFjdHVhbGx5IGNvdmVyZWQgYnkgdGVzdHMsIGJ1dCBpdCBzZWVtc1xuICAgIC8vIGxpa2UgYzggaGFzIGEgYnVnIHRoYXQgbWFya3MgdGhlbSBhcyBub3QgY292ZXJlZC5cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAoYWN0dWFsID09PSAwICYmIGV4cGVjdGVkID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgZW5kICovXG4gICAgcmV0dXJuIE1hdGguYWJzKChhY3R1YWwgLSBleHBlY3RlZCkgLyBleHBlY3RlZCk7XG59XG5cbi8qKlxuICogQXBwcm94aW1hdGUgZXF1YWxpdHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFjdHVhbCBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkIFRoZSByZWZlcmVuY2UgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRoZSBhY2NlcHRhYmxlIHJlbGF0aXZlIGRpZmZlcmVuY2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG51bWJlcnMgYXJlIHdpdGhpbiB0b2xlcmFuY2UuXG4gKi9cbmZ1bmN0aW9uIGFwcHJveEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRvbGVyYW5jZSkge1xuICAgIGlmICggdG9sZXJhbmNlID09PSB2b2lkIDAgKSB0b2xlcmFuY2UgPSBlcHNpbG9uO1xuXG4gICAgcmV0dXJuIHJlbGF0aXZlRXJyb3IoYWN0dWFsLCBleHBlY3RlZCkgPD0gdG9sZXJhbmNlO1xufVxuXG5leHBvcnQgeyBCYXllc2lhbkNsYXNzaWZpZXIsIFBlcmNlcHRyb25Nb2RlbCwgYWRkVG9NZWFuLCBhcHByb3hFcXVhbCwgbWVhbiBhcyBhdmVyYWdlLCBtZWFuU2ltcGxlIGFzIGF2ZXJhZ2VTaW1wbGUsIEJheWVzaWFuQ2xhc3NpZmllciBhcyBiYXllc2lhbiwgYmVybm91bGxpRGlzdHJpYnV0aW9uLCBiaW5vbWlhbERpc3RyaWJ1dGlvbiwgYmlzZWN0LCBjaGlTcXVhcmVkRGlzdHJpYnV0aW9uVGFibGUsIGNoaVNxdWFyZWRHb29kbmVzc09mRml0LCBjaHVuaywgY2ttZWFucywgY29lZmZpY2llbnRPZlZhcmlhdGlvbiwgY29tYmluYXRpb25zLCBjb21iaW5hdGlvbnNSZXBsYWNlbWVudCwgY29tYmluZU1lYW5zLCBjb21iaW5lVmFyaWFuY2VzLCBjdW11bGF0aXZlU3RkTG9naXN0aWNQcm9iYWJpbGl0eSwgY3VtdWxhdGl2ZVN0ZE5vcm1hbFByb2JhYmlsaXR5LCBlcHNpbG9uLCBlcXVhbEludGVydmFsQnJlYWtzLCBlcnJvckZ1bmN0aW9uIGFzIGVyZiwgZXJyb3JGdW5jdGlvbiwgZXh0ZW50LCBleHRlbnRTb3J0ZWQsIGZhY3RvcmlhbCwgZ2FtbWEsIGdhbW1hbG4sIGdlb21ldHJpY01lYW4sIGhhcm1vbmljTWVhbiwgaW50ZXJxdWFydGlsZVJhbmdlLCBpbnZlcnNlRXJyb3JGdW5jdGlvbiwgaW50ZXJxdWFydGlsZVJhbmdlIGFzIGlxciwgamVua3MsIGtNZWFuc0NsdXN0ZXIsIGtlcm5lbERlbnNpdHlFc3RpbWF0aW9uIGFzIGtkZSwga2VybmVsRGVuc2l0eUVzdGltYXRpb24sIGxpbmVhclJlZ3Jlc3Npb24sIGxpbmVhclJlZ3Jlc3Npb25MaW5lLCBsb2dBdmVyYWdlLCBsb2dpdCwgbWVkaWFuQWJzb2x1dGVEZXZpYXRpb24gYXMgbWFkLCBtYXgsIG1heFNvcnRlZCwgbWVhbiwgbWVhblNpbXBsZSwgbWVkaWFuLCBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbiwgbWVkaWFuU29ydGVkLCBtaW4sIG1pblNvcnRlZCwgbW9kZSwgbW9kZUZhc3QsIG1vZGVTb3J0ZWQsIG51bWVyaWNTb3J0LCBQZXJjZXB0cm9uTW9kZWwgYXMgcGVyY2VwdHJvbiwgcGVybXV0YXRpb25UZXN0LCBwZXJtdXRhdGlvbnNIZWFwLCBwb2lzc29uRGlzdHJpYnV0aW9uLCBwcm9iaXQsIHByb2R1Y3QsIHF1YW50aWxlLCBxdWFudGlsZVJhbmssIHF1YW50aWxlUmFua1NvcnRlZCwgcXVhbnRpbGVTb3J0ZWQsIHF1aWNrc2VsZWN0LCByU3F1YXJlZCwgcmVsYXRpdmVFcnJvciwgcm9vdE1lYW5TcXVhcmUgYXMgcm1zLCByb290TWVhblNxdWFyZSwgc2FtcGxlLCBzYW1wbGVDb3JyZWxhdGlvbiwgc2FtcGxlQ292YXJpYW5jZSwgc2FtcGxlS3VydG9zaXMsIHNhbXBsZVJhbmtDb3JyZWxhdGlvbiwgc2FtcGxlU2tld25lc3MsIHNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uLCBzYW1wbGVWYXJpYW5jZSwgc2FtcGxlV2l0aFJlcGxhY2VtZW50LCBzaHVmZmxlLCBzaHVmZmxlSW5QbGFjZSwgc2lnbiwgc2lsaG91ZXR0ZSwgc2lsaG91ZXR0ZU1ldHJpYywgc3RhbmRhcmREZXZpYXRpb24sIHN0YW5kYXJkTm9ybWFsVGFibGUsIHN1YnRyYWN0RnJvbU1lYW4sIHN1bSwgc3VtTnRoUG93ZXJEZXZpYXRpb25zLCBzdW1TaW1wbGUsIHRUZXN0LCB0VGVzdFR3b1NhbXBsZSwgdW5pcXVlQ291bnRTb3J0ZWQsIHZhcmlhbmNlLCB3aWxjb3hvblJhbmtTdW0sIHpTY29yZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxlLXN0YXRpc3RpY3MubWpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubmMgPSB1bmRlZmluZWQ7IiwiaW1wb3J0ICcuL2Nzcy9pbmRleC5jc3MnXHJcbmV4cG9ydCAqIGZyb20gJy4vZXVyb3N0YXQtbWFwJ1xyXG4vL2V4cG9ydCB7IHN0YXREYXRhIH0gZnJvbSBcIi4vY29yZS9zdGF0LWRhdGEuanNcIjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9