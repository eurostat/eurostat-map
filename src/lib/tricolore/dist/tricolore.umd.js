/**
 * Tricolore
 * Copyright (C) 2025 Matthieu Viry
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("d3")):"function"==typeof define&&define.amd?define(["exports","d3"],r):r((t="undefined"!=typeof globalThis?globalThis:t||self).tricolore={},t.d3)}(this,function(t,r){"use strict";class e{static geometricMean(t,r=!0){const e=r?t.filter(t=>0!==t):t;return 0===e.length?0:Math.exp(e.reduce((t,r)=>t+Math.log(r),0)/e.length)}static centre(t){const r=this.geometricMean(t.map(t=>t[0])),e=this.geometricMean(t.map(t=>t[1])),a=this.geometricMean(t.map(t=>t[2])),n=r+e+a;return[r/n,e/n,a/n]}static perturbe(t,r=[1/3,1/3,1/3]){return t.map(t=>{if(!t)return null;const e=[t[0]*r[0],t[1]*r[1],t[2]*r[2]],a=e.reduce((t,r)=>t+r,0);return[e[0]/a,e[1]/a,e[2]/a]})}static powerScale(t,r=1){return t.map(t=>{if(!t)return null;const e=[Math.pow(t[0],r),Math.pow(t[1],r),Math.pow(t[2],r)],a=e.reduce((t,r)=>t+r,0);return[e[0]/a,e[1]/a,e[2]/a]})}static close(t){return t.map(t=>{if(!this.isValidTernary(t))return null;const r=t[0]+t[1]+t[2];return[t[0]/r,t[1]/r,t[2]/r]})}static validateTernaryPoints(t){for(let r=0;r<t.length;r++){const e=t[r];if(!e)continue;if(3!==e.length)throw new Error(`Ternary point must have exactly 3 components, got ${e.length}`);if(e.some(t=>t<0))throw new Error(`Ternary point contains negative values: [${e}]`);const a=e[0]+e[1]+e[2];if(Math.abs(a-1)>1e-9)throw new Error(`Ternary point components must sum to 1, got ${a}: [${e}]`)}}static isValidTernary(t){return Array.isArray(t)&&3===t.length&&t.every(t=>"number"==typeof t&&!Number.isNaN(t))}}class a{static ternaryMeshCentroids(t){const r=t*t,e=[];for(let a=1;a<=r;a++){const n=Math.floor(Math.sqrt(r-a)),o=n*n,s=((-r+a+n*(n+2)+1)%2-3*o-3*a+3*r+1)/(6*t),i=-((-r+o+a+2*n+1)%2+3*n-3*t+1)/(3*t),c=((-r+o+a+2*n+1)%2+3*o+6*n+3*a-3*r+1)/(6*t);e.push({id:a,p1:s,p2:i,p3:c})}return e}static ternaryMeshVertices(t){const r=Math.sqrt(t.length),e=[];return t.forEach(t=>{const a=r-Math.floor(Math.sqrt(r*r-t.id)),n=t.id-(a-1)*(2*r-a+1),o=2*Math.pow(-1,n%2)/(3*r),s=Math.pow(-1,n%2)/(3*r);e.push({id:t.id,vertex:1,p1:t.p1-o,p2:t.p2+s,p3:t.p3+s}),e.push({id:t.id,vertex:2,p1:t.p1+s,p2:t.p2-o,p3:t.p3+s}),e.push({id:t.id,vertex:3,p1:t.p1+s,p2:t.p2+s,p3:t.p3-o})}),e}static ternaryDistance(t,r){return r.map(r=>{const e=t[0]-r[0],a=t[1]-r[1],n=t[2]-r[2];return-(a*n+n*e+e*a)})}static ternaryNearest(t,r){return t.map(t=>{if(!t)return null;const e=this.ternaryDistance(t,r),a=e.indexOf(Math.min(...e));return r[a]})}static ternarySextantVertices(t){const r=[],e=[t[0],1-t[0],0],a=[t[0],0,1-t[0]],n=[0,t[1],1-t[1]],o=[1-t[1],t[1],0],s=[1-t[2],0,t[2]],i=[0,1-t[2],t[2]],c=[[t,s,[1,0,0],o,t],[t,o,e,t],[t,e,[0,1,0],i,t],[t,i,n,t],[t,n,[0,0,1],a,t],[t,a,s,t]];for(let t=1;t<=6;t++){const e=c[t-1];for(let a=0;a<e.length;a++)r.push({id:t,vertex:a+1,p1:e[a][0],p2:e[a][1],p3:e[a][2]})}return r}static ternarySurroundingSextant(t,r){return t.map(t=>{if(!t)return null;const e=[t[0]>r[0],t[1]>r[1],t[2]>r[2]];return!e[0]||e[1]||e[2]?e[0]&&e[1]&&!e[2]?2:e[0]||!e[1]||e[2]?!e[0]&&e[1]&&e[2]?4:e[0]||e[1]||!e[2]?e[0]&&!e[1]&&e[2]?6:null:5:3:1})}static ternaryToCartesian(t){return[.5*(2*t[2]+t[1]),Math.sqrt(3)/2*t[1]]}static cartesianToTernary(t,r){const e=2*r/Math.sqrt(3),a=t-e/2;return[1-e-a,e,a]}static ternaryLimits(t){const r=[1,1,1],e=[0,0,0];return t.forEach(t=>{r[0]=Math.min(r[0],t[0]),r[1]=Math.min(r[1],t[1]),r[2]=Math.min(r[2],t[2]),e[0]=Math.max(e[0],t[0]),e[1]=Math.max(e[1],t[1]),e[2]=Math.max(e[2],t[2])}),{lower:r,upper:e}}}class n{static colorMapTricolore(t,r=[1/3,1/3,1/3],n=4,o=80,s=140,i=80,c=.4,h=1){const l=e.close([...t]);let p=e.close([...t]);if(Number.isFinite(n)&&n<100){const t=a.ternaryMeshCentroids(n).map(t=>[t.p1,t.p2,t.p3]);p=a.ternaryNearest(p,t)}const d=e.perturbe(p,[1/r[0],1/r[1],1/r[2]]);return e.powerScale(d,h).map((r,e)=>{if(!r)return{p1:t[e][0],p2:t[e][1],p3:t[e][2],h:null,c:null,l:null,rgb:null};const a=r.map(t=>t*s),n=[o,o+120,o+240].map(t=>t*Math.PI/180),h=n.map((t,r)=>({re:a[r]*Math.cos(t),im:a[r]*Math.sin(t)})).reduce((t,r)=>({re:t.re+r.re,im:t.im+r.im}),{re:0,im:0}),p=(180*Math.atan2(h.im,h.re)/Math.PI+360)%360,d=Math.sqrt(h.re*h.re+h.im*h.im),g=d*c/s+1-c,u=g*i,m=g*d,y=this.hclToHex(p,m,u);return{p1:l[e][0],p2:l[e][1],p3:l[e][2],h:p,c:m,l:u,rgb:y}})}static colorMapSextant(t,r=[1/3,1/3,1/3],n=["#FFFF00","#B3DCC3","#01A0C6","#B8B3D8","#F11D8C","#FFB3B3"]){if(6!==n.length)throw new Error("Sextant values array must have exactly 6 elements");const o=e.close([...t]),s=a.ternarySurroundingSextant(o,r);return o.map((r,e)=>{if(!r)return{p1:t[e][0],p2:t[e][1],p3:t[e][2],sextant:null,rgb:null};const a=s[e],o=null!==a?n[a-1]:null;return{p1:r[0],p2:r[1],p3:r[2],sextant:a,rgb:o}})}static hclToHex(t,r,e){(t%=360)<0&&(t+=360),r=Math.max(0,Math.min(r,230)),e=Math.max(0,Math.min(e,100));const a=t*Math.PI/180,n=(e+16)/116,o=Math.cos(a)*r/500+n,s=n-Math.sin(a)*r/200,i=.95047*(o>.206893034?o**3:(o-16/116)/7.787),c=1*(n>.206893034?n**3:(n-16/116)/7.787),h=1.08883*(s>.206893034?s**3:(s-16/116)/7.787);let l=3.2406*i-1.5372*c-.4986*h,p=-.9689*i+1.8758*c+.0415*h,d=.0557*i-.204*c+1.057*h;const g=t=>t>.0031308?1.055*t**(1/2.4)-.055:12.92*t;l=g(l),p=g(p),d=g(d);const u=t=>Math.round(255*(t=>Math.max(0,Math.min(1,t)))(t)),m=t=>{const r=u(t).toString(16);return 1===r.length?"0"+r:r};return`#${m(l)}${m(p)}${m(d)}`}}t.ColorMapping=n,t.CompositionUtils=e,t.TernaryGeometry=a,t.TricoloreViz=class{constructor(t,e=650,a=520,n={top:20,right:60,bottom:50,left:60}){if(this.canvas=null,this.ctx=null,"object"!=typeof r||"function"!=typeof r.select)throw new Error('D3.js is required for visualization. Please install it with "npm install d3" or include it in your HTML.');this.container=r.select(t),this.width=e,this.height=a,this.margin=n,this.svg=this.container.append("svg").attr("width",e).attr("height",a),this.triangle=this.svg.append("g").attr("transform",`translate(${n.left},${n.top})`),this.legend=this.svg.append("g").attr("transform",`translate(${n.left},${n.top})`),this.circles=this.svg.append("g").attr("transform",`translate(${n.left},${n.top})`)}createContinuousPlot(t=[],e={}){const{center:a=[1/3,1/3,1/3],hue:n=80,chroma:o=140,lightness:s=80,contrast:i=.4,spread:c=1,showData:h=!0,showCenter:l=!0,showLines:p=!0,labels:d=["p₁","p₂","p₃"],labelPosition:g="corner"}=e,u=this.width-this.margin.left-this.margin.right,m=this.height-this.margin.top-this.margin.bottom,y=Math.min(u,m);this.canvas&&r.select(this.canvas).remove(),this.triangle.selectAll("*").remove(),this.legend.selectAll("*").remove(),this.circles.selectAll("*").remove(),this.canvas=document.createElement("canvas"),this.canvas.width=y,this.canvas.height=y,this.ctx=this.canvas.getContext("2d"),this.ctx&&(this.drawContinuousTriangle(y,a,n,o,s,i,c),this.triangle.append("image").attr("x",0).attr("y",0).attr("width",y).attr("height",y).attr("href",this.canvas.toDataURL()),this.drawTriangleFrame(y,d,a,l,p,g),h&&t.length>0&&this.addDataPoints(t,y))}createDiscretePlot(t=[],e={}){const{center:o=[1/3,1/3,1/3],breaks:s=4,hue:i=80,chroma:c=140,lightness:h=80,contrast:l=.4,spread:p=1,showData:d=!0,showCenter:g=!0,showLines:u=!0,labels:m=["p₁","p₂","p₃"],labelPosition:y="corner"}=e,f=this.width-this.margin.left-this.margin.right,x=this.height-this.margin.top-this.margin.bottom,v=Math.min(f,x);this.triangle.selectAll("*").remove(),this.legend.selectAll("*").remove(),this.circles.selectAll("*").remove();const M=a.ternaryMeshCentroids(s),T=a.ternaryMeshVertices(M),C=M.map(t=>[t.p1,t.p2,t.p3]),w=n.colorMapTricolore(C,o,100,i,c,h,l,p);r.group(T,t=>t.id).forEach((t,r)=>{const e=t.map(t=>{const[r,e]=this.ternaryToSvgCoords([t.p1,t.p2,t.p3],v);return`${r},${e}`}).join(" "),a=w[Number(r)-1].rgb;this.triangle.append("polygon").attr("points",e).attr("fill",a).attr("stroke","none")}),this.drawTriangleFrame(v,m,o,g,u,y),d&&t.length>0&&this.addDataPoints(t,v)}createSextantPlot(t=[],e={}){const{center:n=[1/3,1/3,1/3],values:o=["#FFFF00","#B3DCC3","#01A0C6","#B8B3D8","#F11D8C","#FFB3B3"],showData:s=!0,showCenter:i=!0,showLines:c=!0,labels:h=["p₁","p₂","p₃"],labelPosition:l="corner"}=e;if(6!==o.length)throw new Error("Sextant plot requires exactly 6 color values");const p=this.width-this.margin.left-this.margin.right,d=this.height-this.margin.top-this.margin.bottom,g=Math.min(p,d);this.triangle.selectAll("*").remove(),this.legend.selectAll("*").remove(),this.circles.selectAll("*").remove();const u=a.ternarySextantVertices(n);r.group(u,t=>t.id).forEach((t,r)=>{t.sort((t,r)=>t.vertex-r.vertex);const e=t.map(t=>{const[r,e]=this.ternaryToSvgCoords([t.p1,t.p2,t.p3],g);return`${r},${e}`}).join(" "),a=Number(r)-1;this.triangle.append("polygon").attr("points",e).attr("fill",o[a]).attr("stroke","none")}),this.drawTriangleFrame(g,h,n,i,c,l),s&&t.length>0&&this.addDataPoints(t,g)}drawContinuousTriangle(t,r,e,a,o,s,i){if(!this.ctx)return;const c=t,h=this.ctx.createImageData(c,c);for(let t=0;t<c;t++)for(let l=0;l<c;l++){const[p,d,g]=this.svgToTernaryCoords([l,t],c);if(p<0||d<0||g<0||p>1||d>1||g>1)continue;const u=n.colorMapTricolore([[p,d,g]],r,100,e,a,o,s,i)[0],m=parseInt(u.rgb.slice(1,3),16),y=parseInt(u.rgb.slice(3,5),16),f=parseInt(u.rgb.slice(5,7),16),x=4*(t*c+l);h.data[x]=m,h.data[x+1]=y,h.data[x+2]=f,h.data[x+3]=255}this.ctx.putImageData(h,0,0)}drawTriangleFrame(t,r,e,a,n,o="corner"){const s=[[1,0,0],[0,1,0],[0,0,1]].map(r=>this.ternaryToSvgCoords(r,t)),i=s.map(t=>t.join(",")).join(" ");if(this.triangle.append("polygon").attr("points",i).attr("fill","none").attr("stroke","black").attr("stroke-width",1),"edge"===o){const t=[[(s[0][0]+s[1][0])/2-35,(s[0][1]+s[1][1])/2-14],[(s[1][0]+s[2][0])/2+35,(s[1][1]+s[2][1])/2-14],[(s[0][0]+s[2][0])/2,(s[0][1]+s[2][1])/2+25]],e=[-60,60,0];r.forEach((r,a)=>{this.legend.append("text").attr("x",t[a][0]).attr("y",t[a][1]).attr("text-anchor","middle").attr("dominant-baseline","middle").attr("transform",`rotate(${e[a]},${t[a][0]},${t[a][1]})`).text(r)})}else{const t=[[s[0][0],s[0][1]+25],[s[1][0],s[1][1]-15],[s[2][0],s[2][1]+25]];r.forEach((r,e)=>{this.legend.append("text").attr("x",t[e][0]).attr("y",t[e][1]).attr("text-anchor","middle").text(r)})}const c=[.25,.5,.75];if(n&&(c.forEach(r=>{const e=[this.ternaryToSvgCoords([r,0,1-r],t),this.ternaryToSvgCoords([r,1-r,0],t)];this.legend.append("line").attr("x1",e[0][0]).attr("y1",e[0][1]).attr("x2",e[1][0]).attr("y2",e[1][1]).attr("stroke","#aaa").attr("stroke-width",.5).attr("opacity",.7)}),c.forEach(r=>{const e=[this.ternaryToSvgCoords([0,r,1-r],t),this.ternaryToSvgCoords([1-r,r,0],t)];this.legend.append("line").attr("x1",e[0][0]).attr("y1",e[0][1]).attr("x2",e[1][0]).attr("y2",e[1][1]).attr("stroke","#aaa").attr("stroke-width",.5).attr("opacity",.7)}),c.forEach(r=>{const e=[this.ternaryToSvgCoords([1-r,0,r],t),this.ternaryToSvgCoords([0,1-r,r],t)];this.legend.append("line").attr("x1",e[0][0]).attr("y1",e[0][1]).attr("x2",e[1][0]).attr("y2",e[1][1]).attr("stroke","#aaa").attr("stroke-width",.5).attr("opacity",.7)})),a){const[r,a]=this.ternaryToSvgCoords(e,t);this.triangle.append("circle").attr("cx",r).attr("cy",a).attr("r",3).attr("fill","black").attr("stroke","white");[[this.ternaryToSvgCoords([e[0],0,1-e[0]],t),this.ternaryToSvgCoords([e[0],1-e[0],0],t)],[this.ternaryToSvgCoords([0,e[1],1-e[1]],t),this.ternaryToSvgCoords([1-e[1],e[1],0],t)],[this.ternaryToSvgCoords([0,1-e[2],e[2]],t),this.ternaryToSvgCoords([1-e[2],0,e[2]],t)]].forEach(t=>{this.triangle.append("line").attr("x1",t[0][0]).attr("y1",t[0][1]).attr("x2",t[1][0]).attr("y2",t[1][1]).attr("stroke","black").attr("stroke-width",.5).attr("opacity",.5)})}c.forEach(r=>{const e=[this.ternaryToSvgCoords([r,1-r,0],t),this.ternaryToSvgCoords([r,0,1-r],t)];this.legend.append("text").attr("x",e[0][0]-5).attr("y",e[0][1]).attr("text-anchor","end").attr("font-size","10px").text(100*r+"%")}),c.forEach(r=>{const e=[this.ternaryToSvgCoords([0,r,1-r],t),this.ternaryToSvgCoords([1-r,r,0],t)];this.legend.append("text").attr("x",e[0][0]+5).attr("y",e[0][1]).attr("text-anchor","start").attr("font-size","10px").text(100*r+"%")}),c.forEach(r=>{const e=[this.ternaryToSvgCoords([1-r,0,r],t),this.ternaryToSvgCoords([0,1-r,r],t)];this.legend.append("text").attr("x",e[0][0]).attr("y",e[0][1]+10).attr("text-anchor","middle").attr("font-size","10px").text(100*r+"%")})}addDataPoints(t,r){const a=e.close([...t]);e.validateTernaryPoints(a),a.forEach((t,e)=>{if(t){const[a,n]=this.ternaryToSvgCoords(t,r);this.circles.append("circle").datum({point:t,id:e}).attr("cx",a).attr("cy",n).attr("r",2).attr("fill","black").attr("opacity",.5)}})}ternaryToSvgCoords(t,r){const[e,n]=a.ternaryToCartesian(t);return[e*r,r-n*r]}svgToTernaryCoords(t,r){return a.cartesianToTernary(t[0]/r,1-t[1]/r)}},t.tricolore=function(t,r={}){const{center:e=[1/3,1/3,1/3],breaks:a=4,hue:o=80,chroma:s=140,lightness:i=80,contrast:c=.4,spread:h=1}=r;return n.colorMapTricolore(t,e,a,o,s,i,c,h).map(t=>t.rgb)},t.tricoloreDetailed=function(t,r={}){const{center:e=[1/3,1/3,1/3],breaks:a=4,hue:o=80,chroma:s=140,lightness:i=80,contrast:c=.4,spread:h=1}=r;return n.colorMapTricolore(t,e,a,o,s,i,c,h)},t.tricoloreSextant=function(t,r={}){const{center:e=[1/3,1/3,1/3],values:a=["#FFFF00","#B3DCC3","#01A0C6","#B8B3D8","#F11D8C","#FFB3B3"]}=r;return n.colorMapSextant(t,e,a).map(t=>t.rgb)},t.tricoloreSextantDetailed=function(t,r={}){const{center:e=[1/3,1/3,1/3],values:a=["#FFFF00","#B3DCC3","#01A0C6","#B8B3D8","#F11D8C","#FFB3B3"]}=r;return n.colorMapSextant(t,e,a)}});
//# sourceMappingURL=tricolore.umd.js.map
